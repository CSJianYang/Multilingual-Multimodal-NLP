[
    {
        "title": "Best Time to Buy and Sell Stock",
        "question_content": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n&nbsp;\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= prices.length <= 105\n\t0 <= prices[i] <= 104",
        "solutions": [
            {
                "id": 1735550,
                "title": "python-javascript-easy-solution-with-very-clear-explanation",
                "content": "**The question is saying us to find the best day to buy and sell stock, so we will get maiximum profit.**\\n\\n**Some body might think that we can find min and max number from the array so that we can get the max profit. But here is one catch\\nFor Example:\\nprices=[3,4,1,6]\\nmin=1\\nmax=6\\nprofit=max-min=5 which is correct\\nin this Example:\\n```\\nprices = [7,6,4,3,1]\\n```\\nmin = 1 price at day 6\\nmax = 7 price at day 1\\nmax_profit = 7-1 = 6 u can think like this but you can\\'t buy the stock at day 6 and sell it at day 1.**\\n\\n---\\n\\n**So what is the best way to find the max profit lets see \\uD83D\\uDE03\\n<ins>Explanation:</ins>\\nlet use initialize Left and Right pointer to first and second position of array\\nHere Left is to buy stock and Right is to sell stock**\\n\\n\\n`   Then we initialize our max_profit as 0.    `\\n\\n#### Now we will start our while loop and we will run till our \\n\\n**Right pointer less then length of array \\n<ins>For Example: </ins>\\nprices=[7,1,5,3,6,4]\\nNote:\\nprices[left] --> buy stock\\nprices[right] --> sell stock\\nnow we will check price at right and left pointer**\\n\\n\\n**step 1:** <br>\\nprice[left]=7 price[right]=1 profit=-6\\nhere price[left] is greater than price[right] so we will move left pointer to the right position and increment our right pointer by 1. We always want our left point to be minimum\\n\\n**step 2:** <br>\\nprice[left]=1 price[right]=5 profit=4\\nhere price[left] is less than price[right] which means we will get profit so we will update our max_profit and move our right pointer alone\\n\\n**step 3:** <br>\\nprice[left]=1 price[right]=3 profit=2\\nhere price[left] is less than price[right] which means we will get profit so we will check our max_profit previously it\\n\\nwas 4 now our current profit is 2 so we will check which is maximum and update our max_profit and move our right pointer alone\\n\\n**step 4:** <br>\\nprice[left]=1 price[right]=6 profit=5\\nhere price[left] is less than price[right] which means we will get profit so we will check our max_profit previously it was 4 now our current profit is 5 so we will check which is maximum and update our max_profit and move our right pointer alone\\n\\n**step 5:** <br>\\nprice[left]=1 price[right]=4 profit=3\\nsame logic as above\\n\\n\\n```\\nBig O :\\nn--> length of array\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```\\n\\n**My Hand Writting will not be good ,please adjust it \\uD83D\\uDE05**\\n\\n![image](https://assets.leetcode.com/users/images/c0c86dc7-f7fa-4be7-85f9-61e629aa67ae_1643686591.6894035.jpeg)\\n\\n\\n## lets go to the solution:\\n\\npython:\\n```python []\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left = 0 #Buy\\n        right = 1 #Sell\\n        max_profit = 0\\n        while right < len(prices):\\n            currentProfit = prices[right] - prices[left] #our current Profit\\n            if prices[left] < prices[right]:\\n                max_profit =max(currentProfit,max_profit)\\n            else:\\n                left = right\\n            right += 1\\n        return max_profit\\n```\\n\\njavascript:\\n```javascript []\\nconst maxProfit = (prices) => {\\n  let left = 0; // Buy\\n  let right = 1; // sell\\n  let max_profit = 0;\\n  while (right < prices.length) {\\n    if (prices[left] < prices[right]) {\\n      let profit = prices[right] - prices[left]; // our current profit\\n\\n      max_profit = Math.max(max_profit, profit);\\n    } else {\\n      left = right;\\n    }\\n    right++;\\n  }\\n  return max_profit;\\n};\\n```\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.`\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nprices = [7,6,4,3,1]\\n```\n```\\nBig O :\\nn--> length of array\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left = 0 #Buy\\n        right = 1 #Sell\\n        max_profit = 0\\n        while right < len(prices):\\n            currentProfit = prices[right] - prices[left] #our current Profit\\n            if prices[left] < prices[right]:\\n                max_profit =max(currentProfit,max_profit)\\n            else:\\n                left = right\\n            right += 1\\n        return max_profit\\n```\n```javascript []\\nconst maxProfit = (prices) => {\\n  let left = 0; // Buy\\n  let right = 1; // sell\\n  let max_profit = 0;\\n  while (right < prices.length) {\\n    if (prices[left] < prices[right]) {\\n      let profit = prices[right] - prices[left]; // our current profit\\n\\n      max_profit = Math.max(max_profit, profit);\\n    } else {\\n      left = right;\\n    }\\n    right++;\\n  }\\n  return max_profit;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735493,
                "title": "java-c-best-ever-explanation-could-possible",
                "content": "Let\\'s understand this problem by an **imagination**. **Imagine** you have given a **time machine**, you can go to **past** to **buy** the **stock** of your choice when the price is very least. And again using that **time machine** you went into **future** to **sell** the **stock**.\\n\\n![image](https://assets.leetcode.com/users/images/21002ba2-d686-4465-8486-38e3ccd4a063_1643683166.0503008.png)\\n\\nBy doing that you have achieve **maximum profit**. From `buying at very least price and selling at very higher price`. **And you have become rich now!**\\n\\n![image](https://assets.leetcode.com/users/images/2950d9ce-0000-49dd-8270-cdfbf8a7a6af_1643683545.5999126.png)\\n\\nNow let\\'s just understand it with our given example,\\n**Input**: prices = [7,1,5,3,6,4]\\n**Output**: 5\\n\\n![image](https://assets.leetcode.com/users/images/ca7614a0-a717-48c1-a4ba-7fba42046941_1643684561.8969386.png)\\n\\n`Remember one rule :- You can only buy one time & sell one time`\\n\\n* So, if **buy at 7** & **sell at any time in the future**, we\\'ll face loss. Because **buying price** is way **higher** then **selling price** available we have\\n* Now, I have seen a dip & I **buy at 1** & **sell at 5** my **overall profit** will be **5 - 1 = 4**\\n\\n* But what if, I had **buy at 1** & **sell at 6** my profit will be **6 - 1 = 5**. Which is **greater then my overall profit**. So, i will **update** my **overall profit** with new value.\\n* Now we have done as further we don\\'t have any higher point to sell. We will **return our answer.**\\n\\n**I hope now question, approach is absolute clear.**\\n\\n*code each line explained :* `Similar for C++, Java`\\n\\n```\\n{\\n        int lsf = Integer.MAX_VALUE; // least so far\\n        int op = 0; // overall profit\\n        int pist = 0; // profit if sold today\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){ // if we found new buy value which is more smaller then previous one\\n                lsf = prices[i]; // update our least so far\\n            }\\n            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell\\n            if(op < pist){ // if pist is more then our previous overall profit\\n                op = pist; // update overall profit\\n            }\\n        }\\n        return op; // return op \\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int lsf = INT_MAX;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.size(); i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n{\\n        int lsf = Integer.MAX_VALUE; // least so far\\n        int op = 0; // overall profit\\n        int pist = 0; // profit if sold today\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){ // if we found new buy value which is more smaller then previous one\\n                lsf = prices[i]; // update our least so far\\n            }\\n            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell\\n            if(op < pist){ // if pist is more then our previous overall profit\\n                op = pist; // update overall profit\\n            }\\n        }\\n        return op; // return op \\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int lsf = INT_MAX;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.size(); i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39038,
                "title": "kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input",
                "content": "The logic to solve this problem is same as \"max subarray problem\" using `Kadane's Algorithm`. Since no body has mentioned this so far, I thought it's a good thing for everybody to know. \\n\\nAll the straight forward solution should work, but if the interviewer twists the question slightly by giving the ***difference array of prices***, Ex: for `{1, 7, 4, 11}`, if he gives `{0, 6, -3, 7}`, you might end up being confused. \\n\\nHere, the logic is to calculate the difference (`maxCur += prices[i] - prices[i-1]`) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero.\\n\\n\\n        public int maxProfit(int[] prices) {\\n            int maxCur = 0, maxSoFar = 0;\\n            for(int i = 1; i < prices.length; i++) {\\n                maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\\n                maxSoFar = Math.max(maxCur, maxSoFar);\\n            }\\n            return maxSoFar;\\n        }\\n\\n*`maxCur = current maximum value`\\n\\n*`maxSoFar = maximum value found so far`",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The logic to solve this problem is same as \"max subarray problem\" using `Kadane's Algorithm`. Since no body has mentioned this so far, I thought it's a good thing for everybody to know. \\n\\nAll the straight forward solution should work, but if the interviewer twists the question slightly by giving the ***difference array of prices***, Ex: for `{1, 7, 4, 11}`, if he gives `{0, 6, -3, 7}`, you might end up being confused. \\n\\nHere, the logic is to calculate the difference (`maxCur += prices[i] - prices[i-1]`) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero.\\n\\n\\n        public int maxProfit(int[] prices) {\\n            int maxCur = 0, maxSoFar = 0;\\n            for(int i = 1; i < prices.length; i++) {\\n                maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]);\\n                maxSoFar = Math.max(maxCur, maxSoFar);\\n            }\\n            return maxSoFar;\\n        }\\n\\n*`maxCur = current maximum value`\\n\\n*`maxSoFar = maximum value found so far`",
                "codeTag": "Unknown"
            },
            {
                "id": 39039,
                "title": "sharing-my-simple-and-clear-c-solution",
                "content": "    int maxProfit(vector<int> &prices) {\\n        int maxPro = 0;\\n        int minPrice = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++){\\n            minPrice = min(minPrice, prices[i]);\\n            maxPro = max(maxPro, prices[i] - minPrice);\\n        }\\n        return maxPro;\\n    }\\n\\nminPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. \\n\\nHow to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice.",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "    int maxProfit(vector<int> &prices) {\\n        int maxPro = 0;\\n        int minPrice = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++){\\n            minPrice = min(minPrice, prices[i]);\\n            maxPro = max(maxPro, prices[i] - minPrice);\\n        }\\n        return maxPro;\\n    }\\n\\nminPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. \\n\\nHow to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice.",
                "codeTag": "Unknown"
            },
            {
                "id": 39049,
                "title": "easy-o-n-python-solution",
                "content": "    def maxProfit(prices):\\n        max_profit, min_price = 0, float('inf')\\n        for price in prices:\\n            min_price = min(min_price, price)\\n            profit = price - min_price\\n            max_profit = max(max_profit, profit)\\n        return max_profit",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def maxProfit(prices):\\n        max_profit, min_price = 0, float('inf')\\n        for price in prices:\\n            min_price = min(min_price, price)\\n            profit = price - min_price\\n            max_profit = max(max_profit, profit)\\n        return max_profit",
                "codeTag": "Python3"
            },
            {
                "id": 3169837,
                "title": "best-c-3-solution-dp-space-optimization-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Three approach.\\n\\n1. Solved using Array(Two Nested Loop). Brute Force Approach.\\n2. Solved using Dynamic Programming Approach (tabulation).\\n3. Solved using Dynamic Programming Approach(Space optimization).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the Array(prices). As we check for possible pair, and the\\n    total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(), maxProfit = 0;\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(prices[j] - prices[i] > maxProfit){\\n                    maxProfit = prices[j] - prices[i];\\n                }\\n            }\\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\\n\\n    Space complexity : O(N), Array(maxPrices) space.\\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> maxPrices(n, 0);\\n        maxPrices[n-1] = prices[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            maxPrices[i] = max(maxPrices[i+1], prices[i]); \\n        }\\n        int maxProfit = 0;\\n        for(int i=0; i<n; i++){\\n            maxProfit = max(maxProfit, maxPrices[i] - prices[i]); \\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Dynamic Programming Approach(Space optimisation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int buyAtPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<n; i++){\\n            buyAtPrice = min(buyAtPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - buyAtPrice); \\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n```\\n*IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.*\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the Array(prices). As we check for possible pair, and the\\n    total number of pairs are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size(), maxProfit = 0;\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(prices[j] - prices[i] > maxProfit){\\n                    maxProfit = prices[j] - prices[i];\\n                }\\n            }\\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\\n\\n    Space complexity : O(N), Array(maxPrices) space.\\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<int> maxPrices(n, 0);\\n        maxPrices[n-1] = prices[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            maxPrices[i] = max(maxPrices[i+1], prices[i]); \\n        }\\n        int maxProfit = 0;\\n        for(int i=0; i<n; i++){\\n            maxProfit = max(maxProfit, maxPrices[i] - prices[i]); \\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the array(prices) two times. Where N = size of the array.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Dynamic Programming Approach(Space optimisation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int buyAtPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<n; i++){\\n            buyAtPrice = min(buyAtPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - buyAtPrice); \\n        }\\n        return maxProfit;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884314,
                "title": "python-3-very-simple-solution-explanation-added",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe might think about using sliding window technique, but obviously we don\\'t need subarray here. We just need one value from the given input list. So, this technique is not useful.\\n\\n**Solution:**\\nWe always need to know what is the maxProfit we can make if we sell the stock on i-th day. So, keep track of maxProfit.\\nThere might be a scenario where if stock bought on i-th day is minimum and we sell it on (i + k)th day. So, keep track of minPurchase as well.\\n\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tif not prices:\\n\\t\\treturn 0\\n\\n\\tmaxProfit = 0\\n\\tminPurchase = prices[0]\\n\\tfor i in range(1, len(prices)):\\t\\t\\n\\t\\tmaxProfit = max(maxProfit, prices[i] - minPurchase)\\n\\t\\tminPurchase = min(minPurchase, prices[i])\\n\\treturn maxProfit\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tif not prices:\\n\\t\\treturn 0\\n\\n\\tmaxProfit = 0\\n\\tminPurchase = prices[0]\\n\\tfor i in range(1, len(prices)):\\t\\t\\n\\t\\tmaxProfit = max(maxProfit, prices[i] - minPurchase)\\n\\t\\tminPurchase = min(minPurchase, prices[i])\\n\\treturn maxProfit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 900050,
                "title": "fully-explained-all-buy-and-sell-problems-c-recursive-memoization-minor-difference",
                "content": "**To solve this problem just start from basic similar problem. After solving these peoblems we wil reach at final this problem.**\\n\\n``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n**Recursive Solution and memoize solutions:**\\n\\n1. https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\\n\\n   **You can do at most one transaction**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n2. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\\n\\n    **You can do as many transactions as you like**\\n\\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\\n \\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n 3.  https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n      **You may complete at most two transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n4. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\\n\\n     **You may complete at most k transactions.**\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------------------\\n\\n**Hit \\uD83D\\uDC4D if you like it :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` I have discussed all the problems by recursive and memoization approach , so that everyone can figure out minor differences between the questions :)```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices, int i,int k,bool buy,vector<vector<int>> &v)\\n    {\\n        //if we have no stock or we have no chance of transaction(k=0)\\n        if(i>=prices.size()||k<=0) return 0;\\n        if(v[i][buy]!=-1) return v[i][buy];\\n        \\n        if(buy)  //if we are buying then next time we will sell else next time we will buy\\n        {        //-prices[i], because bought stock of prices[i], expend money\\n            \\n           return v[i][buy]=max(-prices[i]+find(prices,i+1,k,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n        else    //it\\'s time to sell , now decrease k, we have done 1 transaction\\n        {       //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n           return v[i][buy]=max( prices[i]+find(prices,i+1,k-1,!buy,v),find(prices,i+1,k,buy,v)); \\n        }\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size(); \\n        vector<vector<int>> v(n,vector<int> (2,-1));\\n        //passing here buy=1 because we will first buy then sell\\n        //we can do atmost k=1 transaction\\n        return find(prices,0,1,1,v);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint find(int ind,vector<int> &v,bool buy,vector<vector<int>> &memo)\\n{    \\n    if(ind>=v.size()) return 0;\\n    if(memo[ind][buy]!=-1) return memo[ind][buy];\\n    \\n    if(buy) //if we are buying then next time we will sell else next time we will buy\\n    {      //-prices[i], because bought stock of prices[i], expend money, !buy because next time sell\\n        \\n       return memo[ind][buy]=max(-v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n    else   //it\\'s time to sell \\n    {      //+prices[i], because we now gain (i.e) sell our stock at rate of prices[i]\\n        \\n       return memo[ind][buy]=max(v[ind]+find(ind+1,v,!buy,memo),find(ind+1,v,buy,memo));  \\n    }\\n     \\n}\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n=prices.size();\\n        if(n<2) return 0;\\n        vector<vector<int>> v(n+1,vector<int>(2,-1));\\n        //passing here buy=1 because we will first buy then sell \\n        return find(0,prices,1,v); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,vector<vector<vector<int>>> &memo)\\n    {   \\n        //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=2) return 0; //counter\\n        if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n            return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n            return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,memo),find(prices,ind+1,buy,c,memo));\\n        }\\n        \\n    }\\n    int maxProfit(vector<int>& prices) {\\n        //here we can do maximum two transaction\\n        //Use 3-D vector because here three states i,k,buy/sell\\n        vector<vector<vector<int>>> memo(prices.size(),vector<vector<int>>(2,vector<int>(2,-1)));\\n          \\n       return find(prices,0,1,0,memo); \\n    }\\n};\\n \\n```\n```\\nclass Solution {\\npublic:\\n    int find(vector<int> &prices,int ind,bool buy,int c,int k,vector<vector<vector<int>>> &memo)\\n    {   //if buy =1 means we have to buy now\\n        //else we have to sell now\\n        if(ind>=prices.size()||c>=k) return 0; //counter\\n        \\n        else if(memo[ind][buy][c]!=-1) return memo[ind][buy][c];\\n         \\n        if(buy) //now we can either buy prices[i] or we can skip it and try next to buy\\n        {\\n        return memo[ind][buy][c]=max(-prices[ind]+find(prices,ind+1,!buy,c,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        else  //now we can either sell prices[i] or we can skip it and try next to sell\\n        {\\n        return memo[ind][buy][c]=max(prices[ind]+find(prices,ind+1,!buy,c+1,k,memo),find(prices,ind+1,buy,c,k,memo));\\n        }\\n        \\n    }\\n    int maxProfit(int k, vector<int>& prices) {\\n        \\n        //edge case we are not able to pick 2k points from n points, which means \\n        //we will not reach the limit no matter how we try. \\n        //if the price of day i arise, buy the stock in i-1th day and sell it at ith day.\\n        if (2 * k > prices.size()) {\\n            int res = 0;\\n            for (int i = 1; i < prices.size(); i++) {\\n                res += max(0, prices[i] - prices[i - 1]);\\n            }\\n            return res;\\n        }\\n        \\n         //here we can do maximum k transaction\\n        vector<vector<vector<int>>> memo(prices.size()+1,vector<vector<int>>(2,vector<int>(k+1,-1)));\\n        return find(prices,0,1,0,k,memo); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39062,
                "title": "my-jave-accepted-solution-with-o-n-time-and-o-1-space",
                "content": "The idea is to find so far min price.\\n\\n     public int maxProfit(int[] prices) {\\n    \\t\\t if (prices.length == 0) {\\n    \\t\\t\\t return 0 ;\\n    \\t\\t }\\t\\t\\n    \\t\\t int max = 0 ;\\n    \\t\\t int sofarMin = prices[0] ;\\n    \\t     for (int i = 0 ; i < prices.length ; ++i) {\\n    \\t    \\t if (prices[i] > sofarMin) {\\n    \\t    \\t\\t max = Math.max(max, prices[i] - sofarMin) ;\\n    \\t    \\t } else{\\n    \\t    \\t\\tsofarMin = prices[i];  \\n    \\t    \\t }\\n    \\t     }\\t     \\n    \\t    return  max ;\\n    \\t }",
                "solutionTags": [],
                "code": "The idea is to find so far min price.\\n\\n     public int maxProfit(int[] prices) {\\n    \\t\\t if (prices.length == 0) {\\n    \\t\\t\\t return 0 ;\\n    \\t\\t }\\t\\t\\n    \\t\\t int max = 0 ;\\n    \\t\\t int sofarMin = prices[0] ;\\n    \\t     for (int i = 0 ; i < prices.length ; ++i) {\\n    \\t    \\t if (prices[i] > sofarMin) {\\n    \\t    \\t\\t max = Math.max(max, prices[i] - sofarMin) ;\\n    \\t    \\t } else{\\n    \\t    \\t\\tsofarMin = prices[i];  \\n    \\t    \\t }\\n    \\t     }\\t     \\n    \\t    return  max ;\\n    \\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 263197,
                "title": "python-2-solutions-min-so-far-kadane-s-algorithm-with-picture-o-1-in-space",
                "content": "**\\u2714\\uFE0F Solution 1: MinSoFar**\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        ans = 0\\n        minSoFar = prices[0]\\n        for i in range(1, n):\\n            ans = max(ans, prices[i] - minSoFar)\\n            minSoFar = min(minSoFar, prices[i])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is length of `prices` array.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Kadane\\'s Algorithm**\\n- Same with problem **[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)**.\\n\\n![image](https://assets.leetcode.com/users/images/fc0e41c4-bb24-4d62-9891-0d88f62d49b3_1632370664.418544.png)\\n\\n\\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        ans = 0\\n        curSum = 0\\n        for i in range(n-1):\\n            curSum += prices[i+1] - prices[i]\\n            if curSum < 0:\\n                curSum = 0\\n            ans = max(ans, curSum)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is length of `prices` array.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        ans = 0\\n        minSoFar = prices[0]\\n        for i in range(1, n):\\n            ans = max(ans, prices[i] - minSoFar)\\n            minSoFar = min(minSoFar, prices[i])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        ans = 0\\n        curSum = 0\\n        for i in range(n-1):\\n            curSum += prices[i+1] - prices[i]\\n            if curSum < 0:\\n                curSum = 0\\n            ans = max(ans, curSum)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914105,
                "title": "most-optimized-solution-easy-to-understand-c-java-python",
                "content": "# Approach\\nTo solve this problem, I employed a straightforward approach that iterates through the array of stock prices. At each step, I kept track of the minimum stock price seen so far (`min_price`) and calculated the potential profit that could be obtained by selling at the current price (`prices[i] - min_price`). I updated the `maxprof` (maximum profit) variable with the maximum of its current value and the calculated profit. Additionally, I updated the `min_price` to be the minimum of the current stock price and the previously seen minimum.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nThe algorithm iterates through the array of stock prices once, performing constant-time operations at each step. Therefore, the time complexity is linear in the size of the input array.\\n\\n- Space complexity: $$O(1)$$\\nThe algorithm uses a constant amount of extra space to store variables like `min_price` and `maxprof`. The space complexity remains constant regardless of the size of the input array.\\n\\n\\n# Code\\n``` cpp []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=1;i<prices.size();i++){\\n            maxprof = max(maxprof,prices[i]-min_price);\\n            min_price = min(prices[i],min_price);\\n        }\\n\\n        return maxprof;\\n    }\\n};\\n```\\n\\n``` java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=0;i<prices.length;i++){\\n            maxprof = Math.max(maxprof,prices[i]-min_price);\\n            min_price = Math.min(prices[i],min_price);\\n        }\\n\\n        return maxprof;\\n    }\\n}\\n```\\n\\n``` python3 []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices[1:]:\\n            max_profit = max(max_profit, price - min_price)\\n            min_price = min(min_price, price)\\n            \\n        return max_profit\\n```\\n\\nHope you liked the Solution,\\nIf you have any questions or suggestions, feel free to share \\u2013 happy coding!\\n\\n---\\n\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/a79b8806-f22f-40aa-91d5-be9118ab659f_1692112738.478644.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "``` cpp []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=1;i<prices.size();i++){\\n            maxprof = max(maxprof,prices[i]-min_price);\\n            min_price = min(prices[i],min_price);\\n        }\\n\\n        return maxprof;\\n    }\\n};\\n```\n``` java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int min_price = prices[0];\\n        int maxprof = 0;\\n\\n        for(int i=0;i<prices.length;i++){\\n            maxprof = Math.max(maxprof,prices[i]-min_price);\\n            min_price = Math.min(prices[i],min_price);\\n        }\\n\\n        return maxprof;\\n    }\\n}\\n```\n``` python3 []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices[1:]:\\n            max_profit = max(max_profit, price - min_price)\\n            min_price = min(min_price, price)\\n            \\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433981,
                "title": "easy-100-kadane-s-algorithm-java-c-python-js-python3-min-so-far",
                "content": "Given an array prices where prices[i] is the price of a given stock on the ith day.\\nmaximize our profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\\nReturn the maximum profit achieve from this transaction. If you cannot achieve any profit, return 0\\n\\n**Example:**\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n**Note that, buying on day 2 and selling on day 1 is not allowed because we must buy before sell.**\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 98.59% of Java online submissions for Best Time to Buy and Sell Stock.\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // Base case...\\n        // If the array is empty or its length <= 1, return 0...\\n        if(prices == null || prices.length <= 1) return 0;\\n        // Initialize the minimum price to buy...\\n        int minBuy = prices[0];\\n        // Initialize the maximum profit...\\n        int profit = 0;\\n        // Traverse all elements through a for loop...\\n        for(int i = 1; i < prices.length; i++) {\\n            // Get the minimum price to buy...\\n            minBuy = Math.min(minBuy, prices[i]);\\n            // Get maximum profit...\\n            profit = Math.max(profit, prices[i] - minBuy);\\n        }\\n        return profit;      //return the maximum profit...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() == 0) return 0;\\n        int profit = 0;\\n        int low = prices[0], high = prices[0];\\n        for(int i = 0; i < prices.size(); i++){\\n            if(prices[i] < low){\\n                profit = max(profit, high - low);\\n                low = prices[i];\\n                high = prices[i];\\n            }else{\\n                high = max(high, prices[i]);\\n            }\\n        }\\n        profit = max(profit, high - low);\\n        return profit;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        if len(prices) == 0: return 0\\n        else:\\n            profit = 0\\n            minBuy = prices[0]\\n            for i in range(len(prices)):\\n                profit = max(prices[i] - minBuy, profit)\\n                minBuy = min(minBuy, prices[i])\\n            return profit\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar maxProfit = function(prices) {\\n    if(prices == null || prices.length <= 1) return 0;\\n    let minBuy = prices[0];\\n    let profit = 0;\\n    for(let i = 1; i < prices.length; i++) {\\n        minBuy = Math.min(minBuy, prices[i]);\\n        profit = Math.max(profit, prices[i] - minBuy);\\n    }\\n    return profit;\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 0: return 0\\n        else:\\n            profit = 0\\n            minBuy = prices[0]\\n            for i in range(len(prices)):\\n                profit = max(prices[i] - minBuy, profit)\\n                minBuy = min(minBuy, prices[i])\\n            return profit\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // Base case...\\n        // If the array is empty or its length <= 1, return 0...\\n        if(prices == null || prices.length <= 1) return 0;\\n        // Initialize the minimum price to buy...\\n        int minBuy = prices[0];\\n        // Initialize the maximum profit...\\n        int profit = 0;\\n        // Traverse all elements through a for loop...\\n        for(int i = 1; i < prices.length; i++) {\\n            // Get the minimum price to buy...\\n            minBuy = Math.min(minBuy, prices[i]);\\n            // Get maximum profit...\\n            profit = Math.max(profit, prices[i] - minBuy);\\n        }\\n        return profit;      //return the maximum profit...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() == 0) return 0;\\n        int profit = 0;\\n        int low = prices[0], high = prices[0];\\n        for(int i = 0; i < prices.size(); i++){\\n            if(prices[i] < low){\\n                profit = max(profit, high - low);\\n                low = prices[i];\\n                high = prices[i];\\n            }else{\\n                high = max(high, prices[i]);\\n            }\\n        }\\n        profit = max(profit, high - low);\\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        if len(prices) == 0: return 0\\n        else:\\n            profit = 0\\n            minBuy = prices[0]\\n            for i in range(len(prices)):\\n                profit = max(prices[i] - minBuy, profit)\\n                minBuy = min(minBuy, prices[i])\\n            return profit\\n```\n```\\nvar maxProfit = function(prices) {\\n    if(prices == null || prices.length <= 1) return 0;\\n    let minBuy = prices[0];\\n    let profit = 0;\\n    for(let i = 1; i < prices.length; i++) {\\n        minBuy = Math.min(minBuy, prices[i]);\\n        profit = Math.max(profit, prices[i] - minBuy);\\n    }\\n    return profit;\\n};\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 0: return 0\\n        else:\\n            profit = 0\\n            minBuy = prices[0]\\n            for i in range(len(prices)):\\n                profit = max(prices[i] - minBuy, profit)\\n                minBuy = min(minBuy, prices[i])\\n            return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273395,
                "title": "python-greedy",
                "content": "The heuristic is that as long as current price is higher than previous lowest price, max profit could be updated. So I use ```buy``` to track previous lowest price (indicating we can buy in that time) and ```ans``` to track max profit we have achieved so far.\\n```\\ndef maxProfit(prices):\\n\\tbuy, ans = float(\\'inf\\'), 0\\n\\tfor p in prices:\\n\\t\\tbuy, ans = min(buy, p), max(ans, p-buy)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```buy```\n```ans```\n```\\ndef maxProfit(prices):\\n\\tbuy, ans = float(\\'inf\\'), 0\\n\\tfor p in prices:\\n\\t\\tbuy, ans = min(buy, p), max(ans, p-buy)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1545423,
                "title": "python-easy-to-understand-solution-with-explanation-tracking-and-dynamic-programming",
                "content": "### Idea 1: Array \\n* The trick : track the minimum price and the maximum possible profit\\n\\t* \\tKeep track of the buy price --> keep comparing the current price with prvious buy price and track of the minimum price while iterating through the list\\n\\t* \\tHowever, if the current price is greater than the previous buy price \\n\\t\\t* \\tnow check if you sell it now would you get a better profit than the previous one \\n\\t\\t\\t* \\tKeep track of the maximum profit\\n```\\n\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \\n        buy_price = prices[0] # at the begining the minimum price is the first price\\n        profit = 0 # at the begining the minimum  profit is zero\\n        \\n        for i in range(1,len(prices)):\\n            #if the current price is less than the previous buy price ; update the buy_price\\n            if prices[i] < buy_price:\\n                buy_price = prices[i]\\n            else: # if not check if you sell with the current price would you get better profit than the previous one\\n                profit = max(profit, prices[i]-buy_price) # compare the previous profit with the current profit\\n                \\n        return profit\\n\\t\\t\\n\\t\\t#Runtime: 916 ms\\n\\t\\t#Memory Usage: 23 MB\\n```\\n        \\n### * Idea 2 : Dynamic programming\\n* Track the minimum_price and the maximum profit together using a dp table\\n\\t* Thus each dp table cell will hold two items --> dp = [[min_price, max_profit], [min_price, max_profit], ........[min_price, max_profit]]\\n        \\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        dp = [0]*n # initializing the dp table\\n        dp[0] = [prices[0],0] # filling the the first dp table --> low_price = prices[0] max_profit=0\\n        min_price = max_profit = 0\\n        # Note that ---> indixing the dp table --> dp[i-1][0] stores minimum price and dp[i-1][1] stores maximum profit\\n        for i in range(1,n):\\n            min_price = min(dp[i-1][0], prices[i]) # min(previous_min_price, cur_min_price)\\n            max_profit = max(dp[i-1][1], prices[i]-dp[i-1][0]) # max(previoius_max_profit, current_profit)\\n            dp[i] =[min_price,max_profit]\\n                \\n        return dp[n-1][1]\\n\\t\\t#Runtime: 1220 ms, \\n\\t\\t#Memory Usage: 32.4 MB,\\n```\\n### \\n### ******* If you found this helpful , upvote and comment as sign of appreciation **********",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \\n        buy_price = prices[0] # at the begining the minimum price is the first price\\n        profit = 0 # at the begining the minimum  profit is zero\\n        \\n        for i in range(1,len(prices)):\\n            #if the current price is less than the previous buy price ; update the buy_price\\n            if prices[i] < buy_price:\\n                buy_price = prices[i]\\n            else: # if not check if you sell with the current price would you get better profit than the previous one\\n                profit = max(profit, prices[i]-buy_price) # compare the previous profit with the current profit\\n                \\n        return profit\\n\\t\\t\\n\\t\\t#Runtime: 916 ms\\n\\t\\t#Memory Usage: 23 MB\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        dp = [0]*n # initializing the dp table\\n        dp[0] = [prices[0],0] # filling the the first dp table --> low_price = prices[0] max_profit=0\\n        min_price = max_profit = 0\\n        # Note that ---> indixing the dp table --> dp[i-1][0] stores minimum price and dp[i-1][1] stores maximum profit\\n        for i in range(1,n):\\n            min_price = min(dp[i-1][0], prices[i]) # min(previous_min_price, cur_min_price)\\n            max_profit = max(dp[i-1][1], prices[i]-dp[i-1][0]) # max(previoius_max_profit, current_profit)\\n            dp[i] =[min_price,max_profit]\\n                \\n        return dp[n-1][1]\\n\\t\\t#Runtime: 1220 ms, \\n\\t\\t#Memory Usage: 32.4 MB,\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39267,
                "title": "javascript-solution-if-anyone-is-interested",
                "content": "    var maxProfit = function(prices) {\\n        var min = Number.MAX_SAFE_INTEGER; \\n        var max = 0;\\n        for (var i = 0; i < prices.length; i++) {\\n            min = Math.min(min, prices[i]);\\n            max = Math.max(max, prices[i] - min);\\n        }\\n        return max;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var maxProfit = function(prices) {\\n        var min = Number.MAX_SAFE_INTEGER; \\n        var max = 0;\\n        for (var i = 0; i < prices.length; i++) {\\n            min = Math.min(min, prices[i]);\\n            max = Math.max(max, prices[i] - min);\\n        }\\n        return max;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3226882,
                "title": "day-56-o-n-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\nThe intuition behind the code is to keep track of the minimum stock value seen so far while traversing the array from left to right. At each step, if the current stock value is greater than the minimum value seen so far, we calculate the profit that can be earned by selling the stock at the current value and buying at the minimum value seen so far, and update the maximum profit seen so far accordingly.\\n\\nBy keeping track of the minimum stock value and the maximum profit seen so far, we can solve the problem in a single pass over the array, without needing to consider all possible pairs of buy-sell transactions. This makes the code efficient and easy to implement.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize a variable n to the size of the input vector prices.\\n2. Initialize variables maximumProfit and minStockVal to 0 and INT_MAX respectively.\\n3. Initialize a loop variable i to 0.\\n4. While i is less than n, do the following:\\n    - a. Set minStockVal to the minimum value between minStockVal and the value of prices at index i.\\n    - b. If minStockVal is less than or equal to the value of prices at index i, set maximumProfit to the maximum value between maximumProfit and the difference between prices at index i and minStockVal.\\n    - c. Increment i by 1.\\n1. Return maximumProfit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maximumProfit = 0, minStockVal = INT_MAX;\\n        int i = 0;\\n        while (i < n) {\\n            minStockVal = min(minStockVal, prices[i]);\\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \\n            if (prices[i] >= minStockVal)\\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal);\\n            i++;\\n        }\\n        return maximumProfit;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int maximumProfit = 0, minStockVal = Integer.MAX_VALUE;\\n        int i = 0;\\n        while (i < n) {\\n            minStockVal = Math.min(minStockVal, prices[i]);\\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \\n            if (prices[i] >= minStockVal)\\n                maximumProfit = Math.max(maximumProfit, prices[i] - minStockVal);\\n            i++;\\n        }\\n        return maximumProfit;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        maximumProfit, minStockVal = 0, float(\\'inf\\')\\n        i = 0\\n        while i < n:\\n            minStockVal = min(minStockVal, prices[i])\\n            if prices[i] >= minStockVal:\\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal)\\n            i += 1\\n        return maximumProfit\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the size of the input vector prices.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as we are only using constant extra space for variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int maximumProfit = 0, minStockVal = INT_MAX;\\n        int i = 0;\\n        while (i < n) {\\n            minStockVal = min(minStockVal, prices[i]);\\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \\n            if (prices[i] >= minStockVal)\\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal);\\n            i++;\\n        }\\n        return maximumProfit;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int maximumProfit = 0, minStockVal = Integer.MAX_VALUE;\\n        int i = 0;\\n        while (i < n) {\\n            minStockVal = Math.min(minStockVal, prices[i]);\\n            // whenever the price of current stock is greater then then the stock value which we bought then only we will sell the stock \\n            if (prices[i] >= minStockVal)\\n                maximumProfit = Math.max(maximumProfit, prices[i] - minStockVal);\\n            i++;\\n        }\\n        return maximumProfit;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        maximumProfit, minStockVal = 0, float(\\'inf\\')\\n        i = 0\\n        while i < n:\\n            minStockVal = min(minStockVal, prices[i])\\n            if prices[i] >= minStockVal:\\n                maximumProfit = max(maximumProfit, prices[i] - minStockVal)\\n            i += 1\\n        return maximumProfit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280980,
                "title": "c-kadens-algo",
                "content": "**TIme complexity:O(n)\\nspace complexity:(1)**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```\\nif you like the solution ,upvote it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185218,
                "title": "javascript",
                "content": "```\nvar maxProfit = function(prices) {\n    let result = 0;\n    let min = prices[0];\n    for(let i = 1; i < prices.length; i++) {\n        min = Math.min(prices[i], min);\n        result = Math.max(result, prices[i] - min);\n    }\n    return result;\n};\n\n```",
                "solutionTags": [],
                "code": "```\nvar maxProfit = function(prices) {\n    let result = 0;\n    let min = prices[0];\n    for(let i = 1; i < prices.length; i++) {\n        min = Math.min(prices[i], min);\n        result = Math.max(result, prices[i] - min);\n    }\n    return result;\n};\n\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39075,
                "title": "a-o-1-n-solution",
                "content": "1.for prices[0] .... prices[n], prices[n+1].....\\nif (prices[n] < prices[0]) then, the max profit is in prices[0]...prices[n], or begin from prices[n+1],\\notherwise, suppose prices[n+1] > prices[0], and max profit is happened between prices[n+1] , and \\nprices[n+k](k>1), then if we buy at day 0, and sell at day n+k, we get a bigger profit.\\n\\nBase on logic above, we can have a O(1*n) solution:\\n\\n    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            \\n            if (prices.length == 0)\\n            {\\n                return 0;\\n            }\\n            \\n            int max = 0, min = prices[0];\\n            int profit = 0;\\n            \\n            for (int i = 1; i < prices.length; i++)\\n            {\\n                if (prices[i] < min)\\n                {\\n                    \\n                    min = prices[i];\\n                }\\n                else\\n                {\\n                    if (prices[i] - min > profit)\\n                    {\\n                        profit = prices[i] - min;\\n                    }\\n                    \\n                }\\n            }\\n         \\n       \\n         \\n         return profit;\\n         \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            \\n            if (prices.length == 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1505850,
                "title": "java-fastest-greedy-solution-100",
                "content": "````\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        int max=0,min=prices[0];\\n        for(int i=1;i<prices.length;i++)   {\\n\\t\\t\\n            if(min<prices[i])\\n                max=Math.max(prices[i]-min,max);\\n            else\\n                min=prices[i];\\n        }\\n        return max;\\n    }\\n}\\n````\\n\\nIf it helped you then I will be happy if give a **upvote**!",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "````\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        int max=0,min=prices[0];\\n        for(int i=1;i<prices.length;i++)   {\\n\\t\\t\\n            if(min<prices[i])\\n                max=Math.max(prices[i]-min,max);\\n            else\\n                min=prices[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39230,
                "title": "5-line-cpp-solution",
                "content": "\\n    int maxProfit(vector<int>& prices) {\\n        int maxPro = 0, minPrice = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxPro = max(prices[i] - minPrice, maxPro);\\n        }\\n        return maxPro;\\n    }",
                "solutionTags": [],
                "code": "\\n    int maxProfit(vector<int>& prices) {\\n        int maxPro = 0, minPrice = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxPro = max(prices[i] - minPrice, maxPro);\\n        }\\n        return maxPro;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3227453,
                "title": "fast-java-solution",
                "content": "# JAVA Code\\n``` JAVA []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/6233d50d-1433-4516-8d8e-90fb8e13d32f_1677303191.974716.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lsf = Integer.MAX_VALUE;\\n        int op = 0;\\n        int pist = 0;\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            if(prices[i] < lsf){\\n                lsf = prices[i];\\n            }\\n            pist = prices[i] - lsf;\\n            if(op < pist){\\n                op = pist;\\n            }\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040282,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n\\n```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        int max=0,min=prices[0];\\n        for(int i=1;i<prices.length;i++)   {\\n\\t\\t\\n            if(min<prices[i])\\n                max=Math.max(prices[i]-min,max);\\n            else\\n                min=prices[i];\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nint maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int maxprofit = 0;\\n        int minvalue = INT_MAX;\\n        for(int i =0;i<n;i++){\\n            minvalue = min(prices[i],minvalue);\\n            maxprofit= max(maxprofit,prices[i] - minvalue);\\n        }\\n        return maxprofit;\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left = 0 #Buy\\n        right = 1 #Sell\\n        max_profit = 0\\n        while right < len(prices):\\n            currentProfit = prices[right] - prices[left] #our current Profit\\n            if prices[left] < prices[right]:\\n                max_profit =max(currentProfit,max_profit)\\n            else:\\n                left = right\\n            right += 1\\n        return max_profit\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst maxProfit = (prices) => {\\n  let left = 0; // Buy\\n  let right = 1; // sell\\n  let max_profit = 0;\\n  while (right < prices.length) {\\n    if (prices[left] < prices[right]) {\\n      let profit = prices[right] - prices[left]; // our current profit\\n\\n      max_profit = Math.max(max_profit, profit);\\n    } else {\\n      left = right;\\n    }\\n    right++;\\n  }\\n  return max_profit;\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nfun maxProfit(prices: IntArray): Int {\\n   prices.foldIndexed<Int>(prices[0]) { i, min, n ->\\n\\t\\tprices[i] = n - min\\n\\t\\tif (n < min) n else min\\n   }\\n   return prices.max() ?: 0\\n} \\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nfunc maxProfit(_ prices: [Int]) -> Int {\\n    guard prices.count > 1 else { return 0 }\\n    var best = 0, current = 0\\n    for index in 1..<prices.endIndex {\\n        current = max(0, current + prices[index] - prices[index-1])\\n        best = max(best, current)\\n    }\\n    return best\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        int max=0,min=prices[0];\\n        for(int i=1;i<prices.length;i++)   {\\n\\t\\t\\n            if(min<prices[i])\\n                max=Math.max(prices[i]-min,max);\\n            else\\n                min=prices[i];\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nint maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int maxprofit = 0;\\n        int minvalue = INT_MAX;\\n        for(int i =0;i<n;i++){\\n            minvalue = min(prices[i],minvalue);\\n            maxprofit= max(maxprofit,prices[i] - minvalue);\\n        }\\n        return maxprofit;\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left = 0 #Buy\\n        right = 1 #Sell\\n        max_profit = 0\\n        while right < len(prices):\\n            currentProfit = prices[right] - prices[left] #our current Profit\\n            if prices[left] < prices[right]:\\n                max_profit =max(currentProfit,max_profit)\\n            else:\\n                left = right\\n            right += 1\\n        return max_profit\\n```\n```\\n```\n```\\n```\n```\\nconst maxProfit = (prices) => {\\n  let left = 0; // Buy\\n  let right = 1; // sell\\n  let max_profit = 0;\\n  while (right < prices.length) {\\n    if (prices[left] < prices[right]) {\\n      let profit = prices[right] - prices[left]; // our current profit\\n\\n      max_profit = Math.max(max_profit, profit);\\n    } else {\\n      left = right;\\n    }\\n    right++;\\n  }\\n  return max_profit;\\n};\\n```\n```\\n```\n```\\n```\n```\\nfun maxProfit(prices: IntArray): Int {\\n   prices.foldIndexed<Int>(prices[0]) { i, min, n ->\\n\\t\\tprices[i] = n - min\\n\\t\\tif (n < min) n else min\\n   }\\n   return prices.max() ?: 0\\n} \\n```\n```\\n```\n```\\n```\n```\\nfunc maxProfit(_ prices: [Int]) -> Int {\\n    guard prices.count > 1 else { return 0 }\\n    var best = 0, current = 0\\n    for index in 1..<prices.endIndex {\\n        current = max(0, current + prices[index] - prices[index-1])\\n        best = max(best, current)\\n    }\\n    return best\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227007,
                "title": "simplest-solution-beginner-friendly-dp-c-python-java",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\nIn this question we have to find the **Maximum Profit**.\\nSo, we find the **stock with Minimum value** and then **check for maximum profit**.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    Example : prices = [7,1,5,3,6,4]\\n    Initially `minValue` = INT_MAX, `profit` = 0\\n    At index `0` \\n        `minValue` = min(minValue, 7)\\n        profit = max(profit, 7 - minValue)\\n        so, `profit` = 0\\n    At index `1` \\n        minValue = min(minValue, 1)\\n        profit = max(profit, 1 - 1)\\n        so, `profit` = 0\\n    At index `2` \\n        minValue = min(minValue, 5)\\n        profit = max(profit, 5 - 1)\\n        so, `profit` = 4\\n    At index `3` \\n        minValue = min(minValue, 3)\\n        profit = max(profit, 3 - 1)\\n        so, `profit` = 4\\n    At index `4` \\n        minValue = min(minValue, 6)\\n        profit = max(profit, 6 - 1)\\n        so, `profit` = 5\\n    At index `5` \\n        minValue = min(minValue, 4)\\n        profit = max(profit, 4 - 1)\\n        so, `profit` = 5\\n    So answer is `5`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minValue = INT_MAX;\\n        int profit = 0;\\n        for(int i=0;i<prices.size();i++){\\n            minValue = min(minValue, prices[i]);\\n            profit = max(profit, prices[i]-minValue);\\n        }\\n        return profit;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        minValue = 1e9\\n        profit = 0\\n\\n        for i in range(len(prices)):\\n            minValue = min(minValue, prices[i])\\n            profit = max(profit, prices[i]-minValue)\\n        \\n        return profit\\n```\\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minValue = Integer.MAX_VALUE;\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            minValue = Math.min(minValue, prices[i]);\\n            profit = Math.max(profit, prices[i] - minValue);\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\\n\\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minValue = INT_MAX;\\n        int profit = 0;\\n        for(int i=0;i<prices.size();i++){\\n            minValue = min(minValue, prices[i]);\\n            profit = max(profit, prices[i]-minValue);\\n        }\\n        return profit;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        minValue = 1e9\\n        profit = 0\\n\\n        for i in range(len(prices)):\\n            minValue = min(minValue, prices[i])\\n            profit = max(profit, prices[i]-minValue)\\n        \\n        return profit\\n```\n```Java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minValue = Integer.MAX_VALUE;\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            minValue = Math.min(minValue, prices[i]);\\n            profit = Math.max(profit, prices[i] - minValue);\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851941,
                "title": "python-o-n-dynamic-programming-solution-explained",
                "content": "Classical dynamic programming problem. Let `dp[i]` be a maximum profit we can have if we sell stock at `i`-th moment of time. Then we can get, that `dp[i+1] = max(dp[i] + q, q)`, where `q = nums[i+1] - nums[i]`, we have two choices, either we just buy and immeditely sell and get `q` gain, or we use `dp[i] + q` to merge two transactions. \\n\\nNote now, that we do not really need to keep all `dp` array, but we can keep only last state.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, nums):\\n        ans, dp = 0, 0\\n        for i in range(0, len(nums)-1):\\n            q = nums[i+1] - nums[i]\\n            dp = max(dp + q, q)\\n            ans = max(ans, dp)\\n        return ans\\n```\\n\\n**PS** Look also my solutions to similar problems: \\nBest Time to Buy and Sell Stock III\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/794633/Python-O(n)-solution-with-optimization-explained\\nBest Time to Buy and Sell Stock with Cooldown\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/761720/Python-dp-O(n)-solution-using-differences-explained\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, nums):\\n        ans, dp = 0, 0\\n        for i in range(0, len(nums)-1):\\n            q = nums[i+1] - nums[i]\\n            dp = max(dp + q, q)\\n            ans = max(ans, dp)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172820,
                "title": "explanation-for-algorithm-why-this-is-dp",
                "content": "There are several solutions that invoke some recursive formula resembling\\n```\\nProfit_if_sold[i] = max(0, Profit_if_sold[i-1] + Diff_from_last[i])\\n```\\nwithout motivating how this formula is obtained. This post provides the explanation for **how** one arrives at this recursive formula.\\n\\n1. To arrive at this formula, you must first identify the optimal strategy. Realize that at time ```i```, you have three possible actions: buy, hold, or sell. The optimal actions to take are:\\n\\ta. **Buy the stock** if it is the minimum price-to-date, i.e. ```P_i < P_j``` for all ```j < i```\\n\\tb. **Hold / sell the stock** if it is not at the minimum price to-date, i.e. ```P_j < P_i``` for some ```j < i```\\n\\n2. To implement the strategy, it is informative to look at a concrete example:\\n```\\nPrices =         [7, 1, 5, 3, 6, 4, 0, 7] \\nMin_to_date =    [7, 1, 1, 1, 1, 1, 0, 0] \\nProfit_if_sold = [0, 0, 4, 2, 5, 3, 0, 7]\\nDiff_from_last = [0,-6, 4,-2, 3,-2,-4, 7]\\n```\\n* ```Prices``` are the stock prices\\n* ```Min_to_date``` is the minimum price to date\\n* ```Profit_if_sold``` is the profit if a stock was sold at step ```i```; note that it is ```0``` if is the min-to-date, as that would be the time to buy according to the strategy\\n* ```Diff_from_last[i] = P[i] - P[i-1]```\\n\\nIt is clear that the solution to the problem statement is ```max(Profit_if_sold)```. So how do you calculate ```Profit_if_sold```? You calculate it using the recursive formula\\n```\\nProfit_if_sold[i] = max(0, Profit_if_sold[i-1] + Diff_from_last[i]) \\n```\\nThis is the recursive formula used in several solutions. As this a recursive formula, one can consider this problem a DP problem",
                "solutionTags": [],
                "code": "```\\nProfit_if_sold[i] = max(0, Profit_if_sold[i-1] + Diff_from_last[i])\\n```\n```i```\n```P_i < P_j```\n```j < i```\n```P_j < P_i```\n```j < i```\n```\\nPrices =         [7, 1, 5, 3, 6, 4, 0, 7] \\nMin_to_date =    [7, 1, 1, 1, 1, 1, 0, 0] \\nProfit_if_sold = [0, 0, 4, 2, 5, 3, 0, 7]\\nDiff_from_last = [0,-6, 4,-2, 3,-2,-4, 7]\\n```\n```Prices```\n```Min_to_date```\n```Profit_if_sold```\n```i```\n```0```\n```Diff_from_last[i] = P[i] - P[i-1]```\n```max(Profit_if_sold)```\n```Profit_if_sold```\n```\\nProfit_if_sold[i] = max(0, Profit_if_sold[i-1] + Diff_from_last[i]) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711530,
                "title": "python-beginner-simple-solution",
                "content": "If the code helped, would appreciate an upvote.\\n\\'\\'\\'\\nclass Solution:\\n    \\n\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\n\\t\\tif not prices:\\n            return 0\\n\\n        profit = 0\\n\\n        buy_stock = prices[0]\\n\\n        for i in range(len(prices)):\\n\\n            # update the buy_stock if there\\'s\\n            # any smaller value is present in the list\\n            if buy_stock > prices[i]:\\n                buy_stock = prices[i]\\n\\n            # Now we\\'ve buy_stock.\\n            # Calculate the max of price diff and profit made till now\\n            profit = max((prices[i] - buy_stock, profit))\\n\\n        return profit",
                "solutionTags": [
                    "Python3"
                ],
                "code": "If the code helped, would appreciate an upvote.\\n\\'\\'\\'\\nclass Solution:\\n    \\n\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\n\\t\\tif not prices:\\n            return 0\\n\\n        profit = 0\\n\\n        buy_stock = prices[0]\\n\\n        for i in range(len(prices)):\\n\\n            # update the buy_stock if there\\'s\\n            # any smaller value is present in the list\\n            if buy_stock > prices[i]:\\n                buy_stock = prices[i]\\n\\n            # Now we\\'ve buy_stock.\\n            # Calculate the max of price diff and profit made till now\\n            profit = max((prices[i] - buy_stock, profit))\\n\\n        return profit",
                "codeTag": "Java"
            },
            {
                "id": 39171,
                "title": "java-6-lines-4-lines-2-lines-solutions",
                "content": "I only count the new lines of code that I've written, i.e. everything except for the method definition and the method closing bracket.\\n\\nProper Java - 6 lines:\\n\\n    public int maxProfit(int[] prices) {\\n         int min = Integer.MAX_VALUE, max = 0;\\n         for (int i = 0; i < prices.length; i++) {\\n             min = Math.min(min, prices[i]);\\n             max = Math.max(max, prices[i] - min);\\n         }\\n         return max;\\n     }  \\n\\nProper Java with shortcuts - 4 lines:\\n  \\n    public int maxProfit(int[] prices) {\\n        int min = Integer.MAX_VALUE, max = 0;\\n        for (int i = 0; i < prices.length; i++)\\n            max = Math.max(max, prices[i] - (min = Math.min(min, prices[i])));\\n        return max;\\n    }\\n\\nJava 8 streams - 2 lines:\\n\\n    int min = Integer.MAX_VALUE;\\n    public int maxProfit(int[] prices) {\\n        return Arrays.stream(prices).map(i -> i - (min = Math.min(min, i))).max().orElse(0);\\n    }",
                "solutionTags": [],
                "code": "I only count the new lines of code that I've written, i.e. everything except for the method definition and the method closing bracket.\\n\\nProper Java - 6 lines:\\n\\n    public int maxProfit(int[] prices) {\\n         int min = Integer.MAX_VALUE, max = 0;\\n         for (int i = 0; i < prices.length; i++) {\\n             min = Math.min(min, prices[i]);\\n             max = Math.max(max, prices[i] - min);\\n         }\\n         return max;\\n     }  \\n\\nProper Java with shortcuts - 4 lines:\\n  \\n    public int maxProfit(int[] prices) {\\n        int min = Integer.MAX_VALUE, max = 0;\\n        for (int i = 0; i < prices.length; i++)\\n            max = Math.max(max, prices[i] - (min = Math.min(min, prices[i])));\\n        return max;\\n    }\\n\\nJava 8 streams - 2 lines:\\n\\n    int min = Integer.MAX_VALUE;\\n    public int maxProfit(int[] prices) {\\n        return Arrays.stream(prices).map(i -> i - (min = Math.min(min, i))).max().orElse(0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39234,
                "title": "clean-java-solution-with-o-n-time-and-o-1-space",
                "content": "First attempt - simple brute force solution (just coded up problem definition):\\n\\n    // O(n^2) time, O(1) space\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i; j >= 0; j--) {\\n                profit = Math.max(profit, prices[i]-prices[j]);\\n            }\\n        }\\n        return profit;\\n    }\\n\\nSecond attempt - tried to solve iterating over array two times:\\n\\nfirst pass - from left to right and saving current minimum in additional array \\n\\nsecond pass - from right to left finding maximum of current profit and previous maximum profit\\n\\n    // O(n) time, O(n) space\\n    public int maxProfit(int[] prices) {\\n        int[] minPrices = new int[prices.length];\\n        int currentMinPrice = prices.length > 0 ? prices[0] : 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            currentMinPrice = Math.min(currentMinPrice, prices[i]);\\n            minPrices[i] = currentMinPrice;\\n        }\\n        \\n        int currentMaxPrice = prices.length > 0 ? prices[prices.length - 1] : 0;\\n        int profit = currentMaxPrice - currentMinPrice;\\n        for (int i = prices.length - 1; i >= 0 ; i--) {\\n            currentMaxPrice = Math.max(currentMaxPrice, prices[i]);\\n            profit = Math.max(profit, currentMaxPrice - minPrices[i]);\\n        }\\n        return profit;\\n    }\\n\\nThird attempt - finally figured out, that keeping current minimum in separate array is really not required:\\n      \\n    // O(n) time, O(1) space\\n    public int maxProfit(int[] prices) {\\n        int currentMinPrice = prices.length > 0 ? prices[0] : 0;\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            currentMinPrice = Math.min(currentMinPrice, prices[i]);\\n            profit = Math.max(profit, prices[i] - currentMinPrice); \\n        }\\n        return profit;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "First attempt - simple brute force solution (just coded up problem definition):\\n\\n    // O(n^2) time, O(1) space\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i; j >= 0; j--) {\\n                profit = Math.max(profit, prices[i]-prices[j]);\\n            }\\n        }\\n        return profit;\\n    }\\n\\nSecond attempt - tried to solve iterating over array two times:\\n\\nfirst pass - from left to right and saving current minimum in additional array \\n\\nsecond pass - from right to left finding maximum of current profit and previous maximum profit\\n\\n    // O(n) time, O(n) space\\n    public int maxProfit(int[] prices) {\\n        int[] minPrices = new int[prices.length];\\n        int currentMinPrice = prices.length > 0 ? prices[0] : 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            currentMinPrice = Math.min(currentMinPrice, prices[i]);\\n            minPrices[i] = currentMinPrice;\\n        }\\n        \\n        int currentMaxPrice = prices.length > 0 ? prices[prices.length - 1] : 0;\\n        int profit = currentMaxPrice - currentMinPrice;\\n        for (int i = prices.length - 1; i >= 0 ; i--) {\\n            currentMaxPrice = Math.max(currentMaxPrice, prices[i]);\\n            profit = Math.max(profit, currentMaxPrice - minPrices[i]);\\n        }\\n        return profit;\\n    }\\n\\nThird attempt - finally figured out, that keeping current minimum in separate array is really not required:\\n      \\n    // O(n) time, O(1) space\\n    public int maxProfit(int[] prices) {\\n        int currentMinPrice = prices.length > 0 ? prices[0] : 0;\\n        int profit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            currentMinPrice = Math.min(currentMinPrice, prices[i]);\\n            profit = Math.max(profit, prices[i] - currentMinPrice); \\n        }\\n        return profit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1735436,
                "title": "c-solutions-using-kadane-s-algorithm",
                "content": "smjh\\n```\\nint maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int maxprofit = 0;\\n        int minvalue = INT_MAX;\\n        for(int i =0;i<n;i++){\\n            minvalue = min(prices[i],minvalue);\\n            maxprofit= max(maxprofit,prices[i] - minvalue);\\n        }\\n        return maxprofit;\\n    }\\n```\\nDo upvote if you find it helpful",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int maxprofit = 0;\\n        int minvalue = INT_MAX;\\n        for(int i =0;i<n;i++){\\n            minvalue = min(prices[i],minvalue);\\n            maxprofit= max(maxprofit,prices[i] - minvalue);\\n        }\\n        return maxprofit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144842,
                "title": "several-solutions-in-python",
                "content": "We only want to buy once, sell once.\\n\\n**Brute force** - compare each element, find max diff\\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        max_so_far = 0\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                max_so_far = max(max_so_far, p[j] - p[i])\\n                \\n        return max_so_far           \\n```\\nTime: `O(n^2)`\\nSpace: `O(1)`\\n\\n**Kadane\\'s algorithm** \\nIf the \"profit so far\" `cur` becomes negative, start from 0.\\nOtherwise add it to current diff `p[i] - p[i-1]` and update `max_so_far` (max profit so far).\\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        max_so_far, cur = 0, 0\\n        \\n        for i in range(1,n):\\n            cur = max(cur + p[i] - p[i-1], 0)\\n            max_so_far = max(cur, max_so_far)\\n        return max_so_far           \\n```\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n**Comparing with min**\\nKeep the `min_so_far` (min element so far) value along with `max_so_far` (max profit so far).\\nFind the diff of `p[i]` with `min_so_far` at each step and update `max_so_far` if it exceeds it.\\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        min_so_far, max_so_far = math.inf, 0\\n        \\n        for i in range(n):\\n            cur = p[i] - min_so_far\\n            max_so_far = max(cur, max_so_far)\\n            min_so_far = min(min_so_far, p[i])\\n        return max_so_far\\n```\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n**Slightly more Pythonic or one-liner solution**\\n```\\ndef maxProfit(self, p):\\n        res, min_so_far = 0, math.inf\\n        \\n        for p1 in p:\\n            res, min_so_far = max(res, p1 - min_so_far), min(min_so_far, p1)\\n        \\n        return res\\n```\\nTime: `O(n)`\\nSpace: `O(1)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        max_so_far = 0\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                max_so_far = max(max_so_far, p[j] - p[i])\\n                \\n        return max_so_far           \\n```\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        max_so_far, cur = 0, 0\\n        \\n        for i in range(1,n):\\n            cur = max(cur + p[i] - p[i-1], 0)\\n            max_so_far = max(cur, max_so_far)\\n        return max_so_far           \\n```\n```\\n    def maxProfit(self, p):\\n        n = len(p)\\n        min_so_far, max_so_far = math.inf, 0\\n        \\n        for i in range(n):\\n            cur = p[i] - min_so_far\\n            max_so_far = max(cur, max_so_far)\\n            min_so_far = min(min_so_far, p[i])\\n        return max_so_far\\n```\n```\\ndef maxProfit(self, p):\\n        res, min_so_far = 0, math.inf\\n        \\n        for p1 in p:\\n            res, min_so_far = max(res, p1 - min_so_far), min(min_so_far, p1)\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1659852,
                "title": "easy-c-solution-in-few-line-of-code",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- The idea is quite simple, we\\u2019ve to find the max profit by selling the stocks.\\n- We took 2 int variables: **mn** *(to store the minimum till a particular date)* **& ans.**\\n- Run a for loop and in every time check for the minimum value till that iteration and store it in mn ~**min(mn, prices[i])**.\\n- Also, find the ans with **max(ans, prices[i]-mn)**.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Solution:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int mn= INT_MAX;\\n        int ans=0;\\n        \\n        for(int i=0; i<n; i++){\\n            mn = min(mn, prices[i]);\\n            ans = max(ans, prices[i]-mn);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n= prices.size();\\n        int mn= INT_MAX;\\n        int ans=0;\\n        \\n        for(int i=0; i<n; i++){\\n            mn = min(mn, prices[i]);\\n            ans = max(ans, prices[i]-mn);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057073,
                "title": "simple-o-n-java-solution",
                "content": "```\\n     public int maxProfit(int[] prices) {\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n        for(int price:prices){\\n            minPrice = Math.min(minPrice,price);\\n            maxProfit = Math.max(maxProfit,price-minPrice);\\n        }\\n        return maxProfit;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     public int maxProfit(int[] prices) {\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n        for(int price:prices){\\n            minPrice = Math.min(minPrice,price);\\n            maxProfit = Math.max(maxProfit,price-minPrice);\\n        }\\n        return maxProfit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39281,
                "title": "java-simple-solution",
                "content": "  public int maxProfit(int[] prices) {\\n    \\n        int le = prices.length, maxD = 0, min = Integer.MAX_VALUE;\\n    \\n        for (int i = 0; i < le; i++){ \\n            min = Math.min(min, prices[i]);\\n            maxD = Math.max(maxD, prices[i] - min);\\n        }\\n\\n        return maxD;       \\n}",
                "solutionTags": [],
                "code": "  public int maxProfit(int[] prices) {\\n    \\n        int le = prices.length, maxD = 0, min = Integer.MAX_VALUE;\\n    \\n        for (int i = 0; i < le; i++){ \\n            min = Math.min(min, prices[i]);\\n            maxD = Math.max(maxD, prices[i] - min);\\n        }\\n\\n        return maxD;       \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1932147,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of prices.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var minPrice = Int.max\\n        var ans = 0\\n        \\n        for price in prices {\\n            minPrice = min(minPrice, price)\\n            ans = max(ans, price - minPrice)\\n        }\\n        \\n        return ans        \\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of prices.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var minPrice = Int.max\\n        var ans = 0\\n        \\n        for price in prices {\\n            minPrice = min(minPrice, price)\\n            ans = max(ans, price - minPrice)\\n        }\\n        \\n        return ans        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161290,
                "title": "simple-o-n-python-solution",
                "content": "920ms, faster than 96.58%\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        best_price_to_buy = prices[0]\\n        for price in prices:\\n            if price < best_price_to_buy:\\n                best_price_to_buy = price\\n            elif price > best_price_to_buy:\\n                profit = price - best_price_to_buy\\n                if profit > max_profit:\\n                    max_profit = profit\\n        return max_profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        best_price_to_buy = prices[0]\\n        for price in prices:\\n            if price < best_price_to_buy:\\n                best_price_to_buy = price\\n            elif price > best_price_to_buy:\\n                profit = price - best_price_to_buy\\n                if profit > max_profit:\\n                    max_profit = profit\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822579,
                "title": "easy-c-o-n-soln-faang-interview-optimized-code",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\uD83D\\uDCA1\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int low = prices[0], curr_profit = 0, ovr_profit = 0;\\n        for(int  i = 1; i < prices.size(); i++){\\n            if(prices[i]<low){\\n                low = prices[i];\\n            }\\n            curr_profit = prices[i]-low;\\n            if(curr_profit > ovr_profit)\\n                ovr_profit = curr_profit;\\n        }\\n        return ovr_profit;\\n    }\\n};\\n```\\n\\n# **Please Upvote if it helps \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int low = prices[0], curr_profit = 0, ovr_profit = 0;\\n        for(int  i = 1; i < prices.size(); i++){\\n            if(prices[i]<low){\\n                low = prices[i];\\n            }\\n            curr_profit = prices[i]-low;\\n            if(curr_profit > ovr_profit)\\n                ovr_profit = curr_profit;\\n        }\\n        return ovr_profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735444,
                "title": "5-lines-sol-c-easy-to-undersatand",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxpro = 0;\\n        int minprice = INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minprice=min(prices[i],minprice);\\n            maxpro=max(maxpro,prices[i]-minprice);\\n        }\\n        return maxpro;\\n    }\\n};\\n\\nTC : O(n)\\nSC : O(1)\\n\\nfeel free to ask your doubts :)\\nand ps upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2048073,
                "title": "go-clean-solution-beats-100-runtime",
                "content": "```\\nfunc maxProfit(prices []int) int {\\n    var profit = 0\\n    var minPrice = prices[0]\\n    \\n    for i := 1; i < len(prices); i++ {\\n        // If we find any price which is lower than the current minPrice\\n        // update the minPrice\\n        if prices[i] < minPrice {\\n            minPrice = prices[i]\\n        } else if (prices[i] - minPrice) > profit {\\n            // If diff of current stock with minPrice is greater\\n            // update the profit\\n            profit = prices[i] - minPrice\\n        }\\n    }\\n    \\n    return profit\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxProfit(prices []int) int {\\n    var profit = 0\\n    var minPrice = prices[0]\\n    \\n    for i := 1; i < len(prices); i++ {\\n        // If we find any price which is lower than the current minPrice\\n        // update the minPrice\\n        if prices[i] < minPrice {\\n            minPrice = prices[i]\\n        } else if (prices[i] - minPrice) > profit {\\n            // If diff of current stock with minPrice is greater\\n            // update the profit\\n            profit = prices[i] - minPrice\\n        }\\n    }\\n    \\n    return profit\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312541,
                "title": "easy-o-n-tc-o-1-sc-solution-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int buy=prices[0],ans=0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            ans=max(ans,prices[i]-buy);\\n            buy=min(buy,prices[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code.Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int buy=prices[0],ans=0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            ans=max(ans,prices[i]-buy);\\n            buy=min(buy,prices[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461359,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let min = prices[0], max = 0;\\n    \\n    for(let i = 1; i < prices.length; i++){\\n        if(prices[i] - min > max){\\n            max = prices[i] - min;\\n        }\\n        \\n        if(prices[i] < min) min = prices[i]\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let min = prices[0], max = 0;\\n    \\n    for(let i = 1; i < prices.length; i++){\\n        if(prices[i] - min > max){\\n            max = prices[i] - min;\\n        }\\n        \\n        if(prices[i] < min) min = prices[i]\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 211020,
                "title": "c-0ms",
                "content": "```\\n    int i =0;\\n    int min = prices[i];\\n    int profit =0;\\n    \\n    for(i=1;i<pricesSize;i++){\\n        if(prices[i]>min){\\n            \\n            profit = (prices[i]-min>=profit)?(prices[i]-min):profit;\\n        }\\n        else\\n            min = prices[i];\\n    \\n    }\\n    \\n    \\n    return profit;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    int i =0;\\n    int min = prices[i];\\n    int profit =0;\\n    \\n    for(i=1;i<pricesSize;i++){\\n        if(prices[i]>min){\\n            \\n            profit = (prices[i]-min>=profit)?(prices[i]-min):profit;\\n        }\\n        else\\n            min = prices[i];\\n    \\n    }\\n    \\n    \\n    return profit;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39328,
                "title": "c-simple-solution",
                "content": "    int maxProfit(vector<int>& prices) {\\n        int ret = 0, max = 0;\\n        for(int i = 1; i < prices.size(); i++)\\n        {\\n            ret += prices[i] - prices[i-1];\\n            if(ret < 0) ret = 0;\\n            if(ret > max) max = ret;\\n         }\\n         return max;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int maxProfit(vector<int>& prices) {\\n        int ret = 0, max = 0;\\n        for(int i = 1; i < prices.size(); i++)\\n        {\\n            ret += prices[i] - prices[i-1];\\n            if(ret < 0) ret = 0;\\n            if(ret > max) max = ret;\\n         }\\n         return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2791216,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802390,
                "title": "python-go-js-c-o-n-by-dp-w-visualization",
                "content": "Python O(n) by DP + State machine\\n\\n---\\n\\n**State machine diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/1128f24f-0acb-48cd-9de3-13c49ccde4a9_1597935823.84157.png)\\n\\n---\\n\\n**Implementation** by bottom-up DP with state machine:\\n<iframe src=\"https://leetcode.com/playground/MSLnVn8i/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n---\\n\\n**Implementation** by Top-down DP + recursion\\n<iframe src=\"https://leetcode.com/playground/RZLuFL45/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n---\\n\\nShare another viewpoint dp solution\\n<iframe src=\"https://leetcode.com/playground/TBNQ8rNj/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\n---\\n\\nCorresponding equvilent top-down DP + recusrion\\n<iframe src=\"https://leetcode.com/playground/k5WUoupZ/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "Python O(n) by DP + State machine\\n\\n---\\n\\n**State machine diagram**:\\n\\n![image](https://assets.leetcode.com/users/images/1128f24f-0acb-48cd-9de3-13c49ccde4a9_1597935823.84157.png)\\n\\n---\\n\\n**Implementation** by bottom-up DP with state machine:\\n<iframe src=\"https://leetcode.com/playground/MSLnVn8i/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n---\\n\\n**Implementation** by Top-down DP + recursion\\n<iframe src=\"https://leetcode.com/playground/RZLuFL45/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n---\\n\\nShare another viewpoint dp solution\\n<iframe src=\"https://leetcode.com/playground/TBNQ8rNj/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\n---\\n\\nCorresponding equvilent top-down DP + recusrion\\n<iframe src=\"https://leetcode.com/playground/k5WUoupZ/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---",
                "codeTag": "Unknown"
            },
            {
                "id": 853090,
                "title": "javascript-clean-one-pass-solution",
                "content": "```javascript\\nvar maxProfit = function(prices) {\\n    let maxProf = 0, curr = prices[0];\\n    \\n    for(let x of prices) {\\n        if(curr < x) maxProf = Math.max(maxProf, x - curr);\\n        else curr = x;\\n    }\\n    return maxProf;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxProfit = function(prices) {\\n    let maxProf = 0, curr = prices[0];\\n    \\n    for(let x of prices) {\\n        if(curr < x) maxProf = Math.max(maxProf, x - curr);\\n        else curr = x;\\n    }\\n    return maxProf;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132879,
                "title": "exhaustive-search-dp-with-explanation-java-python",
                "content": "> **Exhaustive Search**\\nThe problem is to get the maximum (prices[j] - prices[i]) for 0 <= i < j <= price.length,\\nAny price maycanbe the candidate prices[j].\\nTo get the maximum (prices[j] - prices[i]), prices[i] should be the minimum value to the left of prices[j].\\n```\\n    public int maxProfit(int[] prices) {\\n        int minPriceSoFar = Integer.MAX_VALUE, maxProfitSoFar = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (minPriceSoFar > prices[i]) {\\n                minPriceSoFar = prices[i];\\n            } else {\\n                maxProfitSoFar = Math.max(maxProfitSoFar, prices[i] - minPriceSoFar);\\n            }\\n        }\\n        \\n        return maxProfitSoFar;\\n    }\\n```\\n\\n> **Dynamic Programming**\\nThe maximum profit is actually the maximum consecutively increasing difference.\\nThe maximum consecutively increasing difference can end at any element in nums.\\nThe maximum consecutively increasing difference ending at position i + 1 is\\neither includes maximum consecutively increasing difference ending at position i or it doesn\\'t.\\nThat can be solved in the way similar to [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/discuss/132821/DP-Thinking-Process-with-Java-Code).\\n****\\n```\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length, maxProfitSoFar = 0;\\n        // maxIncDiffSum[i] max sum of increasing difference ending at prices[i].\\n        int[] maxIncDiffSum = new int[n];\\n        \\n        for (int i = 1; i < n; i++) {\\n            maxIncDiffSum[i] = Math.max(0, maxIncDiffSum[i - 1] + prices[i] - prices[i - 1]);\\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxIncDiffSum[i]);\\n        }\\n        \\n        return maxProfitSoFar;\\n    }\\n```\\n```\\n    def maxProfit(self, prices):\\n        if len(prices) <= 1:\\n            return 0\\n        \\n        lenPrices = len(prices)\\n        state = [0] * lenPrices\\n        for i in range(1, lenPrices):\\n            state[i] = max(state[i - 1] + prices[i] - prices[i - 1], 0)   \\n            \\n        return max(state)\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public int maxProfit(int[] prices) {\\n        int minPriceSoFar = Integer.MAX_VALUE, maxProfitSoFar = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (minPriceSoFar > prices[i]) {\\n                minPriceSoFar = prices[i];\\n            } else {\\n                maxProfitSoFar = Math.max(maxProfitSoFar, prices[i] - minPriceSoFar);\\n            }\\n        }\\n        \\n        return maxProfitSoFar;\\n    }\\n```\n```\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length, maxProfitSoFar = 0;\\n        // maxIncDiffSum[i] max sum of increasing difference ending at prices[i].\\n        int[] maxIncDiffSum = new int[n];\\n        \\n        for (int i = 1; i < n; i++) {\\n            maxIncDiffSum[i] = Math.max(0, maxIncDiffSum[i - 1] + prices[i] - prices[i - 1]);\\n            maxProfitSoFar = Math.max(maxProfitSoFar, maxIncDiffSum[i]);\\n        }\\n        \\n        return maxProfitSoFar;\\n    }\\n```\n```\\n    def maxProfit(self, prices):\\n        if len(prices) <= 1:\\n            return 0\\n        \\n        lenPrices = len(prices)\\n        state = [0] * lenPrices\\n        for i in range(1, lenPrices):\\n            state[i] = max(state[i - 1] + prices[i] - prices[i - 1], 0)   \\n            \\n        return max(state)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3418898,
                "title": "c-easy-dp-very-short-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int mn=p[0];\\n        int ans=0;\\n        for(int i=1;i<p.size();i++){\\n          ans=max(ans,p[i]-mn);\\n          mn=min(mn,p[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/e73ffd6a-40e6-4d94-948a-a970bd55b51a_1681547184.833364.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& p) {\\n        int mn=p[0];\\n        int ans=0;\\n        for(int i=1;i<p.size();i++){\\n          ans=max(ans,p[i]-mn);\\n          mn=min(mn,p[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317146,
                "title": "c",
                "content": "```CSHARP\\npublic int MaxProfit(int[] prices)\\n{\\n\\tif (prices.Length == 0) return 0;\\n\\n\\tint min = int.MaxValue;\\n\\tint max = int.MinValue;\\n\\n\\tfor(int i = 0; i < prices.Length; i++)\\n\\t{\\n\\t\\tmin = Math.Min(min, prices[i]);\\n\\t\\tmax = Math.Max(max, prices[i] - min);\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```CSHARP\\npublic int MaxProfit(int[] prices)\\n{\\n\\tif (prices.Length == 0) return 0;\\n\\n\\tint min = int.MaxValue;\\n\\tint max = int.MinValue;\\n\\n\\tfor(int i = 0; i < prices.Length; i++)\\n\\t{\\n\\t\\tmin = Math.Min(min, prices[i]);\\n\\t\\tmax = Math.Max(max, prices[i] - min);\\n\\t}\\n\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178695,
                "title": "c-solution-simple-optimized-solution-tc-o-n",
                "content": "**Explanation: Optimized Solution || T.C -> O(n)**\\n\\n* Take `maxProf` to store maximum profit.\\n* Take `minPrice` to store the minimal price to the left and initialize it with `INT_MAX` or `1e9`.\\n* Now linearly traverse from left to right and update the `minPrice` at every stage and after that try to sell it where profit will be price at that instance minus minimal price.\\n* Then we compare the current profit with the maximum profit and update the `maxProf`.\\n* After the traversal is over, we return the `maxProf`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProf = 0;\\n        int minPrice = INT_MAX;\\n        \\n        for(int i = 0; i<prices.size(); i++)\\n        {\\n            minPrice = min(minPrice,prices[i]);\\n            maxProf = max(maxProf, prices[i] - minPrice);\\n        }\\n        \\n        return maxProf;\\n    }\\n};\\n```\\n\\n**Please upvote if you find the solution useful, means a lot.**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProf = 0;\\n        int minPrice = INT_MAX;\\n        \\n        for(int i = 0; i<prices.size(); i++)\\n        {\\n            minPrice = min(minPrice,prices[i]);\\n            maxProf = max(maxProf, prices[i] - minPrice);\\n        }\\n        \\n        return maxProf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987099,
                "title": "javascript-solution-with-explanation-and-comments",
                "content": "This problem can be solved using a sliding window/two-pointer technique. The reason that works is that we\\'ve got an array-based problem statement, and we want to calculate information about certain sub-sections of the array. A fast way to do this, in linear time, is to use two pointers that move through the set of data.\\n\\nWe\\'ll track a few things:\\n\\n1. We\\'ll track a maximum profit. That will start at 0, so we can have a good default value in case there are no profits available (in the case that the stock price only goes down)\\n1. We\\'ll track a left pointer. The left pointer will start at the beginning of the array.\\n1. We\\'ll track a right pointer. The right pointer will start at the beginning of the array + 1 - just after the left pointer.\\n\\nAt each step, we\\'ll subtract the value at the left pointer position from the right pointer position. If that value is greater than the current max, we\\'ll track it as the new max. In the case where the value is greater than the current max, we\\'ll increment the right pointer by one to see if there\\'s a better profit available. The left pointer will stay in the same place.\\n\\nIf the value isn\\'t greater than the max, but is positive, we\\'ll still move the right pointer, just to see if there are better days in the future to sell.\\n\\nIf, when we subtract the left pointer from the right pointer, there\\'s a negative value, it means that the value at the left can\\'t be the minimum price at all. In fact, it means that the value at the right pointer is our new lowest. So we update the left pointer to the right pointer position, and increment the right pointer again.\\n\\nWe\\'ll repeat this until the right pointer has exceeded the length of the array, at which point, we return the max.\\n\\nHere\\'s how to write that in JavaScript:\\n\\n```js\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    // Set up variables to track the max profit we\\'ve seen (init at 0),\\n    // the left pointer (init at day 0)\\n    // and the right pointer (init at day 1, since we can\\'t buy/sell on the same day)\\n    let max = 0\\n    let left = 0\\n    let right = 1\\n    \\n    // Keep incrementing the right pointer until we hit the end of the prices array.\\n    while (right < prices.length) {\\n\\n        // The profit on any given day is the difference between the sell date (represented by right pointer)\\n        // and buy date (represented by the left pointer)\\n        const profit = prices[right] - prices[left]\\n        \\n        // If we can get a profit higher than we\\'ve seen before, set it as our maximum,\\n        // and we\\'ll keep going.\\n        if (profit > max) {\\n            max = profit\\n        }\\n        \\n        // If today would be a loss, it means two things: \\n        // 1. We don\\'t have a new maximum.\\n        // 2. We just found a day on which we could buy at a lower price than before, so we should buy now.\\n        // \\n        // The implication of point two is that we move our left pointer (again, as a sliding window) to be the current day,\\n        // as represented by the right pointer.\\n        if (profit < 0) {\\n            left = right\\n        }\\n        \\n        // Increment the right pointer to keep searching.\\n        right += 1\\n    }\\n    \\n    // This will return 0 if we had no possible profit, since we initialized at 0,\\n    // or the maximum profit possible.\\n    return max\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    // Set up variables to track the max profit we\\'ve seen (init at 0),\\n    // the left pointer (init at day 0)\\n    // and the right pointer (init at day 1, since we can\\'t buy/sell on the same day)\\n    let max = 0\\n    let left = 0\\n    let right = 1\\n    \\n    // Keep incrementing the right pointer until we hit the end of the prices array.\\n    while (right < prices.length) {\\n\\n        // The profit on any given day is the difference between the sell date (represented by right pointer)\\n        // and buy date (represented by the left pointer)\\n        const profit = prices[right] - prices[left]\\n        \\n        // If we can get a profit higher than we\\'ve seen before, set it as our maximum,\\n        // and we\\'ll keep going.\\n        if (profit > max) {\\n            max = profit\\n        }\\n        \\n        // If today would be a loss, it means two things: \\n        // 1. We don\\'t have a new maximum.\\n        // 2. We just found a day on which we could buy at a lower price than before, so we should buy now.\\n        // \\n        // The implication of point two is that we move our left pointer (again, as a sliding window) to be the current day,\\n        // as represented by the right pointer.\\n        if (profit < 0) {\\n            left = right\\n        }\\n        \\n        // Increment the right pointer to keep searching.\\n        right += 1\\n    }\\n    \\n    // This will return 0 if we had no possible profit, since we initialized at 0,\\n    // or the maximum profit possible.\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735384,
                "title": "python-o-n-solution-for-2-1-22-daily",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        lowest_price, best_profit = float(\"inf\"), 0\\n        for price in prices:\\n            profit = price - lowest_price\\n            best_profit = max(profit, best_profit)\\n            lowest_price = min(price, lowest_price)\\n        return best_profit\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        lowest_price, best_profit = float(\"inf\"), 0\\n        for price in prices:\\n            profit = price - lowest_price\\n            best_profit = max(profit, best_profit)\\n            lowest_price = min(price, lowest_price)\\n        return best_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712254,
                "title": "2-approaches-dp-recursion-time-o-n-space-o-1",
                "content": "```\\n// Time - O(n) Space - O(1)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        return getMaxProfit(prices, 0, Integer.MAX_VALUE, 0);\\n    }\\n    \\n    public int getMaxProfit(int[] prices, int index, int minStockPrice, int maxDiff) {\\n        if(prices.length == index) {\\n            return maxDiff;\\n        }\\n         int earn =  prices[index] - minStockPrice;\\n         maxDiff = Math.max(earn, maxDiff);\\n         minStockPrice = Math.min(minStockPrice, prices[index]);\\n        return getMaxProfit(prices, ++index, minStockPrice, maxDiff);\\n    }\\n}\\n\\n// Time - O(n) Space - O(1)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        return getMaxProfit(prices);\\n    }\\n    \\n    public int getMaxProfit(int[] prices) {\\n        int minStockPrice = Integer.MAX_VALUE, maxDiff = 0;\\n        for(int i = 0; i < prices.length; i++) {\\n            int earn =  prices[i] - minStockPrice;\\n            maxDiff = Math.max(earn, maxDiff);\\n            minStockPrice = Math.min(minStockPrice, prices[i]);\\n        }\\n        return maxDiff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n// Time - O(n) Space - O(1)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        return getMaxProfit(prices, 0, Integer.MAX_VALUE, 0);\\n    }\\n    \\n    public int getMaxProfit(int[] prices, int index, int minStockPrice, int maxDiff) {\\n        if(prices.length == index) {\\n            return maxDiff;\\n        }\\n         int earn =  prices[index] - minStockPrice;\\n         maxDiff = Math.max(earn, maxDiff);\\n         minStockPrice = Math.min(minStockPrice, prices[index]);\\n        return getMaxProfit(prices, ++index, minStockPrice, maxDiff);\\n    }\\n}\\n\\n// Time - O(n) Space - O(1)\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        return getMaxProfit(prices);\\n    }\\n    \\n    public int getMaxProfit(int[] prices) {\\n        int minStockPrice = Integer.MAX_VALUE, maxDiff = 0;\\n        for(int i = 0; i < prices.length; i++) {\\n            int earn =  prices[i] - minStockPrice;\\n            maxDiff = Math.max(earn, maxDiff);\\n            minStockPrice = Math.min(minStockPrice, prices[i]);\\n        }\\n        return maxDiff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400573,
                "title": "python3-beats-93-61-with-comments",
                "content": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # Max profit and price to buy\\n        max_profit = 0\\n        high_buy = 0\\n        \\n        # Reverse the array of prices\\n        prices = prices[::-1]\\n        \\n        # Check each price to sell at compared to the highest buy price ahead of it\\n        for price in prices:\\n            # Update highest buy price in front of price\\n            if price > high_buy:\\n                high_buy = price\\n            # Check if this sale make higher profit than sales later in original array\\n            if high_buy - price > max_profit:\\n                max_profit = high_buy - price\\n                \\n        # Return the highest profit achieved\\n        return max_profit\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # Max profit and price to buy\\n        max_profit = 0\\n        high_buy = 0\\n        \\n        # Reverse the array of prices\\n        prices = prices[::-1]\\n        \\n        # Check each price to sell at compared to the highest buy price ahead of it\\n        for price in prices:\\n            # Update highest buy price in front of price\\n            if price > high_buy:\\n                high_buy = price\\n            # Check if this sale make higher profit than sales later in original array\\n            if high_buy - price > max_profit:\\n                max_profit = high_buy - price\\n                \\n        # Return the highest profit achieved\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676718,
                "title": "java-code-to-find-best-time-to-buy-and-sell-stocks",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int left = 0, right = 1,max = 0;\\n        while(right < prices.length){\\n            if(prices[left] > prices[right]){\\n                left = right;\\n            }else if(prices[left] < prices[right]){\\n                max = Math.max(max,(prices[right] - prices[left]));\\n            }\\n            right++;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n## **If you find this helpful, please upvote \\uD83D\\uDE0A**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int left = 0, right = 1,max = 0;\\n        while(right < prices.length){\\n            if(prices[left] > prices[right]){\\n                left = right;\\n            }else if(prices[left] < prices[right]){\\n                max = Math.max(max,(prices[right] - prices[left]));\\n            }\\n            right++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520779,
                "title": "c-java-python-javascript-simple-code-easy-to-understand",
                "content": "# Intuition:\\nThe intuition behind this solution is to find the maximum profit by keeping track of the minimum price encountered so far. By iterating over the prices, we update the minimum price if we find a smaller price. Then, we calculate the profit by subtracting the minimum price from the current price, and update the maximum profit if it is larger.\\n\\n# Approach:\\n1. Initialize the variables `profit` and `minPrice` to 0 and INT_MAX respectively.\\n2. Iterate over the `prices` vector using a for loop, with index `i` ranging from 0 to `prices.size() - 1`.\\n3. Inside the loop, update the `minPrice` by taking the minimum of the current `minPrice` and the price at index `i`.\\n4. Calculate the profit by subtracting the `minPrice` from the price at index `i`.\\n5. Update the `profit` by taking the maximum of the current `profit` and the calculated profit.\\n6. After the loop ends, return the `profit`.\\n\\n# Complexity:\\n- The time complexity of this solution is O(n), where n is the size of the `prices` vector, as we iterate over the vector once.\\n- The space complexity is O(1) as we only use a constant amount of additional space to store the variables `profit` and `minPrice`.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minPrice=INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n            profit = max(profit,prices[i]-minPrice);\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int minPrice = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            profit = Math.max(profit, prices[i] - minPrice);\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        minPrice = float(\"inf\")\\n        for price in prices:\\n            minPrice = min(minPrice, price)\\n            profit = max(profit, price - minPrice)\\n        return profit\\n\\n```\\n---\\n# JavaScript\\n```\\nvar maxProfit = function(prices) {\\n    let profit = 0;\\n    let minPrice = Number.MAX_VALUE;\\n    for (let i = 0; i < prices.length; i++) {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        profit = Math.max(profit, prices[i] - minPrice);\\n    }\\n    return profit;  \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minPrice=INT_MAX;\\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n            profit = max(profit,prices[i]-minPrice);\\n        }\\n        return profit;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int minPrice = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            profit = Math.max(profit, prices[i] - minPrice);\\n        }\\n        return profit;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        minPrice = float(\"inf\")\\n        for price in prices:\\n            minPrice = min(minPrice, price)\\n            profit = max(profit, price - minPrice)\\n        return profit\\n\\n```\n```\\nvar maxProfit = function(prices) {\\n    let profit = 0;\\n    let minPrice = Number.MAX_VALUE;\\n    for (let i = 0; i < prices.length; i++) {\\n        minPrice = Math.min(minPrice, prices[i]);\\n        profit = Math.max(profit, prices[i] - minPrice);\\n    }\\n    return profit;  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422184,
                "title": "javascript-best-time-to-buy-and-sell-stock-written-explanation-code",
                "content": "# Table of Contents:\\n* High level overview of the problem\\n* Translate words to solution\\n* Code demo\\n\\n## **High level overview of the problem:**\\n\\n*You are given an array prices where prices[i] is the price of a given stock on the ith day.*\\n\\n*You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.*\\n\\n*Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.*\\n\\nWhen it comes to buying stocks in real life, you want to buy low and sell high. The concept is applied in this problem. We need to keep track of two prices in order to get a positive profit.\\n\\n**There are 2 ways to solve this problem:**\\n1. Brute Force\\n2. Greedy Algorithm\\n\\n## **Translate words to solution:**\\n\\n**Solution #1 Brute Force:**\\n\\nIf we iterate over the array with one for loop (buy price), we need an additional for loop (sell price) to scan the elements to the right of it. The reason we need a second for loop is because we need the buy price from the first for loop so that we can subtract the sell price in the second for loop. If we can loop over the elements with two for loops then we can generate the combinations to achieve a maximum profit. \\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(1)\\n\\n**Solution #2 Greedy Algorithm:**\\n\\nThe idea of the greedy algorithm is keep track of the locally optimal solution that will eventually build up to an optimal global solution. \\n\\nIn order for us to get a locally optimal solution we need to keep track of the minimum buy price, the maximum sell price, and the current profit. The formula for getting the current profit is equal to buy price subtracted by the sell price.\\n\\nOn every iteration, we simultaneously check if the current profit is greater than the global profit, if it is then we update the global profit to equal our current profit. \\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n## **Code demo:**\\n\\n**Solution #1 Brute Force:**\\n\\n```\\nfunction maxProfit(prices) {\\n  let globalProfit = 0;\\n\\t// the reason prices.length - 1 is because we are using the second for loop to scan every element to the right of i\\n  for (let i = 0; i < prices.length - 1; i++) {\\n\\t  // the reason j is i + 1 is because we are scanning all the combinations of the first for loop\\n    for (let j = i + 1; j < prices.length; j++) {\\n      const currentProfit = prices[j] - prices[i]\\n\\n      if (currentProfit > globalProfit) {\\n        globalProfit = currentProfit\\n      }\\n    }\\n  }\\n\\n  return globalProfit;\\n}\\n\\n```\\n\\n**Solution #2 Greedy Algorithm:**\\n\\n```\\nfunction maxProfit(prices) {\\n  let globalProfit = 0;\\n  // minBuyPrice is set to Infinity because we can guarantee the first element will be set to the buy price \\n  let minBuyPrice = Infinity;\\n\\n  for (let i = 0; i < prices.length; i++) {\\n    if (minBuyPrice > prices[i]) {\\n      minBuyPrice = prices[i];\\n    }\\n\\n    const currentProfit = prices[i] - minBuyPrice;\\n\\n    if (currentProfit > globalProfit) {\\n      globalProfit = currentProfit;\\n    }\\n  }\\n\\n  return globalProfit;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction maxProfit(prices) {\\n  let globalProfit = 0;\\n\\t// the reason prices.length - 1 is because we are using the second for loop to scan every element to the right of i\\n  for (let i = 0; i < prices.length - 1; i++) {\\n\\t  // the reason j is i + 1 is because we are scanning all the combinations of the first for loop\\n    for (let j = i + 1; j < prices.length; j++) {\\n      const currentProfit = prices[j] - prices[i]\\n\\n      if (currentProfit > globalProfit) {\\n        globalProfit = currentProfit\\n      }\\n    }\\n  }\\n\\n  return globalProfit;\\n}\\n\\n```\n```\\nfunction maxProfit(prices) {\\n  let globalProfit = 0;\\n  // minBuyPrice is set to Infinity because we can guarantee the first element will be set to the buy price \\n  let minBuyPrice = Infinity;\\n\\n  for (let i = 0; i < prices.length; i++) {\\n    if (minBuyPrice > prices[i]) {\\n      minBuyPrice = prices[i];\\n    }\\n\\n    const currentProfit = prices[i] - minBuyPrice;\\n\\n    if (currentProfit > globalProfit) {\\n      globalProfit = currentProfit;\\n    }\\n  }\\n\\n  return globalProfit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979892,
                "title": "java-all-approach-recursive-dp-kadane-s-algorithm",
                "content": "**Algorithm**\\n* This is one of the popular interview question and I would like to expalin in a way that I understood\\n\\n**Recursive Approach**\\n* The base case is that if the index passed to the recursive function has reached the `prices` array length, if so `return 0`\\n* compute the minimum of the current item, `prices[index]` so that when we backtrack after the recursive call we can compute `maxProfit` by comparing with the current element difference with the `prices[index]`\\n* recursively call the function by incrementing the `index`, the value that will be returned from recursive call is the `maxProfit`\\n* after coming from the recursive call, we cmpute the maxProfit with the current element `prices[index] - min` element found before recursing.\\n\\n```\\nclass Solution {\\n     protected int dfs(int[] prices, int index, int min){\\n         if (index == prices.length)\\n             return 0;\\n        \\n         int minimumEndingHere = Math.min(min, prices[index]);\\n         int maxProfit = dfs(prices, index + 1, minimumEndingHere);\\n         maxProfit = Math.max(maxProfit, prices[index] - min);\\n         return maxProfit;\\n     }\\n     public int maxProfit(int[] prices) {\\n         return dfs(prices, 0, Integer.MAX_VALUE);\\n   }\\n}\\n```\\n\\n**O(N) - Bottom Up Approach**\\n* start with having the dp array of the length of the `prices` array\\n* At each index store the max of the difference with the `prices[i]` with `min` that was computed earlier\\n* update the `min` everytime comparing with the current price\\n\\n```\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n        if (prices.length == 0)\\n            return 0;\\n        int[] dp = new int[prices.length];\\n        int min = prices[0];\\n    \\n        for (int i=1;i<prices.length;i++){\\n            dp[i] = Math.max(dp[i-1], prices[i] - min);\\n            min = Math.min(min, prices[i]);\\n        }\\n        \\n        return dp[prices.length-1];\\n    }\\n}\\n```\\n\\n**O(N) - Kadane\\'s Algorithm**\\n* assign `maxEndingHere` and `minEndingHere` with the first element in the prices array\\n* Loop through the length of the `prices` array\\n* If at any time you see `prices[i] < max`, then assign the `maxEndingHere` to the `prices[i]`, this is because we have to have the max computed after we buy the share for minimum prices. So we need to compute everytime\\n* Get the `maxEndingHere` and `minEndingHere` as the max and min compared with the `prices[i]`\\n* Compute `maxProfit` as the max between computed `maxEndingHere` and the difference of `maxEndingHere` and `minEndingHere`\\n* return the `maxProfit`\\n```\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n\\nif (prices == null || prices.length == 0)\\n     return 0;\\n        int maxProfit = 0;\\n         int maxEndingHere = prices[0];\\n         int minEndingHere = prices[0];\\n        \\n         for (int i=1;i<prices.length;i++){\\n             if (prices[i] < maxEndingHere){\\n                 maxEndingHere = prices[i];\\n             }\\n            maxEndingHere = Math.max(maxEndingHere, prices[i]);\\n            minEndingHere = Math.min(minEndingHere, prices[i]);\\n            maxProfit = Math.max(maxProfit, Math.abs(maxEndingHere-minEndingHere));\\n         }\\n         return maxProfit;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     protected int dfs(int[] prices, int index, int min){\\n         if (index == prices.length)\\n             return 0;\\n        \\n         int minimumEndingHere = Math.min(min, prices[index]);\\n         int maxProfit = dfs(prices, index + 1, minimumEndingHere);\\n         maxProfit = Math.max(maxProfit, prices[index] - min);\\n         return maxProfit;\\n     }\\n     public int maxProfit(int[] prices) {\\n         return dfs(prices, 0, Integer.MAX_VALUE);\\n   }\\n}\\n```\n```\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n        if (prices.length == 0)\\n            return 0;\\n        int[] dp = new int[prices.length];\\n        int min = prices[0];\\n    \\n        for (int i=1;i<prices.length;i++){\\n            dp[i] = Math.max(dp[i-1], prices[i] - min);\\n            min = Math.min(min, prices[i]);\\n        }\\n        \\n        return dp[prices.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n\\nif (prices == null || prices.length == 0)\\n     return 0;\\n        int maxProfit = 0;\\n         int maxEndingHere = prices[0];\\n         int minEndingHere = prices[0];\\n        \\n         for (int i=1;i<prices.length;i++){\\n             if (prices[i] < maxEndingHere){\\n                 maxEndingHere = prices[i];\\n             }\\n            maxEndingHere = Math.max(maxEndingHere, prices[i]);\\n            minEndingHere = Math.min(minEndingHere, prices[i]);\\n            maxProfit = Math.max(maxProfit, Math.abs(maxEndingHere-minEndingHere));\\n         }\\n         return maxProfit;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118512,
                "title": "multiple-c-solutions-with-explaination",
                "content": "**1) Using 2 variables high and low**\\nThis is a sort of DP solution where we store the profits at each day\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int high=0,low=0;\\n        int n = prices.size();\\n        \\n        //Edge Case\\n        if(n<2) return 0;\\n        \\n        //Store Profits at each day\\n        vector<int> profit(n,0);\\n        \\n        high = prices[0];\\n        low = prices[0];\\n        \\n        //For each day\\n        for(int i=1;i<n;i++) {\\n            \\n            //If current day price is grater then Great! Your profit is increasing\\n            if(prices[i]>high) {\\n                high = prices[i];\\n                profit[i] = high-low;\\n            }\\n            \\n            //If you see a new low- you should reset low as this current price and high as 0\\n            //As there can be a bigger margin profit ahead\\n            if(prices[i]<=low) {\\n                profit[i] = high-low;\\n                low = prices[i];\\n                high = 0; //Reset\\n            }\\n            \\n            //For cases where the value is between low and high\\n                profit[i] =high-low;\\n        }\\n        \\n        return *max_element(profit.begin(),profit.end());\\n    }\\n};\\n```\\n\\n\\n\\n**2) Using Max Difference (Unknown Author)**\\nThis also uses 2 variables.\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int min=INT_MAX,maxdiff=0;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            if(prices[i]<min)\\n                min=prices[i];\\n            else\\n                if(prices[i]-min > maxdiff)\\n                    maxdiff = prices[i]-min;\\n        }\\n        \\n        \\n        return maxdiff;\\n    }\\n};\\n```\\n\\n\\n**3) Kadane\\'s Algorithm**\\n\\nCheck this [solution](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39038/Kadane\\'s-Algorithm-Since-no-one-has-mentioned-about-this-so-far-:)\\n\\n\\n**4) Justification for it to be a DP solution**\\nCheck this [post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/39112/Why-is-this-problem-tagged-with-\"Dynamic-programming\"/36893)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int high=0,low=0;\\n        int n = prices.size();\\n        \\n        //Edge Case\\n        if(n<2) return 0;\\n        \\n        //Store Profits at each day\\n        vector<int> profit(n,0);\\n        \\n        high = prices[0];\\n        low = prices[0];\\n        \\n        //For each day\\n        for(int i=1;i<n;i++) {\\n            \\n            //If current day price is grater then Great! Your profit is increasing\\n            if(prices[i]>high) {\\n                high = prices[i];\\n                profit[i] = high-low;\\n            }\\n            \\n            //If you see a new low- you should reset low as this current price and high as 0\\n            //As there can be a bigger margin profit ahead\\n            if(prices[i]<=low) {\\n                profit[i] = high-low;\\n                low = prices[i];\\n                high = 0; //Reset\\n            }\\n            \\n            //For cases where the value is between low and high\\n                profit[i] =high-low;\\n        }\\n        \\n        return *max_element(profit.begin(),profit.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int min=INT_MAX,maxdiff=0;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            if(prices[i]<min)\\n                min=prices[i];\\n            else\\n                if(prices[i]-min > maxdiff)\\n                    maxdiff = prices[i]-min;\\n        }\\n        \\n        \\n        return maxdiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39315,
                "title": "python-different-solutions-dp",
                "content": "       \\n    # DP\\n    def maxProfit1(self, prices):\\n        if not prices:\\n            return 0\\n        loc = glo = 0\\n        for i in xrange(1, len(prices)):\\n            loc = max(loc+prices[i]-prices[i-1], 0)\\n            glo = max(glo, loc)\\n        return glo\\n        \\n    def maxProfit2(self, prices):\\n        if not prices:\\n            return 0\\n        minPri, maxPro = prices[0], 0\\n        for i in xrange(1, len(prices)):\\n            minPri = min(minPri, prices[i])\\n            maxPro = max(maxPro, prices[i]-minPri)\\n        return maxPro\\n        \\n    # Reuse maximum subarray method\\n    def maxProfit(self, prices):\\n        if not prices or len(prices) == 1:\\n            return 0\\n        dp = [0] * len(prices)\\n        for i in xrange(1, len(prices)):\\n            dp[i] = prices[i]-prices[i-1]\\n        glo = loc = dp[0]\\n        for i in xrange(1, len(dp)):\\n            loc = max(loc+dp[i], dp[i])\\n            glo = max(glo, loc)\\n        return glo",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "       \\n    # DP\\n    def maxProfit1(self, prices):\\n        if not prices:\\n            return 0\\n        loc = glo = 0\\n        for i in xrange(1, len(prices)):\\n            loc = max(loc+prices[i]-prices[i-1], 0)\\n            glo = max(glo, loc)\\n        return glo\\n        \\n    def maxProfit2(self, prices):\\n        if not prices:\\n            return 0\\n        minPri, maxPro = prices[0], 0\\n        for i in xrange(1, len(prices)):\\n            minPri = min(minPri, prices[i])\\n            maxPro = max(maxPro, prices[i]-minPri)\\n        return maxPro\\n        \\n    # Reuse maximum subarray method\\n    def maxProfit(self, prices):\\n        if not prices or len(prices) == 1:\\n            return 0\\n        dp = [0] * len(prices)\\n        for i in xrange(1, len(prices)):\\n            dp[i] = prices[i]-prices[i-1]\\n        glo = loc = dp[0]\\n        for i in xrange(1, len(dp)):\\n            loc = max(loc+dp[i], dp[i])\\n            glo = max(glo, loc)\\n        return glo",
                "codeTag": "Python3"
            },
            {
                "id": 2549176,
                "title": "2-pointer-big-o-n-easy-solution",
                "content": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit, l = 0, 0\\n\\n        for r in range(1, len(prices)):\\n            \\n            net = prices[r]-prices[l]\\n            is_profit = net > 0\\n            \\n            if is_profit:\\n                max_profit = max(max_profit, net)\\n            else:\\n                l = r\\n\\n        return max_profit\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit, l = 0, 0\\n\\n        for r in range(1, len(prices)):\\n            \\n            net = prices[r]-prices[l]\\n            is_profit = net > 0\\n            \\n            if is_profit:\\n                max_profit = max(max_profit, net)\\n            else:\\n                l = r\\n\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506973,
                "title": "c-java-python3-javascript-solution-o-n",
                "content": "**Here to see the full explanation :\\u2B50[Zyrastory - #121 Best Time to Buy and Sell Stock](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-121-best-time-to-buy-and-sell-stock-solution-and-explanation-en/)\\u2B50**\\n\\n\\n---\\n\\n# Example :\\n# C#\\n\\u274Cfirst try  - **Time Complexity : O(n^2)**\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        \\n        int max = 0;\\n         for(int i = 0;i<prices.Length-1;i++)\\n         {\\n             for(int j = i+1;j<prices.Length;j++)\\n             {\\n                 int res = prices[j]-prices[i];\\n                 if(res>max)\\n                 {\\n                     max = res;\\n                 }\\n             }\\n         }\\n        return max;\\n    }\\n}\\n```\\n\\nSolution - **Time Complexity : O(n)**\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int max = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.Length;i++){\\n            if(prices[i] < min){\\n                min = prices[i];\\n            }\\n            \\n            else if((prices[i] - min) > max )\\n            {\\n                max = prices[i] - min;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n---\\n\\n# Java\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i] < min){\\n                min = prices[i];\\n            }\\n            \\n            else if((prices[i] - min) > max )\\n            {\\n                max = prices[i] - min;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n---\\n# Python3\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max = 0;\\n        min = prices[0];\\n        \\n        for i in range(1,len(prices)):\\n            if prices[i] < min :\\n                min = prices[i]\\n            \\n            elif((prices[i] - min) > max):\\n                max = prices[i] - min\\n        \\n        return max;\\n```\\n\\n---\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    var max = 0;\\n    var min = prices[0];\\n\\n    for(var i=1;i<prices.length;i++){\\n        if(prices[i] < min){\\n            min = prices[i];\\n        }\\n\\n        else if((prices[i] - min) > max )\\n        {\\n            max = prices[i] - min;\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\n\\n**If you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).**\\n\\nThanks!\\n\\n**\\uD83E\\uDDE1See next question - [Zyrastory - #122 Best Time to Buy and Sell Stock II](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-122-best-time-to-buy-and-sell-stock-ii-solution-and-explanation-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        \\n        int max = 0;\\n         for(int i = 0;i<prices.Length-1;i++)\\n         {\\n             for(int j = i+1;j<prices.Length;j++)\\n             {\\n                 int res = prices[j]-prices[i];\\n                 if(res>max)\\n                 {\\n                     max = res;\\n                 }\\n             }\\n         }\\n        return max;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int max = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.Length;i++){\\n            if(prices[i] < min){\\n                min = prices[i];\\n            }\\n            \\n            else if((prices[i] - min) > max )\\n            {\\n                max = prices[i] - min;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int min = prices[0];\\n        \\n        for(int i=1;i<prices.length;i++){\\n            if(prices[i] < min){\\n                min = prices[i];\\n            }\\n            \\n            else if((prices[i] - min) > max )\\n            {\\n                max = prices[i] - min;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max = 0;\\n        min = prices[0];\\n        \\n        for i in range(1,len(prices)):\\n            if prices[i] < min :\\n                min = prices[i]\\n            \\n            elif((prices[i] - min) > max):\\n                max = prices[i] - min\\n        \\n        return max;\\n```\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    var max = 0;\\n    var min = prices[0];\\n\\n    for(var i=1;i<prices.length;i++){\\n        if(prices[i] < min){\\n            min = prices[i];\\n        }\\n\\n        else if((prices[i] - min) > max )\\n        {\\n            max = prices[i] - min;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493104,
                "title": "c-one-pass-approach-with-explanation",
                "content": "# Intuition: \\nTo maximize the profit, we iterate through the array while keeping track of the minimum price encountered so far. We calculate the potential profit by selling at each price if we had bought at the minimum price. We update the maximum profit whenever a higher profit is obtained.\\n\\n# Approach:\\n- Initialize `minPrice` as the maximum possible value and `maxProfit` as 0.\\n- Iterate through the `prices` array.\\n- For each price, check if it is lower than the current `minPrice`. If so, update `minPrice`.\\n- Calculate the profit by subtracting `minPrice` from the current price.\\n- If the profit is higher than the current `maxProfit`, update `maxProfit`.\\n- Return the final `maxProfit` value.\\n\\n# Complexity:\\n- Time complexity: O(n), where n is the length of the `prices` array. We iterate through the array once.\\n- Space complexity: O(1). We use a constant amount of extra space to store variables.\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int minPrice = int.MaxValue;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.Length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            }\\n            \\n            int profit = prices[i] - minPrice;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int minPrice = int.MaxValue;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.Length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            }\\n            \\n            int profit = prices[i] - minPrice;\\n            if (profit > maxProfit) {\\n                maxProfit = profit;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572962,
                "title": "typescript-solution",
                "content": "```\\nfunction maxProfit(prices: number[]): number {\\n  let min = prices[0]\\n  let max = 0\\n  \\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i])\\n    max = Math.max(max, prices[i] - min)\\n  }\\n  \\n  return max\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction maxProfit(prices: number[]): number {\\n  let min = prices[0]\\n  let max = 0\\n  \\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i])\\n    max = Math.max(max, prices[i] - min)\\n  }\\n  \\n  return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1735433,
                "title": "rust-12-ms-2-9mb-oneliner",
                "content": "Runtime: 12 ms, faster than 93.02% of Rust online submissions for Best Time to Buy and Sell Stock.\\nMemory Usage: 2.9 MB, less than 50.39% of Rust online submissions for Best Time to Buy and Sell Stock.\\n```\\nimpl Solution {\\n    //  Profit = max price - min cost\\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\\n        prices\\n        .iter()\\n        .fold((0, i32::MAX), |(mut max_profit, mut cost), price| {\\n            cost = i32::min(*price, cost);\\n            max_profit = i32::max(max_profit, price-cost);\\n            (max_profit, cost)\\n        }).0\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    //  Profit = max price - min cost\\n    pub fn max_profit(prices: Vec<i32>) -> i32 {\\n        prices\\n        .iter()\\n        .fold((0, i32::MAX), |(mut max_profit, mut cost), price| {\\n            cost = i32::min(*price, cost);\\n            max_profit = i32::max(max_profit, price-cost);\\n            (max_profit, cost)\\n        }).0\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709087,
                "title": "java-simple-solution-time-o-n-space-o-1",
                "content": "Kindly upvote if it helps you!\\n```\\npublic int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n\\t\\t//we buy the stock on the \\'left\\' day & plan on selling on the \\'right\\' day\\n        int left = 0, right = 1;\\n        while(right < prices.length){\\n\\t\\t\\t//We want a profitable deal. Hence if the cost at day we buy the stock is less than the price on\\n\\t\\t\\t//the day we sell the stock, calculating currentProfit.\\n\\t\\t\\t//If currentProfit is greater that maxProfit, updating maxProfit\\n            if(prices[left]<prices[right]){\\n                int currentProfit = prices[right]-prices[left];\\n                maxProfit = Math.max(maxProfit, currentProfit);\\n            }else{\\n\\t\\t\\t\\t//if we found a day having even less price , we will buy the stock at that day. \\n                left = right;\\n            }\\n            right++;\\n        }\\n        return maxProfit;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "Kindly upvote if it helps you!\\n```\\npublic int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n\\t\\t//we buy the stock on the \\'left\\' day & plan on selling on the \\'right\\' day\\n        int left = 0, right = 1;\\n        while(right < prices.length){\\n\\t\\t\\t//We want a profitable deal. Hence if the cost at day we buy the stock is less than the price on\\n\\t\\t\\t//the day we sell the stock, calculating currentProfit.\\n\\t\\t\\t//If currentProfit is greater that maxProfit, updating maxProfit\\n            if(prices[left]<prices[right]){\\n                int currentProfit = prices[right]-prices[left];\\n                maxProfit = Math.max(maxProfit, currentProfit);\\n            }else{\\n\\t\\t\\t\\t//if we found a day having even less price , we will buy the stock at that day. \\n                left = right;\\n            }\\n            right++;\\n        }\\n        return maxProfit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1528220,
                "title": "o-n-detailed-explanation-case-dissected",
                "content": "# 5, 2, 6, 1, 4\\n**Let us solve the problem for the above data**\\nDays are numbered, from 0 to 4 (i = i to 4)\\n\\nPrimary idea: Buying at the lowest price and selling it at the maximum will bring us profit! We always look for maximum profit if we cannot sell it at lowest or buy it at its highest.\\n\\n**Day 0: [5]** \\n*We have one option. Let us suppose we buy the stock at day 0. **minbytsofar=5.**\\nLet us suppose we sold it at Day 0 itself. Thus, we sold it at 5.\\nRemember profit= sell cost- buy cost. What will be the profit in this case? **profit=5-5=0***\\n\\n**Day 1: [5 , 2]**\\n*On day 1 we see that if we bought it now, instead of buying it when the cost was 5, we will be at an advantage. Because, our primary idea was to buy at the lowest. Thus, **minbuysofar**= **minimum(5,2)= 2**\\nSelling it at day 1 will give us a **profit=2-2=0***\\n\\n**Day 2: [5, 2, 6]**\\n*If we bought it on day 2, we wont be making an intellingent choice, because we always buy stock at its minimum. We let the minbuysofar remain as it was. Mathematically, **minbuysofar=minimum(6,2)=2***\\n*Selling it now would give us a profit of (selling at day 2- buying at day 1)= **profit=6-2=4***\\n*setting a global maxima for profit, maxprofit=4*\\n\\n**Day 3: [5, 2, 6, 1]**\\n*The price is 1 now. Will we buy now? Hell yeah!! Its lower than 2 **minbuysofar=minimum(2,1)***\\n***profit=selling it on day 3- buying it on day 3=1-1=0***\\n*Global maxima for profit? Maximum(0,4)=4. 4 was still our maximum profit made*\\n\\n**Day 4: [5, 2, 6, 1, 4]**\\n***minbuysofar= minimum(1,4)*** *We won\\'t buy anymore*\\n*Maximum profit made is still 4. Because Max(4,3)=4*\\n\\n**Answer = 4. OUR BEST PROFIT!!**\\n\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length == 1)\\n            return 0;\\n        \\n        //              DYNAMIC PROGRAMMING APPROACH  \\n        \\n        //we are going to run a loop and find selling on which day is going to give us profit, corresponding to each buying day\\n        //to optimize this we further find the best buying day before calculating the profit\\n        \\n        int minbuysofar = prices [0];\\n        int maxprofit = 0;\\n        int profit = 0;\\n        \\n        for (int i=0; i<prices.length; i++)\\n        {\\n            minbuysofar = Math.min(minbuysofar, prices[i]);\\n            //we buy at the price of minbuysofar\\n            \\n            \\n            profit = prices[i]- minbuysofar; \\n            /* this translates to:\\n        minbuysofar = selling on i\\'th day- buying when price is minbuysofar*/\\n            \\n            \\n            //Now we need to see where the profit was maximum\\n            maxprofit = Math.max(maxprofit, profit);\\n        }\\n        \\n        return maxprofit;\\n}\\n}\\n```\\n\\n***upvote if you find this helpful :p***",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length == 1)\\n            return 0;\\n        \\n        //              DYNAMIC PROGRAMMING APPROACH  \\n        \\n        //we are going to run a loop and find selling on which day is going to give us profit, corresponding to each buying day\\n        //to optimize this we further find the best buying day before calculating the profit\\n        \\n        int minbuysofar = prices [0];\\n        int maxprofit = 0;\\n        int profit = 0;\\n        \\n        for (int i=0; i<prices.length; i++)\\n        {\\n            minbuysofar = Math.min(minbuysofar, prices[i]);\\n            //we buy at the price of minbuysofar\\n            \\n            \\n            profit = prices[i]- minbuysofar; \\n            /* this translates to:\\n        minbuysofar = selling on i\\'th day- buying when price is minbuysofar*/\\n            \\n            \\n            //Now we need to see where the profit was maximum\\n            maxprofit = Math.max(maxprofit, profit);\\n        }\\n        \\n        return maxprofit;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534953,
                "title": "explain-like-i-m-5-o-n-java-solution-solved-with-only-basic-intuition",
                "content": "Too often the solution is overcomplicated with terms like\\n- DP\\n- Kadane Algorithm\\n\\nYou can solve this problem with only simple logical reasoning to come up with the optimal solution.\\n\\nOur input: [7,1,5,3,6,4]\\n\\nWe know:\\n-  You can potentially sell stock on any day\\n-  When we sell stock on a certain day, we want to have bought stock when it was at it\\'s lowest prior to that day\\n\\nWe can simulate selling selling the stock every day and see which day would yield the max profit.\\n\\nWe do this by going through the array day by day while:\\n- Keeping track of lowest value\\n- Simulating the maximum profit if we were to sold that day\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lowestUntilThisPoint = Integer.MAX_VALUE;\\n        int maxProfit = -1;\\n        \\n        for (int price: prices) {\\n            if (price < lowestUntilThisPoint) {\\n                lowestUntilThisPoint = price;\\n            }\\n            int profit = price - lowestUntilThisPoint;\\n            if (profit > maxProfit) \\n                maxProfit = profit;\\n        }\\n        return Math.max(maxProfit, 0);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int lowestUntilThisPoint = Integer.MAX_VALUE;\\n        int maxProfit = -1;\\n        \\n        for (int price: prices) {\\n            if (price < lowestUntilThisPoint) {\\n                lowestUntilThisPoint = price;\\n            }\\n            int profit = price - lowestUntilThisPoint;\\n            if (profit > maxProfit) \\n                maxProfit = profit;\\n        }\\n        return Math.max(maxProfit, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39206,
                "title": "o-n-solution-without-using-dp-using-divide-and-conquer-technique",
                "content": "I know the problem tag says it is a DP problem but this can also be solved using divide and conquer approach. The Idea is to divide the array in two halves and call it recursively. recursive method will return 3 values maxProfit, minPrice and maxPrice. For each iteration max profit will be max of maxProfit of each halves compared with the difference of max of right half and min of left half. Following is the code\\n\\n    public int maxProfit(int[] prices) {\\n            return prices.length > 0 ? helper(prices,0,prices.length -1)[0] : 0;\\n        }\\n        /**\\n         * index 0 is max profit, index 1 is max price in the range and index 2 is min price in the range.\\n         */\\n        private int[] helper(int[] prices, int i, int j){\\n            int[] result = {0,prices[i],prices[j]}; // base case \\n            if(i == j) return result;\\n            int m = i + (j - i) / 2 ;\\n            int[] left = helper(prices,i,m); // left half\\n            int[] right = helper(prices,m+1,j); // right half\\n            result[0] = Math.max(left[0],Math.max(right[0],right[1] - left[2]));\\n            result[1] = Math.max(left[1],right[1]);\\n            result[2] = Math.min(left[2],right[2]);\\n            return result;\\n        }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "I know the problem tag says it is a DP problem but this can also be solved using divide and conquer approach. The Idea is to divide the array in two halves and call it recursively. recursive method will return 3 values maxProfit, minPrice and maxPrice. For each iteration max profit will be max of maxProfit of each halves compared with the difference of max of right half and min of left half. Following is the code\\n\\n    public int maxProfit(int[] prices) {\\n            return prices.length > 0 ? helper(prices,0,prices.length -1)[0] : 0;\\n        }\\n        /**\\n         * index 0 is max profit, index 1 is max price in the range and index 2 is min price in the range.\\n         */\\n        private int[] helper(int[] prices, int i, int j){\\n            int[] result = {0,prices[i],prices[j]}; // base case \\n            if(i == j) return result;\\n            int m = i + (j - i) / 2 ;\\n            int[] left = helper(prices,i,m); // left half\\n            int[] right = helper(prices,m+1,j); // right half\\n            result[0] = Math.max(left[0],Math.max(right[0],right[1] - left[2]));\\n            result[1] = Math.max(left[1],right[1]);\\n            result[2] = Math.min(left[2],right[2]);\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 39192,
                "title": "simple-python-code",
                "content": "    class Solution(object):\\n        def maxProfit(self, prices):\\n            \"\"\"\\n            :type prices: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n=len(prices)\\n            if n<=1:\\n                return 0\\n            max_profit=0\\n            low_price=prices[0]\\n            for i in range(1,n):\\n                low_price=min(low_price,prices[i])\\n                max_profit=max(max_profit, prices[i]-low_price)\\n            return max_profit",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def maxProfit(self, prices):\\n            \"\"\"\\n            :type prices: List[int]\\n            :rtype: int\\n            \"\"\"\\n            n=len(prices)\\n            if n<=1:\\n                return 0\\n            max_profit=0\\n            low_price=prices[0]\\n            for i in range(1,n):\\n                low_price=min(low_price,prices[i])\\n                max_profit=max(max_profit, prices[i]-low_price)\\n            return max_profit",
                "codeTag": "Java"
            },
            {
                "id": 39244,
                "title": "concise-solution-o-n",
                "content": "1 to record the changes from yesterday \\n2 find the max sum of consecutive subarray(if sum<0 sum==0)\\n\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int> &prices) {\\n            \\n            int max=0;\\n            int current=0;\\n            for(int i=1;i<prices.size();i++){\\n                current+=prices[i]-prices[i-1];\\n                if(current<0) current=0;\\n                else if(current>max) max=current;\\n            }\\n        return max;\\n    }  \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int> &prices) {\\n            \\n            int max=0;\\n            int current=0;\\n            for(int i=1;i<prices.size();i++){\\n                current+=prices[i]-prices[i-1];\\n                if(current<0) current=0;\\n                else if(current>max) max=current;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4041235,
                "title": "java-dynamic-programming-o-n",
                "content": "# Intuition\\nThe problem involves finding the maximum profit that can be obtained by buying and selling a stock. The intuition is to use **dynamic** **programming** to keep track of the minimum buying price and the maximum profit that can be obtained at each step.\\n\\n# Approach\\n- Check if the length of the `prices` array is less than or equal to 1. If so, return 0 because there are not enough days to make a profit.\\n- Initialize an integer array `dp` of the same length as `prices` to store the maximum profit that can be obtained at each day. Set `dp[0]` to 0 because no profit can be made on the first day.\\n- Initialize an integer variable `minPrice` to store the minimum buying price. Set `minPrice` to the price on the first day, `prices[0]`.\\n- Use a loop to iterate through the `prices` array starting from the second day (index 1).\\n- For each day `i`, calculate the maximum profit that can be obtained either by not selling on this day (i.e., `dp[i-1]`) or by selling on this day (i.e., `prices[i] - minPrice`). Take the maximum of these two values and update `dp[i]` accordingly.\\n- Update `minPrice` by taking the minimum of its current value and the price on the current day `prices[i]`. This step ensures that `minPrice` always represents the minimum buying price seen so far.\\n- After the loop, the maximum profit is stored in `dp[n-1]`, where `n` is the length of the `prices` array.\\n- Return `dp[n-1]` as the maximum profit that can be obtained.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm iterates through the `prices` array once, performing constant-time operations at each step, resulting in a linear time complexity of O(n), where n is the length of the `prices` array.\\n\\n- Space complexity: O(n)\\n  The algorithm uses an additional integer array `dp` of the same length as the `prices` array, resulting in a space complexity of O(n).\\n  \\n# Code\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length <= 1) {\\n            return 0;\\n        }\\n\\n        int n = prices.length;\\n        int[] dp = new int[n]; \\n        dp[0] = 0;\\n        int minPrice = prices[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            dp[i] = Math.max(dp[i - 1], prices[i] - minPrice);\\n            minPrice = Math.min(minPrice, prices[i]);\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices.length <= 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3226931,
                "title": "python-3-5-lines-w-explanation-and-example-t-m-98-83",
                "content": "Here\\'s the plan:\\n\\nWe iterate through`prices`, keeping track of\\n1. `mn`, the minimum`price` were we to buy that day,and \\n2. `mx`, the potential maximum profit, were we to sell that day.\\n\\nWe return the profit`mx`after completing the iteration\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:\\n                                            # Example: prices = [7,1,5,3,6,4]\\n                                            #\\n        mn, mx = prices[0], 0               #   p   mn   mx  \\n                                            #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\n        for p in prices:                    #        7    0    <--   initial values\\n                                            #   1    1    0    <--   1 - 1 = 0, so mx = 0 still\\n            if   p < mn     : mn = p        #   5    1    4    <--   5 - 1 = 4, so mx = 4 now\\n            elif p > mx + mn: mx = p - mn   #   3    1    4    <--   3 - 1 = 2, so mx = 4 still\\n                                            #   6    1    4    <--   6 - 1 = 5, so mx = 5 now\\n        return mx                           #   4    1    5    <--   4 - 1 = 3, so mx = 5 still\\n                                            #\\n                                            #                         return 5\\n\\n```\\n[https://leetcode.com/problems/best-time-to-buy-and-sell-stock/submissions/904408311/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: list[int]) -> int:\\n                                            # Example: prices = [7,1,5,3,6,4]\\n                                            #\\n        mn, mx = prices[0], 0               #   p   mn   mx  \\n                                            #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\n        for p in prices:                    #        7    0    <--   initial values\\n                                            #   1    1    0    <--   1 - 1 = 0, so mx = 0 still\\n            if   p < mn     : mn = p        #   5    1    4    <--   5 - 1 = 4, so mx = 4 now\\n            elif p > mx + mn: mx = p - mn   #   3    1    4    <--   3 - 1 = 2, so mx = 4 still\\n                                            #   6    1    4    <--   6 - 1 = 5, so mx = 5 now\\n        return mx                           #   4    1    5    <--   4 - 1 = 3, so mx = 5 still\\n                                            #\\n                                            #                         return 5\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108528,
                "title": "c-simple-o-n-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply track mininum upto each element take the differnee and comapre it it is greater than previous then update .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust traverse the whole array and track minimum so far and take take its diffrence with each element and keep updating the max diff.At lst return the maximum diffrence.\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int ans=0;\\n        int n=arr.size();\\n        int mini=INT_MAX,maxi=0;\\n         for(int i=0;i<n;i++){\\n             ans=max(ans,arr[i]-mini);\\n             mini=min(arr[i],mini);\\n           //  maxi=max(arr[i+1],maxi);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int ans=0;\\n        int n=arr.size();\\n        int mini=INT_MAX,maxi=0;\\n         for(int i=0;i<n;i++){\\n             ans=max(ans,arr[i]-mini);\\n             mini=min(arr[i],mini);\\n           //  maxi=max(arr[i+1],maxi);\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795048,
                "title": "java-runtime-1ms-faster-than-100-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minBuy = prices[0], maxProfit = 0;\\n        for (int current : prices) {\\n            minBuy = Math.min(minBuy, current);\\n            maxProfit = Math.max(maxProfit, current - minBuy);\\n        }\\n        return maxProfit;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/302b12c8-9225-4955-8376-ddc8de15ccd5_1667962964.2372463.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minBuy = prices[0], maxProfit = 0;\\n        for (int current : prices) {\\n            minBuy = Math.min(minBuy, current);\\n            maxProfit = Math.max(maxProfit, current - minBuy);\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643827,
                "title": "comprehensive-python-solution-thought-process-examples",
                "content": "**Approach**\\nYour first thought when approaching this problem is probably that we should buy on the cheapest day and then sell on the most expensive day. This works for cases such as ```[1,4,3,2,5]```  where the highest priced day is after the lowest priced day (in this case you can buy on day ```0``` and sell on day ```4``` to make a profit of ```4```. However, in a case such as example 1, ```[7,1,5,3,6,4]```, this method would assert that we can get a profit of ```6``` by selling at the highest price, ```7```, and buying at the lowest price, ```1```. Unfortuantely, this is not possible since we need to buy before we sell! So, how can we go from here? Well, let\\'s think about this major restriction \\u2013 we need to sell *after* we buy. This means that we can figure out the maximum profit to make by going to each day and seeing what would happen if we buy on that day and sell later!\\n\\n**Method 1: Brute-force; Time: O(N^2), Space: O(1) \\u2014> TLE**\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        profit = 0 #best profit possible\\n        for i in range(len(prices)-1):\\n            buy = prices[i] #assume we buy today\\n            sell = max(prices[i+1:]) #we sell on the future day with the highest price\\n            if sell-buy > profit: #if this combination improves our profit\\n                profit = sell-buy #update the profit\\n        return profit\\n```\\nIn this method we iterate through all the days and then figure out the highest profit we can make by buying on day ```i``` and selling on the day with the maximum price that occurs after this day (day ```i+1``` or later). Each time we check to see if this improved our profit. This method has a time complexity of ```O(N^2)``` since for every day ```i```, we need to look at ```N-i-1``` days afterwards to find the best day to sell. Unfortunately this results in a time limit exception since some of the leetcode test cases are super lengthy, so we will need to find a better solution.\\n\\n**How to improve - what to do when stuck**\\nFirst, let\\'s identify what step in our process is slowing down the code. It isn\\'t figuring out which day to buy, since we just assume we buy on day ```i```, but finding the day we sell on. Since the day we sell on is in the future, we need to look at every day even though we sometimes already looked at them in the last iteration of our ```for``` loop. So, let\\'s brainstorm how we can improve this method. Rather than assuming we buy on day ```i```, let\\'s assume we actually sell on day ```i```. Since we have already looked at the ```i-1``` days before this day, we can keep track of the cheapest day to buy on which was before day ```i```. This will greatly improve the speed of our code since we don\\'t need to look at a ton of days each time!\\n\\n**Method 2: One-pass; Time: O(N), Space: O(1)**\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        profit = 0 #our answer\\n        buy = prices[0] #the day we buy on\\n        for i in range(1,len(prices)):\\n            sell = prices[i] #assume we sell today\\n            profit = max(profit,sell-buy) #update the maximum profit if we were to sell today\\n            buy = min(buy,prices[i]) #update the cheapest price we could buy\\n        return profit\\n```\\nAs mentioned before, in this method we keep track of the cheapest day to buy, then see what would happen if we sold our stock on day ```i```. First we see if the profit we make from selling today is better than the profit we previously could make. Then make sure that this value, ```buy``` is as small as possible by checking to see if the current price is cheaper. To help illustrate how this works, I will walk through both examples provided with the question.\\n\\n**Example 1:**\\n```\\nprices = [7,1,5,3,6,4]\\n\\ni = 1, previous max profit = 0, buy = 7, sell = 1\\ni = 2, previous max profit = 0, buy = 1, sell = 5\\ni = 3, previous max profit = 4, buy = 1, sell = 3\\ni = 4, previous max profit = 4, buy = 1, sell = 6\\ni = 5, previous max profit = 5, buy = 1, sell = 4\\n```\\n\\n**Example 2:**\\n```\\nprices = [7,1,5,3,6,4]\\n\\ni = 1, previous max profit = 0, buy = 7, sell = 6\\ni = 2, previous max profit = 0, buy = 6, sell = 4\\ni = 3, previous max profit = 0, buy = 4, sell = 3\\ni = 4, previous max profit = 0, buy = 3, sell = 1\\n```\\n\\nI hope that walking through these examples has helped you understand what\\'s going on! If you still have any questions, please comment and I will try to help!\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```[1,4,3,2,5]```\n```0```\n```4```\n```4```\n```[7,1,5,3,6,4]```\n```6```\n```7```\n```1```\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        profit = 0 #best profit possible\\n        for i in range(len(prices)-1):\\n            buy = prices[i] #assume we buy today\\n            sell = max(prices[i+1:]) #we sell on the future day with the highest price\\n            if sell-buy > profit: #if this combination improves our profit\\n                profit = sell-buy #update the profit\\n        return profit\\n```\n```i```\n```i+1```\n```O(N^2)```\n```i```\n```N-i-1```\n```i```\n```for```\n```i```\n```i```\n```i-1```\n```i```\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n        profit = 0 #our answer\\n        buy = prices[0] #the day we buy on\\n        for i in range(1,len(prices)):\\n            sell = prices[i] #assume we sell today\\n            profit = max(profit,sell-buy) #update the maximum profit if we were to sell today\\n            buy = min(buy,prices[i]) #update the cheapest price we could buy\\n        return profit\\n```\n```i```\n```buy```\n```\\nprices = [7,1,5,3,6,4]\\n\\ni = 1, previous max profit = 0, buy = 7, sell = 1\\ni = 2, previous max profit = 0, buy = 1, sell = 5\\ni = 3, previous max profit = 4, buy = 1, sell = 3\\ni = 4, previous max profit = 4, buy = 1, sell = 6\\ni = 5, previous max profit = 5, buy = 1, sell = 4\\n```\n```\\nprices = [7,1,5,3,6,4]\\n\\ni = 1, previous max profit = 0, buy = 7, sell = 6\\ni = 2, previous max profit = 0, buy = 6, sell = 4\\ni = 3, previous max profit = 0, buy = 4, sell = 3\\ni = 4, previous max profit = 0, buy = 3, sell = 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2573375,
                "title": "simple-javascript-solution",
                "content": "### Solution\\n```js\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    // set to first element in array by default\\n    let minprice = prices[0];\\n    let profit = 0;\\n    for (let i = 0; i < prices.length; i++) {\\n        if (prices[i] < minprice) {\\n            minprice = prices[i];\\n        } else if (prices[i] - minprice > profit) {\\n            profit = prices[i] - minprice;\\n        }\\n    }\\n     return profit\\n};\\n```\\n\\n### LeetCode Output\\nRuntime: **89 ms**, faster than **93.23%** of JavaScript online submissions for Valid Parentheses.\\nMemory Usage: **52 MB**, less than **24.52%** of JavaScript online submissions for Valid Parentheses.\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/799297619/)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    // set to first element in array by default\\n    let minprice = prices[0];\\n    let profit = 0;\\n    for (let i = 0; i < prices.length; i++) {\\n        if (prices[i] < minprice) {\\n            minprice = prices[i];\\n        } else if (prices[i] - minprice > profit) {\\n            profit = prices[i] - minprice;\\n        }\\n    }\\n     return profit\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2376959,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        min_price = 999999\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            if price - min_price > max_profit:\\n                max_profit = price - min_price\\n        return max_profit\\n```\\n\\n\\tIf you liked it, hit the upvote button! ;)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        max_profit = 0\\n        min_price = 999999\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            if price - min_price > max_profit:\\n                max_profit = price - min_price\\n        return max_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719577,
                "title": "javascript-easy-approach",
                "content": "```\\nvar maxProfit = function (prices) {\\n    let minBuyPrice = prices[0];\\n    let maxProfit = 0;\\n    for (let price of prices) {\\n        if (price < minBuyPrice) {\\n            minBuyPrice = price\\n        } else if (price-minBuyPrice > maxProfit){\\n            maxProfit = price-minBuyPrice\\n        }\\n    }\\n    return maxProfit\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function (prices) {\\n    let minBuyPrice = prices[0];\\n    let maxProfit = 0;\\n    for (let price of prices) {\\n        if (price < minBuyPrice) {\\n            minBuyPrice = price\\n        } else if (price-minBuyPrice > maxProfit){\\n            maxProfit = price-minBuyPrice\\n        }\\n    }\\n    return maxProfit\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 494015,
                "title": "accepted-c-solution-easy-to-understand",
                "content": "For C# programmers the optimal solution code from Solution tab\\n# Approach\\nTrack minimum price and check for maximum profit\\n\\nTime Complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices)\\n    {\\n        int minprice = int.MaxValue;\\n        int maxprofit = 0;\\n        \\n        for (int i = 0; i < prices.Length; i++)\\n        {\\n            if (prices[i] < minprice)\\n            {\\n                minprice = prices[i];\\n            }\\n            else if (prices[i] - minprice > maxprofit)\\n            {\\n                maxprofit = prices[i] - minprice;\\n            }\\n        }\\n        \\n        return maxprofit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices)\\n    {\\n        int minprice = int.MaxValue;\\n        int maxprofit = 0;\\n        \\n        for (int i = 0; i < prices.Length; i++)\\n        {\\n            if (prices[i] < minprice)\\n            {\\n                minprice = prices[i];\\n            }\\n            else if (prices[i] - minprice > maxprofit)\\n            {\\n                maxprofit = prices[i] - minprice;\\n            }\\n        }\\n        \\n        return maxprofit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872093,
                "title": "beats-94-43-in-runtime-63-in-memory-only-6-lines",
                "content": "![image.png](https://assets.leetcode.com/users/images/298dc630-31a5-4e65-b0eb-cf5bfdb3bc3e_1691325811.8985078.png)\\n\\n\\n\\nPlease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        l,r=0,1;maxP=0 \\n        while r<len(prices):\\n            if prices[l]<prices[r]:profit=prices[r]-prices[l];maxP=max(maxP, profit)                \\n            else:l=r \\n            r+=1\\n        return maxP\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        l,r=0,1;maxP=0 \\n        while r<len(prices):\\n            if prices[l]<prices[r]:profit=prices[r]-prices[l];maxP=max(maxP, profit)                \\n            else:l=r \\n            r+=1\\n        return maxP\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758901,
                "title": "c-python-greedy-explain-w-pyplot",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is a solution to the problem of finding the maximum profit that can be obtained from buying and selling stocks. The class Solution contains a single member function maxProfit that takes a vector of integers prices as input and returns an integer value representing the maximum profit.\\n\\n<!-- Describe your approach to solving the problem. -->\\n # Explain with Matplotlib.pyplot\\n[Please turn on English subtitles]\\n[https://youtu.be/--vVXnaKPqI](https://youtu.be/--vVXnaKPqI)\\n# Approach\\nThe following loop iterates through the prices vector starting from index 1 (since we already initialized buy with the price at index 0):\\n\\nbuy = min(buy, prices[i]);: \\nThis line compares the current price (prices[i]) with the current minimum price (buy). It updates buy if the current price is smaller, ensuring that buy always represents the minimum price seen so far.\\n\\nsell = max(sell, prices[i] - buy);: \\nThis line calculates the profit that can be obtained by selling at the current price (prices[i]) after buying at the minimum price (buy). It compares this profit with the current maximum profit (sell) and updates sell if the calculated profit is larger. This way, sell always represents the maximum profit seen so far.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int&& s=prices.size();\\n        if (s <= 1) return 0;\\n        int buy = prices[0], sell=0;\\n        for (int i = 1; i < s; i++) {\\n            buy = min(buy, prices[i]);\\n            sell = max(sell, prices[i] - buy);\\n //           cout<<buy<<\"|\"<<sell<<endl;          \\n        }\\n        return sell;\\n    }\\n};  \\n  \\n```\\n# Python Code\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #List & Loop \\n        profit=0\\n        buy=prices[0]\\n        for x in prices[1:]:\\n            buy=min(buy, x)\\n            profit=max(profit, x-buy)\\n        return profit\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int&& s=prices.size();\\n        if (s <= 1) return 0;\\n        int buy = prices[0], sell=0;\\n        for (int i = 1; i < s; i++) {\\n            buy = min(buy, prices[i]);\\n            sell = max(sell, prices[i] - buy);\\n //           cout<<buy<<\"|\"<<sell<<endl;          \\n        }\\n        return sell;\\n    }\\n};  \\n  \\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #List & Loop \\n        profit=0\\n        buy=prices[0]\\n        for x in prices[1:]:\\n            buy=min(buy, x)\\n            profit=max(profit, x-buy)\\n        return profit\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227970,
                "title": "stocks-buy-and-sell-dp-easy-understanding",
                "content": "Hi,\\n\\nThere are lot of solutions already available, but reason behind writing this solution is this question is tagged as \\'Easy\\' but most of the solutions are not looking easy it looks like \\'Medium\\'. So thought to write a easy solution which is easy for everyone.\\n\\nI picked up DP approach, because its easy to relate to.\\n\\n**Intution:**\\nInorder to get maximum profit we will see what is the minimum rate before today that we can buy. \\n\\n**Steps:**\\n1. Define a DP array of size equal to array length\\n2. Iterate through the given array and see the minimum prices till that array store it in the DP array -> dp[i] = Math.min(dp[i-1], prices[i]);\\n3. Find which day has maximum difference compared to the DP array\\n4. Return the result\\n\\nKindly upvote and spread joy..\\n\\n```\\n\\tpublic int maxProfit(int[] prices) {\\n\\t\\tint res=0;\\n\\t\\tint[] dp = new int[prices.length];\\n\\t\\tdp[0]=prices[0];\\n\\t\\tfor(int i=1; i<prices.length; i++){\\n\\t\\t\\tdp[i] = Math.min(dp[i-1], prices[i]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<prices.length; i++){\\n\\t\\t\\tres = Math.max(res, prices[i]-dp[i]);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Hi,\\n\\nThere are lot of solutions already available, but reason behind writing this solution is this question is tagged as \\'Easy\\' but most of the solutions are not looking easy it looks like \\'Medium\\'. So thought to write a easy solution which is easy for everyone.\\n\\nI picked up DP approach, because its easy to relate to.\\n\\n**Intution:**\\nInorder to get maximum profit we will see what is the minimum rate before today that we can buy. \\n\\n**Steps:**\\n1. Define a DP array of size equal to array length\\n2. Iterate through the given array and see the minimum prices till that array store it in the DP array -> dp[i] = Math.min(dp[i-1], prices[i]);\\n3. Find which day has maximum difference compared to the DP array\\n4. Return the result\\n\\nKindly upvote and spread joy..\\n\\n```\\n\\tpublic int maxProfit(int[] prices) {\\n\\t\\tint res=0;\\n\\t\\tint[] dp = new int[prices.length];\\n\\t\\tdp[0]=prices[0];\\n\\t\\tfor(int i=1; i<prices.length; i++){\\n\\t\\t\\tdp[i] = Math.min(dp[i-1], prices[i]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<prices.length; i++){\\n\\t\\t\\tres = Math.max(res, prices[i]-dp[i]);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2945822,
                "title": "simplest-c-solution",
                "content": "# Approach\\nSimply tack the min price of the stock and the profit. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        var min = prices[0];\\n        var profit = 0;\\n        foreach (var today in prices) {\\n            profit = Math.Max(profit, today-min);\\n            min = Math.Min(min, today);\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        var min = prices[0];\\n        var profit = 0;\\n        foreach (var today in prices) {\\n            profit = Math.Max(profit, today-min);\\n            min = Math.Min(min, today);\\n        }\\n        return profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739938,
                "title": "python-c-java-rust-simple-min-max-operations-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs simple min and max operations. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. \\n| **Language** | [**Python**](https://leetcode.com/submissions/detail/829388260/) | [**C++**](https://leetcode.com/submissions/detail/829376733/) | [**Java**](https://leetcode.com/submissions/detail/829383379/) | [**Rust**](https://leetcode.com/submissions/detail/829390159/) | \\n|---|---|---|---|---|\\n| **Runtime** | **1084 ms (93.30%)** | **93 ms (99.88%)** | **1 ms (100.00%)** | **4 ms (99.72%)** |\\n| **Memory** | **25.0 MB  (85.47%)** | **93.5 MB (8.10%)** | **58.8 MB  (94.22%)** | **3.0 MB  (66.34%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/7ktsghLD/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs simple min and max operations. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. \\n| **Language** | [**Python**](https://leetcode.com/submissions/detail/829388260/) | [**C++**](https://leetcode.com/submissions/detail/829376733/) | [**Java**](https://leetcode.com/submissions/detail/829383379/) | [**Rust**](https://leetcode.com/submissions/detail/829390159/) | \\n|---|---|---|---|---|\\n| **Runtime** | **1084 ms (93.30%)** | **93 ms (99.88%)** | **1 ms (100.00%)** | **4 ms (99.72%)** |\\n| **Memory** | **25.0 MB  (85.47%)** | **93.5 MB (8.10%)** | **58.8 MB  (94.22%)** | **3.0 MB  (66.34%)** |\\n\\n<iframe src=\"https://leetcode.com/playground/7ktsghLD/shared\" frameBorder=\"0\" width=\"800\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2266768,
                "title": "c-easy-and-clean-code",
                "content": "**APPROACH**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int p = 0;\\n        int m = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++){\\n            m = min(m, prices[i]);\\n            p = max(p, prices[i] - m);\\n        }\\n        return p;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int p = 0;\\n        int m = INT_MAX;\\n        for(int i = 0; i < prices.size(); i++){\\n            m = min(m, prices[i]);\\n            p = max(p, prices[i] - m);\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942808,
                "title": "python-faster-than-99-explanation-added",
                "content": "So we need to find difference between max and min value in array.\\nBut, cause of time (it\\'s market, man!), max value should be later (with higher array index).\\nFinally, algo is find min value and max difference with next values.\\n\\nReadable things like\\n```\\nprofit = max(profit, new_profit)\\n```\\nworks a bit slower than\\n```\\nif profit > new_profit:\\n\\tprofit = new_profit\\n```\\ncause of a lot additional assignments in most cases.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        profit = 0\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > profit:\\n                profit = price - min_price\\n        return profit\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nprofit = max(profit, new_profit)\\n```\n```\\nif profit > new_profit:\\n\\tprofit = new_profit\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = prices[0]\\n        profit = 0\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > profit:\\n                profit = price - min_price\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929705,
                "title": "java-2ms-sliding-window-explanation-simple-o-n",
                "content": "The key to solving this problem is realizing that once a local minima is found, it is never more profitable going forward to buy on a day that costs more money. This is because we only have one day to choose to buy and one day to choose to sell.\\n\\nIf you are having trouble understanding why this solution works, then I would recommend simulating on paper what the code would do for two or more test cases.\\n\\n**Runtime Complexity - O(N)**\\n**Memory Complexity - O(1)**\\nwhere N is the size of the input array \"prices\".\\n```\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        \\n        int minSeenSoFar = prices[0];\\n        for(int day = 1; day < prices.length; day++) {\\n            int priceToday = prices[day];\\n            \\n            if(priceToday < minSeenSoFar) {\\n                minSeenSoFar = priceToday;\\n                continue;\\n            }\\n            \\n            maxProfit = Math.max(maxProfit, priceToday - minSeenSoFar);\\n        }\\n        \\n        return maxProfit;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        \\n        int minSeenSoFar = prices[0];\\n        for(int day = 1; day < prices.length; day++) {\\n            int priceToday = prices[day];\\n            \\n            if(priceToday < minSeenSoFar) {\\n                minSeenSoFar = priceToday;\\n                continue;\\n            }\\n            \\n            maxProfit = Math.max(maxProfit, priceToday - minSeenSoFar);\\n        }\\n        \\n        return maxProfit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871901,
                "title": "c-easy-solution-explained",
                "content": "Approach is maintaining the smallest price and use this formula \\n`profit = current_day_price - minimum_price`\\nexample : \\n```\\n\\t\\t\\t\\t\\t\\tday     =  1 ,2 ,3 ,4 ,5 ,6\\n\\t\\t\\t\\t\\t\\tprice   =  7 ,1 ,5 ,3 ,6 ,4\\n\\t\\t\\n\\t\\tprice = 7\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 7- 7 = 0\\n\\t\\t\\n\\t\\tprice = 1\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 1 - 1 = 0\\n\\t\\t\\n\\t\\tprice = 5\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 5 - 1 = 4   (since minimum price is still 1)\\n\\t\\t\\n\\t\\tprice = 3\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 3 - 1 = 2\\n\\t\\t\\n\\t\\tprice = 6\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 6 - 1 = 5\\n\\t\\t\\n\\t\\tprice = 4\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 4 - 1 = 3\\n\\t\\t\\n\\tand now you know maximum profit is  5  ( on 6th day )\\n\\tthis is taking O(n) Time\\n```\\n\\nNow try to code down this approach and if you cant do it do not lose hope come back and look to the solution and try again.\\n\\nIf you have any issue or if you found any error in my method do mention it in comments.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tThank you\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int minPrices = INT_MAX, maxProfit = 0, profit;\\n        \\n        for(int i = 0;i < prices.size();i++)\\n        {\\n            minPrices = min(minPrices,prices[i]);\\n            profit = prices[i] - minPrices ;\\n            \\n            if(profit > maxProfit){ maxProfit = profit;}\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\n\\n* ***Try to understand the code rather than coping.***\\n* ***If you liked my work than upvote my solution.***\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t AND\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t**** Happy Coding ****\\n\\t\\t\\t\\t\\t\\t**** Keep Solving, Keep Upgrading **** \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\tday     =  1 ,2 ,3 ,4 ,5 ,6\\n\\t\\t\\t\\t\\t\\tprice   =  7 ,1 ,5 ,3 ,6 ,4\\n\\t\\t\\n\\t\\tprice = 7\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 7- 7 = 0\\n\\t\\t\\n\\t\\tprice = 1\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 1 - 1 = 0\\n\\t\\t\\n\\t\\tprice = 5\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 5 - 1 = 4   (since minimum price is still 1)\\n\\t\\t\\n\\t\\tprice = 3\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 3 - 1 = 2\\n\\t\\t\\n\\t\\tprice = 6\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 6 - 1 = 5\\n\\t\\t\\n\\t\\tprice = 4\\n\\t\\tprofit = current_day_price - minPrice\\n\\t\\tprofit = 4 - 1 = 3\\n\\t\\t\\n\\tand now you know maximum profit is  5  ( on 6th day )\\n\\tthis is taking O(n) Time\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int minPrices = INT_MAX, maxProfit = 0, profit;\\n        \\n        for(int i = 0;i < prices.size();i++)\\n        {\\n            minPrices = min(minPrices,prices[i]);\\n            profit = prices[i] - minPrices ;\\n            \\n            if(profit > maxProfit){ maxProfit = profit;}\\n        }\\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738780,
                "title": "java-leetcode-daily-challenege-1st-feb-faster-than-100",
                "content": "```\\n//PLEASE UPVOTE IF IT HELPS YOU\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sp=0;\\n        int profit=0;\\n        for(int i=prices.length-1;i>=0;i--){\\n            sp=Math.max(sp,prices[i]);\\n            profit=Math.max(profit,sp-prices[i]);\\n        }\\n        return profit;\\n    }\\n}\\n\\n\\n//TC:O(n)   n:size of array prices\\n /*\\n APPROACH: profit=sp-cp\\n Traverse from the last index of array prices which is aur cp and find maximum sp and projfit for each iteration\\n */\\n \\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//PLEASE UPVOTE IF IT HELPS YOU\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sp=0;\\n        int profit=0;\\n        for(int i=prices.length-1;i>=0;i--){\\n            sp=Math.max(sp,prices[i]);\\n            profit=Math.max(profit,sp-prices[i]);\\n        }\\n        return profit;\\n    }\\n}\\n\\n\\n//TC:O(n)   n:size of array prices\\n /*\\n APPROACH: profit=sp-cp\\n Traverse from the last index of array prices which is aur cp and find maximum sp and projfit for each iteration\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1735439,
                "title": "python-2-approaches-complexity",
                "content": "\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tmiN = (1 << 31)\\n\\t\\t\\tmaX = 0\\n\\t\\t\\tfor i in range(1, len(prices)):\\n\\t\\t\\t\\tif prices[i] > prices[i-1]:\\n\\t\\t\\t\\t\\tmiN = min(miN, prices[i-1])\\n\\t\\t\\t\\t\\tmaX = max(maX, prices[i]-miN)\\n\\t\\t\\treturn maX\\n\\n\\t# Kadane\\'s Algo \\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\tcurSum = 0\\n\\t\\t\\tfor i in range(len(prices)-1):\\n\\t\\t\\t\\tcurSum += prices[i+1]-prices[i]\\n\\t\\t\\t\\tif curSum < 0:\\n\\t\\t\\t\\t\\tcurSum = 0\\n\\t\\t\\t\\tans = max(ans, curSum)\\n\\t\\t\\treturn ans\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# Time: O(n)\\n\\t# Space: O(1)\\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tmiN = (1 << 31)\\n\\t\\t\\tmaX = 0\\n\\t\\t\\tfor i in range(1, len(prices)):\\n\\t\\t\\t\\tif prices[i] > prices[i-1]:\\n\\t\\t\\t\\t\\tmiN = min(miN, prices[i-1])\\n\\t\\t\\t\\t\\tmaX = max(maX, prices[i]-miN)\\n\\t\\t\\treturn maX\\n\\n\\t# Kadane\\'s Algo \\n\\tclass Solution:\\n\\t\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\tans = 0\\n\\t\\t\\tcurSum = 0\\n\\t\\t\\tfor i in range(len(prices)-1):\\n\\t\\t\\t\\tcurSum += prices[i+1]-prices[i]\\n\\t\\t\\t\\tif curSum < 0:\\n\\t\\t\\t\\t\\tcurSum = 0\\n\\t\\t\\t\\tans = max(ans, curSum)\\n\\t\\t\\treturn ans\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1735352,
                "title": "java-greedy-explained",
                "content": "**Idea:**\\n* Maximum profit is made when \\n\\t* stocks are bought at price[i] and sold at price[j], where i < j, and \\n\\t* profit = price[j] - price[i] is max across all profits\\n* So scan from left to right, recording any profit and also the cheapest price seen yet\\n* If you come across a profit, check if its more than last profit, if yes, then this is the new max profit\\n* If you come across a cheaper price than the last cheapest seen, then this is the new cheapest price\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int maxProfit(int[] prices) {\\n\\tvar maxProfit = 0;\\n\\n\\tfor (int i = 1, cheapest = prices[0]; i < prices.length; i++) {\\n\\t\\tif (prices[i] >= cheapest)\\n\\t\\t\\tmaxProfit = Math.max(maxProfit, prices[i] - cheapest);\\n\\t\\tcheapest = Math.min(cheapest, prices[i]);\\n\\t}\\n\\treturn maxProfit;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n\\tvar maxProfit = 0;\\n\\n\\tfor (int i = 1, cheapest = prices[0]; i < prices.length; i++) {\\n\\t\\tif (prices[i] >= cheapest)\\n\\t\\t\\tmaxProfit = Math.max(maxProfit, prices[i] - cheapest);\\n\\t\\tcheapest = Math.min(cheapest, prices[i]);\\n\\t}\\n\\treturn maxProfit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675152,
                "title": "easiest-and-optimized-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& profit) {\\n        int ans = profit[0];\\n        int mxpro = -1;\\n        for(int i = 0 ; i < profit.size() ; i++){\\n            ans = min(ans,profit[i]);\\n            mxpro = max(mxpro , profit[i] - ans);\\n        }\\n        return mxpro;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& profit) {\\n        int ans = profit[0];\\n        int mxpro = -1;\\n        for(int i = 0 ; i < profit.size() ; i++){\\n            ans = min(ans,profit[i]);\\n            mxpro = max(mxpro , profit[i] - ans);\\n        }\\n        return mxpro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286991,
                "title": "java-solution-multiple-approach",
                "content": "\\nBrute Force Approach - this code will exceed the time limit but \\nthat does not mean your logic is wrong\\nbe easy on yourself, #KeepCoding\\n\\n```\\npublic class Main {\\n    public static void main(String args[]) {\\n       int[] arr={7,1,5,3,6,4};\\n        int profit=0;\\n        int  max_profit=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n            profit=arr[j]-arr[i];\\n            if(profit>max_profit) max_profit=profit;\\n            }\\n\\n        }\\n        System.out.println(max_profit);\\n    }\\n}\\n```\\n\\n\\n//Method -2\\n```\\nclass Solution {\\n   public int maxProfit(int[] prices) {\\n        int max = 0, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < min) min = prices[i];\\n            else if (prices[i] > min) max = Math.max(prices[i] - min, max);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n//Method -3\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0, max_profit=0, min_price=prices[0];\\n        for(int i=1;i<prices.length; i++){\\n            profit=prices[i]-min_price;\\n            min_price=Math.min(min_price,prices[i]);\\n            max_profit=Math.max(max_profit,profit);\\n        }\\n        return max_profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Main {\\n    public static void main(String args[]) {\\n       int[] arr={7,1,5,3,6,4};\\n        int profit=0;\\n        int  max_profit=0;\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=i+1; j<arr.length; j++){\\n            profit=arr[j]-arr[i];\\n            if(profit>max_profit) max_profit=profit;\\n            }\\n\\n        }\\n        System.out.println(max_profit);\\n    }\\n}\\n```\n```\\nclass Solution {\\n   public int maxProfit(int[] prices) {\\n        int max = 0, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < min) min = prices[i];\\n            else if (prices[i] > min) max = Math.max(prices[i] - min, max);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0, max_profit=0, min_price=prices[0];\\n        for(int i=1;i<prices.length; i++){\\n            profit=prices[i]-min_price;\\n            min_price=Math.min(min_price,prices[i]);\\n            max_profit=Math.max(max_profit,profit);\\n        }\\n        return max_profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853112,
                "title": "dynamic-programming-explanation",
                "content": "We can view the official solution as a form of optimized dynamic programming solution.\\n\\nWith a naive dynamic programming solution, we can keep track of the lowest price encountered thus far using the folllowing relation:\\n\\n* memo[i+1] is the lowest price up to prices[0..i]\\n\\nThe code becomes:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        int[] memo = new int[n+1];\\n        memo[1] = prices[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            memo[i+1] = Math.min(memo[i], prices[i]);\\n            ans = Math.max(ans, prices[i] - memo[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nIt requires `~O(N)` space.\\n\\nNoticing that we only ever need to keep track of the maximum solution of a subproblem, we can avoid allocating an array.\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        int lo = prices[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            ans = Math.max(ans, prices[i] - lo);\\n            lo = Math.min(lo, prices[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nNow it requires `~O(1)` space.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        int[] memo = new int[n+1];\\n        memo[1] = prices[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            memo[i+1] = Math.min(memo[i], prices[i]);\\n            ans = Math.max(ans, prices[i] - memo[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        int lo = prices[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            ans = Math.max(ans, prices[i] - lo);\\n            lo = Math.min(lo, prices[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283486,
                "title": "100-simple-golang-solution",
                "content": "```\\nfunc maxProfit(prices []int) int {\\n    if len(prices) <= 1 {\\n\\t\\treturn 0\\n\\t} \\n    \\n    min, maxSale := prices[0], 0\\n\\n\\tfor _,price := range prices {\\n\\t\\tif price < min {\\n\\t\\t\\tmin = price\\n        } else if (price-min) > maxSale{\\n\\t\\t\\tmaxSale = price-min\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn  maxSale\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxProfit(prices []int) int {\\n    if len(prices) <= 1 {\\n\\t\\treturn 0\\n\\t} \\n    \\n    min, maxSale := prices[0], 0\\n\\n\\tfor _,price := range prices {\\n\\t\\tif price < min {\\n\\t\\t\\tmin = price\\n        } else if (price-min) > maxSale{\\n\\t\\t\\tmaxSale = price-min\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn  maxSale\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 39283,
                "title": "java-all-3-solutions-bruteforce-timeout-dp-3ms-divide-conquer-4ms",
                "content": "    public class Solution {\\n        \\n        public int maxProfitBruteForce(int[] prices) {\\n            int max = 0;\\n            for(int i=0; i<prices.length; i++)\\n                for(int j=i+1; j<prices.length; j++)\\n                    max = prices[j]-prices[i] > max ? prices[j]-prices[i] : max;\\n            return max;\\n        }\\n        \\n        public int maxProfitRec(int[] prices, int i, int j) {\\n            if(i==j)\\n                return 0;\\n            int mid = (i+j) / 2;\\n            int leftProfit = maxProfitRec(prices, i, mid);\\n            int rightProfit = maxProfitRec(prices, mid+1, j);\\n            int subMax = Math.max(leftProfit,rightProfit);\\n            \\n            int leftMin = prices[i];\\n            for(int k=i+1; k<=mid; k++)\\n                leftMin = prices[k] < leftMin ? prices[k] : leftMin;\\n            \\n            int rightMax = prices[mid+1];\\n            for(int k=mid+2; k<=j; k++)\\n                rightMax = prices[k] > rightMax ? prices[k] : rightMax;\\n            \\n            int crossMax = Math.max(0,rightMax-leftMin);\\n            \\n            return Math.max(subMax,crossMax);\\n        }\\n        \\n        public int maxProfitDp(int[] prices) {\\n            int buy = prices[0];\\n            int max = 0;\\n            for(int i=1; i<prices.length; i++) {\\n                max = prices[i]-buy > max ? prices[i]-buy : max;\\n                if(prices[i]<buy)\\n                    buy = prices[i];\\n            }\\n            return max;\\n        }\\n        \\n        public int maxProfit(int[] prices) {\\n            if(prices.length==0)\\n                return 0;\\n            // return maxProfitBruteForce(prices);\\n            // return maxProfitRec(prices,0,prices.length-1);\\n            return maxProfitDp(prices);   \\n        }\\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public int maxProfitBruteForce(int[] prices) {\\n            int max = 0;\\n            for(int i=0; i<prices.length; i++)\\n                for(int j=i+1; j<prices.length; j++)\\n                    max = prices[j]-prices[i] > max ? prices[j]-prices[i] : max;\\n            return max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39294,
                "title": "c-o-n-solution-kind-of-greedy",
                "content": "    int maxProfit(vector<int>& prices) {\\n        int size=prices.size();\\n        int profit=0;\\n        int max=0;\\n        for(int i=1;i<size;++i){\\n            profit+=(prices[i]-prices[i-1]);\\n            if(profit>max)\\n               max=profit;\\n            if(profit<0)\\n               profit=0;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "    int maxProfit(vector<int>& prices) {\\n        int size=prices.size();\\n        int profit=0;\\n        int max=0;\\n        for(int i=1;i<size;++i){\\n            profit+=(prices[i]-prices[i-1]);\\n            if(profit>max)\\n               max=profit;\\n            if(profit<0)\\n               profit=0;\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39351,
                "title": "easy-solution-in-c-o-n-time-complexity-and-o-1-space-complexity",
                "content": "    int maxProfit(int price[], int n)\\n    {\\n        int ret = 0, past = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n    \\t    ret += price[i] - price[i-1];\\n    \\t    if(ret < 0) ret = 0;\\n    \\t    if(ret > past) past = ret;\\n        }\\n        return past;\\n    }",
                "solutionTags": [],
                "code": "    int maxProfit(int price[], int n)\\n    {\\n        int ret = 0, past = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n    \\t    ret += price[i] - price[i-1];\\n    \\t    if(ret < 0) ret = 0;\\n    \\t    if(ret > past) past = ret;\\n        }\\n        return past;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39367,
                "title": "short-python-solution-o-n-runtime-o-1-space",
                "content": "The question is simple. You want to find the difference of the maximum and the minimum. The only trick is that the bigger number should come after the smaller number.\\n\\nSo, here is how I tackled it. Instead of going forward, I scanned through the list of prices backward to store the current maximum number. Update the biggest difference along the way.\\n\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            length = len(prices)\\n            if length==0:\\n                return 0\\n            temp = prices[length-1]\\n            res = 0\\n            for i in range(length-1,-1,-1):\\n                temp = max(temp,prices[i])\\n                if temp - prices[i] > res:\\n                    res = temp - prices[i]\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "The question is simple. You want to find the difference of the maximum and the minimum. The only trick is that the bigger number should come after the smaller number.\\n\\nSo, here is how I tackled it. Instead of going forward, I scanned through the list of prices backward to store the current maximum number. Update the biggest difference along the way.\\n\\n\\n    class Solution:\\n        # @param prices, a list of integer\\n        # @return an integer\\n        def maxProfit(self, prices):\\n            length = len(prices)\\n            if length==0:\\n                return 0\\n            temp = prices[length-1]\\n            res = 0\\n            for i in range(length-1,-1,-1):\\n                temp = max(temp,prices[i])\\n                if temp - prices[i] > res:\\n                    res = temp - prices[i]\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 4062083,
                "title": "video-visualization-and-intuitive-proof-of-o-n-solution",
                "content": "https://youtube.com/watch?v=ioFPBdChabY\\n\\nA brute force approach would calculate every possible buy-sell combination and would run in O(n^2), but we can reduce this to O(n) by avoiding unncessary computations.  The strategy below iterates once for every sell date, and handles two cases:\\n1. If buy price < sell price, calculate the profit and compare it to the max profit so far.  If it is greater than the max profit, replace it.  Also, there is no need to go back and calculate profits using this <i>sell</i> date as a buy date, since we can always achieve a higher profit from using the original buy date (which is at a lower price).\\n2. If sell price <= buy date, simply update the buy date to be the current sell date, since we have found a lower price to buy from.\\n\\nAt the end, return `profit`, which will contain the maximum profit achievable.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        buy = prices[0]\\n        for sell in prices[1:]:\\n            if sell > buy:\\n                profit = max(profit, sell - buy)\\n            else:\\n                buy = sell\\n        \\n        return profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        profit = 0\\n        buy = prices[0]\\n        for sell in prices[1:]:\\n            if sell > buy:\\n                profit = max(profit, sell - buy)\\n            else:\\n                buy = sell\\n        \\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697960,
                "title": "java-striver-easy-approach",
                "content": "##### Optimal Approach \\nTime Complexity : O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\n\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        int minPrice = prices[0];\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(prices[i], minPrice);\\n            int profit = prices[i] - minPrice;\\n            maxProfit = Math.max(maxProfit, profit);\\n        }\\n        return maxProfit;\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/images/4adf4688-89b6-40bf-9298-fe5bcd52ba3d_1688563501.1123872.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxProfit(int[] prices) {\\n        int maxProfit = 0;\\n        int minPrice = prices[0];\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(prices[i], minPrice);\\n            int profit = prices[i] - minPrice;\\n            maxProfit = Math.max(maxProfit, profit);\\n        }\\n        return maxProfit;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333942,
                "title": "javascript-99-99-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<O(n)>\\n\\n- Space complexity:\\n<O(1)>\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let maxProfit = 0;\\n    let minPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        const currentPrice = prices[i];\\n        const currentProfit = currentPrice - minPrice;\\n        if (currentProfit > maxProfit) {\\n            maxProfit = currentProfit;\\n        }\\n        if (currentPrice < minPrice) {\\n            minPrice = currentPrice;\\n        }\\n    }\\n    return maxProfit;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let maxProfit = 0;\\n    let minPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        const currentPrice = prices[i];\\n        const currentProfit = currentPrice - minPrice;\\n        if (currentProfit > maxProfit) {\\n            maxProfit = currentProfit;\\n        }\\n        if (currentPrice < minPrice) {\\n            minPrice = currentPrice;\\n        }\\n    }\\n    return maxProfit;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272237,
                "title": "fast-5-lines-code-in-java-c",
                "content": "\\n# Algorithm\\n- keep min. value as first element of array\\n- Just travesrse left to right of array\\n  - Change value of min. only when you get a number smaller than it\\n  - Change value of profit only when you get a number greater than it\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C []\\nint maxProfit(int* prices, int pricesSize){\\n    int profit = 0, min = prices[0], temp;\\n    for(int i=1; i<pricesSize; i++){\\n        if(prices[i]<min) min = prices[i];\\n        temp = prices[i] - min;\\n        if(temp > profit) profit = temp;\\n    }\\n    return profit;\\n}\\n```\\n```JAVA []\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n    int profit = 0, min = prices[0], temp;\\n    for(int i=1; i<prices.length; i++){\\n        if(prices[i]<min) min = prices[i];\\n        temp = prices[i] - min;\\n        if(temp > profit) profit = temp;\\n    }\\n    return profit;\\n}\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```C []\\nint maxProfit(int* prices, int pricesSize){\\n    int profit = 0, min = prices[0], temp;\\n    for(int i=1; i<pricesSize; i++){\\n        if(prices[i]<min) min = prices[i];\\n        temp = prices[i] - min;\\n        if(temp > profit) profit = temp;\\n    }\\n    return profit;\\n}\\n```\n```JAVA []\\nclass Solution {\\npublic int maxProfit(int[] prices) {\\n    int profit = 0, min = prices[0], temp;\\n    for(int i=1; i<prices.length; i++){\\n        if(prices[i]<min) min = prices[i];\\n        temp = prices[i] - min;\\n        if(temp > profit) profit = temp;\\n    }\\n    return profit;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236117,
                "title": "easy-to-understand-solution-two-pointer-method",
                "content": "# Intuition\\nTo use **2-pointer** method to solve the stock buy sell problem.\\n\\n# Approach\\nwe take two variables **l** and **r** that we given the 0th and 1st index.\\nwe traverse the while loop till the array length.\\nwhen we get the price of **right index greater than the left index** we find out the profit.\\nthen we check if the profit it greater than maxp then we switch them by using **Math.max** fucntion.\\n\\nif the right index value is not greater than the left index value than we appoint left as right, (l = r).\\n\\nthen we increment the value of right pointer(r++) and the while loop goes on till the end.\\n\\nat the end of while loop we can get the value of maximum profit.\\n# Solution\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\t\\tint l = 0 , r = 1;\\n        int maxp = 0;\\n        int profit = 0;\\n        while (r < prices.length){\\n            if(prices[l] < prices[r]){\\n                profit = prices[r] - prices[l];\\n                maxp = Math.max(maxp,profit);\\n            }\\n            else{\\n                l = r;\\n            }\\n            r++;\\n        }\\n        return maxp;\\n    }\\n}\\n```\\n\\n# Time and Space Complexity\\n\\n**Time Complexity** : O(n)\\nAs we are moving in a linear motion in the array.\\n\\n**Space Complexity** : O(1)\\nAs we didn\\'t use any extra memory such as an extra array , so the space complexity is O(1)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\t\\tint l = 0 , r = 1;\\n        int maxp = 0;\\n        int profit = 0;\\n        while (r < prices.length){\\n            if(prices[l] < prices[r]){\\n                profit = prices[r] - prices[l];\\n                maxp = Math.max(maxp,profit);\\n            }\\n            else{\\n                l = r;\\n            }\\n            r++;\\n        }\\n        return maxp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772159,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit=0;\\n        int minelem=prices[0];\\n        for(int i=1;i<prices.size();i++){\\n           minelem=min(prices[i],minelem);\\n            profit=max(profit,(prices[i]-minelem));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296118,
                "title": "java-easy-solution-100-fast-explanation",
                "content": "```\\n*) The Idea of solution is very simple.\\n*) Just know the minimum element on left side w.r.to current array[i].\\n*) And then update the profit at current array[i](i.e by array[i] - minimum if and only if it is greater than profit).\\n*) Return profit.\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int min = Integer.MAX_VALUE;\\n        int profit = 0;\\n        for(int i=0; i < prices.length; i++){\\n            min = Math.min(min, prices[i]);\\n            profit = Math.max(prices[i] - min, profit);\\n        }\\n        return profit;\\n    }\\n}\\n\\nPlease do upvote, If you find it useful .  :-)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n*) The Idea of solution is very simple.\\n*) Just know the minimum element on left side w.r.to current array[i].\\n*) And then update the profit at current array[i](i.e by array[i] - minimum if and only if it is greater than profit).\\n*) Return profit.\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int min = Integer.MAX_VALUE;\\n        int profit = 0;\\n        for(int i=0; i < prices.length; i++){\\n            min = Math.min(min, prices[i]);\\n            profit = Math.max(prices[i] - min, profit);\\n        }\\n        return profit;\\n    }\\n}\\n\\nPlease do upvote, If you find it useful .  :-)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178784,
                "title": "c-solution-simple-brute-force-solution-tc-o-n-2",
                "content": "```\\n// Brute Force Solution\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n\\n        for(int i=0;i<prices.size();i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[j] > prices[i] && prices[j]-prices[i] > profit){\\n                    profit = (prices[j]-prices[i]);\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```\\n\\n**Please upvote if you find the solution useful, means a lot.**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Brute Force Solution\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit = 0;\\n\\n        for(int i=0;i<prices.size();i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[j] > prices[i] && prices[j]-prices[i] > profit){\\n                    profit = (prices[j]-prices[i]);\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995994,
                "title": "python-solution-95-easy",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        import math\\n        min_price = math.inf\\n        max_profit = 0\\n        for index in range(len(prices)):\\n            if prices[index] < min_price:\\n                min_price = prices[index]\\n            elif prices[index] - min_price > max_profit:\\n                max_profit = prices[index] - min_price\\n        return max_profit\\n",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        import math\\n        min_price = math.inf\\n        max_profit = 0\\n        for index in range(len(prices)):\\n            if prices[index] < min_price:\\n                min_price = prices[index]\\n            elif prices[index] - min_price > max_profit:\\n                max_profit = prices[index] - min_price\\n        return max_profit\\n",
                "codeTag": "Java"
            },
            {
                "id": 1517927,
                "title": "1-line-javascript-solution",
                "content": "```\\nfunction maxProfit(prices) { \\n    let max = 0, min = Infinity;\\n    prices.forEach(price => price < min ? min = price : max = Math.max(max, price - min));\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction maxProfit(prices) { \\n    let max = 0, min = Infinity;\\n    prices.forEach(price => price < min ? min = price : max = Math.max(max, price - min));\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153262,
                "title": "o-n-time-complexity-o-1-space-complexity-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int profit = 0, mini = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            mini = min(mini, prices[i]);\\n            if(mini < prices[i])\\n                profit = max(profit, (prices[i] - mini));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int profit = 0, mini = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            mini = min(mini, prices[i]);\\n            if(mini < prices[i])\\n                profit = max(profit, (prices[i] - mini));\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414863,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let max = 0;\\n    let min = Infinity;\\n    for(let i = 0; i < prices.length; i++) {\\n        min = Math.min(min, prices[i]);\\n        max = Math.max(max, prices[i] - min);\\n    }    \\n    \\n    return max;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    let max = 0;\\n    let min = Infinity;\\n    for(let i = 0; i < prices.length; i++) {\\n        min = Math.min(min, prices[i]);\\n        max = Math.max(max, prices[i] - min);\\n    }    \\n    \\n    return max;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 286814,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        var n = prices.Length;\\n        if (n == 0) return 0;\\n        var globalMaxProfit = 0;\\n        var globalMin = prices[0];\\n        for (int i = 1; i < n; i++) {\\n            var curPrice = prices[i];\\n            var localMaxProfit = Math.Max(0, curPrice - globalMin);\\n            globalMaxProfit = Math.Max(localMaxProfit, globalMaxProfit);\\n            globalMin = Math.Min(globalMin, curPrice);\\n        }\\n\\n        return globalMaxProfit;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        var n = prices.Length;\\n        if (n == 0) return 0;\\n        var globalMaxProfit = 0;\\n        var globalMin = prices[0];\\n        for (int i = 1; i < n; i++) {\\n            var curPrice = prices[i];\\n            var localMaxProfit = Math.Max(0, curPrice - globalMin);\\n            globalMaxProfit = Math.Max(localMaxProfit, globalMaxProfit);\\n            globalMin = Math.Min(globalMin, curPrice);\\n        }\\n\\n        return globalMaxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154770,
                "title": "go-dp-bottom-up-single-loop-beats-100-with-explanation",
                "content": "Key observation: prices[2] - prices[0] = prices[2] - prices[1] + prices[1] - prices[0]\\n```\\nfunc maxProfit(prices []int) int {\\n    tmp := 0\\n    max := 0\\n    for i := 1; i < len(prices); i++ {\\n        tmp += prices[i] - prices[i-1]\\n        if tmp < 0 {\\n            tmp = 0\\n        }\\n        if tmp > max {\\n            max = tmp\\n        }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxProfit(prices []int) int {\\n    tmp := 0\\n    max := 0\\n    for i := 1; i < len(prices); i++ {\\n        tmp += prices[i] - prices[i-1]\\n        if tmp < 0 {\\n            tmp = 0\\n        }\\n        if tmp > max {\\n            max = tmp\\n        }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39064,
                "title": "dynamic-programming-explanation",
                "content": "```\\nclass Solution {\\n    //Dynamic programming. Using OPT[i] refers to the max profit we can get from first i days.\\n    /*OPT[i] = OPT[i-1] do nothing in day i or buy ticket in day i.\\n      OPT[i] = price[i] - smallest_value_from_first_i-1_days.\\n    */\\n    public int maxProfit(int[] prices) {\\n        //one exception: no day\\n        if(prices.length == 0)  return 0;\\n        int[] OPT = new int[prices.length];\\n        int smallest = prices[0];\\n        for(int i = 1; i < prices.length; i++){\\n            OPT[i] = Math.max(OPT[i-1], prices[i]-smallest);\\n            smallest = Math.min(smallest, prices[i]);\\n        }\\n        return OPT[OPT.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //Dynamic programming. Using OPT[i] refers to the max profit we can get from first i days.\\n    /*OPT[i] = OPT[i-1] do nothing in day i or buy ticket in day i.\\n      OPT[i] = price[i] - smallest_value_from_first_i-1_days.\\n    */\\n    public int maxProfit(int[] prices) {\\n        //one exception: no day\\n        if(prices.length == 0)  return 0;\\n        int[] OPT = new int[prices.length];\\n        int smallest = prices[0];\\n        for(int i = 1; i < prices.length; i++){\\n            OPT[i] = Math.max(OPT[i-1], prices[i]-smallest);\\n            smallest = Math.min(smallest, prices[i]);\\n        }\\n        return OPT[OPT.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39250,
                "title": "clearly-simple-java-solution",
                "content": "public class Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        if(prices==null || prices.length==0)\\n            return 0;\\n        \\n        int buyPrice = prices[0];\\n        int max = 0;\\n        \\n        int len = prices.length;\\n        for(int i=0;i<len;i++){\\n            \\n            if(prices[i]<buyPrice)\\n                buyPrice = prices[i];\\n            else{\\n                int newProfit = prices[i]-buyPrice ;\\n                max = ( newProfit>max ? newProfit : max);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        \\n        if(prices==null || prices.length==0)\\n            return 0;\\n        \\n        int buyPrice = prices[0];\\n        int max = 0;\\n        \\n        int len = prices.length;\\n        for(int i=0;i<len;i++){\\n            \\n            if(prices[i]<buyPrice)\\n                buyPrice = prices[i];\\n            else{\\n                int newProfit = prices[i]-buyPrice ;\\n                max = ( newProfit>max ? newProfit : max);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39153,
                "title": "simplest-dp-solution-in-java",
                "content": "public class Solution {\\n\\n    public int maxProfit(int[] prices) {\\n\\n        int min = Integer.MAX_VALUE;\\n        int max = 0;\\n\\n        for(int p:prices) {\\n            min = Math.min(min, p);\\n            max = Math.max(p-min, max);\\n        }\\n\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int maxProfit(int[] prices) {\\n\\n        int min = Integer.MAX_VALUE;\\n        int max = 0;\\n\\n        for(int p:prices) {\\n            min = Math.min(min, p);\\n            max = Math.max(p-min, max);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3818335,
                "title": "explained-c-easy-and-clean-code-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We\\'ll chose minimum element from array for buying\\n- And max element from array after the minimum element\\n- and calculate the maximum possible profit\\n- Res will be the answer\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int result=0, minVal = INT_MAX;\\n        int soldToday = -1;\\n        for(int price: prices){\\n            minVal = min(price, minVal);\\n            soldToday = price-minVal;\\n            result = max(result, soldToday);\\n        }     \\n        return result;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int result=0, minVal = INT_MAX;\\n        int soldToday = -1;\\n        for(int price: prices){\\n            minVal = min(price, minVal);\\n            soldToday = price-minVal;\\n            result = max(result, soldToday);\\n        }     \\n        return result;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538972,
                "title": "c-easy-solution-additional-variables-simple-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: const;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() == 0) return 0;\\n        int max, min, i, temp_min, temp_max;\\n        for (i = 0, min = max = temp_max = temp_min = prices[0]; i < prices.size(); i++) {\\n            if (temp_min > prices[i]) temp_min = temp_max = prices[i];\\n            if (temp_max <= prices[i] && prices[i] >  temp_min) temp_max = prices[i];\\n            if (temp_max - temp_min > max - min) {\\n                max = temp_max;\\n                min = temp_min;\\n            }\\n        }\\n        return max - min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() == 0) return 0;\\n        int max, min, i, temp_min, temp_max;\\n        for (i = 0, min = max = temp_max = temp_min = prices[0]; i < prices.size(); i++) {\\n            if (temp_min > prices[i]) temp_min = temp_max = prices[i];\\n            if (temp_max <= prices[i] && prices[i] >  temp_min) temp_max = prices[i];\\n            if (temp_max - temp_min > max - min) {\\n                max = temp_max;\\n                min = temp_min;\\n            }\\n        }\\n        return max - min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411647,
                "title": "easiest-apporach-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is  a common algorithm for solving the problem of finding the maximum profit that can be made from buying and selling a stock represented by a vector of prices.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function initializes a variable i to 0, representing the current index in the vector. It then **initializes a variable min** to the first element in the vector, representing the minimum price seen so far. It also initializes a variable profit to 0, representing the maximum profit seen so far.\\n\\nThe function then enters a loop that iterates through the remaining elements in the vector. For each element, the function **checks if it is greater than the current minimum price (min)**. If it is, **then the function calculates the profit that could be made by selling at this price and updates the profit variable if the calculated profit is greater than the current maximum**. If the element is less than the current minimum, then the function **updates the min variable** to this element, representing a new minimum price seen so far.\\n\\nAfter iterating through all the elements, the function returns the maximum profit seen during the iteration.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int min = prices[0];\\n        int profit = 0;\\n        for(int i=1;i<prices.size();i++){\\n\\n        //checks and upadtes the profit if price less than min\\n\\n            if(prices[i]>min){\\n               profit = max(profit,prices[i]-min);\\n            }\\n            else if (prices[i]<min){\\n                min = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int min = prices[0];\\n        int profit = 0;\\n        for(int i=1;i<prices.size();i++){\\n\\n        //checks and upadtes the profit if price less than min\\n\\n            if(prices[i]>min){\\n               profit = max(profit,prices[i]-min);\\n            }\\n            else if (prices[i]<min){\\n                min = prices[i];\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228818,
                "title": "superb-logic-question-three-approaches",
                "content": "# Easy approach\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ans,buy=0,prices[0]\\n        for cost in prices[1:]:\\n            if cost<buy:\\n                buy=cost\\n            ans=max(ans,cost-buy)\\n        return ans\\n```\\n# Simple Approches:\\n```\\nclass Solution:\\n    def maxProfit(self, arr: List[int]) -> int:\\n        buy=arr[0]\\n        sell=0\\n        n=len(arr)\\n        profit=0\\n        for i in range(1,n):\\n            if arr[i]<buy:\\n                buy=arr[i]\\n            if arr[i]>buy:\\n                sell=arr[i]\\n                profit=max(profit,sell-buy)\\n        return profit\\n```\\n# Two Pointers Approches\\n```\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left,right,maxprofit=0,1,0\\n        while right<len(prices):\\n            if prices[left]<prices[right]:\\n                currentprofit=prices[right]-prices[left]\\n                maxprofit=max(currentprofit,maxprofit)\\n            else:\\n                left=right\\n            right+=1\\n        return maxprofit\\n    \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        ans,buy=0,prices[0]\\n        for cost in prices[1:]:\\n            if cost<buy:\\n                buy=cost\\n            ans=max(ans,cost-buy)\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxProfit(self, arr: List[int]) -> int:\\n        buy=arr[0]\\n        sell=0\\n        n=len(arr)\\n        profit=0\\n        for i in range(1,n):\\n            if arr[i]<buy:\\n                buy=arr[i]\\n            if arr[i]>buy:\\n                sell=arr[i]\\n                profit=max(profit,sell-buy)\\n        return profit\\n```\n```\\nclass Solution:\\n    def maxProfit(self,prices):\\n        left,right,maxprofit=0,1,0\\n        while right<len(prices):\\n            if prices[left]<prices[right]:\\n                currentprofit=prices[right]-prices[left]\\n                maxprofit=max(currentprofit,maxprofit)\\n            else:\\n                left=right\\n            right+=1\\n        return maxprofit\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195802,
                "title": "beats-93-69-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe basic idea is to loop through each price in the list and keep track of the minimum price seen so far and the maximum profit that can be made by selling the stock at that price. If the current price is less than the minimum price so far, update the minimum price. If the difference between the current price and the minimum price is greater than the maximum profit so far, update the maximum profit. Finally, return the maximum profit.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = float(\\'inf\\') # initialize minimum price to positive infinity\\n        max_profit = 0 # initialize maximum profit to zero\\n        \\n        for price in prices: # loop through each price in the list\\n            if price < min_price: # if price is less than minimum price so far\\n                min_price = price # update minimum price\\n            elif price - min_price > max_profit: # if selling price - buying price is greater than max profit so far\\n                max_profit = price - min_price # update max profit\\n        \\n        return max_profit # return the maximum profit\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        min_price = float(\\'inf\\') # initialize minimum price to positive infinity\\n        max_profit = 0 # initialize maximum profit to zero\\n        \\n        for price in prices: # loop through each price in the list\\n            if price < min_price: # if price is less than minimum price so far\\n                min_price = price # update minimum price\\n            elif price - min_price > max_profit: # if selling price - buying price is greater than max profit so far\\n                max_profit = price - min_price # update max profit\\n        \\n        return max_profit # return the maximum profit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188772,
                "title": "python3-easy-explanation-91-fast",
                "content": "![Capture.PNG](https://assets.leetcode.com/users/images/447d8e46-9cae-4879-bc1a-bc5a90db7f65_1676458994.5410964.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- buy when lowest price found.\\n- if next is not lower price try to sell but here we\\'ew keeping track of last lowest so everytime high price comes we will compare it to lowest.\\n- if next low value comes sell it and keep track of old max profit.\\n- do till all daysa are covered.\\n- return found profit.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        low = float(\"inf\")\\n        for i in prices:\\n            if low > i:\\n                low = i\\n            elif i - low > profit:\\n                profit = i - low\\n        return profit\\n```\\n# Please like and comment below :-)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        low = float(\"inf\")\\n        for i in prices:\\n            if low > i:\\n                low = i\\n            elif i - low > profit:\\n                profit = i - low\\n        return profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088782,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int curr_sell=prices[0];\\n        int profit=0;\\n        for(int i=1;i<n;i++){\\n            profit = max(profit,prices[i]-curr_sell);\\n            curr_sell = min(curr_sell,prices[i]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int curr_sell=prices[0];\\n        int profit=0;\\n        for(int i=1;i<n;i++){\\n            profit = max(profit,prices[i]-curr_sell);\\n            curr_sell = min(curr_sell,prices[i]);\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718970,
                "title": "python-c-java-faster-than-100-short-simple-solution-beginnerlevel",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q121. Best Time to Buy and Sell Stock***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        l, r = 0, 1\\n        maxp = 0\\n        while r < len(prices):\\n            if prices[l] < prices[r]:\\n                profit = prices[r] - prices[l]\\n                maxp = max(maxp, profit)\\n            else:\\n                l = r\\n            r += 1\\n        return maxp\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length==0)\\n            return 0;\\n    int n = prices.size();\\n        int profit = 0, pointer = prices[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] < pointer) pointer = prices[i];\\n            \\n            else profit = max(profit, prices[i] - pointer);\\n        }\\n        \\n        return profit;\\n}\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int profit = 0, pointer = prices[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] < pointer) pointer = prices[i];\\n            \\n            else profit = max(profit, prices[i] - pointer);\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        l, r = 0, 1\\n        maxp = 0\\n        while r < len(prices):\\n            if prices[l] < prices[r]:\\n                profit = prices[r] - prices[l]\\n                maxp = max(maxp, profit)\\n            else:\\n                l = r\\n            r += 1\\n        return maxp\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length==0)\\n            return 0;\\n    int n = prices.size();\\n        int profit = 0, pointer = prices[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] < pointer) pointer = prices[i];\\n            \\n            else profit = max(profit, prices[i] - pointer);\\n        }\\n        \\n        return profit;\\n}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int profit = 0, pointer = prices[0];\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(prices[i] < pointer) pointer = prices[i];\\n            \\n            else profit = max(profit, prices[i] - pointer);\\n        }\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715902,
                "title": "121-best-time-to-buy-and-sell-stock-js",
                "content": "```\\nRuntime: 92 ms, faster than 91.28% of JavaScript online submissions for Best Time to Buy and Sell Stock.\\nMemory Usage: 51.7 MB, less than 66.52% of JavaScript online submissions for Best Time to Buy and Sell Stock.\\n\\n// We need to have two vars profit and difference.\\n// By Looping through the loop starting from the\\n// 1th element in prices array we substract the 0th element from the 1th\\n// element and save the difference in the difference var, after this we get the biggest \\n// number between profit and difference, to get the day with highest profit.\\n\\nconst maxProfit = (prices) => {\\n    let profit = 0;\\n    let left = 0;\\n    for(let right = 1 ; right< prices.length ; right++){\\n        if(prices[left]<prices[right]){\\n            let difference = prices[right] - prices[left];\\n            profit = Math.max(profit, difference);\\n        }\\n        else{\\n            left = right;\\n        }\\n    }\\n    return profit ?? 0;\\n};\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nRuntime: 92 ms, faster than 91.28% of JavaScript online submissions for Best Time to Buy and Sell Stock.\\nMemory Usage: 51.7 MB, less than 66.52% of JavaScript online submissions for Best Time to Buy and Sell Stock.\\n\\n// We need to have two vars profit and difference.\\n// By Looping through the loop starting from the\\n// 1th element in prices array we substract the 0th element from the 1th\\n// element and save the difference in the difference var, after this we get the biggest \\n// number between profit and difference, to get the day with highest profit.\\n\\nconst maxProfit = (prices) => {\\n    let profit = 0;\\n    let left = 0;\\n    for(let right = 1 ; right< prices.length ; right++){\\n        if(prices[left]<prices[right]){\\n            let difference = prices[right] - prices[left];\\n            profit = Math.max(profit, difference);\\n        }\\n        else{\\n            left = right;\\n        }\\n    }\\n    return profit ?? 0;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2675038,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n            int profit = 0;\\n            int min_pr = INT_MAX;\\n            for(int i = 0 ;i<prices.size(); i++){\\n                    int cost = prices[i] - min_pr;\\n                    min_pr = min(min_pr,prices[i]);\\n                    profit = max(profit ,cost);\\n            }\\n            return profit;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n            int profit = 0;\\n            int min_pr = INT_MAX;\\n            for(int i = 0 ;i<prices.size(); i++){\\n                    int cost = prices[i] - min_pr;\\n                    min_pr = min(min_pr,prices[i]);\\n                    profit = max(profit ,cost);\\n            }\\n            return profit;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518795,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int mini = prices[0];\\n    int maxProfit  = 0;\\n    int n = prices.size();\\n    for(int i=0;i<n;i++){\\n        int cost =  prices[i] - mini;\\n        maxProfit = max(maxProfit, cost);\\n        mini = min(mini,prices[i]);\\n    }\\n    return maxProfit;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int mini = prices[0];\\n    int maxProfit  = 0;\\n    int n = prices.size();\\n    for(int i=0;i<n;i++){\\n        int cost =  prices[i] - mini;\\n        maxProfit = max(maxProfit, cost);\\n        mini = min(mini,prices[i]);\\n    }\\n    return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198965,
                "title": "java-solution-easy-to-understand-upvote-as-well",
                "content": "***<----Click there to give thumbs up ;)***\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int length = prices.length;\\n        int minValue = prices[0];\\n        int maxProfit = 0;\\n        \\n        for(int i = 1; i < length; i++){\\n            maxProfit = Math.max(prices[i]-minValue,maxProfit); // Every time check the profit, i.e, current price - previous minimum price\\n            minValue = Math.min(minValue, prices[i]); // If current value is less than the existing minimum value, that means new minimum value will be current value\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int length = prices.length;\\n        int minValue = prices[0];\\n        int maxProfit = 0;\\n        \\n        for(int i = 1; i < length; i++){\\n            maxProfit = Math.max(prices[i]-minValue,maxProfit); // Every time check the profit, i.e, current price - previous minimum price\\n            minValue = Math.min(minValue, prices[i]); // If current value is less than the existing minimum value, that means new minimum value will be current value\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785769,
                "title": "java-clean-code-with-explanation-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //keep a minprice variable which denotes the min price uptill that particular day \\n        //profit on that day = cost of the stock on that day - minprice\\n        //if the price of stock on that day < minprice then update minprice\\n        //keep a maxprofit variable and keep updating it as you traverse along the array\\n        \\n        int minprice = prices[0], maxprofit = 0;\\n        for(int day=1; day<prices.length; day++){\\n            int present_day_profit = prices[day] - minprice;\\n            \\n            if(present_day_profit>maxprofit) maxprofit = present_day_profit;\\n            \\n            if(prices[day]<minprice){\\n                minprice = prices[day];\\n            }\\n            \\n        }\\n        return maxprofit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        //keep a minprice variable which denotes the min price uptill that particular day \\n        //profit on that day = cost of the stock on that day - minprice\\n        //if the price of stock on that day < minprice then update minprice\\n        //keep a maxprofit variable and keep updating it as you traverse along the array\\n        \\n        int minprice = prices[0], maxprofit = 0;\\n        for(int day=1; day<prices.length; day++){\\n            int present_day_profit = prices[day] - minprice;\\n            \\n            if(present_day_profit>maxprofit) maxprofit = present_day_profit;\\n            \\n            if(prices[day]<minprice){\\n                minprice = prices[day];\\n            }\\n            \\n        }\\n        return maxprofit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735814,
                "title": "python-3-o-n-simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # tracking the minimum while traverse\\n        # and maximizing the variable\\n        current_min, max_so_far = float(\\'inf\\'), 0\\n        for price in prices:\\n            current_min = min(current_min,  price)\\n            max_so_far = max(max_so_far, price-current_min)\\n        return max_so_far\\n```\\n\\nSimilar problems can be solved using Kadane\\'s Algorithm (DP)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # tracking the minimum while traverse\\n        # and maximizing the variable\\n        current_min, max_so_far = float(\\'inf\\'), 0\\n        for price in prices:\\n            current_min = min(current_min,  price)\\n            max_so_far = max(max_so_far, price-current_min)\\n        return max_so_far\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694218,
                "title": "easiest-and-compact-approach-o-n-c",
                "content": "```\\n  int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        \\n        int minVal = prices[0];\\n        int ans = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            ans = max(ans,prices[i]-minVal);\\n            \\n            minVal = min(minVal,prices[i]);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int maxProfit(vector<int>& prices)\\n    {\\n        int n = prices.size();\\n        \\n        int minVal = prices[0];\\n        int ans = 0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            ans = max(ans,prices[i]-minVal);\\n            \\n            minVal = min(minVal,prices[i]);\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514338,
                "title": "simple-and-clear-java-solution-o-n-time-and-o-1-space-best-time-to-buy-and-sell-stock",
                "content": "We just need to find maximum profit, for which we will buy the stock when it is minimum and sell it when it is maximum also we will not sell it on the same day we buy it.\\n```\\npublic int maxProfit(int[] prices) {\\n        int buy = prices[0];\\n        int profit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (buy > prices[i]) {\\n                buy = prices[i]; // buy when price is minimum\\n            } else if (prices[i] - buy > profit) { \\n                profit = prices[i] - buy; // sell only when we have max profit\\n            }\\n        }\\n        return profit;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n        int buy = prices[0];\\n        int profit = 0;\\n        for (int i = 1; i < prices.length; i++) {\\n            if (buy > prices[i]) {\\n                buy = prices[i]; // buy when price is minimum\\n            } else if (prices[i] - buy > profit) { \\n                profit = prices[i] - buy; // sell only when we have max profit\\n            }\\n        }\\n        return profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431436,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function (prices) {\\n  let result = 0;\\n  let lowestPrice = prices[0];\\n\\n  for (let i = 0; i < prices.length; i++) {\\n    lowestPrice = Math.min(prices[i], lowestPrice);\\n    result = Math.max(result, prices[i] - lowestPrice);\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function (prices) {\\n  let result = 0;\\n  let lowestPrice = prices[0];\\n\\n  for (let i = 0; i < prices.length; i++) {\\n    lowestPrice = Math.min(prices[i], lowestPrice);\\n    result = Math.max(result, prices[i] - lowestPrice);\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370459,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func maxProfit(_ p: [Int]) -> Int {\\n        guard !p.isEmpty else { return 0 }\\n        var bday = 0, prof = 0\\n        for i in p.indices.dropFirst() {\\n            bday = max(0, bday + p[i] - p[i-1])\\n            prof = max(prof, bday)\\n        }\\n        return prof\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n    // Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n    func test0() {\\n        let value = solution.maxProfit([7,1,5,3,6,4])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // In this case, no transactions are done and the max profit = 0.\\n    func test1() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxProfit(_ p: [Int]) -> Int {\\n        guard !p.isEmpty else { return 0 }\\n        var bday = 0, prof = 0\\n        for i in p.indices.dropFirst() {\\n            bday = max(0, bday + p[i] - p[i-1])\\n            prof = max(prof, bday)\\n        }\\n        return prof\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n    // Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n    func test0() {\\n        let value = solution.maxProfit([7,1,5,3,6,4])\\n        XCTAssertEqual(value, 5)\\n    }\\n    \\n    // In this case, no transactions are done and the max profit = 0.\\n    func test1() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330044,
                "title": "c-brute-force-efficient-solution-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) { \\n    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n    int len=prices.size(),profit=0;\\n        for(int i=0;i<len;i++){\\n            for(int j=i+1;j<len;j++){\\n                if(prices[j]>prices[i]){\\n                    int pro=prices[j]-prices[i];\\n                    profit=max(profit,pro);\\n                }\\n            }\\n        }\\n    return profit; \\n  }\\n};\\n```\\n\\n**Efficient Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n    // Efficient Solution Time O(N) & Auxiliary Space O(1)\\n    int min_val=INT_MAX,profit=0,len=prices.size();\\n    for(int i=0;i<len;i++){\\n          min_val=min(min_val,prices[i]);\\n          profit=max(profit,prices[i]-min_val);\\n        }\\n    return profit;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) { \\n    // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n    int len=prices.size(),profit=0;\\n        for(int i=0;i<len;i++){\\n            for(int j=i+1;j<len;j++){\\n                if(prices[j]>prices[i]){\\n                    int pro=prices[j]-prices[i];\\n                    profit=max(profit,pro);\\n                }\\n            }\\n        }\\n    return profit; \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n    // Efficient Solution Time O(N) & Auxiliary Space O(1)\\n    int min_val=INT_MAX,profit=0,len=prices.size();\\n    for(int i=0;i<len;i++){\\n          min_val=min(min_val,prices[i]);\\n          profit=max(profit,prices[i]-min_val);\\n        }\\n    return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067884,
                "title": "python-dp-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 0:\\n            return 0\\n\\t\\t# dp is an array of tuples where the first element in the tuple\\n\\t\\t# represents the cheapest stock I could have bought on the i\\'th day and the second\\n\\t\\t# element represents the max profit I could make on the i\\'th day\\n        dp = [(0, 0)]*len(prices)\\n        dp[0] = (prices[0], 0)\\n        for i in range(1, len(prices)):\\n            dp[i] = (min(dp[i - 1][0], prices[i]), max(prices[i] - dp[i - 1][0], dp[i - 1][1]))\\n        return dp[len(prices) - 1][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) == 0:\\n            return 0\\n\\t\\t# dp is an array of tuples where the first element in the tuple\\n\\t\\t# represents the cheapest stock I could have bought on the i\\'th day and the second\\n\\t\\t# element represents the max profit I could make on the i\\'th day\\n        dp = [(0, 0)]*len(prices)\\n        dp[0] = (prices[0], 0)\\n        for i in range(1, len(prices)):\\n            dp[i] = (min(dp[i - 1][0], prices[i]), max(prices[i] - dp[i - 1][0], dp[i - 1][1]))\\n        return dp[len(prices) - 1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981294,
                "title": "python3-two-pointer",
                "content": "```\\n# Two point\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        l, r = 0, 1\\n        maxProfit = 0\\n        \\n        while(r < len(prices)):\\n            if prices[l] <= prices[r]:\\n                maxProfit = max(maxProfit, prices[r] - prices[l])\\n                r += 1\\n            else:\\n                l = r\\n                r += 1\\n        \\n        return maxProfit\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n# Two point\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        l, r = 0, 1\\n        maxProfit = 0\\n        \\n        while(r < len(prices)):\\n            if prices[l] <= prices[r]:\\n                maxProfit = max(maxProfit, prices[r] - prices[l])\\n                r += 1\\n            else:\\n                l = r\\n                r += 1\\n        \\n        return maxProfit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 908061,
                "title": "state-machine-beats-100",
                "content": "\\nIf we are in S1, it means we bought a stock at current time or we bought it in past.\\nIf we are in S2, it means we sold a stock at current time or we sold it in past.\\n\\nAt beginning, only way to be in S1 is to buy stock at that time.\\nAt beginning, there is no way to be in S2, so it is undefined (`INT_MIN`).\\n\\n![image](https://assets.leetcode.com/users/images/2292f521-67ae-4f0d-bb59-db6389690725_1603536167.8704946.png)\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() < 2) {\\n            return 0;\\n        }\\n        int n = prices.size();\\n        vector<vector<int>> dp(2, vector<int> (n));\\n        dp[0][0] = -prices[0], dp[1][0] = INT_MIN;\\n        for(int i = 1; i < n; ++i) {\\n            dp[0][i] = max(dp[0][i - 1], -prices[i]);\\n            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i]);\\n        }\\n        return max(0, dp[1][n - 1]);\\n    }\\n};\\n```\\n\\nO(1) space can be achieved by utilizing the fact that only the previous state is required to construct current state.\\n\\nInspired by this [post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking))",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() < 2) {\\n            return 0;\\n        }\\n        int n = prices.size();\\n        vector<vector<int>> dp(2, vector<int> (n));\\n        dp[0][0] = -prices[0], dp[1][0] = INT_MIN;\\n        for(int i = 1; i < n; ++i) {\\n            dp[0][i] = max(dp[0][i - 1], -prices[i]);\\n            dp[1][i] = max(dp[1][i - 1], dp[0][i - 1] + prices[i]);\\n        }\\n        return max(0, dp[1][n - 1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852196,
                "title": "o-n-solution-dynamic-programming-c-optimal-solution-detailed-explanation",
                "content": "\\nYoutube link : https://youtu.be/0-6V7nDG8TY\\nFollow for further updates.\\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profit=0;\\n        int minvalue=INT_MAX;\\n        \\n        for(int i=0;i<prices.size();i++)\\n        {\\n            minvalue=min(minvalue,prices[i]);\\n            profit=max(profit,prices[i]-minvalue);\\n        }\\n        \\n        return profit;\\n        \\n    }\\n};\\n\\n\\n// FORMULA FOR CALCULATING PROFIT\\n\\n\\n// profit=(price of stock on ith day)-(min value of stock till ith day)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profit=0;\\n        int minvalue=INT_MAX;\\n        \\n        for(int i=0;i<prices.size();i++)\\n        {\\n            minvalue=min(minvalue,prices[i]);\\n            profit=max(profit,prices[i]-minvalue);\\n        }\\n        \\n        return profit;\\n        \\n    }\\n};\\n\\n\\n// FORMULA FOR CALCULATING PROFIT\\n\\n\\n// profit=(price of stock on ith day)-(min value of stock till ith day)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813030,
                "title": "php-faster-than-100",
                "content": "Faster than 100%\\n function maxProfit($prices) {\\n \\n        $min = $prices[0]; $max = 0;\\n    \\n         for($i = 1; $i < count($prices); $i++){\\n           if($prices[$i] - $min > $max) $max = $prices[$i] - $min;\\n           if($prices[$i] < $min) $min = $prices[$i];\\n        }\\n    \\n        return $max;\\n}\\n\\n**+-----------------------+------------------------+----------------------+**\\n\\nFaster than 68%\\n\\nfunction maxProfit($prices) {   \\n      \\n        $min = $prices[0]; $max = 0;\\n    \\n        for($i = 1; $i < count($prices); $i++){\\n          $max = max($prices[$i] - $min, $max);\\n          $min = min($prices[$i], $min);\\n        }\\n    \\n        return $max;\\n      \\n}",
                "solutionTags": [
                    "PHP"
                ],
                "code": "Faster than 100%\\n function maxProfit($prices) {\\n \\n        $min = $prices[0]; $max = 0;\\n    \\n         for($i = 1; $i < count($prices); $i++){\\n           if($prices[$i] - $min > $max) $max = $prices[$i] - $min;\\n           if($prices[$i] < $min) $min = $prices[$i];\\n        }\\n    \\n        return $max;\\n}\\n\\n**+-----------------------+------------------------+----------------------+**\\n\\nFaster than 68%\\n\\nfunction maxProfit($prices) {   \\n      \\n        $min = $prices[0]; $max = 0;\\n    \\n        for($i = 1; $i < count($prices); $i++){\\n          $max = max($prices[$i] - $min, $max);\\n          $min = min($prices[$i], $min);\\n        }\\n    \\n        return $max;\\n      \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 711172,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar maxProfit = function(prices) {\\n    let maxProfit = 0;\\n    let buyingPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        if (prices[i] > buyingPrice) {\\n            let tempProfit = prices[i] - buyingPrice;\\n            maxProfit = Math.max(maxProfit, tempProfit);\\n        }\\n        if (prices[i] < buyingPrice) {\\n            buyingPrice = prices[i];\\n        }\\n    }\\n    return maxProfit;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n\\n/*\\nTest Cases:\\n[3,7,0,1,2,2,3] => 4\\n[] => 0\\n[1] => 0 since we can\\'t perform selling\\n[2, 1] => 0\\n\\nIdea:\\n1. Create two variables, one of which will track the maximum possible profit so far and the other of which will track my buying price.\\nI initialise maximum profit to zero because we start with no profit, and I initialise my buying price to the first element of the array \\nsince this is the first possible price I can buy a stock at.\\n2. Loop over every number in the array from the second element.\\nEvery time I can make a profit (so when the current price is higher than the price I bought), I will compare the maximum profit so far\\nand the profit I can make through this transaction and update my tracking variable if I can make a higher profit through this transaction.\\nAlso, every time I encounter a price lower that the price I bought, update my buying price to this lower price because I want to maximise my profit.\\n3. Return the maximum profit.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n    let maxProfit = 0;\\n    let buyingPrice = prices[0];\\n    for (let i = 1; i < prices.length; i++) {\\n        if (prices[i] > buyingPrice) {\\n            let tempProfit = prices[i] - buyingPrice;\\n            maxProfit = Math.max(maxProfit, tempProfit);\\n        }\\n        if (prices[i] < buyingPrice) {\\n            buyingPrice = prices[i];\\n        }\\n    }\\n    return maxProfit;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n\\n/*\\nTest Cases:\\n[3,7,0,1,2,2,3] => 4\\n[] => 0\\n[1] => 0 since we can\\'t perform selling\\n[2, 1] => 0\\n\\nIdea:\\n1. Create two variables, one of which will track the maximum possible profit so far and the other of which will track my buying price.\\nI initialise maximum profit to zero because we start with no profit, and I initialise my buying price to the first element of the array \\nsince this is the first possible price I can buy a stock at.\\n2. Loop over every number in the array from the second element.\\nEvery time I can make a profit (so when the current price is higher than the price I bought), I will compare the maximum profit so far\\nand the profit I can make through this transaction and update my tracking variable if I can make a higher profit through this transaction.\\nAlso, every time I encounter a price lower that the price I bought, update my buying price to this lower price because I want to maximise my profit.\\n3. Return the maximum profit.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676371,
                "title": "java-with-picture",
                "content": "\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_121_using_dp.png)  \\n\\n\\n``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int len = prices.length;\\n        for (int i = 0; i < len; i++){\\n            for (int j = i + 1; j < len; j++){\\n                max = Math.max(max, prices[j] - prices[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nTime complexity is O(N^2)  \\n\\n\\nLet\\'s optimize it to O(N).\\n\\n\\n``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int len = prices.length;\\n        if (len == 0) return 0;\\n        int preMin = prices[0];\\n        int maxPro = 0;\\n\\n        for (int i = 1; i < len; i++){\\n            int cur = prices[i];\\n            maxPro = Math.max(maxPro, cur - preMin);\\n            preMin = Math.min(preMin, cur);\\n        }\\n        return maxPro;\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int len = prices.length;\\n        for (int i = 0; i < len; i++){\\n            for (int j = i + 1; j < len; j++){\\n                max = Math.max(max, prices[j] - prices[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int len = prices.length;\\n        if (len == 0) return 0;\\n        int preMin = prices[0];\\n        int maxPro = 0;\\n\\n        for (int i = 1; i < len; i++){\\n            int cur = prices[i];\\n            maxPro = Math.max(maxPro, cur - preMin);\\n            preMin = Math.min(preMin, cur);\\n        }\\n        return maxPro;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613191,
                "title": "8-line-java-solution-o-n-o-1-intuitive-solution",
                "content": "I found that using terms like \"buy\" and \"profit\" made this problem easier to understand/ code. \\n\\n**The question to avoid is:** If a buy a stock today, what\\'s the best price I can sell at? You go through every price and check your profit margins. This leads to O(n^2). \\n**A better question is:** What is the best stock to buy **today**, what\\'s the best price I can sell at? Because you continually adjust your buy time, you can go through the array once. \\n\\nGetting the perfect solution is all about perspective. \\n1. Go through the entire array. \\n2. If the current price of a stock is less than our previous purchase, we buy the stock \\n3. Otherwise, we sell the stock at the current price\\n4. We take note if there was a larger profit. \\n```\\npublic int maxProfit(int[] prices) {\\n        int profit = 0, \\n        buy = Integer.MAX_VALUE; \\n        for (int i = 0; i < prices.length; i ++){\\n            if (prices[i] < buy)\\n                buy = prices[i]; \\n\\t\\t\\telse\\n\\t\\t\\t\\tprofit = Math.max(profit, prices[i] - buy); \\n        }\\n        return profit; \\n    }\\n```\\nWe do not need the else, but for clarity, I included it. On either day we either buy or sell. (But If we buy/sell on the same day, we make 0 profit anyways). \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n        int profit = 0, \\n        buy = Integer.MAX_VALUE; \\n        for (int i = 0; i < prices.length; i ++){\\n            if (prices[i] < buy)\\n                buy = prices[i]; \\n\\t\\t\\telse\\n\\t\\t\\t\\tprofit = Math.max(profit, prices[i] - buy); \\n        }\\n        return profit; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591350,
                "title": "6-approaches-with-step-by-step-optimization-time-and-space-analysis",
                "content": "# APP1: find all buy&sell days combination and keep updating best benefit\\n# Time: O(n^2) Space: O(1). Runtime: TLE\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        max_profit = -sys.maxsize\\n        for i in range(n - 1):\\n            # you\\'re allowed to buy&sell on the same day \\n            for j in range(i, n):\\n                max_profit = max(max_profit, prices[j] - prices[i])\\n        return max_profit\\n\\n# APP2: for each buy date, Pre-calculate the largest sell date. \\n# Time: O(n), Space: O(n), Runtime: 40%, memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        suffix = [0] * n\\n        largest, ans = prices[n - 1], -sys.maxsize\\n        for i in range(n - 1, -1, -1):\\n            largest = max(largest, prices[i])\\n            suffix[i] = largest\\n        for i in range(n):\\n            ans = max(ans, suffix[i] - prices[i])\\n        return ans \\n                \\n# APP3: for each sell day, Pre-calculate the lowest buy date before. \\n# Time: O(n), Space: O(n), Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        prefix = [0] * n \\n        lowest, ans = prices[0], -sys.maxsize\\n        for i in range(n):\\n            lowest = min(lowest, prices[i])\\n            prefix[i] = lowest\\n        for i in range(n):\\n            ans = max(ans, prices[i] - prefix[i])\\n        return ans\\n        \\n# APP4-Draft: DP: f[i][j]: max profit buy at i and sell at j using two dimension array \\n# Here we can calculate f[i][j] directly using prices[j] = prices[i], which means we don\\'t need two dimension \\n# f[i][j] = max(f[i][j - 1] + price[j] - price[j - 1], price[j] - price[i] if i == j - 1)\\n\\n# APP4-final: DP optimize APP4-draft using one dimension array, f[j]: max profit sell at j day.\\n# Two conditions: Fist, buy day is before j - 1, Second, buy day is on j - 1 \\n# f[j] = max(f[j - 1] + price[j] - price[j - 1], price[j] - price[j - 1])\\n# Time: O(n) Space: O(n) Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n, ans = len(prices), -sys.maxsize\\n        f = [0] * n\\n        for j in range(1, n):\\n            f[j] = max(f[j - 1] + prices[j] - prices[j - 1], prices[j] - prices[j - 1])                        \\n            ans = max(ans, f[j])\\n        # consider same day buy&sell \\n        if ans < 0:\\n            return 0\\n        return ans \\n\\n# APP5 optimize APP2, we only need a variable instead of an array to know the lowest buy date for each sell day.\\n# Time: O(n) space: O(1) Runtime: 84% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        lowest = sys.maxsize\\n        max_profit = -sys.maxsize\\n        for i in range(n):\\n            lowest = min(lowest, prices[i])\\n            max_profit = max(max_profit, prices[i] - lowest)\\n        if max_profit < 0:\\n            return 0\\n        return max_profit\\n    \\n# APP6: for each sell day, i only care the price smaller than its previously, so it\\'s a increasing monotonic stack\\n# Time: O(n), space: O(n) Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        stack = []\\n        ans = -sys.maxsize\\n        # add last value to pop all the remaining ones in stack at last\\n        new_prices = prices + [-sys.maxsize]\\n        n = len(new_prices)\\n        for i in range(n):\\n            while stack and new_prices[i] < stack[-1]:\\n                ans = max(ans, stack[-1] - stack[0])\\n                stack.pop()\\n            stack.append(new_prices[i])\\n        return ans",
                "solutionTags": [],
                "code": "# APP1: find all buy&sell days combination and keep updating best benefit\\n# Time: O(n^2) Space: O(1). Runtime: TLE\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        max_profit = -sys.maxsize\\n        for i in range(n - 1):\\n            # you\\'re allowed to buy&sell on the same day \\n            for j in range(i, n):\\n                max_profit = max(max_profit, prices[j] - prices[i])\\n        return max_profit\\n\\n# APP2: for each buy date, Pre-calculate the largest sell date. \\n# Time: O(n), Space: O(n), Runtime: 40%, memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        suffix = [0] * n\\n        largest, ans = prices[n - 1], -sys.maxsize\\n        for i in range(n - 1, -1, -1):\\n            largest = max(largest, prices[i])\\n            suffix[i] = largest\\n        for i in range(n):\\n            ans = max(ans, suffix[i] - prices[i])\\n        return ans \\n                \\n# APP3: for each sell day, Pre-calculate the lowest buy date before. \\n# Time: O(n), Space: O(n), Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        prefix = [0] * n \\n        lowest, ans = prices[0], -sys.maxsize\\n        for i in range(n):\\n            lowest = min(lowest, prices[i])\\n            prefix[i] = lowest\\n        for i in range(n):\\n            ans = max(ans, prices[i] - prefix[i])\\n        return ans\\n        \\n# APP4-Draft: DP: f[i][j]: max profit buy at i and sell at j using two dimension array \\n# Here we can calculate f[i][j] directly using prices[j] = prices[i], which means we don\\'t need two dimension \\n# f[i][j] = max(f[i][j - 1] + price[j] - price[j - 1], price[j] - price[i] if i == j - 1)\\n\\n# APP4-final: DP optimize APP4-draft using one dimension array, f[j]: max profit sell at j day.\\n# Two conditions: Fist, buy day is before j - 1, Second, buy day is on j - 1 \\n# f[j] = max(f[j - 1] + price[j] - price[j - 1], price[j] - price[j - 1])\\n# Time: O(n) Space: O(n) Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n, ans = len(prices), -sys.maxsize\\n        f = [0] * n\\n        for j in range(1, n):\\n            f[j] = max(f[j - 1] + prices[j] - prices[j - 1], prices[j] - prices[j - 1])                        \\n            ans = max(ans, f[j])\\n        # consider same day buy&sell \\n        if ans < 0:\\n            return 0\\n        return ans \\n\\n# APP5 optimize APP2, we only need a variable instead of an array to know the lowest buy date for each sell day.\\n# Time: O(n) space: O(1) Runtime: 84% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        n = len(prices)\\n        lowest = sys.maxsize\\n        max_profit = -sys.maxsize\\n        for i in range(n):\\n            lowest = min(lowest, prices[i])\\n            max_profit = max(max_profit, prices[i] - lowest)\\n        if max_profit < 0:\\n            return 0\\n        return max_profit\\n    \\n# APP6: for each sell day, i only care the price smaller than its previously, so it\\'s a increasing monotonic stack\\n# Time: O(n), space: O(n) Runtime: 63% memory: 5%\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        stack = []\\n        ans = -sys.maxsize\\n        # add last value to pop all the remaining ones in stack at last\\n        new_prices = prices + [-sys.maxsize]\\n        n = len(new_prices)\\n        for i in range(n):\\n            while stack and new_prices[i] < stack[-1]:\\n                ans = max(ans, stack[-1] - stack[0])\\n                stack.pop()\\n            stack.append(new_prices[i])\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 539219,
                "title": "c-0ms-dp-solution-w-explanation",
                "content": "This problem is not one where DP immediately comes to mind, but it is good training to think \"DP\". For this problem, DP does not immediately come to mind because it is not directly related to the answer. Instead, the answer is calculated as a side-effect of running the DP program. The DP part involves calculating the minimum number before current. This is used to get the maximum profit at that number. \\n\\nThus, the algorithm would be like this:\\n1. For each index `i`, Use DP to get minimum number from `prices[0 ... i-1]`. Subtract `prices[i]` with `min(prices[0 ... j-1])` to get maximum revenue selling at `i`. \\n2. Record maximum revenue, and return that.\\n\\nRecording `min` seems like an obvious problem, but *you have to think in DP*. Forget everything else. To think in DP, first find the optimal subproblems:\\n\\n1. `min(prices[0 ... i]) = min(min(prices[0 ... i-1]), prices[i])`\\n\\nThis is the optimal subproblem structure. This can then be immediately used to construct DP array, with `dp[i] = min(dp[i-1], prices[i])` as the update function. This forms the first solution.\\n\\nBecause the DP update function only depends on the previous state (`dp[i-1]`), we can do space optimization and reduce space from `O(n)` to `O(1)`. This forms the second solution.\\n\\nThis may seem complicated, but for harder problems this way of thinking will make generating solutions *very fast*. The only *thinking* required is to identify the subproblems, and use the relationship between subproblems to generate the update function. Once that is done, everything else is systematic. This may not be the most optimized solution, but you at least have a solution, and you can then take your time to try to come up with a better one. \\n\\n```\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int size = prices.size(), res = 0;\\n        if(!size) return 0;\\n        vi dp(size, 0);\\n        dp[0] = prices[0];\\n        for(int i = 1; i < size; ++i) {\\n            res = max(res, prices[i]-dp[i-1]);\\n            dp[i] = min(dp[i-1], prices[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\nSpace optimized solution `O(n)` time `O(1)` space.\\n\\n```\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int size = prices.size(), res = 0;\\n        if(!size) return 0;\\n        vi dp(2, 0);\\n        dp[0] = prices[0];\\n        for(int i = 1; i < size; ++i) {\\n            res = max(res, prices[i]-dp[0]);\\n            dp[1] = min(dp[0], prices[i]);\\n            swap(dp[0], dp[1]);\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int size = prices.size(), res = 0;\\n        if(!size) return 0;\\n        vi dp(size, 0);\\n        dp[0] = prices[0];\\n        for(int i = 1; i < size; ++i) {\\n            res = max(res, prices[i]-dp[i-1]);\\n            dp[i] = min(dp[i-1], prices[i]);\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```\\n#define vi vector<int>\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int size = prices.size(), res = 0;\\n        if(!size) return 0;\\n        vi dp(2, 0);\\n        dp[0] = prices[0];\\n        for(int i = 1; i < size; ++i) {\\n            res = max(res, prices[i]-dp[0]);\\n            dp[1] = min(dp[0], prices[i]);\\n            swap(dp[0], dp[1]);\\n        }\\n        return res;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 473883,
                "title": "python-concise-o-n-time-and-constant-space-solution",
                "content": "The idea is to record the minimum price so far as we loop through the price array, then \\'p - minP\\' is the maximum profit we can get if we sell the stock on current day, finally we get the overall maximum profit by comparing all the possible maximum profits.\\n\\nNote: it is OK to calculate minimum price before getting the maximum profit on each day. Because if today\\'s price is not the minimum so far, it does not affect the minimum price, and if today\\'s price is the minimum, it means all previous days\\' prices will be higher or equal to today\\'s price, then the maximum profit we can get today will be 0 anyways.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        res, minP = 0, float(\\'inf\\')\\n        for p in prices:\\n            minP = min(p, minP)\\n            res = max(res, p - minP)\\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        res, minP = 0, float(\\'inf\\')\\n        for p in prices:\\n            minP = min(p, minP)\\n            res = max(res, p - minP)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405069,
                "title": "python-solution-easy-to-understand-and-o-n",
                "content": "1. Using element comparison\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n\\n        low = float(\\'inf\\') # set initial low price to be infinite \\n        profit = 0 # set profit to be 0 \\n        for price in prices:\\n            if price < low:  # detect current price are lower than low\\n                low = price \\n            else:  # detect current price are higher\\n                profit = max(price-low, profit) # compare the current difference and previous max profit\\n        return profit\\n```\\n\\n2. Dynamic programming\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n    \\n        fb, fs = float(\\'inf\\'), 0\\n        for price in prices:\\n            fb = min(fb, price) # keep minimal\\n            fs = max(fs, price-fb) # compute max difference\\n        return fs\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n\\n        low = float(\\'inf\\') # set initial low price to be infinite \\n        profit = 0 # set profit to be 0 \\n        for price in prices:\\n            if price < low:  # detect current price are lower than low\\n                low = price \\n            else:  # detect current price are higher\\n                profit = max(price-low, profit) # compare the current difference and previous max profit\\n        return profit\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n    \\n        fb, fs = float(\\'inf\\'), 0\\n        for price in prices:\\n            fb = min(fb, price) # keep minimal\\n            fs = max(fs, price-fb) # compute max difference\\n        return fs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341798,
                "title": "solution-in-python-3",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n    \\tm, mp = float(\\'inf\\'), 0\\n    \\tfor p in prices:\\n    \\t\\tif p < m: m = p\\n    \\t\\tif p - m > mp: mp = p - m\\n    \\treturn mp\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n    \\tm, mp = float(\\'inf\\'), 0\\n    \\tfor p in prices:\\n    \\t\\tif p < m: m = p\\n    \\t\\tif p - m > mp: mp = p - m\\n    \\treturn mp\\n\\t\\t\\n\\t\\t\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 322506,
                "title": "best-python-solution-crack-the-dynamic-programming-explained",
                "content": "# Explaination\\nFirst setup a memo\\nThe value in memo is the max profit we are going to get when we only look at 0~i\\nFor every i, we either sell or not sell\\n* If we sell, the max profit is price now - lowest price before (prices[i]-min_price).\\n* If we not sell, the max profit we get now is the same as yesterday.\\nEvery i between these two we pick the max.\\nSo we iterate from 0 to the end.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        if prices is None or len(prices)==0: return 0\\n        \\n        memo = [0]*len(prices)\\n        min_price = float(\\'inf\\')\\n        \\n        for i in xrange(len(prices)):\\n            min_price = min(min_price, prices[i])\\n            if i==0: continue\\n            memo[i] = max(prices[i]-min_price, memo[i-1])\\n        return memo[-1]\\n```\\n\\n# More Resource\\nI really take time tried to make the best solution or explaination. \\nBecause I wanted to help others like me. \\nIf you like my answer, a star on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python\\n\\n# Dynamic programming\\nThis is a dynamic programming question.\\nMost dynamic programming can solve it by the simliar approach.\\nIf you are not familiar with it take a look at  \\n* [House robber problem](https://leetcode.com/problems/min-cost-climbing-stairs) with @heroes3001 \\'s [explaination](https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.). \\n* [Climbing stairs problem](https://leetcode.com/problems/climbing-stairs/) with my [explaination](https://leetcode.com/problems/min-cost-climbing-stairs/discuss/322531/).\\n* [Stock problem](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) with my [explaination](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/322506).\\n* [0/1 Knapsack problem](https://www.youtube.com/watch?v=8LusJS5-AGo).",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        if prices is None or len(prices)==0: return 0\\n        \\n        memo = [0]*len(prices)\\n        min_price = float(\\'inf\\')\\n        \\n        for i in xrange(len(prices)):\\n            min_price = min(min_price, prices[i])\\n            if i==0: continue\\n            memo[i] = max(prices[i]-min_price, memo[i-1])\\n        return memo[-1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1757990,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1575902,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1677787,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1665530,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1564785,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1785221,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1880567,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1756186,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1566236,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1565340,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1757990,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1575902,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1677787,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1665530,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1564785,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1785221,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1880567,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1756186,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1566236,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1565340,
                "content": [
                    {
                        "username": "Serosidium",
                        "content": "I couldn\\'t find any good explanations here and only code, so I will do my best to explain how I solved it without providing code. I am sure there are other possible solutions, but this is how it worked for me.\\n\\nThe brute force method of a double for loop is not necessary here, and this problem is marked with dynamic programming because it requires the [Sliding Window technique](https://algorithm-visualizer.org/dynamic-programming/sliding-window).\\n\\nBased on the fact that we have to sell after we buy and we are trying to maximize profit, we can iterate through the prices and only need to consider two things:\\n1.) **Is this price cheaper than any other price I\\'ve seen before?** \\n2.) If I subtract current price by the cheapest price I\\'ve found, **does this yield a greater profit than what I\\'ve seen so far?**\\n\\n*A fun thing to note is if #1 is true, then #2 cannot be true as well so there isn\\'t a need to check*\\n\\nLet\\'s consider an example of [4,1,5,2,7]\\n- 4 is the cheapest price we see to start, and we can\\'t sell on the first day so maxProfit is 0\\n- 1 is now the cheapest price we\\'ve seen. Selling now would lose us money, so we can\\'t update maxProfit\\n- 5 is not cheaper than 1, but if we sell now we get a maxProfit of 4! Better save that for later\\n- 2 is not cheaper than 1 and if we sell, we only get a profit of 1, no need to do anything here\\n- 7 is not cheaper than 1, but if we sell here, we\\'ll increase maxProfit to 6, making this the best profit to return.\\n\\nHope this helps someone else!\\n"
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Thank you bro"
                    },
                    {
                        "username": "lorentzimys",
                        "content": "Awesome solution, thanks!"
                    },
                    {
                        "username": "Khoa268",
                        "content": "thanks for sharing!"
                    },
                    {
                        "username": "omeh-a",
                        "content": "This is not a DP solution as described, it is greedy"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Thanks bro for your help without code really appreciate "
                    },
                    {
                        "username": "245120733119",
                        "content": "Brilliant!! Thanks for sharing!!"
                    },
                    {
                        "username": "Aniket_sggs",
                        "content": "Initially, this seemed to be DP problem. but after reading this description it is clear that this is basic problem with greedy solution."
                    },
                    {
                        "username": "duffinson97",
                        "content": "Thank you for not posting code, I don\\'t understand the sliding window technique or how this applies to that. I google it and the image link to this problem doesn\\'t make a lot of sense to me. But this solution works thanks"
                    },
                    {
                        "username": "typranjal1",
                        "content": "Thank you!."
                    },
                    {
                        "username": "jakho100",
                        "content": "was stuck on it for hours, thanks for the simple explanation! "
                    },
                    {
                        "username": "zafeer_rangoonwala",
                        "content": "I was originally not able to solve it but after reading your thought process it was a cake walk! \\n\\nThanks! "
                    },
                    {
                        "username": "mohammed1212345",
                        "content": "thank for helping out"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "Exellent explaination!"
                    },
                    {
                        "username": "kcleland18",
                        "content": "This was a great explanation!! Thanks!"
                    },
                    {
                        "username": "as358",
                        "content": "Best Explanation ever !!!"
                    },
                    {
                        "username": "user6798sW",
                        "content": "AWESOME BREAKDOWN! Ty"
                    },
                    {
                        "username": "jaydeep-pro",
                        "content": "[@evoniuk](/evoniuk) exactly! "
                    },
                    {
                        "username": "akshaydusad",
                        "content": "okay this is genius and surprisingly easier to follow!"
                    },
                    {
                        "username": "evoniuk",
                        "content": "Thank you! This is a solution that\\'s so simple and obvious once you see it you kick yourself for not thinking of it yourself!"
                    },
                    {
                        "username": "ivantchev",
                        "content": "How would the original wording of the problem have to be modified so that the double loop solution _has_ to be used?"
                    },
                    {
                        "username": "ivantchev",
                        "content": "Very helpful, thank you! To add: the reason why using your point 1.) works as a valid check is because given the problem constraints, it will always yield a higher profit down the line regardless of future values.\\n\\nAnd point  2.) shows we don\\'t need a second loop.\\n\\nI wonder, can any concrete aspect of the problem  be used as a clue so that we can reach Serosidium\\'s solution  independently. "
                    },
                    {
                        "username": "VishnuKesav",
                        "content": "[@sharpsailor](/sharpsailor) our target is to get highest possible profit.\\nYou are focusing on buying for the lowest price alone. No matter how low the price is, buying on a last day will yield 0 profit.\\n"
                    },
                    {
                        "username": "kaushar",
                        "content": "[@tengxianrui](/tengxianrui) Thanks  !"
                    },
                    {
                        "username": "neelimag459",
                        "content": "Thank you so much for such good explanation. Happy coding."
                    },
                    {
                        "username": "Nbs-26",
                        "content": "Thank u brother. Your explanation is very clear and well defined."
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "[@sharpsailor](/sharpsailor) if we buy on 2 and sell on 4, our profit would be 4 - 2 = 2. "
                    },
                    {
                        "username": "sharpsailor",
                        "content": "check for {2,4,1} ideally it should give 0 but leetcode gives 2..Help me figure out where am I getting it wrong\\n"
                    },
                    {
                        "username": "jackbb147",
                        "content": "that\\'s actually very smart... thanks"
                    },
                    {
                        "username": "chiahao1",
                        "content": "Thank you! Your technique worked for me."
                    },
                    {
                        "username": "Marre-86",
                        "content": "Man, you made my day! I spent two hours and wrote almost 100 hundred lines code that probably was soving it but had \"time limit exceeded\" with huge input. And after your explanation I rewrite it in freaking 7 lines and it made it right off the bat!"
                    },
                    {
                        "username": "m1ma087",
                        "content": "Best tip! Thanks!"
                    },
                    {
                        "username": "sasaalina1985",
                        "content": "was reading this and solved the problem first try! Very good explanation!!!"
                    },
                    {
                        "username": "Yash_6207",
                        "content": "This is what we call as Greedy ! Good Explanation\\n"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@fjod](/fjod) but it\\'s buy day that should be before then sellday"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "[@iosifpetrupuha](/iosifpetrupuha) daaamn there is no indentation in this comment section"
                    },
                    {
                        "username": "iosifpetrupuha",
                        "content": "so I didn\\'t know this was called sliding window or sumthin, but I am second year at CS university, i have some grasp of this kind of logic and I solved it this way:\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        #you obviously must buy before you sell(can\\'t go back in time)\\n        GreatestProfit=0\\n        priceToBeat=prices[0]\\n        for i in range(len(prices)-1):#we can iterate through the whole list, otherwise we get out of bounds, so we iterate from the first to the penultimate (so the last comparation we do is between the penultimate and the last element) \\n            if prices[i]<prices[i+1]:#sure profit, possible greatest profit\\n                if prices[i]<=priceToBeat:\\n                    priceToBeat=prices[i]\\n                if GreatestProfit<=prices[i+1]-priceToBeat: #if the GreatestProfit we calculate is greater than the one we have already, we update the Greatest Profit, otherwise we do nothing\\n                    GreatestProfit=prices[i+1]-priceToBeat\\n        return GreatestProfit\\nis this a proper way to solve this kind of problems? (in terms of efficiency I think we\\'re in O(n) so it should be pretty good"
                    },
                    {
                        "username": "Rohit_8412",
                        "content": "Thanks, I was about to see the solution after 10 min I didn\\'t get an approach into my mind.\\nThen I saw your discussion and I solved the question myself \\uD83D\\uDE0E"
                    },
                    {
                        "username": "fjod",
                        "content": "your explanation does not include rule of sellDay must be after buyDay"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "thanks for great explaination without any spoilers.\\ni will try my best for the code, thanks a lot ;)"
                    },
                    {
                        "username": "csrnontol",
                        "content": "Sounds good, but I think your tip fails for [2,9,3,4,5,1,7] (how you\\'d choose 2, 9) and [2,9,3,4,5,1,7,10] (how you\\'d choose 1, 10)."
                    },
                    {
                        "username": "rockmanex",
                        "content": "best explanations so far. Thankyou it\\'s help a lot"
                    },
                    {
                        "username": "ak67",
                        "content": "I think this problem should be catogarise as medium level problem\\n"
                    },
                    {
                        "username": "Sultan_Ul_Arfin",
                        "content": "[@chazwinter](/chazwinter) what is sliding window? I never heard it ..will you explain that please<3\\n "
                    },
                    {
                        "username": "chazwinter",
                        "content": "It doesn\\'t require DP though. You only think it\\'s harder than it is because you\\'re overthinking it. You can use sliding window and just keep track of the lowest price as you go."
                    },
                    {
                        "username": "rwatso",
                        "content": "[@lucky_nik77](/lucky_nik77) Because by its very nature DP is not a beginner / easy level topic."
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@lucky_nik77](/lucky_nik77) This is not hard for simple lists. But all people here usually stuck at TimeLimit error. So algorithm should be another, at least medium level of complexity."
                    },
                    {
                        "username": "lucky_nik77",
                        "content": "But why? It is hard to think about a DP problem that would be easier than this."
                    },
                    {
                        "username": "tiwarimrutunjay",
                        "content": "agreed"
                    },
                    {
                        "username": "codernoob",
                        "content": "how to resolve the time exceeded issue? Mine fails at 203rd test case with a large array"
                    },
                    {
                        "username": "user4279js",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) I\\'m not a javascript expert, but probably doing prices.slice(index) is looping 0 -index eachtime ... so you have O(N\\n^2) soltuion overall"
                    },
                    {
                        "username": "Behnoosh",
                        "content": "[@htooak2014](/htooak2014) To me it was occurring when my code had an O(n^2) complexity. Resolving that (to O(n)) solved this problem. I start from the end of the array prices and dynamically find the max value from the end of the array until the current step backwards. This way, at the end of the for loop, we can find the max profit with only one single pass over all entries of the array."
                    },
                    {
                        "username": "eyastaifour",
                        "content": "[@htooak2014](/htooak2014) I am hitting a limit error as well and I believe that it is because I keep on querying max() of the window, but when I think of it the max is either on the first index of the window (as I descend), or somewhere else, in which case, it should be cached as it doesnt change... at least, that\\'s what i am thinking\\n"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) You need to reconsider your variable naming. They carry very few meanings."
                    },
                    {
                        "username": "knotri",
                        "content": "[@rajamandalofficial56](/rajamandalofficial56) since u iterate over N elements with prices.map, and for each elements u call Math.max(...prices.slice) u need approx additional 1/2N to find maximum. So O(n) = n^2"
                    },
                    {
                        "username": "rajamandalofficial56",
                        "content": " let max = 0;\\n\\n    prices.map((el,index) => {\\n      let tem =  Math.max(...prices.slice(index))\\n      if(el< tem){\\n         if(max< tem-el){\\n             max = tem-el\\n         }\\n      }\\n    })\\n    return max\\n\\nError : Time Limit Exceeded\\n\\nO(n) complexity\\nwhat\\'s wrong this approach? "
                    },
                    {
                        "username": "htooak2014",
                        "content": "me too. time limit error occurs. why? leetcode compiler error?"
                    },
                    {
                        "username": "drmolenhouse",
                        "content": "Same issue, using the LeetCode Official solution lmao. What am I paying $35/month for?"
                    },
                    {
                        "username": "user4387LF",
                        "content": "Because you may be using a brute force approach with two loops checking every combination which takes O(n2) time; Cause it exceeds time limit. Optimize your code. Think to solve it in one pass with one loop in linear time."
                    },
                    {
                        "username": "Sahil481",
                        "content": "Your code is not well optimised. It is not ran within the given time limit."
                    },
                    {
                        "username": "pstrait",
                        "content": "Are you doing it with more than one loop? If so, there\\'s a better solution that has O(n) time complexity"
                    },
                    {
                        "username": "leet_code_master",
                        "content": "prices = [2, 4, 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nYou buy on day three but cannot sell because it is the last day. Should that not be zero?"
                    },
                    {
                        "username": "langhudson870",
                        "content": "You should buy on day 1 and sell on day 2"
                    },
                    {
                        "username": "almaas21",
                        "content": "[@user4391xh](/user4391xh) \\nthe output required is max profit through traversing  in the list, it could be adjacent too like in [2,4,1] max_profit here is 2 not 0"
                    },
                    {
                        "username": "ashish_bhosale848",
                        "content": "Yes , I am facing the same issue at case 154"
                    },
                    {
                        "username": "user4391xh",
                        "content": "According to the example 2 \\n(Input: prices = [7,6,4,3,1]\\nOutput: 0\\nExplanation: In this case, no transactions are done and the max profit = 0.)\\nin the task description, 0 should be returned so looks like tests expect incorrect value here.."
                    },
                    {
                        "username": "kaushit",
                        "content": "[@mp9508](/mp9508) I also done the same thing but if that solution is wrong then what approach should we think."
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "you buy on the first day and sell on the second"
                    },
                    {
                        "username": "sazuki",
                        "content": "[@mp9508](/mp9508) This happend to me too, because ahahah well, the first value that is taken is the min() so basically 1, but this is the last one because that will end in a 0 output. "
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on first day and sell on second day makes profit 2 "
                    },
                    {
                        "username": "Dan_A_S",
                        "content": "[@mkv1892](/mkv1892) I don\\'t agree with that (except if the explanation of the problem is not correct). What I understood from the explanation is, you buy when the price is cheapest and sell on a later date when you can maximize profit (meaning the highest prize on a later date from the date of purchase). Going by that, you buy at 1 so the output should be zero and not the expected 2."
                    },
                    {
                        "username": "mkv1892",
                        "content": "No, Here you buy at day 1, Where the buy price is 2 and sell at day 2, Where the sell price is 4."
                    },
                    {
                        "username": "Byas_Yadav",
                        "content": "[@mp9508](/mp9508) you buy on day 1 and sell it on day 2 i.e. profit =sell-buy --> 4-2=2"
                    },
                    {
                        "username": "mp9508",
                        "content": "[@leet_code_master](/leet_code_master) happened the same to me . the approach i took is:\\nfind the minimum element and then maxi=mini then use a loop from the next index of the lowest mini element and then find maxi, then return the output.\\nhope this helps\\n"
                    },
                    {
                        "username": "VaishaliChauhan",
                        "content": "We need to maximize profit, you can buy at 2 and sell on 4, giving a profit of 2"
                    },
                    {
                        "username": "IbrahimJunior",
                        "content": "you have to maintain your profit in a variable and only change the variable if the new profit is greater than the previous one, so for this scenario, 2 is the former profit, 0 is the new one, it is not greater than 2 so you don\\'t change your profit."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 4 profit = 2\\ni am facing the same problem bro............."
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@leet_code_master](/leet_code_master) What I did was look at what the largest value after i is for each i, and what the smallest value is before each i. Then, for each i, i subtract smallest from largest. This is your optimal profit for buying before i and selling after i. Now you just find the largest number out of these, and you\\'re done."
                    },
                    {
                        "username": "leet_code_master",
                        "content": "[@MeriemA](/MeriemA) I see. Thank you :) How do you recommend I go about this? Because now the new code I make messes up the second test case."
                    },
                    {
                        "username": "MeriemA",
                        "content": "Actually,  the idea here is how you can make the maximum of profits. You don\\'t have to buy the stock when it\\'s at its lowest price.\\nHere you can buy the first day and sell the second day and still make a profit which is 2.\\n"
                    },
                    {
                        "username": "EXLsunshine",
                        "content": "Why is this problem tagged with \"Dynamic programming\"?"
                    },
                    {
                        "username": "princebillygk2",
                        "content": "[@aryan14decsingh](/aryan14decsingh) The problem can be solved in Dynamic way but the more efficient way is array traversal approach."
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "It should be tagged as two pointer problem"
                    },
                    {
                        "username": "aryan14decsingh",
                        "content": "Because it is Dynamic  ( debatable ) \\nquestion apart , did you get any job by now ? you posted this on 2015 , if you are still alive let me know if you got any jobs and some tips aswell"
                    },
                    {
                        "username": "djslim",
                        "content": "[@sourov1407](/sourov1407)  tbh it\\'s classic greedy problem, interestingly in leetcode 75 they marked it as greedy"
                    },
                    {
                        "username": "sahle123",
                        "content": "[@AdityaBhate](/AdityaBhate) He/she was asking a question, not for a solution."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n\\n"
                    },
                    {
                        "username": "sourov1407",
                        "content": "Because we can use kadene\\'s algorithm here and as it is widely regarded as dp algorithm so yeah this problem is tagged with dynamic programming"
                    },
                    {
                        "username": "casper07",
                        "content": "I am So dumb...."
                    },
                    {
                        "username": "ydumar",
                        "content": "same bruh"
                    },
                    {
                        "username": "savagesam343",
                        "content": "me too bro, me too..."
                    },
                    {
                        "username": "night07",
                        "content": "me too jit"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing an intuitive proof of the O(n) solution:\nhttps://youtube.com/watch?v=ioFPBdChabY"
                    },
                    {
                        "username": "astek14",
                        "content": "Thanks it\\'s awesome"
                    },
                    {
                        "username": "shilbabun491",
                        "content": "how to resolve the time exceeded issue? Mine fails at 200th test case with a large array"
                    },
                    {
                        "username": "akelux",
                        "content": "How to get max profit 4 from input [3,2,6,5,0,3]?"
                    },
                    {
                        "username": "jenil59",
                        "content": "buy at 2 and sell at 6"
                    },
                    {
                        "username": "Trinto_610",
                        "content": "damn bro 2013"
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "3 (buy),  2 (buy) , 6 (sell), 5 (hold), 0 (hold), 3 (hold)\\n-3 -2 + (2*6)\\n= -5 + 12 = 7"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "by selling on 6 and buying on 0\\nwhich means short selling"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "2,6"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 2 and sell = 6"
                    },
                    {
                        "username": "hungkiet244203",
                        "content": "[@jannatbushra524](/jannatbushra524) yeah but the profit it provides isnt\\n"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@jannatbushra524](/jannatbushra524) Buy at 0, then you have to sell after zero, so the best sell price is 3. 3-0 = 3, 6-2=4"
                    },
                    {
                        "username": "ajjha7203",
                        "content": "6-2 = 4"
                    },
                    {
                        "username": "damajsam93",
                        "content": "6-2 ==> 4 "
                    },
                    {
                        "username": "Jagdeep4485",
                        "content": "6-2= 4"
                    },
                    {
                        "username": "jannatbushra524",
                        "content": "[@rajanhossainkhan](/rajanhossainkhan) isn\\'t \\'0\\' a buy_price ??...and its smallest too."
                    },
                    {
                        "username": "rajanhossainkhan",
                        "content": "Here are the steps - \\n\\n1. First buy out price is 3 and profit is set to 0. \\n2. Now loop through array from index 1, since index 0 (which is 3) is taken as minimum buy out price for now. \\n3. Now if price is 2, then set this as new buy out price, since its smaller. So our current buy out price is 2. \\n4. Now next price is 6. This is bigger, so sell with current buy out price 2. \\n5. Calculate max profit  = max(profit, ( current_price - buy_price) \\n6. In this case, max(0, 6-2) = 4\\n\\nHope this helps. "
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "2 -6\\n"
                    },
                    {
                        "username": "hemantgautam505",
                        "content": "output is 4\\n"
                    },
                    {
                        "username": "Shashi3k",
                        "content": "2-6\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** One Pass\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1566103,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1772605,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1766938,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1567867,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1702991,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1569240,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1869011,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1567393,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1571250,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1807383,
                "content": [
                    {
                        "username": "Anonymous_Cat",
                        "content": "I solved the problem using dynamic programming (iteratively) but I am trying to draw the recursive tree. Since I am trying to understand DP as well as possible. I failed though so can someone help?\\n\\nAlso is there a way to solve this using memoization (recursively). I tried and failed as well."
                    },
                    {
                        "username": "vladandrei51",
                        "content": "[@tirthprajapati1810](/tirthprajapati1810) Hey"
                    },
                    {
                        "username": "tirthprajapati1810",
                        "content": "hii..\\n"
                    },
                    {
                        "username": "RANJITH_G",
                        "content": "prices=[1,2]\\noutput =2\\nexpected =1\\nhow do I get 1?..\\nwhen buy for rs 1 at day1 and sells at Rs.2 gives the profit ...Then,how do I get day1 as output?"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you don\\'t return the day, you return price[selling day] - price[buying day], so 2 -1 = 1"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "You dont return the day, return the maximum profit "
                    },
                    {
                        "username": "Akshaychouke",
                        "content": "because 2-1 = 1 = profit"
                    },
                    {
                        "username": "mingchoi",
                        "content": "(creative) A Dynamic Programming approch:\nYou can actually solve this problem with by converting it into [53.Maximum Subarray], here's how:\n\nLet's start with case 1:`prices=[7,1,5,3,6,4]`\nnow loop once to calculate the gain/loss if you buy it then sell it on the next day, \n`prices[i] = prices[i+1] - prices[i]`\ne.g. buy at 7 sell at 1: `1-7=-6`, then you will come up with this array:\n`[-6, +4, -2, +3, -2]`\n\nFor now, you need find the range with maximum profit(sub array) from above. The answer can tell by looking at it, the best range is `+4 -2 +3 = 5`.\nIf the maximum is negative you should return 0 and that's all!\n\nBest part of this approch is you can do it in-place, there will be an empty slot at the end of array, but if you think about that -- you can simply put 0 at that empty slot so you don't have to check negative anymore. Perfect!\n"
                    },
                    {
                        "username": "Dabchinsky",
                        "content": "Well, you dont need to create any arrays, you can simply loop prices array once, calculating maximum profit on each step. "
                    },
                    {
                        "username": "WallaWonka",
                        "content": "\\uD83D\\uDC4F\\uD83C\\uDFFE\\uD83D\\uDC4F\\uD83C\\uDFFE"
                    },
                    {
                        "username": "wangxin501",
                        "content": "Input:\\t[6,1,3,2,4,7]\\nOutput:\\t5\\nExpected:\\t6"
                    },
                    {
                        "username": "mdsali914",
                        "content": "Just do + 1 on the answer"
                    },
                    {
                        "username": "bhanureddy7",
                        "content": "1,7\\n"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "buy = 1 and sell = 7 profit = 6"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "[@alangreg](/alangreg) 7-1 *"
                    },
                    {
                        "username": "alangreg",
                        "content": "1-7"
                    },
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0;\\n      int minimum = prices[0];\\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]);\\n          maxi  = max(maxi ,prices[i] - minimum );\\n      }\\n      return maxi;\\n    }"
                    },
                    {
                        "username": "user1889GX",
                        "content": "This is good solutions"
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Pikachu13](/Pikachu13) dude is a protagonist"
                    },
                    {
                        "username": "Socrii13",
                        "content": "there is also requirement to check for the future day ?\\n"
                    },
                    {
                        "username": "zomart",
                        "content": "Not a dynamic prog problem. Incorrect tagging must be fixed"
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "probably using knapsack as well"
                    },
                    {
                        "username": "alankrit_1403",
                        "content": "it is a dp problem as we can solve it using kadane algo and that algo is part of dp algo and also we can solve it using memoization"
                    },
                    {
                        "username": "bytecode15",
                        "content": "This should be a medium level question, its demotivating to mark it as Medium :9"
                    },
                    {
                        "username": "pineappleunderthesea",
                        "content": "Because of a fairly pointless test case - it passes in Java though."
                    },
                    {
                        "username": "NEWrecruit",
                        "content": "[2,1,2,1,0,0,1] wrong case?testcase output 1 but submit return 2"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "buy on one , sell on the next 2 "
                    },
                    {
                        "username": "inception_007",
                        "content": "i wonder how this problem is of easy on leetcode, it should be medium"
                    }
                ]
            },
            {
                "id": 1813722,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1567866,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1914445,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1813766,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1813637,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1776027,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1668224,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1571251,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 2055422,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 2018576,
                "content": [
                    {
                        "username": "Promethus",
                        "content": "#Intuition#\\n\\nso keep two variables one keeps track of profit and second keeps track of minimum(minCost) value of stock\\n1. initialize profit with zero and minCost to first price\\n2.  then iterate through the array \\n3. we have to check what profit we can get if we sell the stock at that index and is it greater than our previous profits\\n4.  then we need to also check  if current price of stock is less than the minCost we have been keeping track of\\n5. return profit  after iterating overprice array"
                    },
                    {
                        "username": "hborah@ncsu.edu",
                        "content": "![Don't understand the expected answer][1]\\n\\n\\n  [1]: https://s32.postimg.org/m4zfjazol/Screen_Shot_2016_06_22_at_10_29_32_PM.png"
                    },
                    {
                        "username": "aleksandvladiminikol",
                        "content": "looks like that\\'s not easy level :)"
                    },
                    {
                        "username": "Umair9912",
                        "content": "Bro I miss the old location of the discussion tab ;( damn corporate greed."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a very good DP problem for beginners."
                    },
                    {
                        "username": "licy_zane",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max = 0;\\n        int delta = 0;\\n        for (int i = prices.length-1; i >= 0; i--) {\\n            if (prices[i] >= max) {\\n                max = prices[i];\\n            } else {\\n                delta = Math.max(max - prices[i], delta);\\n            }\\n        }\\n        return delta;\\n    }\\n}"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I really need to learn how to use less for loops, i always run into problems where they ask me huge questions that are impossible to solve quickly enough with nested loops."
                    },
                    {
                        "username": "krishna3062018",
                        "content": "if you learnt then teach us.."
                    },
                    {
                        "username": "binhope",
                        "content": "The case [6,1,3,2,4,7] which  expected ouput is 6.My output is  7.My solution is,at the second day i buy,and the third day sell,the fourth day buy it ,the sixth day sell it .Why the answer is 6?"
                    },
                    {
                        "username": "user2696u",
                        "content": "prices[2,4,1] should have an answer of 0 shouldn\\'t it?"
                    },
                    {
                        "username": "arurahul16",
                        "content": "No bro , you need to understand \"MAX Profit\" focus on that , you will understand why its not 0."
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: \\nYou can go through the prices just once."
                    }
                ]
            },
            {
                "id": 1939069,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1893957,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1859704,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1749296,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1721198,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1676300,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1575175,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1573229,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1572764,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 1575261,
                "content": [
                    {
                        "username": "avinashsp93",
                        "content": "I think this problem should be categorized as medium and the next problem should be categorized as easy!!"
                    },
                    {
                        "username": "sumeetlalla",
                        "content": "For the testcase 1\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5\\n\\nHad a query. If we are buying at day 2 then sell it at day 3 we will get a profit of 4 and if we again buy it at day 4 and sell at day 5 we get a profit of 3 so total profit will be 7. If the transaction is single then 5 will come but if we break the buy sell transaction 7 is coming"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is correct, but the problem statement specifically mentions that you can only make a single transaction, i.e., buy once and sell once. \\n\\nThe problem statement says \"You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\"\\n\\nSo, you can\\'t buy and sell multiple times. You must decide the best day to buy and the best day to sell to maximize your profit. Hence, the maximum profit for the given input [7,1,5,3,6,4] would be 5 (buy at price 1 and sell at price 6), not 7. \\n\\nIf multiple transactions were allowed, then your approach would be correct, and the maximum profit would indeed be 7. However, that\\'s a different problem altogether."
                    },
                    {
                        "username": "f-rams",
                        "content": "I am encountering Runtime Error on test 198/211. Could it be because I am using a nested loop? "
                    },
                    {
                        "username": "dogukan0101",
                        "content": "I guess it is because of the time complexity. It shouldn\\'t be O(n^2)."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time Limit Exceeded after passing 199 test cases, what should I rectify?\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n\\n\\n       int maxnum=INT_MIN;\\n       int current =0;\\n       int st=0;\\n       int en=prices.size()-1;\\n       while(st<prices.size()-1){\\n           if(en==st){\\n               st++;\\n               en=prices.size()-1;\\n           }\\n\\n           else{\\n                current=prices[en]-prices[st];\\n                maxnum=max(maxnum,current);\\n                en--;\\n           }\\n       }\\n       if(maxnum<0){\\n           return 0;\\n       }\\n       return maxnum; \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The current approach, in worst-case scenarios, runs in O(n^2) time complexity. This is because for each element in the array, you\\'re scanning all the elements to its right. This could lead to a timeout for larger inputs.\\n\\nHere\\'s an optimized solution with O(n) time complexity:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int max_profit = 0;\\n        int min_price = prices[0];\\n        \\n        for(int i = 1; i < prices.size(); i++){\\n            if(prices[i] < min_price) {\\n                min_price = prices[i];\\n            } else if(prices[i] - min_price > max_profit) {\\n                max_profit = prices[i] - min_price;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```\\n\\nIn this solution, we initialize `min_price` to the first price and `max_profit` to 0. Then, we iterate over the prices from the second price. For each price, we do the following:\\n\\n1. If the current price is less than `min_price`, we update `min_price`.\\n2. If the profit we can get by selling at the current price (which is `prices[i] - min_price`) is more than the current `max_profit`, we update `max_profit`.\\n\\nThis solution works because for each price, we\\'re checking whether we should update our `min_price` and whether selling at the current price would give us a higher profit than any we\\'ve seen before. This ensures that our buy happens before the sell, since we always sell at a price that comes after our `min_price`.\\n\\nThus, this solution is much faster and should not lead to a timeout."
                    },
                    {
                        "username": "htooak2014",
                        "content": "me ,too."
                    },
                    {
                        "username": "Rohith8641",
                        "content": "I have solved this problem with 2 Approaches \\nApproach 1:\\nUsing Auxillary Space\\n1.Initially calculate the maximum right value from right \\n2.Then Iterate through the loop once and calculate the profit.\\n3.Choose the stock which has maximum profit\\nTime Complexity: O(N)\\nAuxillary Space: O(N)\\n----------------------------------------------------------------------\\nApproach 2:\\n1.By Standing over the stock price and calculate the minimum Stock price So far \\nand update it with the maximum Profit.\\n2.Return the Maximum Profit after reaching the end of the Stocks\\n3.It means U need to stand over the price of the stock and calculate the difference between the price of the stock.\\n\\n\\n"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "test case [3,3]\\nfailed \\nbut in my local machine it give exact output that is  0."
                    },
                    {
                        "username": "alangreg",
                        "content": "I have simillar issue with some other problem. Get error here but on my machine it gives correct answer."
                    },
                    {
                        "username": "t_man",
                        "content": "Hi  everyone,\\nI am really surprised to see that my code has just passed for the custom test case but it\\'s showing error for the same test case when submitted .\\nWhat should I do then?\\n![image](https://assets.leetcode.com/users/images/09fb85df-e144-4726-bdf7-896a62f2f37a_1619278979.3459322.png)\\n"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Upgrade to Arch Linux :)"
                    },
                    {
                        "username": "undefitied",
                        "content": "I\\'ve got here from the \"Top Interview Questions\" course, and \"Dynamic Programming\" chapter. Can somebody explain me, please, what the problem does in this chapter? Isn\\'t it a simple array-chapter problem?"
                    },
                    {
                        "username": "ronaldabellano",
                        "content": "Input: [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\n             **Not 7-1 = 6, as selling price needs to be larger than buying price.**\\n\\t\\t\\t \\nShould this be that you buy on day 2 and you can\\'t sell it on day 1. Because to how I understand 7-1 selling price on day 1 is 7 is larger than buying price on day 2 which is 1.\\nIt states selling price needs to be larger than buying price which is must be always true to solve the problem."
                    },
                    {
                        "username": "vrushabhshetcr7",
                        "content": "https://www.codemummy.com/2020/08/best-time-to-buy-and-sell-stock.html\\n\\nbest and easiest c++ solution with explanation"
                    }
                ]
            },
            {
                "id": 2077049,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2074753,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2068195,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2068097,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2065933,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2065291,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2064553,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2064519,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2063495,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2062848,
                "content": [
                    {
                        "username": "Himanshu_Singh11",
                        "content": "prices = [7,1,5,3,6,4] \\nProblem Statement :- so basically wht we need to do is buy a stock on any day from 0 to (i-1) index and sell it on on any ith day , in the process we need to do so such that we get the maximum profit by selling the stock we bought\\nLogic:-  so if we sell a stock on ith day say it has a price of  prices[i] so to get max profit by selling it we should have bought a stock before the ith day ie minimum in price so ie basically\\n min(prices[0...i-1])\\n\\nNote :- we can Buy and sell a stock only once \\n"
                    },
                    {
                        "username": "elliekity",
                        "content": "i got time limit exceeded :joe_angry:"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "you could solve this with a single pass on the array. No need for double array, recursion, etc. Just a simple for loop."
                    },
                    {
                        "username": "icor",
                        "content": "There is wrong testcase 20. prices =\n[1,2] My output 2. Expected 1. Expected 1 is not correct it should be 2. Buy on day 1 and sell on day 2. Profit 1 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "You answered your own problem. Profit = 1. "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I don\\'t think this is a dynamic problem."
                    },
                    {
                        "username": "Natnael_32",
                        "content": " Why does the test case [2, 4, 1] pass on my machine but fail here?  [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "nitheshkumar0731",
                        "content": "can anyone tell me  ,how expected outcome become 1\nfor array [4,1,2]   ,  It should be  2 right?"
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "If you buy now, you can only sell in the future. Think of index as the days. Assuming that array is day 0, 1, 2. you cant buy on day 2 and sell on day 1."
                    },
                    {
                        "username": "arurahul16",
                        "content": "HI Nithesh , just understand index position of sell must be greater than buy position. i hope you will understand now"
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This problem must be categorized as medium level problem. "
                    },
                    {
                        "username": "rubayea",
                        "content": "There is some kind inconsistency with the test cases because some assume that its starts from Day 0 while others on Day 1. However the provided examples follows the normal counting of days starting from 1 . "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I had no problem"
                    },
                    {
                        "username": "roshanjhakota",
                        "content": "class Solution {\\npublic:\\n          int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n <= 1)\\n            return 0;\\n\\n        int minPrice = prices[0];\\n        int maxProfit = 0;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n\\n        return maxProfit;\\n    }\\n};     Here i have first taken min and max price as index = 0 and max as 0 while iterating over the loop i am changing the value of min max accordingly . Let me explain ....   \\nIf the arr[index] < minPrice then i have to change the minPrice as it become minPrice = arr[index]\\nand the using else if this false it means arr[index] > minPrice then i am just subtracting and checking with the maxProfit if it is maximum then it is answer otherwise maxProfit = price[i] - minPrice;"
                    },
                    {
                        "username": "abhijeetyadav82",
                        "content": "prices = [7,1,5,3,6,4]  Shouldn\\'t the max profit be 7 here. buy at 1 sell at 5. then buy at 3 sell at 6. 4+3 = 7 "
                    },
                    {
                        "username": "RealJiaJie",
                        "content": "I also had the same thinking, however, the key point is that you can only perform ONE transaction throughout the problem. Here you did two. "
                    },
                    {
                        "username": "arurahul16",
                        "content": "hi brother , you are adding the profits , that\\'s not the point, understand you need to find max profit and also need to keep in mind that sell index position should greater than buying index position and then check whether the profit you got is maximum."
                    }
                ]
            },
            {
                "id": 2059543,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2059222,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2058635,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2057134,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2053504,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2050021,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2047035,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2046535,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2040489,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2035481,
                "content": [
                    {
                        "username": "KRISHNENDU_MAITY",
                        "content": "prices = [7 , 5 , 2 , 4 , 3 , 1]\\n\\nOutput: 0\\nExpected: 2\\n\\nso you have to transfer \\'max\\' every time you change the \\'min\\'.\\nkeep  record profit = max - min; every time;\\n"
                    },
                    {
                        "username": "adreasnow",
                        "content": "For anyone struggling with time limits in python3, who don't care about getting to an $O(n)$ solution, the bottleneck is probably the use of the `max()` function inside of a loop, that I'm guessing pushes the problem to $O(n^2)$.\n\nIf you use numpy instead, then you can:\n```python\nimport numpy as np\n...\nprices = np.array(prices)\n```\n\nthen you can get the max of the numpy array (or partial numpy array) as `prices.max()` and it will be SIGNIFICANTLY more performant.\n\nI'm guessing (pure speculation) that this is because numpy stores the vector in memory before the loop and only accesses it when called, rather than python constantly building and destroying it with each loop.\n\nI'm sure there's a more efficient way to solve this problem, but getting AN answer is usually more important in an interview than coming up with the *perfect* answer."
                    },
                    {
                        "username": "bharti820",
                        "content": " if we are selling on ith day we have to buy on the minimal price from first i-1\\n\\n\\n\\n    int maxProfit(vector<int>& prices) {\\n       int profit=0,mini=prices[0];\\n       for(int i=1;i<prices.size();i++){\\n           int cost=prices[i]-mini;\\n           profit=max(profit,cost);\\n           mini=min(mini,prices[i]);\\n       } \\n       return profit;\\n    }"
                    },
                    {
                        "username": "praneethKJ",
                        "content": "in question they said prices[i] is the price of a given stock on the ith day,  does mean do we need to consider day from day 0 or 1 as per explation?"
                    },
                    {
                        "username": "parapsychic",
                        "content": "Unless explicitly specified, all problems can be thought of as starting from 0. If not, they\\'ll specify it in the problem or the constraints part."
                    },
                    {
                        "username": "taresh345",
                        "content": "prices =\\n[2,4,1]\\nexpected =2\\nmy output =0 ?\\ncan someone explain it to me how did we arrive to the expected output \\n\\n"
                    },
                    {
                        "username": "arurahul16",
                        "content": "just understand MAX profit , second day you are selling it for profit 2 and 3rd day you cannot sell because the list is empty and also selling index position should be greater than buying index position"
                    },
                    {
                        "username": "ks1313",
                        "content": "[1,2]\\n\\ntest case 3 is wrong, Buy on day 1 and sell on day 2 and return 2. The expected output shows 1. I am confused"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "[@user4279js](/user4279js)  subtract  day1 with day2 \\nprices"
                    },
                    {
                        "username": "user4279js",
                        "content": "If you buy on the first day  that's -\\$1 ... Then sell on the second day +\\$2 ... So you make a profit of $1. You get this value prices[1] - prices[0]"
                    },
                    {
                        "username": "ramongazonil",
                        "content": "I have an issue with the approach shown by [@Adam Kerr](/Serosidium) or [@AlgoEngine](/AlgoEngine), when the array is [3,100, 1, 5] for example. I can not wrap my head around to solve this case with their approach, can someone help me?"
                    },
                    {
                        "username": "Rivo11",
                        "content": "you can think of an array  of max_ right for each element so u can choose the max difference and return it."
                    },
                    {
                        "username": "ChetanJichkar08",
                        "content": "prices =\\n[2,4,1] please explain this output"
                    },
                    {
                        "username": "Rivo11",
                        "content": "the max profit will be 2 .. buy on the first day which is has a value 2 and sell on the second that has value 4.. then the profit = 4 (sell day)- 2 (buy day)= 2"
                    },
                    {
                        "username": "Rivo11",
                        "content": "I got a o(n) solution using o(n) space ... i have only one loop ,and still the time efficency comparing to others not good.. 40% .How can i improve that ?"
                    },
                    {
                        "username": "shivamyadav2113128",
                        "content": "simple dp problem "
                    }
                ]
            },
            {
                "id": 2034941,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2027699,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2026743,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2026572,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2025604,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2017569,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2017052,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2012720,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2011482,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2008881,
                "content": [
                    {
                        "username": "gmnaik96",
                        "content": "Q1. Why am I getting time limit exceeded error for following code?\\n\\nprofit = 0\\n\\n        for i in range(0,len(prices)-1):\\n            key = prices[i]\\n            for j in range(i+1,len(prices)):\\n                if(prices[j] > key):\\n                    newprofit = prices[j] - key\\n                    \\n                    if(newprofit > profit):\\n                        profit = newprofit\\n                  \\n        return profit"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Because your code run in o(n^2) brute force .. and the test cases provided make you must run your code in a less time \\n2 options :\\n1) Optimize your o(n^2) .. you will submit but in a low time efficency\\n2) Find a o(n) solution using extra space."
                    },
                    {
                        "username": "Strix_wl",
                        "content": "This cant be easy XD"
                    },
                    {
                        "username": "daria_mp",
                        "content": "i make this declaration \\ndef maxProfit(self, prices = List[int]) -> int: \\nand it says invalid syntax. I don\\'t know why. I\\'ve used it before and it worked properly. Can someone give me a hint?"
                    },
                    {
                        "username": "kar10arora",
                        "content": "I am getting this error again and again during the compilation of the code. And I have Checked the code in different compiler and it is running successfully. So why I am getting this error here again and again..\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x560e7035f015 bp 0x7ffeb3ced9a0 sp 0x7ffeb3ced990\\nREAD of size 4 at 0x603000000028 thread T0\\n    #2 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x603000000028 is located 0 bytes to the right of 24-byte region [0x603000000010,0x603000000028)\\nallocated by thread T0 here:\\n    #0 0x7fdcbb1cd808 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:144\\n    #3 0x7fdcba585082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c067fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c067fff8000: fa fa 00 00 00[fa]fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c067fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING"
                    },
                    {
                        "username": "devhindo",
                        "content": "how is this easy"
                    },
                    {
                        "username": "sunny_nath",
                        "content": "i have simple logic but it is not working for prices=[2,1,4], can anyone help?\nsome part of code is with the question, please consider it.\n\n\n \nclass Solution(object):\n    def maxProfit(self, prices):\n            if len(prices)==2:\n                for i in range(len(prices)-1):\n\n                    if prices[i]<prices[i+1]:\n                        return prices[i+1]-prices[i]\n                    else:\n                        return 0\n            if prices==sorted(prices):\n                return prices[-1]-prices[0]\n            min_p=float(inf)\n            max_p=0\n            for i in range(len(prices) - 1):\n                if prices[i] < min_p:\n                    min_p = prices[i]\n                elif prices[i] > max_p:\n                    max_p = prices[i]\n                else:\n                    continue\n            \n            if min_p <= max_p:\n                return max_p - min_p\n            else:\n                return 0\n"
                    },
                    {
                        "username": "user0570Va",
                        "content": "Having an issue with the test runner not returning from within a while loop. Tried this code for input of [ 7, 1, 5, 3, 6, 4 ] in a node shell and it returns just fine.\\n\\nI\\'ve tried using a break, setting a boolean condition the while evaluates, and explicitly returning from within the while but it always seems to get caught in an infinite loop!\\n\\n```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\n\\nvar maxProfit = function(prices) {\\nlet process = true\\n\\n  let profit = 0\\n  console.log(\\'process is\\', process)\\n  while(process) {\\n    // profit = prices[0]\\n\\n    console.log(\\'prices\\', prices)\\n    console.log(\\'process\\', process)\\n    const maxPrice = Math.max(...prices)\\n    const minPrice = Math.min(...prices)\\n  \\n    const maxPriceIndex = prices.findIndex((p)=> p===maxPrice)\\n    const minPriceIndex = prices.findIndex((p)=> p===minPrice)\\n    console.log(\\'minIdx\\', minPriceIndex)\\n    console.log(\\'maxIdx\\', maxPriceIndex)\\n    if (minPriceIndex === prices.length-1) {\\n        console.log(\\'why am i here?\\')\\n        prices = [...prices.slice(0, prices.length)]\\n        continue\\n    }\\n    if(minPriceIndex < maxPriceIndex) {\\n        const tempProfit = maxPrice-minPrice\\n        if(tempProfit > profit) {\\n            profit = tempProfit\\n            console.log(\\'returning now\\')\\n            process =false\\n            return profit\\n        }\\n    } else {\\n        prices = [...prices.slice(0,maxPriceIndex),...prices.slice(maxPriceIndex+1,prices.length)]\\n    }\\n  }\\n  \\n    return profit\\n};\\n```\\n\\nLOG OUTPUT:\\n```\\nprocess is true\\nprices [ 7, 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 1\\nmaxIdx 0\\nprices [ 1, 5, 3, 6, 4 ]\\nprocess true\\nminIdx 0\\nmaxIdx 3\\nreturning now\\nprocess is true\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\nprices [ 7, 6, 4, 3, 1 ]\\nprocess true\\nminIdx 4\\nmaxIdx 0\\nwhy am i here?\\n```\\n"
                    },
                    {
                        "username": "user4279js",
                        "content": "Strange,... Would be good to console log the version of the node runtime version if that\\'s possible"
                    },
                    {
                        "username": "Subiksha_KS",
                        "content": "For the test case #153,\n`prices = [3,3,5,0,0,3,1,4]`\nHow is the expected output 4 and not 3?\n\nAccording to me the explanation is : Buy on day 7 (price = 1) and sell on day 8 (price = 4), so profit = 4-1 = 3.\n\nWhere am I going wrong?\n"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 4 or day 5(price = 0) and sell on day 8-- price=4\\n4-0=4 ,  the gap between the buying and selling day doesn\\'t matter"
                    },
                    {
                        "username": "apoorva123sinha123",
                        "content": "how does it make sense that [1,2] expects an output of 1 instead of 2?"
                    },
                    {
                        "username": "shubhamDhapola",
                        "content": "buy on day 1 at 1 , sell on day 2 at 2 -- 2-1=1 answer"
                    },
                    {
                        "username": "darthnithin",
                        "content": "Time limit exceeded using the intuitive brute force method :("
                    }
                ]
            },
            {
                "id": 2008631,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 2007997,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 2007439,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 2005483,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1997386,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1995165,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1990636,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1988341,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1987856,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1984254,
                "content": [
                    {
                        "username": "chakravarthybatna46234",
                        "content": "why this below code shows Time Limit Exceeded when i submit my answer,\\nis this code wrong??????? please tell anyone\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0,profit=0,k=2;\\n        for(int i=prices.length-1;i>=0;i--)\\n        {\\n            for(int j=prices.length-k;j>=0;j--)\\n            {\\n               profit=prices[i]-prices[j];\\n               if(profit>0&&profit>max)\\n               {\\n                   max=profit;\\n               }\\n            }\\n            k++;\\n        }\\n        return max;\\n    }\\n}"
                    },
                    {
                        "username": "user4279js",
                        "content": "You can do this problem in linear time, so this probably isn\\'t accepted for larger inputs "
                    },
                    {
                        "username": "ojjasvi",
                        "content": "This is a tricky question . If you are solving this question using two loop one for smallest number and second loop for maximum profit ..... then think again \\uD83D\\uDE00"
                    },
                    {
                        "username": "aceton41k",
                        "content": "Time Limit Exceeded on test case 200/212 in Java"
                    },
                    {
                        "username": "user4279js",
                        "content": "Please post a snippet or what your expected time complexity is... For this problem, only linear is accepted I think"
                    },
                    {
                        "username": "poornachandra07",
                        "content": "Can someone help me in below C# solution. It fails at 198th testcase\\n\\n`public int MaxProfit(int[] prices) {\\n        if(prices.Length<2) \\nreturn 0;\\n        var bestPrice = prices\\n        .SelectMany((price, index) => prices\\n            .Skip(index + 1)\\n            .Select(nxtPrice => price - nxtPrice))\\n        .Min();\\n\\n\\n        if(bestPrice<0){\\n            return -(bestPrice);\\n        }\\n        return 0;\\n    }`"
                    },
                    {
                        "username": "user4279js",
                        "content": "This approach doesn\\'t work .. firstly  you can\\'t just flip the sign of bestPrice, if it\\'s negative it means you bought for more than you sold so the sign has a significance to the problem.\\nSecondly  I think your code is doing O(n^2) work with the two selects correct me if I\\'m wrong."
                    },
                    {
                        "username": "chandancodes_28",
                        "content": "guys , i code in c and i have 200/212 testcases passed . i applied double pointer and then returned the maximum profit i could . someone plz help"
                    },
                    {
                        "username": "LeetCode_Problem",
                        "content": "prices = [2,4,1] why the expected value is 2. Can anyone please tell me"
                    },
                    {
                        "username": "SwaggerKid",
                        "content": "u bought on the 1st day, and sold on the second. So your profit is 2 dollars. "
                    },
                    {
                        "username": "vamshidharreddy3397",
                        "content": "Should we consider 0 while buying stock or avoid it?\\n\\nthere are 2 test cases which are conflicting\\n1) [3,2,6,5,0,3] in this case expected output is 4 which is (6-2)\\n2) [2,1,2,1,0,1,2] in this case expected output is 2 which can be (2 - 0)\\n\\nThanks in advance"
                    },
                    {
                        "username": "makleo2002",
                        "content": "211 case is incorrect"
                    },
                    {
                        "username": "nikitafeoktistov",
                        "content": "The solutions all mention a greedy approach, where you keep track of the minimum cost and update it whenever there is a smaller value. Why doesn\\'t this fail any testcases? I\\'d imagine something along the lines of [6,12,1,3] would cause those algorithms to fail, no?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This approach doesn\\'t fail any test cases due to the nature of the problem. The problem asks for the maximum profit we can make from a single buy and sell operation. The best time to buy is always the lowest possible price up to the current point in time, which is why we keep track of the minimum cost.\\n\\nFor your example, [6,12,1,3], this approach correctly identifies that the best time to buy is when the cost is 1. However, it also keeps track of the maximum profit possible up to the current point in time, which includes profits made before we encounter this new minimum.\\n\\nLet\\'s break down this example:\\n\\n- Initially, the minimum cost is 6, and the maximum profit is 0.\\n- Next, we see 12. We update our maximum profit to be max(0, 12 - 6) = 6. Minimum cost remains at 6.\\n- Then, we see 1. Now, we update our minimum cost to be 1 since 1 < 6. Our maximum profit is still 6 from before.\\n- Finally, we see 3. The maximum profit becomes max(6, 3 - 1) = 6.\\n\\nSo, the algorithm correctly returns 6 as the maximum profit. It\\'s important to note that the algorithm doesn\\'t just remember the latest minimum cost, but also the maximum profit it can make with previous minimum costs. So, the greedy approach works perfectly for this problem."
                    },
                    {
                        "username": "johngjackson0",
                        "content": "You\\'re not using the minimum of the data set. Whichever element you are on, you need to know the minimum BUY from all other elements in the previous elements only. Calculate the profit and max profit at that element. This ensures you\\'re doing buy and sell in proper order for the answer. "
                    },
                    {
                        "username": "abhishekspawar2003",
                        "content": "[2,11,1,4,7]\\nHow to let code know that there is good option lies at start."
                    }
                ]
            },
            {
                "id": 1984019,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1983668,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1976956,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1976316,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1975276,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1974149,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1972813,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1970161,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1959176,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1958022,
                "content": [
                    {
                        "username": "Shaswat_Pandey",
                        "content": "As the time constraint is given 10^6 , i was thinking that in these type of cases, we can move upto the time complexity of O(n logn). Correct me if i\\'m wrong?\\n\\ncan we solve the same problem in O(n logn)?\\nif yes then kindly suggest the idea.\\nThanks!"
                    },
                    {
                        "username": "woeth",
                        "content": "Most of the solutions are incorrect, as the list represents days and the data represents prices. following logic prices[i] means price on day i. so ->\\n[7,1,5,3,6,4,9,4]\\nbuy in day 2 and sell in day 7 your profit is 8\\nbut the expected output shows 8 as the best day\\n\\nthis solution shows the correct outputs according to the problem description\\n `class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        profit = 0\\n        day = 0\\n        for i in range(len(prices) - 1):\\n            for j in range(i + 1, len(prices)):\\n                if prices[j] - prices[i] > profit:\\n                    day = j + 1\\n                    profit = prices[j] - prices[i]\\n        return day`"
                    },
                    {
                        "username": "sanskarv120503",
                        "content": "i am not understant this qution "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "every time i come to solve this problem i cant optimize it "
                    },
                    {
                        "username": "pawarsach_n",
                        "content": "where did i went wrong?\\n\\n `class Solution {\\n    public static class Stock {\\n        int day;\\n        int price;\\n        \\n        Stock(int day, int price) {\\n            this.day = day;\\n            this.price = price;\\n        }\\n    }\\n    \\n    public int maxProfit(int[] prices) {\\n        Stock sell = new Stock(0, 0);\\n        Stock buy = new Stock(0, Integer.MAX_VALUE);\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] <= buy.price && sell.day<=buy.day) {\\n                System.out.println(\" stock bought at day \"+(i+1)+\" at price \"+prices[i]);\\n                buy.price = prices[i];\\n                buy.day = i + 1;\\n            }\\n            if (prices[i] >= sell.price && i + 1 > buy.day) {\\n                System.out.println(\" stock selled at day \"+(i+1)+\" at price \"+prices[i]);\\n                sell.price = prices[i];\\n                sell.day = i + 1;\\n            }\\n        }\\n        \\n        int profit = sell.price - buy.price;\\n        return profit > 0 ? profit : 0;\\n    }\\n}\\n`\\n\\n[2,1,2,1,0,1,2]\\n\\nUse Testcase\\nStdout\\n stock bought at day 1 at price 2\\n stock bought at day 2 at price 1\\n stock selled at day 3 at price 2\\n stock selled at day 7 at price 2\\nOutput\\n1\\nExpected\\n2"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Maintain the minimum price seen so far and update the maximum profit whenever the current profit is greater than maximum profit (curr profit = price[i]-min price)\\nHope it helps !"
                    },
                    {
                        "username": "Meghajit",
                        "content": "We can solve it by memoizing the maximas at each index as seen traversing from the right. \\n\\nSince we can only sell after we buy( that\\'s how stocks work :) ), the problem is simply that: Given I buy a stock on day T, can I sell it at a cheaper price at any day after day T and if so how much is the profit ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rishith_11203",
                        "content": "[1,4,2]\\noutput :2\\nexpected:3\\nit this worng:\\n1-4 =3\\nwhich is 2nd elemnet can u help me"
                    },
                    {
                        "username": "winstonallo",
                        "content": "you buy at day 0, sell at day 1, 4-1=3"
                    },
                    {
                        "username": "Mkaif_Agb",
                        "content": "prices = [2,4,1] \\nThis should have the expected profit of 0 as the number 1 is the lowest but testcase 154 wants the expected output to be 2. I am unable to understand."
                    },
                    {
                        "username": "winstonallo",
                        "content": "[@bjraval](/bjraval) No, profit is selling price - buying price, in this case you would do 1-4 which is -3."
                    },
                    {
                        "username": "bjraval",
                        "content": "[@winstonallo](/winstonallo) what you are saying doesn\\'t make sense. For the example [2,4,1], the correct solution is 3 i.e. buy on Day2 and sell on day 3 so 4-1 = 3"
                    },
                    {
                        "username": "winstonallo",
                        "content": "You just need to find the biggest difference between one integer and another that comes after in the array.\\nYou would return 0 if for example the array is [5, 4, 3].\\nIn this case, max(s[j > i] - s[i]) = 4 - 2 = 2"
                    },
                    {
                        "username": "soslow",
                        "content": "shorting is common practice.."
                    }
                ]
            },
            {
                "id": 1956000,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1954492,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1951533,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1949654,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1946608,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1945955,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1943053,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1942138,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1940079,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1939930,
                "content": [
                    {
                        "username": "abmath113",
                        "content": "I don\\'t get it, how does this problem is sliding window."
                    },
                    {
                        "username": "Tikam_Gupta",
                        "content": "class Solution{\\npublic:\\n    int maxProfit(vector<int>& prices){\\n        int profit= 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            for(int j= i+1; j<prices.size(); j++){\\n                int ans= prices[j] - prices[i];\\n                profit = max(ans, profit);\\n            }\\n        }\\n        return profit;\\n    }\\n\\n};\\n\\nWhy is it showing time limit exceeded?"
                    },
                    {
                        "username": "maharahisoni",
                        "content": "CODE:\\n\\nint maxii=0;\\nclass Solution {\\npublic:\\n    int minimum(vector<int> arr,int size){\\n    if (size==0) return arr[0];\\n    int temp=min(arr[size-1],minimum(arr,size-1));\\n    maxii=max(maxii,arr[size]-temp);\\n    return temp;\\n} \\n    int maxProfit(vector<int> prices) {\\n      \\n       minimum(prices,prices.size()-1);\\n       int temp=maxii;\\n       maxii=0;\\n       return temp;\\n    }\\n};\\n\\nThis code stucks at TC no 198 in  MEMORY LIMIT EXCEED why??"
                    },
                    {
                        "username": "johngjackson0",
                        "content": "There is a much easier way to do this than Sliding Window or Dynamic programming! Instead it would be \"Greedy Algorithm.\" It\\'s a way to say, in the present make the \"best choice.\" \\n\\n1. Since you cannot go in the past, it\\'s not a simple min vs max of nums. i.e. your min number cannot be compared to a max number before it. \\n2. You just calculate the optimal choice in the present."
                    },
                    {
                        "username": "uddiptapathak729",
                        "content": "how can a stock be bought at zero lol"
                    },
                    {
                        "username": "Mr_Jobs",
                        "content": "Time & Space: O(n) & O(1)\\n1. Use two variables to keep track of max_profit and max_price\\n2. Traverse from the end\\n3. If encounter a price that is greater than max_price, update max_price\\n4. Else, calculate profit and update max_profit if profit is greater than max_profit"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "This keeps getting the \"Time Limit Exceeded\" error on the 200th test case. Can anyone please offer some guidance on what I am doing wrong or what I should do to make it work? I am only using one loop\n\nmax_profit = 0\n        for i in range(len(prices)):\n            if i != len(prices)-1:\n                temp_max = max(prices[i+1:len(prices)]) - prices[i]\n                if temp_max > max_profit:\n                    max_profit = temp_max\n        return max_profit"
                    },
                    {
                        "username": "luizhenriquemaia",
                        "content": "Nice one, it's impossible to writing the solution with python, because of runtime, thanks alot leetcode for -1 hour of my life for nothing :)"
                    },
                    {
                        "username": "JeremyAnderson8",
                        "content": "fr, doesn\\'t work with my single for loop. don\\'t know what else to do "
                    },
                    {
                        "username": "chazwinter",
                        "content": "We should be able to flag/report bad solutions. The \"top\" solutions just hard code the answers for the large test cases  to appear faster. That\\'s really lame, and I see it as cheating. We\\'re here to learn, not cheat."
                    },
                    {
                        "username": "prasumitmishra",
                        "content": "for [1, 2, 4], the expected answer is 3. Not sure How?\nYou can do a Buy + Buy + Sell, which means -1 -2 + (2*4) = 5 is your profit. Not sure how come is the expected answer 3?\n\nMy approach includes continue buying till you find max on your right.\nEg.\n\n[1, 3, 5, 3, 1, 2]\nMax is 5 (So sale should happen here)\n[1 (Buy) 3(Buy) 5 (Sell)] [3,  1,  2]\n\nRepeat same with [3, 1, 2] : (if present rate is greater than max on right, skip: don't buy don't sell), i.e. [3(hold) 1 (Buy), 2 (Sell)]\n\n-1 -3 +5*2 + 0 -1  + 2\n= 7.\n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a single transaction only problem."
                    }
                ]
            },
            {
                "id": 1935929,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1933542,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1933269,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1933183,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1930000,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1923542,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1922941,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1921452,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1919708,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1912831,
                "content": [
                    {
                        "username": "anmolsankadiya",
                        "content": "can someone write dp relation for the recursion code below although it pass all the test \\n\\nclass Solution {\\npublic:\\n    int func(vector<int>& prices ,int i ,int e){\\n        if(i>=prices.size()) return 0;\\n        if(prices[i]>=e && e!=-1){\\n            return max(prices[i]-e , func(prices, i+1,e));\\n        }\\n        else return func(prices,i+1,prices[i]);\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        return func(prices,0,-1);\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "In testCase:\\nprices = [7, 1, 5, 3, 6, 4]\\nOutput = 5\\nExpected = 5\\nOK\\n\\nAfter i submited my code:\\nprices = [1, 2]\\nOutput = 2\\nExpected = 1"
                    },
                    {
                        "username": "gribeiro5000",
                        "content": "[@ashim_raibs](/ashim_raibs) You are right! Thank you! "
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "you\\'re not supposed to return day, you have to return max profit"
                    },
                    {
                        "username": "dhanushhg",
                        "content": "Hey, i just need a small help, while i code this in VScode, it works, the same code i put it here and i\\'m constantly failing the test case 2, can anyone help me, what i am wrong with at? my code\\nclass Solution {\\n    static int profit=0;\\n    static int main_profit=0;\\n     public static int maxProfit(int[] prices) {\\n      for(int i=0;i<prices.length;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n           main_profit= prices[j]-prices[i];\\n        //   System.out.println(main_profit);\\n            if(profit<main_profit){\\n        profit=main_profit;\\n       }      \\n        }\\n      }              \\n      if(profit<=0){\\n        profit= 0;\\n       }\\n     return profit;\\n} }\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason you might be failing the second test case could be due to the static variables `profit` and `main_profit`. These variables maintain their values across multiple calls to the function `maxProfit`. If the function is being called more than once (as in the test environment of many online coding platforms), the old values of `profit` and `main_profit` could interfere with the calculations of subsequent calls, leading to incorrect results.\\n\\nHere\\'s your code, adjusted to remove the static variables:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit = 0;\\n        int main_profit = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                main_profit = prices[j] - prices[i];\\n\\n                if (profit < main_profit) {\\n                    profit = main_profit;\\n                }\\n            }\\n        }\\n\\n        if (profit <= 0) {\\n            profit = 0;\\n        }\\n\\n        return profit;\\n    }\\n}\\n```\\n\\nPlease note that the inner for-loop in your implementation leads to a time complexity of O(n^2) which might cause a timeout for large inputs. A more efficient approach would be to keep track of the minimum price and the maximum profit during a single pass through the array.\\n\\nHere\\'s an efficient solution with O(n) complexity:\\n\\n```java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice = Integer.MAX_VALUE;\\n        int maxProfit = 0;\\n        \\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minPrice) {\\n                minPrice = prices[i];\\n            } else if (prices[i] - minPrice > maxProfit) {\\n                maxProfit = prices[i] - minPrice;\\n            }\\n        }\\n        \\n        return maxProfit;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "harishini45",
                        "content": "time limit exceeded yaar failed at 202 "
                    },
                    {
                        "username": "mdsang_97",
                        "content": "[1,2]\\noutput:2\\nexpected:1\\n?"
                    },
                    {
                        "username": "ashim_raibs",
                        "content": "1 is the maxProfit, not the day/index, I got confused too "
                    },
                    {
                        "username": "_DarKReapper_",
                        "content": "class Solution {\\n    vector<vector<int>> t;\\npublic:\\n    int maxProfit(vector<int>& prices) \\n    {\\n        int n = prices.size();\\n        t.resize(n + 1, vector<int>(2,-1));\\n        return rec(prices.size(),1,prices);       \\n    }\\n    int rec(int n,int s,vector<int>& nums )\\n    {\\n        if(n <= 0) return 0;\\n        \\n        if(t[n][s] != -1) return t[n][s]; \\n        if(s)\\n        {\\n            return t[n][s] = max(nums[n - 1] + rec(n -1, 0,nums),rec(n -1,s,nums));\\n        }\\n        else \\n        {\\n            return t[n][s] = max(rec(n -1,s,nums), -nums[n - 1] );\\n        }\\n    }\\n};\\n\\n-- why is this code not working and how to correct it?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach seems to be trying to solve a slightly different problem. In the problem statement, you are asked to find the maximum profit with at most one transaction (buy one and sell one share of the stock). The solution you provided seems to be trying to solve a problem where you can buy and sell as many times as you want.\\n\\nHowever, your recursive function call seems to be a bit off. In the case where you\\'re not holding a stock (`s == 0`), you\\'re not subtracting from `rec(n - 1, 1, nums)` in the return statement, so it effectively ends up ignoring the buying operation and the cost associated with it.\\n\\nA simpler and more efficient approach would be as follows:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int minPrice = INT_MAX;\\n        int maxProfit = 0;\\n        for(int i=0; i<prices.size(); i++) {\\n            minPrice = min(minPrice, prices[i]);\\n            maxProfit = max(maxProfit, prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};\\n```\\n\\nThis solution works in O(n) time complexity and doesn\\'t require additional space like a DP solution. It keeps track of the minimum price we\\'ve seen so far and the maximum profit we can get from selling at the current price."
                    },
                    {
                        "username": "ssalinasfe",
                        "content": "I cannot solve this problems due to time limitex exceed. It is impossible due to one of the test case is a enormous array of input of 31915 elements,, and I get time limit exceeded only for traverse the array."
                    },
                    {
                        "username": "akarshannigam123",
                        "content": "The compiler has some problem with it as it is not performing appropriately and it is giving error while other compiler are giving correct output"
                    },
                    {
                        "username": "dynamic099",
                        "content": " int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX;\\n        int minIndex = 0;\\n        int buy ;\\n        int profit ;\\n        int i ; \\n        int n = prices.size();\\n        if(n==0||n==1)\\n        return 0 ;\\n        cout << n ;\\n        for (i = 0 ; i < prices.size() ; i++)\\n        {\\n            \\n            if(prices[i]<mini)\\n            {\\n                mini = prices[i];\\n                minIndex=i;\\n            }\\n            // cout<<\"The value of minIndex is \"<<minIndex;   \\n        }\\n        if(minIndex < n )\\n        {\\n            int max = prices[mini];\\n            for(int i=mini ; i < prices.size();i ++)\\n            {\\n                if(prices[i]>max)\\n                max=prices[i];\\n            }\\n            buy=prices[mini];\\n            profit=max-buy;\\n            return profit ;\\n        }\\n        else\\n        return 0 ;\\n    }\\n\\nWhy is this solution not working for the test case [1,2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation has some logical and syntax errors. Here are some of the reasons why your solution might fail for the test case [1,2]:\\n\\n1. You have initialized `mini` as INT_MAX and then `max` as prices[mini]. This can be problematic because `mini` is the minimum value from the integer range, not the index. It looks like you\\'ve confused the variable `mini` (which is meant to store the minimum price) with `minIndex` (which is meant to store the index of the minimum price). So in the line where you have `int max = prices[mini];`, you should actually have `int max = prices[minIndex];`.\\n\\n2. Your check `if(minIndex < n )` doesn\\'t make sense because `minIndex` will always be less than `n` (which is prices.size()). This if block will always be true and is therefore not needed.\\n\\n3. In the for loop, you\\'ve used `mini` as the start index, but it should be `minIndex`. The loop should start from `minIndex`, not from `mini`.\\n\\nA corrected version of your function could look something like this:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int mini = INT_MAX;\\n    int minIndex = 0;\\n    int n = prices.size();\\n\\n    if(n < 2)\\n        return 0;\\n\\n    // Find the minimum price and its index\\n    for (int i = 0 ; i < n ; i++) {\\n        if(prices[i] < mini) {\\n            mini = prices[i];\\n            minIndex = i;\\n        }\\n    }\\n\\n    // Find the maximum price after the minimum price\\n    int maxPrice = prices[minIndex];\\n    for(int i = minIndex ; i < n; i++) {\\n        if(prices[i] > maxPrice)\\n            maxPrice = prices[i];\\n    }\\n\\n    return maxPrice - mini;\\n}\\n```\\n\\nThis should now work correctly for the input [1,2]. However, this still has a linear time complexity and can be improved to a constant time complexity by keeping track of the minimum price and maximum profit simultaneously:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int minPrice = INT_MAX;\\n    int maxProfit = 0;\\n\\n    for(int i = 0; i < prices.size(); i++) {\\n        if(prices[i] < minPrice) {\\n            minPrice = prices[i];\\n        } else if(prices[i] - minPrice > maxProfit) {\\n            maxProfit = prices[i] - minPrice;\\n        }\\n    }\\n\\n    return maxProfit;\\n}\\n```"
                    },
                    {
                        "username": "teenel",
                        "content": "I dont understand what\\'s wrong with last test? (211)\\nIt\\'s write `Time Limit Exceeded`\\nLast Executed Input `prices = ` (There is nothing, no zero, no digits). I make check for `null`, but it isn\\'t help.\\nAnd also there no output and excepted values"
                    }
                ]
            },
            {
                "id": 1912148,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1903962,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1903519,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1901925,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1898032,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1896805,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1887292,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1876807,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1872643,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1862252,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "At first, I used the nested loop and it went through very well with small array. However, with the last test case, it gave error because it had excessed the time limit.\n\nThen I realised that nested loop was not OK so maximum 1 loop.\nNow, let think what I can do with 1 loop? \nThen boom, using conditional structure inside the loop to find the smallest value and maximum profit by substructing the current value with smallest value (until the loop point).\n\nIn general, it will be like this (no real code)\n\nminValue = [integer max value]\nmaxProfit = 0\n\nloop i from 0 to prices.length\nif prices at position i < minValue then minValue = prices at position i\nelse if prices at position i subtract minValue is greater than maxProfit then maxProfit will be adjusted accordingly.\n\nAlso, you can use Min, Max without using conditional structure.\nminValue = min(minValue, Prices at i)\nmaxProfit = max(maxValue, Prices at i - minValue)\n\nIt will constantly change the minValue in order get the maximum Profit."
                    },
                    {
                        "username": "aysknt_02",
                        "content": "How to resolve the time exceeded issue at 200th testcase ?"
                    },
                    {
                        "username": "KayvanShah1",
                        "content": "Profit can also be maximized for first instance by selling on 1st day and buying on second day\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 6\\n\\nExplanation: Sell on day 1 (price = 7) and buy on day 2 (price = 1), profit = 7-1 = 6."
                    },
                    {
                        "username": "zafar99",
                        "content": "def maxProfit(self, stocks: List[int]) -> int:\\n        outcomes = []\\n        for x in stocks:\\n            for y in stocks[stocks.index(x):]:\\n                outcomes.append(y-x)\\n        return max(outcomes)\\n\\nI am getting Memory Limit Exceeded problem. Why? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The Memory Limit Exceeded error is likely due to the fact that you\\'re storing all possible outcomes in a list before returning the maximum. This can take up a lot of memory especially when the size of the `stocks` list is large.\\n\\nBesides, the time complexity of your solution is also high due to the nested for loops. The time complexity is approximately O(n^2), where n is the length of the `stocks` list. And, you are also using `stocks.index(x)` in your code, which takes O(n) time for each call, making your solution even slower.\\n\\nYou can solve this problem with a linear scan, which only needs to iterate through the `stocks` list once. \\n\\nHere is a more efficient approach using the concept of dynamic programming. This approach only uses O(1) memory and runs in O(n) time:\\n\\n```python\\ndef maxProfit(self, prices: List[int]) -> int:\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n\\n    return max_profit\\n```\\n\\nIn this approach, you maintain a variable `min_price` to hold the minimum price seen so far and a variable `max_profit` to hold the maximum profit. You then iterate over the `prices` list updating `min_price` and `max_profit` accordingly. At the end of the loop, `max_profit` will hold the maximum profit that can be achieved."
                    },
                    {
                        "username": "Priyanshu626",
                        "content": "can we do this problem with O(N) time complexity"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, this problem can indeed be solved in O(N) time complexity using a technique often referred to as the \"one pass\" approach, which involves a single iteration over the input list.\\n\\nThe key insight here is that the maximum profit that can be made from selling on a particular day is determined by the minimum price seen on any of the previous days. This suggests an algorithm: keep track of the minimum price seen so far, and for each day, check if selling on that day would yield a higher profit than any seen before.\\n\\nHere\\'s a Python implementation of this approach:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')  # initialize min_price to be a very large number\\n    max_profit = 0  # initialize max_profit to be 0\\n\\n    for price in prices:  # iterate through the list of prices\\n        if price < min_price:\\n            min_price = price  # update min_price if current price is less than min_price\\n        elif price - min_price > max_profit:\\n            max_profit = price - min_price  # update max_profit if the profit of selling now is more than max_profit\\n\\n    return max_profit\\n```\\n\\nIn this code, we go through the list of prices once, updating the minimum price and maximum profit as necessary. Thus, the time complexity is O(N), where N is the number of days (or the size of the input list). This is much more efficient than an approach that considers all pairs of days, which would have a time complexity of O(N^2)."
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Did the code in O(n) and still got TLE. After commenting the debug the test case passed successfully. I would suggest using Fast Input-Output for better results."
                    },
                    {
                        "username": "tommy787576",
                        "content": "[Complete Five solutions: One-pass / DP and Optimized DP / Maximum Subarray with Kadane\\'s alg or D&C](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227281/complete-five-solutions-one-pass-dp-and-optimized-dp-maximum-subarray-with-kadane-s-alg-or-d-c/)\\nIf you find it helpful, please give me a star\\uD83D\\uDE00. Thank you!"
                    },
                    {
                        "username": "bader45berro",
                        "content": "can someone explain how this test case is working input [2,4,1] and the expected output is equal to 2\\n"
                    },
                    {
                        "username": "theerawatch",
                        "content": "buy 2, sell 4\\nprofit = 4-2 = 2"
                    },
                    {
                        "username": "anshuuuu____",
                        "content": "To solve this question in O(N) and constant space O(1) :-\n\n1. Make two variables maxprofit and mintillnow.\nmaxprofit=0 and mintillnow=prices[0]\n2. Traverse the array and findmin.\nmintillnow=min(mintillnow,prices[i]);\n3. find profit = prices[i]-mintillnow;\n4. update maxprofit\n\n\nHere we are trying to sell the stock everyday."
                    },
                    {
                        "username": "sahilshinde-45",
                        "content": "can anyone help me with runtime error i.e(Time Limit Exceeded) at 200th case.\\nbelow is my code\\n        profit = 0\\n        min_of_price = prices[0]\\n        for i in range(0,len(prices[1:])):\\n            min_of_price = min(min_of_price,prices[1:][i])\\n            profit = max(profit,prices[1:][i] - min_of_price)  \\n        return(profit)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is that you\\'re slicing the `prices` list in every iteration of your loop, which leads to a large amount of unnecessary computation and increases the time complexity. The slice operation `prices[1:]` creates a new list in each iteration which takes additional time, resulting in a Time Limit Exceeded (TLE) error for large input.\\n\\nHere is the corrected version of your code:\\n\\n```python\\nprofit = 0\\nmin_of_price = prices[0]\\nfor i in range(1, len(prices)):\\n    min_of_price = min(min_of_price, prices[i])\\n    profit = max(profit, prices[i] - min_of_price)\\nreturn profit\\n```\\n\\nIn this code, we start iterating from the second day (`i = 1`) till the end of `prices` list. We find the minimum price till the current day and the maximum profit we could have made till now. This approach ensures we are only using a single pass through the `prices` list, thus achieving a linear time complexity O(N), where N is the size of the `prices` list."
                    }
                ]
            },
            {
                "id": 1858263,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1856403,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1841400,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1836519,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1835268,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1833692,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1832161,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1821442,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1815109,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1814574,
                "content": [
                    {
                        "username": "OctavianSN",
                        "content": "Input : [1,2] (Test 19/211)\\nOutput: 2\\nExpected: 1\\nSo I buy on day one and sell on day one? Not day two to maximize profit? Wat??"
                    },
                    {
                        "username": "PeterTheZoe",
                        "content": "You're buying on day 1 which is 1 and selling on day 2, now 2 and returning a max profit 1 ( 2 - 1)"
                    },
                    {
                        "username": "MeghaShivhare",
                        "content": "First check if the array is empty and return 0 if it is.\\n\\nInitialize variables - min_price and max_profit - to the first price in array and 0, respectively. Iterate through the array and update these variables as follows:\\n\\nIf the current price is less than the minimum price seen so far, update min_price to the current price.\\nOtherwise, if the difference between the current price and min_price is greater than max_profit, update max_profit to this difference.\\nAfter iterating through the entire array, return max_profit"
                    },
                    {
                        "username": "palak8856",
                        "content": "abc"
                    },
                    {
                        "username": "NitinBhalla",
                        "content": "Tip :  Use recursive approach , try to find the difference of arr[j] and arr[i] where j>i , and if that diff is greater than profit update accordingly,\\n\\nDRY RUN THE APPROACH , YOU WILL DEFINATELY FIND THE WAY OUT."
                    },
                    {
                        "username": "adityagupta36",
                        "content": "#JAVA# Test cases passed, but TLE....how to overcome this??\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit =0;\n        int n = prices.length;\n        for(int i=0; i<n-1; i++){\n            for(int j=i+1; j<n; j++){\n            int ans=prices[i]-prices[j];\n            if(ans<maxprofit){\n                maxprofit=ans;\n            }\n            else{\n                maxprofit = maxprofit;\n            }\n        }\n        \n    }\n    return maxprofit*(-1);\n}\n}"
                    },
                    {
                        "username": "tirthyakamaldasgupta",
                        "content": "In this test input, [2,1,2,1,0,1,2], I am assuming that the buying price should be 1 and the selling price should be 2, resulting in a profit of 1. But the test case expects the profit to be 2. It will be of great help if someone is generous to help clear the confusion."
                    },
                    {
                        "username": "user4836NR",
                        "content": "you buy at day 5 = 0 then sell at day 7 = 2; 2-0=2"
                    },
                    {
                        "username": "Vithesh",
                        "content": "bruh....this took me around 40min to solve this in O(n) and this was a almost a medium level question.\\n\\nWe are using two pointer.\\nAnd a max variable.\\n"
                    },
                    {
                        "username": "mydjolie",
                        "content": "[2, 1, 2, 1, 0, 1, 2] \\nOutput : 1\\nExpected : 2\\nhow? buy =0 sell =2 ?\\ncan we buy 0 ?"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice=prices[0];\\n        int profit=0;\\n        for(int i=1;i<prices.length;i++){\\n            int newProfit=prices[i]-minPrice;\\n            \\n            profit=Math.max(profit,newProfit);\\n            minPrice=Math.min(minPrice,prices[i]);\\n        }\\n        return profit;\\n        \\n    }\\n}`"
                    },
                    {
                        "username": "nhefner",
                        "content": "prices = [1,2]\nOutput = 2\nExpected = 1\n\nTest Case # 20\n\nBuy on the first day, sell on the second?\nis this a correct test case?"
                    }
                ]
            },
            {
                "id": 1814450,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814409,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814269,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814096,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814094,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814093,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1814039,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1813951,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1813896,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1813788,
                "content": [
                    {
                        "username": "kos2kos",
                        "content": "<div class=\"view-lines monaco-mouse-cursor-text\" role=\"presentation\" aria-hidden=\"true\" data-mprt=\"7\" style=\"position: absolute; font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace; font-weight: normal; font-size: 15px; font-feature-settings: &quot;liga&quot; 0, &quot;calt&quot; 0; line-height: 23px; letter-spacing: 0px; width: 1364px; height: 747px;\"><div style=\"top:8px;height:23px;\" class=\"view-line\"><span><span class=\"mtk4\">class</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">Solution</span><span class=\"mtk1\">&nbsp;{</span></span></div><div style=\"top:31px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk4\">public</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk11\">maxProfit</span><span class=\"mtk1\">(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">[]&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">)&nbsp;{</span></span></div><div style=\"top:54px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk3\">/*Go&nbsp;through&nbsp;list&nbsp;and&nbsp;add&nbsp;all&nbsp;values&nbsp;maintaing&nbsp;max</span><span class=\"mtk3\">imum&nbsp;value&nbsp;</span></span></div><div style=\"top:77px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterate&nbsp;through&nbsp;the&nbsp;list&nbsp;and&nbsp;find&nbsp;differen</span><span class=\"mtk3\">ce&nbsp;between&nbsp;max&nbsp;and&nbsp;current&nbsp;val.&nbsp;set&nbsp;result&nbsp;to&nbsp;larg</span><span class=\"mtk3\">er&nbsp;numnber.</span></span></div><div style=\"top:100px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove&nbsp;currnet&nbsp;number&nbsp;from&nbsp;maxHeap.&nbsp;</span></span></div><div style=\"top:123px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result</span></span></div><div style=\"top:146px;height:23px;\" class=\"view-line\"><span><span class=\"mtk3\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span></span></div><div style=\"top:169px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;</span><span class=\"mtk10\">Integer</span><span class=\"mtk1\">&gt;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk13\">new</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk10\">PriorityQueue</span><span class=\"mtk1\">&lt;&gt;(</span><span class=\"mtk14\">Collections</span><span class=\"mtk1\">.</span><span class=\"mtk11\">reverseOrder</span><span class=\"mtk1\">());</span></span></div><div style=\"top:192px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:215px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">result</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;</span></span></div><div style=\"top:238px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div><div style=\"top:261px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">stock</span><span class=\"mtk13\">:</span><span class=\"mtk1\">&nbsp;prices){</span></span></div><div style=\"top:284px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">add</span><span class=\"mtk1\">(stock);</span></span></div><div style=\"top:307px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:330px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:353px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">for</span><span class=\"mtk1\">&nbsp;(</span><span class=\"mtk10\">int</span><span class=\"mtk1\">&nbsp;</span><span class=\"mtk14\">i</span><span class=\"mtk1\">&nbsp;=&nbsp;</span><span class=\"mtk7\">0</span><span class=\"mtk1\">;&nbsp;i&nbsp;&lt;&nbsp;</span><span class=\"mtk14\">prices</span><span class=\"mtk1\">.</span><span class=\"mtk14\">length</span><span class=\"mtk1\">;&nbsp;i++){</span></span></div><div style=\"top:376px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">if</span><span class=\"mtk1\">&nbsp;(prices[i]&nbsp;==&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">())&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">poll</span><span class=\"mtk1\">();</span></span></div><div style=\"top:399px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;</span><span class=\"mtk14\">Math</span><span class=\"mtk1\">.</span><span class=\"mtk11\">max</span><span class=\"mtk1\">(result,&nbsp;</span><span class=\"mtk14\">maxHeap</span><span class=\"mtk1\">.</span><span class=\"mtk11\">peek</span><span class=\"mtk1\">()&nbsp;-&nbsp;prices[i]);</span></span></div><div style=\"top:422px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:445px;height:23px;\" class=\"view-line\"><span><span></span></span></div><div style=\"top:468px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=\"mtk13\">return</span><span class=\"mtk1\">&nbsp;result;</span></span></div><div style=\"top:491px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div style=\"top:514px;height:23px;\" class=\"view-line\"><span><span class=\"mtk1\">}</span></span></div></div>\\n\\nThis was my first initial take where I had my current value and tried to find the max difference by comparing the FUTURE VALUES and that\\'s how I interpret the brute force solution by looking forward at all maximum differences. I was stuck for a few minutes on approach two, especially this code block if (prices[i] - minprice > maxprofit) because at first glance I saw that as knowing the future value and then knowing the overall min value, which didn\\'t make sense to me. Now I see the code working as the following, on my current day what was the smallest stock purchase price that proceeded me, find the difference between now and then. I now know I can buy on that day and sell today. A little counterintuitive and not how I think about in practical day to day terms. My first version runs O(n)log(n) with O(n) space. Hope this is helpful for those who need a good middle jumping step to get to the final solution."
                    },
                    {
                        "username": "sanshoys",
                        "content": "return Array.IndexOf(prices, prices.Max()) why is this not working?"
                    },
                    {
                        "username": "mdganapati",
                        "content": "Input: prices = [7,1,5,3,6,4]\\nOutput: 5\\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\\n\\nNow here \\n\\nbuy at 2nd day (1) and sell at 3rd day(5) so profit = 5-1 = 4;\\n\\nnext buy at 4th day(3) and sell on 5th day(6) so the profit = 6-3= 3\\n\\nso the total profit is 4+3 = 7;\\n\\nbut expected is 5 HOW COME ???????????? \\n\\n\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "mehrak205",
                        "content": "This is my code but it\\'s not working for all the cases .\\n\\nint maxProfit(vector<int>& prices) {\\n        if(prices.size()==1)\\n        return 0;\\n        int bs=INT_MAX;\\n        int ind=-1;\\n        int maxprofit=0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            if(prices[i]<bs){\\n                bs=prices[i];\\n                ind=i;\\n            }\\n        } \\n        for(int i=ind+1;i<prices.size();i++){\\n            if(prices[i]-bs>maxprofit)\\n            maxprofit=prices[i]-prices[ind];\\n        }\\n        return maxprofit;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "Consider the following array: `[3,2,6,5,0,3]`. The lowest price is `0` (on the 5th day), but if you buy at this day you wouldn\\'t make a profit because there\\'s no higher price after it. The maximum profit you can make is by buying at the 2nd day where the price is `2`, and selling at the 3rd day where the price is `6`, even though `2` isn\\'t the lowest price in the array. \\n\\nThe example illustrates the issue with your code: you cannot simply buy at the lowest price because it doesn\\'t guarantee the maximum profit. \\n\\nThe correct approach is:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    for (int i = 0; i < prices.size(); i++) {\\n        if (prices[i] < min_price) {\\n            min_price = prices[i];\\n        } else if (prices[i] - min_price > max_profit) {\\n            max_profit = prices[i] - min_price;\\n        }\\n    }\\n    return max_profit;\\n}\\n```\\n\\nThis code iterates over the `prices` array, keeping track of the smallest price seen so far, and updating the maximum profit whenever a larger profit is found.\\n"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It was really difficult until manage to solve by 6th submission, seeing actually how it is easy, brrr."
                    },
                    {
                        "username": "victorpichugov",
                        "content": "Additional explanation: profit in 2 example 0 because:\\n1) the minimum element is last\\n2) if the last element is the minimum, then you need to search for the minimum first to the minimum, i.e. arr[:len(arr) - 1] , but in the 2 example 7 > 6 > 4 > 3 > 1"
                    },
                    {
                        "username": "_vikash_kumar_",
                        "content": "EASY SOLUTION.......\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n=prices.length;\\n        int min=Integer.MAX_VALUE;\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(prices[i],min);\\n            diff=Math.max(diff,prices[i]-min);\\n        }\\n        return diff;\\n        \\n        \\n    }\\n}\\n"
                    },
                    {
                        "username": "bharti820",
                        "content": "step1: take starting index as lowprice and profit be 0 and initialize i=1\\nstep 2 while(i<:pricesSize)do step 3 to step 6\\nstep3 cost=prices[i]-lowprice\\nstep4 if(profit<cost)\\n     profit=cost\\nstep 5 if (lowprice>prices[i])\\nlowprice=prices[i]\\nstep 6 end of loop\\nstep 7 return profit\\n   "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nIterate through the prices array and keep track of the minimum price seen so far, and the maximum profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far.\n\nAt each iteration, calculate the difference between the current price and the minimum price seen so far, which gives the profit that can be obtained by selling the stock at the current price after buying it at the minimum price seen so far. Update the maximum profit obtained so far by taking the maximum of the current profit and the maximum profit obtained in the previous iterations. Update the minimum price seen so far by taking the minimum of the current price and the minimum price seen in the previous iterations.\n\nBy the end of the iteration, the maximum profit obtained is returned as the output of the function."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for Help:-\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2941124/thanks-to-striver-for-an-great-explanation/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1813656,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1813640,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1812308,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1811887,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1811691,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1811623,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1804275,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1803716,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1802339,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1799870,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez weekend I guess"
                    },
                    {
                        "username": "jga111",
                        "content": "You can do this in one pass. Keep track of your best time to buy stock. Keep track of your profits. "
                    },
                    {
                        "username": "tanmoysantra67",
                        "content": "class Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        min_price = prices[0]\\n        max_profit = 0\\n        \\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif price - min_price > max_profit:\\n                max_profit = price - min_price\\n        \\n        return max_profit\\n"
                    },
                    {
                        "username": "cagils",
                        "content": "A quick tip to get a single line solution in js using sliding windows approach:\\n```js\\nwhile (++r < length) if (prices[r] <= prices[l]) l = r; else *CALCULATE_MAX*\\n```"
                    },
                    {
                        "username": "david144",
                        "content": "Just think If I sell the stock in day n, then the max profit will equals today\\'s price minus minimum price from day 0 to day n."
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "What\\'s wrong with my approach(besides time complexity)?\\n ```javascript\\n    const tradeResults = [];\\n\\n    for (let i = 0; i<prices.length; i++) {\\n        let start = i;\\n        let end = prices.length - 1;\\n\\n        while (start <= end) {\\n            tradeResults.push(prices[end] - prices[start]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    return tradeResults.sort((a, b) => b - a)[0];\\n```"
                    },
                    {
                        "username": "parsa-sedigh",
                        "content": "The problem is I don\\'t consider all the possibilities together because of incrementing and decrementing the start and end simultaneously."
                    },
                    {
                        "username": "Dikshika_12",
                        "content": "for this question you must be familiar with prefix and suffix array \\n\\n in prefix array you will be storing the element minimum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your prefix array will look like prefix_array[7,5,5,1,1,1] i.e, minimum element till first index is 7 so we sotred it in the prefix_array then moving on minimum element till 2nd index is 5 and so on we will make the array.\\n\\n in suffix array you will be storing the element maximum till that index for \\ne.g the array is [7,5,8,1,3,4]\\nso your suffix  array will look like suffix_array [8,8,8,4,4,4] i.e, maximum element from last index is 4 so we stored it in the suffix_array then moving on maximum element till 2nd last index is 4 again because 3<4  so on we will make the array.\\nonce you make the array reverse it.\\n\\nnow itreate over the array and store the ans = suffix_array[i]-prefix_array[i],\\nmaxi  = max(maxi,ans);\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is correct and a great demonstration of using prefix and suffix arrays. However, it seems a bit over-complicated for this particular problem. Essentially, you\\'re trying to find the maximum difference between a pair of numbers in the array, where the smaller number comes before the larger one.\\n\\nAs a result, while your solution will certainly work, it also requires extra space to store the prefix and suffix arrays. Additionally, it involves a bit more computation than necessary since it computes the minimum value up to each index and the maximum value after each index, even though this isn\\'t strictly necessary to find the maximum profit.\\n\\nHere\\'s a simpler solution that accomplishes the same thing in O(n) time complexity and O(1) space complexity:\\n\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n    int min_price = INT_MAX;\\n    int max_profit = 0;\\n    \\n    for (int price : prices) {\\n        if (price < min_price) {\\n            min_price = price;\\n        } else if (price - min_price > max_profit) {\\n            max_profit = price - min_price;\\n        }\\n    }\\n    \\n    return max_profit;\\n}\\n```\\n\\nThis solution works by maintaining the minimum price seen so far and the maximum profit that can be made from selling at the current price. By updating these values as it iterates through the array, it ensures that it only considers selling prices that come after the minimum price it\\'s seen."
                    },
                    {
                        "username": "williamhergott",
                        "content": "Hey, when submitting my code I recieve \"time limit exceeded\" and the code is not approved, but I only used one for loop? Why is this the case? Thanks. (python 3)\\n\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        max_prof = 0\\n        \\n        for i in range(len(prices)):\\n            max_prof = max(max(prices[i:]) - prices[i], max_prof)\\n        \\n        return max_prof"
                    },
                    {
                        "username": "Vectorido",
                        "content": "I suppose, when you use max - this is some kind of loop, but built-in and not in python language. Anyway, 2 max\\'s have big complexity. I don\\'t know too how to manage with that. This is definitely not an EASY problem. "
                    },
                    {
                        "username": "voronokKita",
                        "content": "Raise the difficulty from easy to medium.\\nChange the Dynamic Programming tag to the Sliding Window."
                    },
                    {
                        "username": "_IshikaJain",
                        "content": "How to deal with Time Limit Exceeded issue ?"
                    }
                ]
            },
            {
                "id": 1794666,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1794647,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1793462,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1793435,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1793434,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1791443,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1790740,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1786557,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1785995,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1785664,
                "content": [
                    {
                        "username": "kumar_Gaurav_Shrivastav",
                        "content": "i\\'m new on leetcode. can anybody tell where can i get main() of program? "
                    },
                    {
                        "username": "mohamedazizjnayah",
                        "content": "the complexity of this code must be what????"
                    },
                    {
                        "username": "SKYWITCHERY",
                        "content": "please tell me why it isnt work \nC#\n` int[] prices = { 7, 1, 5, 3, 6, 4 };\n            int maxPrice = int.MinValue;\n            int minPrice = int.MaxValue;\n            int minIndex = 0;\n            int maxIndex = 0;\n            for (int i = 0; i < prices.Length + 1; i++)\n            {\n                if (prices[i] < minPrice)\n                {\n                    minPrice = prices[i];\n                    minIndex++;\n                }\n                if (prices[i] > maxPrice)\n                {\n                    maxPrice = prices[i];\n                    maxIndex++;\n                }\n                if (maxIndex < minIndex)\n                {\n                    prices[maxIndex] = prices[minIndex];\n                }\n            }\n            Console.WriteLine(maxPrice - minPrice); `"
                    },
                    {
                        "username": "AvtarS2k2",
                        "content": "This is TLE Please tell me why and also how to improve it. `your inline code...your inline code...`\\n\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sum = 0;\\n      for(int i=0;i<prices.size()-1;i++){\\nfor(int j=i+1;j<prices.size();j++){\\n    if(prices[j]>prices[i]){\\n        int newSum = prices[j]-prices[i];\\n        sum = max(sum,newSum);\\n    }else{\\n        continue;\\n    }\\n}\\n      }\\n      return sum;\\n    }\\n};"
                    },
                    {
                        "username": "khandalshivang2002",
                        "content": "in this problem we just maintain smallest element from left of ith element.\\nint maxProfit(vector<int>& prices) {\\n        int res=0;\\n        int sm=prices[0];\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(sm>prices[i]){\\n                sm=prices[i];\\n            }else if(prices[i]>sm){\\n                res=max(prices[i]-sm,res);\\n            }\\n        }\\n        return res;\\n    }"
                    },
                    {
                        "username": "Aastha_09",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n             int profit=0;\\n             for(int i=1;i<prices.length;i++){\\n                 if(prices[i] > prices[i-1])\\n                 profit += (prices[i]-prices[i-1]);\\n\\n              \\n             }\\n     return profit;  }\\n} \\n\\n\\nCan someone tell me what to do to make this code work?\\n"
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "This problem can also be solved using concept of greatest element on the right for every index. This way you will know what will be the maximum sell price for a buying price."
                    },
                    {
                        "username": "aryandsheth",
                        "content": "python"
                    },
                    {
                        "username": "thatslokesh1",
                        "content": "Input\\nprices =[2,4,1]\\n\\nOutput\\n0\\nExpected\\n2\\nsomeone  please  explain??"
                    },
                    {
                        "username": "ShaggyRobot",
                        "content": "You buy at 2, sell at 4. Max profit is 2."
                    },
                    {
                        "username": "s0me1",
                        "content": "I don\\'t understand why the input [1,2]  expected output is 1?"
                    },
                    {
                        "username": "Brian4755",
                        "content": "if you buy the product on day 1 (index 0, price is 1) and sell on day 2 (index 1, price is 2) your profit is 1"
                    }
                ]
            },
            {
                "id": 1783076,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1780811,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1778201,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1775385,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1775328,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1774233,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1764660,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1764204,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1763557,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1762249,
                "content": [
                    {
                        "username": "durveshpal538",
                        "content": "  int maxProfit(vector<int>& price) {\\n        int n = price.size();\\n        int profit=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]>price[i-1])\\n            {\\n                profit += (price[i]-price[i-1]);\\n            }\\n           \\n        }\\n        return profit;\\n    }"
                    },
                    {
                        "username": "mcnugets",
                        "content": "buggy test case prevents me from compiling a code, "
                    },
                    {
                        "username": "johny_racc00n",
                        "content": "Maybe you didnt notice, but in [7,1,5,3,6,4] you\\'ll get maximum profit when you\\'ll bye when its 7 and sell when it 1, am i wrong?\\n"
                    },
                    {
                        "username": "Sujan-Koirala021",
                        "content": "Its the opposite. You get maximum loss...."
                    },
                    {
                        "username": "juansymontano",
                        "content": "The problem I encountered with this code is I tried so hard to beat O(n).\\nWay easier if I just code it without thinking of complexity."
                    },
                    {
                        "username": "harsh_k112002",
                        "content": "Since this problem explanation is not clearly made in discussion section , I would like to show you an approach to solve the problem:-\\n1. First you have to make a cheap price, let it be first element of array,\\n2. You have to also find the maxprofit. so let it initially be zero.\\n3. Now we have to iterate through the loop and find an element from which if we subtract cheap, we get the maximum profit.\\n4. While iterating we have to do the following:\\n  1. If an element is less than cheap, we have to update the cheap value, so that we can get maxprofit.\\n  2. If an element is greater than  cheap, and element - cheap is greater than maxprofit, then update maxprofit to this new value of element-cheap. \\n3. Do this until the loop ends.\\n4. Now return the maximum profit you got.\\n\\nPlease Upvote if you like my approach.\\n \\n"
                    },
                    {
                        "username": "princethet",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit,i,j,buy=INT_MAX,sell=INT_MIN;\\n        int n= prices.size(),b_d;\\n\\n        for(i=0;i<n;i++){\\n            if(buy>prices[i]){ buy = prices[i];\\n                b_d = i;\\n                }\\n        }\\n\\n        if(b_d<n){\\n            for(j=b_d;j<n;j++){\\n                if(sell<prices[j]) sell = prices[j];\\n            }\\n            profit = sell-buy;\\n            return profit;\\n        }\\n\\n        else return 0;\\n\\n         \\n    }\\n};\\n\\ncan anyone modify this code according to question???"
                    },
                    {
                        "username": "karankumar560k",
                        "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n     int maxpro=0;\\n    int minprice=prices[0];\\n    for(int i=0;i<prices.size();i++)\\n    {\\n        minprice=min(minprice,prices[i]);\\n        maxpro=max(maxpro,prices[i]-minprice);\\n        if(prices[i]-minprice < 0)\\n        {\\n            minprice = prices[i];\\n        }\\n    }\\n        return maxpro; \\n    }\\n};"
                    },
                    {
                        "username": "RinkeshKumarSinha",
                        "content": "c++ solution but giving TLE please resolve !!!\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        vector<int>v=prices;\\n        int count=0;\\n        sort(v.begin(),v.end(),greater<int>());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]==prices[i])count++;\\n        }\\n        if(count==v.size())return 0;\\n        vector<int>G(prices.size()*prices.size());\\n        for(int i=prices.size()-1;i>0;i--){\\n            for(int j=i-1;j>=0;j--){\\n                int t_dex=prices[i]-prices[j];\\n                G.push_back(t_dex);\\n            }\\n        }\\n        sort(G.begin(),G.end(),greater<int>());\\n        for(int i=0;i<G.size();i++){\\n            if(G[i]>0)return G[i];\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "dogpoglog",
                        "content": "I don\\'t understand how my solution exceeds the time limit. \\n `        maxProfit = 0\\n      \\n          \\n        \\n        for x in range(len(prices)):\\n            cheapest = min(prices[:x+1])\\n            if prices[x] - cheapest > maxProfit:\\n                maxProfit = prices[x]-cheapest\\n        return maxProfit`\\nI thought this was an O(n) solution, but it always fails at case 199."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current approach is actually O(n^2), not O(n). This is because for each iteration of the loop (n iterations), you\\'re calling the `min()` function on a slice of the prices list. This operation itself takes O(n) time because in the worst case, it needs to look at each element in the slice. So, the overall time complexity is O(n) * O(n) = O(n^2).\\n\\nTo achieve an O(n) solution, you want to keep track of the minimum price found so far and the maximum profit found so far in a single pass through the list. Here\\'s a Python solution that demonstrates this:\\n\\n```python\\ndef maxProfit(prices):\\n    min_price = float(\\'inf\\')\\n    max_profit = 0\\n    for price in prices:\\n        min_price = min(min_price, price)\\n        profit = price - min_price\\n        max_profit = max(max_profit, profit)\\n    return max_profit\\n```\\nThis solution iterates through the list once, keeping track of the minimum price and maximum profit as it goes. At each step, it checks whether the current price is less than the minimum price found so far. If it is, the current price becomes the new minimum price. Then, it calculates the profit that could be made by buying at the minimum price and selling at the current price. If this profit is more than the maximum profit found so far, it becomes the new maximum profit. This approach gives you an O(n) time complexity and O(1) space complexity."
                    },
                    {
                        "username": "ashwinpatel0808",
                        "content": "Time limit exceeded after passing 198  test cases. how to optimize?\nI used only one for loop but used sort() and copy() inside it."
                    }
                ]
            },
            {
                "id": 1760881,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1760451,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1756340,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1752674,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1751046,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1749800,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1749490,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1748741,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1747151,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1745671,
                "content": [
                    {
                        "username": "johnnyboy1981",
                        "content": "I\\'m only starting out at this after an almost 20 year hiatus from CS, and I have to say this is the most fun problem I\\'ve done on leetcode yet!"
                    },
                    {
                        "username": "yaagmurss",
                        "content": "input : [3,2,6,5,0,3]\noutput : 4\nisn't 0 the smallest number?"
                    },
                    {
                        "username": "shivakumarkandra420",
                        "content": "you have to make max profit 1. if you buy at 0 and sell at 3 profit =3 2. if you buuy at 2 and sell at 6 profit = 4 that is the answer"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/best-time-to-buy-and-sell-stock-leet-code-121/"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Please note that short selling is not allowed in this Q !! :D"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Buy a stock when price is lowest and sell it when price is highest"
                    },
                    {
                        "username": "AliJavadov",
                        "content": "public static int maxProfit(int...prices) {\\n        int bestDay = 0;\\n        int bestProfit = 0;\\n        for (int i = 0; i < prices.length - 1; i++) {\\n            for (int j = i + 1; j < prices.length; j++) {\\n                if(Integer.valueOf(prices[j] - prices[i]) > bestProfit){\\n                    bestProfit = Integer.valueOf(prices[j] - prices[i]);\\n                    bestDay = j + 1;\\n\\n                }\\n            }\\n\\n        }\\n        return bestDay;\\n    }\\n\\n\\nIt\\'s my code, but in this case [1,2] and similar\\'s cases i have problems. Output :2 Expected : 1. what am i doing wrong?"
                    },
                    {
                        "username": "omjain",
                        "content": "you have to return max profit, not best day."
                    },
                    {
                        "username": "ghsatpute",
                        "content": "# Memory question \\n\\nI\\'ve two solutions \\n1. One has an additional array of equal to prices array i.e. O(n) extra space\\n2. Second one uses, three additional `int` variables i.e. O(1) extra spaces\\n\\nWhen I run both the programs, the first one says 53MB storage on leetCode while the second one says 56MB. How is this possible?"
                    },
                    {
                        "username": "ponharshita",
                        "content": "Someone tell me why is this not working for the 97th testcase but have passed all the previous testcases ?\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n\\n        int len = prices.length;\\n        int first = 0;\\n        int last = len - 1;\\n        int res = 0;\\n\\n        while(first < last){\\n            if(prices[first] > prices[last]){\\n                res = Math.max(res,prices[last] - prices[first]);\\n                first++;\\n            }\\n            else{\\n                res = Math.max(res,prices[last] - prices[first]);\\n                last--;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason this approach is not working for all test cases is due to the logic of how you\\'re trying to find the maximum profit. The maximum profit is not necessarily obtained from the difference of the first and last element in the array. Your approach assumes that we always need to consider the first and last elements in the array, and then compare the difference between the first element and the last element. If the first element is greater, then we move the pointer to the next one and vice versa.\\n\\nBut this approach is incorrect. In this problem, we want to find the maximum profit where the buying price (a smaller value) appears before the selling price (a larger value). Your approach doesn\\'t ensure this order. You may end up with a buying price that comes after the selling price.\\n\\nHere is the correct solution that scans from left to right and always tracks the minimum price (buying price) and calculates the profit if we sell at the current price.\\n\\n```java\\npublic class Solution {\\n    public int maxProfit(int prices[]) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int i = 0; i < prices.length; i++) {\\n            if (prices[i] < minprice)\\n                minprice = prices[i];\\n            else if (prices[i] - minprice > maxprofit)\\n                maxprofit = prices[i] - minprice;\\n        }\\n        return maxprofit;\\n    }\\n}\\n```\\n\\nThis ensures we always sell the stock after buying it and we maximize the profit."
                    },
                    {
                        "username": "Choubey_harsh",
                        "content": "\\nplz help what\\'s wrong with this code------\\nint maxProfit(vector<int>& prices) {\\n        int ansr=0,largest=0,n=prices.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                 ansr=prices[j]-prices[i];\\n            }\\n            if(ansr>largest){\\n                largest=ansr;\\n            }\\n            \\n        }\\n        return largest;\\n    }"
                    }
                ]
            },
            {
                "id": 1742562,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1742523,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1742514,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1739404,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1738875,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1733050,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1732900,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1729057,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1729035,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1729008,
                "content": [
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 6 Lines Solution || Beats 100% || Easy to Understand\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3001669/simple-java-6-lines-solution-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "aditya223307",
                        "content": "pls tell me what wrong with this approach?\\ncase1 and case2 rum but all test cases are not.\\n `int maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }`"
                    },
                    {
                        "username": "aditya223307",
                        "content": "can anyone pls tell me what wrong with this approach?\\ncase1 and case2 run but all test cases are not correct.\\nint maxProfit(vector<int>& prices) {\\n       auto it = minmax_element(prices.begin(), prices.end());\\n       int min_index = distance(prices.begin(), it.first);\\n       int max_element = prices[min_index];\\n       for(int i=min_index; i<=prices.size()-min_index; i++){\\n           max_element= max(max_element, prices[i]);\\n       }\\n       if(prices[min_index] == max_element){\\n           return 0;\\n       }else{\\n           return max_element - prices[min_index];\\n       }\\n    }"
                    },
                    {
                        "username": "HinaKiran",
                        "content": "Ok so, i just want to reconfirm if i am getting the problem right or not because most of the test cases are passed but i am stuck at test case 102.\\nso it has an input of [2,4,1].\\nas long as i understood the problem is that it will check for the minimum number. here the smallest number is 1 and after that number index it will start searching for the biggest number and then it will just subtract and returns the answer. but if the smallest number is at the last index then it will return 0 then wht am i getting the wrong answer popup and here it says that expected answer is 2.\\ni dont know what is wrong with my code.\\nits in c# ..\\nwritng it down here so that someone can point it out.\\npublic int SingleNumber(int[] nums)\\n        {\\n            int max = nums[0];\\n            int min = nums[0];\\n            int index = 0;\\n            int minIndex = 0;\\n            int maxIndex = 0;\\n            for (int i=1;i<nums.Length;i++)\\n            {\\n                if (min > nums[i])\\n                {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if (minIndex == nums.GetUpperBound(0))\\n            {\\n                return 0;\\n            }\\n            for(int j=minIndex; j<=nums.Length; j++)\\n            {\\n                if(j+1 <= nums.GetUpperBound(0))\\n                {\\n                    if (nums[j] < nums[j + 1])\\n                    {\\n                        max = nums[j + 1];\\n                        maxIndex = j + 1;\\n                    }\\n                    else\\n                    {\\n                        max = nums[j];\\n                        maxIndex = j;\\n                    }\\n                }\\n                if (j + 1 > nums.GetUpperBound(0))\\n                {\\n                    return index = nums[maxIndex] - nums[minIndex];\\n                }\\n\\n            }\\n            return index = nums[maxIndex] - nums[minIndex];\\n        }"
                    },
                    {
                        "username": "JCPrice0024",
                        "content": "The problem isn\\'t looking for the minimum buy price it\\'s looking for the maximum sell price. So in this case 4-2 = 2."
                    },
                    {
                        "username": "rashmi_jain18",
                        "content": "Wondering for the below example given in question, how max profit is 5? It should be 7 - if I buy stock on day2 i.e 1 and sell it on day3 at price 5. Again I buy stock on day4 at price 3 and sell on day5 at price 6. Total profit will be (5-1)+(6-3)=7\\nInput: prices = [7,1,5,3,6,4]\\nOutput: 5"
                    },
                    {
                        "username": "vinaykrishna",
                        "content": "should buy stock only once"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You can buy stocks atmost once"
                    },
                    {
                        "username": "sharadhachelka",
                        "content": "Could someone explain about buy price and sell price how to take?"
                    },
                    {
                        "username": "siddharthaverma6213",
                        "content": "       int profit = 0 ;\\n       for(int i =1 ; i<prices.size() ;i++){\\n     if(prices[i]>prices[i-1]) profit = profit + (prices[i] - prices[i-1]) ;\\n       } \\n     return profit ; \\n\\n\\nwhat is the problem with this code ? can somebody explain ?"
                    },
                    {
                        "username": "Beyond_Multiverse",
                        "content": "You\\'re comparing only consecutive days"
                    },
                    {
                        "username": "GeetMukherjee",
                        "content": "C++\\n\\nint maxProfit(vector<int>& prices) {\\n        int maxProfit = 0;\\n        int buy = prices[0];\\n        int n = prices.size();\\n\\n        if(n==2 && prices[1]>prices[0]){\\n            return prices[1]-prices[0];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            buy = min(buy, prices[i]);\\n            maxProfit = max(maxProfit, prices[i]-buy);\\n        }\\n        return maxProfit;\\n    }"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "int maxProfit = -1e9 ;\\n            int minPrice = prices[0] ;\\n            for(int i = 0 ; i < prices.size() ; i++)\\n            {\\n                if(prices[i]-minPrice > maxProfit)\\n                {\\n                    maxProfit = prices[i] - minPrice ;\\n                }\\n                minPrice = min(minPrice , prices[i]);\\n            }\\n            return maxProfit ;\\n"
                    },
                    {
                        "username": "AKASHKUMARSINGH",
                        "content": "class Solution \\n{\\n    public:\\n        int maxProfit(vector<int>& prices) \\n        {\\n            int n = prices.size();\\n            int maxProfit = -1e9  ;\\n            vector<int>aux1(n);\\n            for(int i = n-1 ; i >= 0 ; i--)\\n            {\\n                aux1[i] = max(maxProfit , prices[i]);\\n                if(maxProfit < prices[i])\\n                {\\n                    maxProfit = prices[i] ;\\n                }\\n            }\\n            int maxDifference = -1e9 ;\\n            for(int i = 0 ; i < n ; i++)\\n            {\\n                int diff = aux1[i] - prices[i] ;\\n                if(diff > maxDifference)\\n                {\\n                    maxDifference = diff ;\\n                }\\n            }\\n            return maxDifference ;\\n        }\\n};"
                    }
                ]
            },
            {
                "id": 1725546,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1722068,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1721400,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1720382,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1716430,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1716278,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1715363,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1708656,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1708235,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1708004,
                "content": [
                    {
                        "username": "Siddharth_Sahu",
                        "content": "Someone please tell why this is not working on the site, it works fine on VS code\\n\\n#include <iostream>\\n#include <vector>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n\\n        int min = prices[0];\\n        int minpos;\\n        int ans;\\n\\n        for (int i = 0; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] < min)\\n            {\\n                min = prices[i];\\n                minpos = i;\\n            }\\n        }\\n        int max = min;\\n        \\n        for (int i = minpos; i < prices.capacity(); i++)\\n        {\\n            if (prices[i] > max)\\n            {\\n                max = prices[i];\\n                \\n            }\\n            \\n        }\\n        ans = max - min;\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\nint main()\\n{\\n    Solution s1;\\n    vector<int> prices = {7, 1, 5, 3, 6, 4};\\n    cout << s1.maxProfit(prices);\\n    return 0;\\n}"
                    },
                    {
                        "username": "lucyrliu",
                        "content": "My code is basically the same as the first Java solution leetcode provided, but whenever I try to submit it it says Time Limit Exceeded. How should I fix it?"
                    },
                    {
                        "username": "BOOMER0641",
                        "content": "i dont understand the question"
                    },
                    {
                        "username": "vasiltsvetkov20",
                        "content": "\npublic class Solution {\n\n    public int MaxProfit(int[] prices) {\n\n            Stack<int> stack = new Stack<int>();\n\n            int maxProfit = int.MinValue;\n\n            for (int i = 0; i < prices.Length; i++)\n            {\n                for (int j = i + 1; j < prices.Length; j++)\n                {\n                    stack.Push(prices[i]);\n\n                    if (- stack.Peek() + prices[j] > maxProfit)\n                    {\n                        maxProfit = - stack.Pop() + prices[j];\n                    }\n                }\n            }\n\n            return maxProfit > 0 ? maxProfit : 0;\n    }\n}\n\nCan someone tell me why the code above has a runtime error 'Out of memory' and how to fix it?"
                    },
                    {
                        "username": "joyifei",
                        "content": "one pitfall I always fall into is,  trying to calculate more information than required. as this problem I think we need to get the date of buying and selling to determine how to get max profit. "
                    },
                    {
                        "username": "simarpalSingh",
                        "content": " \\ndef maxProfit(self, arr: List[int]) -> int:\\n        sm = arr[0]\\n        max = 0\\n        lr = 0\\n        if len(arr) == 0: return 0\\n        for i in range (1, len(arr)):\\n            if arr[i] > lr:\\n                lr = arr[i]\\n                max = max if max > lr-sm else lr-sm\\n            if arr[i] < sm:\\n                sm = arr[i]\\n                lr = 0\\n        return max  \\n"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "class Solution {\\n    public int maxProfit(int[] price) {\\n    int buyPrice=Integer.MAX_VALUE;\\n    int max=0;\\n    int i=0;\\n    if(price.length-1==0)return 0;\\n   \\n    \\n    while(i<price.length)\\n    {\\n        if(buyPrice<price[i])\\n        {\\n            int profit = price[i]-buyPrice;\\n             max=Math.max(max,profit);\\n        }\\n        else\\n        {\\n            buyPrice=price[i];\\n        }\\n        i++;\\n    }\\n    return max;\\n        \\n    }\\n}[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "ashvinPitukun",
                        "content": "pre computation technique is useful here."
                    },
                    {
                        "username": "emti_19",
                        "content": "Why I am getting Time Limit Exceeded here?\\n\\n `\\nint n = prices.size()-1;\\n        int minn = INT_MAX, maxx = INT_MIN;\\n        int i=0,j=n;\\n        while(i<j){\\n            if(prices[i]<minn)\\n                minn = prices[i++];\\n            if(prices[j]>maxx)\\n                maxx = prices[j--];\\n        }\\n        if(maxx-minn>0) return maxx-minn;\\n        else return 0;\\n`"
                    },
                    {
                        "username": "user1799vO",
                        "content": "That is how I understand/digest the one pass approach. Just think yourself as a some one who can change mind at will. \\n\\nint maxProfit(int* prices, int pricesSize)\\n{\\n    /* You buy the stock at day 1 at whatever price. This is ok since you\\n        can change your mind later.  And this is minimal price so far. */  \\n    int min_price = prices[0];     \\n    int max_profit  = 0;   // No profit at day one.\\n    int i;\\n\\n    for(i = 1; i < pricesSize; i++) {\\n        if(prices[i] < min_price) {\\n            /* As days go by. You see a cheaper price. You are kind of regret that\\n               you bought at higher price. But there is nothing you can do other\\n              than recording the minimal price. */\\n            min_price = prices[i];\\n        } else {\\n            if(prices[i] - min_price > max_profit)\\n               /* Now you see a higher price such that  if you sell today and \\n                   bought at the recorded minimal price you will make more profit. \\n                   You immediately changed your mind  :-) */\\n                max_profit = prices[i] - min_price;\\n        }\\n    }\\n\\n    return max_profit;\\n}"
                    }
                ]
            },
            {
                "id": 1702996,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1702080,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1700932,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1700252,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1700172,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1700098,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1699805,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1696716,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1690936,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1686853,
                "content": [
                    {
                        "username": "Azmankhan",
                        "content": " int maxi = 0; //taking maximum 0\\n      int minimum = prices[0];  // choosing the first element of array as minimum \\n      for (int i=0; i< prices.size(); i++ ){\\n          minimum  = min(minimum ,prices[i]); //calculating the minimum \\n          maxi  = max(maxi ,prices[i] - minimum );  //subtracting the the i form minimum as taking maximum bw both \\n      }\\n      return maxi; //returning the maximum \\n    }"
                    },
                    {
                        "username": "indranil_123",
                        "content": "getting TLE on this, any suggestions ?\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n      int profit=0;\\n      for(int i=0;i<prices.size();i++) {\\n          for(int k=i+1;k<prices.size();k++) {\\n              if(prices[k]-prices[i]>profit) {\\n                  profit=prices[k]-prices[i];\\n              }\\n          }\\n      }\\n      return profit;  \\n    }\\n};"
                    },
                    {
                        "username": "jeelanbashaismgk786",
                        "content": "#Best Time to Buy and Sell Stock\\n`class Solution(object):\\n    def maxProfit(self, prices):\\n        maxP=0        \\n        if len(prices) !=0:\\n            for i in range(0,len(prices)):\\n                for j in range(i+1, len(prices)):\\n                    # print(l[i], l[j])\\n                    if prices[i]<prices[j]:\\n                        if prices[j]-prices[i] >maxP:\\n                            maxP=prices[j]-prices[i]\\n        return maxP`\\ni have written this program , but it doesnot pass the total number of testcase\\nin testcase 198 not sure about the input values \\nerror comes ->Time Limit Exceeded\\ncan anybody help please"
                    },
                    {
                        "username": "Geronim",
                        "content": "The following code I\\'ve come up with passes all tests except the one. What\\'s wrong with it? I can\\'t guess the solution.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) > 1:\\n            # minPrice, minIdx = min(prices), prices.index(min(prices))\\n            minPrice, minIdx = min(prices[:-1]), prices[:-1].index(min(prices[:-1]))\\n            maxPrice, maxIdx = max(prices[1:]), 1 + prices[1:].index(max(prices[1:]))\\n        else:\\n            return 0\\n\\n        remPricesMin = prices[minIdx:]\\n        maxPriceMin = max(remPricesMin) if len(remPricesMin) > 0 else minPrice\\n        diff1 = maxPriceMin - minPrice\\n        \\n        remPricesMax = prices[:maxIdx]\\n        minPriceMax = min(remPricesMax) if len(remPricesMax) > 0 else maxPrice\\n        diff2 = maxPrice - minPriceMax\\n\\n        diff = max(diff1, diff2)\\n\\n        if diff > 0:\\n            return diff\\n        else:\\n            return 0\\n```"
                    },
                    {
                        "username": "problemsX",
                        "content": " why test case  prices=[1,2] expected 1, when logically if a person buys on the first day he will sell the items on the second day which the expected should be 2"
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit \\nBuy first day at 1 and Sell on second day 2 \\nso you bought a stock for 1 GBP and selling it to 2 GBP \\nProfit ( 2-1=1 GBP)"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "in test case prices =\\n[1,4,2]; \\n\\nExpected output is 3. But how???? output must be 2 as if we buy on day 1 and sell on day 2 then we have maximum profit."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day at 4\\nso you bought a stock for 1 GBP and selling it to 4 GBP\\nProfit ( 4-1=3 GBP)\\n\\n******Maximum profit*****"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "this is my apprach\\n`class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int currprice=INT_MAX,bestprice=0,op=0;\\n        for(int i=0 ; i<prices.size();i++){\\n            if(currprice > prices[i]){\\n                currprice=prices[i];\\n            }\\n                bestprice=prices[i]-currprice;\\n            if(op<bestprice){\\n                op=bestprice;\\n            }\\n            \\n        }return op;\\n    }\\n};`"
                    },
                    {
                        "username": "Biswajit_sahoo",
                        "content": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int max=0;\\n        int profit =0;\\n        for(int i=0 ; i<prices.length ;i++)\\n        {\\n            for(int j=i+1 ; j<prices.length ;j++)\\n            {\\n                if(prices[j]<prices[i])\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    profit= prices[j]- prices[i];\\n                }\\n                if(profit>max)\\n                {\\n                    max = profit;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n\\n\\nMy code is showing timeout error ."
                    },
                    {
                        "username": "aanchal9580",
                        "content": "how to resolve the time exceeded issue? Mine fails at 201th test case with a large array"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/2822579/easy-c-o-n-soln-faang-interview-optimized-code/\\n"
                    }
                ]
            },
            {
                "id": 1686296,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1684355,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1683906,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1682811,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1676663,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1672220,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1669249,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1656293,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1651214,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1637206,
                "content": [
                    {
                        "username": "Kishore-Thalisetty",
                        "content": "\\nJAVA SOLUTION - (O(N)) time complexity\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n       int buy=prices[0];\\n        int sell=0;\\n        int max=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(buy>prices[i]){\\n                buy=prices[i];\\n\\n            }else if(buy<prices[i] ){\\n                sell=prices[i]-buy;\\n                if(max<sell) max=sell;\\n            }\\n        }\\n           return max;\\n    }\\n}"
                    },
                    {
                        "username": "apeWithKeyBoard",
                        "content": "I have written basic O(n\\'squared) solution but the 203 testcase fails with Time Limit exceeded ouput. Any suggestions ?\\n"
                    },
                    {
                        "username": "Aman_26",
                        "content": "Whats wrong with this code?\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        minimum_num = min(prices)\\n        index_min = prices.index(minimum_num)\\n        if index_min != n:\\n            prices = prices[index_min+1:]\\n            if len(prices) != 0:\\n                max_num = max(prices)\\n            else:\\n                max_num = 0\\n                if max_num > minimum_num:\\n                    return max_num - minimum_num\\n                else:\\n                    return 0\\n        return max_num - minimum_num\\n\\nit fails for the input [2,4,1], expected output is 2 my output is 0"
                    },
                    {
                        "username": "MuthuKrishnan007",
                        "content": "Hi,\\nCan anyone explain what is the requirements of the program clearly because in the first example input 715364 day 2 stock is buyed and sell in day 5 .\\nIn example 2 76431 in this example transaction is zero why can\\'t didn\\'t buy any stock.\\nAnyone please explain this."
                    },
                    {
                        "username": "arurahul16",
                        "content": "you need to read the problem , it says profit\\nBuy first day at 1 and Sell on second day 2\\nso you bought a stock for 1 GBP and selling it to 2 GBP\\nProfit ( 2-1=1 GBP)\\n\\nMAKE SURE  **MAXIMUM PROFIT***"
                    },
                    {
                        "username": "Amit_Joe",
                        "content": "only test case with having input 1,2 doesnt work the program is still to produce expected output in local machine. why??"
                    },
                    {
                        "username": "braads07",
                        "content": "[CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?](CAN SOMEONE PLS..HELP ME , WHERE M I WRONG?\\nCan we find the solution in this way?)\\n\\n  `class Solution {\\npublic:\\n    int maxProfit(vector<int>& v) {\\n\\n        vector<int>v1=v;\\n        sort(v1.begin() , v1.end());\\n        int num=0;\\n        int n=v.size();\\n        int front=0;\\n        int end=v.size()-1;\\n        int maxx=INT_MIN;\\n        while(num!=n)\\n        {\\n            int i=search(v , 0 , n-1 ,  v1[front]);\\n            int j=search(v , 0 , n-1 ,  v1[end]);\\n            if(i<j)\\n            {\\n                maxx=max(maxx , (v1[end]-v1[front]));\\n                end=v.size()-1;\\n                front++;\\n                num++;\\n            }\\n            else if(front==end)\\n            {\\n                front++;\\n                end=v.size()-1;\\n                num++;\\n            }\\n            else\\n            {\\n                end--;\\n            }\\n        }\\n        if(maxx<=0)\\n        return 0;\\n        else \\n        return maxx;\\n\\n        \\n    }\\n    int search(vector<int>arr , int l , int r , int x)\\n    {\\n         if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n\\n        if (arr[mid] == x)\\n            return mid;\\n \\n        // If element is smaller than mid, then\\n        // it can only be present in left subarray\\n        if (arr[mid] > x)\\n            return search(arr, l, mid - 1, x);\\n \\n        // Else the element can only be present\\n        // in right subarray\\n        return search(arr, mid + 1, r, x);\\n    }\\n    return -1;\\n    }\\n\\n\\n};`"
                    },
                    {
                        "username": "codernoob",
                        "content": "how are ppl doing the very large test array input? I am getting Time Limit Exceeded"
                    },
                    {
                        "username": "user3827xr",
                        "content": "In this problem, can we consider prices are positive numbers ? (remember, 2020 and negative prices of crude oil)"
                    },
                    {
                        "username": "arurahul16",
                        "content": "read problem properly ranges for prices[i] are mentioned from 0"
                    },
                    {
                        "username": "MeriemA",
                        "content": "Hello, \n\nI have tried to solve this problem using C. My solution works for almost all of the TCs. But the problem is that it shows time limit exceeded when the input is so large. So can anyone can help me to optimize my code?\nThanks a lot.\n\n `int maxProfit(int* prices, int pricesSize)\n{   \n    int buy_day = 0;\n    int sell_day = 0;\n    int max_profit = 0;\n    int profit = 0;\n\n    for (buy_day = 0; buy_day<pricesSize; buy_day++)\n    {\n        sell_day = buy_day + 1;\n        for(sell_day; sell_day<pricesSize; sell_day++)\n        {\n            profit = prices[sell_day] - prices[buy_day];\n            if (profit > max_profit)\n            {\n                max_profit = profit;\n            }\n        }\n    }\n\nreturn max_profit;\n}`\n\n"
                    },
                    {
                        "username": "alangreg",
                        "content": "[@MeriemA](/MeriemA) Probably. Thats why times out on large TC. I also striked out few times on time limit but then I changed approach to 1 loop (well 1 and a half as I used built in max() function) and it passed."
                    },
                    {
                        "username": "MeriemA",
                        "content": "[@alangreg](/alangreg) Thank you for you reply. Actually, the second loop won\\'t run over all of the table but only a part of it starting from a predefined index. So here I guess the time complexity is O(nlogn) not O(n\\xB2). right?"
                    },
                    {
                        "username": "alangreg",
                        "content": "The first thing I noticed is you are running with two loops."
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "Can Anyone tell why time limit exceeding here:\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int profit =0;\\n        for(int i=0;i<prices.size()-1;i++){\\n            for(int j=i+1;j<prices.size();j++){\\n                if(prices[i]<prices[j]){\\n                int temp= prices[j]-prices[i];\\n                profit= max(profit, temp);\\n                }\\n            }   \\n        }\\n        return profit;\\n    }\\n};"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n          int n = prices.length;\\n        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\\n        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\n            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\\n            // dp[i][1] = max(dp[i-1][1], -prices[i])\\n            dp_i_1 = Math.max(dp_i_1, -prices[i]);\\n        }\\n        return dp_i_0; \\n    }\\n}\\n\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Exclusive Time of Functions",
        "question_content": "<p>On a <strong>single-threaded</strong> CPU, we execute a program containing <code>n</code> functions. Each function has a unique ID between <code>0</code> and <code>n-1</code>.</p>\n\n<p>Function calls are <strong>stored in a <a href=\"https://en.wikipedia.org/wiki/Call_stack\">call stack</a></strong>: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is <strong>the current function being executed</strong>. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.</p>\n\n<p>You are given a list <code>logs</code>, where <code>logs[i]</code> represents the <code>i<sup>th</sup></code> log message formatted as a string <code>&quot;{function_id}:{&quot;start&quot; | &quot;end&quot;}:{timestamp}&quot;</code>. For example, <code>&quot;0:start:3&quot;</code> means a function call with function ID <code>0</code> <strong>started at the beginning</strong> of timestamp <code>3</code>, and <code>&quot;1:end:2&quot;</code> means a function call with function ID <code>1</code> <strong>ended at the end</strong> of timestamp <code>2</code>. Note that a function can be called <b>multiple times, possibly recursively</b>.</p>\n\n<p>A function&#39;s <strong>exclusive time</strong> is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for <code>2</code> time units and another call executing for <code>1</code> time unit, the <strong>exclusive time</strong> is <code>2 + 1 = 3</code>.</p>\n\n<p>Return <em>the <strong>exclusive time</strong> of each function in an array, where the value at the </em><code>i<sup>th</sup></code><em> index represents the exclusive time for the function with ID </em><code>i</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/05/diag1b.png\" style=\"width: 550px; height: 239px;\" />\n<pre>\n<strong>Input:</strong> n = 2, logs = [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]\n<strong>Output:</strong> [3,4]\n<strong>Explanation:</strong>\nFunction 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\nFunction 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\nFunction 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;]\n<strong>Output:</strong> [8]\n<strong>Explanation:</strong>\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls itself again.\nFunction 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\nFunction 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;]\n<strong>Output:</strong> [7,1]\n<strong>Explanation:</strong>\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls function 1.\nFunction 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\nFunction 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\nSo function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= logs.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= function_id &lt; n</code></li>\n\t<li><code>0 &lt;= timestamp &lt;= 10<sup>9</sup></code></li>\n\t<li>No two start events will happen at the same timestamp.</li>\n\t<li>No two end events will happen at the same timestamp.</li>\n\t<li>Each function has an <code>&quot;end&quot;</code> log for each <code>&quot;start&quot;</code> log.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 153497,
                "title": "java-solution-using-stack-wrapper-class-and-calculation-when-pop-element-from-the-stack",
                "content": "* Extract the log parsing logic as a inner class.\\n* Calculate the function\\'s running time when encounter an \"end\" log entry. If current ended func has a main func still running (in the stack), substract the running time advance. So we **don\\'t need** to use a \"prev\" variable.\\n* Another idea is using a field in the inner class to track the real running time for a function. I believe this way would be the most straightforward for myself.\\n* Both methods follows the O(n) time complexiy, and O(n/2) extra space consumption.\\n\\nMethod 1\\n``` JAVA\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Deque<Log> stack = new ArrayDeque<>();\\n        int[] result = new int[n];\\n        for (String content : logs) {\\n            Log log = new Log(content);\\n            if (log.isStart) {\\n                stack.push(log);\\n            } else {\\n                Log top = stack.pop();\\n                result[top.id] += (log.time - top.time + 1);\\n                if (!stack.isEmpty()) {\\n                    result[stack.peek().id] -= (log.time - top.time + 1);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static class Log {\\n        public int id;\\n        public boolean isStart;\\n        public int time;\\n        \\n        public Log(String content) {\\n            String[] strs = content.split(\":\");\\n            id = Integer.valueOf(strs[0]);\\n            isStart = strs[1].equals(\"start\");\\n            time = Integer.valueOf(strs[2]);\\n        }\\n    }\\n}\\n```\\n\\nMethod 2\\n``` JAVA\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Deque<Log> stack = new ArrayDeque<>();\\n        int[] result = new int[n];\\n        int duration = 0;\\n        for (String content : logs) {\\n            Log log = new Log(content);\\n            if (log.isStart) {\\n                stack.push(log);\\n            } else {\\n                Log top = stack.pop();\\n                result[top.id] += (log.time - top.time + 1 - top.subDuration);\\n                if (!stack.isEmpty()) {\\n                    stack.peek().subDuration += (log.time - top.time + 1);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static class Log {\\n        public int id;\\n        public boolean isStart;\\n        public int time;\\n        public int subDuration;\\n        \\n        public Log(String content) {\\n            String[] strs = content.split(\":\");\\n            id = Integer.valueOf(strs[0]);\\n            isStart = strs[1].equals(\"start\");\\n            time = Integer.valueOf(strs[2]);\\n            subDuration = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` JAVA\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Deque<Log> stack = new ArrayDeque<>();\\n        int[] result = new int[n];\\n        for (String content : logs) {\\n            Log log = new Log(content);\\n            if (log.isStart) {\\n                stack.push(log);\\n            } else {\\n                Log top = stack.pop();\\n                result[top.id] += (log.time - top.time + 1);\\n                if (!stack.isEmpty()) {\\n                    result[stack.peek().id] -= (log.time - top.time + 1);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static class Log {\\n        public int id;\\n        public boolean isStart;\\n        public int time;\\n        \\n        public Log(String content) {\\n            String[] strs = content.split(\":\");\\n            id = Integer.valueOf(strs[0]);\\n            isStart = strs[1].equals(\"start\");\\n            time = Integer.valueOf(strs[2]);\\n        }\\n    }\\n}\\n```\n``` JAVA\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Deque<Log> stack = new ArrayDeque<>();\\n        int[] result = new int[n];\\n        int duration = 0;\\n        for (String content : logs) {\\n            Log log = new Log(content);\\n            if (log.isStart) {\\n                stack.push(log);\\n            } else {\\n                Log top = stack.pop();\\n                result[top.id] += (log.time - top.time + 1 - top.subDuration);\\n                if (!stack.isEmpty()) {\\n                    stack.peek().subDuration += (log.time - top.time + 1);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static class Log {\\n        public int id;\\n        public boolean isStart;\\n        public int time;\\n        public int subDuration;\\n        \\n        public Log(String content) {\\n            String[] strs = content.split(\":\");\\n            id = Integer.valueOf(strs[0]);\\n            isStart = strs[1].equals(\"start\");\\n            time = Integer.valueOf(strs[2]);\\n            subDuration = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105100,
                "title": "python-straightforward-with-explanation",
                "content": "We examine two approaches - both will be stack based.\\n\\nIn a more conventional approach, let's look between adjacent events, with duration ```time - prev_time```.  If we started a function, and we have a function in the background, then it was running during this time.  Otherwise, we ended the function that is most recent in our stack.\\n```\\ndef exclusiveTime(self, N, logs):\\n    ans = [0] * N\\n    stack = []\\n    prev_time = 0\\n\\n    for log in logs:\\n        fn, typ, time = log.split(':')\\n        fn, time = int(fn), int(time)\\n\\n        if typ == 'start':\\n            if stack:\\n                ans[stack[-1]] += time - prev_time \\n            stack.append(fn)\\n            prev_time = time\\n        else:\\n            ans[stack.pop()] += time - prev_time + 1\\n            prev_time = time + 1\\n\\n    return ans\\n```\\n\\n<hr>\\n\\nIn the second approach, we try to record the \"penalty\" a function takes.  For example, if function 0 is running at time [1, 10], and function 1 runs at time [3, 5], then we know function 0 ran for 10 units of time, less a 3 unit penalty.  The idea is this: **Whenever a function completes using T time, any functions that were running in the background take a penalty of T.**  Here is a slow version to illustrate the idea:\\n\\n```\\ndef exclusiveTime(self, N, logs):\\n    ans = [0] * N\\n    #stack = SuperStack()\\n    stack = []\\n\\n    for log in logs:\\n        fn, typ, time = log.split(':')\\n        fn, time = int(fn), int(time)\\n\\n        if typ == 'start':\\n            stack.append(time)\\n        else:\\n            delta = time - stack.pop() + 1\\n            ans[fn] += delta\\n            #stack.add_across(delta)\\n            stack = [t+delta for t in stack] #inefficient\\n\\n    return ans\\n```\\n\\nThis code already ACs, but it isn't efficient.  However, we can easily upgrade our stack to a \"superstack\" that supports ```self.add_across```: addition over the whole array in constant time.\\n\\n```\\nclass SuperStack(object):\\n    def __init__(self):\\n        self.A = []\\n    def append(self, x):\\n        self.A.append([x, 0])\\n    def pop(self):\\n        x, y = self.A.pop()\\n        if self.A:\\n            self.A[-1][1] += y\\n        return x + y\\n    def add_across(self, y):\\n        if self.A:\\n            self.A[-1][1] += y\\n```",
                "solutionTags": [],
                "code": "```time - prev_time```\n```\\ndef exclusiveTime(self, N, logs):\\n    ans = [0] * N\\n    stack = []\\n    prev_time = 0\\n\\n    for log in logs:\\n        fn, typ, time = log.split(':')\\n        fn, time = int(fn), int(time)\\n\\n        if typ == 'start':\\n            if stack:\\n                ans[stack[-1]] += time - prev_time \\n            stack.append(fn)\\n            prev_time = time\\n        else:\\n            ans[stack.pop()] += time - prev_time + 1\\n            prev_time = time + 1\\n\\n    return ans\\n```\n```\\ndef exclusiveTime(self, N, logs):\\n    ans = [0] * N\\n    #stack = SuperStack()\\n    stack = []\\n\\n    for log in logs:\\n        fn, typ, time = log.split(':')\\n        fn, time = int(fn), int(time)\\n\\n        if typ == 'start':\\n            stack.append(time)\\n        else:\\n            delta = time - stack.pop() + 1\\n            ans[fn] += delta\\n            #stack.add_across(delta)\\n            stack = [t+delta for t in stack] #inefficient\\n\\n    return ans\\n```\n```self.add_across```\n```\\nclass SuperStack(object):\\n    def __init__(self):\\n        self.A = []\\n    def append(self, x):\\n        self.A.append([x, 0])\\n    def pop(self):\\n        x, y = self.A.pop()\\n        if self.A:\\n            self.A[-1][1] += y\\n        return x + y\\n    def add_across(self, y):\\n        if self.A:\\n            self.A[-1][1] += y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105103,
                "title": "c-o-n-stack-with-explaination",
                "content": "The idea is simple everytime we see a start, we just push it to the stack. Now when we reach an end, we are guaranteed that the top of the stack is a start with the same id as the current item because all completed start/ends in between this start and end has been removed already. We just add current item timestamp - stack top timestamp + 1 to times[i].\\n\\nSo for example\\n[..., {0:start:3}] and item = {0:end:6} we add 6 - 3 + 1\\n\\nHowever, what if there are function calls in between the start and end of the function of id 0? We can account for this by subtracting the length of the function calls in between the function id 0 whenever we complete an inner function marked by an end.\\n\\n[..., {0:start:3}, {2:start:4}]  and item = {2:end:5} so we increment times[2] by curr_length = 5 - 4 + 1 = 2 and then we subtract times[0] by curr_length as it takes up that amount of time out of the total time\\n\\nSo whenever we see an end, we have to make sure to subtract our curr_length to whatever function is enclosing it if it exists.\\n\\n```\\n#include <iostream>\\n#include <vector>\\n#include <stack>\\n#include <sstream>\\n#include <cassert>\\n\\nusing namespace std;\\n\\nstruct Log {\\n    int id;\\n    string status;\\n    int timestamp;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> times(n, 0);\\n        stack<Log> st;\\n        for(string log: logs) {\\n            stringstream ss(log);\\n            string temp, temp2, temp3;\\n            getline(ss, temp, ':');\\n            getline(ss, temp2, ':');\\n            getline(ss, temp3, ':');\\n\\n            Log item = {stoi(temp), temp2, stoi(temp3)};\\n            if(item.status == \"start\") {\\n                st.push(item);\\n            } else {\\n                assert(st.top().id == item.id);\\n\\n                int time_added = item.timestamp - st.top().timestamp + 1;\\n                times[item.id] += time_added;\\n                st.pop();\\n\\n                if(!st.empty()) {\\n                    assert(st.top().status == \"start\");\\n                    times[st.top().id] -= time_added;\\n                }\\n            }\\n        }\\n\\n        return times;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n#include <iostream>\\n#include <vector>\\n#include <stack>\\n#include <sstream>\\n#include <cassert>\\n\\nusing namespace std;\\n\\nstruct Log {\\n    int id;\\n    string status;\\n    int timestamp;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> times(n, 0);\\n        stack<Log> st;\\n        for(string log: logs) {\\n            stringstream ss(log);\\n            string temp, temp2, temp3;\\n            getline(ss, temp, ':');\\n            getline(ss, temp2, ':');\\n            getline(ss, temp3, ':');\\n\\n            Log item = {stoi(temp), temp2, stoi(temp3)};\\n            if(item.status == \"start\") {\\n                st.push(item);\\n            } else {\\n                assert(st.top().id == item.id);\\n\\n                int time_added = item.timestamp - st.top().timestamp + 1;\\n                times[item.id] += time_added;\\n                st.pop();\\n\\n                if(!st.empty()) {\\n                    assert(st.top().status == \"start\");\\n                    times[st.top().id] -= time_added;\\n                }\\n            }\\n        }\\n\\n        return times;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 105062,
                "title": "java-stack-solution-o-n-time-o-n-space",
                "content": "```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n    int[] res = new int[n];\\n    Stack<Integer> stack = new Stack<>();\\n    int prevTime = 0;\\n    for (String log : logs) {\\n        String[] parts = log.split(\":\");\\n        if (!stack.isEmpty()) res[stack.peek()] +=  Integer.parseInt(parts[2]) - prevTime; \\n        prevTime = Integer.parseInt(parts[2]);\\n        if (parts[1].equals(\"start\")) stack.push(Integer.parseInt(parts[0]));\\n        else {\\n            res[stack.pop()]++;\\n            prevTime++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n    int[] res = new int[n];\\n    Stack<Integer> stack = new Stack<>();\\n    int prevTime = 0;\\n    for (String log : logs) {\\n        String[] parts = log.split(\":\");\\n        if (!stack.isEmpty()) res[stack.peek()] +=  Integer.parseInt(parts[2]) - prevTime; \\n        prevTime = Integer.parseInt(parts[2]);\\n        if (parts[1].equals(\"start\")) stack.push(Integer.parseInt(parts[0]));\\n        else {\\n            res[stack.pop()]++;\\n            prevTime++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497890,
                "title": "easy-to-understand-python-solution",
                "content": "I get that it may be really difficult to understand the official solution; I spent over a couple hours just banging my head around it. \\n\\nTurns out, the variables should be named correctly for readability\\n```\\n        stack = []\\n        result = [0] * n\\n        \\n        def normalizeProcessTime(processTime):\\n            return processTime.encode(\\'ascii\\',\\'ignore\\').split(\\':\\') \\n        \\n        for processTime in logs:\\n            processId, eventType, time = normalizeProcessTime(processTime)\\n            \\n            if eventType == \"start\":\\n                stack.append([processId, time])\\n            \\n            elif eventType == \"end\":\\n                processId, startTime = stack.pop()\\n                timeSpent = int(time) - int(startTime) + 1 # Add 1 cause 0 is included\\n                result[int(processId)] += timeSpent\\n                \\n                # Decrement time for next process in the stack\\n                if len(stack) != 0:\\n                    nextProcessId, timeSpentByNextProcess = stack[-1] #\\n                    result[int(nextProcessId)] -= timeSpent\\n                    \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        stack = []\\n        result = [0] * n\\n        \\n        def normalizeProcessTime(processTime):\\n            return processTime.encode(\\'ascii\\',\\'ignore\\').split(\\':\\') \\n        \\n        for processTime in logs:\\n            processId, eventType, time = normalizeProcessTime(processTime)\\n            \\n            if eventType == \"start\":\\n                stack.append([processId, time])\\n            \\n            elif eventType == \"end\":\\n                processId, startTime = stack.pop()\\n                timeSpent = int(time) - int(startTime) + 1 # Add 1 cause 0 is included\\n                result[int(processId)] += timeSpent\\n                \\n                # Decrement time for next process in the stack\\n                if len(stack) != 0:\\n                    nextProcessId, timeSpentByNextProcess = stack[-1] #\\n                    result[int(nextProcessId)] -= timeSpent\\n                    \\n        return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 209173,
                "title": "python-solution",
                "content": "The running logs of the `n` functions admits a valid parenthesis structure. E.g., the logs `n = 2`, `[\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]` can be equivalently represented by `(0:0 (1:2  1:5)  0:6)`. The left and right parenthsis separates the line into segments. The problem is equivalent to calculating the length of each segment.\\n\\nWe use a list `res` to record the exclusive time of each function `ID`, and a `stack` to keep track of the `ID` and `start` time of function calls in previous depths. We iterate over the `logs`, and for each `log`, we do `ID, op, time = log.split(\\':\\')`. we need to consider two cases:\\n\\nCase 1: `op == start`. If the `stack` is empty, it means that the function does not start within another function, and we just need to append `[ID, time]` to `stack`. Else if `stack` is nonempty, it means that the function starts within another function `ID_env`, and we need to update the exclusive time of `ID_env` by doing `res[stack[-1][0]] += time-stack[-1][1]`.\\n\\nCase 2: `op == end`. The `stack` must be nonempty, otherwise the parenthesis structure is invalid. We first pop from the `stack` to get the `start` time corresponding to this `end`, `prev = stack.pop()`. Then we need to update the exclusive time of the function that just ended, `res[ID] += time-prev[1]+1`. Finally, if `stack` still remains nonempty, it means that after the function ends, we are back to the previous function environment `ID_env` with one depth less, so we need to update the `start` time of `ID_env` to `time+1`, i.e., when `ID` ends at the end of `time`, `ID_env` resumes running at the start of `time+1`.\\n\\nTime complexity: `O(n)`, space complexity: `O(d)`, where `n = len(logs)`, and `d` is the depth of the function calls.\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0]*n\\n        stack = []\\n        for log in logs:\\n            ID, op, time = log.split(\\':\\')\\n            ID = int(ID)\\n            time = int(time)\\n            if op == \\'start\\':\\n                if stack:\\n                    res[stack[-1][0]] += time-stack[-1][1]\\n                stack.append([ID, time])\\n            else:\\n                prev = stack.pop()\\n                res[ID] += time-prev[1]+1\\n                if stack:\\n                    stack[-1][1] = time+1\\n        return res\\n```\\n\\nAnother solution without using stack. We can use a dictionary `dic` to keep track of function ID at each depth. The time and space complexity are the same as before.\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        depth = 0\\n        dic = {}\\n        res = [0]*n\\n        prev = None\\n        flag = False\\n        for log in logs:\\n            ID, op, time = log.split(\\':\\')\\n            ID = int(ID)\\n            time = int(time)\\n            if op == \\'start\\':\\n                depth += 1\\n                dic[depth] = ID\\n                if prev != None and depth != 1:\\n                    if flag:\\n                        res[dic[depth-1]] += time-prev-1\\n                    else:\\n                        res[dic[depth-1]] += time-prev\\n                prev = time\\n                flag = False\\n            else:\\n                if flag:\\n                    res[dic[depth]] += time-prev\\n                else:\\n                    res[dic[depth]] += time-prev+1\\n                depth -= 1\\n                prev = time\\n                flag = True\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [0]*n\\n        stack = []\\n        for log in logs:\\n            ID, op, time = log.split(\\':\\')\\n            ID = int(ID)\\n            time = int(time)\\n            if op == \\'start\\':\\n                if stack:\\n                    res[stack[-1][0]] += time-stack[-1][1]\\n                stack.append([ID, time])\\n            else:\\n                prev = stack.pop()\\n                res[ID] += time-prev[1]+1\\n                if stack:\\n                    stack[-1][1] = time+1\\n        return res\\n```\n```\\nclass Solution:\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        depth = 0\\n        dic = {}\\n        res = [0]*n\\n        prev = None\\n        flag = False\\n        for log in logs:\\n            ID, op, time = log.split(\\':\\')\\n            ID = int(ID)\\n            time = int(time)\\n            if op == \\'start\\':\\n                depth += 1\\n                dic[depth] = ID\\n                if prev != None and depth != 1:\\n                    if flag:\\n                        res[dic[depth-1]] += time-prev-1\\n                    else:\\n                        res[dic[depth-1]] += time-prev\\n                prev = time\\n                flag = False\\n            else:\\n                if flag:\\n                    res[dic[depth]] += time-prev\\n                else:\\n                    res[dic[depth]] += time-prev+1\\n                depth -= 1\\n                prev = time\\n                flag = True\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105101,
                "title": "java-clean-solution-with-normalized-time-explained",
                "content": "The sample input is very confusing when time `t` has mixed meaning of beginning of time `t` for `start` and end of time `t` for `end`\\n```\\nlogs = \\n[\"0:start:0\",\\n \"1:start:2\",\\n \"1:end:5\",\\n \"0:end:6\"]\\n```\\nWe can increase all end time by 1 to normalize the meaning of time `t`, so time `t`always means \"beginning of time `t`\"\\n```\\nlogs = \\n[\"0:start:0\",\\n \"1:start:2\",\\n \"1:end:6\",\\n \"0:end:7\"]\\n```\\nNow it is clear to see that function 0 spent `(2 - 0) + (7 - 6)` and function 1 spent `(6 - 2)`\\n\\n```\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] res = new int[n];\\n        int ptime = 0, running = 0;\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (String log : logs) {\\n            String[] split = log.split(\":\");\\n            int func = Integer.parseInt(split[0]);\\n            boolean start = split[1].equals(\"start\");\\n            int time = Integer.parseInt(split[2]);\\n            if (!start)\\n                time++;\\n\\n            res[running] += (time - ptime);\\n            if (start) {\\n                stack.push(running);\\n                running = func;\\n            } else {\\n                running = stack.pop();\\n            }\\n            ptime = time;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlogs = \\n[\"0:start:0\",\\n \"1:start:2\",\\n \"1:end:5\",\\n \"0:end:6\"]\\n```\n```\\nlogs = \\n[\"0:start:0\",\\n \"1:start:2\",\\n \"1:end:6\",\\n \"0:end:7\"]\\n```\n```\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] res = new int[n];\\n        int ptime = 0, running = 0;\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (String log : logs) {\\n            String[] split = log.split(\":\");\\n            int func = Integer.parseInt(split[0]);\\n            boolean start = split[1].equals(\"start\");\\n            int time = Integer.parseInt(split[2]);\\n            if (!start)\\n                time++;\\n\\n            res[running] += (time - ptime);\\n            if (start) {\\n                stack.push(running);\\n                running = func;\\n            } else {\\n                running = stack.pop();\\n            }\\n            ptime = time;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492801,
                "title": "java-tc-o-n-sc-o-n-2-clean-concise-solution-using-stack",
                "content": "```\\n/**\\n * Time Complexity: O(N * L) = O(N)\\n *\\n * Space Complexity: O(N/2) = O(N)\\n *\\n * N = Length of the input list of logs. L = Average length of each log. This\\n * can be considered as constant.\\n */\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        if (n == 0 || logs == null || logs.size() == 0) {\\n            return result;\\n        }\\n\\n        // This stack will store the function ids\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        // Previous time = start/resume time of the previous function\\n        int prevTime = 0;\\n\\n        for (String log : logs) {\\n            String[] logParts = log.split(\":\");\\n            int curTime = Integer.parseInt(logParts[2]);\\n\\n            if (\"start\".equals(logParts[1])) {\\n                // Function is starting now\\n                if (!stack.isEmpty()) {\\n                    // Add the exclusive time of previous function\\n                    result[stack.peek()] += curTime - prevTime;\\n                }\\n                stack.push(Integer.parseInt(logParts[0]));\\n                // Setting the start time for next log.\\n                prevTime = curTime;\\n            } else {\\n                // Function is ending now.\\n                // Make sure to +1 to as end takes the whole unit of time.\\n                result[stack.pop()] += curTime - prevTime + 1;\\n                // prevTime = resume time of the function. Thus adding 1.\\n                prevTime = curTime + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(N * L) = O(N)\\n *\\n * Space Complexity: O(N/2) = O(N)\\n *\\n * N = Length of the input list of logs. L = Average length of each log. This\\n * can be considered as constant.\\n */\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        if (n == 0 || logs == null || logs.size() == 0) {\\n            return result;\\n        }\\n\\n        // This stack will store the function ids\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        // Previous time = start/resume time of the previous function\\n        int prevTime = 0;\\n\\n        for (String log : logs) {\\n            String[] logParts = log.split(\":\");\\n            int curTime = Integer.parseInt(logParts[2]);\\n\\n            if (\"start\".equals(logParts[1])) {\\n                // Function is starting now\\n                if (!stack.isEmpty()) {\\n                    // Add the exclusive time of previous function\\n                    result[stack.peek()] += curTime - prevTime;\\n                }\\n                stack.push(Integer.parseInt(logParts[0]));\\n                // Setting the start time for next log.\\n                prevTime = curTime;\\n            } else {\\n                // Function is ending now.\\n                // Make sure to +1 to as end takes the whole unit of time.\\n                result[stack.pop()] += curTime - prevTime + 1;\\n                // prevTime = resume time of the function. Thus adding 1.\\n                prevTime = curTime + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024327,
                "title": "c-o-number-of-log-lines-stack-solution-with-diagram",
                "content": "The question in itself is composed of two sub-challenges and the candidate is expected to be tested in both of these.\\n1. **How does the candidate deal with parsing of the given log strings?** \\nDoes the candidate make the code readable and logically self explanatory with usage of abstractions?\\n Check how the below code defines a new structure `Log` that correctly encapsulates every log item. While it is definitely not a necessity to solve this question, it certainly makes things clearer & understandable and highlights your ability to write clean code as a developer.\\n\\n2. **Ofcourse, the algorithm itself?**\\nThis part is pretty straightforward here. Once you encounter any new `start` of a function id, we need to make a note of it. This will be used later when we encounter a corresponding `end` for the same function id. Once we get `end` of a function id, it is guaranteed that the `start` for that function id has already been inserted in the stack & is the current top of the stack. This is because we keep on removing all matching `start`/`end` pairs from the queue when we get the `end` and so any function that started as a child in the recursion will have to end prior to its parent.\\n\\n<img src=\"https://assets.leetcode.com/users/images/45dc9c18-d0ff-4682-a6ea-4af59cd07a5e_1611047008.1838188.png\" alt=\"stack trace simulation\" width=\"500\"/>\\n\\n> Time units consumed by the function that just ended = TimeStamp in the `end` log line - Timestamp in the `start` log line in the top of the stack + 1\\n[For example, if a function started at time = 4 & ended at time = 9, total time it took = 4->5->6->7->8->9 = 6 time units ie.e (9-4+1)]\\n\\nAdd this time for the particular function id.\\nRemove the corresponding `start` log for this `end` log from the stack as we are done processing their total time.\\n\\nOne interesting thing to note is that the total time of its parent function(the current top of the stack) has been consumed by this child function that we just removed from the stack and hence the `exclusive time` for the function that is currently on the top of the stack will be reduced by the same amount of time.\\n\\nBut don\\'t worry, we will find a corresponding `end` log line for this parent function too that would help us get the actual total exclusive time after subtracting all the times that child functions consumed.\\n\\n```\\nclass Solution {\\n    \\n    struct Log {\\n        int id;\\n        bool isStart;\\n        int time;\\n    };\\n    \\n    Log getLog(string& s) {\\n        string id, isStart, time;\\n        istringstream ss(s);\\n        getline(ss, id, \\':\\');\\n        getline(ss, isStart, \\':\\');\\n        getline(ss, time, \\':\\');\\n\\n        return {stoi(id), isStart == \"start\", stoi(time)};\\n    }\\n    \\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> exclusive(n, 0);\\n        stack<Log> s;\\n        \\n        for(auto& log: logs) {\\n            Log l = getLog(log);\\n            if(l.isStart)\\n                s.push(l);\\n            else {\\n                int time = l.time - s.top().time + 1;\\n                exclusive[l.id] += time;\\n                \\n                s.pop();\\n                if(!s.empty())\\n                    exclusive[s.top().id] -= time;\\n            }\\n        }\\n        \\n        return exclusive;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(k)** , k : number of log lines [Note that the time taken to parse the log lines can be carefully assumed to be O(1) in the context of the given the constraints. Since the function ids < 100, at max first three char will be sufficient to get the ids, similarly for other attributes too]\\n\\n**Space complexity: O(k)** for stack of log lines. Worst case, you can have k/2 `start` log lines followed by all k/2 `end` log lines in which case the stack will have a maximum of k/2 elements, giving O(k).\\n\\nHope this helps!\\n\\nThe idea above is same as presented here as well: https://leetcode.com/problems/exclusive-time-of-functions/discuss/105103/C%2B%2B-O(n)-stack-with-explaination.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    struct Log {\\n        int id;\\n        bool isStart;\\n        int time;\\n    };\\n    \\n    Log getLog(string& s) {\\n        string id, isStart, time;\\n        istringstream ss(s);\\n        getline(ss, id, \\':\\');\\n        getline(ss, isStart, \\':\\');\\n        getline(ss, time, \\':\\');\\n\\n        return {stoi(id), isStart == \"start\", stoi(time)};\\n    }\\n    \\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> exclusive(n, 0);\\n        stack<Log> s;\\n        \\n        for(auto& log: logs) {\\n            Log l = getLog(log);\\n            if(l.isStart)\\n                s.push(l);\\n            else {\\n                int time = l.time - s.top().time + 1;\\n                exclusive[l.id] += time;\\n                \\n                s.pop();\\n                if(!s.empty())\\n                    exclusive[s.top().id] -= time;\\n            }\\n        }\\n        \\n        return exclusive;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863039,
                "title": "python-3-clean-simple-stack-explanation",
                "content": "### Explanation\\n- Split a function call to 2 different type of states\\n\\t- Before nested call was made\\n\\t- After nested call was made\\n- Record time spent on these 2 types of states\\n- e.g. for `n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]`\\n\\t- Initially stack is empty, then it will record `[[0, 0]]` meaning function `0` start at timestamp `0`\\n\\t- Then nested call happens, we record time spent on function `0` in `ans`, then append to stack\\n\\t\\t- record time spent before nested call `ans[s[-1][0]] += timestamp - s[-1][1]`\\n\\t- now stack has `[[0, 0], [1, 2]]`\\n\\t- when a `end` is met, pop top of stack and record time as `timestamp - s.pop()[1] + 1`\\n\\t- now stack is back to `[[0, 0]]`, but before we end this iteration, we need to update the start time of this record\\n\\t\\t- because time spent on it before nested call is recorded, so now it\\'s like a new start\\n\\t\\t- update start time: `s[-1][1] = timestamp+1`\\n### Implementation\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        helper = lambda log: (int(log[0]), log[1], int(log[2])) # to covert id and time to integer\\n        logs = [helper(log.split(\\':\\')) for log in logs]         # convert [string] to [(,,)]\\n        ans, s = [0] * n, []                                    # initialize answer and stack\\n        for (i, status, timestamp) in logs:                     # for each record\\n            if status == \\'start\\':                               # if it\\'s start\\n                if s: ans[s[-1][0]] += timestamp - s[-1][1]     # if s is not empty, update time spent on previous id (s[-1][0])\\n                s.append([i, timestamp])                        # then add to top of stack\\n            else:                                               # if it\\'s end\\n                ans[i] += timestamp - s.pop()[1] + 1            # update time spend on `i`\\n                if s: s[-1][1] = timestamp+1                    # if s is not empty, udpate start time of previous id; \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        helper = lambda log: (int(log[0]), log[1], int(log[2])) # to covert id and time to integer\\n        logs = [helper(log.split(\\':\\')) for log in logs]         # convert [string] to [(,,)]\\n        ans, s = [0] * n, []                                    # initialize answer and stack\\n        for (i, status, timestamp) in logs:                     # for each record\\n            if status == \\'start\\':                               # if it\\'s start\\n                if s: ans[s[-1][0]] += timestamp - s[-1][1]     # if s is not empty, update time spent on previous id (s[-1][0])\\n                s.append([i, timestamp])                        # then add to top of stack\\n            else:                                               # if it\\'s end\\n                ans[i] += timestamp - s.pop()[1] + 1            # update time spend on `i`\\n                if s: s[-1][1] = timestamp+1                    # if s is not empty, udpate start time of previous id; \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505685,
                "title": "javascript-o-n-stack-solution-with-comments",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nvar exclusiveTime = function(n, logs) {\\n    const sums = new Array(n).fill(0);\\n    const stack = [];\\n    let prevTime;\\n    logs.forEach(log => {\\n        const details = log.split(\\':\\');\\n        const id = parseInt(details[0]);\\n        const point = details[1];\\n        const time = parseInt(details[2]);\\n        if (point === \\'start\\') {\\n            // If the stack is not empty, we need to increment the sum \\n            // of the previous function from previous start time to now\\n            if (stack.length > 0) {\\n\\t\\t\\t    let prevFn = stack[stack.length - 1];\\n                sums[prevFn] += (time - prevTime);      \\n            }\\n            stack.push(id); // Push this function onto the stack\\n            prevTime = time; // Set the previous start time to the time now\\n        } else {\\n            const last = stack.pop(); // Get the last function to start from the top of the stack \\n            sums[last] += (time - prevTime + 1); // Increment the sum from start to end, inclusive\\n            prevTime = time + 1; // Set the previous start time to be one after this function ended\\n        }\\n    });\\n    return sums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nvar exclusiveTime = function(n, logs) {\\n    const sums = new Array(n).fill(0);\\n    const stack = [];\\n    let prevTime;\\n    logs.forEach(log => {\\n        const details = log.split(\\':\\');\\n        const id = parseInt(details[0]);\\n        const point = details[1];\\n        const time = parseInt(details[2]);\\n        if (point === \\'start\\') {\\n            // If the stack is not empty, we need to increment the sum \\n            // of the previous function from previous start time to now\\n            if (stack.length > 0) {\\n\\t\\t\\t    let prevFn = stack[stack.length - 1];\\n                sums[prevFn] += (time - prevTime);      \\n            }\\n            stack.push(id); // Push this function onto the stack\\n            prevTime = time; // Set the previous start time to the time now\\n        } else {\\n            const last = stack.pop(); // Get the last function to start from the top of the stack \\n            sums[last] += (time - prevTime + 1); // Increment the sum from start to end, inclusive\\n            prevTime = time + 1; // Set the previous start time to be one after this function ended\\n        }\\n    });\\n    return sums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105078,
                "title": "simple-o-n-time-and-o-n-space-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        int lastTime = 0; // Remember the time in previous log entry\\n        stack<int> callStack; \\n        vector<int> runTime( n, 0 );\\n        size_t pos;\\n        for( int i = 0; i < logs.size(); i++ ) {\\n            // Parse the line\\n            string str = logs[ i ];\\n            pos = str.find( \":\" );\\n            int funcId = stoi( str.substr( 0, pos ) );\\n            str.erase( 0, pos+1 );\\n            pos = str.find( \":\" );\\n            string type = str.substr( 0, pos );\\n            str.erase( 0, pos+1 );\\n            int currTime = stoi( str );\\n            \\n            if ( type == \"start\" ) {\\n                // If a new function is called top of stack will contain the execution\\n                // context of this function. Update the runTime using that and push \\n                // current function of stack.\\n                if ( callStack.size() > 0 ) runTime[ callStack.top() ] += currTime-lastTime;\\n                callStack.push( funcId );\\n                lastTime = currTime;\\n            } else {\\n                // If a function has ended the top of stack will tell us its id\\n                // Update the runTime using that and pop the function from stack.\\n                runTime[ callStack.top() ] += currTime+1-lastTime;\\n                callStack.pop();\\n                lastTime = currTime+1;\\n            }\\n        }\\n        return runTime;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        int lastTime = 0; // Remember the time in previous log entry\\n        stack<int> callStack; \\n        vector<int> runTime( n, 0 );\\n        size_t pos;\\n        for( int i = 0; i < logs.size(); i++ ) {\\n            // Parse the line\\n            string str = logs[ i ];\\n            pos = str.find( \":\" );\\n            int funcId = stoi( str.substr( 0, pos ) );\\n            str.erase( 0, pos+1 );\\n            pos = str.find( \":\" );\\n            string type = str.substr( 0, pos );\\n            str.erase( 0, pos+1 );\\n            int currTime = stoi( str );\\n            \\n            if ( type == \"start\" ) {\\n                // If a new function is called top of stack will contain the execution\\n                // context of this function. Update the runTime using that and push \\n                // current function of stack.\\n                if ( callStack.size() > 0 ) runTime[ callStack.top() ] += currTime-lastTime;\\n                callStack.push( funcId );\\n                lastTime = currTime;\\n            } else {\\n                // If a function has ended the top of stack will tell us its id\\n                // Update the runTime using that and pop the function from stack.\\n                runTime[ callStack.top() ] += currTime+1-lastTime;\\n                callStack.pop();\\n                lastTime = currTime+1;\\n            }\\n        }\\n        return runTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141362,
                "title": "javascript-python-short-simple-solutions-beats-100",
                "content": "Just process functions when seeing end time and add processed time to previously opened function.\\n* Python\\n```\\nclass Solution:\\n    def exclusiveTime(self, n, logs):\\n        res, stack = [0] * n, []\\n        for log in logs:\\n            log = log.split(\":\")\\n            if log[1] == \"start\":\\n                stack.append([int(log[2]), 0])\\n            else:\\n                start = stack.pop()\\n                time = int(log[2]) - start[0] + 1\\n                res[int(log[0])] += time - start[1]\\n                if stack:\\n                    stack[-1][1] += time\\n        return res\\n```\\n* Javascript\\n```\\nvar exclusiveTime = function(n, logs) {\\n    let res = [...Array(n)].fill(0), stack = [];\\n    for (let i = 0; i < logs.length; i++) {\\n        let log = logs[i].split(\\':\\');\\n        if (log[1] == \\'start\\') {\\n            stack.push([log[2], 0]);\\n        }\\n        else {\\n            let start = stack.pop();\\n            let time = log[2] - start[0] + 1;\\n            res[log[0]] += time - start[1];\\n            if (stack.length > 0) {\\n                stack[stack.length - 1][1] += time;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n, logs):\\n        res, stack = [0] * n, []\\n        for log in logs:\\n            log = log.split(\":\")\\n            if log[1] == \"start\":\\n                stack.append([int(log[2]), 0])\\n            else:\\n                start = stack.pop()\\n                time = int(log[2]) - start[0] + 1\\n                res[int(log[0])] += time - start[1]\\n                if stack:\\n                    stack[-1][1] += time\\n        return res\\n```\n```\\nvar exclusiveTime = function(n, logs) {\\n    let res = [...Array(n)].fill(0), stack = [];\\n    for (let i = 0; i < logs.length; i++) {\\n        let log = logs[i].split(\\':\\');\\n        if (log[1] == \\'start\\') {\\n            stack.push([log[2], 0]);\\n        }\\n        else {\\n            let start = stack.pop();\\n            let time = log[2] - start[0] + 1;\\n            res[log[0]] += time - start[1];\\n            if (stack.length > 0) {\\n                stack[stack.length - 1][1] += time;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706529,
                "title": "python-simple-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        ## RC ##\\n\\t\\t## APPROACH : STACK ##\\n        stack, res = [], [0] * n\\n        for log in logs:\\n            id, func, curr_time = log.split(\":\")\\n            id, curr_time = int(id), int(curr_time)\\n            if func == \"start\":\\n                stack.append((id, curr_time))\\n            elif func == \"end\" and id == stack[-1][0]:\\n                pop_id, insert_time = stack.pop()\\n                time_taken = curr_time - insert_time + 1\\n                res[pop_id] += time_taken\\n                \\n                # gist, we have remove overlap time, if a process is in the stack indicates there is overlap with the last process\\n                if stack:\\n                    res[stack[-1][0]] -= time_taken # time taken by this process is the overlap time for prev process in stack\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        ## RC ##\\n\\t\\t## APPROACH : STACK ##\\n        stack, res = [], [0] * n\\n        for log in logs:\\n            id, func, curr_time = log.split(\":\")\\n            id, curr_time = int(id), int(curr_time)\\n            if func == \"start\":\\n                stack.append((id, curr_time))\\n            elif func == \"end\" and id == stack[-1][0]:\\n                pop_id, insert_time = stack.pop()\\n                time_taken = curr_time - insert_time + 1\\n                res[pop_id] += time_taken\\n                \\n                # gist, we have remove overlap time, if a process is in the stack indicates there is overlap with the last process\\n                if stack:\\n                    res[stack[-1][0]] -= time_taken # time taken by this process is the overlap time for prev process in stack\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439716,
                "title": "stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        stack<vector<int>>st;\\n        vector<int>ans(n);\\n        for(auto&i :logs){\\n            i+=\\':\\';\\n            stringstream str(i);\\n            string id,state,time;\\n            getline(str,id,\\':\\');getline(str,state,\\':\\');getline(str,time,\\':\\');\\n            if(state==\"start\") st.push({stoi(id),stoi(time),0});\\n            else{\\n                vector<int>x=st.top();//ct=child time;\\n                st.pop();\\n                int interval=stoi(time)-x[1]+1;\\n                ans[x[0]]+=interval-x[2];\\n                if(!st.empty())st.top()[2]+=interval;\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        stack<vector<int>>st;\\n        vector<int>ans(n);\\n        for(auto&i :logs){\\n            i+=\\':\\';\\n            stringstream str(i);\\n            string id,state,time;\\n            getline(str,id,\\':\\');getline(str,state,\\':\\');getline(str,time,\\':\\');\\n            if(state==\"start\") st.push({stoi(id),stoi(time),0});\\n            else{\\n                vector<int>x=st.top();//ct=child time;\\n                st.pop();\\n                int interval=stoi(time)-x[1]+1;\\n                ans[x[0]]+=interval-x[2];\\n                if(!st.empty())st.top()[2]+=interval;\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301187,
                "title": "very-simple-java-using-stack-keep-subtract-from-previous-function",
                "content": "```\\nclass Solution {\\n    // Looks complicated but principle is quite simple: \\n    // Whenever we finish current function interval, we peek() to get its previous function to subtract the current execution time. \\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Node> stk = new Stack<>();\\n        int[] res= new int[n];\\n        \\n        for (String log : logs) {\\n            String[] arr = log.split(\"\\\\\\\\:\");\\n            int id = Integer.valueOf(arr[0]);\\n            String state = arr[1];\\n            int time = Integer.valueOf(arr[2]);\\n            \\n            if (state.equals(\"start\")) {\\n                stk.push(new Node(id, time));\\n            } else {\\n                int change = time - stk.pop().time + 1;\\n                res[id] += change;\\n                if (!stk.isEmpty()) \\n                    res[stk.peek().id] -= change; // substract from previous\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass Node {\\n    int id;\\n    int time;\\n    Node(int id, int time) {\\n        this.id = id;\\n        this.time = time;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Looks complicated but principle is quite simple: \\n    // Whenever we finish current function interval, we peek() to get its previous function to subtract the current execution time. \\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Node> stk = new Stack<>();\\n        int[] res= new int[n];\\n        \\n        for (String log : logs) {\\n            String[] arr = log.split(\"\\\\\\\\:\");\\n            int id = Integer.valueOf(arr[0]);\\n            String state = arr[1];\\n            int time = Integer.valueOf(arr[2]);\\n            \\n            if (state.equals(\"start\")) {\\n                stk.push(new Node(id, time));\\n            } else {\\n                int change = time - stk.pop().time + 1;\\n                res[id] += change;\\n                if (!stk.isEmpty()) \\n                    res[stk.peek().id] -= change; // substract from previous\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass Node {\\n    int id;\\n    int time;\\n    Node(int id, int time) {\\n        this.id = id;\\n        this.time = time;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832267,
                "title": "python-stack-easy-to-understand",
                "content": "\\n```\\ndef exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        stack = []\\n        prev_time = 0\\n        ans = [0 for i in range(n)]\\n        \\n        for i in range(0,len(logs)):\\n            fid, state, time = logs[i].split(\\':\\')\\n            fid, time = int(fid), int(time)\\n            \\n            if state == \"start\":\\n                if stack:\\n                    ans[stack[-1]] += time - prev_time\\n                \\n                stack.append(fid)\\n                prev_time = time\\n           \\n            else:\\n                ans[stack.pop()] += time - prev_time + 1\\n                prev_time = time + 1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        stack = []\\n        prev_time = 0\\n        ans = [0 for i in range(n)]\\n        \\n        for i in range(0,len(logs)):\\n            fid, state, time = logs[i].split(\\':\\')\\n            fid, time = int(fid), int(time)\\n            \\n            if state == \"start\":\\n                if stack:\\n                    ans[stack[-1]] += time - prev_time\\n                \\n                stack.append(fid)\\n                prev_time = time\\n           \\n            else:\\n                ans[stack.pop()] += time - prev_time + 1\\n                prev_time = time + 1\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1237541,
                "title": "java-solution-with-full-explaination",
                "content": "```\\nimport java.util.List;\\nimport java.util.Stack;\\n\\npublic class Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        // separate time to several intervals, add interval to their function\\n        int[] res = new int[n];\\n        //store id, not timestamp\\n        Stack<Integer> idStack = new Stack<>();\\n        //store timestamp: prevLogTime here is to maintain previous functions time\\n        // and if it is start function we just add it to previous if it is an end function\\n        // then add plus one to mark the end of the top of stack function\\n        //(It\\'s used to record last log time)\\n        int prevLogTime = 0;\\n        // pre means the start of the interval\\n        for (String s : logs) {\\n            String[] log = s.split(\":\");\\n            if (log[1].equals(\"start\")) {\\n                if (!idStack.isEmpty()) res[idStack.peek()] += Integer.parseInt(log[2]) - prevLogTime;\\n                // log[2] is the start of next interval, doesn\\'t belong to current interval.\\n                idStack.push(Integer.parseInt(log[0]));\\n                prevLogTime = Integer.parseInt(log[2]);\\n            } else {\\n                res[idStack.pop()] += Integer.parseInt(log[2]) - prevLogTime + 1;\\n                // log[2] is end of current interval, belong to current interval. That\\'s why we have +1 here\\n                prevLogTime = Integer.parseInt(log[2]) + 1;\\n                // prevLogTime means the start of next interval, so we need to +1\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nimport java.util.List;\\nimport java.util.Stack;\\n\\npublic class Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        // separate time to several intervals, add interval to their function\\n        int[] res = new int[n];\\n        //store id, not timestamp\\n        Stack<Integer> idStack = new Stack<>();\\n        //store timestamp: prevLogTime here is to maintain previous functions time\\n        // and if it is start function we just add it to previous if it is an end function\\n        // then add plus one to mark the end of the top of stack function\\n        //(It\\'s used to record last log time)\\n        int prevLogTime = 0;\\n        // pre means the start of the interval\\n        for (String s : logs) {\\n            String[] log = s.split(\":\");\\n            if (log[1].equals(\"start\")) {\\n                if (!idStack.isEmpty()) res[idStack.peek()] += Integer.parseInt(log[2]) - prevLogTime;\\n                // log[2] is the start of next interval, doesn\\'t belong to current interval.\\n                idStack.push(Integer.parseInt(log[0]));\\n                prevLogTime = Integer.parseInt(log[2]);\\n            } else {\\n                res[idStack.pop()] += Integer.parseInt(log[2]) - prevLogTime + 1;\\n                // log[2] is end of current interval, belong to current interval. That\\'s why we have +1 here\\n                prevLogTime = Integer.parseInt(log[2]) + 1;\\n                // prevLogTime means the start of next interval, so we need to +1\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160762,
                "title": "python-stacked-time-o-n-space-o-n-with-intuitions",
                "content": "Intuition:\\n1. similar to the closing openning backet problems, where there\\'s nesting, stack is required\\n2. nested function time need to be deducted from the parent time, therefore update the parent function with negative children\\'s time\\n3. Each time a function finishes, the time span needs to be added to the function slot in the outputs array\\n\\n```\\nclass Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        outputs = [0]*n\\n        stack = [] # holds f_id, time stamp\\n        \\n        for s in logs:\\n            tokens = s.split(\":\")\\n            f_id, state, time = int(tokens[0]), tokens[1], int(tokens[2])\\n            if state == \"start\":\\n                stack.append((f_id, time))\\n            else:\\n                f_id_end, time_start = stack.pop()\\n                time_diff = time - time_start + 1\\n                outputs[f_id_end] += time_diff\\n                if len(stack) > 0:\\n                    # deduct from previous fn time \\n                    outputs[stack[-1][0]] += -time_diff\\n        return outputs \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        outputs = [0]*n\\n        stack = [] # holds f_id, time stamp\\n        \\n        for s in logs:\\n            tokens = s.split(\":\")\\n            f_id, state, time = int(tokens[0]), tokens[1], int(tokens[2])\\n            if state == \"start\":\\n                stack.append((f_id, time))\\n            else:\\n                f_id_end, time_start = stack.pop()\\n                time_diff = time - time_start + 1\\n                outputs[f_id_end] += time_diff\\n                if len(stack) > 0:\\n                    # deduct from previous fn time \\n                    outputs[stack[-1][0]] += -time_diff\\n        return outputs \\n```",
                "codeTag": "Java"
            },
            {
                "id": 554690,
                "title": "minimal-and-easy-to-understand-modern-c-using-a-stack-comments",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> exec_time(n, 0);\\n\\t\\t// we\\'re using a pair [process_id, start_time]\\n        stack<pair<int, int>> processing;\\n\\n        for (const auto& log : logs) {\\n            // tokenize the string\\n            std::stringstream sstream(log);\\n            string id; getline(sstream, id, \\':\\');\\n            string op; getline(sstream, op, \\':\\');\\n            string ts; getline(sstream, ts, \\':\\');\\n\\n            if (op == \"start\") {\\n                // add process to stack, convert strings to ints\\n                processing.emplace(std::stoi(id), std::stoi(ts));\\n            } else {\\n                // c++17 structured binding\\n                auto [process_id, start_time] = processing.top();\\n                processing.pop();\\n\\n                // get the process time and set it\\n                auto offset = stoi(ts) - start_time + 1;\\n                exec_time[process_id] += offset;\\n\\n                // if stack is not empty, a process was on hold\\n                // we need to remove the time elapsed since before we resume\\n                if (!std::empty(processing)) {\\n                    exec_time[processing.top().first] -= offset;\\n                }\\n            }\\n        }\\n        return exec_time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> exec_time(n, 0);\\n\\t\\t// we\\'re using a pair [process_id, start_time]\\n        stack<pair<int, int>> processing;\\n\\n        for (const auto& log : logs) {\\n            // tokenize the string\\n            std::stringstream sstream(log);\\n            string id; getline(sstream, id, \\':\\');\\n            string op; getline(sstream, op, \\':\\');\\n            string ts; getline(sstream, ts, \\':\\');\\n\\n            if (op == \"start\") {\\n                // add process to stack, convert strings to ints\\n                processing.emplace(std::stoi(id), std::stoi(ts));\\n            } else {\\n                // c++17 structured binding\\n                auto [process_id, start_time] = processing.top();\\n                processing.pop();\\n\\n                // get the process time and set it\\n                auto offset = stoi(ts) - start_time + 1;\\n                exec_time[process_id] += offset;\\n\\n                // if stack is not empty, a process was on hold\\n                // we need to remove the time elapsed since before we resume\\n                if (!std::empty(processing)) {\\n                    exec_time[processing.top().first] -= offset;\\n                }\\n            }\\n        }\\n        return exec_time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105072,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [0] * n\\n        stack = []\\n        for log in logs:\\n            uid, status, time = map(int, log.replace(\"start\", \"1\").replace(\"end\", \"0\").split(\":\"))\\n            if status:\\n                stack.append([time, 0])\\n            else:\\n                start, innerTime = stack.pop()\\n                ans[uid] += time - start + 1 - innerTime\\n                if stack:\\n                    stack[-1][1] += time - start + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [0] * n\\n        stack = []\\n        for log in logs:\\n            uid, status, time = map(int, log.replace(\"start\", \"1\").replace(\"end\", \"0\").split(\":\"))\\n            if status:\\n                stack.append([time, 0])\\n            else:\\n                start, innerTime = stack.pop()\\n                ans[uid] += time - start + 1 - innerTime\\n                if stack:\\n                    stack[-1][1] += time - start + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105075,
                "title": "c-solution-stack",
                "content": "```\\n/**\\n * Every time end an function, deduce its life span from its parent\\n */\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> times(n, 0);\\n        stack<pair<int, int>> starters;\\n        for (int i = 0; i < logs.size(); i++) {\\n            Line line = getLine(logs[i]);\\n            if (line.start) {\\n                starters.push({ line.fid, line.time });\\n            }\\n            else {\\n                pair<int, int> starter = starters.top();\\n                int lifespan = line.time + 1 - starter.second;\\n                starters.pop();\\n                times[line.fid] += lifespan;\\n                if (!starters.empty()) {\\n                    times[starters.top().first] -= lifespan;\\n                }\\n            }\\n        }\\n        return times;\\n    }\\n\\n    struct Line {\\n        int fid;\\n        bool start;\\n        int time;\\n        Line(int fid, bool start, int time) : fid(fid), start(start), time(time) {};\\n    };\\n\\n    Line getLine(string s) {\\n        int colon1 = s.find(\":\", 0);\\n        int colon2 = s.find(\":\", colon1 + 1);\\n        string fid = s.substr(0, colon1);\\n        string start = s.substr(colon1 + 1, colon2 - (colon1 + 1));\\n        string time = s.substr(colon2 + 1);\\n        return Line(stoi(fid), start == \"start\", stoi(time));\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Every time end an function, deduce its life span from its parent\\n */\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> times(n, 0);\\n        stack<pair<int, int>> starters;\\n        for (int i = 0; i < logs.size(); i++) {\\n            Line line = getLine(logs[i]);\\n            if (line.start) {\\n                starters.push({ line.fid, line.time });\\n            }\\n            else {\\n                pair<int, int> starter = starters.top();\\n                int lifespan = line.time + 1 - starter.second;\\n                starters.pop();\\n                times[line.fid] += lifespan;\\n                if (!starters.empty()) {\\n                    times[starters.top().first] -= lifespan;\\n                }\\n            }\\n        }\\n        return times;\\n    }\\n\\n    struct Line {\\n        int fid;\\n        bool start;\\n        int time;\\n        Line(int fid, bool start, int time) : fid(fid), start(start), time(time) {};\\n    };\\n\\n    Line getLine(string s) {\\n        int colon1 = s.find(\":\", 0);\\n        int colon2 = s.find(\":\", colon1 + 1);\\n        string fid = s.substr(0, colon1);\\n        string start = s.substr(colon1 + 1, colon2 - (colon1 + 1));\\n        string time = s.substr(colon2 + 1);\\n        return Line(stoi(fid), start == \"start\", stoi(time));\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225725,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> ans(n);\\n        stack<pair<int,int>> cur;\\n        int prevTime = 0;\\n        for (auto& s : logs){\\n            int num = stoi(s.substr(0, s.find(\\':\\')));\\n            int time = stoi(s.substr(s.rfind(\\':\\') + 1));\\n            if (s.find(\\'e\\') != -1){\\n                ans[num] += time - prevTime + 1;\\n                cur.pop();\\n                prevTime = time + 1;\\n            }\\n            else{\\n                if (!cur.empty()) ans[cur.top().first] += time - prevTime ;\\n                cur.push({num, time});\\n                prevTime = time;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> ans(n);\\n        stack<pair<int,int>> cur;\\n        int prevTime = 0;\\n        for (auto& s : logs){\\n            int num = stoi(s.substr(0, s.find(\\':\\')));\\n            int time = stoi(s.substr(s.rfind(\\':\\') + 1));\\n            if (s.find(\\'e\\') != -1){\\n                ans[num] += time - prevTime + 1;\\n                cur.pop();\\n                prevTime = time + 1;\\n            }\\n            else{\\n                if (!cur.empty()) ans[cur.top().first] += time - prevTime ;\\n                cur.push({num, time});\\n                prevTime = time;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165829,
                "title": "python-3-12-lines-stack-w-example-t-m-95-94",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\n        stack, ans = deque(), [0]*n                         # Example: [\"0:start:0\", \"0:start:2\", \"0:end:5\",\\n                                                            #           \"1:start:6\", \"1:end  :6\", \"0:end:7\"]\\n    \\n        for log in logs:                                    #                time-\\n            id, action, timestamp = log.split(\":\")          #   id   action  stamp    ans    stack\\n            id, timestamp = int(id), int(timestamp)         #  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                            #    0    start     0    [0,0]   [(0,0)]\\n            if action == \"start\":                           #    0    start     2    [0,0]   [(0,0),(0,2)]\\n                stack.append((id, timestamp))               #    0     end      5    [0,0]   [(0,0)]\\n                                                            #    1    start     6    [0,0]   [(0,0),(1,6)]\\n            else:                                           #    1     end      6    [0,1]   [(0,0)]\\n                id, initTime = stack.pop()                  #    0     end      7    [7,1]   []\\n                elapsedTime = timestamp + 1 - initTime\\n                ans[id]+= elapsedTime\\n\\n                if stack: ans[stack[-1][0]]-= elapsedTime\\n               \\n        return ans\\n\\n```\\n[https://leetcode.com/problems/exclusive-time-of-functions/submissions/894946824/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\n        stack, ans = deque(), [0]*n                         # Example: [\"0:start:0\", \"0:start:2\", \"0:end:5\",\\n                                                            #           \"1:start:6\", \"1:end  :6\", \"0:end:7\"]\\n    \\n        for log in logs:                                    #                time-\\n            id, action, timestamp = log.split(\":\")          #   id   action  stamp    ans    stack\\n            id, timestamp = int(id), int(timestamp)         #  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013    \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                            #    0    start     0    [0,0]   [(0,0)]\\n            if action == \"start\":                           #    0    start     2    [0,0]   [(0,0),(0,2)]\\n                stack.append((id, timestamp))               #    0     end      5    [0,0]   [(0,0)]\\n                                                            #    1    start     6    [0,0]   [(0,0),(1,6)]\\n            else:                                           #    1     end      6    [0,1]   [(0,0)]\\n                id, initTime = stack.pop()                  #    0     end      7    [7,1]   []\\n                elapsedTime = timestamp + 1 - initTime\\n                ans[id]+= elapsedTime\\n\\n                if stack: ans[stack[-1][0]]-= elapsedTime\\n               \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321131,
                "title": "java-solution-easy-to-understand-good-explanation",
                "content": "\\nThis one is little tricky. Few things to notice here:\\n1. Function starts at the start of a time interval and ends at the end of the interval\\n    E.g. function(id=1) starts at the start of time = 2 second. If it was supposed to run for only one second, they would have written it like \"2:end:2\". It ends at the end of second 2. \\n    That means, the  next function can be started at next timestamp. Or if there is a background function running, it can resume only in the next timestamp (which is 3)\\n\\n2. A function DOES NOT end while some other function is running. E.g. this will never happen\\n    \"0:start:0\", \"1:start:2\", \"0:end:3\"\\n    \\n    That means for every \"end\", the running function is of the same id as that of the end\\n\\nWe use stack.\\nthere are only two cases:\\n1. start or 2. end\\n\\n\\n**start:**\\n    We push this on the stack.\\n    Before pushing, we need to put the already running function on the background and add its run time to ans\\n\\n**end:**\\n    Pop the top of the stack. This function has finished its complete run. Now, it\\'s runtime will be\\n    `ret[stack.top.id] += current timestamp - prevTime + 1`\\n    We are adding 1 here because \"end\" gets executed for the whole of current timestamp.\\n\\n**prevTime:**\\n    At each step, we update the prevTime with current time stamp. prevTime represents when actually current function started running (It can be because this function is \"start\"ed or resumed from background)\\n\\n\\n```\\nclass Function {\\n    boolean isStart = false;\\n    int id, time;\\n    \\n    public Function(String[] val)\\n    {\\n        id = Integer.parseInt(val[0]);\\n        isStart = val[1].equals(\"start\");\\n        time = Integer.parseInt(val[2]);\\n    }\\n}\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int[] ret = new int[n];\\n        for(int i=0; i<n; i++)\\n            ret[i] = 0;\\n        \\n        Stack<Function> stack = new Stack<>();\\n        \\n        int prevTime = 0;\\n\\n        for(String log: logs)\\n        {\\n            Function currFunc = new Function(log.split(\":\"));\\n            \\n            if(currFunc.isStart)\\n            {\\n                if(!stack.isEmpty())\\n                {\\n                    ret[stack.peek().id] += currFunc.time - prevTime;\\n                }\\n                \\n                stack.push(currFunc);\\n                prevTime = currFunc.time;\\n            }\\n            else\\n            {\\n                Function popped = stack.pop();\\n                ret[currFunc.id] += currFunc.time - prevTime + 1;\\n                \\n                prevTime = currFunc.time + 1; \\n                // We write +1 here because the next function is going to start at next timestamp\\n                // or resumes at next timestamp\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Function {\\n    boolean isStart = false;\\n    int id, time;\\n    \\n    public Function(String[] val)\\n    {\\n        id = Integer.parseInt(val[0]);\\n        isStart = val[1].equals(\"start\");\\n        time = Integer.parseInt(val[2]);\\n    }\\n}\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int[] ret = new int[n];\\n        for(int i=0; i<n; i++)\\n            ret[i] = 0;\\n        \\n        Stack<Function> stack = new Stack<>();\\n        \\n        int prevTime = 0;\\n\\n        for(String log: logs)\\n        {\\n            Function currFunc = new Function(log.split(\":\"));\\n            \\n            if(currFunc.isStart)\\n            {\\n                if(!stack.isEmpty())\\n                {\\n                    ret[stack.peek().id] += currFunc.time - prevTime;\\n                }\\n                \\n                stack.push(currFunc);\\n                prevTime = currFunc.time;\\n            }\\n            else\\n            {\\n                Function popped = stack.pop();\\n                ret[currFunc.id] += currFunc.time - prevTime + 1;\\n                \\n                prevTime = currFunc.time + 1; \\n                // We write +1 here because the next function is going to start at next timestamp\\n                // or resumes at next timestamp\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295753,
                "title": "python-stack-easy-o-n",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        \\n        f = [0]*(n)\\n        \\n        \\n        stack=[]\\n        \\n        \\n        for i in logs:\\n            \\n            ID,pos,time = i.split(\\':\\')\\n            \\n            ID= int(ID)\\n            time= int(time)\\n            if pos == \\'start\\':\\n                \\n                stack.append([ID,time])\\n            else:\\n                \\n                prID, prtime = stack.pop()\\n                \\n                timespent = time-prtime+1\\n                f[ID]+= timespent\\n                \\n                #remove the overlapping time \\n                \\n                if stack:\\n                    f[stack[-1][0]]-= timespent\\n                    \\n        return f\\n                \\n                    \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        \\n        f = [0]*(n)\\n        \\n        \\n        stack=[]\\n        \\n        \\n        for i in logs:\\n            \\n            ID,pos,time = i.split(\\':\\')\\n            \\n            ID= int(ID)\\n            time= int(time)\\n            if pos == \\'start\\':\\n                \\n                stack.append([ID,time])\\n            else:\\n                \\n                prID, prtime = stack.pop()\\n                \\n                timespent = time-prtime+1\\n                f[ID]+= timespent\\n                \\n                #remove the overlapping time \\n                \\n                if stack:\\n                    f[stack[-1][0]]-= timespent\\n                    \\n        return f\\n                \\n                    \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 651462,
                "title": "python3-solution-using-stack-faster-than-96-75",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        ftimes = [0] * n\\n        stack = []\\n        prev_start_time = 0\\n        \\n        for log in logs:\\n            fid, indicator, ftime = log.split(\":\")\\n            fid, ftime = int(fid), int(ftime)\\n            \\n            if indicator == \\'start\\':\\n                if stack:\\n                    ftimes[stack[-1]] += ftime - prev_start_time\\n                    \\n                stack.append(fid)\\n                prev_start_time = ftime\\n                \\n            else:\\n                ftimes[stack.pop()] += ftime - prev_start_time + 1\\n                prev_start_time = ftime + 1\\n                \\n        return ftimes\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        ftimes = [0] * n\\n        stack = []\\n        prev_start_time = 0\\n        \\n        for log in logs:\\n            fid, indicator, ftime = log.split(\":\")\\n            fid, ftime = int(fid), int(ftime)\\n            \\n            if indicator == \\'start\\':\\n                if stack:\\n                    ftimes[stack[-1]] += ftime - prev_start_time\\n                    \\n                stack.append(fid)\\n                prev_start_time = ftime\\n                \\n            else:\\n                ftimes[stack.pop()] += ftime - prev_start_time + 1\\n                prev_start_time = ftime + 1\\n                \\n        return ftimes\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739360,
                "title": "very-very-simple-solution-stacks",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\n        result = [0]*n\\n        stack = []\\n        \\n        for i, log in enumerate(logs):\\n            curr_fid, curr_event, curr_time = log.split(\":\")\\n            if curr_event == \"start\":\\n                stack.append(log)\\n            elif curr_event == \"end\":\\n                prev_fid, prev_event, prev_time = stack.pop().split(\":\")\\n                result[int(curr_fid)] += int(curr_time)-int(prev_time)+1\\n                if stack:\\n                    prev_fid1, prev_event1, prev_time1 = stack[-1].split(\":\")\\n                    result[int(prev_fid1)] -= (int(curr_time)-int(prev_time))+1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\n        result = [0]*n\\n        stack = []\\n        \\n        for i, log in enumerate(logs):\\n            curr_fid, curr_event, curr_time = log.split(\":\")\\n            if curr_event == \"start\":\\n                stack.append(log)\\n            elif curr_event == \"end\":\\n                prev_fid, prev_event, prev_time = stack.pop().split(\":\")\\n                result[int(curr_fid)] += int(curr_time)-int(prev_time)+1\\n                if stack:\\n                    prev_fid1, prev_event1, prev_time1 = stack[-1].split(\":\")\\n                    result[int(prev_fid1)] -= (int(curr_time)-int(prev_time))+1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520052,
                "title": "java-simple-structured-and-easy-to-understand-with-comments",
                "content": "\\n1.) Get attributes of the log stream\\n2.) Create a call stack and add the running process to it  (`log.state == \"start\"`)\\n3.) at the end of the process call update the child process execution time of the parent process (`parent --> stack.peek()`);\\n4.) calculate the execution time of the process and update the array   \\n\\n\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\n\\n```\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] execution = new int[n];\\n        Stack<Process> stack = new Stack();\\n        \\n        for (String logStream : logs) {\\n            Log log = new Log(logStream);\\n            \\n            if (log.state.equals(\"start\")) stack.push(new Process(log.id, log.time, 0));\\n            else {\\n                Process process = stack.pop();\\n                execution[log.id] += log.time - process.startTime - process.childExecTime + 1;\\n                \\n                // updating the child execution time of the parent\\n                if (!stack.isEmpty()) stack.peek().childExecTime += log.time - process.startTime + 1;\\n            }\\n        }\\n        return execution;\\n    }\\n    \\n    class Log {\\n        int id;\\n        String state;\\n        int time;\\n        \\n        Log( String logStream) {\\n            String[] stream = logStream.split(\":\");\\n            this.id = Integer.parseInt(stream[0]);\\n            this.state = stream[1];\\n            this.time = Integer.parseInt(stream[2]);\\n        }\\n    }\\n    \\n    class Process {\\n        int id;\\n        int startTime;\\n        int childExecTime;\\n        \\n        Process(int id, int startTime, int childExecTime) {\\n            this.id = id;\\n            this.startTime = startTime;\\n            this.childExecTime = childExecTime;\\n        }\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] execution = new int[n];\\n        Stack<Process> stack = new Stack();\\n        \\n        for (String logStream : logs) {\\n            Log log = new Log(logStream);\\n            \\n            if (log.state.equals(\"start\")) stack.push(new Process(log.id, log.time, 0));\\n            else {\\n                Process process = stack.pop();\\n                execution[log.id] += log.time - process.startTime - process.childExecTime + 1;\\n                \\n                // updating the child execution time of the parent\\n                if (!stack.isEmpty()) stack.peek().childExecTime += log.time - process.startTime + 1;\\n            }\\n        }\\n        return execution;\\n    }\\n    \\n    class Log {\\n        int id;\\n        String state;\\n        int time;\\n        \\n        Log( String logStream) {\\n            String[] stream = logStream.split(\":\");\\n            this.id = Integer.parseInt(stream[0]);\\n            this.state = stream[1];\\n            this.time = Integer.parseInt(stream[2]);\\n        }\\n    }\\n    \\n    class Process {\\n        int id;\\n        int startTime;\\n        int childExecTime;\\n        \\n        Process(int id, int startTime, int childExecTime) {\\n            this.id = id;\\n            this.startTime = startTime;\\n            this.childExecTime = childExecTime;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112981,
                "title": "javascript-solution-100ms-with-comments-and-readable-code",
                "content": "Self-explanatory code\\n\\n```\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nvar exclusiveTime = function(n, logs) {\\n    // To track sums of time for each program\\n    let sums = new Array(n).fill(0);\\n    \\n    // To track calls for each function\\n    let fnStack = [];\\n    \\n    // To track previous fn call start time\\n    let prevTime = -1;\\n    \\n    // To extract the log details from input\\n    const getLogDetails = (log) => {\\n        const details = log.split(\":\");\\n        return {\\n            id: parseInt(details[0]),\\n            startEvent: details[1] === \"start\" ? true : false,\\n            time: parseInt(details[2]),\\n        }\\n    }\\n    \\n    logs.forEach(log => {\\n        let {id, startEvent, time} = getLogDetails(log);\\n        if (startEvent) {\\n            /** \\n             * if function exist in stack, then let\\'s update\\n             * previous function\\'s time before current program starts\\n             */\\n            if (fnStack.length) {\\n                let prevFn = fnStack[fnStack.length - 1];\\n                sums[prevFn] += time - prevTime;\\n            }\\n            \\n            // Let\\'s push this function to the stack and record the time it started\\n            fnStack.push(id);\\n            prevTime = time;\\n        } else{\\n            // Let\\'s get the last executing function and calculate how much time it took\\n            let lastFn = fnStack.pop();\\n            sums[lastFn] += (time - prevTime + 1);\\n            \\n            // Let\\'s reset the prevTime for next function to use to calculate it\\'s total time\\n            prevTime = time + 1;\\n        }\\n    });\\n    \\n    return sums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nvar exclusiveTime = function(n, logs) {\\n    // To track sums of time for each program\\n    let sums = new Array(n).fill(0);\\n    \\n    // To track calls for each function\\n    let fnStack = [];\\n    \\n    // To track previous fn call start time\\n    let prevTime = -1;\\n    \\n    // To extract the log details from input\\n    const getLogDetails = (log) => {\\n        const details = log.split(\":\");\\n        return {\\n            id: parseInt(details[0]),\\n            startEvent: details[1] === \"start\" ? true : false,\\n            time: parseInt(details[2]),\\n        }\\n    }\\n    \\n    logs.forEach(log => {\\n        let {id, startEvent, time} = getLogDetails(log);\\n        if (startEvent) {\\n            /** \\n             * if function exist in stack, then let\\'s update\\n             * previous function\\'s time before current program starts\\n             */\\n            if (fnStack.length) {\\n                let prevFn = fnStack[fnStack.length - 1];\\n                sums[prevFn] += time - prevTime;\\n            }\\n            \\n            // Let\\'s push this function to the stack and record the time it started\\n            fnStack.push(id);\\n            prevTime = time;\\n        } else{\\n            // Let\\'s get the last executing function and calculate how much time it took\\n            let lastFn = fnStack.pop();\\n            sums[lastFn] += (time - prevTime + 1);\\n            \\n            // Let\\'s reset the prevTime for next function to use to calculate it\\'s total time\\n            prevTime = time + 1;\\n        }\\n    });\\n    \\n    return sums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 606022,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Log {\\n    int id;\\n    int time;\\n    boolean isStart;\\n    \\n    public Log(String str) {\\n        String[] arr = str.split(\":\");\\n        this.id = Integer.parseInt(arr[0]);\\n        this.time = Integer.parseInt(arr[2]);\\n        this.isStart = \"start\".equals(arr[1]);\\n    }\\n}\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        Stack<Log> stack = new Stack<>();\\n        \\n        for (String str: logs) {\\n            Log log = new Log(str);\\n            if (log.isStart) {\\n                stack.push(log);\\n            } else {\\n                Log top = stack.pop();\\n                result[top.id] += log.time - top.time + 1;\\n                if (!stack.isEmpty()) {\\n                    Log prev = stack.peek();\\n                    result[prev.id] -= log.time - top.time + 1;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Log {\\n    int id;\\n    int time;\\n    boolean isStart;\\n    \\n    public Log(String str) {\\n        String[] arr = str.split(\":\");\\n        this.id = Integer.parseInt(arr[0]);\\n        this.time = Integer.parseInt(arr[2]);\\n        this.isStart = \"start\".equals(arr[1]);\\n    }\\n}\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        Stack<Log> stack = new Stack<>();\\n        \\n        for (String str: logs) {\\n            Log log = new Log(str);\\n            if (log.isStart) {\\n                stack.push(log);\\n            } else {\\n                Log top = stack.pop();\\n                result[top.id] += log.time - top.time + 1;\\n                if (!stack.isEmpty()) {\\n                    Log prev = stack.peek();\\n                    result[prev.id] -= log.time - top.time + 1;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330810,
                "title": "swift-solution-using-stack",
                "content": "```swift\\nclass Solution {\\n    \\n    enum FunctionStatus: Int {\\n        case start = 0\\n        case end = 1\\n    }\\n    \\n    typealias Log = (functionID: Int, status: FunctionStatus, time: Int)\\n    \\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\\n        \\n        var ans = Array<Int>(repeating: 0, count: n)\\n        var stack = Array<Log>()\\n        \\n        for log in logs {\\n            let currentLog = logToTuple(log: log)\\n            if currentLog.status == .start {\\n                stack.append(currentLog)\\n                continue\\n            }\\n            let lastLog = stack.removeLast()\\n            let deltaTime = currentLog.time - lastLog.time + 1\\n            ans[currentLog.functionID] += deltaTime\\n            if !stack.isEmpty {\\n                ans[stack.last!.functionID] -= deltaTime\\n            }\\n        }\\n        \\n        return ans\\n    }\\n    \\n    private func logToTuple(log: String) -> Log {\\n        var parts = log.split(separator: \":\")\\n        return (Int(parts[0])!,parts[1] == \"start\" ? FunctionStatus.start : FunctionStatus.end, Int(parts[2])!)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    \\n    enum FunctionStatus: Int {\\n        case start = 0\\n        case end = 1\\n    }\\n    \\n    typealias Log = (functionID: Int, status: FunctionStatus, time: Int)\\n    \\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\\n        \\n        var ans = Array<Int>(repeating: 0, count: n)\\n        var stack = Array<Log>()\\n        \\n        for log in logs {\\n            let currentLog = logToTuple(log: log)\\n            if currentLog.status == .start {\\n                stack.append(currentLog)\\n                continue\\n            }\\n            let lastLog = stack.removeLast()\\n            let deltaTime = currentLog.time - lastLog.time + 1\\n            ans[currentLog.functionID] += deltaTime\\n            if !stack.isEmpty {\\n                ans[stack.last!.functionID] -= deltaTime\\n            }\\n        }\\n        \\n        return ans\\n    }\\n    \\n    private func logToTuple(log: String) -> Log {\\n        var parts = log.split(separator: \":\")\\n        return (Int(parts[0])!,parts[1] == \"start\" ? FunctionStatus.start : FunctionStatus.end, Int(parts[2])!)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325757,
                "title": "python-one-pass-o-n-stack",
                "content": "\\n![image](https://assets.leetcode.com/users/images/3534d37a-e0fa-4b23-83b5-72b6c68cce70_1658645831.0935893.png)\\nKey points:\\n\\t1. Using a stack to simulate the whole process, just push the \\'start\\' logs.\\n\\t2. Overlapping *\\n\\tThe intervals must be like nested and one is totally included in another like [[1,5],[2,3]] and there won\\'t be cases like[[1,4],[2,5]], because the characteristic of single-thread CPU. \\n\\t3.How to avoid the overlapping: whenever we encounter a \\'end\\', which means we need to pop the stack, we just consider the second to last task in the stack. (after popping, the stack top)\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        cnt = [0] * n\\n        for log in logs:\\n            ID, action, time = log.split(\\':\\')\\n            ID = int(ID); time = int(time)\\n            if action == \\'start\\':\\n                stack.append([ID,time])\\n            elif action == \\'end\\':\\n                _, srt = stack.pop()\\n                add = time + 1 - srt\\n                cnt[ID] += add\\n                if stack:\\n                    cnt[stack[-1][0]] -= add\\n\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        cnt = [0] * n\\n        for log in logs:\\n            ID, action, time = log.split(\\':\\')\\n            ID = int(ID); time = int(time)\\n            if action == \\'start\\':\\n                stack.append([ID,time])\\n            elif action == \\'end\\':\\n                _, srt = stack.pop()\\n                add = time + 1 - srt\\n                cnt[ID] += add\\n                if stack:\\n                    cnt[stack[-1][0]] -= add\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198027,
                "title": "python-stack-easy-to-understand",
                "content": "In this solution, we calculate the time in place rather than waiting for the **endtime** of the process. \\n\\nWe always keep track of current time **currt**\\n\\n\\nWhenever a new process is started, we calculate the time taken by the previus process till now ( **timestamp -currt**) and and add that to the stack along with its **fid**. \\n\\nWhenever a process ends, we pop the the previous element from the stack(which is its starttime log) and update the **res[fid]** with **time -currt + 1**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\t    # Store total time of fid\\n        res = [0 for _ in range(n)]\\n\\t\\t# stack\\n        s = []\\n\\t\\t# store the current time\\n        currt = 0\\n\\t\\t\\n\\t\\t# iterate through the logs\\n        for log in logs: \\n                \\n\\t\\t\\t# Get thefid , state and timestamp from the log\\t\\n            fid, state, timestamp = log.split(\":\")\\n            \\n            fid = int(fid)\\n            timestamp = int(timestamp)\\n            \\n            if state == \"end\":\\n\\t\\t\\t\\t# since the process is ended, we pop out its start log\\n                s.pop()\\n\\t\\t\\t\\t# Update the time of the log. We add **+1** as the process gets over at the end of timestamp. \\n\\t\\t\\t\\t# So adding that **1**\\n                res[fid] += timestamp - currt+1\\n\\t\\t\\t\\t# updating the current time\\n                currt = timestamp + 1\\n            else:\\n                if (s):\\n\\t\\t\\t\\t     # if another process is strating before the previious process has been ended, \\n\\t\\t\\t\\t\\t # we get the fid anf time of previouse proces\\n                    fidprev,time = s[-1]\\n\\t\\t\\t\\t\\t# add the time taken by previouse process till now before a new process is spawned\\n                    res[fidprev] += timestamp - currt\\n\\t\\t\\t\\t# add the start log to the stack \\n                s.append((fid,timestamp))\\n\\t\\t\\t\\t# update the current time\\n                currt = timestamp\\n            \\n        return res\\n```\\n\\nTC: O(N)\\nSC: O(N)\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\t    # Store total time of fid\\n        res = [0 for _ in range(n)]\\n\\t\\t# stack\\n        s = []\\n\\t\\t# store the current time\\n        currt = 0\\n\\t\\t\\n\\t\\t# iterate through the logs\\n        for log in logs: \\n                \\n\\t\\t\\t# Get thefid , state and timestamp from the log\\t\\n            fid, state, timestamp = log.split(\":\")\\n            \\n            fid = int(fid)\\n            timestamp = int(timestamp)\\n            \\n            if state == \"end\":\\n\\t\\t\\t\\t# since the process is ended, we pop out its start log\\n                s.pop()\\n\\t\\t\\t\\t# Update the time of the log. We add **+1** as the process gets over at the end of timestamp. \\n\\t\\t\\t\\t# So adding that **1**\\n                res[fid] += timestamp - currt+1\\n\\t\\t\\t\\t# updating the current time\\n                currt = timestamp + 1\\n            else:\\n                if (s):\\n\\t\\t\\t\\t     # if another process is strating before the previious process has been ended, \\n\\t\\t\\t\\t\\t # we get the fid anf time of previouse proces\\n                    fidprev,time = s[-1]\\n\\t\\t\\t\\t\\t# add the time taken by previouse process till now before a new process is spawned\\n                    res[fidprev] += timestamp - currt\\n\\t\\t\\t\\t# add the start log to the stack \\n                s.append((fid,timestamp))\\n\\t\\t\\t\\t# update the current time\\n                currt = timestamp\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994143,
                "title": "python-stack-approach",
                "content": "The idea is to simulate the function calls and track their start and step-into times. \\nWhen we call another function, we interrupt current function execution and start executing new function, stepping down in our call stack. \\nLet\\'s track start time for the functions - when we call another function, we push function id and start time into the stack, for the caller function we increment its execution time by taking current timestamp and start timestamp difference.\\nWhen we finish the execution, we record time spent in the current function and pop element from the stack. We also update start time of the caller function.\\nWe shoulkd also keep in mind that the first function wouldn\\'t have it\\'s parent function. We could check if when we need to update parent function times or we could also push into our stack the \"main\" function record.\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        times = [0] * n\\n        current = []\\n        for log in logs:\\n            func, code, ts = log.split(\\':\\')\\n            func, ts = int(func), int(ts)\\n            isstart = code == \\'start\\'\\n            if isstart:\\n                if current:\\n                    func_id, started_at = current[-1]\\n                    times[func_id] += ts - started_at\\n                current.append([func, ts])\\n            else:\\n                func_id, started_at = current.pop()\\n                times[func_id] += ts - started_at + 1\\n                if current:\\n                    current[-1][1] = ts + 1\\n        return times\\n```\\n\\nAnd if we use \"main\" function we could get rid of extra checks:\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        times = [0] * n\\n        current = [[0, 0]]\\n        for log in logs:\\n            func, code, ts = log.split(\\':\\')\\n            func, ts = int(func), int(ts)\\n            isstart = code == \\'start\\'\\n            if isstart:\\n                func_id, started_at = current[-1]\\n                times[func_id] += ts - started_at\\n                current.append([func, ts])\\n            else:\\n                func_id, started_at = current.pop()\\n                times[func_id] += ts - started_at + 1\\n                current[-1][1] = ts + 1\\n        return times\\n```\\n\\nShall you have any questions - please feel free to ask. \\n\\nAnd upvote!",
                "solutionTags": [
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        times = [0] * n\\n        current = []\\n        for log in logs:\\n            func, code, ts = log.split(\\':\\')\\n            func, ts = int(func), int(ts)\\n            isstart = code == \\'start\\'\\n            if isstart:\\n                if current:\\n                    func_id, started_at = current[-1]\\n                    times[func_id] += ts - started_at\\n                current.append([func, ts])\\n            else:\\n                func_id, started_at = current.pop()\\n                times[func_id] += ts - started_at + 1\\n                if current:\\n                    current[-1][1] = ts + 1\\n        return times\\n```\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        times = [0] * n\\n        current = [[0, 0]]\\n        for log in logs:\\n            func, code, ts = log.split(\\':\\')\\n            func, ts = int(func), int(ts)\\n            isstart = code == \\'start\\'\\n            if isstart:\\n                func_id, started_at = current[-1]\\n                times[func_id] += ts - started_at\\n                current.append([func, ts])\\n            else:\\n                func_id, started_at = current.pop()\\n                times[func_id] += ts - started_at + 1\\n                current[-1][1] = ts + 1\\n        return times\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972690,
                "title": "c-readable-o-n-stack-solution",
                "content": "```public class Solution {\\n    public int[] ExclusiveTime(int n, IList<string> logs) {\\n        Stack<LogObj> stk = new();\\n        int[] res = new int[n];\\n        \\n        foreach (string log in logs) {\\n            LogObj newLog = new LogObj(log);\\n            \\n            if (newLog.IsStart) {\\n                if (stk.Count != 0) {\\n                    LogObj last = stk.Peek();\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Processes start at the beinning of the time block\\n                    int time = newLog.Time - last.Time;\\n                    \\n                    res[last.Funct] += time;\\n                }\\n                \\n                stk.Push(newLog);\\n                \\n            } else {\\n                LogObj last = stk.Pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Ending processes end at the end of the time block, so we add 1\\n                int time = (newLog.Time - last.Time) + 1;\\n                \\n                res[last.Funct] += time;\\n                \\n\\t\\t\\t\\t// If there is a process in the stack that will start after this one ends\\n\\t\\t\\t\\t// update its start time to the block after the current process ended\\n\\t\\t\\t\\t// since it ended at the end of the time block\\n                if (stk.Count != 0) {\\n                    LogObj prev = stk.Peek();\\n                    prev.Time = newLog.Time + 1;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\npublic class LogObj {\\n    public int Time;\\n    public int Funct;\\n    public bool IsStart;\\n    \\n    public LogObj(string l) {\\n        string[] val = l.Split(\\':\\');\\n        this.Funct = Int32.Parse(val[0]);\\n        this.IsStart = val[1] == \"start\";\\n        this.Time = Int32.Parse(val[2]);\\n    }\\n}",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int[] ExclusiveTime(int n, IList<string> logs) {\\n        Stack<LogObj> stk = new();\\n        int[] res = new int[n];\\n        \\n        foreach (string log in logs) {\\n            LogObj newLog = new LogObj(log);\\n            \\n            if (newLog.IsStart) {\\n                if (stk.Count != 0) {\\n                    LogObj last = stk.Peek();\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// Processes start at the beinning of the time block\\n                    int time = newLog.Time - last.Time;\\n                    \\n                    res[last.Funct] += time;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1940220,
                "title": "java-simple-stack-clearly-explained-o-n-time-and-space",
                "content": "```\\nclass Solution {\\n    /*\\n        -The total execution time for a function is (totalExecutionTime = endTime - startTime + 1)\\n        -Whenever a new function is called the other functions below in the call stack becomes\\n          inactive. \\n        -Executing time of a function is just  (totalExecutionTime - inactiveTime)\\n        -inactiveTime of a Function is the sum of the totalExecution time of all other functions\\n         that are above it in the call stack\\n    */\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        Stack<int[]> st = new Stack<>(); //[id,startTime, inActiveTime]\\n        \\n        for(String log: logs){\\n            String[] info = log.split(\":\");\\n            if(\"start\".equals(info[1])){\\n                st.push(new int[]{Integer.parseInt(info[0]), Integer.parseInt(info[2]),0});\\n            }else{\\n                int curTime = Integer.parseInt(info[2]);\\n                \\n                int[] startPair = st.pop();//stop executing the func\\n                int totalExecTime = curTime - startPair[1] + 1;//end - start + 1\\n                int activeTime = totalExecTime - startPair[2];//remove the inactive time\\n                result[startPair[0]] += activeTime;\\n                \\n                //update the inactive time of the currently executing func (i.e the func that is now \\n                //at the top of the stack)\\n                if(!st.isEmpty()){\\n                    st.peek()[2] += totalExecTime;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n        -The total execution time for a function is (totalExecutionTime = endTime - startTime + 1)\\n        -Whenever a new function is called the other functions below in the call stack becomes\\n          inactive. \\n        -Executing time of a function is just  (totalExecutionTime - inactiveTime)\\n        -inactiveTime of a Function is the sum of the totalExecution time of all other functions\\n         that are above it in the call stack\\n    */\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        Stack<int[]> st = new Stack<>(); //[id,startTime, inActiveTime]\\n        \\n        for(String log: logs){\\n            String[] info = log.split(\":\");\\n            if(\"start\".equals(info[1])){\\n                st.push(new int[]{Integer.parseInt(info[0]), Integer.parseInt(info[2]),0});\\n            }else{\\n                int curTime = Integer.parseInt(info[2]);\\n                \\n                int[] startPair = st.pop();//stop executing the func\\n                int totalExecTime = curTime - startPair[1] + 1;//end - start + 1\\n                int activeTime = totalExecTime - startPair[2];//remove the inactive time\\n                result[startPair[0]] += activeTime;\\n                \\n                //update the inactive time of the currently executing func (i.e the func that is now \\n                //at the top of the stack)\\n                if(!st.isEmpty()){\\n                    st.peek()[2] += totalExecTime;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787506,
                "title": "python-with-comments-easy-to-understand-online-algorithm-data-stream",
                "content": "This solution is different from the \"offline update\" method, which only updates total_execution_time during \"end\" event.\\n\\n* This is an \"online update\" or \"data stream\" method. An interviewer might ask a follow up question like, \\n\"let\\'s change the application scenario a bit. \\n**what if the logs are sent to you in real time?**\\nI want you to change your algorithm to output the total execution time for all functions up until the time when a log is reported to you.\"\\n\\n* Based on this requirement and the observation that  **the function on top of the stack is being processed**, we need to update the total execution time for both \"start\" and \"end\" events. At each key event, we compute the most recent interval and update the result based on it. The most recent interval can be computed be cur_time and pre_time. This time interval will be added to the function sitting on top of stack, if any.\\n\\n\\nHint: To compute the intervals, one needs to preform \"end_time2 - end_time1\" and \"start_time2 - end_time1\" ...\\n\\nThough, I don\\'t appreciate **how end_time is defined differently from start_time in the input**. In the input, start_time represents \"the time a function starts\" while end_time represents \"the time a function will end in one more time unit\". So I preprocess all \"end_time\" by adding one. After preprocessing, both start_time and end_time represent \"the time when a function start or end\". This saved a few lines of code for me.\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        total_execution_time = [0] * n\\n        # assume log is sorted based on timestamp\\n        # otherwise just sort it\\n        \\n        stack_func = []\\n        for index_log in range(len(logs)):\\n            func_id, is_start, timestamp = self.parse_log(logs[index_log])\\n            # add the most recent interval to the top stack function\\n            if stack_func:\\n                (func_id_top, is_start_top, timestamp_top) = stack_func[-1]\\n                total_execution_time[func_id_top] += timestamp - timestamp_pre\\n            # update func stack\\n            if is_start:\\n                stack_func.append((func_id, is_start, timestamp))\\n            else:\\n                stack_func.pop()\\n            # store last event, in order to compute the most recent interval\\n            timestamp_pre = timestamp\\n         \\n        return total_execution_time\\n                \\n    def parse_log(self, log):\\n        func_id, is_start, timestamp = log.split(\":\")\\n        func_id = int(func_id)\\n        is_start = True if is_start == \"start\" else False\\n        timestamp = int(timestamp) if is_start else int(timestamp) + 1\\n        return (func_id, is_start, timestamp)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        total_execution_time = [0] * n\\n        # assume log is sorted based on timestamp\\n        # otherwise just sort it\\n        \\n        stack_func = []\\n        for index_log in range(len(logs)):\\n            func_id, is_start, timestamp = self.parse_log(logs[index_log])\\n            # add the most recent interval to the top stack function\\n            if stack_func:\\n                (func_id_top, is_start_top, timestamp_top) = stack_func[-1]\\n                total_execution_time[func_id_top] += timestamp - timestamp_pre\\n            # update func stack\\n            if is_start:\\n                stack_func.append((func_id, is_start, timestamp))\\n            else:\\n                stack_func.pop()\\n            # store last event, in order to compute the most recent interval\\n            timestamp_pre = timestamp\\n         \\n        return total_execution_time\\n                \\n    def parse_log(self, log):\\n        func_id, is_start, timestamp = log.split(\":\")\\n        func_id = int(func_id)\\n        is_start = True if is_start == \"start\" else False\\n        timestamp = int(timestamp) if is_start else int(timestamp) + 1\\n        return (func_id, is_start, timestamp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616357,
                "title": "c-stack-tc-o-n-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> getTokens(string s) {\\n        stringstream ss(s);\\n        string cur;\\n        vector<string> res;\\n        while(getline(ss, cur, \\':\\')) {\\n            res.push_back(cur);\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        stack<pair<int, int>> stk;\\n        vector<int> result(n, 0);\\n        for (auto log: logs) {\\n            auto res = getTokens(log);\\n            if (res[1] == \"start\") {\\n                stk.push({stoi(res[0]), stoi(res[2])});\\n            } else {\\n                auto node = stk.top();\\n                stk.pop();\\n                int execTime = stoi(res[2]) - node.second + 1;\\n                result[node.first] += execTime;\\n                if (stk.size() > 0) {\\n                    result[stk.top().first] -= execTime;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> getTokens(string s) {\\n        stringstream ss(s);\\n        string cur;\\n        vector<string> res;\\n        while(getline(ss, cur, \\':\\')) {\\n            res.push_back(cur);\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        stack<pair<int, int>> stk;\\n        vector<int> result(n, 0);\\n        for (auto log: logs) {\\n            auto res = getTokens(log);\\n            if (res[1] == \"start\") {\\n                stk.push({stoi(res[0]), stoi(res[2])});\\n            } else {\\n                auto node = stk.top();\\n                stk.pop();\\n                int execTime = stoi(res[2]) - node.second + 1;\\n                result[node.first] += execTime;\\n                if (stk.size() > 0) {\\n                    result[stk.top().first] -= execTime;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593728,
                "title": "java-stack",
                "content": "```\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int v[]=new int[n];\\n        Stack<Node> stack=new Stack();\\n        for(String str:logs){\\n            Node node=new Node(str);\\n            if(node.status==0){\\n                int dur=node.time-stack.pop().time+1;\\n                v[node.id]+=dur;\\n                if(!stack.isEmpty()){\\n                    stack.peek().time=node.time+1;\\n                }\\n            }else{\\n                if(!stack.isEmpty()){\\n                    int dur=node.time-stack.peek().time;\\n                    v[stack.peek().id]+=dur;\\n                }\\n                stack.add(node);\\n            }\\n        }\\n        return v;\\n    }\\n}\\n\\nclass Node{\\n    int id;\\n    int status;\\n    int time;\\n    public Node(String str){\\n        String ss[]=str.split(\":\");\\n        id=Integer.valueOf(ss[0]);\\n        status=ss[1].equals(\"start\")?1:0;\\n        time=Integer.valueOf(ss[2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int v[]=new int[n];\\n        Stack<Node> stack=new Stack();\\n        for(String str:logs){\\n            Node node=new Node(str);\\n            if(node.status==0){\\n                int dur=node.time-stack.pop().time+1;\\n                v[node.id]+=dur;\\n                if(!stack.isEmpty()){\\n                    stack.peek().time=node.time+1;\\n                }\\n            }else{\\n                if(!stack.isEmpty()){\\n                    int dur=node.time-stack.peek().time;\\n                    v[stack.peek().id]+=dur;\\n                }\\n                stack.add(node);\\n            }\\n        }\\n        return v;\\n    }\\n}\\n\\nclass Node{\\n    int id;\\n    int status;\\n    int time;\\n    public Node(String str){\\n        String ss[]=str.split(\":\");\\n        id=Integer.valueOf(ss[0]);\\n        status=ss[1].equals(\"start\")?1:0;\\n        time=Integer.valueOf(ss[2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577858,
                "title": "c-the-idea-is-simple-there-is-at-most-one-function-running-at-a-time",
                "content": "According to the problem description, we can have at most 1 function running at the same time.\\nThat means in terms of exclusive time calculation, any \"start\" log would immediately stop any running function.\\n\\nThe rules can be summerized as follows:\\n1. when the log is an `end` , it ends the function on top of the stack. The elapsed time is (log timestamp - previous timestamp + 1) (+1 because it is the `end` of the time)\\n2. whe th elog is a `start`, it pauses the function on top of the stack, which in terms of time calculation also means to END the the function on top of the stakc. The elapsed time is (log timestamp - previous timestamp) (no need to +1 because it is the `beginning` of the time)\\n\\nThat\\'s all. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> ret(n);\\n        stack<int> ids;\\n        int prev_time = 0;\\n        for(int i=0; i<logs.size(); i++) {\\n            string log = logs[i];\\n            size_t first = log.find_first_of(\":\");\\n            size_t second = log.find_last_of(\":\");\\n            int id = stoi(log.substr(0, first));\\n            string event = log.substr(first+1, second-first-1);\\n            int timestamp = stoi(log.substr(second+1));\\n            if( event == \"end\" ) {\\n                ret[ids.top()] += (timestamp - prev_time+1);\\n                ids.pop();\\n                prev_time = timestamp + 1;\\n            } else if ( event == \"start\" ) {\\n                if(!ids.empty()) {\\n                    ret[ids.top()] += (timestamp - prev_time);\\n                }\\n                ids.push(id);\\n                prev_time = timestamp;\\n                \\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> ret(n);\\n        stack<int> ids;\\n        int prev_time = 0;\\n        for(int i=0; i<logs.size(); i++) {\\n            string log = logs[i];\\n            size_t first = log.find_first_of(\":\");\\n            size_t second = log.find_last_of(\":\");\\n            int id = stoi(log.substr(0, first));\\n            string event = log.substr(first+1, second-first-1);\\n            int timestamp = stoi(log.substr(second+1));\\n            if( event == \"end\" ) {\\n                ret[ids.top()] += (timestamp - prev_time+1);\\n                ids.pop();\\n                prev_time = timestamp + 1;\\n            } else if ( event == \"start\" ) {\\n                if(!ids.empty()) {\\n                    ret[ids.top()] += (timestamp - prev_time);\\n                }\\n                ids.push(id);\\n                prev_time = timestamp;\\n                \\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452690,
                "title": "py-py3-solution-using-stack-w-comments",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        # Init\\n        fid = []\\n        ftime = [0] * n\\n        prev_ts = 0\\n        \\n        # For all logs\\n        for log in logs:\\n            \\n            # Split into, id, type of operation and time\\n            # in correct format\\n            id, mode, ts = log.split(\":\")\\n            id, ts = int(id), int(ts)\\n            \\n            # If a function is starting\\n            if mode == \"start\":\\n                \\n                # If there is already a function, and the current\\n                # function is starting, then calculate time of the\\n                # previous function w.r.t current time\\n                if fid:\\n                    ftime[fid[-1]] += ts - prev_ts # # start_time - previous_start_time\\n                \\n                # Add the current function ID on stack,\\n                # this maintains the order in which the\\n                # functions are called\\n                fid.append(id)\\n                \\n                # NOTE: Here, we are storing the start time,\\n                # hence no need to add 1 to it, as the\\n                # current function starts at the time \"ts\"\\n                prev_ts = ts # start_time\\n            \\n            # If function is ending\\n            else:\\n                \\n                # Pop the entry from the stack.\\n                if fid: fid.pop()\\n                \\n                # Since the start and end call must be mutually\\n                # inclusive, we add 1 to the difference between\\n                # the end and start time. The other take on the\\n                # same theory is that the current function ends\\n                # at time \"ts+1\".\\n                ftime[id] += (ts + 1) - prev_ts # end_time - start_time\\n                \\n                # NOTE: Here, we are storing the end time,\\n                # hence add 1 to it, as the currrent function\\n                # ends at time \"ts+1\".\\n                prev_ts = ts + 1 # end_time\\n                \\n        return ftime\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        # Init\\n        fid = []\\n        ftime = [0] * n\\n        prev_ts = 0\\n        \\n        # For all logs\\n        for log in logs:\\n            \\n            # Split into, id, type of operation and time\\n            # in correct format\\n            id, mode, ts = log.split(\":\")\\n            id, ts = int(id), int(ts)\\n            \\n            # If a function is starting\\n            if mode == \"start\":\\n                \\n                # If there is already a function, and the current\\n                # function is starting, then calculate time of the\\n                # previous function w.r.t current time\\n                if fid:\\n                    ftime[fid[-1]] += ts - prev_ts # # start_time - previous_start_time\\n                \\n                # Add the current function ID on stack,\\n                # this maintains the order in which the\\n                # functions are called\\n                fid.append(id)\\n                \\n                # NOTE: Here, we are storing the start time,\\n                # hence no need to add 1 to it, as the\\n                # current function starts at the time \"ts\"\\n                prev_ts = ts # start_time\\n            \\n            # If function is ending\\n            else:\\n                \\n                # Pop the entry from the stack.\\n                if fid: fid.pop()\\n                \\n                # Since the start and end call must be mutually\\n                # inclusive, we add 1 to the difference between\\n                # the end and start time. The other take on the\\n                # same theory is that the current function ends\\n                # at time \"ts+1\".\\n                ftime[id] += (ts + 1) - prev_ts # end_time - start_time\\n                \\n                # NOTE: Here, we are storing the end time,\\n                # hence add 1 to it, as the currrent function\\n                # ends at time \"ts+1\".\\n                prev_ts = ts + 1 # end_time\\n                \\n        return ftime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388410,
                "title": "java-stack-solution-with-explanation",
                "content": "Use a stack to track the function id\\n\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Integer> stack = new Stack<>();\\n        int[] ans = new int[n];\\n        int prev = 0;\\n        for (String log : logs) {\\n            String[] logArray = log.split(\":\");\\n            \\n            int jobId = Integer.valueOf(logArray[0]);\\n            String state = logArray[1];\\n            int timeStamp = Integer.valueOf(logArray[2]);\\n            \\n\\t\\t\\t// For the start of first function after idle time (include first function)\\n            if (stack.isEmpty()) {\\n                stack.push(jobId);\\n                prev = timeStamp; // keep track of start time\\n                continue;\\n            }\\n            \\n            if (state.equals(\"start\")) {\\n                int interval = timeStamp  - prev; // For the case when there is another function running before current start\\n                ans[stack.peek()] += interval; // Get previous running function id and record interval\\n                stack.push(jobId); // push new start function id\\n                prev = timeStamp; // track the new start time\\n            } else {\\n                int interval = timeStamp - prev + 1; // For the case of end, +1 as function stops at the end of current function\\n                ans[stack.pop()] += interval; // Add interval, but remove function id from top as it has ended.\\n                prev = timeStamp + 1; // use the start of next timestamp as current timestamp has ended\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Integer> stack = new Stack<>();\\n        int[] ans = new int[n];\\n        int prev = 0;\\n        for (String log : logs) {\\n            String[] logArray = log.split(\":\");\\n            \\n            int jobId = Integer.valueOf(logArray[0]);\\n            String state = logArray[1];\\n            int timeStamp = Integer.valueOf(logArray[2]);\\n            \\n\\t\\t\\t// For the start of first function after idle time (include first function)\\n            if (stack.isEmpty()) {\\n                stack.push(jobId);\\n                prev = timeStamp; // keep track of start time\\n                continue;\\n            }\\n            \\n            if (state.equals(\"start\")) {\\n                int interval = timeStamp  - prev; // For the case when there is another function running before current start\\n                ans[stack.peek()] += interval; // Get previous running function id and record interval\\n                stack.push(jobId); // push new start function id\\n                prev = timeStamp; // track the new start time\\n            } else {\\n                int interval = timeStamp - prev + 1; // For the case of end, +1 as function stops at the end of current function\\n                ans[stack.pop()] += interval; // Add interval, but remove function id from top as it has ended.\\n                prev = timeStamp + 1; // use the start of next timestamp as current timestamp has ended\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066160,
                "title": "kotlin-stack",
                "content": "The little trick here to make the code more consistent is to increment by one all \"end events\" as we parse them, since the end bound is inclusive. This way, we use `time - previousTime` to determine how long the caller function spent on its own. Then it\\'s just a matter of identifying which function was the caller and we find this information by using a stack.\\n\\n```\\ndata class Log(val id: Int, val type: String, val time: Int) {\\n\\tcompanion object {\\n\\t\\tfun from(s: String): Log {\\n\\t\\t\\tval parts = s.split(\":\")\\n\\t\\t\\treturn Log(parts[0].toInt(), parts[1], if (parts[1] == \"start\") parts[2].toInt() else parts[2].toInt() + 1)\\n\\t\\t}\\n\\t}\\n}\\n\\nfun exclusiveTime(n: Int, rawLogs: List<String>): IntArray {\\n\\tval times = IntArray(n)\\n\\n\\tval stack = Stack<Int>()\\n\\tvar previousTime = 0\\n\\tfor (rawLog in rawLogs) {\\n\\t\\tval (id, type, time) = Log.from(rawLog)\\n\\t\\tif (stack.isNotEmpty()) times[stack.peek()] += time - previousTime\\n\\t\\tif (type == \"start\") stack.push(id) else stack.pop()\\n\\t\\tpreviousTime = time\\n\\t}\\n\\n\\treturn times\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndata class Log(val id: Int, val type: String, val time: Int) {\\n\\tcompanion object {\\n\\t\\tfun from(s: String): Log {\\n\\t\\t\\tval parts = s.split(\":\")\\n\\t\\t\\treturn Log(parts[0].toInt(), parts[1], if (parts[1] == \"start\") parts[2].toInt() else parts[2].toInt() + 1)\\n\\t\\t}\\n\\t}\\n}\\n\\nfun exclusiveTime(n: Int, rawLogs: List<String>): IntArray {\\n\\tval times = IntArray(n)\\n\\n\\tval stack = Stack<Int>()\\n\\tvar previousTime = 0\\n\\tfor (rawLog in rawLogs) {\\n\\t\\tval (id, type, time) = Log.from(rawLog)\\n\\t\\tif (stack.isNotEmpty()) times[stack.peek()] += time - previousTime\\n\\t\\tif (type == \"start\") stack.push(id) else stack.pop()\\n\\t\\tpreviousTime = time\\n\\t}\\n\\n\\treturn times\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718836,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\n    struct Func {\\n        int id;\\n        string status;\\n        int timestamp;\\n    };\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        \\n        vector<int>res(n, 0);\\n        int m = logs.size();\\n        stack<Func>stk;\\n        \\n        for (int i = 0; i < m; i++) {\\n            stringstream ss(logs[i]);\\n            string t1, t2, t3;\\n            getline(ss, t1, \\':\\');\\n            getline(ss, t2, \\':\\');\\n            getline(ss, t3, \\':\\');\\n            Func item = {stoi(t1), t2, stoi(t3)};\\n            \\n            if (item.status == \"start\") {\\n                stk.push(item);\\n            } else {\\n                int time = item.timestamp - stk.top().timestamp + 1;\\n                res[item.id] += time;\\n                stk.pop();\\n                if (!stk.empty()) {\\n                    res[stk.top().id] -= time;\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct Func {\\n        int id;\\n        string status;\\n        int timestamp;\\n    };\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        \\n        vector<int>res(n, 0);\\n        int m = logs.size();\\n        stack<Func>stk;\\n        \\n        for (int i = 0; i < m; i++) {\\n            stringstream ss(logs[i]);\\n            string t1, t2, t3;\\n            getline(ss, t1, \\':\\');\\n            getline(ss, t2, \\':\\');\\n            getline(ss, t3, \\':\\');\\n            Func item = {stoi(t1), t2, stoi(t3)};\\n            \\n            if (item.status == \"start\") {\\n                stk.push(item);\\n            } else {\\n                int time = item.timestamp - stk.top().timestamp + 1;\\n                res[item.id] += time;\\n                stk.pop();\\n                if (!stk.empty()) {\\n                    res[stk.top().id] -= time;\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455912,
                "title": "python-stack-solution-with-clean-explanations",
                "content": "Explanations are included in the solution as comments.\\n\\nA few important things keep in mind, \\n1) start time and end time are calculated differently in the problem, which really needs to be fixed to avoid ambiguity.\\n\\n\\tFor example with \"0:start:0\" and \"0:end:3\", it really means that,\\n\\t\\n\\tfunction 0 starts at beginning of timestamp = 0, and ends at the ending of timestamp = 3, which undergos 4 intervals:\\n\\t[0, 1], [1, 2], [2, 3], and [3, 4]\\n\\t\\n\\tThis is the sole reason, when we pop out from stack, we need \"timestamp - prev_time + 1\"\\n\\n2) Another thing that is confusing is that there are certain unallowed inputs:\\n\\n\\tFor example, one cannot have the ending of a process that is not on top of the stack, or that is not the current process. If you think about it, it is only natural. In other words, following inputs are NOT considered:\\n\\t\\n\\tInvalid inputs:\\n\\tn = 2\\n\\tlogs = [\"0:start:0\", \"1:start:1\", \"0:end:3\", \"1:end:4\"] \\n\\t\\n```\\n\\t         ======= process 1 ==========\\n\\t====== process 0 =========\\n```\\n\\t\\nHope this helps!\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, N: int, logs: List[str]) -> List[int]:\\n        ans = [0]*N\\n        prev_time = 0\\n        stack = []  # functional stack \\n        \\n        for log in logs:\\n            func_id, func_type, timestamp = log.split(\":\")\\n            func_id = int(func_id)\\n            timestamp = int(timestamp)\\n            \\n            if func_type == \"start\":\\n                \\n                # update time spent if already running a process\\n                if stack:\\n                    ans[stack[-1]] += timestamp - prev_time\\n                    \\n                # starting new process\\n                stack.append(func_id)\\n                prev_time = timestamp\\n                \\n            else:\\n                \\n                # terminating current process\\n                ans[stack.pop()] += timestamp - prev_time + 1\\n                prev_time = timestamp + 1\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\t         ======= process 1 ==========\\n\\t====== process 0 =========\\n```\n```\\nclass Solution:\\n    def exclusiveTime(self, N: int, logs: List[str]) -> List[int]:\\n        ans = [0]*N\\n        prev_time = 0\\n        stack = []  # functional stack \\n        \\n        for log in logs:\\n            func_id, func_type, timestamp = log.split(\":\")\\n            func_id = int(func_id)\\n            timestamp = int(timestamp)\\n            \\n            if func_type == \"start\":\\n                \\n                # update time spent if already running a process\\n                if stack:\\n                    ans[stack[-1]] += timestamp - prev_time\\n                    \\n                # starting new process\\n                stack.append(func_id)\\n                prev_time = timestamp\\n                \\n            else:\\n                \\n                # terminating current process\\n                ans[stack.pop()] += timestamp - prev_time + 1\\n                prev_time = timestamp + 1\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 177873,
                "title": "simple-python-stack-solution",
                "content": "```\\ndef exclusiveTime(self, n, logs):\\n    stack = []\\n    times = [0] * n\\n    for log in logs:\\n        split = log.split(\\':\\')\\n        id, event, t = int(split[0]), split[1], int(split[2])\\n        if event == \\'start\\':\\n            stack.append([id, t, 0])\\n        else:\\n            sId, sStart, sOffset = stack.pop()\\n            dt = t - sStart + 1 - sOffset\\n            times[sId] += dt\\n            if stack:\\n                stack[-1][2] += (dt + sOffset)\\n    return times",
                "solutionTags": [],
                "code": "```\\ndef exclusiveTime(self, n, logs):\\n    stack = []\\n    times = [0] * n\\n    for log in logs:\\n        split = log.split(\\':\\')\\n        id, event, t = int(split[0]), split[1], int(split[2])\\n        if event == \\'start\\':\\n            stack.append([id, t, 0])\\n        else:\\n            sId, sStart, sOffset = stack.pop()\\n            dt = t - sStart + 1 - sOffset\\n            times[sId] += dt\\n            if stack:\\n                stack[-1][2] += (dt + sOffset)\\n    return times",
                "codeTag": "Python3"
            },
            {
                "id": 2513428,
                "title": "python-simple-stack-solution",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        tm = [0]*n\\n        st = []\\n        latestTime = 0\\n        \\n        for i in logs:\\n            ar = i.split(\":\")\\n            \\n            if ar[1] == \"start\":\\n                if len(st) != 0:\\n                    tm[int(st[-1][0])] += int(ar[2])-latestTime\\n                st.append((ar[0], ar[2]))\\n                \\n                latestTime = int(ar[2])\\n            else:\\n                tm[int(ar[0])] += int(ar[2])-latestTime+1\\n                st.pop()\\n                \\n                latestTime = int(ar[2])+1\\n                \\n        return tm",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        tm = [0]*n\\n        st = []\\n        latestTime = 0\\n        \\n        for i in logs:\\n            ar = i.split(\":\")\\n            \\n            if ar[1] == \"start\":\\n                if len(st) != 0:\\n                    tm[int(st[-1][0])] += int(ar[2])-latestTime\\n                st.append((ar[0], ar[2]))\\n                \\n                latestTime = int(ar[2])\\n            else:\\n                tm[int(ar[0])] += int(ar[2])-latestTime+1\\n                st.pop()\\n                \\n                latestTime = int(ar[2])+1\\n                \\n        return tm",
                "codeTag": "Java"
            },
            {
                "id": 2445464,
                "title": "python-simple-solution-with-stack-using-defaultdict",
                "content": "Please upvote!!!\\n\\nTime: O(n), since you need to travel the entire list of logs\\nSpace: O(n/2) so O(n), if you have n/2 start processes, then you would have n/2 end processes too. So at most you have n/2 processes in stack. \\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        output = [0] * n\\n        \\n        # initialize stack for each function_id\\n        record = collections.defaultdict(list)\\n        \\n        for log in logs:\\n            f_id, f_type, ts = log.split(\\':\\')\\n            \\n            #convert ts into integer for array indexing\\n            cur_ts = int(ts)\\n            \\n            # start is straightforward, just push it to stack\\n            if f_type == \\'start\\':\\n                record[f_id].append(cur_ts)\\n                \\n            # end needs to adjust any start ts if records are present\\n            elif f_type == \\'end\\':\\n                prev_ts = record[f_id].pop()\\n                diff = cur_ts - prev_ts + 1\\n                output[int(f_id)] += diff\\n                \\n                # adjust time elapsed for each pending process in stack\\n                for key in record:\\n                    record[key] = [item + diff for item in record[key]]\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        output = [0] * n\\n        \\n        # initialize stack for each function_id\\n        record = collections.defaultdict(list)\\n        \\n        for log in logs:\\n            f_id, f_type, ts = log.split(\\':\\')\\n            \\n            #convert ts into integer for array indexing\\n            cur_ts = int(ts)\\n            \\n            # start is straightforward, just push it to stack\\n            if f_type == \\'start\\':\\n                record[f_id].append(cur_ts)\\n                \\n            # end needs to adjust any start ts if records are present\\n            elif f_type == \\'end\\':\\n                prev_ts = record[f_id].pop()\\n                diff = cur_ts - prev_ts + 1\\n                output[int(f_id)] += diff\\n                \\n                # adjust time elapsed for each pending process in stack\\n                for key in record:\\n                    record[key] = [item + diff for item in record[key]]\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237467,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        Stack<String[]> stack = new Stack<>();\\n        for(String log : logs) {\\n            String[] logDetails = log.split(\":\");\\n            if(logDetails[1].equalsIgnoreCase(\"start\")) {\\n                stack.push(logDetails);\\n            } else {\\n                int taskId = Integer.parseInt(logDetails[0]);\\n                int endTime = Integer.parseInt(logDetails[2]);\\n                String[] prevLogDetails = stack.pop();\\n                int startTime = Integer.parseInt(prevLogDetails[2]);\\n                int executionTime = endTime - startTime + 1;\\n                result[taskId] += executionTime;\\n                if(!stack.isEmpty()) {\\n                    int id = Integer.parseInt(stack.peek()[0]);\\n                    result[id] -= executionTime;\\n                }\\n            }\\n        }\\n        return result; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        Stack<String[]> stack = new Stack<>();\\n        for(String log : logs) {\\n            String[] logDetails = log.split(\":\");\\n            if(logDetails[1].equalsIgnoreCase(\"start\")) {\\n                stack.push(logDetails);\\n            } else {\\n                int taskId = Integer.parseInt(logDetails[0]);\\n                int endTime = Integer.parseInt(logDetails[2]);\\n                String[] prevLogDetails = stack.pop();\\n                int startTime = Integer.parseInt(prevLogDetails[2]);\\n                int executionTime = endTime - startTime + 1;\\n                result[taskId] += executionTime;\\n                if(!stack.isEmpty()) {\\n                    int id = Integer.parseInt(stack.peek()[0]);\\n                    result[id] -= executionTime;\\n                }\\n            }\\n        }\\n        return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097704,
                "title": "java-2-stack-solution-comments-good-naming",
                "content": "```\\nint[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Execution> callStack = new Stack<>();\\n        for (String log : logs) {\\n            callStack.push(new Execution(log));\\n        }\\n\\n        int[] solution = new int[n];\\n\\n        Stack<Execution> backgroundExecution = new Stack<>();\\n\\n        while (!callStack.isEmpty()) {\\n            Execution executing = callStack.pop();\\n            if (callStack.peek().isEnd) {\\n                //send the current execution to background because something executed between its start and end\\n                backgroundExecution.push(executing);\\n            } else {\\n                //execution Stack will be a start, so we calculate how long it took\\n                int executionTime = 1 + (executing.time - callStack.pop().time);\\n                //update solution after processing\\n                solution[executing.id] += executionTime;\\n                //clean the background and update the time removing the subprocess execution time\\n                while (!backgroundExecution.isEmpty()) {\\n                    Execution toExecute = backgroundExecution.pop();\\n                    toExecute.time -= executionTime;\\n                    callStack.push(toExecute);\\n                }\\n            }\\n        }\\n\\n        return solution;\\n    }\\n\\n    static class Execution {\\n        int id;\\n        boolean isEnd;\\n        int time;\\n\\n        public Execution(String log) {\\n            String[] execution = log.split(\":\");\\n            this.id = Integer.parseInt(execution[0]);\\n            this.isEnd = execution[1].equals(\"end\");\\n            this.time = Integer.parseInt(execution[2]);\\n        }\\n\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nint[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Execution> callStack = new Stack<>();\\n        for (String log : logs) {\\n            callStack.push(new Execution(log));\\n        }\\n\\n        int[] solution = new int[n];\\n\\n        Stack<Execution> backgroundExecution = new Stack<>();\\n\\n        while (!callStack.isEmpty()) {\\n            Execution executing = callStack.pop();\\n            if (callStack.peek().isEnd) {\\n                //send the current execution to background because something executed between its start and end\\n                backgroundExecution.push(executing);\\n            } else {\\n                //execution Stack will be a start, so we calculate how long it took\\n                int executionTime = 1 + (executing.time - callStack.pop().time);\\n                //update solution after processing\\n                solution[executing.id] += executionTime;\\n                //clean the background and update the time removing the subprocess execution time\\n                while (!backgroundExecution.isEmpty()) {\\n                    Execution toExecute = backgroundExecution.pop();\\n                    toExecute.time -= executionTime;\\n                    callStack.push(toExecute);\\n                }\\n            }\\n        }\\n\\n        return solution;\\n    }\\n\\n    static class Execution {\\n        int id;\\n        boolean isEnd;\\n        int time;\\n\\n        public Execution(String log) {\\n            String[] execution = log.split(\":\");\\n            this.id = Integer.parseInt(execution[0]);\\n            this.isEnd = execution[1].equals(\"end\");\\n            this.time = Integer.parseInt(execution[2]);\\n        }\\n\\n    }\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1978876,
                "title": "cpp-stack",
                "content": "```\\nclass Util {\\npublic:\\n\\tint id;\\n\\tint startTime;\\n\\tint childTime;\\n\\tUtil(int id, int startTime, int childTime) {\\n\\t\\tthis->id = id;\\n\\t\\tthis->startTime = startTime;\\n\\t\\tthis->childTime = childTime;\\n\\t}\\n};\\n\\nvector<int> exclusiveTimeOfFunctions(int n, vector<string> arr) {\\n\\t//meditate, think why we use stack here\\n\\tstack<Util> st;\\n\\tvector<int> ans(n);\\n\\n\\tfor (string log : arr) {\\n\\t\\t//split kro log ko.\\n\\t\\tauto find1 = log.find(\":\");\\n\\t\\tauto find2 = log.find(\":\", find1 + 1);\\n\\t\\tint id = stoi(log.substr(0, find1));\\n\\t\\tstring type = log.substr(log.find(\":\") + 1, find2 - find1 - 1);\\n\\t\\tint time = stoi(log.substr(find2 + 1));\\n\\t\\t// cout << id << \" \" << type << \" \" << time << endl;\\n\\t\\tif (type == \"start\") {\\n\\t\\t\\t//directly stack me push krdo\\n\\t\\t\\tst.push(Util(id, time, 0));\\n\\t\\t}\\n\\t\\telse { //type == \"end\"\\n\\t\\t\\tUtil obj = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tint interval = time - obj.startTime + 1;\\n\\t\\t\\t// cout << interval << endl;\\n\\t\\t\\tint exactTime = interval - obj.childTime;\\n\\t\\t\\t// cout << exactTime << endl;\\n\\n\\t\\t\\t//add kro iss id ke answer ko in ans array\\n\\t\\t\\tans[obj.id] += exactTime;\\n\\n\\t\\t\\tif (!st.empty()) { //means iska koi parent hai toh parent ke childTime me iska time add krdo\\n\\t\\t\\t\\tst.top().childTime += interval;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Util {\\npublic:\\n\\tint id;\\n\\tint startTime;\\n\\tint childTime;\\n\\tUtil(int id, int startTime, int childTime) {\\n\\t\\tthis->id = id;\\n\\t\\tthis->startTime = startTime;\\n\\t\\tthis->childTime = childTime;\\n\\t}\\n};\\n\\nvector<int> exclusiveTimeOfFunctions(int n, vector<string> arr) {\\n\\t//meditate, think why we use stack here\\n\\tstack<Util> st;\\n\\tvector<int> ans(n);\\n\\n\\tfor (string log : arr) {\\n\\t\\t//split kro log ko.\\n\\t\\tauto find1 = log.find(\":\");\\n\\t\\tauto find2 = log.find(\":\", find1 + 1);\\n\\t\\tint id = stoi(log.substr(0, find1));\\n\\t\\tstring type = log.substr(log.find(\":\") + 1, find2 - find1 - 1);\\n\\t\\tint time = stoi(log.substr(find2 + 1));\\n\\t\\t// cout << id << \" \" << type << \" \" << time << endl;\\n\\t\\tif (type == \"start\") {\\n\\t\\t\\t//directly stack me push krdo\\n\\t\\t\\tst.push(Util(id, time, 0));\\n\\t\\t}\\n\\t\\telse { //type == \"end\"\\n\\t\\t\\tUtil obj = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tint interval = time - obj.startTime + 1;\\n\\t\\t\\t// cout << interval << endl;\\n\\t\\t\\tint exactTime = interval - obj.childTime;\\n\\t\\t\\t// cout << exactTime << endl;\\n\\n\\t\\t\\t//add kro iss id ke answer ko in ans array\\n\\t\\t\\tans[obj.id] += exactTime;\\n\\n\\t\\t\\tif (!st.empty()) { //means iska koi parent hai toh parent ke childTime me iska time add krdo\\n\\t\\t\\t\\tst.top().childTime += interval;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n",
                "codeTag": "C++"
            },
            {
                "id": 1913651,
                "title": "java-easy-clean-and-detailed-solution",
                "content": "```\\nclass Solution {\\n    public static class Pair{\\n\\t\\tint id;\\n\\t\\tint startTime;\\n\\t\\tint childTime;\\n\\t\\t\\n\\t\\tPair(int id, int st, int ct){\\n\\t\\t\\tthis.id = id;\\n\\t\\t\\tthis.startTime = st;\\n\\t\\t\\tthis.childTime = ct;\\n\\t\\t}\\n\\t}\\n    \\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] ans = new int[n];\\n        Stack<Pair> st = new Stack<>();\\n        \\n        for(String OneLog : logs) {\\n        \\tString[] log = OneLog.split(\":\");\\n        \\tif(log[1].equals(\"start\")) {\\n        \\t\\tPair add = new Pair(Integer.parseInt(log[0]), Integer.parseInt(log[2]), 0);\\n        \\t\\tst.push(add);\\n        \\t}else {\\n        \\t\\tPair rem = st.pop();\\n        \\t\\tint time = Integer.parseInt(log[2]) - rem.startTime + 1;\\n        \\t\\tans[rem.id] += time - rem.childTime;\\n        \\t\\tif(st.size() > 0)\\n        \\t\\t\\tst.peek().childTime += time;\\n        \\t}\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static class Pair{\\n\\t\\tint id;\\n\\t\\tint startTime;\\n\\t\\tint childTime;\\n\\t\\t\\n\\t\\tPair(int id, int st, int ct){\\n\\t\\t\\tthis.id = id;\\n\\t\\t\\tthis.startTime = st;\\n\\t\\t\\tthis.childTime = ct;\\n\\t\\t}\\n\\t}\\n    \\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] ans = new int[n];\\n        Stack<Pair> st = new Stack<>();\\n        \\n        for(String OneLog : logs) {\\n        \\tString[] log = OneLog.split(\":\");\\n        \\tif(log[1].equals(\"start\")) {\\n        \\t\\tPair add = new Pair(Integer.parseInt(log[0]), Integer.parseInt(log[2]), 0);\\n        \\t\\tst.push(add);\\n        \\t}else {\\n        \\t\\tPair rem = st.pop();\\n        \\t\\tint time = Integer.parseInt(log[2]) - rem.startTime + 1;\\n        \\t\\tans[rem.id] += time - rem.childTime;\\n        \\t\\tif(st.size() > 0)\\n        \\t\\t\\tst.peek().childTime += time;\\n        \\t}\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826300,
                "title": "o-n-python-faster-than-99-39-easy-to-understand",
                "content": "The easy is easy to build if we understand the boundry conditions. \\n1. The function that starts or ends claims the time stamp\\n2. if a new method is starting we claim the duration of previous method as it has run till that time\\n\\nwe can build a simple timeline as \\n0,0,1,1,1,...\\nwhere 0, 1 represent the function id however it is not necessary to build this if we directly keep the count in the result array\\n\\n```\\nclass Solution:           \\n    \\n\\tdef exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        # memory efficient implementation\\n        # We basically mark the array at that time stamp as the one starting or ending        \\n        stk = []\\n        current = -1\\n        res_count = [0 for _ in range(n)]\\n        for i in range(len(logs)):\\n            curr = logs[i]\\n            fid_str, op, time = curr.split(\":\")\\n            t_int = int(time)\\n            fid = int(fid_str)\\n            if op == \"start\":\\n                if not stk:\\n                    res_count[fid] += t_int - current  # base case, start a new function\\n                else:\\n                    res_count[stk[-1]] += (t_int - current - 1)  # increment the runtime for last function till the t-1\\n                    res_count[fid] += 1  # claim  the runtime of 1 for new function started  \\n                stk.append(fid)\\n            elif op == \"end\":\\n                fid_old = stk.pop()  # pop the last function as it is the one ended\\n                res_count[fid_old] += (t_int - current - 1)  # increment the runtime for last function till the t-1\\n                res_count[fid] += 1  # claim  the runtime of 1 for the function ended\\n            current = t_int\\n        return res_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:           \\n    \\n\\tdef exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        # memory efficient implementation\\n        # We basically mark the array at that time stamp as the one starting or ending        \\n        stk = []\\n        current = -1\\n        res_count = [0 for _ in range(n)]\\n        for i in range(len(logs)):\\n            curr = logs[i]\\n            fid_str, op, time = curr.split(\":\")\\n            t_int = int(time)\\n            fid = int(fid_str)\\n            if op == \"start\":\\n                if not stk:\\n                    res_count[fid] += t_int - current  # base case, start a new function\\n                else:\\n                    res_count[stk[-1]] += (t_int - current - 1)  # increment the runtime for last function till the t-1\\n                    res_count[fid] += 1  # claim  the runtime of 1 for new function started  \\n                stk.append(fid)\\n            elif op == \"end\":\\n                fid_old = stk.pop()  # pop the last function as it is the one ended\\n                res_count[fid_old] += (t_int - current - 1)  # increment the runtime for last function till the t-1\\n                res_count[fid] += 1  # claim  the runtime of 1 for the function ended\\n            current = t_int\\n        return res_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796246,
                "title": "python-intuitive-approach-with-comments",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n    \\n        result = [0] * n\\n        p_num, _, p_timestamp = logs[0].split(\\':\\')\\n        stack = [[int(p_num), int(p_timestamp)]]\\n        \\n        i = 1\\n        while i < len(logs):\\n            # c_ variables are current index\\'s log entry\\n            c_num, c_status, c_timestamp = logs[i].split(\\':\\')\\n            c_num = int(c_num)\\n            c_timestamp = int(c_timestamp)\\n            \\n            if c_status == \\'start\\':\\n                # append to stack if start\\n                stack.append([c_num, c_timestamp])\\n            else:\\n                # p_ variables are from top of the stack\\n                p_num, p_timestamp = stack.pop()\\n                curr_time = c_timestamp - p_timestamp + 1\\n                result[p_num] += curr_time\\n                \\n                # Since we need exclusive time, subract curr function\\'s time \\n                # from prev function that is paused\\n                if stack:\\n                    pp_num, pp_timestamp = stack[-1]\\n                    result[pp_num] -= curr_time\\n                prev_end = p_timestamp\\n            i += 1\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n    \\n        result = [0] * n\\n        p_num, _, p_timestamp = logs[0].split(\\':\\')\\n        stack = [[int(p_num), int(p_timestamp)]]\\n        \\n        i = 1\\n        while i < len(logs):\\n            # c_ variables are current index\\'s log entry\\n            c_num, c_status, c_timestamp = logs[i].split(\\':\\')\\n            c_num = int(c_num)\\n            c_timestamp = int(c_timestamp)\\n            \\n            if c_status == \\'start\\':\\n                # append to stack if start\\n                stack.append([c_num, c_timestamp])\\n            else:\\n                # p_ variables are from top of the stack\\n                p_num, p_timestamp = stack.pop()\\n                curr_time = c_timestamp - p_timestamp + 1\\n                result[p_num] += curr_time\\n                \\n                # Since we need exclusive time, subract curr function\\'s time \\n                # from prev function that is paused\\n                if stack:\\n                    pp_num, pp_timestamp = stack[-1]\\n                    result[pp_num] -= curr_time\\n                prev_end = p_timestamp\\n            i += 1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732754,
                "title": "python-easy-solution-using-stack-with-step-by-step-explanation",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        # store encounter start logs stored as [function number, start time]\\n        stack = []\\n        res = [0] * n\\n        for l in logs:\\n            fun, status, time = l.split(\\':\\')\\n            funNum, timeInt = int(fun), int(time)\\n            if status == \\'start\\':\\n                # Skip the time duration calculation for the first element in logs\\n                if len(stack) > 0:\\n                    res[stack[-1][0]] += timeInt - stack[-1][1]\\n                stack.append([funNum, timeInt])\\n            elif status == \\'end\\':\\n                # time in end log indicates the end of current timestamp duration.\\n                # Convert to the start of timestamp. ie end of ts == start of ts + 1\\n                res[funNum] += timeInt + 1 - stack[-1][1]\\n                stack.pop()\\n                # special handling the current end log is \\n                if len(stack) > 0:\\n                    # After finish the current end function, will resume exeucte the previous function in the stack. \\n                    # Thus update its start time to current ts\\n                    stack[-1][1] = timeInt + 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        # store encounter start logs stored as [function number, start time]\\n        stack = []\\n        res = [0] * n\\n        for l in logs:\\n            fun, status, time = l.split(\\':\\')\\n            funNum, timeInt = int(fun), int(time)\\n            if status == \\'start\\':\\n                # Skip the time duration calculation for the first element in logs\\n                if len(stack) > 0:\\n                    res[stack[-1][0]] += timeInt - stack[-1][1]\\n                stack.append([funNum, timeInt])\\n            elif status == \\'end\\':\\n                # time in end log indicates the end of current timestamp duration.\\n                # Convert to the start of timestamp. ie end of ts == start of ts + 1\\n                res[funNum] += timeInt + 1 - stack[-1][1]\\n                stack.pop()\\n                # special handling the current end log is \\n                if len(stack) > 0:\\n                    # After finish the current end function, will resume exeucte the previous function in the stack. \\n                    # Thus update its start time to current ts\\n                    stack[-1][1] = timeInt + 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567817,
                "title": "o-n-simple-python-with-detailed-comments-using-stacks",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        ans = [0 for _ in range(n)]\\n        call_stack = []\\n\\t\\t\\t#Holds (function_id, index)\\n\\t\\t\\n\\t\\t#We know that each function call will be ended before a new one starts, so there\\'s only two cases,\\n\\t\\t#Either we start a new function, or we end the one that is at the top of stack.\\n        for log in logs:\\n            data = log.split(\\':\\')\\n\\t\\t\\t\\t#Holds (function_id, index)\\n            if data[1] == \\'start\\':\\n\\t\\t\\t\\t#Start a new function call\\n                call_stack.append((int(data[0]), int(data[2])))\\n            else:\\n\\t\\t\\t\\t#End the last function call\\n                func_id, func_start = call_stack.pop()\\n                time_for_func_call = int(data[2]) - func_start + 1\\n                ans[func_id] += time_for_func_call\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#Because one function may lie between the start and end of another, we must subtract the time spent in the callee\\n\\t\\t\\t\\t#function from the caller. At this point, the topmost function on the stack will be the one that called the one which \\n\\t\\t\\t\\t#we are currently ending. This caller function is the one that we must subtract the overlap from.\\n                if call_stack:\\n                    ans[call_stack[-1][0]] -= time_for_func_call\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        ans = [0 for _ in range(n)]\\n        call_stack = []\\n\\t\\t\\t#Holds (function_id, index)\\n\\t\\t\\n\\t\\t#We know that each function call will be ended before a new one starts, so there\\'s only two cases,\\n\\t\\t#Either we start a new function, or we end the one that is at the top of stack.\\n        for log in logs:\\n            data = log.split(\\':\\')\\n\\t\\t\\t\\t#Holds (function_id, index)\\n            if data[1] == \\'start\\':\\n\\t\\t\\t\\t#Start a new function call\\n                call_stack.append((int(data[0]), int(data[2])))\\n            else:\\n\\t\\t\\t\\t#End the last function call\\n                func_id, func_start = call_stack.pop()\\n                time_for_func_call = int(data[2]) - func_start + 1\\n                ans[func_id] += time_for_func_call\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#Because one function may lie between the start and end of another, we must subtract the time spent in the callee\\n\\t\\t\\t\\t#function from the caller. At this point, the topmost function on the stack will be the one that called the one which \\n\\t\\t\\t\\t#we are currently ending. This caller function is the one that we must subtract the overlap from.\\n                if call_stack:\\n                    ans[call_stack[-1][0]] -= time_for_func_call\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546464,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> ans(n, 0);\\n        stack<int> functions; \\n        int prevTime = 0; \\n        for (auto log : logs) {\\n            stringstream ss(log); \\n            string id, action, time; \\n            getline(ss, id, \\':\\'); \\n            getline(ss, action, \\':\\'); \\n            getline(ss, time, \\':\\');\\n            int funcId = stoi(id);\\n            int funcTime = stoi(time);\\n            if (\"start\" == action) {\\n                if (!functions.empty()) { ans[functions.top()] += funcTime - prevTime; }\\n                functions.push(funcId);\\n                prevTime = funcTime;   \\n            } else if (\"end\" == action) {\\n                ans[functions.top()] += funcTime - prevTime + 1; \\n                functions.pop();\\n                prevTime = funcTime + 1;   \\n            }          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> ans(n, 0);\\n        stack<int> functions; \\n        int prevTime = 0; \\n        for (auto log : logs) {\\n            stringstream ss(log); \\n            string id, action, time; \\n            getline(ss, id, \\':\\'); \\n            getline(ss, action, \\':\\'); \\n            getline(ss, time, \\':\\');\\n            int funcId = stoi(id);\\n            int funcTime = stoi(time);\\n            if (\"start\" == action) {\\n                if (!functions.empty()) { ans[functions.top()] += funcTime - prevTime; }\\n                functions.push(funcId);\\n                prevTime = funcTime;   \\n            } else if (\"end\" == action) {\\n                ans[functions.top()] += funcTime - prevTime + 1; \\n                functions.pop();\\n                prevTime = funcTime + 1;   \\n            }          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430688,
                "title": "js-using-stack",
                "content": "```\\nvar exclusiveTime = function(n, logs) {\\n\\t// result will have time taken for each task (n tasks)\\n    const result = Array(n).fill(0); // (initialised with 0)\\n    const stack = [];\\n    \\n    for(let idx = 0; idx < logs.length; ++idx) {    // O(L)\\n        let [id, fn, time] = logs[idx].split(\\':\\');\\n        id = parseInt(id);\\n        time = parseInt(time);\\n        \\n\\t\\t// if the fn is start, push the id and time to the stack\\n        if(fn === \\'start\\') {\\n            stack.push([id, time]);\\n        } else {\\n\\t\\t\\t// if the fn is end, get the prev log from the stack,\\n\\t\\t\\t// calculate the duration of fn and add it to the result\\n            const [prev_log_id, prev_log_time] = stack.pop();\\n            const duration = time - prev_log_time + 1;\\n            result[id] += duration;\\n\\t\\t\\t\\n\\t\\t\\t// if there is a fn that was started earlier and hasn\\'t finished yet (present in the stack)\\n\\t\\t\\t// remove the duration from the result of that fn id\\n\\t\\t\\t// as that fn was not running during this (`duration`) time\\n            if(stack.length) {\\n                const [top_log_id, top_log_time] = stack[stack.length - 1];\\n                result[top_log_id] -= duration;    \\n            }\\n        }\\n    }\\n    return result;\\n};\\n```\\nTime Complexity = O(L)\\nSpace Complexity = O(L)\\n[L - number of logs]",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar exclusiveTime = function(n, logs) {\\n\\t// result will have time taken for each task (n tasks)\\n    const result = Array(n).fill(0); // (initialised with 0)\\n    const stack = [];\\n    \\n    for(let idx = 0; idx < logs.length; ++idx) {    // O(L)\\n        let [id, fn, time] = logs[idx].split(\\':\\');\\n        id = parseInt(id);\\n        time = parseInt(time);\\n        \\n\\t\\t// if the fn is start, push the id and time to the stack\\n        if(fn === \\'start\\') {\\n            stack.push([id, time]);\\n        } else {\\n\\t\\t\\t// if the fn is end, get the prev log from the stack,\\n\\t\\t\\t// calculate the duration of fn and add it to the result\\n            const [prev_log_id, prev_log_time] = stack.pop();\\n            const duration = time - prev_log_time + 1;\\n            result[id] += duration;\\n\\t\\t\\t\\n\\t\\t\\t// if there is a fn that was started earlier and hasn\\'t finished yet (present in the stack)\\n\\t\\t\\t// remove the duration from the result of that fn id\\n\\t\\t\\t// as that fn was not running during this (`duration`) time\\n            if(stack.length) {\\n                const [top_log_id, top_log_time] = stack[stack.length - 1];\\n                result[top_log_id] -= duration;    \\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360426,
                "title": "python-o-n-with-comments-faster-than-97",
                "content": "This code captures blocks of time as they happen.  It uses a stack to keep track of the running function so that book-keeping into \"result\" can happen.  The tricky part is keeping track of the begin and end of each time block.  \"start\" events happen at the beginning of the currentTime unit, and \"end\" events  happen at the end of the current time unit.   \\n\\n```python \\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        result = [0]*n \\n        \\n        runStack = []\\n        start = 0        \\n        for entry in logs:\\n            # unpack and transform log entry\\n            func, event, time = entry.split(\":\")\\n            currentFunc = int(func)\\n            currentTime = int(time)\\n\\n            # capture the elapsed time for the running function, if any \\n            if runStack:\\n                f = runStack[-1]\\n                if event == \"start\":\\n\\t\\t\\t\\t\\t# skip the current time unit, event happens at the beginning of it\\n                    duration = currentTime - start\\n                elif event == \"end\":\\n\\t\\t\\t\\t\\t# include the current time unit, event happens at the end of it\\n                    duration = currentTime - start + 1                     \\n                result[f] += duration \\n            \\n            # update the running variables            \\n            if event == \"start\":\\n                # push the new function onto the stack. \\n                runStack.append(currentFunc)\\n                # For \"starts,\" the next time interval begins at the beginning of currentTime \\n                start = currentTime\\n            elif event == \"end\":\\n                # pop the running function (there should be one)\\n                runStack.pop()\\n                # For \"ends,\" the next time interval begins at the end of currentTime \\n                start = currentTime + 1\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```python \\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        result = [0]*n \\n        \\n        runStack = []\\n        start = 0        \\n        for entry in logs:\\n            # unpack and transform log entry\\n            func, event, time = entry.split(\":\")\\n            currentFunc = int(func)\\n            currentTime = int(time)\\n\\n            # capture the elapsed time for the running function, if any \\n            if runStack:\\n                f = runStack[-1]\\n                if event == \"start\":\\n\\t\\t\\t\\t\\t# skip the current time unit, event happens at the beginning of it\\n                    duration = currentTime - start\\n                elif event == \"end\":\\n\\t\\t\\t\\t\\t# include the current time unit, event happens at the end of it\\n                    duration = currentTime - start + 1                     \\n                result[f] += duration \\n            \\n            # update the running variables            \\n            if event == \"start\":\\n                # push the new function onto the stack. \\n                runStack.append(currentFunc)\\n                # For \"starts,\" the next time interval begins at the beginning of currentTime \\n                start = currentTime\\n            elif event == \"end\":\\n                # pop the running function (there should be one)\\n                runStack.pop()\\n                # For \"ends,\" the next time interval begins at the end of currentTime \\n                start = currentTime + 1\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277614,
                "title": "java-clean-concise-optimal-code-stack-data-structure-95-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int[] answer = new int[n];\\n        Stack<int[]> stack = new Stack<> ();\\n        \\n        for (String log : logs) {\\n            String[] s = log.split (\":\");\\n            if (s[1].equals (\"start\")) {\\n                stack.push (new int[] {Integer.parseInt (s[0]), Integer.parseInt (s[2]), 0});\\n            }\\n            else {\\n                int[] curr = stack.pop ();\\n                int time = Integer.parseInt (s[2]) - curr[1] + 1;\\n                answer[curr[0]] += time - curr[2];\\n                if (!stack.isEmpty ()) {\\n                    stack.peek ()[2] += time;\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int[] answer = new int[n];\\n        Stack<int[]> stack = new Stack<> ();\\n        \\n        for (String log : logs) {\\n            String[] s = log.split (\":\");\\n            if (s[1].equals (\"start\")) {\\n                stack.push (new int[] {Integer.parseInt (s[0]), Integer.parseInt (s[2]), 0});\\n            }\\n            else {\\n                int[] curr = stack.pop ();\\n                int time = Integer.parseInt (s[2]) - curr[1] + 1;\\n                answer[curr[0]] += time - curr[2];\\n                if (!stack.isEmpty ()) {\\n                    stack.peek ()[2] += time;\\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263822,
                "title": "java-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int[] totalTime = new int[n];\\n        \\n        Stack<LogLine> st = new Stack<>();\\n        int prevTime = 0;\\n        \\n        for (String log : logs) {\\n            LogLine l = new LogLine(log.split(\":\"));\\n            if (l.isStart) {\\n                if (!st.isEmpty()) {\\n                    LogLine prevL = st.peek();\\n                    totalTime[prevL.id] += l.time - prevTime;\\n                }\\n                prevTime = l.time;\\n                st.push(l);\\n            } else {\\n                totalTime[l.id] += l.time - prevTime + 1;\\n                prevTime = l.time + 1;\\n                st.pop();\\n            }\\n        }\\n        return totalTime;\\n    }\\n    \\n    \\n    class LogLine{\\n        int id;\\n        boolean isStart;\\n        int time;\\n        \\n        public LogLine(String[] logParts) {\\n            // ASSERT Valid log parts\\n            this.id = Integer.parseInt(logParts[0]);\\n            this.isStart = (logParts[1].equals(\"start\"));\\n            this.time = Integer.parseInt(logParts[2]);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int[] totalTime = new int[n];\\n        \\n        Stack<LogLine> st = new Stack<>();\\n        int prevTime = 0;\\n        \\n        for (String log : logs) {\\n            LogLine l = new LogLine(log.split(\":\"));\\n            if (l.isStart) {\\n                if (!st.isEmpty()) {\\n                    LogLine prevL = st.peek();\\n                    totalTime[prevL.id] += l.time - prevTime;\\n                }\\n                prevTime = l.time;\\n                st.push(l);\\n            } else {\\n                totalTime[l.id] += l.time - prevTime + 1;\\n                prevTime = l.time + 1;\\n                st.pop();\\n            }\\n        }\\n        return totalTime;\\n    }\\n    \\n    \\n    class LogLine{\\n        int id;\\n        boolean isStart;\\n        int time;\\n        \\n        public LogLine(String[] logParts) {\\n            // ASSERT Valid log parts\\n            this.id = Integer.parseInt(logParts[0]);\\n            this.isStart = (logParts[1].equals(\"start\"));\\n            this.time = Integer.parseInt(logParts[2]);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188602,
                "title": "c-solution-with-lots-of-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    tuple<int, bool, int> parseEntry(string const& entry)\\n    {\\n        // Vector of string to save tokens\\n        vector <string> tokens;\\n\\n        // stringstream class check1\\n        stringstream check1(entry);\\n\\n        string intermediate;\\n\\n        // Tokenizing w.r.t. colom \\':\\'\\n        while(getline(check1, intermediate, \\':\\'))\\n        {\\n            tokens.push_back(intermediate);\\n        }\\n        \\n        return {stoi(tokens[0]), tokens[1]==\"start\", stoi(tokens[2])};\\n    }\\n    \\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> times(n, 0);\\n        \\n        int functionID, time;\\n        bool isStart;\\n        tie(functionID, isStart, time) = parseEntry(logs[0]);\\n        assert(isStart);\\n        stack<pair<int, int>> functionStack;\\n        functionStack.push({functionID, time});\\n        \\n        for(int i = 1; i < logs.size(); ++i)\\n        {\\n            auto const& entry = logs[i];\\n            tie(functionID, isStart, time) = parseEntry(entry);\\n            if(isStart)\\n            {\\n                if(not functionStack.empty())\\n                {\\n                    /*\\n                    Current function called another one, let\\'s stop this and account \\n                    for its time\\n                    */\\n                    times[functionStack.top().first] += time - functionStack.top().second;\\n                }\\n                functionStack.push({functionID, time});\\n            }\\n            else\\n            {\\n                assert(not functionStack.empty());\\n                assert(functionID == functionStack.top().first);\\n                \\n                /*\\n                These + 1 are a little tricky: the current function will end at the end\\n                of the time in the entry, not the beginning, so we must account for that\\n                extra second in its running time, hence the + 1\\n                */\\n                times[functionID] += time - functionStack.top().second + 1;\\n                functionStack.pop();\\n                \\n                /*\\n                The previous function in the callstack has resumed working, let\\'s update \\n                its begin time. Same as before, the next function in the stack will resume\\n                working in the second NEXT than that specified in the entry, since in that\\n                second the previous function will still be working\\n                */\\n                if(not functionStack.empty())\\n                    functionStack.top().second = time+1;\\n            }\\n        }\\n        return times;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    tuple<int, bool, int> parseEntry(string const& entry)\\n    {\\n        // Vector of string to save tokens\\n        vector <string> tokens;\\n\\n        // stringstream class check1\\n        stringstream check1(entry);\\n\\n        string intermediate;\\n\\n        // Tokenizing w.r.t. colom \\':\\'\\n        while(getline(check1, intermediate, \\':\\'))\\n        {\\n            tokens.push_back(intermediate);\\n        }\\n        \\n        return {stoi(tokens[0]), tokens[1]==\"start\", stoi(tokens[2])};\\n    }\\n    \\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> times(n, 0);\\n        \\n        int functionID, time;\\n        bool isStart;\\n        tie(functionID, isStart, time) = parseEntry(logs[0]);\\n        assert(isStart);\\n        stack<pair<int, int>> functionStack;\\n        functionStack.push({functionID, time});\\n        \\n        for(int i = 1; i < logs.size(); ++i)\\n        {\\n            auto const& entry = logs[i];\\n            tie(functionID, isStart, time) = parseEntry(entry);\\n            if(isStart)\\n            {\\n                if(not functionStack.empty())\\n                {\\n                    /*\\n                    Current function called another one, let\\'s stop this and account \\n                    for its time\\n                    */\\n                    times[functionStack.top().first] += time - functionStack.top().second;\\n                }\\n                functionStack.push({functionID, time});\\n            }\\n            else\\n            {\\n                assert(not functionStack.empty());\\n                assert(functionID == functionStack.top().first);\\n                \\n                /*\\n                These + 1 are a little tricky: the current function will end at the end\\n                of the time in the entry, not the beginning, so we must account for that\\n                extra second in its running time, hence the + 1\\n                */\\n                times[functionID] += time - functionStack.top().second + 1;\\n                functionStack.pop();\\n                \\n                /*\\n                The previous function in the callstack has resumed working, let\\'s update \\n                its begin time. Same as before, the next function in the stack will resume\\n                working in the second NEXT than that specified in the entry, since in that\\n                second the previous function will still be working\\n                */\\n                if(not functionStack.empty())\\n                    functionStack.top().second = time+1;\\n            }\\n        }\\n        return times;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184754,
                "title": "concise-c-solution-easy-way-to-parse-the-logs-string",
                "content": "Inspired by @dushyantarora13 and comments under that post\\n```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> res(n,0);\\n        stack<int> stk;\\n        int lastTime=0;\\n        for(string s: logs){\\n            //parse the string\\n            int pos1=s.find(\\':\\');\\n            int funcId = stoi(s.substr(0,pos1));\\n            int pos2=s.find_last_of(\\':\\');\\n            string type=s.substr(pos1+1,pos2-pos1-1);\\n            int curTime= stoi(s.substr(pos2+1));\\n            \\n            if(type==\"start\"){\\n                if(!stk.empty()){\\n                    res[stk.top()] += curTime - lastTime;\\n                }\\n                stk.push(funcId);\\n                lastTime=curTime;\\n            } else{\\n                res[funcId] += curTime-lastTime+1;\\n                lastTime=curTime+1;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> res(n,0);\\n        stack<int> stk;\\n        int lastTime=0;\\n        for(string s: logs){\\n            //parse the string\\n            int pos1=s.find(\\':\\');\\n            int funcId = stoi(s.substr(0,pos1));\\n            int pos2=s.find_last_of(\\':\\');\\n            string type=s.substr(pos1+1,pos2-pos1-1);\\n            int curTime= stoi(s.substr(pos2+1));\\n            \\n            if(type==\"start\"){\\n                if(!stk.empty()){\\n                    res[stk.top()] += curTime - lastTime;\\n                }\\n                stk.push(funcId);\\n                lastTime=curTime;\\n            } else{\\n                res[funcId] += curTime-lastTime+1;\\n                lastTime=curTime+1;\\n                stk.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172201,
                "title": "two-approaches-to-solve-the-problem-o-n-space-and-time",
                "content": "1. Keep track of actual running time of the current function\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        results = [0] * n\\n        start_time = 0\\n        for log in logs:\\n            func_id, signal, timestamp  = log.split(\\':\\')\\n            func_id, timestamp = int(func_id), int(timestamp)\\n            if signal == \\'start\\':\\n                if stack:  # the current func stops, store the running time so far\\n                    results[stack[-1]] += timestamp - start_time\\n                stack.append(func_id)\\n                start_time = timestamp  # start keeping track the start of the current sub-func\\n            else:\\n                run_time = timestamp - start_time  + 1\\n                results[stack.pop()] += run_time\\n                start_time = timestamp + 1  # the parent func start again at timestamp + 1\\n                \\n        return results           \\n```\\n\\n2. Keep track of running time of subfunctions:\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        level = 0\\n        subfunc_runtime = []\\n        results = [0] * n\\n        for log in logs:\\n            func_id, signal, timestamp  = log.split(\\':\\')\\n            if signal == \\'start\\':\\n                subfunc_runtime.append(0)\\n                stack.append((int(func_id), int(timestamp)))\\n            else:\\n                func_id, start = stack.pop()\\n                run_time = int(timestamp) - start  + 1\\n                results[func_id] += run_time - subfunc_runtime.pop()                \\n                if subfunc_runtime:\\n                    subfunc_runtime[-1] += run_time\\n        return results                               \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        results = [0] * n\\n        start_time = 0\\n        for log in logs:\\n            func_id, signal, timestamp  = log.split(\\':\\')\\n            func_id, timestamp = int(func_id), int(timestamp)\\n            if signal == \\'start\\':\\n                if stack:  # the current func stops, store the running time so far\\n                    results[stack[-1]] += timestamp - start_time\\n                stack.append(func_id)\\n                start_time = timestamp  # start keeping track the start of the current sub-func\\n            else:\\n                run_time = timestamp - start_time  + 1\\n                results[stack.pop()] += run_time\\n                start_time = timestamp + 1  # the parent func start again at timestamp + 1\\n                \\n        return results           \\n```\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        level = 0\\n        subfunc_runtime = []\\n        results = [0] * n\\n        for log in logs:\\n            func_id, signal, timestamp  = log.split(\\':\\')\\n            if signal == \\'start\\':\\n                subfunc_runtime.append(0)\\n                stack.append((int(func_id), int(timestamp)))\\n            else:\\n                func_id, start = stack.pop()\\n                run_time = int(timestamp) - start  + 1\\n                results[func_id] += run_time - subfunc_runtime.pop()                \\n                if subfunc_runtime:\\n                    subfunc_runtime[-1] += run_time\\n        return results                               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 799123,
                "title": "python-3-stack-explanation",
                "content": "* Build a `Log` class that takes in a `log` string and maps the values to useable fields.\\n* Create an `idToElapsed` array where we map the `log.id` to the time elapsed for that given `id`.\\n* Iterate through each `log` and check:\\n* If it\\'s a start log then we just push it to the top of the `logStack`.\\n* Otherwise:\\n\\t* **Pop** the previously running function off the `logStack` and calculate the `timeDifference`.\\n\\t* Update the `timeDifference` for the previously running function.\\n\\t* If there are still any functions still running, then we subtract the `timeDifference` since there was a gap in time when the previous function started but another function was called that was taking its \"total\" running time up.\\n```\\nclass Log:\\n    \\n    def __init__(self, log: str):\\n        splitLog = log.split(\\':\\')\\n        self.id = int(splitLog[0])\\n        self.isStart = splitLog[1] == \\'start\\'\\n        self.time = int(splitLog[2])\\n        \\nclass Solution:\\n    \\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        wrappedLogs = [Log(log) for log in logs]        \\n        idToElapsed = [0] * (max([log.id for log in wrappedLogs]) + 1)\\n        logStack = []\\n        \\n        for log in wrappedLogs:\\n            if log.isStart:\\n                logStack.append(log)\\n            else:\\n                previousLog = logStack.pop()\\n                timeDifference = log.time - previousLog.time + 1\\n                \\n                idToElapsed[previousLog.id] += timeDifference\\n                \\n                if logStack:\\n                    idToElapsed[logStack[-1].id] -= timeDifference\\n        \\n        return idToElapsed\\n```",
                "solutionTags": [],
                "code": "```\\nclass Log:\\n    \\n    def __init__(self, log: str):\\n        splitLog = log.split(\\':\\')\\n        self.id = int(splitLog[0])\\n        self.isStart = splitLog[1] == \\'start\\'\\n        self.time = int(splitLog[2])\\n        \\nclass Solution:\\n    \\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        wrappedLogs = [Log(log) for log in logs]        \\n        idToElapsed = [0] * (max([log.id for log in wrappedLogs]) + 1)\\n        logStack = []\\n        \\n        for log in wrappedLogs:\\n            if log.isStart:\\n                logStack.append(log)\\n            else:\\n                previousLog = logStack.pop()\\n                timeDifference = log.time - previousLog.time + 1\\n                \\n                idToElapsed[previousLog.id] += timeDifference\\n                \\n                if logStack:\\n                    idToElapsed[logStack[-1].id] -= timeDifference\\n        \\n        return idToElapsed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794808,
                "title": "confused-test-case",
                "content": "Could someone explain why in the following case\\n```\\n1\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\\n```\\nexpected answer is **8** and not **7**?\\n",
                "solutionTags": [],
                "code": "```\\n1\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774549,
                "title": "easy-c-solution-using-stringstream",
                "content": "Comment for any doubt.\\n```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        int m=logs.size();\\n        stack <int> s;\\n        vector <int> ans(n,0);\\n        int last=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            stringstream ss(logs[i]);\\n            string t1,t2,t3;\\n            getline(ss,t1,\\':\\');\\n            getline(ss,t2,\\':\\');\\n            getline(ss,t3,\\':\\');\\n            int id= stoi(t1);\\n            int time=stoi(t3);\\n            if(t2==\"start\")\\n            {\\n                if(!s.empty())\\n                {\\n                    ans[s.top()]+= time-last;\\n                }\\n                s.push(id);\\n                    last=time;\\n            }\\n            else\\n            {\\n                ans[s.top()]+=time+1-last;\\n                s.pop();\\n                last=time+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        int m=logs.size();\\n        stack <int> s;\\n        vector <int> ans(n,0);\\n        int last=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            stringstream ss(logs[i]);\\n            string t1,t2,t3;\\n            getline(ss,t1,\\':\\');\\n            getline(ss,t2,\\':\\');\\n            getline(ss,t3,\\':\\');\\n            int id= stoi(t1);\\n            int time=stoi(t3);\\n            if(t2==\"start\")\\n            {\\n                if(!s.empty())\\n                {\\n                    ans[s.top()]+= time-last;\\n                }\\n                s.push(id);\\n                    last=time;\\n            }\\n            else\\n            {\\n                ans[s.top()]+=time+1-last;\\n                s.pop();\\n                last=time+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701868,
                "title": "c-simple-solution-no-use-of-any-inbuilt-function",
                "content": "```\\nclass Log{\\n    public:\\n    int time = -1;\\n    int id = -1;\\n    string type = \"\";\\n    \\n    Log(){\\n        time = -1;\\n        id = -1;\\n        type = \"\";\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    Log convert(string& s){\\n    \\n        string temp;\\n        Log log;\\n            \\n            for(int j = 0; j < s.size(); j++){\\n                \\n                if(s[j] == \\':\\'){\\n                    \\n                    if(log.id == -1)\\n                        log.id = stoi(temp);\\n                    else if(log.type == \"\")\\n                        log.type = temp;\\n                    \\n                    temp = \"\";\\n                }else\\n                    temp += s[j];\\n            }\\n            log.time = stoi(temp);\\n        \\n        return log;\\n    \\n    }\\n    vector<int> exclusiveTime(int no, vector<string>& logs) {\\n        \\n        int n = logs.size();\\n        \\n        if(n == 0)\\n            return {};\\n        \\n        vector<int> ans(no,0);\\n        stack<Log> st;\\n        \\n        Log log = convert(logs[0]);\\n        st.push(log);\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            Log log = convert(logs[i]);\\n            \\n            if(log.type == \"start\")\\n                st.push(log);\\n            \\n            else{\\n                \\n                Log topLog = st.top();\\n                st.pop();\\n                \\n                int timeSpent = log.time - topLog.time + 1;\\n                ans[topLog.id] += timeSpent;\\n                \\n                if(!st.empty())\\n                    ans[st.top().id] -= timeSpent;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Log{\\n    public:\\n    int time = -1;\\n    int id = -1;\\n    string type = \"\";\\n    \\n    Log(){\\n        time = -1;\\n        id = -1;\\n        type = \"\";\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    Log convert(string& s){\\n    \\n        string temp;\\n        Log log;\\n            \\n            for(int j = 0; j < s.size(); j++){\\n                \\n                if(s[j] == \\':\\'){\\n                    \\n                    if(log.id == -1)\\n                        log.id = stoi(temp);\\n                    else if(log.type == \"\")\\n                        log.type = temp;\\n                    \\n                    temp = \"\";\\n                }else\\n                    temp += s[j];\\n            }\\n            log.time = stoi(temp);\\n        \\n        return log;\\n    \\n    }\\n    vector<int> exclusiveTime(int no, vector<string>& logs) {\\n        \\n        int n = logs.size();\\n        \\n        if(n == 0)\\n            return {};\\n        \\n        vector<int> ans(no,0);\\n        stack<Log> st;\\n        \\n        Log log = convert(logs[0]);\\n        st.push(log);\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            Log log = convert(logs[i]);\\n            \\n            if(log.type == \"start\")\\n                st.push(log);\\n            \\n            else{\\n                \\n                Log topLog = st.top();\\n                st.pop();\\n                \\n                int timeSpent = log.time - topLog.time + 1;\\n                ans[topLog.id] += timeSpent;\\n                \\n                if(!st.empty())\\n                    ans[st.top().id] -= timeSpent;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685923,
                "title": "java-solution-with-explanation",
                "content": "```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n        /**\\n          ALGO: \\n          1. Create a stack of pair ( function id : Timestamp) .\\n          2. If you encountered \"start\" push the the pair Object  in stack .\\n          3. Else pop the value from stack calculate  calculatedTs = current time stamp - pop timetsmap +1  for this function and add it to response array ;\\n             3.1 if stack has more elemnts then update the time stamp of stack top element in responseArray  by -calculatedTs.\\n             \\n             // Dry run of above algorithm\\n             int res =int[2];\\n             logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\\n               i=0  stack.push --> 0 =0\\n               i=1  stack.push --> 1 =2\\n               i=2   ts =  current - stack.pop() +1 --> 5 - 2 +1 = 4 \\n                     res[1] += ts= 4;\\n                     res[0] += -ts = -4;\\n               i=3   ts =  current - stack.pop() +1 --> 6 - 0 +1 = 7\\n                     res[0]+=7 = -4+7 =3;\\n        **/\\n        int[] res = new int[n];\\n        Stack<Pair<Integer,Integer>> stack = new Stack<>();\\n        for( String log : logs){\\n          String splitArr[] = log.split(\":\") ;\\n          int functionId = Integer.valueOf(splitArr[0]);\\n          int ts = Integer.valueOf(splitArr[2]);\\n          String action = splitArr[1];\\n          if(action.equals(\"start\")) {\\n              Pair<Integer,Integer> pair = new Pair(functionId,ts);\\n              stack.push(pair);\\n          } else{\\n              int calculatedTs = ts - stack.pop().getValue() +1;\\n              res[functionId]+=calculatedTs;\\n              if(!stack.isEmpty()){\\n                  res[stack.peek().getKey()]+=-calculatedTs;\\n              }\\n          }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n        /**\\n          ALGO: \\n          1. Create a stack of pair ( function id : Timestamp) .\\n          2. If you encountered \"start\" push the the pair Object  in stack .\\n          3. Else pop the value from stack calculate  calculatedTs = current time stamp - pop timetsmap +1  for this function and add it to response array ;\\n             3.1 if stack has more elemnts then update the time stamp of stack top element in responseArray  by -calculatedTs.\\n             \\n             // Dry run of above algorithm\\n             int res =int[2];\\n             logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\\n               i=0  stack.push --> 0 =0\\n               i=1  stack.push --> 1 =2\\n               i=2   ts =  current - stack.pop() +1 --> 5 - 2 +1 = 4 \\n                     res[1] += ts= 4;\\n                     res[0] += -ts = -4;\\n               i=3   ts =  current - stack.pop() +1 --> 6 - 0 +1 = 7\\n                     res[0]+=7 = -4+7 =3;\\n        **/\\n        int[] res = new int[n];\\n        Stack<Pair<Integer,Integer>> stack = new Stack<>();\\n        for( String log : logs){\\n          String splitArr[] = log.split(\":\") ;\\n          int functionId = Integer.valueOf(splitArr[0]);\\n          int ts = Integer.valueOf(splitArr[2]);\\n          String action = splitArr[1];\\n          if(action.equals(\"start\")) {\\n              Pair<Integer,Integer> pair = new Pair(functionId,ts);\\n              stack.push(pair);\\n          } else{\\n              int calculatedTs = ts - stack.pop().getValue() +1;\\n              res[functionId]+=calculatedTs;\\n              if(!stack.isEmpty()){\\n                  res[stack.peek().getKey()]+=-calculatedTs;\\n              }\\n          }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624992,
                "title": "lots-of-ambiguity-and-wrong-test-case",
                "content": "```\\n3\\n[\"0:start:0\",\"1:start:5\",\"2:start:6\",\"1:start:24\",\"1:end:29\",\"0:start:49\",\"0:end:54\",\"2:start:69\",\"2:end:70\",\"2:start:74\",\"0:start:79\",\"0:end:80\",\"1:start:89\",\"1:end:93\",\"2:end:96\"]\\n```\\n\\nThe  result should be:\\n[13, 12, 69]\\n\\nBut the expected result is:\\n[13,12,72]\\n\\nNot that if we split the test case to be two isolated parts to:\\n```\\n[\"0:start:0\",\"1:start:5\",\"2:start:6\",\"1:start:24\",\"1:end:29\",\"0:start:49\",\"0:end:54\",\"2:start:69\",\"2:end:70\"]\\n```\\nand\\n```\\n[\"2:start:74\",\"0:start:79\",\"0:end:80\",\"1:start:89\",\"1:end:93\",\"2:end:96\"]\\n```\\nBoth of them are caculated correctly.\\n\\nObviously, the gap units (3) beween \"2:end:70\" and \"2:start:74\" are counted towards function 2.",
                "solutionTags": [],
                "code": "```\\n3\\n[\"0:start:0\",\"1:start:5\",\"2:start:6\",\"1:start:24\",\"1:end:29\",\"0:start:49\",\"0:end:54\",\"2:start:69\",\"2:end:70\",\"2:start:74\",\"0:start:79\",\"0:end:80\",\"1:start:89\",\"1:end:93\",\"2:end:96\"]\\n```\n```\\n[\"0:start:0\",\"1:start:5\",\"2:start:6\",\"1:start:24\",\"1:end:29\",\"0:start:49\",\"0:end:54\",\"2:start:69\",\"2:end:70\"]\\n```\n```\\n[\"2:start:74\",\"0:start:79\",\"0:end:80\",\"1:start:89\",\"1:end:93\",\"2:end:96\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 591460,
                "title": "c-concise-o-n-solution-with-stack",
                "content": "```\\npublic class Solution {\\n    public int[] ExclusiveTime(int n, IList<string> logs) {\\n        var st = new Stack<int[]>();\\n        var ans = new int[n];\\n        \\n        for(var i = 0; i < logs.Count; ++i){\\n            var a = logs[i].Split(\\':\\');\\n            var f = int.Parse(a[0]);\\n            var t = int.Parse(a[2]);\\n            if(a[1] == \"start\"){\\n                st.Push(new []{f, t});\\n            }\\n            else{\\n                var item = st.Pop();\\n                var time = t - item[1] + 1;\\n                ans[f] += time;\\n                if(st.Count > 0){\\n                    var peek = st.Peek();\\n                    ans[peek[0]] -= time;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ExclusiveTime(int n, IList<string> logs) {\\n        var st = new Stack<int[]>();\\n        var ans = new int[n];\\n        \\n        for(var i = 0; i < logs.Count; ++i){\\n            var a = logs[i].Split(\\':\\');\\n            var f = int.Parse(a[0]);\\n            var t = int.Parse(a[2]);\\n            if(a[1] == \"start\"){\\n                st.Push(new []{f, t});\\n            }\\n            else{\\n                var item = st.Pop();\\n                var time = t - item[1] + 1;\\n                ans[f] += time;\\n                if(st.Count > 0){\\n                    var peek = st.Peek();\\n                    ans[peek[0]] -= time;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 517494,
                "title": "javascript-clean-solution",
                "content": "```js\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nvar exclusiveTime = function(n, logs) {\\n  const stack = [];\\n  const ret = [];\\n  for (const log of logs) {\\n    const [id, func, ts] = log.split(\":\");\\n    if (func === \"start\") {\\n      if (stack.length) {\\n        const s = stack[stack.length - 1];\\n        s[2] += +ts - s[1];\\n      }\\n      stack.push([+id, +ts, 0]);\\n    } else if (func === \"end\") {\\n      const s = stack.pop();\\n      ret[s[0]] = (ret[s[0]] || 0) + s[2] + +ts - s[1] + 1;\\n      if (stack.length) {\\n        stack[stack.length - 1][1] = +ts + 1;\\n      }\\n    }\\n  }\\n\\n  return ret;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nvar exclusiveTime = function(n, logs) {\\n  const stack = [];\\n  const ret = [];\\n  for (const log of logs) {\\n    const [id, func, ts] = log.split(\":\");\\n    if (func === \"start\") {\\n      if (stack.length) {\\n        const s = stack[stack.length - 1];\\n        s[2] += +ts - s[1];\\n      }\\n      stack.push([+id, +ts, 0]);\\n    } else if (func === \"end\") {\\n      const s = stack.pop();\\n      ret[s[0]] = (ret[s[0]] || 0) + s[2] + +ts - s[1] + 1;\\n      if (stack.length) {\\n        stack[stack.length - 1][1] = +ts + 1;\\n      }\\n    }\\n  }\\n\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360388,
                "title": "python3-super-clean-functional-programming",
                "content": "More clear separation of responsibilities. Use of normalizer to fix the gratuitous inconsistency in the \\'start\\' and \\'end\\' timestamp definition. Use \\'start\\' and \\'end\\' keywords to trigger the appropriate stack operation rather than if conditionals. An attempt of functional programming on a simple problem.\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack, output = [], [0] * n\\n        \\n        normalize = lambda k, e, t : \\\\\\n            [int(k), e, int(t) + (1 if e == \\'end\\' else 0)]\\n        \\n        stack_ops = {   \\'start\\' : lambda k : stack.append(k), \\\\\\n                        \\'end\\' : lambda k : stack.pop(), }\\n        \\n        for log in logs:\\n            k, e, t = normalize(*log.split(\\':\\'))\\n            if stack:\\n                output[stack[-1]] += t - last_t\\n            stack_ops[e](k)\\n            last_t = t\\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack, output = [], [0] * n\\n        \\n        normalize = lambda k, e, t : \\\\\\n            [int(k), e, int(t) + (1 if e == \\'end\\' else 0)]\\n        \\n        stack_ops = {   \\'start\\' : lambda k : stack.append(k), \\\\\\n                        \\'end\\' : lambda k : stack.pop(), }\\n        \\n        for log in logs:\\n            k, e, t = normalize(*log.split(\\':\\'))\\n            if stack:\\n                output[stack[-1]] += t - last_t\\n            stack_ops[e](k)\\n            last_t = t\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287763,
                "title": "python-recursive",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        i = 0\\n        res = defaultdict(int)\\n        while i < len(logs):\\n            i, _ = self.process(logs, i, res)\\n        result = []\\n        k = 0\\n        while str(k) in res:\\n            result.append(res[str(k)])\\n            k+=1\\n            \\n        return result\\n    \\n    \\n    def process(self, logs,i, res):\\n\\n        idx, action, time = logs[i].split(\\':\\')\\n        i += 1\\n\\n        next_idx, next_action, next_time = logs[i].split(\\':\\')\\n        elapse = 0\\n        while next_action == \\'start\\':\\n            i, new_elapse = self.process(logs, i, res)\\n            elapse += new_elapse\\n            next_idx, next_action, next_time = logs[i].split(\\':\\')\\n            \\n        res[idx] += int(next_time) - int(time) - elapse +1\\n        return i+1, int(next_time) - int(time) + 1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        i = 0\\n        res = defaultdict(int)\\n        while i < len(logs):\\n            i, _ = self.process(logs, i, res)\\n        result = []\\n        k = 0\\n        while str(k) in res:\\n            result.append(res[str(k)])\\n            k+=1\\n            \\n        return result\\n    \\n    \\n    def process(self, logs,i, res):\\n\\n        idx, action, time = logs[i].split(\\':\\')\\n        i += 1\\n\\n        next_idx, next_action, next_time = logs[i].split(\\':\\')\\n        elapse = 0\\n        while next_action == \\'start\\':\\n            i, new_elapse = self.process(logs, i, res)\\n            elapse += new_elapse\\n            next_idx, next_action, next_time = logs[i].split(\\':\\')\\n            \\n        res[idx] += int(next_time) - int(time) - elapse +1\\n        return i+1, int(next_time) - int(time) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222527,
                "title": "neat-python-solution",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [0 for _ in range(n)]\\n        stack = []\\n        m = len(logs)\\n        for i in range(m-1):\\n            line1 = logs[i].split(\\':\\')\\n            line2 = logs[i+1].split(\\':\\')\\n            if line1[1] == \\'start\\':\\n                func = int(line1[0])\\n                time = int(line2[2]) - int(line1[2])\\n                stack.append([func, time])\\n            else:\\n                func, time = stack.pop(-1)\\n                ans[func] += time+1\\n                if stack:\\n                    stack[-1][1] += int(line2[2]) - int(line1[2]) - 1\\n                    \\n        ans[stack[0][0]] += stack[0][1]+1\\n        return ans\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [0 for _ in range(n)]\\n        stack = []\\n        m = len(logs)\\n        for i in range(m-1):\\n            line1 = logs[i].split(\\':\\')\\n            line2 = logs[i+1].split(\\':\\')\\n            if line1[1] == \\'start\\':\\n                func = int(line1[0])\\n                time = int(line2[2]) - int(line1[2])\\n                stack.append([func, time])\\n            else:\\n                func, time = stack.pop(-1)\\n                ans[func] += time+1\\n                if stack:\\n                    stack[-1][1] += int(line2[2]) - int(line1[2]) - 1\\n                    \\n        ans[stack[0][0]] += stack[0][1]+1\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 3533759,
                "title": "o-n-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Integer> stack = new Stack<>();\\n        int[] ans = new int[n];\\n        int prevTime=0;\\n        int last=0;\\n        for(String log : logs){\\n            String[] logarr = log.split(\":\");\\n            int id = Integer.parseInt(logarr[0]);\\n            int time = Integer.parseInt(logarr[2]);\\n            \\n            if(logarr[1].equals(\"start\")){\\n                if(!stack.isEmpty()){\\n                    ans[stack.peek()]+=time-prevTime;\\n                }\\n                stack.push(id);\\n                prevTime=time;\\n            }else{\\n                int topind = stack.pop();                \\n                ans[topind]+=time-prevTime+1;   \\n                prevTime=time+1; \\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Integer> stack = new Stack<>();\\n        int[] ans = new int[n];\\n        int prevTime=0;\\n        int last=0;\\n        for(String log : logs){\\n            String[] logarr = log.split(\":\");\\n            int id = Integer.parseInt(logarr[0]);\\n            int time = Integer.parseInt(logarr[2]);\\n            \\n            if(logarr[1].equals(\"start\")){\\n                if(!stack.isEmpty()){\\n                    ans[stack.peek()]+=time-prevTime;\\n                }\\n                stack.push(id);\\n                prevTime=time;\\n            }else{\\n                int topind = stack.pop();                \\n                ans[topind]+=time-prevTime+1;   \\n                prevTime=time+1; \\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481472,
                "title": "java-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Func>s=new Stack<>();\\n        int []array=new int[n];\\n        for(String str:logs)\\n        {\\n            Func temp=new Func(str);\\n            if(temp.start)\\n            {\\n                if(!s.isEmpty())\\n                    array[s.peek().id]+=temp.time-s.peek().time;\\n                s.add(temp);\\n            }\\n            else\\n            {\\n                array[s.peek().id]+=1+temp.time-(s.peek().time);\\n                s.pop();\\n                if(!s.isEmpty())\\n                    s.peek().time=temp.time+1;\\n            }\\n        }\\n        return array;   \\n    }\\n}\\n\\nclass Func{\\n    int id;\\n    boolean start;\\n    int time;\\n    Func(String s)\\n    {\\n        String [] arr=s.split(\":\");\\n        id=Integer.parseInt(arr[0]);\\n        start=arr[1].equals(\"start\");\\n        time=Integer.parseInt(arr[2]);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Func>s=new Stack<>();\\n        int []array=new int[n];\\n        for(String str:logs)\\n        {\\n            Func temp=new Func(str);\\n            if(temp.start)\\n            {\\n                if(!s.isEmpty())\\n                    array[s.peek().id]+=temp.time-s.peek().time;\\n                s.add(temp);\\n            }\\n            else\\n            {\\n                array[s.peek().id]+=1+temp.time-(s.peek().time);\\n                s.pop();\\n                if(!s.isEmpty())\\n                    s.peek().time=temp.time+1;\\n            }\\n        }\\n        return array;   \\n    }\\n}\\n\\nclass Func{\\n    int id;\\n    boolean start;\\n    int time;\\n    Func(String s)\\n    {\\n        String [] arr=s.split(\":\");\\n        id=Integer.parseInt(arr[0]);\\n        start=arr[1].equals(\"start\");\\n        time=Integer.parseInt(arr[2]);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416483,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n    enum Event {kStart, kEnd};\\n    vector<int> ans;\\n    tuple<int, enum Event, int> parseLog(const string &log)\\n    {\\n        tuple<int, enum Event, int> ret;\\n        int pos = log.find(\\':\\');\\n        get<0>(ret) = stoi(log.substr(0, pos));\\n        int prev = pos; pos = log.find(\\':\\', prev+1);\\n\\n        get<1>(ret) = (log.substr(prev+1, pos-prev-1) == \"start\") ? kStart : kEnd;\\n        get<2>(ret) = stoi(log.substr(pos+1));\\n        return ret;\\n    }\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        ans = vector<int>(n, 0);\\n        stack<pair<int, int> > s;\\n        stack<pair<int, int> > res;\\n        int level = 0;\\n\\n        for (int i = 0; i < logs.size(); i++)\\n        {\\n            auto[fid, event, timestamp] = parseLog(logs[i]);\\n            if (event == kStart)\\n            {\\n                level++;\\n                s.push({fid, timestamp});\\n            }\\n            else \\n            {\\n                level--;\\n                pair<int, int> top = s.top();\\n                ans[top.first] += timestamp-top.second+1;\\n                int temp = timestamp-top.second+1;\\n                s.pop();\\n                while (!res.empty() && res.top().second > level)\\n                {\\n                    ans[top.first] -= res.top().first;\\n                    res.pop();\\n                }\\n                res.push({temp, level});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        res = [0 for _ in range(n)]\\n        s = []\\n        currt = 0\\n\\t\\t\\n        for log in logs: \\n                \\n            fid, state, timestamp = log.split(\":\")\\n            \\n            fid = int(fid)\\n            timestamp = int(timestamp)\\n            \\n            if state == \"end\":\\n                s.pop()\\n                res[fid] += timestamp - currt+1\\n                currt = timestamp + 1\\n            else:\\n                if (s):\\n                    fidprev,time = s[-1]\\n                    res[fidprev] += timestamp - currt\\n                s.append((fid,timestamp))\\n                currt = timestamp\\n            \\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        if (n == 0 || logs == null || logs.size() == 0) {\\n            return result;\\n        }\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int prevTime = 0;\\n\\n        for (String log : logs) {\\n            String[] logParts = log.split(\":\");\\n            int curTime = Integer.parseInt(logParts[2]);\\n\\n            if (\"start\".equals(logParts[1])) {\\n                if (!stack.isEmpty()) {\\n                    result[stack.peek()] += curTime - prevTime;\\n                }\\n                stack.push(Integer.parseInt(logParts[0]));\\n                prevTime = curTime;\\n            } else {\\n                result[stack.pop()] += curTime - prevTime + 1;\\n                prevTime = curTime + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n    enum Event {kStart, kEnd};\\n    vector<int> ans;\\n    tuple<int, enum Event, int> parseLog(const string &log)\\n    {\\n        tuple<int, enum Event, int> ret;\\n        int pos = log.find(\\':\\');\\n        get<0>(ret) = stoi(log.substr(0, pos));\\n        int prev = pos; pos = log.find(\\':\\', prev+1);\\n\\n        get<1>(ret) = (log.substr(prev+1, pos-prev-1) == \"start\") ? kStart : kEnd;\\n        get<2>(ret) = stoi(log.substr(pos+1));\\n        return ret;\\n    }\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        ans = vector<int>(n, 0);\\n        stack<pair<int, int> > s;\\n        stack<pair<int, int> > res;\\n        int level = 0;\\n\\n        for (int i = 0; i < logs.size(); i++)\\n        {\\n            auto[fid, event, timestamp] = parseLog(logs[i]);\\n            if (event == kStart)\\n            {\\n                level++;\\n                s.push({fid, timestamp});\\n            }\\n            else \\n            {\\n                level--;\\n                pair<int, int> top = s.top();\\n                ans[top.first] += timestamp-top.second+1;\\n                int temp = timestamp-top.second+1;\\n                s.pop();\\n                while (!res.empty() && res.top().second > level)\\n                {\\n                    ans[top.first] -= res.top().first;\\n                    res.pop();\\n                }\\n                res.push({temp, level});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        res = [0 for _ in range(n)]\\n        s = []\\n        currt = 0\\n\\t\\t\\n        for log in logs: \\n                \\n            fid, state, timestamp = log.split(\":\")\\n            \\n            fid = int(fid)\\n            timestamp = int(timestamp)\\n            \\n            if state == \"end\":\\n                s.pop()\\n                res[fid] += timestamp - currt+1\\n                currt = timestamp + 1\\n            else:\\n                if (s):\\n                    fidprev,time = s[-1]\\n                    res[fidprev] += timestamp - currt\\n                s.append((fid,timestamp))\\n                currt = timestamp\\n            \\n        return res\\n```\n```Java []\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        if (n == 0 || logs == null || logs.size() == 0) {\\n            return result;\\n        }\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        int prevTime = 0;\\n\\n        for (String log : logs) {\\n            String[] logParts = log.split(\":\");\\n            int curTime = Integer.parseInt(logParts[2]);\\n\\n            if (\"start\".equals(logParts[1])) {\\n                if (!stack.isEmpty()) {\\n                    result[stack.peek()] += curTime - prevTime;\\n                }\\n                stack.push(Integer.parseInt(logParts[0]));\\n                prevTime = curTime;\\n            } else {\\n                result[stack.pop()] += curTime - prevTime + 1;\\n                prevTime = curTime + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113137,
                "title": "simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> exec_time(n, 0);\\n\\t\\t// we\\'re using a pair [process_id, start_time]\\n        stack<pair<int, int>> processing;\\n\\n        for (const auto& log : logs) {\\n            // tokenize the string\\n            std::stringstream sstream(log);\\n            string id; getline(sstream, id, \\':\\');\\n            string op; getline(sstream, op, \\':\\');\\n            string ts; getline(sstream, ts, \\':\\');\\n\\n            if (op == \"start\") {\\n                // add process to stack, convert strings to ints\\n                processing.emplace(std::stoi(id), std::stoi(ts));\\n            } else {\\n                // c++17 structured binding\\n                auto [process_id, start_time] = processing.top();\\n                processing.pop();\\n\\n                // get the process time and set it\\n                auto offset = stoi(ts) - start_time + 1;\\n                exec_time[process_id] += offset;\\n\\n                // if stack is not empty, a process was on hold\\n                // we need to remove the time elapsed since before we resume\\n                if (!std::empty(processing)) {\\n                    exec_time[processing.top().first] -= offset;\\n                }\\n            }\\n        }\\n        return exec_time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> exec_time(n, 0);\\n\\t\\t// we\\'re using a pair [process_id, start_time]\\n        stack<pair<int, int>> processing;\\n\\n        for (const auto& log : logs) {\\n            // tokenize the string\\n            std::stringstream sstream(log);\\n            string id; getline(sstream, id, \\':\\');\\n            string op; getline(sstream, op, \\':\\');\\n            string ts; getline(sstream, ts, \\':\\');\\n\\n            if (op == \"start\") {\\n                // add process to stack, convert strings to ints\\n                processing.emplace(std::stoi(id), std::stoi(ts));\\n            } else {\\n                // c++17 structured binding\\n                auto [process_id, start_time] = processing.top();\\n                processing.pop();\\n\\n                // get the process time and set it\\n                auto offset = stoi(ts) - start_time + 1;\\n                exec_time[process_id] += offset;\\n\\n                // if stack is not empty, a process was on hold\\n                // we need to remove the time elapsed since before we resume\\n                if (!std::empty(processing)) {\\n                    exec_time[processing.top().first] -= offset;\\n                }\\n            }\\n        }\\n        return exec_time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451205,
                "title": "python-easy-to-understand-with-stack",
                "content": "```\\n\\t\\tfuncTime = [0 for _ in range(n)]\\n        stack = []\\n        \\n        for log in logs:\\n            rec = log.split(\":\")\\n            ID = int(rec[0])\\n            SE = rec[1]\\n            timeStamp = int(rec[2])\\n            \\n            if SE == \"start\":\\n                stack.append([ID, SE, timeStamp])\\n            elif SE == \"end\":\\n                start = stack.pop()\\n                interval = timeStamp - start[2] + 1\\n                funcTime[ID] += interval\\n                if stack:\\n                    lastRec = stack.pop()\\n                    funcTime[lastRec[0]] -= interval\\n                    stack.append(lastRec)\\n                    \\n        return funcTime\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n\\t\\tfuncTime = [0 for _ in range(n)]\\n        stack = []\\n        \\n        for log in logs:\\n            rec = log.split(\":\")\\n            ID = int(rec[0])\\n            SE = rec[1]\\n            timeStamp = int(rec[2])\\n            \\n            if SE == \"start\":\\n                stack.append([ID, SE, timeStamp])\\n            elif SE == \"end\":\\n                start = stack.pop()\\n                interval = timeStamp - start[2] + 1\\n                funcTime[ID] += interval\\n                if stack:\\n                    lastRec = stack.pop()\\n                    funcTime[lastRec[0]] -= interval\\n                    stack.append(lastRec)\\n                    \\n        return funcTime\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2409422,
                "title": "c-stack-o-n-time-and-space-commented",
                "content": "Intuition : use stack, as function calls are recursive in nature. \\nThe idea here is we **maintain the time taken by execution of child function calls** for every parent function and we subtract that value from the time parent function remained in the stack(end - start + 1) to get the actual execution time of parent function.\\n**when we perform pop operation on function end, after pop , we add its execution time to its parent i.e. top of stack at that moment (after the pop operation ) .**\\nthe stack pop operation is the catch in this question.\\n```\\nclass Solution {\\npublic:\\n    \\n    void decode(string str, int& id, int& timestamp, string& status){\\n        int k = 0, j = 0;\\n        while(str[j] != \\':\\'){\\n            j++;\\n        }\\n        id = stoi(str.substr(0, j-k));\\n        k = ++j;\\n        while(str[j] != \\':\\'){\\n            j++;\\n        }\\n        status = str.substr(k, j-k);\\n        j++;\\n        timestamp = stoi(str.substr(j));\\n    }\\n    \\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        stack<vector<int>> s;     // vector = { id, start time, child execution time }\\n        vector<int> res(n);        \\n        \\n        for(int i = 0; i<logs.size(); i++){\\n            \\n            string status = \"\";\\n            int id, timestamp ;\\n            decode(logs[i], id, timestamp, status);\\n            \\n            if(status == \"start\"){\\n                s.push({id, timestamp, 0});\\n            }\\n            else{\\n                int startToend = (timestamp - s.top()[1] + 1);\\n                res[id] += startToend - s.top()[2]; // startToend - time taken by child function calls\\n                s.pop();\\n                // when ever a function call ends, add its execution time to it\\'s parent\\'s child execution time\\n                if(!s.empty()){\\n                    auto v = s.top();\\n                    s.pop();\\n                    v[2] += startToend;\\n                    s.push(v);\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Please upvote** if you have understood!",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void decode(string str, int& id, int& timestamp, string& status){\\n        int k = 0, j = 0;\\n        while(str[j] != \\':\\'){\\n            j++;\\n        }\\n        id = stoi(str.substr(0, j-k));\\n        k = ++j;\\n        while(str[j] != \\':\\'){\\n            j++;\\n        }\\n        status = str.substr(k, j-k);\\n        j++;\\n        timestamp = stoi(str.substr(j));\\n    }\\n    \\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        stack<vector<int>> s;     // vector = { id, start time, child execution time }\\n        vector<int> res(n);        \\n        \\n        for(int i = 0; i<logs.size(); i++){\\n            \\n            string status = \"\";\\n            int id, timestamp ;\\n            decode(logs[i], id, timestamp, status);\\n            \\n            if(status == \"start\"){\\n                s.push({id, timestamp, 0});\\n            }\\n            else{\\n                int startToend = (timestamp - s.top()[1] + 1);\\n                res[id] += startToend - s.top()[2]; // startToend - time taken by child function calls\\n                s.pop();\\n                // when ever a function call ends, add its execution time to it\\'s parent\\'s child execution time\\n                if(!s.empty()){\\n                    auto v = s.top();\\n                    s.pop();\\n                    v[2] += startToend;\\n                    s.push(v);\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391458,
                "title": "python3-simple-efficient-performance-readable",
                "content": "Simple approach in Python3 which runs in top 90% and is in top 99% memory. *(Of course this is highly variable on Leetcode due to infrastructure).*\\n\\nThis implementation precreates a total time arrays of size `n` called `times` which is indexed by funciton `id`.  It also creates a shared stack array called `stack`.  It also uses `last_id` and `last_t` to hold the priors.  Then, for every log entry string, parse it into simple `id`, `start`, and `t` (as `int`, `bool`, and `int` datatypes).  \\n\\nIf the current entry is a `start` call, then increment the total function time for the previous function id (`last_id`) and add the `last_id` to the stack.  Then, save the current values of id and t using `last_id = id` and `last_t = t`.\\n\\nOtherwise, it\\'s an `end` entry, so increment the total function time for the current function `id` and add +1 to track the time-boundaries for the problem.  Also, update `last_id = stack.pop()` and `last_t = t + 1` to account for the boundary condition.\\n\\n**Note**: This problem is limited to `100` functions and `500` lines in a log. If it were more intense, it might warrant using **tail recursion** for a slight optimization.\\n\\n\\n### Python3 Code\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        times, stack = [0] * n, []\\n        last_id, last_t = 0, 0\\n\\n        for line in logs:\\n            f = line.split(\\':\\')\\n            id, start, t = int(f[0]), f[1]==\\'start\\', int(f[2])\\n            if start:\\n                times[last_id] += (t - last_t)\\n                stack.append(last_id)\\n                last_id, last_t = id, t\\n            else:\\n                times[id] += (t - last_t + 1)\\n                last_id, last_t = stack.pop(), t + 1\\n\\n        return times\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        times, stack = [0] * n, []\\n        last_id, last_t = 0, 0\\n\\n        for line in logs:\\n            f = line.split(\\':\\')\\n            id, start, t = int(f[0]), f[1]==\\'start\\', int(f[2])\\n            if start:\\n                times[last_id] += (t - last_t)\\n                stack.append(last_id)\\n                last_id, last_t = id, t\\n            else:\\n                times[id] += (t - last_t + 1)\\n                last_id, last_t = stack.pop(), t + 1\\n\\n        return times\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2326885,
                "title": "java-faster-than-90-simple-stack-based-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int time = 0;\\n        Stack<int[]> stack = new Stack<>();\\n        int result[] = new int[n];\\n\\n        for(String s : logs){\\n            int functionId = Integer.parseInt(s.substring(0,s.indexOf(\":\")));\\n            String command = s.substring(s.indexOf(\":\")+1, s.lastIndexOf(\":\"));\\n            int timestamp = Integer.parseInt(s.substring(s.lastIndexOf(\":\")+1));\\n            \\n            if(command.equals(\"start\")) stack.push(new int[] {functionId,timestamp});\\n            \\n            else {\\n                int dur = (timestamp - stack.peek()[1]) + 1;\\n                result[functionId] += dur;\\n                stack.pop();\\n                if(!stack.isEmpty()) result[stack.peek()[0]] -= dur;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int time = 0;\\n        Stack<int[]> stack = new Stack<>();\\n        int result[] = new int[n];\\n\\n        for(String s : logs){\\n            int functionId = Integer.parseInt(s.substring(0,s.indexOf(\":\")));\\n            String command = s.substring(s.indexOf(\":\")+1, s.lastIndexOf(\":\"));\\n            int timestamp = Integer.parseInt(s.substring(s.lastIndexOf(\":\")+1));\\n            \\n            if(command.equals(\"start\")) stack.push(new int[] {functionId,timestamp});\\n            \\n            else {\\n                int dur = (timestamp - stack.peek()[1]) + 1;\\n                result[functionId] += dur;\\n                stack.pop();\\n                if(!stack.isEmpty()) result[stack.peek()[0]] -= dur;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204639,
                "title": "c-two-approach-easy-to-understand",
                "content": "### **Approach 1: Using stack**\\n\\nclass Solution {\\npublic:\\n\\t\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n\\t\\t// pair is implemented as : pair<id, pair<tstamp, extra>>\\n        stack<pair<int, pair<int, int>>> st;\\n        vector<int> exclusive(n, 0);\\n        \\n        for(int i=0; i<logs.size(); ++i){\\n            string log = logs[i];\\n            \\n            int f = log.find(\\':\\');\\n            int l = log.rfind(\\':\\');\\n            \\n            int id = stoi(log.substr(0, f));\\n            char c = log[f+1];\\n            int tstamp = stoi(log.substr(l+1));\\n            \\n            if(c == \\'s\\'){\\n                st.push({id, {tstamp, 0}});\\n            } else {\\n                int time = tstamp - st.top().second.first + 1 - st.top().second.second;\\n                exclusive[id] += time;\\n                int extra = st.top().second.second; // extra stores extra time of each log\\n                st.pop();\\n                if(!st.empty()) st.top().second.second += time + extra;\\n            }\\n        }\\n        \\n        return exclusive;\\n    }\\n};\\n\\n### **Approach 2: Using vector**\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<array<int, 3>> v;\\n        vector<int> exclusive(n, 0);\\n        \\n        for(int i=0; i<logs.size(); ++i){\\n            string log = logs[i];\\n            \\n            int f = log.find(\\':\\');\\n            int l = log.rfind(\\':\\');\\n            \\n            int id = stoi(log.substr(0, f));\\n            char c = log[f+1];\\n            int tstamp = stoi(log.substr(l+1));\\n            \\n            if(c == \\'s\\'){\\n                v.push_back({id, tstamp, 0});\\n            } else {\\n                int time = tstamp - v.back()[1] + 1 - v.back()[2];\\n                exclusive[id] += time;\\n                int extra = v.back()[2];\\n                v.pop_back();\\n                if(!v.empty()) v.back()[2] += time + extra;\\n            }\\n        }\\n        \\n        return exclusive;\\n    }\\n};\\n\\nNote: For better understanding and learning, consider dry running the code yourself. For query and suggestion comment below.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n\\t\\t// pair is implemented as : pair<id, pair<tstamp, extra>>\\n        stack<pair<int, pair<int, int>>> st;\\n        vector<int> exclusive(n, 0);\\n        \\n        for(int i=0; i<logs.size(); ++i){\\n            string log = logs[i];\\n            \\n            int f = log.find(\\':\\');\\n            int l = log.rfind(\\':\\');\\n            \\n            int id = stoi(log.substr(0, f));\\n            char c = log[f+1];\\n            int tstamp = stoi(log.substr(l+1));\\n            \\n            if(c == \\'s\\'){\\n                st.push({id, {tstamp, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2203905,
                "title": "python-slightly-different-stack-solution",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        # result array\\n        res = [0] * n\\n        stack = []\\n        for log in logs:            \\n            # parsing next log record\\n            parts = log.split(\\':\\')\\n            id, state, time = int(parts[0]), parts[1], int(parts[2])\\n            if state == \"end\":\\n                # pop the start task record from stack\\n                start_time, exclude_time = stack.pop()                \\n                # total function time\\n                total_time = time - start_time + 1                 \\n                # add exclusive time to the result\\n                res[id] += total_time - exclude_time\\n                # add exclude time which is currently ended function total time\\n                # to the parent task at the top of the stack\\n                if stack:\\n                    stack[-1][1] += total_time\\n            else:\\n                # task start, add to the stack\\n                stack.append([time, 0])            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        # result array\\n        res = [0] * n\\n        stack = []\\n        for log in logs:            \\n            # parsing next log record\\n            parts = log.split(\\':\\')\\n            id, state, time = int(parts[0]), parts[1], int(parts[2])\\n            if state == \"end\":\\n                # pop the start task record from stack\\n                start_time, exclude_time = stack.pop()                \\n                # total function time\\n                total_time = time - start_time + 1                 \\n                # add exclusive time to the result\\n                res[id] += total_time - exclude_time\\n                # add exclude time which is currently ended function total time\\n                # to the parent task at the top of the stack\\n                if stack:\\n                    stack[-1][1] += total_time\\n            else:\\n                # task start, add to the stack\\n                stack.append([time, 0])            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200201,
                "title": "98-fastest-java-easiest-solution",
                "content": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int a[] = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n         Stack<Integer> sstack = new Stack<>();\\n        boolean flag = false;\\n        for(String s: logs) {\\n            int aa = s.indexOf(\\':\\');\\n            int b = s.lastIndexOf(\\':\\');\\n            int id = Integer.parseInt(s.substring(0,aa));\\n            char status = s.charAt(aa+1);\\n            int duration = Integer.parseInt(s.substring(b+1));\\n            if(status == \\'s\\') {\\n                if(!stack.isEmpty()) {\\n                    if(flag)\\n                        a[stack.peek()] += duration - sstack.peek()-1;\\n                    else\\n                        a[stack.peek()] += duration - sstack.peek();\\n                }\\n                stack.push(id);\\n                sstack.push(duration);\\n                flag = false;\\n            }\\n            else {\\n                if(flag)\\n                    a[stack.peek()] += duration - sstack.pop();\\n                else\\n                    a[stack.peek()] += duration - sstack.pop() + 1;\\n                stack.pop();\\n                sstack.push(duration);\\n                flag = true;\\n            }\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int a[] = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n         Stack<Integer> sstack = new Stack<>();\\n        boolean flag = false;\\n        for(String s: logs) {\\n            int aa = s.indexOf(\\':\\');\\n            int b = s.lastIndexOf(\\':\\');\\n            int id = Integer.parseInt(s.substring(0,aa));\\n            char status = s.charAt(aa+1);\\n            int duration = Integer.parseInt(s.substring(b+1));\\n            if(status == \\'s\\') {\\n                if(!stack.isEmpty()) {\\n                    if(flag)\\n                        a[stack.peek()] += duration - sstack.peek()-1;\\n                    else\\n                        a[stack.peek()] += duration - sstack.peek();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2111620,
                "title": "python-o-n-with-stack-simple",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        functions = [0] * n\\n        stack = []\\n        \\n        old_time = 0\\n        for log in logs:\\n            pid, action, time = log.split(\":\")\\n            pid, time = int(pid), int(time)\\n            \\n            ad_time = time + (action == \"end\") # adjusted time\\n            \\n            if stack:\\n                peek = stack[-1]\\n                functions[peek] += ad_time - old_time\\n            \\n            if action == \"start\":\\n                stack.append(pid)\\n            elif action == \"end\":\\n                stack.pop()\\n            \\n            old_time = ad_time\\n                \\n        return functions\\n\\t```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        functions = [0] * n\\n        stack = []\\n        \\n        old_time = 0\\n        for log in logs:\\n            pid, action, time = log.split(\":\")\\n            pid, time = int(pid), int(time)\\n            \\n            ad_time = time + (action == \"end\") # adjusted time\\n            \\n            if stack:\\n                peek = stack[-1]\\n                functions[peek] += ad_time - old_time\\n            \\n            if action == \"start\":\\n                stack.append(pid)\\n            elif action == \"end\":\\n                stack.pop()\\n            \\n            old_time = ad_time\\n                \\n        return functions\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2102277,
                "title": "exclusive-time-of-functions-t-o-n-s-o-d",
                "content": "```\\nclass Solution:\\n    #T=O(n), S=O(d)\\n    #n=len of logs, d=depth of stack\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        #init result array to zeroes of length n (function ids)\\n        res = [0]*n\\n        stack = []\\n        #iterate through logs\\n        for log in logs:\\n            #split the log\\n            #function_id: start|end: timestamp\\n            log = log.split(\":\")\\n            #type cast function id and timestamp to int type\\n            id = int(log[0])\\n            timestamp = int(log[2])\\n            state = log[1]\\n            #detect start of a function call\\n            #stack[function_id, start_timestamp]\\n            if state == \"start\":\\n                #stack is non empty\\n                if stack:\\n                    #get the time taken by last function so far\\n                    res[stack[-1][0]] += timestamp - stack[-1][1]\\n                #append the current function_id and start timestamp to the stack\\n                stack.append([id, timestamp])\\n            else:\\n                #get the time consumed by current function\\n                #dont forget to add 1 as the last unit of time should be included\\n                res[id] += timestamp - stack.pop()[1] + 1 \\n                if stack:\\n                    #update the start time of last function in stack to get the cumulative result\\n                    stack[-1][1] = timestamp + 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    #T=O(n), S=O(d)\\n    #n=len of logs, d=depth of stack\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        #init result array to zeroes of length n (function ids)\\n        res = [0]*n\\n        stack = []\\n        #iterate through logs\\n        for log in logs:\\n            #split the log\\n            #function_id: start|end: timestamp\\n            log = log.split(\":\")\\n            #type cast function id and timestamp to int type\\n            id = int(log[0])\\n            timestamp = int(log[2])\\n            state = log[1]\\n            #detect start of a function call\\n            #stack[function_id, start_timestamp]\\n            if state == \"start\":\\n                #stack is non empty\\n                if stack:\\n                    #get the time taken by last function so far\\n                    res[stack[-1][0]] += timestamp - stack[-1][1]\\n                #append the current function_id and start timestamp to the stack\\n                stack.append([id, timestamp])\\n            else:\\n                #get the time consumed by current function\\n                #dont forget to add 1 as the last unit of time should be included\\n                res[id] += timestamp - stack.pop()[1] + 1 \\n                if stack:\\n                    #update the start time of last function in stack to get the cumulative result\\n                    stack[-1][1] = timestamp + 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099228,
                "title": "c-solution-using-one-stack-o-n",
                "content": "```\\npublic class Solution {\\n    public int[] ExclusiveTime(int n, IList<string> logs) {\\n        \\n        Stack<KeyValuePair<int,int>> stack = new();\\n        int[] functime = new int[n];\\n        \\n        foreach(string s in logs)\\n        {\\n            string[] split = s.Split(\":\");\\n            int func = int.Parse(split[0]);\\n            int time = int.Parse(split[2]);\\n            \\n            if (split[1]==\"start\")\\n            {\\n                if (stack.Count()!=0)\\n                    functime[stack.Peek().Key] += time - stack.Peek().Value;\\n\\n                stack.Push(new KeyValuePair<int,int>(func, time));\\n            }\\n            else\\n            {\\n                functime[func] += time - stack.Pop().Value + 1;\\n                \\n                if (stack.Count()!=0)\\n                    stack.Push(new KeyValuePair<int,int> (stack.Pop().Key, time+1));\\n            }          \\n        }\\n        \\n        return functime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ExclusiveTime(int n, IList<string> logs) {\\n        \\n        Stack<KeyValuePair<int,int>> stack = new();\\n        int[] functime = new int[n];\\n        \\n        foreach(string s in logs)\\n        {\\n            string[] split = s.Split(\":\");\\n            int func = int.Parse(split[0]);\\n            int time = int.Parse(split[2]);\\n            \\n            if (split[1]==\"start\")\\n            {\\n                if (stack.Count()!=0)\\n                    functime[stack.Peek().Key] += time - stack.Peek().Value;\\n\\n                stack.Push(new KeyValuePair<int,int>(func, time));\\n            }\\n            else\\n            {\\n                functime[func] += time - stack.Pop().Value + 1;\\n                \\n                if (stack.Count()!=0)\\n                    stack.Push(new KeyValuePair<int,int> (stack.Pop().Key, time+1));\\n            }          \\n        }\\n        \\n        return functime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039018,
                "title": "clean-javascript-solution",
                "content": "```\\nvar exclusiveTime = function (n, logs) {\\n    let stack = [];\\n    let res = new Array(n).fill(0);\\n    for (let content of logs) {\\n        let log = new Log(content);\\n\\n        if (log.isStart) {\\n            stack.push(log);\\n        } else {\\n            let top = stack.pop();\\n            let interval = log.time - top.time + 1;\\n            res[log.id] += interval;\\n            if (stack.length) {\\n                res[stack[stack.length - 1].id] -= log.time - top.time + 1;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nclass Log {\\n    constructor(content) {\\n        let [id, event, time] = content.split(\":\");\\n        this.id = parseInt(id);\\n        this.isStart = event === \"start\";\\n        this.time = parseInt(time);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar exclusiveTime = function (n, logs) {\\n    let stack = [];\\n    let res = new Array(n).fill(0);\\n    for (let content of logs) {\\n        let log = new Log(content);\\n\\n        if (log.isStart) {\\n            stack.push(log);\\n        } else {\\n            let top = stack.pop();\\n            let interval = log.time - top.time + 1;\\n            res[log.id] += interval;\\n            if (stack.length) {\\n                res[stack[stack.length - 1].id] -= log.time - top.time + 1;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nclass Log {\\n    constructor(content) {\\n        let [id, event, time] = content.split(\":\");\\n        this.id = parseInt(id);\\n        this.isStart = event === \"start\";\\n        this.time = parseInt(time);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015755,
                "title": "java-using-stack-and-created-wrapper-class-o-n-space-and-o-n-time",
                "content": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        List<FunctionLog> logList = new ArrayList<>();\\n        for(String log : logs){\\n            String[] logData = log.split(\":\");\\n            int functionID = Integer.valueOf(logData[0]);\\n            int time = Integer.valueOf(logData[2]);\\n            boolean isStartTime = (logData[1].equals(\"start\") ? true : false);\\n            \\n            logList.add(new FunctionLog(functionID, time, isStartTime));\\n        }\\n        \\n        int numFunction = n;\\n        int[] ans = new int[numFunction];\\n        \\n        int prevTime = 0;\\n        Stack<Integer> st = new Stack<>();\\n        for(int i=0; i<logList.size(); i++){\\n            if(!st.isEmpty()){\\n                ans[st.peek()] += logList.get(i).time - prevTime;\\n            }\\n            \\n            prevTime = logList.get(i).time;\\n            if(logList.get(i).isStartTime){\\n                st.push(logList.get(i).functionID);\\n            }else{\\n                ans[st.pop()]++;\\n                prevTime++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private class FunctionLog{\\n        public int time;\\n        public int functionID;\\n        public boolean isStartTime;\\n        \\n        public FunctionLog(int functionID, int time, boolean isStartTime){\\n            this.functionID = functionID;\\n            this.time = time;\\n            this.isStartTime = isStartTime;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        List<FunctionLog> logList = new ArrayList<>();\\n        for(String log : logs){\\n            String[] logData = log.split(\":\");\\n            int functionID = Integer.valueOf(logData[0]);\\n            int time = Integer.valueOf(logData[2]);\\n            boolean isStartTime = (logData[1].equals(\"start\") ? true : false);\\n            \\n            logList.add(new FunctionLog(functionID, time, isStartTime));\\n        }\\n        \\n        int numFunction = n;\\n        int[] ans = new int[numFunction];\\n        \\n        int prevTime = 0;\\n        Stack<Integer> st = new Stack<>();\\n        for(int i=0; i<logList.size(); i++){\\n            if(!st.isEmpty()){\\n                ans[st.peek()] += logList.get(i).time - prevTime;\\n            }\\n            \\n            prevTime = logList.get(i).time;\\n            if(logList.get(i).isStartTime){\\n                st.push(logList.get(i).functionID);\\n            }else{\\n                ans[st.pop()]++;\\n                prevTime++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private class FunctionLog{\\n        public int time;\\n        public int functionID;\\n        public boolean isStartTime;\\n        \\n        public FunctionLog(int functionID, int time, boolean isStartTime){\\n            this.functionID = functionID;\\n            this.time = time;\\n            this.isStartTime = isStartTime;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014765,
                "title": "java-double-stack-solution",
                "content": "Hopefully self documenting code, but added comments just in case. This uses two simple stack which runs about 90% faster than other solutions but more importantly, hopefully easier to read.\\n\\nObviously for more readabilty, a sub class would be created, but this is a compromise and this pattern can be applied to other problems that require complex items (multi dimension) on the stack. Introduced in William Fiset videos on BFS search.\\n\\n```\\nclass Solution {\\n    public static final String START = \"start\";\\n    public static final int PID = 0;\\n    public static final int CMD = 1;\\n    public static final int TIME = 2;\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] count = new int[n];\\n        Deque<Integer> pidStack = new ArrayDeque<>();\\n        Deque<Integer> timeStack = new ArrayDeque<>();\\n        for(String entry: logs) {\\n            String[] curr = entry.trim().split(\":\");\\n            int pid_v = Integer.valueOf(curr[PID]);\\n            int time_v = Integer.valueOf(curr[TIME]);\\n            // nothing to do if it\\'s a start, we just need\\n            // to add it to the stack for later accounting\\n            if (START.equals(curr[CMD])) {\\n                pidStack.offerFirst(pid_v);\\n                timeStack.offerFirst(time_v);\\n            } else {\\n            // this is an end entry, we\\'re not going to add it but\\n            // take its counterpart (start) off since it\\'s guaranteed\\n            // to finish first in single processing\\n                int pid = pidStack.pollFirst();\\n                int starTime = timeStack.pollFirst();\\n                \\n            // we figure out how long it\\'s been running for \\n\\t\\t\\t// by taking the current entries time (an end time)\\n            // and subtract it from the starting time(top of the stack)\\n\\t\\t\\t// but we need to add 1 to include\\n            // the starting unit, ex [5,8] => 5,6,7,8 => 4\\n                int dt = time_v - starTime + 1; // plus 1 to be inclusive of start\\n                \\n            // apply this time unit to its respective pid, which can be extracted\\n            // from the end entry or the top popped off pid value since they\\n            // would be the same\\n                count[pid] += dt;\\n            \\n            // now if there was another process on the stack, it needs to know\\n            // that this time slice was not part of its \"total\" accounting so\\n            // we will put a negative placeholder in its slot so when its end\\n            // arrives, we will have its interrupts accounted for \\n\\t\\t\\t// total = (endTime - startTime - [interrupted times] + 1)\\n                if (!pidStack.isEmpty()) {\\n                    int topPid = pidStack.peekFirst();\\n                    count[topPid] -= dt;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static final String START = \"start\";\\n    public static final int PID = 0;\\n    public static final int CMD = 1;\\n    public static final int TIME = 2;\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] count = new int[n];\\n        Deque<Integer> pidStack = new ArrayDeque<>();\\n        Deque<Integer> timeStack = new ArrayDeque<>();\\n        for(String entry: logs) {\\n            String[] curr = entry.trim().split(\":\");\\n            int pid_v = Integer.valueOf(curr[PID]);\\n            int time_v = Integer.valueOf(curr[TIME]);\\n            // nothing to do if it\\'s a start, we just need\\n            // to add it to the stack for later accounting\\n            if (START.equals(curr[CMD])) {\\n                pidStack.offerFirst(pid_v);\\n                timeStack.offerFirst(time_v);\\n            } else {\\n            // this is an end entry, we\\'re not going to add it but\\n            // take its counterpart (start) off since it\\'s guaranteed\\n            // to finish first in single processing\\n                int pid = pidStack.pollFirst();\\n                int starTime = timeStack.pollFirst();\\n                \\n            // we figure out how long it\\'s been running for \\n\\t\\t\\t// by taking the current entries time (an end time)\\n            // and subtract it from the starting time(top of the stack)\\n\\t\\t\\t// but we need to add 1 to include\\n            // the starting unit, ex [5,8] => 5,6,7,8 => 4\\n                int dt = time_v - starTime + 1; // plus 1 to be inclusive of start\\n                \\n            // apply this time unit to its respective pid, which can be extracted\\n            // from the end entry or the top popped off pid value since they\\n            // would be the same\\n                count[pid] += dt;\\n            \\n            // now if there was another process on the stack, it needs to know\\n            // that this time slice was not part of its \"total\" accounting so\\n            // we will put a negative placeholder in its slot so when its end\\n            // arrives, we will have its interrupts accounted for \\n\\t\\t\\t// total = (endTime - startTime - [interrupted times] + 1)\\n                if (!pidStack.isEmpty()) {\\n                    int topPid = pidStack.peekFirst();\\n                    count[topPid] -= dt;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011939,
                "title": "concise-c-code-using-stack-beats-99",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        using T = pair<int,int>; // {id, start-time};\\n        stack<T> st;  \\n        vector<int> res(n, 0), toks(3);\\n        \\n        for (auto &s: logs) {\\n            toks = { stoi(s),\\n                    (s[s.find(\\':\\')+1]==\\'s\\')?0:1,\\n                    stoi(s.substr(s.rfind(\\':\\')+1)) };\\n            \\n            if (toks[1] == 0)   //\"start\"\\n                st.push({toks[0], toks[2] });\\n            else {\\n                int t = toks[2]-st.top().second +1;  \\n                res[st.top().first] += t;      // current function plus;\\n                st.pop();\\n                if (!st.empty())\\n                    res[st.top().first] -= t;   //previous function minus;\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        using T = pair<int,int>; // {id, start-time}",
                "codeTag": "Java"
            },
            {
                "id": 1908647,
                "title": "java-o-n-stack",
                "content": "```\\nclass Solution {\\n   public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<int[]> stack = new Stack<>();\\n        int[] res = new int[n];\\n                \\n        for(String log : logs){\\n            String[] logParts = log.split(\":\");\\n            int fid = Integer.parseInt(logParts[0]);\\n            int time = Integer.parseInt(logParts[2]);\\n            \\n            if(logParts[1].equals(\"start\")){\\n                stack.push(new int[]{time, fid});\\n            }\\n            else{\\n                int start = stack.pop()[0];\\n                int timeSpent = time - start + 1;\\n                res[fid] += timeSpent;\\n                if(!stack.empty()){\\n                    res[stack.peek()[1]] -= timeSpent;\\n                }\\n            }\\n        }\\n                           \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<int[]> stack = new Stack<>();\\n        int[] res = new int[n];\\n                \\n        for(String log : logs){\\n            String[] logParts = log.split(\":\");\\n            int fid = Integer.parseInt(logParts[0]);\\n            int time = Integer.parseInt(logParts[2]);\\n            \\n            if(logParts[1].equals(\"start\")){\\n                stack.push(new int[]{time, fid});\\n            }\\n            else{\\n                int start = stack.pop()[0];\\n                int timeSpent = time - start + 1;\\n                res[fid] += timeSpent;\\n                if(!stack.empty()){\\n                    res[stack.peek()[1]] -= timeSpent;\\n                }\\n            }\\n        }\\n                           \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1907452,
                "title": "java-solution-stack-based-easy-understanding-o-n",
                "content": "```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        // current running task will be at top of stack\\n        Stack<int[]> stk = new Stack<>();\\n        // store execution time for each task\\n        int[] res = new int[n];\\n        \\n        for(String log : logs) {\\n            String[] t = log.split(\":\");\\n            int id = Integer.parseInt(t[0]);\\n            int time = Integer.parseInt(t[2]);\\n            \\n            if(t[1].equals(\"start\")) {\\n                if(!stk.isEmpty()) {\\n                    // if stack is not empty calculate time of prev task and update result\\n                    int execTime = time - stk.peek()[1];\\n                    res[stk.peek()[0]] += execTime;\\n                }\\n                // add new task to stack\\n                stk.add(new int[] {id, time});\\n            } else {\\n                // calculate execution time of the task and update in result\\n                // also remove from stack\\n                int execTime = time - stk.peek()[1] + 1;\\n                res[stk.peek()[0]] += execTime;\\n                stk.pop();\\n                \\n                // update start time of task if any in the stack\\n                if(!stk.isEmpty()) stk.peek()[1] = time + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        // current running task will be at top of stack\\n        Stack<int[]> stk = new Stack<>();\\n        // store execution time for each task\\n        int[] res = new int[n];\\n        \\n        for(String log : logs) {\\n            String[] t = log.split(\":\");\\n            int id = Integer.parseInt(t[0]);\\n            int time = Integer.parseInt(t[2]);\\n            \\n            if(t[1].equals(\"start\")) {\\n                if(!stk.isEmpty()) {\\n                    // if stack is not empty calculate time of prev task and update result\\n                    int execTime = time - stk.peek()[1];\\n                    res[stk.peek()[0]] += execTime;\\n                }\\n                // add new task to stack\\n                stk.add(new int[] {id, time});\\n            } else {\\n                // calculate execution time of the task and update in result\\n                // also remove from stack\\n                int execTime = time - stk.peek()[1] + 1;\\n                res[stk.peek()[0]] += execTime;\\n                stk.pop();\\n                \\n                // update start time of task if any in the stack\\n                if(!stk.isEmpty()) stk.peek()[1] = time + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1899263,
                "title": "java-95-fast-stack",
                "content": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] function = new int[n];\\n        Stack<Integer> fstack = new Stack<>();\\n        int time = 0;\\n        for(String log: logs){\\n            String[] fs = log.split(\":\");\\n            int f = Integer.parseInt(fs[0]);\\n            int t = Integer.parseInt(fs[2]);\\n            if(fs[1].equals(\"start\")){\\n                if(t == 0 || fstack.isEmpty()){\\n                    fstack.push(f);\\n                }else{\\n                    int p = fstack.peek();\\n                    function[p] += t - time;\\n                    fstack.push(f);\\n                }\\n                time = t;\\n            }else{\\n                int p = fstack.pop();\\n                function[p] += (t+1) - time;\\n                time = t+1;\\n            }\\n        }\\n        return function;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] function = new int[n];\\n        Stack<Integer> fstack = new Stack<>();\\n        int time = 0;\\n        for(String log: logs){\\n            String[] fs = log.split(\":\");\\n            int f = Integer.parseInt(fs[0]);\\n            int t = Integer.parseInt(fs[2]);\\n            if(fs[1].equals(\"start\")){\\n                if(t == 0 || fstack.isEmpty()){\\n                    fstack.push(f);\\n                }else{\\n                    int p = fstack.peek();\\n                    function[p] += t - time;\\n                    fstack.push(f);\\n                }\\n                time = t;\\n            }else{\\n                int p = fstack.pop();\\n                function[p] += (t+1) - time;\\n                time = t+1;\\n            }\\n        }\\n        return function;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869689,
                "title": "java-solution-stack-explanation-easy-to-understand",
                "content": "1. f1, se1, t1 -> to store the function id, start/end, time for the previous log.\\n2. f2, se2. t2 -> to store the funcion id, start/end, time for the current log.\\n3. if current log is start -> push into stack.\\n4. if current log is end -> pop from the stack.\\n5. during push, calculate the time for the previous log or stack.peek(). \\n\\t2\\n\\t[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n6. during pop, calculate the time for the current log.\\n7. at the end of each iteration,update the current logs.\\n\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List < String > logs) {\\n\\n\\n        // to store the logs, if its start -> push, else pop.\\n        Stack < String > stack = new Stack < String > ();\\n        int f1 = 0, f2 = 0; // store the function id\\n        String se1 = \"\", se2 = \"\"; // stores the start/end values\\n        int t1 = 0, t2 = 0; // stores the time.\\n\\n        int[] arr = new int[n];\\n\\n        // iterate over the logs\\n        for (String str: logs) {\\n            String[] split = str.split(\":\");\\n            if (se1.equals(\"\")) { // if its first entry\\n                f1 = Integer.parseInt(split[0]);\\n                se1 = split[1];\\n                t1 = Integer.parseInt(split[2]);\\n                // System.out.println(f1 + \" -- \" + t1 + \" -- \" + se1);\\n                stack.push(str);\\n            } else { // rest all entries\\n                f2 = Integer.parseInt(split[0]);\\n                se2 = split[1];\\n                t2 = Integer.parseInt(split[2]);\\n                // System.out.println(f2 + \" -- \" + t2 + \" -- \" + se2);\\n\\n                // if current is start, push into stack, and calculate the time for either old stack func id or previous func id.\\n                if (se2.equals(\"start\")) {\\n                    if (se1.equals(\"start\")) {// previous func id \\n                        arr[f1] += t2 - t1;\\n                    } else if (se1.equals(\"end\")) {\\n                        if (t2 != t1 && !stack.isEmpty()) { // time difference betwen start & end, means stack.peek() has run for that much time. old func id\\n                            // eg:\\n                            // 2\\n                            // [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n                            \\n                            // System.out.println(\"stack.peek(): \" + stack.peek());\\n                            String[] temp = stack.peek().split(\":\");\\n                            int fTemp = Integer.parseInt(temp[0]);\\n                            String seTemp = temp[1];\\n                            int tTemp = Integer.parseInt(temp[2]);\\n                            // System.out.println(\"push: fTemp: \" + fTemp + \", seTemp: \" + seTemp  +\", tTemp: \" + tTemp);\\n                            arr[fTemp] += t2 - t1 - 1;\\n                        }\\n                    }\\n                    stack.push(str);\\n                } else if (se2.equals(\"end\")) { // if current is end, then pop from stack and calculate the time of current func id.\\n                    String[] temp = stack.pop().split(\":\");\\n                    int fTemp = Integer.parseInt(temp[0]);\\n                    String seTemp = temp[1];\\n                    int tTemp = Integer.parseInt(temp[2]);\\n                     // System.out.println(\"pop: fTemp: \" + fTemp + \", seTemp: \" + seTemp  +\", tTemp: \" + tTemp);\\n                    if (se1.equals(\"start\")) {\\n                        arr[f2] += t2 - t1 + 1;\\n                    } else if (se1.equals(\"end\")) {\\n                        arr[f2] += t2 - t1;\\n                    }\\n                }\\n                // System.out.println(\"arr[\" + 0 + \"]: \" + arr[0]);\\n                // System.out.println(\"arr[\" + 1 + \"]: \" + arr[1]);\\n\\n\\n                // System.out.println(\"f1: \" + f1 + \", se1: \" + se1  +\", t1: \" + t1 + \", f2: \" + f2 + \", se2: \" + se2  +\", t2: \" + t2);\\n                // swap the logs, so that we have the data for prev & current\\n                f1 = f2;\\n                se1 = se2;\\n                t1 = t2;\\n            }\\n        }\\n        // for (int i = 0; i < n; i++) {\\n        //     System.out.println(\"arr[\" + i + \"] : \" + arr[i]);\\n        // }\\n\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int[] exclusiveTime(int n, List < String > logs) {\\n\\n\\n        // to store the logs, if its start -> push, else pop.\\n        Stack < String > stack = new Stack < String > ();\\n        int f1 = 0, f2 = 0; // store the function id\\n        String se1 = \"\", se2 = \"\"; // stores the start/end values\\n        int t1 = 0, t2 = 0; // stores the time.\\n\\n        int[] arr = new int[n];\\n\\n        // iterate over the logs\\n        for (String str: logs) {\\n            String[] split = str.split(\":\");\\n            if (se1.equals(\"\")) { // if its first entry\\n                f1 = Integer.parseInt(split[0]);\\n                se1 = split[1];\\n                t1 = Integer.parseInt(split[2]);\\n                // System.out.println(f1 + \" -- \" + t1 + \" -- \" + se1);\\n                stack.push(str);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1861902,
                "title": "python-o-no-of-logs-beats-99-with-explanation",
                "content": "**Algorithm:**\\nThe idea is to store the start time of the task that\\'s currently running. This will help in calculating the running time of the task which is ending.\\n\\nIf a function starts:\\n1. Calculate the running time of the prev. function and update the answer array\\n2. Store the start time of the new task, and append it\\'s id to the stack.\\n\\nIf a function ends:\\n1. Update the running time by subtracting the start time stored with the current end time\\n2. Update the start time variable\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        last_start_time = 0\\n        stack = []\\n        hashmap = defaultdict(int)\\n        for log in logs:\\n            _id, _type, _time = log.split(\\':\\')\\n            _id, _time = int(_id), int(_time)\\n            if _type == \"start\":\\n                if len(stack):\\n                    hashmap[stack[-1]] += (_time - last_start_time)\\n                stack.append(_id)\\n                last_start_time = _time\\n            else:\\n                hashmap[stack[-1]] += (_time - last_start_time + 1)\\n                last_start_time = _time + 1\\n                stack.pop()\\n        return [hashmap[key] for key in range(n)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        last_start_time = 0\\n        stack = []\\n        hashmap = defaultdict(int)\\n        for log in logs:\\n            _id, _type, _time = log.split(\\':\\')\\n            _id, _time = int(_id), int(_time)\\n            if _type == \"start\":\\n                if len(stack):\\n                    hashmap[stack[-1]] += (_time - last_start_time)\\n                stack.append(_id)\\n                last_start_time = _time\\n            else:\\n                hashmap[stack[-1]] += (_time - last_start_time + 1)\\n                last_start_time = _time + 1\\n                stack.pop()\\n        return [hashmap[key] for key in range(n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790007,
                "title": "c-99-8ms-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef struct {\\n        int id;\\n        int isStart;\\n        int ts;\\n    } log;\\n    \\n    vector<log> parseLogs(vector<string>& logs) {\\n        vector<log> L;\\n        for(string l:logs) {\\n            int id_end = l.find_first_of(\\':\\');\\n            int id = stoi(l.substr(0, id_end));\\n            int isStart = l[id_end+1] == \\'s\\' ? 1 : 0;\\n            int ts_start = isStart ? 6 + id_end + 1 : 4 + id_end + 1;\\n            int ts = stoi(l.substr(ts_start));\\n            L.push_back({id, isStart, ts});\\n        }\\n        return L;\\n    }\\n    \\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<log> L = parseLogs(logs);\\n        vector<int> result(n,0);\\n        stack<pair<int, int>> unfinished;\\n        int spent_time_by_others = 0;\\n        for(log l:L) {\\n            if(l.isStart){\\n                unfinished.push({l.ts, spent_time_by_others});\\n            } else {\\n                pair<int,int> prev = unfinished.top();\\n                unfinished.pop();\\n                int time_spent = l.ts - prev.first + 1 - (spent_time_by_others - prev.second);\\n                result[l.id] += time_spent;\\n                spent_time_by_others += time_spent;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef struct {\\n        int id;\\n        int isStart;\\n        int ts;\\n    } log;\\n    \\n    vector<log> parseLogs(vector<string>& logs) {\\n        vector<log> L;\\n        for(string l:logs) {\\n            int id_end = l.find_first_of(\\':\\');\\n            int id = stoi(l.substr(0, id_end));\\n            int isStart = l[id_end+1] == \\'s\\' ? 1 : 0;\\n            int ts_start = isStart ? 6 + id_end + 1 : 4 + id_end + 1;\\n            int ts = stoi(l.substr(ts_start));\\n            L.push_back({id, isStart, ts});\\n        }\\n        return L;\\n    }\\n    \\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<log> L = parseLogs(logs);\\n        vector<int> result(n,0);\\n        stack<pair<int, int>> unfinished;\\n        int spent_time_by_others = 0;\\n        for(log l:L) {\\n            if(l.isStart){\\n                unfinished.push({l.ts, spent_time_by_others});\\n            } else {\\n                pair<int,int> prev = unfinished.top();\\n                unfinished.pop();\\n                int time_spent = l.ts - prev.first + 1 - (spent_time_by_others - prev.second);\\n                result[l.id] += time_spent;\\n                spent_time_by_others += time_spent;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777474,
                "title": "java-stack-solution-easy-explanation-comments-included",
                "content": "```\\nclass Solution {\\n    static class Pair{\\n            int id;\\n            int st;   //starting time\\n            int wt;   //waiting time\\n            \\n            Pair(int id,int st,int wt){\\n                this.id = id;\\n                this.st = st;\\n                this.wt = wt;\\n            }\\n            \\n        }\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] arr = new int[n];\\n        Stack<Pair> st = new Stack<>();\\n        for(String s:logs){\\n           String[] temp = s.split(\":\");\\n            int id = Integer.parseInt(temp[0]);\\n            String action = temp[1];\\n            int t = Integer.parseInt(temp[2]);\\n            \\n            if(action.equals(\"start\")){\\n                st.push(new Pair(id,t,0));\\n            }\\n            else{\\n                int tts = t-st.peek().st+1; //total time spent\\n                int exectime = tts-st.peek().wt;  //basically execution time wo time hoga jab wo stack ke peek par raha ho\\n                arr[id]+=exectime;\\n                st.pop();\\n                \\n                if(st.size()>0){\\n                    st.peek().wt+=tts;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    static class Pair{\\n            int id;\\n            int st;   //starting time\\n            int wt;   //waiting time\\n            \\n            Pair(int id,int st,int wt){\\n                this.id = id;\\n                this.st = st;\\n                this.wt = wt;\\n            }\\n            \\n        }\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] arr = new int[n];\\n        Stack<Pair> st = new Stack<>();\\n        for(String s:logs){\\n           String[] temp = s.split(\":\");\\n            int id = Integer.parseInt(temp[0]);\\n            String action = temp[1];\\n            int t = Integer.parseInt(temp[2]);\\n            \\n            if(action.equals(\"start\")){\\n                st.push(new Pair(id,t,0));\\n            }\\n            else{\\n                int tts = t-st.peek().st+1; //total time spent\\n                int exectime = tts-st.peek().wt;  //basically execution time wo time hoga jab wo stack ke peek par raha ho\\n                arr[id]+=exectime;\\n                st.pop();\\n                \\n                if(st.size()>0){\\n                    st.peek().wt+=tts;\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746224,
                "title": "simple-java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public class ETHelper{\\n        int id;\\n        int sTime;\\n        int cet;\\n        \\n        ETHelper(int id,int sTime,int cet){\\n            this.id=id;\\n            this.sTime=sTime;\\n            this.cet=cet;\\n        }\\n    }\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<ETHelper> st=new Stack<>();\\n        int[] res=new int[n];\\n        for(String s:logs){\\n            String[] token=s.split(\":\");\\n            int id=Integer.parseInt(token[0]);\\n            String status=token[1];\\n            int timeStamp=Integer.parseInt(token[2]);\\n            \\n            if(status.equals(\"start\")){\\n                st.push(new ETHelper(id,timeStamp,0));\\n            }else{\\n                int fn_diff=timeStamp-st.peek().sTime+1;\\n                int et=fn_diff-st.peek().cet;\\n                \\n                res[id]+=et;\\n                st.pop();\\n                if(st.size()>0){\\n                    st.peek().cet+=fn_diff;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public class ETHelper{\\n        int id;\\n        int sTime;\\n        int cet;\\n        \\n        ETHelper(int id,int sTime,int cet){\\n            this.id=id;\\n            this.sTime=sTime;\\n            this.cet=cet;\\n        }\\n    }\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<ETHelper> st=new Stack<>();\\n        int[] res=new int[n];\\n        for(String s:logs){\\n            String[] token=s.split(\":\");\\n            int id=Integer.parseInt(token[0]);\\n            String status=token[1];\\n            int timeStamp=Integer.parseInt(token[2]);\\n            \\n            if(status.equals(\"start\")){\\n                st.push(new ETHelper(id,timeStamp,0));\\n            }else{\\n                int fn_diff=timeStamp-st.peek().sTime+1;\\n                int et=fn_diff-st.peek().cet;\\n                \\n                res[id]+=et;\\n                st.pop();\\n                if(st.size()>0){\\n                    st.peek().cet+=fn_diff;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715842,
                "title": "c",
                "content": "(```) class Solution {\\n    \\n    struct Data\\n    {\\n        int id;\\n        \\n        string status;\\n        \\n        int timestamp;\\n        \\n    };\\n  \\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        \\n        vector<int> res(n,0);\\n        \\n        stack<Data> st;\\n        \\n        for(int i=0; i < logs.size(); i++)\\n        {\\n            stringstream ob(logs[i]);\\n            \\n            string t1, t2, t3;\\n            \\n            getline(ob,t1,\\':\\');\\n            getline(ob,t2,\\':\\');\\n            getline(ob,t3,\\':\\');\\n            \\n            Data item = {stoi(t1), t2, stoi(t3)};\\n            \\n            if(item.status == \"start\")\\n            {\\n                st.push(item);\\n            }\\n            else\\n            {\\n                int time = item.timestamp - st.top().timestamp+1;\\n                \\n                res[item.id] += time;\\n                \\n                st.pop( );\\n                \\n                if(!st.empty( ))\\n                {\\n                    res[st.top().id] -= time;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return res;\\n        \\n       \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    struct Data\\n    {\\n        int id;\\n        \\n        string status;\\n        \\n        int timestamp;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1714034,
                "title": "java-with-stack",
                "content": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<FunctionCall> callStack = new Stack<>();\\n\\n        int[] exTime = new int[n];\\n        Map<Integer, Integer> functionDuration = new HashMap<>();\\n        for (String log : logs) {\\n            FunctionProps funProps = parseLog(log);\\n            if (funProps.type == FunctionType.Start) {\\n                if (callStack.isEmpty()) {\\n                    callStack.push(new FunctionCall(funProps.id, funProps.time, 0));\\n                } else {\\n                    FunctionCall previousCall = callStack.peek();\\n                    previousCall.duration += funProps.time - previousCall.startTime;\\n                    previousCall.startTime = funProps.time;\\n                    callStack.push(new FunctionCall(funProps.id, funProps.time, 0));\\n                }\\n            } else {\\n                FunctionCall previousCall = callStack.pop();\\n                previousCall.duration += funProps.time + 1 - previousCall.startTime;\\n                exTime[previousCall.id] += previousCall.duration;\\n                if (!callStack.isEmpty()) {\\n                    callStack.peek().startTime = funProps.time + 1;\\n                }\\n            }\\n        }\\n        return exTime;\\n    }\\n    \\n    private static FunctionProps parseLog(String log) {\\n        String[] split = log.split(\":\");\\n        FunctionProps props = new FunctionProps(Integer.parseInt(split[0]), split[1], Integer.parseInt(split[2]));\\n        return props;\\n    }\\n}\\n\\nclass FunctionCall {\\n    int id;\\n    int startTime;\\n    int duration;\\n\\n    public FunctionCall(int id, int startTime, int duration) {\\n        this.id = id;\\n        this.startTime = startTime;\\n        this.duration = duration;\\n    }\\n}\\n\\nenum FunctionType {\\n    Start, End;\\n}\\n\\nclass FunctionProps {\\n    int id;\\n    FunctionType type;\\n    int time;\\n\\n    public FunctionProps(int id, String typeStr, int time) {\\n        this.id = id;\\n        this.type = typeStr.equalsIgnoreCase(\"start\") ? FunctionType.Start : FunctionType.End;\\n        this.time = time;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<FunctionCall> callStack = new Stack<>();\\n\\n        int[] exTime = new int[n];\\n        Map<Integer, Integer> functionDuration = new HashMap<>();\\n        for (String log : logs) {\\n            FunctionProps funProps = parseLog(log);\\n            if (funProps.type == FunctionType.Start) {\\n                if (callStack.isEmpty()) {\\n                    callStack.push(new FunctionCall(funProps.id, funProps.time, 0));\\n                } else {\\n                    FunctionCall previousCall = callStack.peek();\\n                    previousCall.duration += funProps.time - previousCall.startTime;\\n                    previousCall.startTime = funProps.time;\\n                    callStack.push(new FunctionCall(funProps.id, funProps.time, 0));\\n                }\\n            } else {\\n                FunctionCall previousCall = callStack.pop();\\n                previousCall.duration += funProps.time + 1 - previousCall.startTime;\\n                exTime[previousCall.id] += previousCall.duration;\\n                if (!callStack.isEmpty()) {\\n                    callStack.peek().startTime = funProps.time + 1;\\n                }\\n            }\\n        }\\n        return exTime;\\n    }\\n    \\n    private static FunctionProps parseLog(String log) {\\n        String[] split = log.split(\":\");\\n        FunctionProps props = new FunctionProps(Integer.parseInt(split[0]), split[1], Integer.parseInt(split[2]));\\n        return props;\\n    }\\n}\\n\\nclass FunctionCall {\\n    int id;\\n    int startTime;\\n    int duration;\\n\\n    public FunctionCall(int id, int startTime, int duration) {\\n        this.id = id;\\n        this.startTime = startTime;\\n        this.duration = duration;\\n    }\\n}\\n\\nenum FunctionType {\\n    Start, End;\\n}\\n\\nclass FunctionProps {\\n    int id;\\n    FunctionType type;\\n    int time;\\n\\n    public FunctionProps(int id, String typeStr, int time) {\\n        this.id = id;\\n        this.type = typeStr.equalsIgnoreCase(\"start\") ? FunctionType.Start : FunctionType.End;\\n        this.time = time;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661379,
                "title": "parenthesis-problem",
                "content": "```\\n\\t\\t# Like a parenthesis problem \"(()()) and definitely a valid one\\n        # Encounter a new start, like \"(\" in parenthesis problem, res[stack[-1]\\'s ID] += duration\\n        # encounter an end like \")\" in parenthesis problem, pop an element then res[ID] += duaration, Moreover, update the stack[-1]\\'s end time to the lastest end time \\n        # Time O(n), Space O(n)\\n        \\n        res = [0]*n\\n        stack = []\\n        for log in logs:\\n            cache = log.split(\":\")\\n            if stack and cache[1] == \"start\":\\n                res[int(stack[-1][0])] += int(cache[2])-int(stack[-1][2])\\n                stack.append(cache)\\n            elif cache[1] == \"end\":\\n                prev_ID, _ ,starttime = stack.pop()\\n                res[int(cache[0])] += int(cache[2]) - int(starttime) + 1\\n                if stack:\\n                    stack[-1][2] = str(int(cache[2])+1)\\n            elif not stack:\\n                stack.append(cache)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\t# Like a parenthesis problem \"(()()) and definitely a valid one\\n        # Encounter a new start, like \"(\" in parenthesis problem, res[stack[-1]\\'s ID] += duration\\n        # encounter an end like \")\" in parenthesis problem, pop an element then res[ID] += duaration, Moreover, update the stack[-1]\\'s end time to the lastest end time \\n        # Time O(n), Space O(n)\\n        \\n        res = [0]*n\\n        stack = []\\n        for log in logs:\\n            cache = log.split(\":\")\\n            if stack and cache[1] == \"start\":\\n                res[int(stack[-1][0])] += int(cache[2])-int(stack[-1][2])\\n                stack.append(cache)\\n            elif cache[1] == \"end\":\\n                prev_ID, _ ,starttime = stack.pop()\\n                res[int(cache[0])] += int(cache[2]) - int(starttime) + 1\\n                if stack:\\n                    stack[-1][2] = str(int(cache[2])+1)\\n            elif not stack:\\n                stack.append(cache)\\n                \\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1619695,
                "title": "java-o-n-with-stack-easy-to-understand",
                "content": "The problem already hints that you can use a stack for solving it, where you can keep track of the current function ID and whenever there\\'s a `start`, we push the current function ID in the stack, and whenever there\\'s an `end`, we pop the top of stack. The tricky part is getting the exclusive time while you\\'re doing the stack operations so you can keep the `O(N)` time complexity. You can get this done by counting how long the current function has been as current. This changes whenever there is a `start` or `end`.\\n\\nIf you look at the example provided:\\n<img src=\"https://assets.leetcode.com/uploads/2019/04/05/diag1b.png\" width=\"50%\" />\\n\\nYou\\'ll notice that whenever there is a `start`, the count starts at the beginning of the timestamp, but when there is an `end` the count stops at the end of the timestamp. This is an important implementation detail. So the solution goes like this:\\n\\n* Track the current function ID as `currentId`. Initially with value -1, which means there is no call happening.\\n* Track the last timestamp read as `lastTimestamp`. Initially with value 0.\\n* Have an int array for holding the exclusive times for each function.\\n* For each log string:\\n\\t* If is a start:\\n\\t\\t* If we have a current call (`currentId != -1`):\\n\\t\\t\\t* Add to its exclusive time the amount of time since the last timestamp (`startEventTimestamp - lastTimestamp`).\\n\\t\\t\\t* Push the current id into the stack.\\n\\t\\t* Make the log id the current id.\\n\\t\\t* Make the last timestamp the log\\'s timestamp.\\n\\t* If is an end:\\n\\t\\t* Add to the its exclusive time the amount of time since the last timestamp **plus 1**, as it needs to include that timestamp.\\n\\t\\t* Make the last timestamp the log\\'s timestamp **plus 1**.\\n\\t\\t* Pop from the stack if not empty and make the output the current id.\\n\\nHere the same in code (*Note: I used a private class to hold the log data to clean up a little bit*):\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        Stack<Integer> callStack = new Stack<>();\\n        int lastTimestamp = 0;\\n        int currentId = -1;\\n        for (String log : logs) {\\n            LogDetails details = new LogDetails(log);\\n            if (details.isStart()) {\\n                if (currentId != -1) {\\n                    result[currentId] += details.timestamp - lastTimestamp;\\n                    callStack.push(currentId);\\n                }\\n                currentId = details.id;\\n                lastTimestamp = details.timestamp;\\n            } else {\\n                result[currentId] += details.timestamp + 1 - lastTimestamp;\\n                lastTimestamp = details.timestamp + 1;\\n                currentId = callStack.isEmpty() ? -1 : callStack.pop();\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private class LogDetails {\\n        int id;\\n        String action;\\n        int timestamp;\\n        \\n        private LogDetails(String log) {            \\n            String[] split = log.split(\":\");\\n            this.id = Integer.parseInt(split[0]);\\n            this.action = split[1];\\n            this.timestamp = Integer.parseInt(split[2]);\\n        }\\n        \\n        private boolean isStart() {\\n            return \"start\".equals(this.action);\\n        }\\n    }\\n}\\n```\\n\\n### Complexity\\n* Time complexity: `O(n)` as we iterate over the list of logs only once. Push and pop operations in stack are both `O(1)`, so they don\\'t add to the complexity.\\n* Space complexity: `O(n)` as we are using a stack to store the function ids.",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] result = new int[n];\\n        Stack<Integer> callStack = new Stack<>();\\n        int lastTimestamp = 0;\\n        int currentId = -1;\\n        for (String log : logs) {\\n            LogDetails details = new LogDetails(log);\\n            if (details.isStart()) {\\n                if (currentId != -1) {\\n                    result[currentId] += details.timestamp - lastTimestamp;\\n                    callStack.push(currentId);\\n                }\\n                currentId = details.id;\\n                lastTimestamp = details.timestamp;\\n            } else {\\n                result[currentId] += details.timestamp + 1 - lastTimestamp;\\n                lastTimestamp = details.timestamp + 1;\\n                currentId = callStack.isEmpty() ? -1 : callStack.pop();\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private class LogDetails {\\n        int id;\\n        String action;\\n        int timestamp;\\n        \\n        private LogDetails(String log) {            \\n            String[] split = log.split(\":\");\\n            this.id = Integer.parseInt(split[0]);\\n            this.action = split[1];\\n            this.timestamp = Integer.parseInt(split[2]);\\n        }\\n        \\n        private boolean isStart() {\\n            return \"start\".equals(this.action);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615807,
                "title": "java-o-n-using-stack",
                "content": "```\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Pair<Integer, Pair<Integer, Integer>>> processStack = new Stack<>();\\n        int[] processTime = new int[n];\\n        for(String log : logs) {\\n            int[] tokens = getLogTokens(log);\\n            int currTime = tokens[2];\\n            int pId = tokens[0];\\n            if (tokens[1] == 0) {                \\n                processStack.push(new Pair<>(pId, new Pair<>(currTime, 0)));\\n            } else {\\n                Pair<Integer, Pair<Integer, Integer>> pair = processStack.pop();\\n                int timeSpent = (currTime - pair.getValue().getKey() + 1 - pair.getValue().getValue());\\n                processTime[pair.getKey()] = processTime[pair.getKey()] + timeSpent;\\n                if (!processStack.isEmpty()) {\\n                    Pair<Integer, Pair<Integer, Integer>> topPair = processStack.pop();\\n                    topPair = new Pair<>(topPair.getKey(), new Pair<>(topPair.getValue().getKey(), topPair.getValue().getValue() + currTime - pair.getValue().getKey() + 1));      \\n                    processStack.push(topPair);\\n                }\\n            }\\n        }\\n        return processTime;\\n    }\\n    \\n    private int[] getLogTokens(String str) {\\n        String[] tokens = str.split(\":\");\\n        int[] tokensArray = new int[3];\\n        tokensArray[0] = Integer.parseInt(tokens[0]);\\n        tokensArray[1] = tokens[1].equals(\"start\")? 0 : 1;\\n        tokensArray[2] = Integer.parseInt(tokens[2]);\\n        return tokensArray;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<Pair<Integer, Pair<Integer, Integer>>> processStack = new Stack<>();\\n        int[] processTime = new int[n];\\n        for(String log : logs) {\\n            int[] tokens = getLogTokens(log);\\n            int currTime = tokens[2];\\n            int pId = tokens[0];\\n            if (tokens[1] == 0) {                \\n                processStack.push(new Pair<>(pId, new Pair<>(currTime, 0)));\\n            } else {\\n                Pair<Integer, Pair<Integer, Integer>> pair = processStack.pop();\\n                int timeSpent = (currTime - pair.getValue().getKey() + 1 - pair.getValue().getValue());\\n                processTime[pair.getKey()] = processTime[pair.getKey()] + timeSpent;\\n                if (!processStack.isEmpty()) {\\n                    Pair<Integer, Pair<Integer, Integer>> topPair = processStack.pop();\\n                    topPair = new Pair<>(topPair.getKey(), new Pair<>(topPair.getValue().getKey(), topPair.getValue().getValue() + currTime - pair.getValue().getKey() + 1));      \\n                    processStack.push(topPair);\\n                }\\n            }\\n        }\\n        return processTime;\\n    }\\n    \\n    private int[] getLogTokens(String str) {\\n        String[] tokens = str.split(\":\");\\n        int[] tokensArray = new int[3];\\n        tokensArray[0] = Integer.parseInt(tokens[0]);\\n        tokensArray[1] = tokens[1].equals(\"start\")? 0 : 1;\\n        tokensArray[2] = Integer.parseInt(tokens[2]);\\n        return tokensArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580382,
                "title": "python-stack-commented-o-n-time-beats-80-o-n-space",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        res = [0]*n\\n        startStackIdx = []\\n        prevtimeStamp = 0 # updated every log, since the different between successive log is added as executiion times\\n        for log in logs:\\n            log = log.split(\\':\\')\\n            idx,curtimeStamp = int(log[0]),int(log[2])\\n            \\n            if log[1]==\\'start\\':\\n                if startStackIdx: \\n                    #  Time between last process started the new one started\\n                    # Added to last unended process\\n                    res[startStackIdx[-1]] += (curtimeStamp-prevtimeStamp) \\n                startStackIdx.append(idx)\\n                prevtimeStamp = curtimeStamp\\n            else:\\n                #  Time between after last process ended and this process ended\\n                # Added to current ending process, which was last open process \\n                # before the last ended process.\\n                res[startStackIdx.pop()] += (curtimeStamp-prevtimeStamp+1)\\n                prevtimeStamp = curtimeStamp+1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        res = [0]*n\\n        startStackIdx = []\\n        prevtimeStamp = 0 # updated every log, since the different between successive log is added as executiion times\\n        for log in logs:\\n            log = log.split(\\':\\')\\n            idx,curtimeStamp = int(log[0]),int(log[2])\\n            \\n            if log[1]==\\'start\\':\\n                if startStackIdx: \\n                    #  Time between last process started the new one started\\n                    # Added to last unended process\\n                    res[startStackIdx[-1]] += (curtimeStamp-prevtimeStamp) \\n                startStackIdx.append(idx)\\n                prevtimeStamp = curtimeStamp\\n            else:\\n                #  Time between after last process ended and this process ended\\n                # Added to current ending process, which was last open process \\n                # before the last ended process.\\n                res[startStackIdx.pop()] += (curtimeStamp-prevtimeStamp+1)\\n                prevtimeStamp = curtimeStamp+1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532259,
                "title": "simple-java-solution-with-explaination",
                "content": "Knowledge Assumptions:\\n1. We always have relevant end log for each start log for a process.\\n2. We will always have the same function with start log on top of stack, when we got end log with the same function.\\n\\nWe use stack to know the previous function thats getting executed. We increment the execution time for a process in following ways:\\n1. when we receive end log update the execution time of function and pop the stack. And also update the start time of previous function(top of the stack) to the current time+1\\n2. When we receive the start log, update the execution time of last function(top of stack) and push this log into stack\\n\\n\\n\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int res[] = new int[n];\\n\\t\\t//Here key represents function and value represents corresponding start time.\\n        Stack<Pair<Integer, Integer>> stk = new Stack();\\n        for(String str: logs){\\n            String[] arr = str.split(\":\");\\n            int function = Integer.parseInt(arr[0]);\\n            int time = Integer.parseInt(arr[2]);\\n            if(arr[1].equals(\"start\")){\\n                if(!stk.isEmpty()){\\n                    Pair<Integer, Integer> p = stk.peek();\\n                    res[p.getKey()]+=(time-p.getValue());\\n                }\\n                stk.push(new Pair<>(function, time));\\n            }else{\\n                Pair<Integer, Integer> p = stk.peek();\\n                res[function]+=(time-p.getValue()+1);\\n                stk.pop();\\n                if(!stk.isEmpty()){\\n                    p=stk.pop();\\n                    stk.push(new Pair<>(p.getKey(), time+1));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int res[] = new int[n];\\n\\t\\t//Here key represents function and value represents corresponding start time.\\n        Stack<Pair<Integer, Integer>> stk = new Stack();\\n        for(String str: logs){\\n            String[] arr = str.split(\":\");\\n            int function = Integer.parseInt(arr[0]);\\n            int time = Integer.parseInt(arr[2]);\\n            if(arr[1].equals(\"start\")){\\n                if(!stk.isEmpty()){\\n                    Pair<Integer, Integer> p = stk.peek();\\n                    res[p.getKey()]+=(time-p.getValue());\\n                }\\n                stk.push(new Pair<>(function, time));\\n            }else{\\n                Pair<Integer, Integer> p = stk.peek();\\n                res[function]+=(time-p.getValue()+1);\\n                stk.pop();\\n                if(!stk.isEmpty()){\\n                    p=stk.pop();\\n                    stk.push(new Pair<>(p.getKey(), time+1));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522819,
                "title": "python-code-with-some-hints",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        res = [0]*n\\n        \\n        for log in logs:\\n            logsp = log.split(\":\")\\n            fid, start, time = int(logsp[0]), logsp[1] == \\'start\\', int(logsp[2])\\n            \\n            if start:\\n                stack.append([fid,time])\\n            else:\\n                pfid,ptime = stack.pop()\\n                timeSpent = (time - ptime + 1)\\n                \\n                res[fid] += timeSpent\\n                \\n                if stack:\\n                    res[stack[-1][0]] -= timeSpent # this the KEY part of the code!!\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        res = [0]*n\\n        \\n        for log in logs:\\n            logsp = log.split(\":\")\\n            fid, start, time = int(logsp[0]), logsp[1] == \\'start\\', int(logsp[2])\\n            \\n            if start:\\n                stack.append([fid,time])\\n            else:\\n                pfid,ptime = stack.pop()\\n                timeSpent = (time - ptime + 1)\\n                \\n                res[fid] += timeSpent\\n                \\n                if stack:\\n                    res[stack[-1][0]] -= timeSpent # this the KEY part of the code!!\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481527,
                "title": "java-o-n-time-stack-solution",
                "content": "```\\n// Stack Solution\\n// runningTime = curLog.time - pairLog.time + 1;\\n// current job time + running time\\n// previous job time - running time\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] res = new int[n];\\n        Deque<Log> stack = new ArrayDeque<>();\\n        for (String text : logs) {\\n            Log curLog = new Log(text);\\n            if (curLog.isStart) {\\n                stack.push(curLog);\\n            } else {\\n                Log pairLog = stack.pop();  // The corresponding start log.\\n                int runningTime = curLog.time - pairLog.time + 1;\\n                res[pairLog.id] += runningTime;  // current job time + running time\\n                if (!stack.isEmpty()) {\\n                    res[stack.peek().id] -= runningTime;  // previous job time - running time\\n\\t\\t\\t\\t}\\n            }\\n        }\\n        return res;\\n    }\\n    class Log {\\n        int id;\\n        boolean isStart;\\n        int time;\\n        Log(String text) {\\n            String[] strs = text.split(\":\");\\n            id = Integer.valueOf(strs[0]);\\n            isStart = \"start\".equals(strs[1]);\\n            time = Integer.valueOf(strs[2]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Stack Solution\\n// runningTime = curLog.time - pairLog.time + 1;\\n// current job time + running time\\n// previous job time - running time\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] res = new int[n];\\n        Deque<Log> stack = new ArrayDeque<>();\\n        for (String text : logs) {\\n            Log curLog = new Log(text);\\n            if (curLog.isStart) {\\n                stack.push(curLog);\\n            } else {\\n                Log pairLog = stack.pop();  // The corresponding start log.\\n                int runningTime = curLog.time - pairLog.time + 1;\\n                res[pairLog.id] += runningTime;  // current job time + running time\\n                if (!stack.isEmpty()) {\\n                    res[stack.peek().id] -= runningTime;  // previous job time - running time\\n\\t\\t\\t\\t}\\n            }\\n        }\\n        return res;\\n    }\\n    class Log {\\n        int id;\\n        boolean isStart;\\n        int time;\\n        Log(String text) {\\n            String[] strs = text.split(\":\");\\n            id = Integer.valueOf(strs[0]);\\n            isStart = \"start\".equals(strs[1]);\\n            time = Integer.valueOf(strs[2]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464820,
                "title": "ultra-fast-python-solution-using-stack",
                "content": "~~~\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        base_time = 0\\n        stack = []\\n        ans = [0] * n\\n        stack = []\\n        \\n        for log in logs:\\n            fid, cmd, time = log.split(\":\")\\n            time = int(time)\\n            fid = int(fid)\\n            \\n            if cmd == \"start\":\\n                if stack:\\n                    ans[stack[-1]] += time - base_time\\n                stack.append(fid)\\n                base_time = time\\n            else:\\n                ans[stack.pop()] += time - base_time + 1\\n                base_time = time + 1\\n                \\n        return ans\\n~~~",
                "solutionTags": [],
                "code": "~~~\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        base_time = 0\\n        stack = []\\n        ans = [0] * n\\n        stack = []\\n        \\n        for log in logs:\\n            fid, cmd, time = log.split(\":\")\\n            time = int(time)\\n            fid = int(fid)\\n            \\n            if cmd == \"start\":\\n                if stack:\\n                    ans[stack[-1]] += time - base_time\\n                stack.append(fid)\\n                base_time = time\\n            else:\\n                ans[stack.pop()] += time - base_time + 1\\n                base_time = time + 1\\n                \\n        return ans\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 1462076,
                "title": "detailed-description-log-class-to-easy-handle-java",
                "content": "NOTE: The function that starts at the end (during the start spree), ends first (think of it as a stack)\\n SO read a log and if it has \\'start\\' in it, then simply put into stack\\n When a log with \\'end\\' comes, we know that the function that is ending has the \\'start\\' log line on TOP os stack, so get it and compute time\\n One thing to notice is once a function goes into stack, that function will have a \\'wait time\\' until it resides in the stack and that is not computed in the time to run of that function\\n\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] res = new int[n];\\n        Stack<Log> stack = new Stack<>(); // to hold the func start\\n        \\n        for(String logLine : logs) {\\n            Log log = new Log(logLine); // create a log\\n            \\n            if(log.isStart) {\\n                stack.push(log);\\n            } else {\\n                Log logOnTop = stack.pop(); // get the top log (present log\\'s start)\\n                res[log.id] +=  log.time - logOnTop.time + 1 - logOnTop.timeToWait;\\n                if(!stack.isEmpty()) {\\n                    stack.peek().timeToWait += log.time - logOnTop.time + 1; // update top log in stack\\'s time to wait\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass Log {\\n    int id;\\n    int time;\\n    boolean isStart;\\n    int timeToWait;\\n    \\n    public Log(String logL) {\\n        String[] logLine = logL.split(\":\");\\n        \\n        this.id = Integer.parseInt(logLine[0]);\\n        this.time = Integer.parseInt(logLine[2]);\\n        this.isStart = logLine[1].equals(\"start\");\\n        this.timeToWait = 0;\\n    }\\n }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] res = new int[n];\\n        Stack<Log> stack = new Stack<>(); // to hold the func start\\n        \\n        for(String logLine : logs) {\\n            Log log = new Log(logLine); // create a log\\n            \\n            if(log.isStart) {\\n                stack.push(log);\\n            } else {\\n                Log logOnTop = stack.pop(); // get the top log (present log\\'s start)\\n                res[log.id] +=  log.time - logOnTop.time + 1 - logOnTop.timeToWait;\\n                if(!stack.isEmpty()) {\\n                    stack.peek().timeToWait += log.time - logOnTop.time + 1; // update top log in stack\\'s time to wait\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass Log {\\n    int id;\\n    int time;\\n    boolean isStart;\\n    int timeToWait;\\n    \\n    public Log(String logL) {\\n        String[] logLine = logL.split(\":\");\\n        \\n        this.id = Integer.parseInt(logLine[0]);\\n        this.time = Integer.parseInt(logLine[2]);\\n        this.isStart = logLine[1].equals(\"start\");\\n        this.timeToWait = 0;\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420694,
                "title": "java-clean-code-with-stack",
                "content": "Java code with Stack\\n\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] ans = new int[n];\\n        Stack<Function> order = new Stack<>();\\n        \\n        for(String log:logs){\\n            \\n            String[] logInfo = log.split(Function.SEPARATOR);\\n            \\n            if(logInfo[1].equals(Function.START)){\\n                order.push(new Function(logInfo));\\n            } else{\\n                Function ending = order.pop();\\n                \\n                int endingRunTime = Integer.parseInt(logInfo[2]) - ending.startTime + 1 - ending.idleTime;\\n                ans[ending.id] += endingRunTime;\\n                \\n                if(!order.isEmpty()){\\n                    Function topInOrder = order.peek();\\n                    topInOrder.idleTime += (endingRunTime+ending.idleTime);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\nclass Function{\\n    final static String START = \"start\";\\n    final static String SEPARATOR = \":\";\\n    int startTime;\\n    int id;\\n    int idleTime;\\n    public Function(String[] logInfo){\\n        this.startTime = Integer.parseInt(logInfo[2]);\\n        this.id = Integer.parseInt(logInfo[0]);\\n    }\\n}\\n```\\n\\nKeep tracking the idletime of the top function in stack and it equals to the last end function\\'s idletime + runtime",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] ans = new int[n];\\n        Stack<Function> order = new Stack<>();\\n        \\n        for(String log:logs){\\n            \\n            String[] logInfo = log.split(Function.SEPARATOR);\\n            \\n            if(logInfo[1].equals(Function.START)){\\n                order.push(new Function(logInfo));\\n            } else{\\n                Function ending = order.pop();\\n                \\n                int endingRunTime = Integer.parseInt(logInfo[2]) - ending.startTime + 1 - ending.idleTime;\\n                ans[ending.id] += endingRunTime;\\n                \\n                if(!order.isEmpty()){\\n                    Function topInOrder = order.peek();\\n                    topInOrder.idleTime += (endingRunTime+ending.idleTime);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\nclass Function{\\n    final static String START = \"start\";\\n    final static String SEPARATOR = \":\";\\n    int startTime;\\n    int id;\\n    int idleTime;\\n    public Function(String[] logInfo){\\n        this.startTime = Integer.parseInt(logInfo[2]);\\n        this.id = Integer.parseInt(logInfo[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419287,
                "title": "java-self-explanatory-code-o-n",
                "content": "```\\nclass Solution {\\n    \\n    static class FunctionCallEvent {\\n        int functionId;\\n        int startTime;\\n        \\n        FunctionCallEvent(int fid, int st) {\\n            functionId=fid;\\n            startTime=st;\\n        }\\n        \\n    }\\n    \\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int[] totalTime = new int[n];\\n        Deque<FunctionCallEvent> functionCallStack = new LinkedList<>();\\n        \\n        for(String log: logs) {\\n            String[] logInfo = log.split(\":\");\\n            \\n            int fid = Integer.parseInt(logInfo[0]);\\n            String eventType = logInfo[1];\\n            int timestamp = Integer.parseInt(logInfo[2]);\\n            \\n            switch(eventType) {\\n                case \"start\": {\\n                    if(!functionCallStack.isEmpty()) {\\n                        \\n                        /*\\n                        Function which is currently at the top of stack will be paused and a new function is about to be executed. So total time taken by that function needs to be saved.\\n                        */\\n                        \\n                        FunctionCallEvent e = functionCallStack.peek();\\n                        int timeTaken = timestamp - e.startTime;\\n                        totalTime[e.functionId] += timeTaken;\\n                        \\n                        // e.startTime = -1; //optional; will be reset\\n                    }\\n                    functionCallStack.push(new FunctionCallEvent(fid,timestamp));\\n                    break;\\n                }\\n                case \"end\": {\\n                    /*\\n                    Compute how much time the stack top function took to execute\\n                    */\\n                    FunctionCallEvent e = functionCallStack.pop();\\n                    int timeTaken = timestamp - e.startTime + 1;\\n                    totalTime[e.functionId] += timeTaken;\\n                    \\n                    if(!functionCallStack.isEmpty()) {\\n                        /*\\n                        This function will resume executing. So reset its startTime\\n                        */\\n                        functionCallStack.peek().startTime = timestamp+1;\\n                    }\\n                    break;\\n                }\\n                default: {}\\n            }\\n        }\\n        \\n        return totalTime;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static class FunctionCallEvent {\\n        int functionId;\\n        int startTime;\\n        \\n        FunctionCallEvent(int fid, int st) {\\n            functionId=fid;\\n            startTime=st;\\n        }\\n        \\n    }\\n    \\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        int[] totalTime = new int[n];\\n        Deque<FunctionCallEvent> functionCallStack = new LinkedList<>();\\n        \\n        for(String log: logs) {\\n            String[] logInfo = log.split(\":\");\\n            \\n            int fid = Integer.parseInt(logInfo[0]);\\n            String eventType = logInfo[1];\\n            int timestamp = Integer.parseInt(logInfo[2]);\\n            \\n            switch(eventType) {\\n                case \"start\": {\\n                    if(!functionCallStack.isEmpty()) {\\n                        \\n                        /*\\n                        Function which is currently at the top of stack will be paused and a new function is about to be executed. So total time taken by that function needs to be saved.\\n                        */\\n                        \\n                        FunctionCallEvent e = functionCallStack.peek();\\n                        int timeTaken = timestamp - e.startTime;\\n                        totalTime[e.functionId] += timeTaken;\\n                        \\n                        // e.startTime = -1; //optional; will be reset\\n                    }\\n                    functionCallStack.push(new FunctionCallEvent(fid,timestamp));\\n                    break;\\n                }\\n                case \"end\": {\\n                    /*\\n                    Compute how much time the stack top function took to execute\\n                    */\\n                    FunctionCallEvent e = functionCallStack.pop();\\n                    int timeTaken = timestamp - e.startTime + 1;\\n                    totalTime[e.functionId] += timeTaken;\\n                    \\n                    if(!functionCallStack.isEmpty()) {\\n                        /*\\n                        This function will resume executing. So reset its startTime\\n                        */\\n                        functionCallStack.peek().startTime = timestamp+1;\\n                    }\\n                    break;\\n                }\\n                default: {}\\n            }\\n        }\\n        \\n        return totalTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396371,
                "title": "c-modular-implementation-using-stacks",
                "content": "```\\n// Time complexity - O(n)\\n// Space complexity - O(n)\\nclass Solution {\\n    struct Event {\\n        bool isStart;\\n        int timestamp;\\n        int id;\\n        \\n        Event(bool isStart, int timestamp, int id): isStart(isStart), timestamp(timestamp), id(id) {}\\n    };\\n    \\n    string parseNext(string &log, int &ind) {\\n        if(log[ind] == \\':\\') {\\n            ind++;\\n        }\\n        \\n        string result = \"\";\\n        while(ind < log.size() && log[ind] != \\':\\') {\\n            result += log[ind++];\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<Event> parseEvents(vector<string>& logs) {\\n        vector<Event> events;\\n        for(auto &log: logs) {\\n            int ind = 0;\\n            string id = parseNext(log, ind);\\n            string type = parseNext(log, ind);\\n            string timestamp = parseNext(log, ind);\\n            \\n            Event event = {\\n                type == \"start\",\\n                stoi(timestamp) + (type == \"start\" ? 0 : 1),\\n                stoi(id)\\n            };\\n            \\n            events.push_back(event);\\n        }\\n        \\n        return events;\\n    }\\n    \\n    vector<int> getExclusiveTimes(int n, vector<Event> &events) {\\n        stack<Event> eventStack;\\n        int lastTimestamp = 0;\\n        \\n        vector<int> exclusiveTimes(n, 0);\\n        \\n        for(auto &event: events) {\\n            if(event.isStart) {\\n                if(!eventStack.empty()) {\\n                    Event prevEvent = eventStack.top();\\n                    int timeSpent = event.timestamp - lastTimestamp;\\n                    exclusiveTimes[prevEvent.id] += timeSpent;\\n                }\\n                \\n                eventStack.push(event);\\n                lastTimestamp = event.timestamp;\\n            }\\n            else {\\n                int timeSpent = event.timestamp - lastTimestamp;\\n                exclusiveTimes[event.id] += timeSpent;\\n                eventStack.pop();\\n                lastTimestamp = event.timestamp;\\n            }\\n        }\\n        \\n        return exclusiveTimes;\\n    }\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<Event> events = parseEvents(logs);\\n        return getExclusiveTimes(n, events);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Time complexity - O(n)\\n// Space complexity - O(n)\\nclass Solution {\\n    struct Event {\\n        bool isStart;\\n        int timestamp;\\n        int id;\\n        \\n        Event(bool isStart, int timestamp, int id): isStart(isStart), timestamp(timestamp), id(id) {}\\n    };\\n    \\n    string parseNext(string &log, int &ind) {\\n        if(log[ind] == \\':\\') {\\n            ind++;\\n        }\\n        \\n        string result = \"\";\\n        while(ind < log.size() && log[ind] != \\':\\') {\\n            result += log[ind++];\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<Event> parseEvents(vector<string>& logs) {\\n        vector<Event> events;\\n        for(auto &log: logs) {\\n            int ind = 0;\\n            string id = parseNext(log, ind);\\n            string type = parseNext(log, ind);\\n            string timestamp = parseNext(log, ind);\\n            \\n            Event event = {\\n                type == \"start\",\\n                stoi(timestamp) + (type == \"start\" ? 0 : 1),\\n                stoi(id)\\n            };\\n            \\n            events.push_back(event);\\n        }\\n        \\n        return events;\\n    }\\n    \\n    vector<int> getExclusiveTimes(int n, vector<Event> &events) {\\n        stack<Event> eventStack;\\n        int lastTimestamp = 0;\\n        \\n        vector<int> exclusiveTimes(n, 0);\\n        \\n        for(auto &event: events) {\\n            if(event.isStart) {\\n                if(!eventStack.empty()) {\\n                    Event prevEvent = eventStack.top();\\n                    int timeSpent = event.timestamp - lastTimestamp;\\n                    exclusiveTimes[prevEvent.id] += timeSpent;\\n                }\\n                \\n                eventStack.push(event);\\n                lastTimestamp = event.timestamp;\\n            }\\n            else {\\n                int timeSpent = event.timestamp - lastTimestamp;\\n                exclusiveTimes[event.id] += timeSpent;\\n                eventStack.pop();\\n                lastTimestamp = event.timestamp;\\n            }\\n        }\\n        \\n        return exclusiveTimes;\\n    }\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<Event> events = parseEvents(logs);\\n        return getExclusiveTimes(n, events);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368998,
                "title": "simple-cpp-solution-using-stack-with-explanation-o-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) \\n    {\\n        vector<int> res(n, 0);\\n        stack<pair<int, int>> st;\\n        \\n        //Iterate through given strings\\n        for(auto str : logs)\\n        {\\n            int i = 0, id = 0, time = 0;\\n            string op = \"\";\\n            \\n            //Get the function id\\n            while(i < str.size() && str[i] >= \\'0\\' && str[i] <= \\'9\\')\\n            {\\n                id = (id * 10) + (str[i] - \\'0\\');\\n                i++;\\n            }\\n            \\n            i++;\\n            \\n            //Get the type of operation performed\\n            while(str[i] != \\':\\')\\n                op += str[i++];\\n            \\n            i++;\\n            \\n            //Get the timestamp\\n            while(i < str.size() && str[i] >= \\'0\\' && str[i] <= \\'9\\')\\n            {\\n                time = (time * 10) + (str[i] - \\'0\\');\\n                i++;\\n            }\\n            \\n            //If current operation is start, push to stack\\n            if(op == \"start\")\\n            {\\n                st.push({id, time});\\n            }\\n            //Else its an end operation\\n            else\\n            {\\n                auto prev = st.top();\\n                st.pop();\\n                \\n                int offsetTime = time - prev.second + 1;\\n                \\n                //Add offset time to corresponding function\\n                res[prev.first] += offsetTime;\\n                \\n                //If we have another function on stack, reduce the offset time from its running time\\n                if(!st.empty())\\n                {\\n                    res[st.top().first] -= offsetTime;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) \\n    {\\n        vector<int> res(n, 0);\\n        stack<pair<int, int>> st;\\n        \\n        //Iterate through given strings\\n        for(auto str : logs)\\n        {\\n            int i = 0, id = 0, time = 0;\\n            string op = \"\";\\n            \\n            //Get the function id\\n            while(i < str.size() && str[i] >= \\'0\\' && str[i] <= \\'9\\')\\n            {\\n                id = (id * 10) + (str[i] - \\'0\\');\\n                i++;\\n            }\\n            \\n            i++;\\n            \\n            //Get the type of operation performed\\n            while(str[i] != \\':\\')\\n                op += str[i++];\\n            \\n            i++;\\n            \\n            //Get the timestamp\\n            while(i < str.size() && str[i] >= \\'0\\' && str[i] <= \\'9\\')\\n            {\\n                time = (time * 10) + (str[i] - \\'0\\');\\n                i++;\\n            }\\n            \\n            //If current operation is start, push to stack\\n            if(op == \"start\")\\n            {\\n                st.push({id, time});\\n            }\\n            //Else its an end operation\\n            else\\n            {\\n                auto prev = st.top();\\n                st.pop();\\n                \\n                int offsetTime = time - prev.second + 1;\\n                \\n                //Add offset time to corresponding function\\n                res[prev.first] += offsetTime;\\n                \\n                //If we have another function on stack, reduce the offset time from its running time\\n                if(!st.empty())\\n                {\\n                    res[st.top().first] -= offsetTime;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363189,
                "title": "java-simple-recursion",
                "content": "Process the input just like how the functions are executed. Calculate the time when nested functions are executed to determine the total execution.\\n\\n```\\nclass Solution {\\n    int[] aux;\\n    int i = 0;\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        i = 0;\\n        aux = new int[n];\\n        while(i<logs.size()) {\\n            process(logs);\\n        }        \\n        return aux;\\n    }\\n    \\n    public int process(List<String> logs) {\\n        String[] first = logs.get(i++).split(\":\");\\n        int nested = 0;\\n        while(!logs.get(i).contains(\"end\")) {\\n            nested += process(logs);\\n        }\\n        String[] last = logs.get(i++).split(\":\");\\n        int duration = Integer.parseInt(last[2]) - Integer.parseInt(first[2]) + 1;\\n        aux[Integer.parseInt(first[0])] += duration - nested;\\n        return duration;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] aux;\\n    int i = 0;\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        i = 0;\\n        aux = new int[n];\\n        while(i<logs.size()) {\\n            process(logs);\\n        }        \\n        return aux;\\n    }\\n    \\n    public int process(List<String> logs) {\\n        String[] first = logs.get(i++).split(\":\");\\n        int nested = 0;\\n        while(!logs.get(i).contains(\"end\")) {\\n            nested += process(logs);\\n        }\\n        String[] last = logs.get(i++).split(\":\");\\n        int duration = Integer.parseInt(last[2]) - Integer.parseInt(first[2]) + 1;\\n        aux[Integer.parseInt(first[0])] += duration - nested;\\n        return duration;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355485,
                "title": "636-python3-simple-stack",
                "content": "Time complexity: ```O(n)```\\nSpace complexity: ```O(n)```\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        res = [0] * n\\n\\n        for log in logs:\\n            function, state, timestamp = log.split(\":\")\\n            function, timestamp = int(function), int(timestamp)\\n            if state == \"start\":\\n                stack.append([timestamp, 0])  # [start time, overlap]\\n            else:\\n                start, overlap = stack.pop()\\n                inclusive = timestamp - start + 1\\n                exclusive = inclusive - overlap\\n                res[function] += exclusive\\n                if stack:\\n                    stack[-1][1] += inclusive\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```O(n)```\n```O(n)```\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = []\\n        res = [0] * n\\n\\n        for log in logs:\\n            function, state, timestamp = log.split(\":\")\\n            function, timestamp = int(function), int(timestamp)\\n            if state == \"start\":\\n                stack.append([timestamp, 0])  # [start time, overlap]\\n            else:\\n                start, overlap = stack.pop()\\n                inclusive = timestamp - start + 1\\n                exclusive = inclusive - overlap\\n                res[function] += exclusive\\n                if stack:\\n                    stack[-1][1] += inclusive\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349305,
                "title": "python-stack-solution",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        res = [0] * n\\n        stack = []\\n        idx = 0\\n        while idx < len(logs):\\n            idx_2, opt_2, t_2 = logs[idx].split(\":\")\\n            idx_2, t_2 = int(idx_2), int(t_2)\\n            if \\'start\\' == opt_2:\\n                stack.append((idx_2, t_2))\\n            else:\\n                idx_1, t_1 = stack.pop()\\n                time_cost = t_2 - t_1 + 1\\n                res[idx_1] += time_cost\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\tA non-empty stack represents a nested function invocation\\n\\t\\t\\t\\tTo avoid duplicated counting, we can subtract the time costs on the nested function first\\n\\t\\t\\t\\t\\'\\'\\'\\n                if stack:\\n                    idx_recursion = stack[-1][0]\\n                    res[idx_recursion] -= time_cost\\n            idx += 1\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        res = [0] * n\\n        stack = []\\n        idx = 0\\n        while idx < len(logs):\\n            idx_2, opt_2, t_2 = logs[idx].split(\":\")\\n            idx_2, t_2 = int(idx_2), int(t_2)\\n            if \\'start\\' == opt_2:\\n                stack.append((idx_2, t_2))\\n            else:\\n                idx_1, t_1 = stack.pop()\\n                time_cost = t_2 - t_1 + 1\\n                res[idx_1] += time_cost\\n\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\tA non-empty stack represents a nested function invocation\\n\\t\\t\\t\\tTo avoid duplicated counting, we can subtract the time costs on the nested function first\\n\\t\\t\\t\\t\\'\\'\\'\\n                if stack:\\n                    idx_recursion = stack[-1][0]\\n                    res[idx_recursion] -= time_cost\\n            idx += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332051,
                "title": "golang-o-n-100-beat",
                "content": "With questions that involve a \"start\" and \"end\", a stack should always come to mind. You can think of the same principles as \"(\" open or \")\" closed parenthesis problems.\\n\\n**Steps involved:**\\n* go through the list and add elements to the stack if  its a `start`\\n\\t* while adding to the stack add an offset time for each difference moving forward, think [0, cur - offset, cur - (offset+prevOffset), ...]\\n* if its an end then create the difference in time from the top of the stack \\n* add that delta to the corresponding id in your resulting array\\n* add the delta to the offset\\n\\n```\\n-- first loop --\\nstack = [], offset/delta = 0\\nlog = [0:start:0, 1:start:2, 1:end:5, 0:end:6]\\n-- second loop --\\nstack = [0:start:0, 1:start:2]\\nlog   = [1:end:5,  0:end:6]\\ndelta = 5 - 2 + 1 // 4\\n\\noffset = 0 + 4\\nres = [0, 4] // id 0, id 1\\n-- third loop --\\nstack = [0:start:0]\\nlog   = 0:end:6\\n\\ndelta = (6-4) - 0 + 1 // 3\\n\\noffset = 4 + 3\\nres = [3, 4]\\n\\n-- end --\\n```\\n\\n\\nhere is the code: \\n\\n```\\ntype log struct {\\n  id int\\n  action string\\n  time int\\n}\\n\\nfunc parseLog(s string) (int, string, int) {\\n  split := strings.Split(\":\")\\n  id, _ := strconv.Atoi(split[0])\\n  t, _ := strconv.Atoi(split[2])\\n  return id, split[1], t\\n}\\n\\nfunc exlusiveTime(n int, logs []string) []int {\\n  offset := 0\\n  stack := make([]log, 0)\\n  res := make([]int, n)\\n  \\n  var top log\\n  for _, logString := range logs {\\n    id, action, time := parseLog(logString)\\n\\t\\n\\tlog := log{id, action,time - offset) // pay attention to the offset\\n\\tif action == \"start\" {\\n\\t  stack = append(stack, log)\\n\\t}\\n\\t\\n\\ttop, stack = stack[len(stack) -1], stack[:len(stack)-1] // get the top and pop \\n\\tdelta := log.time - top.time + 1\\n\\tres[log.id] += delta\\n\\t\\n\\toffset += delta\\n  }\\n  \\n  \\n  return res\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n-- first loop --\\nstack = [], offset/delta = 0\\nlog = [0:start:0, 1:start:2, 1:end:5, 0:end:6]\\n-- second loop --\\nstack = [0:start:0, 1:start:2]\\nlog   = [1:end:5,  0:end:6]\\ndelta = 5 - 2 + 1 // 4\\n\\noffset = 0 + 4\\nres = [0, 4] // id 0, id 1\\n-- third loop --\\nstack = [0:start:0]\\nlog   = 0:end:6\\n\\ndelta = (6-4) - 0 + 1 // 3\\n\\noffset = 4 + 3\\nres = [3, 4]\\n\\n-- end --\\n```\n```\\ntype log struct {\\n  id int\\n  action string\\n  time int\\n}\\n\\nfunc parseLog(s string) (int, string, int) {\\n  split := strings.Split(\":\")\\n  id, _ := strconv.Atoi(split[0])\\n  t, _ := strconv.Atoi(split[2])\\n  return id, split[1], t\\n}\\n\\nfunc exlusiveTime(n int, logs []string) []int {\\n  offset := 0\\n  stack := make([]log, 0)\\n  res := make([]int, n)\\n  \\n  var top log\\n  for _, logString := range logs {\\n    id, action, time := parseLog(logString)\\n\\t\\n\\tlog := log{id, action,time - offset) // pay attention to the offset\\n\\tif action == \"start\" {\\n\\t  stack = append(stack, log)\\n\\t}\\n\\t\\n\\ttop, stack = stack[len(stack) -1], stack[:len(stack)-1] // get the top and pop \\n\\tdelta := log.time - top.time + 1\\n\\tres[log.id] += delta\\n\\t\\n\\toffset += delta\\n  }\\n  \\n  \\n  return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1285889,
                "title": "javascript",
                "content": "```\\nclass LogFunc {\\n    constructor(t, funcId, callerId = null) {\\n        this.time = t;\\n        this.funcId = funcId;\\n        this.callerId = callerId;\\n    }\\n}\\n\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nconst exclusiveTime = (n, logs) => {\\n    const res = Array(n).fill(0);    \\n    \\n    const stack = [];\\n    let timeDelay = 0;\\n    \\n    const EVENTS_CALLBACKS = new Map([\\n        [\\'start\\', (id, t) => {\\n            const callerEntity = stack.length > 0 ? stack[stack.length - 1] : null;\\n            \\n            if (callerEntity){\\n                stack.push(new LogFunc(t, id, callerEntity.funcId));\\n            } else {\\n                stack.push(new LogFunc(t, id));\\n            }\\n        }],\\n        [\\'end\\', (endId, endTime) => {\\n            const {time, funcId, callerId} = stack.pop();\\n            const timeShift = endTime - time + 1;\\n            \\n            if (callerId !== null) {\\n                res[callerId] -= timeShift;\\n            }\\n            \\n            res[funcId] +=  timeShift;\\n        }]\\n    ])\\n    \\n    for (let i = 0; i < logs.length; i++) {\\n        let [id, event, t] = logs[i].split(\\':\\');\\n        t = Number(t);\\n        id = Number(id);\\n        EVENTS_CALLBACKS.get(event)(id, t);\\n    }\\n\\n    return res;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass LogFunc {\\n    constructor(t, funcId, callerId = null) {\\n        this.time = t;\\n        this.funcId = funcId;\\n        this.callerId = callerId;\\n    }\\n}\\n\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nconst exclusiveTime = (n, logs) => {\\n    const res = Array(n).fill(0);    \\n    \\n    const stack = [];\\n    let timeDelay = 0;\\n    \\n    const EVENTS_CALLBACKS = new Map([\\n        [\\'start\\', (id, t) => {\\n            const callerEntity = stack.length > 0 ? stack[stack.length - 1] : null;\\n            \\n            if (callerEntity){\\n                stack.push(new LogFunc(t, id, callerEntity.funcId));\\n            } else {\\n                stack.push(new LogFunc(t, id));\\n            }\\n        }],\\n        [\\'end\\', (endId, endTime) => {\\n            const {time, funcId, callerId} = stack.pop();\\n            const timeShift = endTime - time + 1;\\n            \\n            if (callerId !== null) {\\n                res[callerId] -= timeShift;\\n            }\\n            \\n            res[funcId] +=  timeShift;\\n        }]\\n    ])\\n    \\n    for (let i = 0; i < logs.length; i++) {\\n        let [id, event, t] = logs[i].split(\\':\\');\\n        t = Number(t);\\n        id = Number(id);\\n        EVENTS_CALLBACKS.get(event)(id, t);\\n    }\\n\\n    return res;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281733,
                "title": "java-stack-helper-class",
                "content": "```\\nclass Solution {\\n    class Log {\\n        int id;\\n        int time;\\n        String op;\\n        \\n        Log(String log) {\\n            String[] result = log.split(\":\");\\n            this.id = Integer.parseInt(result[0]);\\n            this.op = result[1];\\n            this.time = Integer.parseInt(result[2]);\\n        }\\n        \\n        public boolean isStart() {\\n            return this.op.equals(\"start\");\\n        }\\n    }\\n    \\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] output = new int[n];\\n        Stack<Log> stack = new Stack<>();\\n        int prevTime = 0;\\n        for(String log: logs) {\\n            Log cur = new Log(log);\\n            if (cur.isStart()) {\\n                if (!stack.empty()) {\\n                    output[stack.peek().id] += cur.time-prevTime;\\n                } \\n                stack.push(cur);\\n                prevTime = cur.time;\\n            } else {\\n                stack.pop();\\n                output[cur.id] += cur.time-prevTime+1;\\n                prevTime = cur.time+1;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Log {\\n        int id;\\n        int time;\\n        String op;\\n        \\n        Log(String log) {\\n            String[] result = log.split(\":\");\\n            this.id = Integer.parseInt(result[0]);\\n            this.op = result[1];\\n            this.time = Integer.parseInt(result[2]);\\n        }\\n        \\n        public boolean isStart() {\\n            return this.op.equals(\"start\");\\n        }\\n    }\\n    \\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] output = new int[n];\\n        Stack<Log> stack = new Stack<>();\\n        int prevTime = 0;\\n        for(String log: logs) {\\n            Log cur = new Log(log);\\n            if (cur.isStart()) {\\n                if (!stack.empty()) {\\n                    output[stack.peek().id] += cur.time-prevTime;\\n                } \\n                stack.push(cur);\\n                prevTime = cur.time;\\n            } else {\\n                stack.pop();\\n                output[cur.id] += cur.time-prevTime+1;\\n                prevTime = cur.time+1;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224600,
                "title": "python-straightforward-answer",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = collections.deque()\\n        res = [0 for i in range(n)]\\n        \\n        for log in logs:\\n            log = log.split(\\':\\')\\n            fid, sign, ts = int(log[0]), log[1], int(log[2])\\n            if sign == \\'start\\':\\n                if stack:\\n                    res[stack[-1][0]] += ts - stack[-1][1]\\n                stack.append([fid, ts])\\n\\n            elif sign == \\'end\\':\\n                key, value = stack.pop()\\n                res[key] += ts - value + 1\\n                if stack:\\n                    stack[-1][1] = ts + 1\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        stack = collections.deque()\\n        res = [0 for i in range(n)]\\n        \\n        for log in logs:\\n            log = log.split(\\':\\')\\n            fid, sign, ts = int(log[0]), log[1], int(log[2])\\n            if sign == \\'start\\':\\n                if stack:\\n                    res[stack[-1][0]] += ts - stack[-1][1]\\n                stack.append([fid, ts])\\n\\n            elif sign == \\'end\\':\\n                key, value = stack.pop()\\n                res[key] += ts - value + 1\\n                if stack:\\n                    stack[-1][1] = ts + 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209952,
                "title": "easy-to-understand-solution-in-javascript",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nvar exclusiveTime = function(n, logs) {\\n    execTime = Array(n).fill(0);\\n    callStack = [];\\n    \\n    for(const log of logs) {\\n        [ pid, functionStatus, ts ] = log.split(\\':\\');\\n        \\n        if(functionStatus === \\'start\\') {\\n            if(callStack.length) {\\n\\t\\t\\t    // storing the parent function which is calling the current function\\n                parentFunctionPid = callStack[callStack.length - 1][0];\\n            }\\n            else {\\n                parentFunctionPid = -1;\\n            }\\n\\n            callStack.push([ pid, ts, parentFunctionPid ]);\\n        }\\n        else {\\n            [ childPid, childStartTs, parentPid ] = callStack.pop();\\n            \\n            fnExecTime = ts - childStartTs + 1;\\n            execTime[childPid] += fnExecTime;\\n           \\n\\t\\t    // execution time of the child fuction subtracted from the parent function.\\n            if(parentPid !== -1) {\\n                execTime[parentPid] -= fnExecTime;\\n            }\\n        }\\n    }\\n    \\n    return execTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {string[]} logs\\n * @return {number[]}\\n */\\nvar exclusiveTime = function(n, logs) {\\n    execTime = Array(n).fill(0);\\n    callStack = [];\\n    \\n    for(const log of logs) {\\n        [ pid, functionStatus, ts ] = log.split(\\':\\');\\n        \\n        if(functionStatus === \\'start\\') {\\n            if(callStack.length) {\\n\\t\\t\\t    // storing the parent function which is calling the current function\\n                parentFunctionPid = callStack[callStack.length - 1][0];\\n            }\\n            else {\\n                parentFunctionPid = -1;\\n            }\\n\\n            callStack.push([ pid, ts, parentFunctionPid ]);\\n        }\\n        else {\\n            [ childPid, childStartTs, parentPid ] = callStack.pop();\\n            \\n            fnExecTime = ts - childStartTs + 1;\\n            execTime[childPid] += fnExecTime;\\n           \\n\\t\\t    // execution time of the child fuction subtracted from the parent function.\\n            if(parentPid !== -1) {\\n                execTime[parentPid] -= fnExecTime;\\n            }\\n        }\\n    }\\n    \\n    return execTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197991,
                "title": "java-simple-solution-using-stack-with-comments",
                "content": "Use +1 for start, -1 for end operation. Create a stack of states, where state = {id, op, timestamp}\\nOnly put start events on the stack. When you get an end event, pop the start event from the stack, because it means the function for the function execution on top of stack has ended\\n```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<int[]> stack = new Stack();\\n        int[] res = new int[n];\\n        for (int i = 0; i < logs.size();i++) {\\n            String[] vals =logs.get(i).split(\":\");\\n            int id = Integer.valueOf(vals[0]);\\n            int time = Integer.valueOf(vals[2]);\\n            int op = vals[1].equals(\"start\") ? 1 : -1;\\n            \\n            if (op == 1) {\\n                if (!stack.isEmpty()) {\\n\\t\\t\\t\\t// Whenever you get a start event, update the time for the previously executing event\\n                    res[stack.peek()[0]] += time - stack.peek()[1];\\n                }\\n                stack.add(new int[]{id, time});\\n            } else {\\n\\t\\t\\t// Whenever you get an end event, the event on the stack(currently executing function) will have the same id as that of the end event. Update the time \\n\\t\\t\\t// of the currently executing function and pop it off the stack since it has completed\\n                int[] currTask = stack.pop();\\n                res[currTask[0]] += time-currTask[1]+1;\\n\\t\\t\\t\\t// The next function inn the stack would start executuing as soon as the top event is popped. Update the execution start timestamp of the next function.\\n                if (!stack.isEmpty()) {\\n                    stack.peek()[1] = time+1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n        Stack<int[]> stack = new Stack();\\n        int[] res = new int[n];\\n        for (int i = 0; i < logs.size();i++) {\\n            String[] vals =logs.get(i).split(\":\");\\n            int id = Integer.valueOf(vals[0]);\\n            int time = Integer.valueOf(vals[2]);\\n            int op = vals[1].equals(\"start\") ? 1 : -1;\\n            \\n            if (op == 1) {\\n                if (!stack.isEmpty()) {\\n\\t\\t\\t\\t// Whenever you get a start event, update the time for the previously executing event\\n                    res[stack.peek()[0]] += time - stack.peek()[1];\\n                }\\n                stack.add(new int[]{id, time});\\n            } else {\\n\\t\\t\\t// Whenever you get an end event, the event on the stack(currently executing function) will have the same id as that of the end event. Update the time \\n\\t\\t\\t// of the currently executing function and pop it off the stack since it has completed\\n                int[] currTask = stack.pop();\\n                res[currTask[0]] += time-currTask[1]+1;\\n\\t\\t\\t\\t// The next function inn the stack would start executuing as soon as the top event is popped. Update the execution start timestamp of the next function.\\n                if (!stack.isEmpty()) {\\n                    stack.peek()[1] = time+1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165552,
                "title": "swift-stack",
                "content": "```swift\\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\\n        var stack = [Int]()\\n        var res = (0..<n).map { _ in 0 }\\n        var startTime = 0\\n        for log in logs {\\n            let data = log.split(separator: \":\")\\n            let id = Int(data[0])!, op = data[1], time = Int(data[2])!\\n            switch op {\\n                case \"start\":\\n                   if !stack.isEmpty {\\n                       let lastId = stack.last!\\n                       res[lastId] += time - startTime - 1\\n                   }\\n                   stack.append(id) \\n                   startTime = time\\n                case \"end\":\\n                    let lastId = stack.removeLast()\\n                    res[lastId] += time - startTime + 1 \\n                    startTime = time\\n                default:\\n                    break\\n            }\\n        }\\n        return res\\n    }\\n```",
                "solutionTags": [],
                "code": "```swift\\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\\n        var stack = [Int]()\\n        var res = (0..<n).map { _ in 0 }\\n        var startTime = 0\\n        for log in logs {\\n            let data = log.split(separator: \":\")\\n            let id = Int(data[0])!, op = data[1], time = Int(data[2])!\\n            switch op {\\n                case \"start\":\\n                   if !stack.isEmpty {\\n                       let lastId = stack.last!\\n                       res[lastId] += time - startTime - 1\\n                   }\\n                   stack.append(id) \\n                   startTime = time\\n                case \"end\":\\n                    let lastId = stack.removeLast()\\n                    res[lastId] += time - startTime + 1 \\n                    startTime = time\\n                default:\\n                    break\\n            }\\n        }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157110,
                "title": "javascript-o-n-95",
                "content": "```\\nvar exclusiveTime = function(n, logs) {\\n    let [time,stack]=[0,[]];\\n    let rst = [];\\n    logs.forEach((l)=>{\\n        let [id,state,timeStamp]=l.split(\\':\\');\\n        switch(state){\\n            case \"start\":\\n                if(stack.length>0){\\n                    stack[stack.length-1]+=timeStamp-time;\\n                }\\n                stack.push(0);\\n                time=timeStamp;\\n                break;\\n            case \"end\":\\n                let lastRun = stack.pop();\\n                timeStamp++;//because process stops at the end of the second.\\n                rst[id]=(rst[id]||0)+(timeStamp-time)+lastRun;\\n                time=timeStamp;\\n                break;\\n        }\\n    });\\n    return rst;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar exclusiveTime = function(n, logs) {\\n    let [time,stack]=[0,[]];\\n    let rst = [];\\n    logs.forEach((l)=>{\\n        let [id,state,timeStamp]=l.split(\\':\\');\\n        switch(state){\\n            case \"start\":\\n                if(stack.length>0){\\n                    stack[stack.length-1]+=timeStamp-time;\\n                }\\n                stack.push(0);\\n                time=timeStamp;\\n                break;\\n            case \"end\":\\n                let lastRun = stack.pop();\\n                timeStamp++;//because process stops at the end of the second.\\n                rst[id]=(rst[id]||0)+(timeStamp-time)+lastRun;\\n                time=timeStamp;\\n                break;\\n        }\\n    });\\n    return rst;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1151943,
                "title": "java-stack-o-n",
                "content": "class Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        Stack<Integer> stk=new Stack<>();\\n        int ans[]=new int[n];\\n        int prev=0;\\n        for(String s:logs)\\n        {\\n            String temp[]=s.split(\":\");\\n            int id=Integer.parseInt(temp[0]);\\n            int time=Integer.parseInt(temp[2]);\\n            \\n            if(stk.size()==0)\\n            {\\n                stk.push(id);\\n                prev=time;\\n            }\\n            else\\n            {\\n                \\n                int diff=time-prev;\\n                if(temp[1].equals(\"end\"))\\n                    diff++;\\n                \\n                ans[stk.peek()]+=diff;\\n                prev=time;\\n                if(temp[1].equals(\"end\"))\\n                {\\n                    stk.pop();\\n                    prev++;\\n                }\\n                else\\n                    stk.push(id);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        Stack<Integer> stk=new Stack<>();\\n        int ans[]=new int[n];\\n        int prev=0;\\n        for(String s:logs)\\n        {\\n            String temp[]=s.split(\":\");\\n            int id=Integer.parseInt(temp[0]);\\n            int time=Integer.parseInt(temp[2]);\\n            \\n            if(stk.size()==0)\\n            {\\n                stk.push(id);\\n                prev=time;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1108753,
                "title": "python-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\t\\t\\tres = [0] * n\\n\\t\\t\\tstack = []\\n\\t\\t\\tfor log in logs:\\n\\t\\t\\t\\ti, status, time = log.split(\":\")\\n\\t\\t\\t\\tif status == \"start\":\\n\\t\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\t\\tres[stack[-1][0]] += int(time) - stack[-1][1]\\n\\t\\t\\t\\t\\tstack.append([int(i), int(time)])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[int(i)] += int(time) - stack.pop()[1] + 1\\n\\t\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\t\\tstack[-1][1] = int(time) + 1\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\t\\t\\tres = [0] * n\\n\\t\\t\\tstack = []\\n\\t\\t\\tfor log in logs:\\n\\t\\t\\t\\ti, status, time = log.split(\":\")\\n\\t\\t\\t\\tif status == \"start\":\\n\\t\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\t\\tres[stack[-1][0]] += int(time) - stack[-1][1]\\n\\t\\t\\t\\t\\tstack.append([int(i), int(time)])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[int(i)] += int(time) - stack.pop()[1] + 1\\n\\t\\t\\t\\t\\tif stack:\\n\\t\\t\\t\\t\\t\\tstack[-1][1] = int(time) + 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1105388,
                "title": "c-linear-time-scan-using-a-stack-with-explanation",
                "content": "**Key point:**\\n* Like a real computer, we need a stack to push in functions.\\n* In the stack I save off the function start time and how long it was pushed in stack by other functions on top.\\n* When I encountered an end log entry, I trust the log was never messed up and it must match with the top entry in stack. In real life, I will always double check.\\n* The run time of any function is its end time + 1 - start time - wait in stack time.\\n* When a function is popped from stack, make sure the next function in stack accumulate its wait time.\\n```\\n  vector<int> exclusiveTime(int n, vector<string>& logs) {\\n    vector<int> ret(n, 0);\\n    vector<std::pair<int, int>> s;\\n    for (const string & log : logs) {\\n      size_t pos;\\n      int id = std::stoi(log, &pos);\\n      bool start = log[pos+1] == \\'s\\';\\n      int t = std::stoi(log.substr(pos+(start?7:5)));\\n      if (start)\\n        s.push_back({t, 0});\\n      else {\\n        std::pair<int, int> head = s.back();\\n        s.pop_back();\\n        ret[id] += t + 1 - head.first - head.second;\\n        if (s.size())\\n          s.back().second += t + 1- head.first;\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n  vector<int> exclusiveTime(int n, vector<string>& logs) {\\n    vector<int> ret(n, 0);\\n    vector<std::pair<int, int>> s;\\n    for (const string & log : logs) {\\n      size_t pos;\\n      int id = std::stoi(log, &pos);\\n      bool start = log[pos+1] == \\'s\\';\\n      int t = std::stoi(log.substr(pos+(start?7:5)));\\n      if (start)\\n        s.push_back({t, 0});\\n      else {\\n        std::pair<int, int> head = s.back();\\n        s.pop_back();\\n        ret[id] += t + 1 - head.first - head.second;\\n        if (s.size())\\n          s.back().second += t + 1- head.first;\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079696,
                "title": "concise-python-and-swift-using-different-accounting-of-stacks-with-explanations-beats-100",
                "content": "Using stack is a natural choice for this kind of problem.\\nFollowing a simple logic: we only care about ID of the function that it\\'s on the top of the stack. The previous timestamp (pts) is always the timestamp (ts) from last log entry that we processed.  If a new event is an \"end\" event, we pop current function and update the run time of current function with an adjustment of +1 ; if it\\'s a \"start\" event, we still update the current function without adjustment.\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        result,stack,ts=[0]*n,[],0\\n        for log in logs:\\n            pts, pid=ts, stack[-1] if stack else 0\\n            id,event,ts=log.split(\\':\\')\\n            id,ts=int(id),int(ts) \\n            if event==\\'end\\': \\n                stack.pop()\\n                ts+=1  #end event necessitates an adjustment of adding 1\\n            else:\\n                stack.append(id)  # we only need to track id\\n            result[pid] += ts - pts #always update the function that is on the stack top\\n        return result\\n```\\n\\nFor Swift implementation, I used a slightly different accounting approach which beats 100% of answers. I use result list to maintain an important invariant to reflect the most up-to-date cumulative runtime so far for each function. \\n```\\nclass Solution {\\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\\n        /* Algorithm step by step:\\n        1.  Create a n-element result list and init to value 0 ; create an empty stack that holds (Int,Int) tuples\\n        2.  process each log from logs list:\\n            2a. split log to id,event,time \\n            2b. convert id and time from String to Int\\n        3. if the new event is start, push to stack and continue\\n        4. otherwise, \\n            4a. pop stack\\n            4b. get DURATION of the current running event\\'s runtime by substracting: newTime-currentStackTopTime+1\\n            4c. now whatever on stack top can resume its execution from here, but due to the past DURATION time was\\n                occupied by other function, we need to substract duration from its runtime in result. \\n                The result maintains the invariant that the current value for each function is the cumulative runtime up to current moment\\n        6. return result list\\n        */\\n        var stack:[(Int,Int)]=[], result:[Int]=Array<Int>(repeating:0, count:n)\\n        for log in logs {\\n            let splited=log.split(separator:\":\")\\n            let id=Int(splited[0]), time=Int(splited[2])\\n            if splited[1]==\"start\" {\\n                stack.append((id!,time!))\\n            }\\n            else {\\n                var (currFuncId, currFuncTime)=stack.removeLast()\\n                let runtime=time!-currFuncTime+1\\n                result[currFuncId]+=runtime //An important invariant of this algo is to maintain an up-to-the-moment cumulative runtime for each function in result\\n                if stack.count>0 { \\n                    var (currFuncId, currFuncTime)=stack.last!   //The current func on top can resume its running, but adjusted by the duration for which it did not run\\n                    result[currFuncId]-=runtime\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        result,stack,ts=[0]*n,[],0\\n        for log in logs:\\n            pts, pid=ts, stack[-1] if stack else 0\\n            id,event,ts=log.split(\\':\\')\\n            id,ts=int(id),int(ts) \\n            if event==\\'end\\': \\n                stack.pop()\\n                ts+=1  #end event necessitates an adjustment of adding 1\\n            else:\\n                stack.append(id)  # we only need to track id\\n            result[pid] += ts - pts #always update the function that is on the stack top\\n        return result\\n```\n```\\nclass Solution {\\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\\n        /* Algorithm step by step:\\n        1.  Create a n-element result list and init to value 0 ; create an empty stack that holds (Int,Int) tuples\\n        2.  process each log from logs list:\\n            2a. split log to id,event,time \\n            2b. convert id and time from String to Int\\n        3. if the new event is start, push to stack and continue\\n        4. otherwise, \\n            4a. pop stack\\n            4b. get DURATION of the current running event\\'s runtime by substracting: newTime-currentStackTopTime+1\\n            4c. now whatever on stack top can resume its execution from here, but due to the past DURATION time was\\n                occupied by other function, we need to substract duration from its runtime in result. \\n                The result maintains the invariant that the current value for each function is the cumulative runtime up to current moment\\n        6. return result list\\n        */\\n        var stack:[(Int,Int)]=[], result:[Int]=Array<Int>(repeating:0, count:n)\\n        for log in logs {\\n            let splited=log.split(separator:\":\")\\n            let id=Int(splited[0]), time=Int(splited[2])\\n            if splited[1]==\"start\" {\\n                stack.append((id!,time!))\\n            }\\n            else {\\n                var (currFuncId, currFuncTime)=stack.removeLast()\\n                let runtime=time!-currFuncTime+1\\n                result[currFuncId]+=runtime //An important invariant of this algo is to maintain an up-to-the-moment cumulative runtime for each function in result\\n                if stack.count>0 { \\n                    var (currFuncId, currFuncTime)=stack.last!   //The current func on top can resume its running, but adjusted by the duration for which it did not run\\n                    result[currFuncId]-=runtime\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067251,
                "title": "java-with-in-depth-explanation-and-logical-variable-names",
                "content": "This problem really confused me but it\\'s actually quite easy once you understand it.  I hope this code and explanation will help save the community valuable time.  My code is intended to be fast but also to be easy to understand and more importantly remember.\\n\\nHappy Coding!!!\\n\\n```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        //here we declare and array to store the overall runtimes\\n        //A stack to store the order of tasks being executed\\n        //and an int to track the current time\\n        \\n        int[] runTimes = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        int currentTime = 0;\\n        \\n        // we loop through all the logs\\n        for(String l : logs){\\n            // split the string into an array we can parse for \\n            // important information\\n            String[] log = l.split(\"\\\\\\\\:\");\\n            int currTask = Integer.valueOf(log[0]);\\n            int currTimeStamp = Integer.valueOf(log[2]);\\n            String command = log[1];\\n            \\n            // There are only three different possabilities \\n            // 1) stacks empty and we a starting a new function\\n            // 2) stacks not empty and we a starting a new function\\n            // 3) we are ending a function\\n            if(stack.isEmpty() && command.equals(\"start\")){\\n                // stacks empty all we do is push new function\\n                stack.push(currTask);\\n                \\n            }else if(!stack.isEmpty() && command.equals(\"start\")){\\n                // stacks not empty so we update the runtime for\\n                // the task at the top of the stack and set the current\\n                // time to the currentTimeStamp that we a pushing in\\n                // Note: the same task can be pushed multiple times\\n                // without being ended\\n                runTimes[stack.peek()] += currTimeStamp - currentTime;\\n                currentTime = currTimeStamp;\\n                stack.push(currTask);\\n                // when we find command end it will always be to end the\\n                // task at the top of the stack\\n                // Note: when upating the runtime here we add 1 \\n                // the reason for this is that when we start a task we\\n                // begin a the begining of the current block of time\\n                // conversley when we end we end at the end of the current block\\n                // lets say we are at time block 2 if we cal start we begin at the \\n                // divide between 1 and 2 if we call end we end at the divide\\n                // between 2 and 3\\n            }else if(command.equals(\"end\")){\\n                runTimes[stack.pop()] += (currTimeStamp + 1) - currentTime ;\\n                currentTime = currTimeStamp + 1;\\n            }\\n        }\\n        return runTimes;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "This problem really confused me but it\\'s actually quite easy once you understand it.  I hope this code and explanation will help save the community valuable time.  My code is intended to be fast but also to be easy to understand and more importantly remember.\\n\\nHappy Coding!!!\\n\\n```\\npublic int[] exclusiveTime(int n, List<String> logs) {\\n        \\n        //here we declare and array to store the overall runtimes\\n        //A stack to store the order of tasks being executed\\n        //and an int to track the current time\\n        \\n        int[] runTimes = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        int currentTime = 0;\\n        \\n        // we loop through all the logs\\n        for(String l : logs){\\n            // split the string into an array we can parse for \\n            // important information\\n            String[] log = l.split(\"\\\\\\\\:\");\\n            int currTask = Integer.valueOf(log[0]);\\n            int currTimeStamp = Integer.valueOf(log[2]);\\n            String command = log[1];\\n            \\n            // There are only three different possabilities \\n            // 1) stacks empty and we a starting a new function\\n            // 2) stacks not empty and we a starting a new function\\n            // 3) we are ending a function\\n            if(stack.isEmpty() && command.equals(\"start\")){\\n                // stacks empty all we do is push new function\\n                stack.push(currTask);\\n                \\n            }else if(!stack.isEmpty() && command.equals(\"start\")){\\n                // stacks not empty so we update the runtime for\\n                // the task at the top of the stack and set the current\\n                // time to the currentTimeStamp that we a pushing in\\n                // Note: the same task can be pushed multiple times\\n                // without being ended\\n                runTimes[stack.peek()] += currTimeStamp - currentTime;\\n                currentTime = currTimeStamp;\\n                stack.push(currTask);\\n                // when we find command end it will always be to end the\\n                // task at the top of the stack\\n                // Note: when upating the runtime here we add 1 \\n                // the reason for this is that when we start a task we\\n                // begin a the begining of the current block of time\\n                // conversley when we end we end at the end of the current block\\n                // lets say we are at time block 2 if we cal start we begin at the \\n                // divide between 1 and 2 if we call end we end at the divide\\n                // between 2 and 3\\n            }else if(command.equals(\"end\")){\\n                runTimes[stack.pop()] += (currTimeStamp + 1) - currentTime ;\\n                currentTime = currTimeStamp + 1;\\n            }\\n        }\\n        return runTimes;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1030006,
                "title": "0636-c-exclusive-time-of-functions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int>     result(n,0);\\n        vector<int>     vID;\\n        int             prev_time = 0;\\n        for(string s : logs)\\n        {\\n            /* Parse Log */\\n            int     c_pos1    = s.find(\\':\\');\\n            int     c_pos2    = s.find_last_of(\\':\\');\\n            int     p_id      = stoi(s.substr(         0,  c_pos1)); \\n            string  p_status  = s.substr(       c_pos1+1,  c_pos2-(c_pos1+1)); \\n            int     curr_time = stoi(s.substr(  c_pos2+1)); \\n           \\n            if( p_status ==\"start\") {\\n                if( !vID.empty() ){\\n                    result[ vID.back() ] += curr_time - prev_time;\\n                }\\n                vID.push_back( p_id );\\n                prev_time = curr_time;                \\n            }\\n            if( p_status ==\"end\") {                \\n                result[ p_id ] += curr_time - prev_time+1;;\\n                vID.pop_back();\\n                prev_time = curr_time+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int>     result(n,0);\\n        vector<int>     vID;\\n        int             prev_time = 0;\\n        for(string s : logs)\\n        {\\n            /* Parse Log */\\n            int     c_pos1    = s.find(\\':\\');\\n            int     c_pos2    = s.find_last_of(\\':\\');\\n            int     p_id      = stoi(s.substr(         0,  c_pos1)); \\n            string  p_status  = s.substr(       c_pos1+1,  c_pos2-(c_pos1+1)); \\n            int     curr_time = stoi(s.substr(  c_pos2+1)); \\n           \\n            if( p_status ==\"start\") {\\n                if( !vID.empty() ){\\n                    result[ vID.back() ] += curr_time - prev_time;\\n                }\\n                vID.push_back( p_id );\\n                prev_time = curr_time;                \\n            }\\n            if( p_status ==\"end\") {                \\n                result[ p_id ] += curr_time - prev_time+1;;\\n                vID.pop_back();\\n                prev_time = curr_time+1;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021700,
                "title": "c-20ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        int nl=logs.size();\\n        vector<int> ans(n,0);\\n        stack<int> st;\\n        int prev=0;\\n        for(auto& log:logs){\\n            auto [id,state,time]=convert(log);\\n            if(state){\\n                if(!st.empty())\\n                    ans[st.top()]+=time-prev;\\n                st.push(id);\\n                prev=time;\\n            }\\n            else{\\n                ans[st.top()]+=time-prev+1;\\n                st.pop();\\n                prev=time+1;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    tuple<int,bool,int> convert(string& log) {\\n        char* token=strtok((char*)log.c_str(),\":\");\\n        int id=stoi(token);\\n        token=strtok(NULL,\":\");\\n        bool state=token[0]==\\'s\\';\\n        token=strtok(NULL,\":\");\\n        int time=stoi(token);\\n        return {id,state,time};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\\n        int nl=logs.size();\\n        vector<int> ans(n,0);\\n        stack<int> st;\\n        int prev=0;\\n        for(auto& log:logs){\\n            auto [id,state,time]=convert(log);\\n            if(state){\\n                if(!st.empty())\\n                    ans[st.top()]+=time-prev;\\n                st.push(id);\\n                prev=time;\\n            }\\n            else{\\n                ans[st.top()]+=time-prev+1;\\n                st.pop();\\n                prev=time+1;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    tuple<int,bool,int> convert(string& log) {\\n        char* token=strtok((char*)log.c_str(),\":\");\\n        int id=stoi(token);\\n        token=strtok(NULL,\":\");\\n        bool state=token[0]==\\'s\\';\\n        token=strtok(NULL,\":\");\\n        int time=stoi(token);\\n        return {id,state,time};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920025,
                "title": "sadistic-question-messing-with-start-and-end-point-of-time",
                "content": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] ans = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        int time = 0;\\n        String lastAction = \"\";\\n        for (String log : logs) {\\n            String[] sepLog = log.split(\":\");\\n            int id = Integer.parseInt(sepLog[0]);\\n            String action = sepLog[1];\\n            int timestamp = Integer.parseInt(sepLog[2]);\\n            if (action.equals(\"start\")) {\\n                if (!stack.isEmpty()) {\\n                    ans[stack.peek()] += timestamp-time;\\n                }\\n                stack.add(id);\\n                time = timestamp;\\n            } else {\\n                ans[stack.pop()] += timestamp-time+1;\\n                time = timestamp+1;\\n            }\\n            lastAction = action;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        int[] ans = new int[n];\\n        Stack<Integer> stack = new Stack<>();\\n        int time = 0;\\n        String lastAction = \"\";\\n        for (String log : logs) {\\n            String[] sepLog = log.split(\":\");\\n            int id = Integer.parseInt(sepLog[0]);\\n            String action = sepLog[1];\\n            int timestamp = Integer.parseInt(sepLog[2]);\\n            if (action.equals(\"start\")) {\\n                if (!stack.isEmpty()) {\\n                    ans[stack.peek()] += timestamp-time;\\n                }\\n                stack.add(id);\\n                time = timestamp;\\n            } else {\\n                ans[stack.pop()] += timestamp-time+1;\\n                time = timestamp+1;\\n            }\\n            lastAction = action;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886029,
                "title": "java-stack-solution-faster-than-99",
                "content": "Just keep adding time to the exclusive time of the current function *i*\\nAnd substracting time from the exclusive time of the enclosing function.\\nThe reason why this is faster than the Apprache 2 is it takes less add/sub under some scenarios.\\n\\nGiven a series of logs: s1 -- e1 -- s2 -- e2 -- s3 -- e3 -- s4 -- e4\\nMy solution only take 4 x 2 = 8 times of add/sub\\n- 4 is the number of functions\\n- for each function duration calculation, 1 more operation is required  to update the res[]\\n\\nOn the other hand, Approache 2 would take 7 x 2 = 14 times of add/sub\\n- 7 is the number of gaps between the start/end points\\n- for each gap difference calculation, 1 more operation is required  to update the res[]\\n\\n```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        ArrayDeque<String[]> stack = new ArrayDeque<>();\\n        int[] res = new int[n];\\n        \\n        for(String log : logs) {\\n            String[] logEntry = log.split(\":\");\\n            String type = logEntry[1];\\n            \\n            if(\"start\".equals(type)) {\\n                \\n                stack.push(logEntry);\\n                \\n            } else if(\"end\".equals(type)) {\\n                String[] funcStart = stack.pop();\\n                \\n                int id = Integer.parseInt(logEntry[0]);\\n                int start = Integer.parseInt(funcStart[2]);\\n                int end = Integer.parseInt(logEntry[2]);\\n                int duration = end - start + 1;\\n                \\n                /// Add duration to the time for the current func i\\n                res[id] += duration;\\n                \\n                /// If there is a enclosing function\\n                /// Subtract duration from the time for it\\n                if(!stack.isEmpty()) {\\n                    String[] parentFunc = stack.peek();\\n                    int pId = Integer.parseInt(parentFunc[0]);\\n                    res[pId] -= duration;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] exclusiveTime(int n, List<String> logs) {\\n        ArrayDeque<String[]> stack = new ArrayDeque<>();\\n        int[] res = new int[n];\\n        \\n        for(String log : logs) {\\n            String[] logEntry = log.split(\":\");\\n            String type = logEntry[1];\\n            \\n            if(\"start\".equals(type)) {\\n                \\n                stack.push(logEntry);\\n                \\n            } else if(\"end\".equals(type)) {\\n                String[] funcStart = stack.pop();\\n                \\n                int id = Integer.parseInt(logEntry[0]);\\n                int start = Integer.parseInt(funcStart[2]);\\n                int end = Integer.parseInt(logEntry[2]);\\n                int duration = end - start + 1;\\n                \\n                /// Add duration to the time for the current func i\\n                res[id] += duration;\\n                \\n                /// If there is a enclosing function\\n                /// Subtract duration from the time for it\\n                if(!stack.isEmpty()) {\\n                    String[] parentFunc = stack.peek();\\n                    int pId = Integer.parseInt(parentFunc[0]);\\n                    res[pId] -= duration;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848847,
                "title": "stack-based-simple-python",
                "content": "```python\\nclass Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        time for each function = (end log time - start) - (any time taken by functions in between)\\n\\t\\twhere, any time taken by functions in between = total time taken by other functions when it ended - total time taken by other functions when it started\\n\\t\\t\\n        algo:\\n        1. init a stack\\n        2. append [index, start dates, total time taken by other functions]\\n        3. if end log received, calculate time, append it to total time, add at index n\\n        \"\"\"\\n\\t\\t\\n        tty = 0\\n        stack = []\\n        ans = [0]*n\\n        \\n        for log in logs:\\n            [index, typ, time] = log.split(\":\")\\n            if typ == \\'start\\':\\n                stack.append([index, time, tty])\\n            else:\\n                [_, _time, _tty] = stack.pop()\\n                calTime = 1 + (int(time) - int(_time)) - (int(tty)-int(_tty))\\n                tty += calTime\\n                ans[int(index)] += calTime\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def exclusiveTime(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[str]\\n        :rtype: List[int]\\n        time for each function = (end log time - start) - (any time taken by functions in between)\\n\\t\\twhere, any time taken by functions in between = total time taken by other functions when it ended - total time taken by other functions when it started\\n\\t\\t\\n        algo:\\n        1. init a stack\\n        2. append [index, start dates, total time taken by other functions]\\n        3. if end log received, calculate time, append it to total time, add at index n\\n        \"\"\"\\n\\t\\t\\n        tty = 0\\n        stack = []\\n        ans = [0]*n\\n        \\n        for log in logs:\\n            [index, typ, time] = log.split(\":\")\\n            if typ == \\'start\\':\\n                stack.append([index, time, tty])\\n            else:\\n                [_, _time, _tty] = stack.pop()\\n                calTime = 1 + (int(time) - int(_time)) - (int(tty)-int(_tty))\\n                tty += calTime\\n                ans[int(index)] += calTime\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847391,
                "title": "c-stack",
                "content": "```\\npublic int[] ExclusiveTime(int n, IList<string> logs) {\\n        Stack<int[]> stack = new Stack<int[]>();\\n        int[] res = new int[n];\\n        foreach(string log in logs)\\n        {\\n            int firstColon = log.IndexOf(\":\");\\n            int secondColon = log.IndexOf(\":\",firstColon+1);\\n            int id = Int32.Parse(log.Substring(0,firstColon));\\n            int time = Int32.Parse(log.Substring(secondColon+1));\\n            if(log[firstColon+1] == \\'s\\')\\n            {\\n                if(stack.Count>0)\\n                {\\n                    int[] f = stack.Peek();\\n                    res[f[0]] += time - f[1];\\n                }\\n                stack.Push(new int[]{id,time});\\n            }\\n            else\\n            {\\n                res[id] += time - stack.Pop()[1] + 1;\\n                if(stack.Count>0)\\n                {\\n                    int[] f = stack.Peek();\\n                    f[1] = time + 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\npublic int[] ExclusiveTime(int n, IList<string> logs) {\\n        Stack<int[]> stack = new Stack<int[]>();\\n        int[] res = new int[n];\\n        foreach(string log in logs)\\n        {\\n            int firstColon = log.IndexOf(\":\");\\n            int secondColon = log.IndexOf(\":\",firstColon+1);\\n            int id = Int32.Parse(log.Substring(0,firstColon));\\n            int time = Int32.Parse(log.Substring(secondColon+1));\\n            if(log[firstColon+1] == \\'s\\')\\n            {\\n                if(stack.Count>0)\\n                {\\n                    int[] f = stack.Peek();\\n                    res[f[0]] += time - f[1];\\n                }\\n                stack.Push(new int[]{id,time});\\n            }\\n            else\\n            {\\n                res[id] += time - stack.Pop()[1] + 1;\\n                if(stack.Count>0)\\n                {\\n                    int[] f = stack.Peek();\\n                    f[1] = time + 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820971,
                "title": "swift-stack",
                "content": "```\\nenum Operation: String {\\n    case start\\n    case end\\n}\\n\\nstruct Process {\\n    let id: Int\\n    let op: Operation\\n    var time: Int\\n}\\n\\nclass Solution {\\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\\n        let processes = logs.map { convertToProcess($0) }\\n        \\n        return getExclusiveTime(processes, n)\\n    }\\n    \\n    private func getExclusiveTime(_ processes: [Process], _ n: Int) -> [Int] {\\n        var total = [Int](repeating: 0, count: n)\\n        var stack: [(process: Process, totalTime: Int)] = [(processes[0], 0)]\\n        var current = processes[0]\\n        \\n        for newProcess in processes[1...] {\\n            if newProcess.op == .start {\\n                stack.append((current, newProcess.time))\\n                total[current.id] += newProcess.time - current.time\\n                \\n                current = newProcess\\n            } else {\\n                let diffTime = newProcess.time - current.time + 1\\n                total[current.id] += diffTime\\n                \\n                if let last = stack.popLast() {\\n                    current = last.process\\n                    current.time = newProcess.time + 1\\n                } else {\\n                    break\\n                }\\n            }\\n            \\n        }\\n        \\n        return total\\n    }\\n    \\n    private func convertToProcess(_ string: String) -> Process {\\n        let array = string.components(separatedBy: \":\")\\n        \\n        return Process(id: Int(array[0])!, op: Operation(rawValue: array[1])!, time: Int(array[2])!)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nenum Operation: String {\\n    case start\\n    case end\\n}\\n\\nstruct Process {\\n    let id: Int\\n    let op: Operation\\n    var time: Int\\n}\\n\\nclass Solution {\\n    func exclusiveTime(_ n: Int, _ logs: [String]) -> [Int] {\\n        let processes = logs.map { convertToProcess($0) }\\n        \\n        return getExclusiveTime(processes, n)\\n    }\\n    \\n    private func getExclusiveTime(_ processes: [Process], _ n: Int) -> [Int] {\\n        var total = [Int](repeating: 0, count: n)\\n        var stack: [(process: Process, totalTime: Int)] = [(processes[0], 0)]\\n        var current = processes[0]\\n        \\n        for newProcess in processes[1...] {\\n            if newProcess.op == .start {\\n                stack.append((current, newProcess.time))\\n                total[current.id] += newProcess.time - current.time\\n                \\n                current = newProcess\\n            } else {\\n                let diffTime = newProcess.time - current.time + 1\\n                total[current.id] += diffTime\\n                \\n                if let last = stack.popLast() {\\n                    current = last.process\\n                    current.time = newProcess.time + 1\\n                } else {\\n                    break\\n                }\\n            }\\n            \\n        }\\n        \\n        return total\\n    }\\n    \\n    private func convertToProcess(_ string: String) -> Process {\\n        let array = string.components(separatedBy: \":\")\\n        \\n        return Process(id: Int(array[0])!, op: Operation(rawValue: array[1])!, time: Int(array[2])!)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790610,
                "title": "super-concise-40-ms-c-solution",
                "content": "```\\nvector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> ans(n,0);\\n        string sid, type , duration;\\n        int id, currTime, prevTime;\\n        stack<int> stk;\\n        \\n        for(int i=0;i<logs.size();++i){\\n            stringstream ss(logs[i]);\\n            getline(ss,sid,\\':\\');getline(ss,type,\\':\\');getline(ss,duration,\\':\\');\\n            id = stoi(sid);\\n            currTime = stoi(duration);\\n            \\n            if(type==\"start\") {\\n                if(!stk.empty())\\n                    ans[stk.top()] += (currTime - prevTime);  \\n                stk.push(id);\\n                prevTime = currTime;\\n            } \\n            else if (type==\"end\") {\\n                ans[stk.top()] += (currTime+1-prevTime);\\n                stk.pop();\\n                prevTime=currTime+1;\\n            }\\n        }\\n        return ans;  \\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> exclusiveTime(int n, vector<string>& logs) {\\n        vector<int> ans(n,0);\\n        string sid, type , duration;\\n        int id, currTime, prevTime;\\n        stack<int> stk;\\n        \\n        for(int i=0;i<logs.size();++i){\\n            stringstream ss(logs[i]);\\n            getline(ss,sid,\\':\\');getline(ss,type,\\':\\');getline(ss,duration,\\':\\');\\n            id = stoi(sid);\\n            currTime = stoi(duration);\\n            \\n            if(type==\"start\") {\\n                if(!stk.empty())\\n                    ans[stk.top()] += (currTime - prevTime);  \\n                stk.push(id);\\n                prevTime = currTime;\\n            } \\n            else if (type==\"end\") {\\n                ans[stk.top()] += (currTime+1-prevTime);\\n                stk.pop();\\n                prevTime=currTime+1;\\n            }\\n        }\\n        return ans;  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 776745,
                "title": "is-this-a-valid-test-case-if-not-why",
                "content": "Is this a valid test case?\\n\\n```\\n3\\n[\"0:start:0\",\"1:start:1\",\"2:start:2\",\"1:end:3\",\"0:end:4\",\"2:end:5\"]\\n```\\n\\nIf not, which sentence in the question does this test case violate with?",
                "solutionTags": [],
                "code": "```\\n3\\n[\"0:start:0\",\"1:start:1\",\"2:start:2\",\"1:end:3\",\"0:end:4\",\"2:end:5\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772943,
                "title": "simple-python-solution",
                "content": "Stack was the first thing that jumped to my mind because we need to \\n1) keep track of the order of functions being executed\\n2) start and end pairs are symmetrical\\n\\nThe tricky part is that we also need to subtract time taken by functions executed between the start and end times of the current function. So instead of just a start log entry, we can append a [log, time taken by other functions in between start and end] pair to the stack. Whenever a function finishes, we increment stack[-1][1] to account for the time taken by the function.\\n\\nTime complexity is O(N) as we iterate through the logs once. Space complexity is O(N) as we may have N/2 logs in the stack in the worst case. \\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        counts = [0] * n\\n        stack = []\\n        \\n        for log in logs:\\n            curr = log.split(\\':\\')\\n            if curr[1] == \\'start\\':\\n                stack.append([curr, 0])\\n            if curr[1] == \\'end\\':\\n                prev, taken = stack.pop()\\n                time = int(curr[2]) - int(prev[2]) + 1\\n                counts[int(curr[0])] += time - taken\\n                if stack:\\n                    stack[-1][1] += time\\n        \\n        return counts\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        counts = [0] * n\\n        stack = []\\n        \\n        for log in logs:\\n            curr = log.split(\\':\\')\\n            if curr[1] == \\'start\\':\\n                stack.append([curr, 0])\\n            if curr[1] == \\'end\\':\\n                prev, taken = stack.pop()\\n                time = int(curr[2]) - int(prev[2]) + 1\\n                counts[int(curr[0])] += time - taken\\n                if stack:\\n                    stack[-1][1] += time\\n        \\n        return counts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716817,
                "title": "short-commented-python-ac-solution-using-stack",
                "content": "Hello Leetcoders,\\n\\nPlease find below my commented code.\\n\\nCheers,\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\t\\t\\n\\t\\t# q: stack which will contain all background tasks\\n        q = []\\n        \\n\\t\\t# res: result array contains the exclusive time values\\n\\t\\tres = [0] * n\\n        \\n\\t\\t# Iterate through the given logs\\n        for data in logs:\\n\\t\\t\\t# Split log in 3 items [function_id, start|end, timestamp]\\n            ids, tag, t = data.split(\\':\\')\\n            \\n\\t\\t\\t# if it\\'s the start of a task; toss it inside your stack \\n            if tag == \\'start\\':\\n                q.append((ids, tag, int(t)))\\n            \\n\\t\\t\\t# If it\\'s the end; compute the diff.\\n\\t\\t\\t# Be careful, the formula is: diff = end_time + 1 - start_time\\n\\t\\t\\t# example: end = 6 --> means that the task ends after 6 == ends before 7\\n\\t\\t\\t\\n            if tag == \\'end\\':\\n                cur = int(ids)\\n                diff = int(t) + 1 - q.pop()[2]\\n                \\n\\t\\t\\t\\t# If there is any background tasks; deduct from the next task in line the time you\\'ve just computed. \\n                if q:\\n                    res[int(q[-1][0])] -= diff\\n                \\n\\t\\t\\t\\t# Update current exclusive time value.\\n                res[cur] += diff\\n                    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\t\\t\\n\\t\\t# q: stack which will contain all background tasks\\n        q = []\\n        \\n\\t\\t# res: result array contains the exclusive time values\\n\\t\\tres = [0] * n\\n        \\n\\t\\t# Iterate through the given logs\\n        for data in logs:\\n\\t\\t\\t# Split log in 3 items [function_id, start|end, timestamp]\\n            ids, tag, t = data.split(\\':\\')\\n            \\n\\t\\t\\t# if it\\'s the start of a task; toss it inside your stack \\n            if tag == \\'start\\':\\n                q.append((ids, tag, int(t)))\\n            \\n\\t\\t\\t# If it\\'s the end; compute the diff.\\n\\t\\t\\t# Be careful, the formula is: diff = end_time + 1 - start_time\\n\\t\\t\\t# example: end = 6 --> means that the task ends after 6 == ends before 7\\n\\t\\t\\t\\n            if tag == \\'end\\':\\n                cur = int(ids)\\n                diff = int(t) + 1 - q.pop()[2]\\n                \\n\\t\\t\\t\\t# If there is any background tasks; deduct from the next task in line the time you\\'ve just computed. \\n                if q:\\n                    res[int(q[-1][0])] -= diff\\n                \\n\\t\\t\\t\\t# Update current exclusive time value.\\n                res[cur] += diff\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685930,
                "title": "resolved-why-the-hell-this-test-case",
                "content": "```\\n8\\n[\"0:start:0\",\"1:start:5\",\"2:start:6\",\"3:start:9\",\"4:start:11\",\"5:start:12\",\"6:start:14\",\"7:start:15\",\"1:start:24\",\"1:end:29\",\"7:end:34\",\"6:end:37\",\"5:end:39\",\"4:end:40\",\"3:end:45\",\"0:start:49\",\"0:end:54\",\"5:start:55\",\"5:end:59\",\"4:start:63\",\"4:end:66\",\"2:start:69\",\"2:end:70\",\"2:start:74\",\"6:start:78\",\"0:start:79\",\"0:end:80\",\"6:end:85\",\"1:start:89\",\"1:end:93\",\"2:end:96\",\"2:end:100\",\"1:end:102\",\"2:start:105\",\"2:end:109\",\"0:end:114\"]\\n```",
                "solutionTags": [],
                "code": "```\\n8\\n[\"0:start:0\",\"1:start:5\",\"2:start:6\",\"3:start:9\",\"4:start:11\",\"5:start:12\",\"6:start:14\",\"7:start:15\",\"1:start:24\",\"1:end:29\",\"7:end:34\",\"6:end:37\",\"5:end:39\",\"4:end:40\",\"3:end:45\",\"0:start:49\",\"0:end:54\",\"5:start:55\",\"5:end:59\",\"4:start:63\",\"4:end:66\",\"2:start:69\",\"2:end:70\",\"2:start:74\",\"6:start:78\",\"0:start:79\",\"0:end:80\",\"6:end:85\",\"1:start:89\",\"1:end:93\",\"2:end:96\",\"2:end:100\",\"1:end:102\",\"2:start:105\",\"2:end:109\",\"0:end:114\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683093,
                "title": "python-easy-to-understand-t-s-o-n-using-stack",
                "content": "Time: O(n)\\nSpace: O(n)\\nDS: Stack\\n\\nIdea: Keep track of child_time for each process entry.\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        # its assumed logs are already sorted\\n        \\n        results = [0 for _ in range(n)]\\n        \\n        stack = []\\n        for log in logs:\\n            p_id, event, timestamp = log.split(\":\")\\n            p_id = int(p_id)\\n            timestamp = int(timestamp)\\n            \\n            if event == \"start\":\\n                start_time = timestamp\\n                stack.append([p_id, start_time, 0]) # appending p_id for simplicity/debugging. we dont actually use it.\\n                \\n            else: # end\\n                \\n                end_time = timestamp + 1\\n                _, start_time, child_time = stack.pop()\\n                \\n                # calculate current p_id time, minus the child time\\n                p_id_time = end_time - start_time - child_time\\n                results[p_id] += p_id_time \\n                \\n                if stack:\\n                    # update child time for the top of the stack p_id\\n                    stack[-1][2] += end_time - start_time\\n                    \\n        return results\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        # its assumed logs are already sorted\\n        \\n        results = [0 for _ in range(n)]\\n        \\n        stack = []\\n        for log in logs:\\n            p_id, event, timestamp = log.split(\":\")\\n            p_id = int(p_id)\\n            timestamp = int(timestamp)\\n            \\n            if event == \"start\":\\n                start_time = timestamp\\n                stack.append([p_id, start_time, 0]) # appending p_id for simplicity/debugging. we dont actually use it.\\n                \\n            else: # end\\n                \\n                end_time = timestamp + 1\\n                _, start_time, child_time = stack.pop()\\n                \\n                # calculate current p_id time, minus the child time\\n                p_id_time = end_time - start_time - child_time\\n                results[p_id] += p_id_time \\n                \\n                if stack:\\n                    # update child time for the top of the stack p_id\\n                    stack[-1][2] += end_time - start_time\\n                    \\n        return results\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 650413,
                "title": "poorly-described-problem",
                "content": "\\n2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nI dont understand how the ans would be [8, 1]. My algorithm is giving output as [7,1].\\nDo I need to implicitely consider - \"0:start 6?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 643017,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        total = [0 for i in range(n)]\\n        s = []\\n        i = 0\\n        curTime = 0\\n        while( i < len(logs)):\\n            curLog = logs[i].split(\":\")\\n            curId = int(curLog[0])\\n            status = curLog[1]\\n            nextTime = int(curLog[2])\\n            if (status ==  \"start\"):\\n                if (s):\\n                    total[s[-1]]+= nextTime - curTime\\n                s.append(curId)\\n                curTime = nextTime\\n            else:\\n                total[s[-1]]+= nextTime - curTime + 1\\n                s.pop()\\n                curTime = nextTime + 1\\n            i+=1\\n        return total\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n        \\n        total = [0 for i in range(n)]\\n        s = []\\n        i = 0\\n        curTime = 0\\n        while( i < len(logs)):\\n            curLog = logs[i].split(\":\")\\n            curId = int(curLog[0])\\n            status = curLog[1]\\n            nextTime = int(curLog[2])\\n            if (status ==  \"start\"):\\n                if (s):\\n                    total[s[-1]]+= nextTime - curTime\\n                s.append(curId)\\n                curTime = nextTime\\n            else:\\n                total[s[-1]]+= nextTime - curTime + 1\\n                s.pop()\\n                curTime = nextTime + 1\\n            i+=1\\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625810,
                "title": "aaa",
                "content": "O(N) Time \\nO(N) Space\\n\\n```\\nvar exclusiveTime = function(n, logs) {\\n  const result = new Array(n).fill(0); // \\n  const stack = []; \\n  let prevTime; \\n  logs.forEach(log => {//  [\\'0:start:0\\', \\'1:start:2\\', \\'1:end:5\\', \\'0:end:6\\']));\\n    const details = log.split(\\':\\'); // [ \\'0\\', \\'start\\', \\'0\\' ]\\n    const id = parseInt(details[0]);\\n    const point = details[1];\\n    const time = parseInt(details[2]);\\n    if (point === \\'start\\') {\\n      // If the stack is not empty, we need to increment the sum\\n      // of the previous function from previous start time to now\\n      if (stack.length > 0) {\\n        let prevFn = stack[stack.length - 1]; \\n        result[prevFn] += time - prevTime;  \\n      }\\n      stack.push(id); // Push this function onto the stack\\n      prevTime = time; // Set the previous start time to the time now\\n    } else { // point === \\'end\\'\\n      const last = stack.pop(); // Get the last function to start from the top of the stack \\n      result[last] += time - prevTime + 1; // Increment the sum from start to end, inclusive \\n      prevTime = time + 1; // Set the previous start time to be one after this function ended \\n    }\\n  });\\n  return result;\\n};\\n\\nconsole.log(exclusiveTime(2, [\\'0:start:0\\', \\'1:start:2\\', \\'1:end:5\\', \\'0:end:6\\']));\\n\\n/*\\n0Start----- 1Start----------- 1End   0End \\n[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] \\nTime Slots\\n*/\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar exclusiveTime = function(n, logs) {\\n  const result = new Array(n).fill(0); // \\n  const stack = []; \\n  let prevTime; \\n  logs.forEach(log => {//  [\\'0:start:0\\', \\'1:start:2\\', \\'1:end:5\\', \\'0:end:6\\']));\\n    const details = log.split(\\':\\'); // [ \\'0\\', \\'start\\', \\'0\\' ]\\n    const id = parseInt(details[0]);\\n    const point = details[1];\\n    const time = parseInt(details[2]);\\n    if (point === \\'start\\') {\\n      // If the stack is not empty, we need to increment the sum\\n      // of the previous function from previous start time to now\\n      if (stack.length > 0) {\\n        let prevFn = stack[stack.length - 1]; \\n        result[prevFn] += time - prevTime;  \\n      }\\n      stack.push(id); // Push this function onto the stack\\n      prevTime = time; // Set the previous start time to the time now\\n    } else { // point === \\'end\\'\\n      const last = stack.pop(); // Get the last function to start from the top of the stack \\n      result[last] += time - prevTime + 1; // Increment the sum from start to end, inclusive \\n      prevTime = time + 1; // Set the previous start time to be one after this function ended \\n    }\\n  });\\n  return result;\\n};\\n\\nconsole.log(exclusiveTime(2, [\\'0:start:0\\', \\'1:start:2\\', \\'1:end:5\\', \\'0:end:6\\']));\\n\\n/*\\n0Start----- 1Start----------- 1End   0End \\n[ 0 ] [ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ] \\nTime Slots\\n*/\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 606110,
                "title": "concise-c-stack-solution-beats-100-memory-space",
                "content": "public class Solution {\\n    public int[] ExclusiveTime(int n, IList<string> logs) {\\n        int[] res = new int[n];\\n        var stk = new Stack<int>();\\n\\n        int i = 0;\\n        int prev = 0;\\n        while( i < logs.Count){\\n            string[] s = logs[i].Split( new char[]{ \\':\\'});\\n            int id = Int32.Parse(s[0]);\\n            int time = Int32.Parse(s[2]);\\n            if( s[1] == \"start\"){\\n                if( stk.Count > 0) res[stk.Peek()] += time - prev;\\n                stk.Push( id );\\n                prev = time;\\n            }\\n            else{\\n                res[stk.Pop()] += (time + 1) - prev;               \\n                prev = time + 1;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] ExclusiveTime(int n, IList<string> logs) {\\n        int[] res = new int[n];\\n        var stk = new Stack<int>();\\n\\n        int i = 0;\\n        int prev = 0;\\n        while( i < logs.Count){\\n            string[] s = logs[i].Split( new char[]{ \\':\\'}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564815,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1567514,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1568034,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1568143,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1718723,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1572685,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1572648,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1572594,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1816238,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1800349,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1564815,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1567514,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1568034,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1568143,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1718723,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1572685,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1572648,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1572594,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1816238,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1800349,
                "content": [
                    {
                        "username": "sha256pki",
                        "content": "0----1----2----3----4----5----6\\n|----|----|----|----|----|----|----|\\n\\nfun0 - 0 to 1, 1 to 2            - 2 time units\\nfun1 - 2 to 3, 3 to 4, 4 to 5 - 3 time units \\nfun0 - 5 to 6                       - 1 time units\\n\\nWondering how fun1 took 4 time units?\\n\\n\\nUpdate - \\n\\nfigured it, instead of seeing x as clock strike (or coordinate on line), see x as an item\\n\\n[0][1][2][3][4][5][6]\\n\\nNow it makes sense, \\nfun0 - took first 2 boxes\\nfun1 - took next 4 boxes\\nfun0 - took last 1 box"
                    },
                    {
                        "username": "semi_martingale",
                        "content": "I thought CPU would handle tasks by priority, not strictly **LIFO**. Below test case, which I think is valid, bombed with assertion error. Can we make a safe assumption to use **Stack**? Did I miss anything from the problem description?\\n\\n3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"2:end:4\",\"0:end:5\",\"1:end:6\"]"
                    },
                    {
                        "username": "seekerwu",
                        "content": "2\\n[\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:7\",\"1:end:7\",\"0:end:8\"]\\n\\nHow can the same process start itself before it ends? Or is still running after it ended?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "This is recursion... Program 0 is started at time 0, then at time 2, **program 0 calls itself** hence another program 0 started at 2. Program started at 0 and started at 2 are both program 0, but different instances."
                    },
                    {
                        "username": "realq86",
                        "content": "Why is a test case with 2 extra ends for a thread valid?"
                    },
                    {
                        "username": "gziz",
                        "content": "Why do people dislike this problem?"
                    },
                    {
                        "username": "dibugger",
                        "content": "3\\n[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]"
                    },
                    {
                        "username": "karthikveeramani",
                        "content": "I see that most people use stack for this problem. Assumption seems to be that if task 0 starts, task 1 starts,  task 1 would end first before 0 ends. That fits the stack model, as when you pop, you are assuming that the top of the stack is the one that\\'s ending. Where is this assumption mentioned? Am I misreading the question?"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because problem specifically stated \\n\\n> Function calls are stored in a call stack"
                    },
                    {
                        "username": "sunny60",
                        "content": "[\"0:start:0\",\"1:start:2\",\"2:start:3\",\"1:end:5\",\"2:end:6\",\"0:end:7\"]![image](https://assets.leetcode.com/users/sunny60/image_1554611175.png)\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just use stack when end comes pop the top element and store their diff and put the current timestamp + 1 value in next top if present.\\n[\"0:start:0\",\"1:start:2\"]\\nnow for [1, end, 5] pop the top which is[1, start, 2] take res[1] = 5 - 2 + 1 and change value of prev timestamp [0, start, 5 + 1] now for [0, end, 6] repeat the following.\\nNote for each start added take their diff and store it in res of prev id for ex when [1, start, 2] is added res[0] = 2 - stack.peek()[2] is added."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n    void convert(string str,int &id,string &operation,int &time){\\n            int j = 0;\\n            id = time = 0;\\n            while(str[j]!=\\':\\'){\\n                id = id*10 + str[j]-\\'0\\';\\n                j++;\\n            } j++;\\n            while(str[j]!=\\':\\'){\\n                operation.push_back(str[j]);\\n                j++;\\n            } j++;\\n            while(j<str.length()){\\n                time = time*10 + str[j]-\\'0\\';\\n                j++;\\n            }  \\n            if(operation == \"end\") time++;\\n}\\n\\nvector<int> exclusiveTime(int n, vector<string>& logs){\\n      vector<int> duration(n,0);\\n      stack<int>st;\\n      int prev_op_time;\\n      for(int i=0;i<logs.size();i++){\\n          int id,time; string operation;\\n          convert(logs[i],id,operation,time);\\n          if(!st.empty()){\\n              int fn_id = st.top();\\n              duration[fn_id] += (time - prev_op_time);\\n          }\\n          prev_op_time = time;\\n\\n          if(operation == \"start\"){\\n              st.push(id);\\n          }\\n          else st.pop();\\n      }\\n      return duration;\\n}\\n};"
                    }
                ]
            }
        ]
    }
]