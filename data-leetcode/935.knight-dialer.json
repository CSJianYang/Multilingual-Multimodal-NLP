[
    {
        "title": "Knight Dialer",
        "question_content": "The chess knight has a unique movement,&nbsp;it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\nA chess knight can move as indicated in the chess diagram below:\nWe have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell&nbsp;(i.e. blue cell).\nGiven an integer n, return how many distinct phone numbers of length n we can dial.\nYou are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\nAs the answer may be very large, return the answer modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: 10\nExplanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\nExample 2:\n\nInput: n = 2\nOutput: 20\nExplanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n\nExample 3:\n\nInput: n = 3131\nOutput: 136006598\nExplanation: Please take care of the mod.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 5000",
        "solutions": [
            {
                "id": 190787,
                "title": "how-to-solve-this-problem-explained-for-noobs",
                "content": "We can think of this problem as the total number of unique paths the knight can travel making n hops because to dial distinct numbers, the path taken by the knight must be unique.\\n\\nIn this post I want to explain how I came up with a solution to this problem. This approach can be used to solve other similar problems such as Unique Paths, Minimum Path Sum etc.\\n\\nImagine an 8 x 8 chess board with Knight (k) sitting at some index `(i, j)`. The board would look as follows,\\n\\n```\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\n```\\n\\n\\n**[0]** If k is at index `(i, j)`, then in a single hop, k can move to 8 possible positions which are below. \\n\\n\\n```\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n```\\n\\n**[1]** Conversely, you can also say that in a single hop, there are 8 possible places (a,b,c,d,e,f,g,h) from which you can move to k.\\n\\n**Math behind the solution:**\\n\\nConsider a function paths(i, j, n) which calculates the total number of unique paths to reach index (i, j) for a given n, where n is the number of hops. From [0] or [1], we can recusively define paths(i, j, n) for all non-trivial (n > 1, that is, more than one hop) cases as follows,\\n\\n```\\npaths(i, j, n) = paths(i - 1, j - 2, n - 1) + \\n                 paths (i - 2, j - 1, n - 1) +\\n                 paths (i - 2, j + 1, n - 1) +\\n                 paths (i - 1, j + 2, n - 1) +\\n                 paths (i + 1, j + 2, n - 1) +\\n                 paths  (i + 2, j + 1, n - 1) +\\n                 paths (i + 2, j - 1, n - 1) +\\n                 paths (i + 1, j - 2, n - 1)\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nIf we translate this to plain english, all we are saying is \"the total number of unique paths to (i, j) for certain hops n is equal to the sum of total number of unique paths to each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nIf you are confused why it is n - 1 hops, note that when we are at (i, j), we already made one hop and we have n - 1 hops more to take.\\n\\nFor the trivial case (n = 1, that is no hops), the problem states that this must be considered as one path. Therefore, paths(i, j, n) = 1, for n = 1.\\n\\n**A Sample Trace**\\n\\nIf the above recursive equation or it\\'s translation is not very enlightening, you can follow this sample trace to get a better understanding of the logic.\\n\\nOur keypad is a 4 x 3 matrix which looks like below.\\n\\n```\\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\n```\\n\\nNote that in the code there is no need to use a matrix like this. This is just for explanation purpose.\\n\\nWe shall trace the recursion tree of paths(0, 0, 3) in this section, that is, all the possible unique paths from 1 (0, 0) in 3 hops. From 1 (0, 0), in a single hop, we have two possible places to jump to - 6 and 8.\\n\\nWait! Didn\\'t I say that a knight can jump to 8 possible places in a single hop some where in this post?\\n\\n*...\"in a single hop, k can move to 8 possible positions\"...*\\n\\nYes, a knight can jump to 8 possible places in a single hop and this is still true. However, 6 of the other hops will take you outside of the matrix. You will see later in the code how this is being handled as a part of base case.\\n\\n*A brief on notation*: \\n\\nI am representing each node in the recursion tree something like X (i, j, n). This means that we are at the call paths(0, 0, 3) and the knight is currently sitting on the number X with n - 1 hops remaining.\\n\\nBelow is the recursion tree for paths(0, 0, 3).\\n\\nNote: The following tree diagram is not visually appealing with the old UI. I recommend to view this in the new UI for a proper visual representation.\\n\\n                                  1 (0,0,3)\\n\\t\\t\\t\\t               /\\t\\t     \\\\\\n\\t\\t\\t\\t\\t          /               \\\\\\n\\t\\t\\t\\t  \\t  6 (1,2,2)             8 (2,1,2)\\t\\n\\t\\t\\t\\t   \\t/   |    \\\\                |   \\t\\\\\\n\\t\\t\\t\\t   /\\t|\\t  \\\\\\t\\t          |  \\t \\\\\\n\\t\\t1 (0,0,1)  0 (3,1,1)  7 (2,0,1)   1 (0,0,1)  3 (0,2,1)\\n\\n\\nSince, 6 jumps are invalid, that leaves us with only two valid jumps `e (i + 1, j + 2)` and  `f  (i + 2, j + 1)` from 1 (0, 0). In other words, from 1 the knight can jump only to 8 and 6. \\n\\nIn fact, in this matrix, the maximum number of valid jumps you can make is 3 which is from 4, 6.\\n\\nExplanation of this recursion tree is below,\\n\\nFrom 1 (0, 0, 3), the knight can go to 6 (1, 2, 2) and 8 (2, 1, 2) in a single hop. As we go down the recursion tree, we pass the number of hops to make as 1 less than the current.\\n\\nFrom 6 (1, 2, 2), it can go to 1 (0, 0, 1) , 0 (3, 1, 1) and 7 (2, 0, 1). We pass n as 1 as we are going down in the recursion. At this point, each of these calls return 1 (since n = 1 which is the trivial case). \\n\\nTherefore, **[2]** 6 (1, 2, 2) = 1 + 1 + 1 = 3, which means that there are 3 unique paths from 6 when n = 2 and they are 61, 60, 67.\\n\\nFrom 8 (2,1,2), it can go to 1 (0, 0, 1) and 3 (0, 2, 1). At this point, each of these calls return 1 (since n = 1).\\n\\nTherefore, **[3]** 8 (2, 1, 2) = 1 + 1 = 2, which means that there are 2 unique paths from 8 when n = 2 and they are 81, 83.\\n\\nFinally, 1 (0, 0, 3) = 6 (1, 2, 2) + 8 (2, 1, 2)\\n\\nFrom [2], [3], we can write this as,\\n\\n1 (0, 0, 3) = 3 + 2 = 5, which means that there are 5 unique paths from 1 when n = 3 and they are 161, 160, 167, 181, 183.\\n\\n**Naive Recursive Code**\\n```\\n\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   //trivial case\\n   if(n == 1) return 1;\\n   //non trivial case\\n   long s = paths(i - 1, j - 2, n - 1) % max + // jump to a\\n            paths(i - 2, j - 1, n - 1) % max + // jump to b\\n            paths(i - 2, j + 1, n - 1) % max + // jump to c\\n            paths(i - 1, j + 2, n - 1) % max + // jump to d\\n            paths(i + 1, j + 2, n - 1) % max + // jump to e\\n            paths(i + 2, j + 1, n - 1) % max + // jump to f\\n            paths(i + 2, j - 1, n - 1) % max + // jump to g\\n            paths(i + 1, j - 2, n - 1) % max; // jump to h\\n   return s;\\n}\\n```\\n\\nIf you run this code for n = 50 in your favorite programming language, you will realize that it takes at least an hour to get the answer. \\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems. What does this mean? Let me explain with an example.\\n\\nAs seen in the above trace, a subproblem of 1 (0, 0, 3) is 8 (2, 1, 2). \\n\\nA subproblem of 3 (0, 2, 3) is also 8 (2, 1, 2) because you can get from 3 to 8 in a single hop.\\n\\nWe have already computed the solution to 8 (2, 1, 2) while computing the solution to 1 (0, 0, 3) and there is no need to re-compute this solution if were to store the solution somewhere in memory. The above recursive solution re-computes the solutions to overlapping subproblems and therefore is highly inefficient (runs in the order of O(3 ^ n) I believe).\\n\\n**Top down Dynamic programming solution**\\n\\nWe use dynamic programming and store the solution of each subproblem in M. M is a 3D array and each index of M corresponds to a solution of n. Each n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\nBelow is the code.\\n\\n```\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   // A 3D array to store the solutions to the subproblems\\n   long M[][][] = new long[n + 1][4][3];\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(M, i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(long[][][] M, int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   if(n == 1) return 1;\\n   //if the subproblem\\'s solution is already computed, then return it\\n   if(M[n][i][j] > 0) return M[n][i][j];\\n   //else compute the subproblem\\'s solution and save it in memory\\n   M[n][i][j] = paths(M, i - 1, j - 2, n - 1) % max + // jump to a\\n                paths(M, i - 2, j - 1, n - 1) % max + // jump to b\\n                paths(M, i - 2, j + 1, n - 1) % max + // jump to c\\n                paths(M, i - 1, j + 2, n - 1) % max + // jump to d\\n                paths(M, i + 1, j + 2, n - 1) % max + // jump to e\\n                paths(M, i + 2, j + 1, n - 1) % max + // jump to f\\n                paths(M, i + 2, j - 1, n - 1) % max + // jump to g\\n                paths(M, i + 1, j - 2, n - 1) % max; // jump to h\\n   return M[n][i][j];\\n}\\n```\\n\\nAny questions or feedback is welcome!\\n\\n**P.S: The wysiwyg editor of leetcode sucks! :P**\\n",
                "solutionTags": [],
                "code": "```\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\n```\n```\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n```\n```\\npaths(i, j, n) = paths(i - 1, j - 2, n - 1) + \\n                 paths (i - 2, j - 1, n - 1) +\\n                 paths (i - 2, j + 1, n - 1) +\\n                 paths (i - 1, j + 2, n - 1) +\\n                 paths (i + 1, j + 2, n - 1) +\\n                 paths  (i + 2, j + 1, n - 1) +\\n                 paths (i + 2, j - 1, n - 1) +\\n                 paths (i + 1, j - 2, n - 1)\\n```\n```\\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\n```\n```\\n\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   //trivial case\\n   if(n == 1) return 1;\\n   //non trivial case\\n   long s = paths(i - 1, j - 2, n - 1) % max + // jump to a\\n            paths(i - 2, j - 1, n - 1) % max + // jump to b\\n            paths(i - 2, j + 1, n - 1) % max + // jump to c\\n            paths(i - 1, j + 2, n - 1) % max + // jump to d\\n            paths(i + 1, j + 2, n - 1) % max + // jump to e\\n            paths(i + 2, j + 1, n - 1) % max + // jump to f\\n            paths(i + 2, j - 1, n - 1) % max + // jump to g\\n            paths(i + 1, j - 2, n - 1) % max; // jump to h\\n   return s;\\n}\\n```\n```\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   // A 3D array to store the solutions to the subproblems\\n   long M[][][] = new long[n + 1][4][3];\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(M, i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(long[][][] M, int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   if(n == 1) return 1;\\n   //if the subproblem\\'s solution is already computed, then return it\\n   if(M[n][i][j] > 0) return M[n][i][j];\\n   //else compute the subproblem\\'s solution and save it in memory\\n   M[n][i][j] = paths(M, i - 1, j - 2, n - 1) % max + // jump to a\\n                paths(M, i - 2, j - 1, n - 1) % max + // jump to b\\n                paths(M, i - 2, j + 1, n - 1) % max + // jump to c\\n                paths(M, i - 1, j + 2, n - 1) % max + // jump to d\\n                paths(M, i + 1, j + 2, n - 1) % max + // jump to e\\n                paths(M, i + 2, j + 1, n - 1) % max + // jump to f\\n                paths(M, i + 2, j - 1, n - 1) % max + // jump to g\\n                paths(M, i + 1, j - 2, n - 1) % max; // jump to h\\n   return M[n][i][j];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189252,
                "title": "o-logn",
                "content": "<img src=\"https://assets.leetcode.com/users/lee215/image_1541301837.png\" style=\"width:200px;\"/>\\n\\n**Naive recursion:**\\n`O(N)` time and `O(1)` space, good enough.\\n\\n```\\n    def knightDialer(self, N):\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(N - 1):\\n            x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = \\\\\\n                x6 + x8, x7 + x9, x4 + x8, \\\\\\n                x3 + x9 + x0, 0, x1 + x7 + x0, \\\\\\n                x2 + x6, x1 + x3, x2 + x4, \\\\\\n                x4 + x6\\n        return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0) % (10**9 + 7)\\n```\\n\\n\\nIn fact, we recursively did pow operation.\\nThis can be optimised to `O(log)` time.\\n\\nConstruct a 10 * 10 transformation matrix M.\\n`M[i][j] = 1` if i and j is connnected.\\n\\nif N = 1, return 10.\\nif N > 1, return sum of `[1,1,1,1,1,1,1,1,1,1] * M ^ (N - 1)`\\n\\nThe power of matrix reveals the number of walks in an undirected graph.\\nFind more details on this link provide by @shankark:\\nhttps://math.stackexchange.com/questions/1890620/finding-path-lengths-by-the-power-of-adjacency-matrix-of-an-undirected-graph\\n\\n\\n```\\n    def knightDialer(self, N):\\n        mod = 10**9 + 7\\n        if N == 1: return 10\\n        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\\n        res, N = 1, N - 1\\n        while N:\\n            if N % 2: res = res * M % mod\\n            M = M * M % mod\\n            N /= 2\\n        return int(np.sum(res)) % mod",
                "solutionTags": [],
                "code": "```\\n    def knightDialer(self, N):\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(N - 1):\\n            x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = \\\\\\n                x6 + x8, x7 + x9, x4 + x8, \\\\\\n                x3 + x9 + x0, 0, x1 + x7 + x0, \\\\\\n                x2 + x6, x1 + x3, x2 + x4, \\\\\\n                x4 + x6\\n        return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189287,
                "title": "o-n-time-o-1-space-dp-solution-google-interview-question-writeup",
                "content": "This is former Google interview question. It was leaked over a year ago and was soon after blacklisted. Because of this, a former Google interviewer decided to write an excellent blog post breaking down how he asked this question and what he expected from candidates who attempt it. This blog post explains the background of this question, common pitfalls candidates encounter, four different ways to solve it, and how a Google interviewer will evaluate your solution. This article is a gold mine for anyone considering interviewing at Google.\\nhttps://medium.com/@alexgolec/google-interview-questions-deconstructed-the-knights-dialer-f780d516f029\\n\\nAccording to the article, four possible solutions are (1) naive recursive number generation, (2) naive recursive counting, (3) recursion + memoization, and (4) dynamic programming. A candidate who coded either the memoization or DP solution is likely to receive a \"strong hire\" recommendation.\\n\\nI encourage everyone to check out the article. If you\\'re just here for the solution, below is an accepted leetcode solution based on the ideas from the article.\\n```\\ndef knightDialer(self, N):\\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\\n    neighbors = {\\n        0:(4,6),\\n        1:(6,8),\\n        2:(7,9),\\n        3:(4,8),\\n        4:(0,3,9),\\n        5:(),\\n        6:(0,1,7),\\n        7:(2,6),\\n        8:(1,3),\\n        9:(2,4)\\n    }\\n    current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n    for _ in range(N-1):\\n        next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n        for src_key in range(10):\\n            for dst_key in neighbors[src_key]:\\n                next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\\n        current_counts = next_counts\\n    return sum(current_counts) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef knightDialer(self, N):\\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\\n    neighbors = {\\n        0:(4,6),\\n        1:(6,8),\\n        2:(7,9),\\n        3:(4,8),\\n        4:(0,3,9),\\n        5:(),\\n        6:(0,1,7),\\n        7:(2,6),\\n        8:(1,3),\\n        9:(2,4)\\n    }\\n    current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n    for _ in range(N-1):\\n        next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n        for src_key in range(10):\\n            for dst_key in neighbors[src_key]:\\n                next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\\n        current_counts = next_counts\\n    return sum(current_counts) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189271,
                "title": "java-top-down-memo-dp-o-n",
                "content": "The problem can be transformed into:\\nTraverse a directed graph (each node with a number as label and edges are defined by Knight\\'s moving rule)\\nStart from `0 to 9`\\nMove `N - 1` step\\nReturn `how many ways to reach the end`\\n\\nEasy to come up with a DFS solution to start traversal from 0 to 9\\nIn each recursion, move to one of the current node\\'s neighbors and the remain step becomes `N-1`\\nStop recursion when `N == 0`\\n\\n**Optimization:**\\nObserve the recursive problem. The variances are:\\n1. Current Node\\n2. Remain Steps\\n\\nTherefore, we can store these two variables as the memo to speed up DFS (then it\\'s a Top Down DP)\\n```\\n    public static final int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        int[][] graph = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        int cnt = 0;\\n        Integer[][] memo = new Integer[N+1][10];\\n        for (int i = 0; i <= 9; i++)\\n            cnt = (cnt + helper(N-1, i, graph, memo)) % MOD;\\n        return cnt;\\n    }\\n    private int helper(int N, int cur, int[][] graph, Integer[][] memo) {\\n        if (N == 0)\\n            return 1;\\n        if (memo[N][cur] != null)\\n            return memo[N][cur];\\n        int cnt = 0;\\n        for (int nei : graph[cur])\\n            cnt = (cnt + helper(N-1, nei, graph, memo)) % MOD;\\n        memo[N][cur] = cnt;\\n        return cnt;\\n    }\\n```\\n**Time Complexity:** `O(10*N) = O(N)` fill the memo\\n**Space Complexity:** `O(N)` depth of the recursion ",
                "solutionTags": [],
                "code": "```\\n    public static final int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        int[][] graph = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        int cnt = 0;\\n        Integer[][] memo = new Integer[N+1][10];\\n        for (int i = 0; i <= 9; i++)\\n            cnt = (cnt + helper(N-1, i, graph, memo)) % MOD;\\n        return cnt;\\n    }\\n    private int helper(int N, int cur, int[][] graph, Integer[][] memo) {\\n        if (N == 0)\\n            return 1;\\n        if (memo[N][cur] != null)\\n            return memo[N][cur];\\n        int cnt = 0;\\n        for (int nei : graph[cur])\\n            cnt = (cnt + helper(N-1, nei, graph, memo)) % MOD;\\n        memo[N][cur] = cnt;\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 655853,
                "title": "if-you-want-to-laugh-check-out-this-stupid-solution-guarantee-you-could-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tlong kMod=1e9+7;\\n\\t\\t\\tlong hop1=1; // number of ways to form a distinct number ending with key 1\\n\\t\\t\\tlong hop2=1;\\n\\t\\t\\tlong hop3=1;\\n\\t\\t\\tlong hop4=1;\\n\\t\\t\\tlong hop5=1;\\n\\t\\t\\tlong hop6=1;\\n\\t\\t\\tlong hop7=1;\\n\\t\\t\\tlong hop8=1;\\n\\t\\t\\tlong hop9=1;\\n\\t\\t\\tlong hop0=1;\\n\\n\\t\\t\\tif(N==1) return 10;\\n\\t\\t\\tfor(int i=2;i<=N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong old_1=hop1;\\n\\t\\t\\t\\tlong old_2=hop2;\\n\\t\\t\\t\\tlong old_3=hop3;\\n\\t\\t\\t\\tlong old_4=hop4;\\n\\t\\t\\t\\tlong old_5=hop5;\\n\\t\\t\\t\\tlong old_6=hop6;\\n\\t\\t\\t\\tlong old_7=hop7;\\n\\t\\t\\t\\tlong old_8=hop8;\\n\\t\\t\\t\\tlong old_9=hop9;\\n\\t\\t\\t\\tlong old_0=hop0;\\n\\n\\t\\t\\t\\thop1=(old_6+old_8)%kMod;\\n\\t\\t\\t\\thop2=(old_7+old_9)%kMod;\\n\\t\\t\\t\\thop3=(old_4+old_8)%kMod;\\n\\t\\t\\t\\thop4=(old_3+old_9+old_0)%kMod;\\n\\t\\t\\t\\thop5=0;\\n\\t\\t\\t\\thop6=(old_1+old_7+old_0)%kMod;\\n\\t\\t\\t\\thop7=(old_2+old_6)%kMod;\\n\\t\\t\\t\\thop8=(old_1+old_3)%kMod;\\n\\t\\t\\t\\thop9=(old_2+old_4)%kMod;\\n\\t\\t\\t\\thop0=(old_4+old_6)%kMod;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (hop1+hop2+hop3+hop4+hop6+hop7+hop8+hop9+hop0)%kMod;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tlong kMod=1e9+7;\\n\\t\\t\\tlong hop1=1; // number of ways to form a distinct number ending with key 1\\n\\t\\t\\tlong hop2=1;\\n\\t\\t\\tlong hop3=1;\\n\\t\\t\\tlong hop4=1;\\n\\t\\t\\tlong hop5=1;\\n\\t\\t\\tlong hop6=1;\\n\\t\\t\\tlong hop7=1;\\n\\t\\t\\tlong hop8=1;\\n\\t\\t\\tlong hop9=1;\\n\\t\\t\\tlong hop0=1;\\n\\n\\t\\t\\tif(N==1) return 10;\\n\\t\\t\\tfor(int i=2;i<=N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong old_1=hop1;\\n\\t\\t\\t\\tlong old_2=hop2;\\n\\t\\t\\t\\tlong old_3=hop3;\\n\\t\\t\\t\\tlong old_4=hop4;\\n\\t\\t\\t\\tlong old_5=hop5;\\n\\t\\t\\t\\tlong old_6=hop6;\\n\\t\\t\\t\\tlong old_7=hop7;\\n\\t\\t\\t\\tlong old_8=hop8;\\n\\t\\t\\t\\tlong old_9=hop9;\\n\\t\\t\\t\\tlong old_0=hop0;\\n\\n\\t\\t\\t\\thop1=(old_6+old_8)%kMod;\\n\\t\\t\\t\\thop2=(old_7+old_9)%kMod;\\n\\t\\t\\t\\thop3=(old_4+old_8)%kMod;\\n\\t\\t\\t\\thop4=(old_3+old_9+old_0)%kMod;\\n\\t\\t\\t\\thop5=0;\\n\\t\\t\\t\\thop6=(old_1+old_7+old_0)%kMod;\\n\\t\\t\\t\\thop7=(old_2+old_6)%kMod;\\n\\t\\t\\t\\thop8=(old_1+old_3)%kMod;\\n\\t\\t\\t\\thop9=(old_2+old_4)%kMod;\\n\\t\\t\\t\\thop0=(old_4+old_6)%kMod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 189251,
                "title": "c-5-lines-dp",
                "content": "The ```moves``` show the possible hoops from a given number. Each digit in ```dial[i]``` contains numbers that end with this digit. For each hoop, we add numbers from other digits that we can hop out from. For example, for digit 4 we add numbers from digits 3, 9 and 0:\\n```\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n1 | 1 | 1 -> 3 | 0 | 3 -> 6 | 0 | 6\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n  | 1 |        | 2 |        | 6 |\\n```\\n```\\nvector<vector<int>> ms = { {4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {4, 2}};\\nint knightDialer(int N) {\\n  vector<int> d1(10, 1), d2(10);\\n  for (; --N > 0; swap(d1, d2))\\n    for (auto i = 0; i < 10; ++i) \\n        d2[i] = accumulate(begin(ms[i]), end(ms[i]), 0, [&](int s, int i) {return (s + d1[i]) % 1000000007;});\\n  return accumulate(begin(d1), end(d1), 0, [](int s, int n) {return (s + n) % 1000000007;});\\n}\\n```",
                "solutionTags": [],
                "code": "```moves```\n```dial[i]```\n```\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n1 | 1 | 1 -> 3 | 0 | 3 -> 6 | 0 | 6\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n  | 1 |        | 2 |        | 6 |\\n```\n```\\nvector<vector<int>> ms = { {4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {4, 2}};\\nint knightDialer(int N) {\\n  vector<int> d1(10, 1), d2(10);\\n  for (; --N > 0; swap(d1, d2))\\n    for (auto i = 0; i < 10; ++i) \\n        d2[i] = accumulate(begin(ms[i]), end(ms[i]), 0, [&](int s, int i) {return (s + d1[i]) % 1000000007;});\\n  return accumulate(begin(d1), end(d1), 0, [](int s, int n) {return (s + n) % 1000000007;});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189322,
                "title": "java-dfs-with-memo",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int[][] map = new int[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        int[][] memo = new int[N + 1][10];\\n        for (int i = 1; i <= N; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        int result = 0;\\n        for (int i = 0; i < 10; i++) {\\n            result += helper(N, i, map, memo);\\n            result %= (int)1e9 + 7;\\n        }\\n        return result;\\n    }\\n    private int helper(int N, int start, int[][] map, int[][] memo) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n        if (memo[N][start] > -1) {\\n            return memo[N][start];\\n        }\\n        memo[N][start] = 0;\\n        for (int next : map[start]) {\\n            memo[N][start] += helper(N - 1, next, map, memo);\\n            memo[N][start] %= (int)1e9 + 7;\\n        }\\n        return memo[N][start];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int[][] map = new int[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        int[][] memo = new int[N + 1][10];\\n        for (int i = 1; i <= N; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        int result = 0;\\n        for (int i = 0; i < 10; i++) {\\n            result += helper(N, i, map, memo);\\n            result %= (int)1e9 + 7;\\n        }\\n        return result;\\n    }\\n    private int helper(int N, int start, int[][] map, int[][] memo) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n        if (memo[N][start] > -1) {\\n            return memo[N][start];\\n        }\\n        memo[N][start] = 0;\\n        for (int next : map[start]) {\\n            memo[N][start] += helper(N - 1, next, map, memo);\\n            memo[N][start] %= (int)1e9 + 7;\\n        }\\n        return memo[N][start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189265,
                "title": "concise-java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N){\\n        int[][] dirs = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[ N + 1][10];\\n        for(int j = 0; j < dp[0].length; j ++){\\n            dp[1][j] = 1;\\n        }\\n        int mod = (int)1e9 + 7;\\n        for(int i = 2; i < dp.length;i ++)\\n            for(int j = 0; j < dp[0].length; j ++){\\n\\t\\t\\t\\t\\t\\n                int[] dir = dirs[j]; \\t//Where j comes from\\n                for(int num : dir){\\n                    dp[i][j] += dp[i - 1][num]; \\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        int count = 0;\\n        for(int i = 0; i < dp[0].length; i ++){\\n            count += dp[N][i];\\n            count %= mod;\\n        }\\n       return count;\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N){\\n        int[][] dirs = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[ N + 1][10];\\n        for(int j = 0; j < dp[0].length; j ++){\\n            dp[1][j] = 1;\\n        }\\n        int mod = (int)1e9 + 7;\\n        for(int i = 2; i < dp.length;i ++)\\n            for(int j = 0; j < dp[0].length; j ++){\\n\\t\\t\\t\\t\\t\\n                int[] dir = dirs[j]; \\t//Where j comes from\\n                for(int num : dir){\\n                    dp[i][j] += dp[i - 1][num]; \\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        int count = 0;\\n        for(int i = 0; i < dp[0].length; i ++){\\n            count += dp[N][i];\\n            count %= mod;\\n        }\\n       return count;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824317,
                "title": "simple-c-solution-dp-92-time-efficient",
                "content": "**Think of it as for the current postion how many times we can fix it with 0,1...**\\nconsider -->if previous place is 0 then current place can be fixed with 4 and 6 so if v[0] is the count of 0 in previous place and tmp is for current postion then at current postion we will get 4 due to 0 as previous ,is v[0] times and similarly for current 6 due to previous 0 is v[0] times.\\n**so considering tmp as current and v as previous counts\\ntmp[x]=sum of all the previous values from which we can reach x;**\\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod=1000000007;\\n        if(n==1)return 10;\\n        vector<long long int>v(10,1);\\n        vector<long long int>tmp(10);\\n        v[5]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            tmp[0]=(v[4]+v[6])%mod;\\n            tmp[1]=(v[6]+v[8])%mod;\\n            tmp[2]=(v[7]+v[9])%mod;\\n            tmp[3]=(v[4]+v[8])%mod;\\n            tmp[4]=(v[0]+v[3]+v[9])%mod;\\n            tmp[6]=(v[0]+v[1]+v[7])%mod;\\n            tmp[7]=(v[2]+v[6])%mod;\\n            tmp[8]=(v[1]+v[3])%mod;\\n            tmp[9]=(v[2]+v[4])%mod;\\n            for(int i=0;i<10;i++)\\n                v[i]=tmp[i];\\n        }\\n        int sum=0;\\n        for(int i=0;i<10;i++)\\n            sum=(sum+v[i])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod=1000000007;\\n        if(n==1)return 10;\\n        vector<long long int>v(10,1);\\n        vector<long long int>tmp(10);\\n        v[5]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            tmp[0]=(v[4]+v[6])%mod;\\n            tmp[1]=(v[6]+v[8])%mod;\\n            tmp[2]=(v[7]+v[9])%mod;\\n            tmp[3]=(v[4]+v[8])%mod;\\n            tmp[4]=(v[0]+v[3]+v[9])%mod;\\n            tmp[6]=(v[0]+v[1]+v[7])%mod;\\n            tmp[7]=(v[2]+v[6])%mod;\\n            tmp[8]=(v[1]+v[3])%mod;\\n            tmp[9]=(v[2]+v[4])%mod;\\n            for(int i=0;i<10;i++)\\n                v[i]=tmp[i];\\n        }\\n        int sum=0;\\n        for(int i=0;i<10;i++)\\n            sum=(sum+v[i])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189273,
                "title": "9-line-python-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\" \\n        dct = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\\n        \\n        dp = [1] * 10\\n        for _ in range(N - 1):\\n            nxt = [0] * 10\\n            for i in range(10):\\n                for j in dct[i]:\\n                    nxt[j] += dp[i]\\n            dp = nxt\\n        \\n        return sum(dp) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\" \\n        dct = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\\n        \\n        dp = [1] * 10\\n        for _ in range(N - 1):\\n            nxt = [0] * 10\\n            for i in range(10):\\n                for j in dct[i]:\\n                    nxt[j] += dp[i]\\n            dp = nxt\\n        \\n        return sum(dp) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189229,
                "title": "concise-c-using-dp-with-explanation",
                "content": "**Explanation:**  The row of the DP vector represent the N number of hops.  The column of the DP vector represent\nthe numeric phone pad keys [0:9] ( zero to nine, inclusive ).  Then the DP formula is as follows:\n \n**Base case:** when N is 1, the knight will take zero hops from its current digit\n \n```dp[1][0:9] = 1```\n \n**Recursive case:** observe the overlapping subproblems and optimal substructure.  The current i-th hop for each keypad digit can be found from the previous i-th-minus-1 hop for each keypad digit which can reach the current keypad digit from a single hop.  Therefore calculate the current i-th hop for each keypad destination digit (dst) as the sum of all keypad source digits (src) i-th-minus-1 hop solutions.\n \n```dp[ i ][ dst ] = sum( dp[ i-1 ][ src ] )```\n\n**verbose DP solution #1:**  \n```\nusing VL = vector< long >;\nusing VVL = vector< VL >;\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        VVL dp( N+1, VL( 10, 1 ));\n        for( int i{ 2 };  i <= N;  ++i ){\n            dp[ i ][ 0 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 1 ] = (  dp[ i-1 ][ 6 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 2 ] = (  dp[ i-1 ][ 7 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 3 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 4 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 3 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 5 ] = (  0  );\n            dp[ i ][ 6 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 1 ] + dp[ i-1 ][ 7 ]  ) % MOD;\n            dp[ i ][ 7 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 8 ] = (  dp[ i-1 ][ 1 ] + dp[ i-1 ][ 3 ]  ) % MOD;\n            dp[ i ][ 9 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 4 ]  ) % MOD;\n        }\n        return accumulate( dp[ N ].begin(), dp[ N ].end(), 0L ) % MOD;\n    }\n};\n```\n\n**verbose DP solution #2:** same concept as above, but optimized for memory use as we only need to keep track of the previous i-th-minus-1 hop values ( i.e. use a \"sliding window\" of size 2 ).\n\n```\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        vector<long> cur( 10, 1 ), next( cur );\n        for( int i{ 2 };  i <= N;  ++i ){\n            next[ 0 ] = (  cur[ 4 ] + cur[ 6 ]  ) % MOD;\n            next[ 1 ] = (  cur[ 6 ] + cur[ 8 ]  ) % MOD;\n            next[ 2 ] = (  cur[ 7 ] + cur[ 9 ]  ) % MOD;\n            next[ 3 ] = (  cur[ 4 ] + cur[ 8 ]  ) % MOD;\n            next[ 4 ] = (  cur[ 0 ] + cur[ 3 ] + cur[ 9 ]  ) % MOD;\n            next[ 5 ] = (  0  );\n            next[ 6 ] = (  cur[ 0 ] + cur[ 1 ] + cur[ 7 ]  ) % MOD;\n            next[ 7 ] = (  cur[ 2 ] + cur[ 6 ]  ) % MOD;\n            next[ 8 ] = (  cur[ 1 ] + cur[ 3 ]  ) % MOD;\n            next[ 9 ] = (  cur[ 2 ] + cur[ 4 ]  ) % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**Concise DP solution #3:** same concepts as above, using \"hops\" to track the next hops from each current digit.  (The current digit's value is the index of the vector of vectors \"hops\".)\n\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{\n        { 4, 6 },  { 6, 8 },  { 7, 9 },  { 4, 8 },  { 0, 3, 9 },  { },  { 0, 1, 7 },  { 2, 6 },  { 1, 3 },  { 2, 4 }\n    };\npublic:\n    int knightDialer( int N ){\n        VL cur( 10, 1 );\n        for(  VL next( 10, 0 );  --N > 0;  next=VL( 10, 0 )  ){\n            for( int i=0;  i <= 9;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**More concise DP solution #4:** same concepts as above, just remove a handful of lines\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\npublic:\n    int knightDialer( int N, VL cur=VL( 10, 1 ) ){\n        for(  VL next( 10, 0 );  --N > 0;  cur.swap( next ), next=VL( 10, 0 )  )\n            for( int i=0;  i < 10;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**Recursive top-down DFS solution:** same concept as above, recursively top-down with memoization\n```\nstatic const int MOD = 1000000007;\nusing VI = vector< int >;\nusing VVI = vector< VI >;\nVVI memo=VVI( 5001, VI(10,1L) );\nclass Solution {\n    VVI hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\n    long go( int N, int digit, long result = 0L ){\n        if( N-1 == 0 || memo[ N ][ digit ] > 1L )\n            return memo[ N ][ digit ];\n        for( auto hop: hops[ digit ] )\n            result += go( N-1, hop ) % MOD;\n        return memo[ N ][ digit ] = result % MOD;\n    }\npublic:\n    int knightDialer( int N, long result=0L ){\n        for( int digit = 0;  digit < 10;  ++digit )\n            result += go( N, digit ) % MOD;\n        return static_cast<int>( result % MOD );\n    }\n};\n```",
                "solutionTags": [],
                "code": "```dp[1][0:9] = 1```\n```dp[ i ][ dst ] = sum( dp[ i-1 ][ src ] )```\n```\nusing VL = vector< long >;\nusing VVL = vector< VL >;\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        VVL dp( N+1, VL( 10, 1 ));\n        for( int i{ 2 };  i <= N;  ++i ){\n            dp[ i ][ 0 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 1 ] = (  dp[ i-1 ][ 6 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 2 ] = (  dp[ i-1 ][ 7 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 3 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 4 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 3 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 5 ] = (  0  );\n            dp[ i ][ 6 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 1 ] + dp[ i-1 ][ 7 ]  ) % MOD;\n            dp[ i ][ 7 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 8 ] = (  dp[ i-1 ][ 1 ] + dp[ i-1 ][ 3 ]  ) % MOD;\n            dp[ i ][ 9 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 4 ]  ) % MOD;\n        }\n        return accumulate( dp[ N ].begin(), dp[ N ].end(), 0L ) % MOD;\n    }\n};\n```\n```\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        vector<long> cur( 10, 1 ), next( cur );\n        for( int i{ 2 };  i <= N;  ++i ){\n            next[ 0 ] = (  cur[ 4 ] + cur[ 6 ]  ) % MOD;\n            next[ 1 ] = (  cur[ 6 ] + cur[ 8 ]  ) % MOD;\n            next[ 2 ] = (  cur[ 7 ] + cur[ 9 ]  ) % MOD;\n            next[ 3 ] = (  cur[ 4 ] + cur[ 8 ]  ) % MOD;\n            next[ 4 ] = (  cur[ 0 ] + cur[ 3 ] + cur[ 9 ]  ) % MOD;\n            next[ 5 ] = (  0  );\n            next[ 6 ] = (  cur[ 0 ] + cur[ 1 ] + cur[ 7 ]  ) % MOD;\n            next[ 7 ] = (  cur[ 2 ] + cur[ 6 ]  ) % MOD;\n            next[ 8 ] = (  cur[ 1 ] + cur[ 3 ]  ) % MOD;\n            next[ 9 ] = (  cur[ 2 ] + cur[ 4 ]  ) % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{\n        { 4, 6 },  { 6, 8 },  { 7, 9 },  { 4, 8 },  { 0, 3, 9 },  { },  { 0, 1, 7 },  { 2, 6 },  { 1, 3 },  { 2, 4 }\n    };\npublic:\n    int knightDialer( int N ){\n        VL cur( 10, 1 );\n        for(  VL next( 10, 0 );  --N > 0;  next=VL( 10, 0 )  ){\n            for( int i=0;  i <= 9;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\npublic:\n    int knightDialer( int N, VL cur=VL( 10, 1 ) ){\n        for(  VL next( 10, 0 );  --N > 0;  cur.swap( next ), next=VL( 10, 0 )  )\n            for( int i=0;  i < 10;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nstatic const int MOD = 1000000007;\nusing VI = vector< int >;\nusing VVI = vector< VI >;\nVVI memo=VVI( 5001, VI(10,1L) );\nclass Solution {\n    VVI hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\n    long go( int N, int digit, long result = 0L ){\n        if( N-1 == 0 || memo[ N ][ digit ] > 1L )\n            return memo[ N ][ digit ];\n        for( auto hop: hops[ digit ] )\n            result += go( N-1, hop ) % MOD;\n        return memo[ N ][ digit ] = result % MOD;\n    }\npublic:\n    int knightDialer( int N, long result=0L ){\n        for( int digit = 0;  digit < 10;  ++digit )\n            result += go( N, digit ) % MOD;\n        return static_cast<int>( result % MOD );\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 189230,
                "title": "java-straightforward-simulation-dp-whatever",
                "content": "I don\\'t want to call it dp, because I just simply simulate the process.\\n```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        if (N==1) return 10;\\n        long[] cur= new long[10];\\n        Arrays.fill(cur, 1);\\n        cur[5]=0;\\n        long res=0, M=(int)1e9+7;;\\n        while (N-->1){\\n            long[] next= Arrays.copyOf(cur, 10);\\n            next[0]=(cur[4]+cur[6])%M;\\n            next[1]=(cur[6]+cur[8])%M;\\n            next[2]=(cur[7]+cur[9])%M;\\n            next[3]=(cur[4]+cur[8])%M;\\n            next[4]=(cur[3]+cur[9]+cur[0])%M;\\n            next[6]=(cur[1]+cur[7]+cur[0])%M;\\n            next[7]=(cur[2]+cur[6])%M;\\n            next[8]=(cur[1]+cur[3])%M;\\n            next[9]=(cur[2]+cur[4])%M;\\n            cur=next;\\n        }\\n        for (long n: cur) res=(res+n)%M;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        if (N==1) return 10;\\n        long[] cur= new long[10];\\n        Arrays.fill(cur, 1);\\n        cur[5]=0;\\n        long res=0, M=(int)1e9+7;;\\n        while (N-->1){\\n            long[] next= Arrays.copyOf(cur, 10);\\n            next[0]=(cur[4]+cur[6])%M;\\n            next[1]=(cur[6]+cur[8])%M;\\n            next[2]=(cur[7]+cur[9])%M;\\n            next[3]=(cur[4]+cur[8])%M;\\n            next[4]=(cur[3]+cur[9]+cur[0])%M;\\n            next[6]=(cur[1]+cur[7]+cur[0])%M;\\n            next[7]=(cur[2]+cur[6])%M;\\n            next[8]=(cur[1]+cur[3])%M;\\n            next[9]=(cur[2]+cur[4])%M;\\n            cur=next;\\n        }\\n        for (long n: cur) res=(res+n)%M;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540675,
                "title": "c-simple-clean-and-concise-solution-with-detailed-explanation-o-n-tc-o-1-sc",
                "content": "**Idea:**\\nFirst, we set a map from each number to its neighbors to easily know where we can go, using a vector and its indices.\\nThe `count` vector keeps the number of phone numbers we can dial starting from each index.\\nWe initialize `count` with `1`s, because we can place the knight in any cell initially, and need no steps to make numbers with 1 digit.\\nNow, we loop `n` times.\\nEach time, we go through all the numbers - `0` to `9` - and try to continue another step from that number.\\nWe count the new ways in a temporary vector `curr_count` to keep track of the old and new counts.\\nAt the end, we sum up `count` to get the total numbers we can dial.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1) (All vectors have constant sizes)\\n\\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod = pow(10, 9) + 7;\\n        vector<vector<int>> v = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        \\n        vector<long> count(10, 1), curr_count(10, 0);\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            fill(curr_count.begin(), curr_count.end(), 0);\\n            \\n            for (int j = 0; j < 10; j++) {\\n                \\n                for (auto next : v[j]) {\\n                    curr_count[next] += count[j] % mod;\\n                }\\n                \\n            }\\n            \\n            count = curr_count;\\n        }\\n\\n        long total = 0;\\n        for (auto c : count) total += c % mod;\\n        return total % mod;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod = pow(10, 9) + 7;\\n        vector<vector<int>> v = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        \\n        vector<long> count(10, 1), curr_count(10, 0);\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            fill(curr_count.begin(), curr_count.end(), 0);\\n            \\n            for (int j = 0; j < 10; j++) {\\n                \\n                for (auto next : v[j]) {\\n                    curr_count[next] += count[j] % mod;\\n                }\\n                \\n            }\\n            \\n            count = curr_count;\\n        }\\n\\n        long total = 0;\\n        for (auto c : count) total += c % mod;\\n        return total % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469930,
                "title": "1-for-loop-4-ints-that-s-it",
                "content": "Python, 5 lines, 97% time efficient, 96% memory efficient, no DP. \\n\\nI came up with a pretty elegant solution by thinking about this problem in terms of board-states. Each square the knight can stand on has certain properties. I classified all the squares on the keypad into 5 types of board-states.\\n\\n- A\\n\\t- Squares: 0\\n\\t- Moves: B, B\\n- B\\n\\t- Squares: 4, 6\\n\\t- Moves: A, C, C\\n- C\\n\\t- Squares: 1, 3, 7, 9\\n\\t- Moves: B, D\\n- D\\n\\t- Squares: 2, 8\\n\\t- Moves: C, C\\n- E\\n\\t- Squares: 5\\n\\t- Moves: none\\n\\nTo translate these classifications: every time you arrive at a C-square, one B-square and one D-square are available for your next move. I counted how many of each of the board-states we started with, and wrote down the formulas for how many of each board-state would be created for the next round by our existing board-states. Here\\'s my code:\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        A, B, C, D = 1, 2, 4, 2\\n        if n == 1:\\n            return(A+B+C+D+1)\\n        for i in range(n-1):\\n            A, B, C, D = B, (2*A + C), (2*B + 2*D), C\\n        return((A+B+C+D) % (10**9 + 7)) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        A, B, C, D = 1, 2, 4, 2\\n        if n == 1:\\n            return(A+B+C+D+1)\\n        for i in range(n-1):\\n            A, B, C, D = B, (2*A + C), (2*B + 2*D), C\\n        return((A+B+C+D) % (10**9 + 7)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278584,
                "title": "easy-c-solution-3-approaches",
                "content": "# Approach 1 : Recursion - TLE\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    int func(int i, int j, int hops){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        long ans = func(i-2, j-1, hops-1)%mod+func(i-2, j+1, hops-1)%mod+\\n                   func(i-1, j-2, hops-1)%mod+func(i+1, j-2, hops-1)%mod+\\n                   func(i-1, j+2, hops-1)%mod+func(i+1, j+2, hops-1)%mod+\\n                   func(i+2, j-1, hops-1)%mod+func(i+2, j+1, hops-1)%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach2 : DP Top Down - Accepted\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        vector<vector<vector<long>>> dp (4, vector<vector<long>> (3, vector<long> (n+1, -1)));\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n, dp))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    long func(int i, int j, int hops, vector<vector<vector<long>>> &dp){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        if(dp[i][j][hops] != -1)\\n            return dp[i][j][hops];\\n        \\n        dp[i][j][hops] = func(i-2, j-1, hops-1, dp)%mod+func(i-2, j+1, hops-1, dp)%mod+\\n                       func(i-1, j-2, hops-1, dp)%mod+func(i+1, j-2, hops-1, dp)%mod+\\n                       func(i-1, j+2, hops-1, dp)%mod+func(i+1, j+2, hops-1, dp)%mod+\\n                       func(i+2, j-1, hops-1, dp)%mod+func(i+2, j+1, hops-1, dp)%mod;\\n        \\n        return dp[i][j][hops];\\n    }\\n};\\n```\\n\\n# Approach 3 : DP Bottom Up - Accepted\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> a = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1e9+7;\\n    int knightDialer(int n){\\n        long long int ans = 0;\\n        vector<vector<long long int>> dp(n+1,vector<long long int>(10,0));\\n        for(int i = 0;i<10;i++) \\n            dp[1][i] = 1;\\n        \\n        for(int i=2;i<n+1;i++)\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<a[j].size();k++)\\n                    dp[i][j]+=dp[i-1][a[j][k]];\\n                dp[i][j]%=mod;\\n            }\\n        \\n        for(auto x:dp[n])\\n            ans += x;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    int func(int i, int j, int hops){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        long ans = func(i-2, j-1, hops-1)%mod+func(i-2, j+1, hops-1)%mod+\\n                   func(i-1, j-2, hops-1)%mod+func(i+1, j-2, hops-1)%mod+\\n                   func(i-1, j+2, hops-1)%mod+func(i+1, j+2, hops-1)%mod+\\n                   func(i+2, j-1, hops-1)%mod+func(i+2, j+1, hops-1)%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        vector<vector<vector<long>>> dp (4, vector<vector<long>> (3, vector<long> (n+1, -1)));\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n, dp))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    long func(int i, int j, int hops, vector<vector<vector<long>>> &dp){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        if(dp[i][j][hops] != -1)\\n            return dp[i][j][hops];\\n        \\n        dp[i][j][hops] = func(i-2, j-1, hops-1, dp)%mod+func(i-2, j+1, hops-1, dp)%mod+\\n                       func(i-1, j-2, hops-1, dp)%mod+func(i+1, j-2, hops-1, dp)%mod+\\n                       func(i-1, j+2, hops-1, dp)%mod+func(i+1, j+2, hops-1, dp)%mod+\\n                       func(i+2, j-1, hops-1, dp)%mod+func(i+2, j+1, hops-1, dp)%mod;\\n        \\n        return dp[i][j][hops];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> a = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1e9+7;\\n    int knightDialer(int n){\\n        long long int ans = 0;\\n        vector<vector<long long int>> dp(n+1,vector<long long int>(10,0));\\n        for(int i = 0;i<10;i++) \\n            dp[1][i] = 1;\\n        \\n        for(int i=2;i<n+1;i++)\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<a[j].size();k++)\\n                    dp[i][j]+=dp[i-1][a[j][k]];\\n                dp[i][j]%=mod;\\n            }\\n        \\n        for(auto x:dp[n])\\n            ans += x;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476546,
                "title": "python-simple-recursion-memoization",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t# paths represents every key we can go to from given key\\n\\t# -1 is starting condition, we can start from any key\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t# paths represents every key we can go to from given key\\n\\t# -1 is starting condition, we can start from any key\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191495,
                "title": "java-dp-talk-about-patience",
                "content": "Patience for manually doing the mapping :)\\n\\n```\\nclass Solution {\\n    \\n    public int knightDialer(int N) {\\n        long[][] dp = new long[N][10];\\n        int[][] reach = new int[][]{\\n            { 4, 6 }, { 6, 8 }, { 7, 9 }, { 4, 8 }, { 0, 3, 9 }, \\n            { }, { 0, 1, 7 }, { 2, 6 }, { 1, 3 }, { 2, 4 }\\n        };\\n        int mod = (int) Math.pow(10, 9) + 7;\\n        for (int i = 0; i < 10; i++) dp[0][i] = 1;\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                int[] prev = reach[j];\\n                for (int key : prev) {\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][key]) % mod;\\n                }\\n            }\\n        }\\n        long total = 0L;\\n        for (int i = 0; i < 10; i++) {\\n            total += dp[N - 1][i];\\n            total %= mod;\\n        }\\n        return (int) total;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int knightDialer(int N) {\\n        long[][] dp = new long[N][10];\\n        int[][] reach = new int[][]{\\n            { 4, 6 }, { 6, 8 }, { 7, 9 }, { 4, 8 }, { 0, 3, 9 }, \\n            { }, { 0, 1, 7 }, { 2, 6 }, { 1, 3 }, { 2, 4 }\\n        };\\n        int mod = (int) Math.pow(10, 9) + 7;\\n        for (int i = 0; i < 10; i++) dp[0][i] = 1;\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                int[] prev = reach[j];\\n                for (int key : prev) {\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][key]) % mod;\\n                }\\n            }\\n        }\\n        long total = 0L;\\n        for (int i = 0; i < 10; i++) {\\n            total += dp[N - 1][i];\\n            total %= mod;\\n        }\\n        return (int) total;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317319,
                "title": "fully-commented-easy-dp-java-solution",
                "content": "```\\n//index -> its neighbor mapping, like a bidirectional graph\\n    Integer[][] graph = new Integer[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0},\\n                                        {},{1, 7, 0}, {2, 6}, {1, 3}, {2, 4}};\\n\\n    int MOD = (int)1e9 + 7;\\n    public int knightDialer(int N) {\\n        //dp[i][j] stores\\uFF1Awhen there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have\\n        int[][] dp = new int[N + 1][10];\\n        //base case, defined by question as: \\n        //when it has 1 hop left on the current number, it should just return 1 (dp[0][j] IS NOT CORRECT)\\n        for(int j = 0; j < 10; j++) dp[1][j] = 1;\\n        //iterate sub-problem\\n        //be careful. i start on 2 because 2 ~ N is N - 1, and i - 1 could get our basecase\\n        for(int i = 2; i <= N; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int neighbor : graph[j]){//current number\\'s neighbor\\n                    dp[i][j] += dp[i - 1][neighbor];\\n                    //MOD should be seperated because it may alter our state transfer when number gets big\\n                    dp[i][j] %= MOD; \\n                } \\n            \\n            }\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < 10;j++){\\n            cnt += dp[N][j];\\n            cnt %= MOD; //MOD should be seperated \\n        }\\n        return cnt;\\n    }\\n```\\ndp[i][j] represents\\uFF1A<b>when there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have</b>\\nThus, we can use our graph to trace back to each of j\\'s (j is the current number) neighbors as we keep deducting steps number i.\\nThus the state transfer equation is defined as: \\n\\t<b>dp[i][j] += dp[i - 1][neighbor];</b>\\nFor example, if our current number is 0 and have 2 hops left, it would be <b>dp[2][0]</b>, \\nthen our dp array will try to get the value stored in <b>dp[1][4]</b> and <b>dp[1][6]</b>, which will both return 1. Then our  <b>dp[2][0]</b> will be store the value 2, which is equavalent to try out the number combination \"04\" and \"06\"",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n//index -> its neighbor mapping, like a bidirectional graph\\n    Integer[][] graph = new Integer[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0},\\n                                        {},{1, 7, 0}, {2, 6}, {1, 3}, {2, 4}};\\n\\n    int MOD = (int)1e9 + 7;\\n    public int knightDialer(int N) {\\n        //dp[i][j] stores\\uFF1Awhen there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have\\n        int[][] dp = new int[N + 1][10];\\n        //base case, defined by question as: \\n        //when it has 1 hop left on the current number, it should just return 1 (dp[0][j] IS NOT CORRECT)\\n        for(int j = 0; j < 10; j++) dp[1][j] = 1;\\n        //iterate sub-problem\\n        //be careful. i start on 2 because 2 ~ N is N - 1, and i - 1 could get our basecase\\n        for(int i = 2; i <= N; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int neighbor : graph[j]){//current number\\'s neighbor\\n                    dp[i][j] += dp[i - 1][neighbor];\\n                    //MOD should be seperated because it may alter our state transfer when number gets big\\n                    dp[i][j] %= MOD; \\n                } \\n            \\n            }\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < 10;j++){\\n            cnt += dp[N][j];\\n            cnt %= MOD; //MOD should be seperated \\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189249,
                "title": "don-t-know-why-tle-by-python",
                "content": "       **It doesn't cost much time in my Jupyter**\n\t\t\t\t\n\t\t\t\tif N==0:\n            return None\n        if N==1:\n            return 10\n        phone={}\n        num=[0,1,2,3,4,5,6,7,8,9]\n        phone[num[0]]=[4,6]\n        phone[num[1]]=[6,8]\n        phone[num[2]]=[7,9]\n        phone[num[3]]=[4,8]\n        phone[num[4]]=[3,9,0]\n        phone[num[5]]=[]\n        phone[num[6]]=[1,7,0]\n        phone[num[7]]=[2,6]\n        phone[num[8]]=[1,3]\n        phone[num[9]]=[2,4]\n\n        res=collections.Counter(num)\n\n        for i in range(N-1):\n            ans=0\n            new=collections.Counter()\n            for number in res:\n                for j in phone[number]:\n                    new[j]+=res[number]\n                ans+=res[number]*len(phone[number])\n            res=new\n\n        return(ans%(10**9+7))",
                "solutionTags": [],
                "code": "\t\t\t\tif N==0:\n        if N==1:\n        phone={}\n        num=[0,1,2,3,4,5,6,7,8,9]\n        phone[num[0]]=[4,6]\n        phone[num[1]]=[6,8]\n        phone[num[2]]=[7,9]\n        phone[num[3]]=[4,8]\n        phone[num[4]]=[3,9,0]\n        phone[num[5]]=[]\n        phone[num[6]]=[1,7,0]\n        phone[num[7]]=[2,6]\n        phone[num[8]]=[1,3]\n        phone[num[9]]=[2,4]\n        res=collections.Counter(num)\n        for i in range(N-1):\n            ans=0\n            new=collections.Counter()\n                    new[j]+=res[number]\n                ans+=res[number]*len(phone[number])\n            res=new\n        return(ans%(10**9+7))",
                "codeTag": "Unknown"
            },
            {
                "id": 1806575,
                "title": "easy-memoization-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = (int) 1e9 + 7; \\n    \\n    int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2}; \\n    int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1}; \\n    \\n    bool safe(int x, int y) {\\n        if(x == 3 and (y == 0 or y == 2)) return false; \\n        if(x < 0 or x > 3) return false; \\n        if(y < 0 or y > 2) return false; \\n        return true; \\n    }\\n    \\n    int f(int x, int y, int n, vector<vector<vector<int>>>& dp) {\\n        if(!safe(x, y)) return 0;\\n        if(n == 1) return 1;\\n        if(n < 0) return 0; \\n        \\n        if(dp[x][y][n] != -1) return dp[x][y][n]; \\n        \\n        int cnt = 0;\\n        \\n        for(int k = 0; k < 8; k++) {\\n            int i = x + dx[k]; \\n            int j = y + dy[k]; \\n            if(safe(i, j)) {\\n                cnt = (cnt % mod + f(i, j, n - 1, dp) % mod) % mod; \\n            }\\n        }\\n        return dp[x][y][n] = cnt % mod; \\n    }\\n    \\n    int knightDialer(int n) {\\n        int cnt = 0; \\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(3, vector<int>(n + 1,-1))); \\n        \\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < 3; j++) {\\n                cnt = (cnt % mod + f(i, j, n, dp) % mod) % mod; \\n            }\\n        }\\n        return cnt % mod; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = (int) 1e9 + 7; \\n    \\n    int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2}; \\n    int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1}; \\n    \\n    bool safe(int x, int y) {\\n        if(x == 3 and (y == 0 or y == 2)) return false; \\n        if(x < 0 or x > 3) return false; \\n        if(y < 0 or y > 2) return false; \\n        return true; \\n    }\\n    \\n    int f(int x, int y, int n, vector<vector<vector<int>>>& dp) {\\n        if(!safe(x, y)) return 0;\\n        if(n == 1) return 1;\\n        if(n < 0) return 0; \\n        \\n        if(dp[x][y][n] != -1) return dp[x][y][n]; \\n        \\n        int cnt = 0;\\n        \\n        for(int k = 0; k < 8; k++) {\\n            int i = x + dx[k]; \\n            int j = y + dy[k]; \\n            if(safe(i, j)) {\\n                cnt = (cnt % mod + f(i, j, n - 1, dp) % mod) % mod; \\n            }\\n        }\\n        return dp[x][y][n] = cnt % mod; \\n    }\\n    \\n    int knightDialer(int n) {\\n        int cnt = 0; \\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(3, vector<int>(n + 1,-1))); \\n        \\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < 3; j++) {\\n                cnt = (cnt % mod + f(i, j, n, dp) % mod) % mod; \\n            }\\n        }\\n        return cnt % mod; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893523,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "The problem can be solved by matrix power. Similar problems are\\n[70. Climbing Stairs ](https://leetcode.com/problems/climbing-stairs/discuss/929659/Evolve-from-brute-force-to-optimal)\\n[509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/discuss/989672/Evolve-from-intuition)\\n[552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/discuss/650804/Evolve-from-brute-force-to-optimal).\\n1. Brute force O(3^n), may be larger than O(2^n) since 4 and 6 have three next states. The last array is the start locations\\n```\\n\\tint[][] nxt={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4},{0,1,2,3,4,5,6,7,8,9}};\\n    public int knightDialer(int n) {\\n        return dfs(n,10);\\n    }\\n    private int dfs(int n, int num) {\\n        if(n==0) return 1;\\n        int tot=0;\\n        for(int next:nxt[num])\\n            tot+=dfs(n-1,next);\\n        return tot;\\n    }\\n```\\n2. Memoization O(n), mem[i][j] caches dfs(i,j). It means the number of ways starting at number j with i jumps to go.\\n```\\n\\tpublic int knightDialer(int n) {\\n        return dfs(n,10,new Integer[n+1][11])%1000000007;\\n    }\\n    private int dfs(int n, int num,Integer[][] mem) {\\n        if(n==0) return 1;\\n        if(mem[n][num]!=null) return mem[n][num];\\n        int tot=0;\\n        for(int next:nxt[num]) {\\n            tot=(tot+dfs(n-1,next,mem))%1000000007;\\n        }\\n        return mem[n][num]=tot;\\n    }\\n```\\n3. dp O(n) Time, O(n) Space. From #1 and #2, it is clear that dp[i][j] = sum(dp[i-1][k]), k=next[j].\\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] dp=new int[n+1][11];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<=n;i++)\\n            for(int j=0;j<=10;j++) \\n                for(int next:nxt[j]) \\n                    dp[i][j]=(dp[i][j]+dp[i-1][next])%1000000007;\\n        return dp[n][10];\\n    }\\n```\\n4. dp O(n) Time, constant space. In #3, dp[i] is computed from dp[i-1] only, so we only need to cache two rows.\\n```\\n\\tpublic int knightDialer(int n) {\\n        int[] pre=new int[11];\\n        Arrays.fill(pre,1);\\n        for(int i=1;i<=n;i++) {\\n            int[] cur=new int[11];\\n            for(int j=0;j<=10;j++)\\n                for(int nxt:next[j])\\n                    cur[j] = (cur[j]+pre[nxt])%1000000007;\\n            pre=cur;\\n        }\\n        return pre[10];\\n    }\\n```\\n5. State transition O(logn). There are only 10 numbers/states. Similar as above, the next state look up matrix can be represented as a 10x10 binary matrix. The matrix is extended to 10x10 because I want to use matrix multiplication to solve the problem. The ith row is the next states of i. The ith column is the states that jumps to i. Current state s={s0,s1,..s9} 1x10 times the 10x10 matrix gives the next state 1x10 s\\'={s0\\',s1\\'..s9\\'}. An entry s[i] in state vector means the number of ways that end at i. When it multiplies the matrix, it extracts the ith row and update the 1s to s\\'. Ex, the knight starts from 0 and takes 1 jump. We multiply {1,0...0} with the transition matrix and get {0,0,0,0,1,0,1,0,0,0} which is the first row of the matrix. Sum the vector is the total number of ways to take 1 jump from 0. In general, \\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] M = {{0,0,0,0,1,0,1,0,0,0},\\n                     {0,0,0,0,0,0,1,0,1,0},\\n                     {0,0,0,0,0,0,0,1,0,1},\\n                     {0,0,0,0,1,0,0,0,1,0},\\n                     {1,0,0,1,0,0,0,0,0,1},\\n                     {0,0,0,0,0,0,0,0,0,0},\\n                     {1,1,0,0,0,0,0,1,0,0},\\n                     {0,0,1,0,0,0,1,0,0,0},\\n                     {0,1,0,1,0,0,0,0,0,0},\\n                     {0,0,1,0,1,0,0,0,0,0}};\\n        M=pow(M,n-1);\\n        int sum=0;\\n        for(int i=0;i<N;i++)  \\n            for(int s:M[i])\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    int N=10, MOD=1000000007;\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint[][] nxt={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4},{0,1,2,3,4,5,6,7,8,9}};\\n    public int knightDialer(int n) {\\n        return dfs(n,10);\\n    }\\n    private int dfs(int n, int num) {\\n        if(n==0) return 1;\\n        int tot=0;\\n        for(int next:nxt[num])\\n            tot+=dfs(n-1,next);\\n        return tot;\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        return dfs(n,10,new Integer[n+1][11])%1000000007;\\n    }\\n    private int dfs(int n, int num,Integer[][] mem) {\\n        if(n==0) return 1;\\n        if(mem[n][num]!=null) return mem[n][num];\\n        int tot=0;\\n        for(int next:nxt[num]) {\\n            tot=(tot+dfs(n-1,next,mem))%1000000007;\\n        }\\n        return mem[n][num]=tot;\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] dp=new int[n+1][11];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<=n;i++)\\n            for(int j=0;j<=10;j++) \\n                for(int next:nxt[j]) \\n                    dp[i][j]=(dp[i][j]+dp[i-1][next])%1000000007;\\n        return dp[n][10];\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[] pre=new int[11];\\n        Arrays.fill(pre,1);\\n        for(int i=1;i<=n;i++) {\\n            int[] cur=new int[11];\\n            for(int j=0;j<=10;j++)\\n                for(int nxt:next[j])\\n                    cur[j] = (cur[j]+pre[nxt])%1000000007;\\n            pre=cur;\\n        }\\n        return pre[10];\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] M = {{0,0,0,0,1,0,1,0,0,0},\\n                     {0,0,0,0,0,0,1,0,1,0},\\n                     {0,0,0,0,0,0,0,1,0,1},\\n                     {0,0,0,0,1,0,0,0,1,0},\\n                     {1,0,0,1,0,0,0,0,0,1},\\n                     {0,0,0,0,0,0,0,0,0,0},\\n                     {1,1,0,0,0,0,0,1,0,0},\\n                     {0,0,1,0,0,0,1,0,0,0},\\n                     {0,1,0,1,0,0,0,0,0,0},\\n                     {0,0,1,0,1,0,0,0,0,0}};\\n        M=pow(M,n-1);\\n        int sum=0;\\n        for(int i=0;i<N;i++)  \\n            for(int s:M[i])\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    int N=10, MOD=1000000007;\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526276,
                "title": "java-use-dfs",
                "content": "```\\n    private final static long mod = (long) Math.pow(10, 9) + 7;\\n    long[][][] res;\\n    public int knightDialer(int N) {\\n        res = new long[N+1][4][3];\\n        long s = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                s = (s + dfs(i, j, N)) % mod;\\n            }\\n        }\\n        return (int) s;\\n    }\\n    \\n    private long dfs(int i, int j, int cnt) {\\n        if (i < 0 || j < 0 || j > 2 || i > 3 || (i == 3 && j != 1)) return 0;\\n        if (res[cnt][i][j] > 0) return res[cnt][i][j];\\n        if (cnt == 1) return 1;\\n        res[cnt][i][j] = (dfs(i + 2, j + 1, cnt - 1)\\n            + dfs(i - 2, j + 1, cnt - 1)\\n            + dfs(i + 2, j - 1, cnt - 1)\\n            + dfs(i - 2, j - 1, cnt - 1)\\n            + dfs(i + 1, j + 2, cnt - 1)\\n            + dfs(i - 1, j + 2, cnt - 1)\\n            + dfs(i + 1, j - 2, cnt - 1)\\n            + dfs(i - 1, j - 2, cnt - 1)) % mod;\\n        return res[cnt][i][j];        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private final static long mod = (long) Math.pow(10, 9) + 7;\\n    long[][][] res;\\n    public int knightDialer(int N) {\\n        res = new long[N+1][4][3];\\n        long s = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                s = (s + dfs(i, j, N)) % mod;\\n            }\\n        }\\n        return (int) s;\\n    }\\n    \\n    private long dfs(int i, int j, int cnt) {\\n        if (i < 0 || j < 0 || j > 2 || i > 3 || (i == 3 && j != 1)) return 0;\\n        if (res[cnt][i][j] > 0) return res[cnt][i][j];\\n        if (cnt == 1) return 1;\\n        res[cnt][i][j] = (dfs(i + 2, j + 1, cnt - 1)\\n            + dfs(i - 2, j + 1, cnt - 1)\\n            + dfs(i + 2, j - 1, cnt - 1)\\n            + dfs(i - 2, j - 1, cnt - 1)\\n            + dfs(i + 1, j + 2, cnt - 1)\\n            + dfs(i - 1, j + 2, cnt - 1)\\n            + dfs(i + 1, j - 2, cnt - 1)\\n            + dfs(i - 1, j - 2, cnt - 1)) % mod;\\n        return res[cnt][i][j];        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1456762,
                "title": "c-dp-easy-solution-with-explanation",
                "content": "```\\nDiagram to show moves of a knight\\n\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\nFrom \\u2018k\\u2019 a knight can move to all positions marked with alphabet,\\nMore precisely from pos(i,j)=k all valid moves of knight are\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n\\n\\nWe can think of this problem as the total number of unique paths\\nthe knight can travel making n hops because to dial distinct numbers,\\nthe path taken by the knight must be unique.\\n\\nIn simple words\\n\"the total number of unique paths to (i, j) \\nfor certain hops n is equal to the sum of total number of unique paths\\nto each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nLet keypad be like \\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\na knight can jump to 8 possible places in a single hop .\\nHowever, 6 of the other hops will take you outside of the matrix.\\nYou will see later in the code how this is being handled as a part of base case.\\n\\nNaive Recursive Code:\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    long solve(int i,int j,int n)\\n    {\\n\\t\\t//Conditions to prevent edge cases of going out of matrix and preventing to move on ladt row\\'s 0th and 2nd column\\n\\t\\tif(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1)) \\n\\t\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        \\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n\\nIf you run this code for n = 50 you will realize that it takes at least an hour to get the answer.\\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems.\\nAnd answer for these overlapping subproblems \\nwe have calculated earlier so again and again we are doing same calculation and this is time consuming \\nA better way is to store the answer of the subproblem in an additional space ad before calculating\\nthe ans further first check if the ans for that subproblem is already present if yes,\\nuse that answer, this will prevent us from calculating  the same answer and if no\\ncalculate the answer and store it .This approach is called TOP DOWN DP\\n\\nWe use dynamic programming and store the solution of each subproblem in M.\\nM is a 3D array and each index of M corresponds to a solution of n. \\nEach n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    int dp[5001][4][3];\\n    long solve(int i,int j,int n)\\n    {\\n        if(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1))\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[n][i][j]!=-1)\\n            return dp[n][i][j];\\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return dp[n][i][j]=res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nDiagram to show moves of a knight\\n\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\nFrom \\u2018k\\u2019 a knight can move to all positions marked with alphabet,\\nMore precisely from pos(i,j)=k all valid moves of knight are\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n\\n\\nWe can think of this problem as the total number of unique paths\\nthe knight can travel making n hops because to dial distinct numbers,\\nthe path taken by the knight must be unique.\\n\\nIn simple words\\n\"the total number of unique paths to (i, j) \\nfor certain hops n is equal to the sum of total number of unique paths\\nto each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nLet keypad be like \\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\na knight can jump to 8 possible places in a single hop .\\nHowever, 6 of the other hops will take you outside of the matrix.\\nYou will see later in the code how this is being handled as a part of base case.\\n\\nNaive Recursive Code:\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    long solve(int i,int j,int n)\\n    {\\n\\t\\t//Conditions to prevent edge cases of going out of matrix and preventing to move on ladt row\\'s 0th and 2nd column\\n\\t\\tif(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1)) \\n\\t\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        \\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n\\nIf you run this code for n = 50 you will realize that it takes at least an hour to get the answer.\\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems.\\nAnd answer for these overlapping subproblems \\nwe have calculated earlier so again and again we are doing same calculation and this is time consuming \\nA better way is to store the answer of the subproblem in an additional space ad before calculating\\nthe ans further first check if the ans for that subproblem is already present if yes,\\nuse that answer, this will prevent us from calculating  the same answer and if no\\ncalculate the answer and store it .This approach is called TOP DOWN DP\\n\\nWe use dynamic programming and store the solution of each subproblem in M.\\nM is a 3D array and each index of M corresponds to a solution of n. \\nEach n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    int dp[5001][4][3];\\n    long solve(int i,int j,int n)\\n    {\\n        if(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1))\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[n][i][j]!=-1)\\n            return dp[n][i][j];\\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return dp[n][i][j]=res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289217,
                "title": "c-with-explanation-2-approaches-dp-and-memoization-o-n",
                "content": "*Idea for both Approaches (Memoization and DP)*\\nSay we have to find the number of possible combinations of length n starting from 0. Then this is the same as the sum of number of combinations of length n-1 from 4 +6 as from 0 , the knight can hop to 4 and 6. Create a vector of possible hops where the index represents soucre and the vector represents possible hops and apply this logic.\\nTime Complexity: O(10n)=O(n) for both Approaches\\nSpace Compelxity->O(10n)=O(n) for both Approaches\\n\\n**Approach-1** (Memoization)\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int helper(int x, int n,vector<vector<int>>&dp)\\n    {\\n        if(n==1)\\n        {\\n            return dp[n][x]=1;\\n        }\\n        if(dp[n][x]!=-1)\\n        {\\n            return dp[n][x];\\n        }\\n        dp[n][x]=0;\\n        for(auto nextSquare:v[x])\\n        {\\n            dp[n][x]=(dp[n][x]+helper(nextSquare,n-1,dp))%mod;\\n        }\\n        return dp[n][x];\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            ans=(ans+helper(i,n,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach-2** (DP)\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,0));\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                for(auto nextSquare:v[j])\\n                {\\n                    dp[i][j]=(dp[i][j]+dp[i-1][nextSquare])%mod;\\n                }\\n            }\\n        }\\n        for(int j=0;j<10;j++)\\n        {\\n            ans=(ans+dp[n][j])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int helper(int x, int n,vector<vector<int>>&dp)\\n    {\\n        if(n==1)\\n        {\\n            return dp[n][x]=1;\\n        }\\n        if(dp[n][x]!=-1)\\n        {\\n            return dp[n][x];\\n        }\\n        dp[n][x]=0;\\n        for(auto nextSquare:v[x])\\n        {\\n            dp[n][x]=(dp[n][x]+helper(nextSquare,n-1,dp))%mod;\\n        }\\n        return dp[n][x];\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            ans=(ans+helper(i,n,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,0));\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                for(auto nextSquare:v[j])\\n                {\\n                    dp[i][j]=(dp[i][j]+dp[i-1][nextSquare])%mod;\\n                }\\n            }\\n        }\\n        for(int j=0;j<10;j++)\\n        {\\n            ans=(ans+dp[n][j])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985146,
                "title": "using-recursion-top-down-dp-cpp",
                "content": "# Intuition\\nrecursive and dp\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n```\\n// recursive code\\n```\\nll solve(int val, int n, vector<vector<int>> &arr)\\n{\\n    if (n == 0)\\n    {\\n        return 0;\\n    }\\n\\n    if (n == 1)\\n    {\\n        return 1;\\n    }\\n    ll ans = 0;\\n    for (int i = 0; i < arr[val].size(); i++)\\n    {\\n        ans += solve(arr[val][i], n - 1, arr);\\n    }\\n    return ans;\\n}\\n\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> arr(10);\\n    arr[0] = {4, 6};\\n    arr[1] = {6, 8};\\n    arr[2] = {7, 9};\\n    arr[3] = {4, 8};\\n    arr[4] = {0, 3, 9};\\n    arr[5] = {};\\n    arr[6] = {0, 1, 7};\\n\\n    arr[7] = {2, 6};\\n    arr[8] = {1, 3};\\n    arr[9] = {2, 4};\\n\\n    ll ans = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n\\n        ans += solve(i, n, arr);\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n\\n```\\n// top down dp\\n\\n```\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> a = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n    int mod = 1e9 + 7;\\n    long long int ans = 0;\\n    vector<vector<long long int>> dp(n + 1, vector<long long int>(10, 0));\\n    for (int i = 0; i < 10; i++)\\n        dp[1][i] = 1;\\n\\n    for (int i = 2; i < n + 1; i++)\\n        for (int j = 0; j < 10; j++)\\n        {\\n            for (int k = 0; k < a[j].size(); k++)\\n                dp[i][j] += dp[i - 1][a[j][k]];\\n            dp[i][j] %= mod;\\n        }\\n\\n    for (auto x : dp[n])\\n        ans += x;\\n\\n    return ans % mod;\\n}\\n\\n```\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n```\n```\\nll solve(int val, int n, vector<vector<int>> &arr)\\n{\\n    if (n == 0)\\n    {\\n        return 0;\\n    }\\n\\n    if (n == 1)\\n    {\\n        return 1;\\n    }\\n    ll ans = 0;\\n    for (int i = 0; i < arr[val].size(); i++)\\n    {\\n        ans += solve(arr[val][i], n - 1, arr);\\n    }\\n    return ans;\\n}\\n\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> arr(10);\\n    arr[0] = {4, 6};\\n    arr[1] = {6, 8};\\n    arr[2] = {7, 9};\\n    arr[3] = {4, 8};\\n    arr[4] = {0, 3, 9};\\n    arr[5] = {};\\n    arr[6] = {0, 1, 7};\\n\\n    arr[7] = {2, 6};\\n    arr[8] = {1, 3};\\n    arr[9] = {2, 4};\\n\\n    ll ans = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n\\n        ans += solve(i, n, arr);\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n\\n```\n```\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> a = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n    int mod = 1e9 + 7;\\n    long long int ans = 0;\\n    vector<vector<long long int>> dp(n + 1, vector<long long int>(10, 0));\\n    for (int i = 0; i < 10; i++)\\n        dp[1][i] = 1;\\n\\n    for (int i = 2; i < n + 1; i++)\\n        for (int j = 0; j < 10; j++)\\n        {\\n            for (int k = 0; k < a[j].size(); k++)\\n                dp[i][j] += dp[i - 1][a[j][k]];\\n            dp[i][j] %= mod;\\n        }\\n\\n    for (auto x : dp[n])\\n        ans += x;\\n\\n    return ans % mod;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1544986,
                "title": "python-simple-dp-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n        \\n        \\n        for _ in range(n-1):\\n            dp = [0 for _ in range(10)]\\n            dp[0] = arr[5] + arr[7]\\n            dp[1] = arr[6] + arr[8]\\n            dp[2] = arr[3] + arr[7]\\n            dp[3] = arr[2] + arr[8] + arr[9]\\n            dp[4] = 0\\n            dp[5] = arr[0] + arr[6] + arr[9]\\n            dp[6] = arr[1] + arr[5]\\n            dp[7] = arr[0] + arr[2]\\n            dp[8] = arr[1] + arr[3]\\n            dp[9] = arr[3] + arr[5]\\n            arr = dp\\n        return sum(arr) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n        \\n        \\n        for _ in range(n-1):\\n            dp = [0 for _ in range(10)]\\n            dp[0] = arr[5] + arr[7]\\n            dp[1] = arr[6] + arr[8]\\n            dp[2] = arr[3] + arr[7]\\n            dp[3] = arr[2] + arr[8] + arr[9]\\n            dp[4] = 0\\n            dp[5] = arr[0] + arr[6] + arr[9]\\n            dp[6] = arr[1] + arr[5]\\n            dp[7] = arr[0] + arr[2]\\n            dp[8] = arr[1] + arr[3]\\n            dp[9] = arr[3] + arr[5]\\n            arr = dp\\n        return sum(arr) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292870,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {   \\n    int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        long dp[] = new long[10];\\n        Arrays.fill(dp , 1);\\n        long ans = 0;\\n        for(int i = 1 ; i < N ; i++) {\\n            long temp[] = new long[10];\\n            temp[0] = (dp[4]+dp[6]) % MOD;\\n            temp[1] = (dp[6]+dp[8]) % MOD;\\n            temp[2] = (dp[7]+dp[9]) % MOD;\\n            temp[3] = (dp[4]+dp[8]) % MOD;\\n            temp[4] = (((dp[0]+dp[3]) % MOD)+dp[9])%MOD;\\n            temp[6] = (((dp[0]+dp[1]) % MOD)+dp[7])%MOD;\\n            temp[7] = (dp[2]+dp[6])%MOD;\\n            temp[8] = (dp[1]+dp[3])%MOD;\\n            temp[9] = (dp[4]+dp[2])%MOD;\\n            dp = temp;\\n        }\\n        for(long val : dp) \\n            ans = (ans + val) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {   \\n    int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        long dp[] = new long[10];\\n        Arrays.fill(dp , 1);\\n        long ans = 0;\\n        for(int i = 1 ; i < N ; i++) {\\n            long temp[] = new long[10];\\n            temp[0] = (dp[4]+dp[6]) % MOD;\\n            temp[1] = (dp[6]+dp[8]) % MOD;\\n            temp[2] = (dp[7]+dp[9]) % MOD;\\n            temp[3] = (dp[4]+dp[8]) % MOD;\\n            temp[4] = (((dp[0]+dp[3]) % MOD)+dp[9])%MOD;\\n            temp[6] = (((dp[0]+dp[1]) % MOD)+dp[7])%MOD;\\n            temp[7] = (dp[2]+dp[6])%MOD;\\n            temp[8] = (dp[1]+dp[3])%MOD;\\n            temp[9] = (dp[4]+dp[2])%MOD;\\n            dp = temp;\\n        }\\n        for(long val : dp) \\n            ans = (ans + val) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241911,
                "title": "js-dp-based-solution-o-n-with-explanation-78",
                "content": "```\\nvar knightDialer = function(n) {\\n\\n\\t// if n equals 1, 10 number can be formed, that is with each digit\\n    if(n === 1) {\\n        return 10;\\n    }\\n    const mod = 1000000007;\\n\\t\\n\\t// since knight can move in 8 directions, in the dialpad, we know what positions the knight can move when we start from a digit\\n\\t// created the map of those positions that can be moved from key `num`\\n    const map = {1: [6,8], 2: [7,9], 3: [4,8], 4: [0,3,9],\\n                 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4], 0: [4,6]};\\n    \\n\\t// create a dp array of size - 10 * (n + 1), initialize with 0\\n    const dp = Array(10).fill(null).map(() => Array(n + 1).fill(0));\\n\\t\\n\\t//initialize the dp array for each num and n = 1 and n = 2 \\n    let total = 0;\\n    for(let num = 0; num <= 9; ++num) {\\n        dp[num][1] = 1;\\n        dp[num][2] = map[num].length;\\n        if(n === 2) {\\n            total += dp[num][2];\\n        }\\n    }\\n\\t\\n\\t// if n > 2, we calculate the total numbers that can be formed from each digit when we start from it\\n\\t// `total` will be summation of all the numbers which we will return\\n    for(let i = 3; i <= n; ++i) {\\n        for(let num = 0; num <= 9; ++num) {\\n\\t\\t\\n\\t\\t\\t/* the number of digits that can be formed starting with `num` equals the sum of the number of digits that can be formed by the digits which are reachable from `num`\\n\\t\\t\\tfor instance, for n = 3 and num = 1, `16` and `18` are two 2 digit number. \\n\\t\\t\\tin order to get the 3 digit numbers starting with `1`, we need to check the digits reachable from 6 and 8\\n\\t\\t\\tfor `6` we check all the 2 digit numbers - 3 (0,1,7), and for `8` = 2 (1,3)\\n\\t\\t\\tthat is,\\n\\t\\t\\tdp[1][3] = dp[6][2] + dp[8][2]\\n\\t\\t\\tdp[6][2] = 3\\n\\t\\t\\tdp[8][2] = 2\\n\\t\\t\\t=> dp[1][3] = 5 (phone numbers - 160, 161, 167, 181, 183)\\n\\t\\t\\t*/\\n            map[num].forEach(d => dp[num][i] = (dp[num][i] + dp[d][i - 1]) % mod);\\n            if(i === n) {\\n                total = (total + dp[num][i]) % mod;\\n            }\\n        }    \\n    }\\n    return total;\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(n)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar knightDialer = function(n) {\\n\\n\\t// if n equals 1, 10 number can be formed, that is with each digit\\n    if(n === 1) {\\n        return 10;\\n    }\\n    const mod = 1000000007;\\n\\t\\n\\t// since knight can move in 8 directions, in the dialpad, we know what positions the knight can move when we start from a digit\\n\\t// created the map of those positions that can be moved from key `num`\\n    const map = {1: [6,8], 2: [7,9], 3: [4,8], 4: [0,3,9],\\n                 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4], 0: [4,6]};\\n    \\n\\t// create a dp array of size - 10 * (n + 1), initialize with 0\\n    const dp = Array(10).fill(null).map(() => Array(n + 1).fill(0));\\n\\t\\n\\t//initialize the dp array for each num and n = 1 and n = 2 \\n    let total = 0;\\n    for(let num = 0; num <= 9; ++num) {\\n        dp[num][1] = 1;\\n        dp[num][2] = map[num].length;\\n        if(n === 2) {\\n            total += dp[num][2];\\n        }\\n    }\\n\\t\\n\\t// if n > 2, we calculate the total numbers that can be formed from each digit when we start from it\\n\\t// `total` will be summation of all the numbers which we will return\\n    for(let i = 3; i <= n; ++i) {\\n        for(let num = 0; num <= 9; ++num) {\\n\\t\\t\\n\\t\\t\\t/* the number of digits that can be formed starting with `num` equals the sum of the number of digits that can be formed by the digits which are reachable from `num`\\n\\t\\t\\tfor instance, for n = 3 and num = 1, `16` and `18` are two 2 digit number. \\n\\t\\t\\tin order to get the 3 digit numbers starting with `1`, we need to check the digits reachable from 6 and 8\\n\\t\\t\\tfor `6` we check all the 2 digit numbers - 3 (0,1,7), and for `8` = 2 (1,3)\\n\\t\\t\\tthat is,\\n\\t\\t\\tdp[1][3] = dp[6][2] + dp[8][2]\\n\\t\\t\\tdp[6][2] = 3\\n\\t\\t\\tdp[8][2] = 2\\n\\t\\t\\t=> dp[1][3] = 5 (phone numbers - 160, 161, 167, 181, 183)\\n\\t\\t\\t*/\\n            map[num].forEach(d => dp[num][i] = (dp[num][i] + dp[d][i - 1]) % mod);\\n            if(i === n) {\\n                total = (total + dp[num][i]) % mod;\\n            }\\n        }    \\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705341,
                "title": "c-easy-solution-with-diagram",
                "content": "**Key Idea** : \\n\\nGiven you are at a position on the keypad, find all keys from where you can reach the current position. \\n\\nFor eg: 1 can be reached by a knight\\'s move from 8 and 6. Also, if you can get to 1 from 6, you can also get to 6 from 1. \\n\\n5 is a special case. It can not be reached from any key. There is no way to reach 5 other than starting out at 5.\\n\\nYou can then construct a undirected graph as below. \\n\\n![image](https://assets.leetcode.com/users/images/e5392c69-0e3d-4608-bd06-85fed7f56f34_1593109968.5285418.png)\\n\\n\\nOnce you have the adjaceny-graph, the following dp recurssion formula can be applied for all r from [1...N]: \\n```\\nfor (auto & prev : graph[curr]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD\\n```\\n\\n**Optimization**:\\n\\nOnce you have the solution using the Nx10 matrix, you can collapse the Nx10 matrix to 2x10 matrix, since for evaluting a row \\'r\\' in the Nx10 matrix we use only values from row \\'r-1\\'. You can therefore then cyclically use the 2x10 matrix to evaluate all the rows in the Nx10 matrix.\\n\\n**Solution**: \\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n\\n        int MOD = 1e9+7;\\n        \\n        vector<vector<int>> dp (N+1, vector<int> (10,0)); \\n        \\n        int rows = dp.size(); // numbers\\n        int cols = dp[0].size(); // cols\\n        \\n        for (int c = 0; c < cols; c++) {\\n            dp[1][c] = 1;\\n        }\\n        \\n        vector<vector<int>> graph =  {{4,6},   // 0 -> 4,6\\n                                      {8,6},   // 1 -> 6,8 \\n                                      {7,9},   // 2 -> 7,9\\n                                      {8,4},   // 3 -> 4,8\\n                                      {3,9,0}, // 4 -> 0,3,9\\n                                      {},      // 5 -> empty\\n                                      {1,0,7}, // 6 -> 0,1,7\\n                                      {6,2},   // 7 -> 2,6\\n                                      {1,3},   // 8 -> 1,3\\n                                      {4,2}};  // 9 -> 4,2\\n\\n        \\n        for (int r = 2; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                 dp[r][c] = 0; \\n                 for (auto & prev : graph[c]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD;\\n                 }\\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int j=0; j<10; j++) \\n\\t\\t\\tresult = (result + dp[N][j]) % MOD; \\n                                 \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor (auto & prev : graph[curr]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD\\n```\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n\\n        int MOD = 1e9+7;\\n        \\n        vector<vector<int>> dp (N+1, vector<int> (10,0)); \\n        \\n        int rows = dp.size(); // numbers\\n        int cols = dp[0].size(); // cols\\n        \\n        for (int c = 0; c < cols; c++) {\\n            dp[1][c] = 1;\\n        }\\n        \\n        vector<vector<int>> graph =  {{4,6},   // 0 -> 4,6\\n                                      {8,6},   // 1 -> 6,8 \\n                                      {7,9},   // 2 -> 7,9\\n                                      {8,4},   // 3 -> 4,8\\n                                      {3,9,0}, // 4 -> 0,3,9\\n                                      {},      // 5 -> empty\\n                                      {1,0,7}, // 6 -> 0,1,7\\n                                      {6,2},   // 7 -> 2,6\\n                                      {1,3},   // 8 -> 1,3\\n                                      {4,2}};  // 9 -> 4,2\\n\\n        \\n        for (int r = 2; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                 dp[r][c] = 0; \\n                 for (auto & prev : graph[c]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD;\\n                 }\\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int j=0; j<10; j++) \\n\\t\\t\\tresult = (result + dp[N][j]) % MOD; \\n                                 \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313285,
                "title": "c-recursion-memoization",
                "content": "we just have to traverse dial pad one by one and at each num we use dfs to count the number.\\n**\"we don\\'t need to make matrix\"**\\n```\\nclass Solution {\\npublic:\\n    int dp[5][4][5001];\\n    int mod=1000000007;\\n    int solve(int k,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=4 || j>=3 || (i==3 && (j==0 || j==2)))                            //5th OR cond for * and # (:\\n            return 0;\\n        if(k==1)\\n            return 1;\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        int a=solve(k-1,i+1,j-2)%mod;\\n            a=(a+solve(k-1,i+1,j+2))%mod;\\n            a=(a+solve(k-1,i+2,j-1))%mod;\\n            a=(a+solve(k-1,i+2,j+1))%mod;\\n            a=(a+solve(k-1,i-1,j-2))%mod;\\n            a=(a+solve(k-1,i-1,j+2))%mod;\\n            a=(a+solve(k-1,i-2,j-1))%mod;\\n            a=(a+solve(k-1,i-2,j+1))%mod;\\n            \\n        return dp[i][j][k]=a;\\n    }\\n    int knightDialer(int n)\\n    {\\n       int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n       for(int i=0;i<4;i++)                                                       // dial Pad\\n           for(int j=0;j<3;j++)\\n               ans=(ans+solve(n,i,j))%mod;\\n        return ans;\\n    }\\n};\\n\\n// Feel free to ask any doubt in comment section",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[5][4][5001];\\n    int mod=1000000007;\\n    int solve(int k,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=4 || j>=3 || (i==3 && (j==0 || j==2)))                            //5th OR cond for * and # (:\\n            return 0;\\n        if(k==1)\\n            return 1;\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        int a=solve(k-1,i+1,j-2)%mod;\\n            a=(a+solve(k-1,i+1,j+2))%mod;\\n            a=(a+solve(k-1,i+2,j-1))%mod;\\n            a=(a+solve(k-1,i+2,j+1))%mod;\\n            a=(a+solve(k-1,i-1,j-2))%mod;\\n            a=(a+solve(k-1,i-1,j+2))%mod;\\n            a=(a+solve(k-1,i-2,j-1))%mod;\\n            a=(a+solve(k-1,i-2,j+1))%mod;\\n            \\n        return dp[i][j][k]=a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2171762,
                "title": "python-math-t-m-98-96",
                "content": "```\\nclass Solution:\\n            # Consider this partition of an iteration based on last digits. In this \\n\\t\\t\\t# iretation, the four elements are a, b, c, d, where:\\n            #                   a: 1,3,7,9    b: 4,6    c: 2,8    d: 0\\n\\t\\t\\t#(Note that 5 only matters when n = 1) \\n\\t\\t\\t# For example,\\n\\t\\t\\t#      For n = 1:  len(a) = 4, len(b) = 2, len(c) = 2, len(d) = 1. Sum  is 10  (See Ex 1)\\n\\t\\t\\t#      For n = 2:  len(a) = 8, len(b) = 6, len(c) = 4, len(d) = 2. Sum  is 20  (See Ex 2)\\n\\t\\t\\t#\\n            # In general, in the next interation,  the count in each element of the partition is \\n\\t\\t\\t# determined by the counts in the current iteration.  For example,\\n\\t\\t\\t#                   new_a = 2 x old_b + 2 x old_c.\\n\\t\\t\\t# the other relations are below in the code.\\n\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1: return 10        # edge case\\n        N = 10**9+7\\n        v = [4, 2, 2, 1]            # n = 1: four in a, two in b, etc\\n        for _ in range(n-1):        # iterate n-1 times (since we start at n=1)\\n            a,b,c,d  = v\\n            v = [(2*b+2*c)%N, (a+2*d)%N, a, b]\\n        return sum(v)%N",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n            # Consider this partition of an iteration based on last digits. In this \\n\\t\\t\\t# iretation, the four elements are a, b, c, d, where:\\n            #                   a: 1,3,7,9    b: 4,6    c: 2,8    d: 0\\n\\t\\t\\t#(Note that 5 only matters when n = 1) \\n\\t\\t\\t# For example,\\n\\t\\t\\t#      For n = 1:  len(a) = 4, len(b) = 2, len(c) = 2, len(d) = 1. Sum  is 10  (See Ex 1)\\n\\t\\t\\t#      For n = 2:  len(a) = 8, len(b) = 6, len(c) = 4, len(d) = 2. Sum  is 20  (See Ex 2)\\n\\t\\t\\t#\\n            # In general, in the next interation,  the count in each element of the partition is \\n\\t\\t\\t# determined by the counts in the current iteration.  For example,\\n\\t\\t\\t#                   new_a = 2 x old_b + 2 x old_c.\\n\\t\\t\\t# the other relations are below in the code.\\n\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1: return 10        # edge case\\n        N = 10**9+7\\n        v = [4, 2, 2, 1]            # n = 1: four in a, two in b, etc\\n        for _ in range(n-1):        # iterate n-1 times (since we start at n=1)\\n            a,b,c,d  = v\\n            v = [(2*b+2*c)%N, (a+2*d)%N, a, b]\\n        return sum(v)%N",
                "codeTag": "Java"
            },
            {
                "id": 1594768,
                "title": "easy-recursion-solutinon-cpp-memoziation",
                "content": "**UPVOTE ME IF THIS IS HELPFULL AND COMMENT FOR DOUBTS \\nTHIS SIDE MOHIT.KOTA || HAPPY CODING TO ALL CODERS **\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long solve(int x,int y,int n,long hash[][4][3])\\n    { \\n        // checking whether the postion is a valid postion or not \\n        if(x<0 || y<0 || x>=4 || y>=3 || (x==3 && y==0)||(x==3 &&y==2))\\n        {\\n            return 0;\\n        }\\n        if(n==1)  // if n==1 then we can only move 1 step so return the same \\n        {\\n            return 1;\\n        }\\n        if(hash[n][x][y]>0) // taking hash as 3D array which helps to store previous result \\n        {\\n            // if it exists we can just return the same \\n            return hash[n][x][y];\\n        }\\n        int mod=1000000007; //to make sure that our answer is in range  \\n        /*\\n                    this below step is crucial one because we have only \\n                    8 direction\\'s to move to any other cell/in keypad so\\n                    just check that below one you can get a clear cut note \\\\\\n                    what i was doing ;;\\n                    just take a paper and pen and try to observe the step\\'s \\n                    you can get it easily\\'\\'\\'             \\n        */\\n        long ans= solve(x-1,y+2,n-1,hash)%mod+ \\n            solve(x+1,y+2,n-1,hash)%mod+\\n            solve(x-1,y-2,n-1,hash)%mod+\\n            solve(x+1,y-2,n-1,hash)%mod+\\n            solve(x+2,y+1,n-1,hash)%mod+\\n            solve(x+2,y-1,n-1,hash)%mod+\\n            solve(x-2,y+1,n-1,hash)%mod+\\n            solve(x-2,y-1,n-1,hash)%mod;\\n        hash[n][x][y]=ans;\\n        \\n        return ans%mod;\\n            \\n    }   \\n    int knightDialer(int n) \\n    {\\n        long hash[n+1][4][3];\\n        memset(hash,0,sizeof(hash)); //making the arr to zeroes\\n        long ans = 0;\\n        int mod = 1000000007;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                ans = (ans+solve(i,j,n,hash))%mod;   // calculating answere for every cell \\n            }\\n        }\\n        return (ans)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long solve(int x,int y,int n,long hash[][4][3])\\n    { \\n        // checking whether the postion is a valid postion or not \\n        if(x<0 || y<0 || x>=4 || y>=3 || (x==3 && y==0)||(x==3 &&y==2))\\n        {\\n            return 0;\\n        }\\n        if(n==1)  // if n==1 then we can only move 1 step so return the same \\n        {\\n            return 1;\\n        }\\n        if(hash[n][x][y]>0) // taking hash as 3D array which helps to store previous result \\n        {\\n            // if it exists we can just return the same \\n            return hash[n][x][y];\\n        }\\n        int mod=1000000007; //to make sure that our answer is in range  \\n        /*\\n                    this below step is crucial one because we have only \\n                    8 direction\\'s to move to any other cell/in keypad so\\n                    just check that below one you can get a clear cut note \\\\\\n                    what i was doing ;;\\n                    just take a paper and pen and try to observe the step\\'s \\n                    you can get it easily\\'\\'\\'             \\n        */\\n        long ans= solve(x-1,y+2,n-1,hash)%mod+ \\n            solve(x+1,y+2,n-1,hash)%mod+\\n            solve(x-1,y-2,n-1,hash)%mod+\\n            solve(x+1,y-2,n-1,hash)%mod+\\n            solve(x+2,y+1,n-1,hash)%mod+\\n            solve(x+2,y-1,n-1,hash)%mod+\\n            solve(x-2,y+1,n-1,hash)%mod+\\n            solve(x-2,y-1,n-1,hash)%mod;\\n        hash[n][x][y]=ans;\\n        \\n        return ans%mod;\\n            \\n    }   \\n    int knightDialer(int n) \\n    {\\n        long hash[n+1][4][3];\\n        memset(hash,0,sizeof(hash)); //making the arr to zeroes\\n        long ans = 0;\\n        int mod = 1000000007;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                ans = (ans+solve(i,j,n,hash))%mod;   // calculating answere for every cell \\n            }\\n        }\\n        return (ans)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270845,
                "title": "python-o-logn-100-with-explanation",
                "content": "I used to ask this question for virtually every phone screen, so I\\'ve seen this done well over a hundred times at this point. I also know the absolute *best* solution for it and this is it.\\n- create a numpy matrix representing 1 move\\n- we subtract 1 from `n` because the the number of moves is the length of the string minus 1\\n- multiplying that move matrix by itself represents 2 moves\\n- doing that `n` times, represents `2**n` moves\\n- we initialize our answer as a `1x10` vector of ones (ie one move on each square)\\n- for each power of 2, if that power of 2 is in `n`, we add it to our answer\\n- then we create the next power of 2 by multiplying it by itself\\n- we also mod by `10**9 + 7` because the question says so\\n```\\nimport numpy as np\\nMOD = (10**9 + 7)\\noneMove = np.zeros((10, 10), dtype=np.int64)\\nfor i, j in ((1, 8), (1, 6), (2, 7), (2, 9), (3, 4), (3, 8), (4, 9), (4, 0), (6, 7), (6, 0)):\\n    oneMove[i][j] = 1\\n    oneMove[j][i] = 1\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        n -= 1\\n        currMove = oneMove\\n        sumMoves = np.ones((10,), dtype=np.int64)\\n        while n > 0:\\n            if n & 1:\\n                sumMoves = np.matmul(sumMoves, currMove)\\n                sumMoves = np.mod(sumMoves, MOD)\\n            n >>= 1\\n            if n > 0:\\n                currMove = np.matmul(currMove, currMove)\\n                currMove = np.mod(currMove, MOD)\\n        return np.sum(sumMoves) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nMOD = (10**9 + 7)\\noneMove = np.zeros((10, 10), dtype=np.int64)\\nfor i, j in ((1, 8), (1, 6), (2, 7), (2, 9), (3, 4), (3, 8), (4, 9), (4, 0), (6, 7), (6, 0)):\\n    oneMove[i][j] = 1\\n    oneMove[j][i] = 1\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        n -= 1\\n        currMove = oneMove\\n        sumMoves = np.ones((10,), dtype=np.int64)\\n        while n > 0:\\n            if n & 1:\\n                sumMoves = np.matmul(sumMoves, currMove)\\n                sumMoves = np.mod(sumMoves, MOD)\\n            n >>= 1\\n            if n > 0:\\n                currMove = np.matmul(currMove, currMove)\\n                currMove = np.mod(currMove, MOD)\\n        return np.sum(sumMoves) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399690,
                "title": "10-lines-super-concise-java-solution-beat-98-in-speed-with-explanation",
                "content": "There is no need to do DP for each specific digit. Classifying them into different sets.\\n\\n```\\npublic int knightDialer(int N) {\\n\\t// In total, 10 digits can be classified into four sets: A: {1,3,7,9}, B: {4,6}, C: {2,8}, D: {0}. \\n\\t// The digits within the same set are symmetric and hence no need to further distinguish them.\\n\\t// s(n) = 4*a(n) + 2*b(n) + 2*c(n) + d(n); s(n) means total number of distinct numbers\\n\\t//     E.g. a(n) means total number of distinct numbers when starting with numbers in set A.\\n\\t// Recursive formula: a(n) = b(n-1) + c(n-1); b(n) = 2*a(n-1) + d(n-1); c(n) = 2*a(n-1); d(n) = 2*b(n-1);\\n\\t// Base case: n = 1 -> a=b=c=d=1\\n\\tif (N == 1) return 10;\\n\\tlong a=1L, b=1L, c=1L, d=1L; // N=1 base case\\n\\tlong na, nb, nc, nd;\\n\\tfor (int i = 2; i <= N; i++) {\\n\\t\\tna = b + c;\\n\\t\\tnb = 2 * a + d;\\n\\t\\tnc = 2 * a;\\n\\t\\tnd = 2 * b;\\n\\t\\ta = na % (1000000007L); b = nb % (1000000007L); c = nc % (1000000007L); d = nd % (1000000007L);\\n\\t}\\n\\treturn (int)((4 * a + 2 * b + 2 * c + d) % (1000000007L));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int knightDialer(int N) {\\n\\t// In total, 10 digits can be classified into four sets: A: {1,3,7,9}, B: {4,6}, C: {2,8}, D: {0}. \\n\\t// The digits within the same set are symmetric and hence no need to further distinguish them.\\n\\t// s(n) = 4*a(n) + 2*b(n) + 2*c(n) + d(n); s(n) means total number of distinct numbers\\n\\t//     E.g. a(n) means total number of distinct numbers when starting with numbers in set A.\\n\\t// Recursive formula: a(n) = b(n-1) + c(n-1); b(n) = 2*a(n-1) + d(n-1); c(n) = 2*a(n-1); d(n) = 2*b(n-1);\\n\\t// Base case: n = 1 -> a=b=c=d=1\\n\\tif (N == 1) return 10;\\n\\tlong a=1L, b=1L, c=1L, d=1L; // N=1 base case\\n\\tlong na, nb, nc, nd;\\n\\tfor (int i = 2; i <= N; i++) {\\n\\t\\tna = b + c;\\n\\t\\tnb = 2 * a + d;\\n\\t\\tnc = 2 * a;\\n\\t\\tnd = 2 * b;\\n\\t\\ta = na % (1000000007L); b = nb % (1000000007L); c = nc % (1000000007L); d = nd % (1000000007L);\\n\\t}\\n\\treturn (int)((4 * a + 2 * b + 2 * c + d) % (1000000007L));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338833,
                "title": "c-top-down-with-memo-o-n-easy",
                "content": "**Intuition:** Think of every number as a state (0 to 9). You can move from one state to another just like a knight moves on a chessboard. This information is enough to find the states you can go to from a given state. You can start from any state.\\n\\nI stored the state information in a 2D vector. Now, when I start on a state, I know exactly where all I can go with the help of the 2D vector. When I move from one state to another I reduce N by 1.\\n\\nSolve the question using recursion first. You\\'ll find your solution TLE before N = 16 or so.\\nDraw the recursion tree, you\\'ll find that it has overlapping subproblems, so memoize them.\\n\\nCODE:\\n\\n```\\nvector<vector<int>> states = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\nint knh(int state, int n, vector<vector<int>> &dp){\\nif(n == 0) return 1; // base case\\nint total = 0;\\n\\nif(dp[state][n] != -1)\\nreturn dp[state][n]; //using memo table\\n\\nfor(int j = 0 ; j < states[state].size() ; j++) // for going through all states you can go\\n    total = (total + knh(states[state][j],n-1,dp)) %1000000007 ; // to from the current state\\n\\nreturn dp[state][n] = total; //memoize\\n}\\n\\nint kn(int n)\\n{\\n    vector<vector<int>> dp (10, vector<int>(n,-1));\\n    int ans = 0;\\n    for(int i = 0 ; i <= 9 ; i++) // As you can start from any state (between 0 to 9)\\n        ans = (ans + knh(i,n-1,dp))%1000000007; \\n    return ans;\\n}\\n     \\n    int knightDialer(int N) {\\n        return kn(N);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvector<vector<int>> states = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\nint knh(int state, int n, vector<vector<int>> &dp){\\nif(n == 0) return 1; // base case\\nint total = 0;\\n\\nif(dp[state][n] != -1)\\nreturn dp[state][n]; //using memo table\\n\\nfor(int j = 0 ; j < states[state].size() ; j++) // for going through all states you can go\\n    total = (total + knh(states[state][j],n-1,dp)) %1000000007 ; // to from the current state\\n\\nreturn dp[state][n] = total; //memoize\\n}\\n\\nint kn(int n)\\n{\\n    vector<vector<int>> dp (10, vector<int>(n,-1));\\n    int ans = 0;\\n    for(int i = 0 ; i <= 9 ; i++) // As you can start from any state (between 0 to 9)\\n        ans = (ans + knh(i,n-1,dp))%1000000007; \\n    return ans;\\n}\\n     \\n    int knightDialer(int N) {\\n        return kn(N);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189232,
                "title": "python-o-n",
                "content": "```\nclass Solution:\n    def knightDialer(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        \n        # N == 1 is special because it is the only instance where 5 can be used in any hop sequence\n        if N == 1:\n            return 10\n        \n        # current number of hops that end in index i, skip 5 because it is terminal\n        ends_in = [0 if i == 5 else 1 for i in range(10)]\n        \n        mod = (10**9 + 7)\n        \n        for i in range(1, N):\n            # compute how many times we can be at each number for the next iteration\n            next_ends_in = [0 for _ in range(10)]\n            next_ends_in[0] = ends_in[4] + ends_in[6] % mod\n            next_ends_in[1] = ends_in[6] + ends_in[8] % mod\n            next_ends_in[2] = ends_in[7] + ends_in[9] % mod\n            next_ends_in[3] = ends_in[4] + ends_in[8] % mod\n            next_ends_in[4] = ends_in[3] + ends_in[9] + ends_in[0] % mod\n            # skip 5 because we can never get to it\n            next_ends_in[6] = ends_in[1] + ends_in[7] + ends_in[0] % mod\n            next_ends_in[7] = ends_in[2] + ends_in[6] % mod\n            next_ends_in[8] = ends_in[1] + ends_in[3] % mod\n            next_ends_in[9] = ends_in[2] + ends_in[4] % mod\n            ends_in = next_ends_in\n        \n        return sum(ends_in) % mod\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def knightDialer(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        \n        # N == 1 is special because it is the only instance where 5 can be used in any hop sequence\n        if N == 1:\n            return 10\n        \n        # current number of hops that end in index i, skip 5 because it is terminal\n        ends_in = [0 if i == 5 else 1 for i in range(10)]\n        \n        mod = (10**9 + 7)\n        \n        for i in range(1, N):\n            # compute how many times we can be at each number for the next iteration\n            next_ends_in = [0 for _ in range(10)]\n            next_ends_in[0] = ends_in[4] + ends_in[6] % mod\n            next_ends_in[1] = ends_in[6] + ends_in[8] % mod\n            next_ends_in[2] = ends_in[7] + ends_in[9] % mod\n            next_ends_in[3] = ends_in[4] + ends_in[8] % mod\n            next_ends_in[4] = ends_in[3] + ends_in[9] + ends_in[0] % mod\n            # skip 5 because we can never get to it\n            next_ends_in[6] = ends_in[1] + ends_in[7] + ends_in[0] % mod\n            next_ends_in[7] = ends_in[2] + ends_in[6] % mod\n            next_ends_in[8] = ends_in[1] + ends_in[3] % mod\n            next_ends_in[9] = ends_in[2] + ends_in[4] % mod\n            ends_in = next_ends_in\n        \n        return sum(ends_in) % mod\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856954,
                "title": "easy-implementation-using-recursion-and-memoization-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long dp[5004][10];\\n    vector<vector<int>>vv = { {4,6},{8,6},{7,9},{8,4},{3,9,0},{},{1,7,0},{6,2},{1,3},{2,4} };\\n    long long solve(int dig, int n){\\n        if(n == 0) return 1;\\n        if(dp[n][dig] != -1) return dp[n][dig];\\n        long long ans = 0;\\n        for(auto d : vv[dig]){\\n            ans += solve(d,n-1);\\n            ans = ans%mod;\\n        }\\n        return dp[n][dig] = ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = 0;\\n        for(int i=0; i<=9; i++){\\n            if(i == 5) continue;\\n            ans += solve(i,n-1)%mod;\\n            ans = ans%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n\\n/**\\n0 --> 4,6\\n1 --> 8,6\\n2 --> 7,9\\n3 --> 8,4\\n4 --> 3,9,0\\n5 --> \\n6 --> 1,7,0\\n7 --> 6,2\\n8 --> 1,3\\n9 --> 2,4\\n**/\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long dp[5004][10];\\n    vector<vector<int>>vv = { {4,6},{8,6},{7,9},{8,4},{3,9,0},{},{1,7,0},{6,2},{1,3},{2,4} };\\n    long long solve(int dig, int n){\\n        if(n == 0) return 1;\\n        if(dp[n][dig] != -1) return dp[n][dig];\\n        long long ans = 0;\\n        for(auto d : vv[dig]){\\n            ans += solve(d,n-1);\\n            ans = ans%mod;\\n        }\\n        return dp[n][dig] = ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = 0;\\n        for(int i=0; i<=9; i++){\\n            if(i == 5) continue;\\n            ans += solve(i,n-1)%mod;\\n            ans = ans%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n\\n/**\\n0 --> 4,6\\n1 --> 8,6\\n2 --> 7,9\\n3 --> 8,4\\n4 --> 3,9,0\\n5 --> \\n6 --> 1,7,0\\n7 --> 6,2\\n8 --> 1,3\\n9 --> 2,4\\n**/\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358333,
                "title": "dp-solution-easy-to-undersatnd-recursion-memoization",
                "content": "```\\nlong long mod = 1e9+7;\\nint dx[] = {2,2,1,1,-2,-2,-1,-1};\\nint dy[] = {1,-1,2,-2,1,-1,2,-2};\\nint dp[5][4][5002];\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& nums,int i ,int j,int n)\\n    {\\n       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;\\n        if(n==0)return 1;\\n        auto &t = dp[i][j][n];\\n        if(t!=-1)return t;\\n        int ans =0;\\n        for(int k=0;k<8;k++)\\n        {\\n            int x = dx[k]+i;\\n            int y = dy[k]+j;\\n            ans= (ans+f(nums,x,y,n-1))%mod;\\n        }\\n        return t =  ans%mod;\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>> nums(4,vector<int>(3,-1));\\n        memset(dp,-1,sizeof(dp));\\n        int x=1;\\n         nums[3][1] = 0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                nums[i][j] = x;\\n                x++;\\n            }\\n        }\\n      int ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(nums[i][j]!=-1)\\n                {\\n                    ans=(ans+f(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlong long mod = 1e9+7;\\nint dx[] = {2,2,1,1,-2,-2,-1,-1};\\nint dy[] = {1,-1,2,-2,1,-1,2,-2};\\nint dp[5][4][5002];\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& nums,int i ,int j,int n)\\n    {\\n       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;\\n        if(n==0)return 1;\\n        auto &t = dp[i][j][n];\\n        if(t!=-1)return t;\\n        int ans =0;\\n        for(int k=0;k<8;k++)\\n        {\\n            int x = dx[k]+i;\\n            int y = dy[k]+j;\\n            ans= (ans+f(nums,x,y,n-1))%mod;\\n        }\\n        return t =  ans%mod;\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>> nums(4,vector<int>(3,-1));\\n        memset(dp,-1,sizeof(dp));\\n        int x=1;\\n         nums[3][1] = 0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                nums[i][j] = x;\\n                x++;\\n            }\\n        }\\n      int ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(nums[i][j]!=-1)\\n                {\\n                    ans=(ans+f(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285446,
                "title": "python-top-down-and-bottom-up-approach-following-intuition",
                "content": "# Approach\\nConsider all 8 positions knight can jump from current position in a grid of 4x3 in which all positions are valid except cell (3, 0) and (3, 2).\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n**NOTE:** Above complexity has some contants also `3 * 4 * 8 = 96` so it\\'s actually `O(96*n)`\\n\\n# Code\\n## 1. Top down with memoization\\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\ndef isInvalid(r, c):\\n    if r >= 4 or c >= 3 or r < 0 or c < 0:\\n        return True\\n    if (r, c) in [(3, 0), (3, 2)]:\\n        return True\\n    return False\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        cache = {}\\n        def countPhoneNumbers(r, c, l):\\n            if isInvalid(r, c):\\n                return 0\\n            if n == l:\\n                return 1\\n            if (r, c, l) in cache:\\n                return cache[(r, c, l)]\\n            v = 0\\n            for r0, c0 in pos:\\n                v += countPhoneNumbers(\\n                    r + r0, c + c0, l + 1)\\n            cache[(r, c, l)] = v\\n            return cache[(r, c, l)] % 1000000007\\n\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += countPhoneNumbers(r, c, 1)\\n        return res % 1000000007\\n```\\n\\n## 2. Bottom up\\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [[[0 for _ in range(n + 1)] for _ in range(3)] for _ in range(4)]\\n\\n        for r in range(4):\\n            for c in range(3):\\n                if (r, c) not in [(3, 0), (3, 2)]:\\n                    dp[r][c][1] = 1\\n\\n        for l in range(2, n + 1):\\n            for r in range(4):\\n                for c in range(3):\\n                    if (r, c) in [(3, 0), (3, 2)]:\\n                        continue\\n                    for r0, c0 in pos:\\n                        nr = r - r0\\n                        nc = c - c0\\n                        if nr >= 0 and nr < 4 and nc >= 0 and nc < 3:\\n                            dp[r][c][l] += dp[nr][nc][l - 1]\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += dp[r][c][n]\\n        return res % 1000000007\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\ndef isInvalid(r, c):\\n    if r >= 4 or c >= 3 or r < 0 or c < 0:\\n        return True\\n    if (r, c) in [(3, 0), (3, 2)]:\\n        return True\\n    return False\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        cache = {}\\n        def countPhoneNumbers(r, c, l):\\n            if isInvalid(r, c):\\n                return 0\\n            if n == l:\\n                return 1\\n            if (r, c, l) in cache:\\n                return cache[(r, c, l)]\\n            v = 0\\n            for r0, c0 in pos:\\n                v += countPhoneNumbers(\\n                    r + r0, c + c0, l + 1)\\n            cache[(r, c, l)] = v\\n            return cache[(r, c, l)] % 1000000007\\n\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += countPhoneNumbers(r, c, 1)\\n        return res % 1000000007\\n```\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [[[0 for _ in range(n + 1)] for _ in range(3)] for _ in range(4)]\\n\\n        for r in range(4):\\n            for c in range(3):\\n                if (r, c) not in [(3, 0), (3, 2)]:\\n                    dp[r][c][1] = 1\\n\\n        for l in range(2, n + 1):\\n            for r in range(4):\\n                for c in range(3):\\n                    if (r, c) in [(3, 0), (3, 2)]:\\n                        continue\\n                    for r0, c0 in pos:\\n                        nr = r - r0\\n                        nc = c - c0\\n                        if nr >= 0 and nr < 4 and nc >= 0 and nc < 3:\\n                            dp[r][c][l] += dp[nr][nc][l - 1]\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += dp[r][c][n]\\n        return res % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761128,
                "title": "python-dp-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [1] * 10\\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],\\n                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]\\n        for _ in range(n-1):\\n            dp_next = [0] * 10\\n            for digit in range(10):\\n                for move_digit in moves[digit]:\\n                    dp_next[digit] += dp[move_digit]\\n                    \\n            dp = dp_next\\n        \\n        return sum(dp) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [1] * 10\\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],\\n                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]\\n        for _ in range(n-1):\\n            dp_next = [0] * 10\\n            for digit in range(10):\\n                for move_digit in moves[digit]:\\n                    dp_next[digit] += dp[move_digit]\\n                    \\n            dp = dp_next\\n        \\n        return sum(dp) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437317,
                "title": "c-easy-top-down-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long int mod=1000000007;\\n\\t\\t\\tvector<long long int>dp(10);\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tdp[i]=1;\\n\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\tvector<long long int>old_dp(10);\\n\\t\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\t\\told_dp[i]=dp[i];\\n\\t\\t\\t\\tdp[0]=(old_dp[6]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t\\tdp[1]=(old_dp[6]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[2]=(old_dp[7]%mod+old_dp[9]%mod)%mod;\\n\\t\\t\\t\\tdp[3]=(old_dp[4]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[4]=(old_dp[3]%mod+old_dp[9]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[5]=0;\\n\\t\\t\\t\\tdp[6]=(old_dp[7]%mod+old_dp[1]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[7]=(old_dp[2]%mod+old_dp[6]%mod)%mod;\\n\\t\\t\\t\\tdp[8]=(old_dp[1]%mod+old_dp[3]%mod)%mod;\\n\\t\\t\\t\\tdp[9]=(old_dp[2]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t}\\n\\t\\t\\tlong long int ans=0;\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tans+=(dp[i]%mod);\\n\\t\\t\\tans%=mod;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long int mod=1000000007;\\n\\t\\t\\tvector<long long int>dp(10);\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tdp[i]=1;\\n\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\tvector<long long int>old_dp(10);\\n\\t\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\t\\told_dp[i]=dp[i];\\n\\t\\t\\t\\tdp[0]=(old_dp[6]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t\\tdp[1]=(old_dp[6]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[2]=(old_dp[7]%mod+old_dp[9]%mod)%mod;\\n\\t\\t\\t\\tdp[3]=(old_dp[4]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[4]=(old_dp[3]%mod+old_dp[9]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[5]=0;\\n\\t\\t\\t\\tdp[6]=(old_dp[7]%mod+old_dp[1]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[7]=(old_dp[2]%mod+old_dp[6]%mod)%mod;\\n\\t\\t\\t\\tdp[8]=(old_dp[1]%mod+old_dp[3]%mod)%mod;\\n\\t\\t\\t\\tdp[9]=(old_dp[2]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2287071,
                "title": "java-dynamic-programming-explanation-in-comments",
                "content": "class Solution {\\n    \\n    /* DP:\\n    \\n    ex n=2;\\n    \\n        0   1   2   3   4   5   6   7   8   9\\n        \\n    0   0   0   0   0   0   0   0   0   0   0\\n    \\n    1   1   1   1   1   1   1   1   1   1   1\\n\\n    2   2   2   2   2   3   0   3   2   2   2\\n    \\n    3   6   5   4   5   6   0   6   5   4   5\\n    \\n    \\n    In the above matrix, the columns indicate each digit on key pad.\\n    Rows indicate number of steps.\\n    \\n    So for (1,1) will indicate number of ways the knight can land on digit 1 in 1 step. It is going to be 1.\\n    because you have 1 step and knight will directly be on 1.\\n    \\n    (2,3) will indicate number of ways the knight can land on digit 3 in 2 steps. It is going to be 2 i.e., from     8 and 4.\\n    \\n    (3,4) indicates number of ways the knight can land on digit 4 in 3 steps. Here we will need to add (2,0) ,\\n    (2,3) and (2,9) because knight can reach 4 from all these places(0,3,9) in 1 step. but we need to count how\\n    we got to all these places in two steps and so on.\\n    \\n    So \\n    Answer is going to be sum of all digits in nth row.\\n    */\\n    \\n    public int knightDialer(int n) {\\n        int mod = 1000000007;\\n        int[][] paths = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[n+1][10];\\n        \\n        for(int i=0;i<10;i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        \\n        int sum = 0;\\n        for(int i=2;i<n+1;i++){\\n            for(int j=0; j<10; j++){\\n                for(int k =0;k<paths[j].length;k++){\\n                    int y = paths[j][k];\\n                    dp[i][j] += dp[i-1][y];\\n\\t\\t\\t\\t\\t// if this gets too big we mod it per problem description\\n                    dp[i][j] = dp[i][j] % mod;\\n                }        \\n            }\\n        }\\n        \\n        for(int j=0;j<10;j++){\\n            sum+=dp[n][j];\\n\\t\\t\\t// if this gets too big we mod it per problem description\\n            sum = sum % mod;\\n        }\\n        return sum;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\n    \\n    /* DP:\\n    \\n    ex n=2;\\n    \\n        0   1   2   3   4   5   6   7   8   9\\n        \\n    0   0   0   0   0   0   0   0   0   0   0\\n    \\n    1   1   1   1   1   1   1   1   1   1   1\\n\\n    2   2   2   2   2   3   0   3   2   2   2\\n    \\n    3   6   5   4   5   6   0   6   5   4   5\\n    \\n    \\n    In the above matrix, the columns indicate each digit on key pad.\\n    Rows indicate number of steps.\\n    \\n    So for (1,1) will indicate number of ways the knight can land on digit 1 in 1 step. It is going to be 1.\\n    because you have 1 step and knight will directly be on 1.\\n    \\n    (2,3) will indicate number of ways the knight can land on digit 3 in 2 steps. It is going to be 2 i.e., from     8 and 4.\\n    \\n    (3,4) indicates number of ways the knight can land on digit 4 in 3 steps. Here we will need to add (2,0) ,\\n    (2,3) and (2,9) because knight can reach 4 from all these places(0,3,9) in 1 step. but we need to count how\\n    we got to all these places in two steps and so on.\\n    \\n    So \\n    Answer is going to be sum of all digits in nth row.\\n    */\\n    \\n    public int knightDialer(int n) {\\n        int mod = 1000000007;\\n        int[][] paths = {{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 2241874,
                "title": "c-recursive-dp-solution-easy-to-understand",
                "content": "We simply recurse through all the possible scenarios, and store the reuslt in a dp array, so that we do not have to recalculate moves that we have already gone through. \\nFor example, \\nfor n = 3. We will consider all the numbers on the numberpad.\\nlets consider 2 paths - from number 0, and from number 3.\\nas we can see, in both the cases we will have to calculate the number of moves for n = 2 and number = 4. (since 3 and 0 both can lead to 4 by the horse). \\nthus to avoid recalculation, we will use the dp array. \\n```\\nvector <vector<int>> dp(5001, vector <int> (10, -1));\\nvector <vector<int>> reference(10);\\n\\nint MOD = 1000000007;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector <int> states(10);\\n        int ans = 0;\\n        reference[0] = {4,6};\\n        reference[1] = {8,6};\\n        reference[2] = {7,9};\\n        reference[3] = {4,8};\\n        reference[4] = {3,9,0};\\n        reference[5] = {};\\n        reference[6] = {1,7,0};\\n        reference[7] = {6,2};\\n        reference[8] = {1,3};\\n        reference[9] = {4,2};\\n        n--;\\n        if (n == 0) return 10;\\n        cout << MOD;\\n        for (int i = 0; i < 10; i++) {\\n            if (i == 5) continue;\\n            ans = (ans % MOD + solution(n, i) % MOD) % MOD;\\n        }\\n        return ans % MOD;\\n    }\\n    \\n    int solution(int n, int start) {\\n        //cout << \"YES\";\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[n][start] == -1) {\\n            dp[n][start] = 0;\\n            for (int i = 0; i < reference[start].size(); i++) {\\n                //cout << n << \" \"  << start << \" \" << dp[n][start] << \" \" << \"\\\\n\";\\n                dp[n][start] = (dp[n][start] % MOD + solution(n - 1, reference[start][i]) % MOD) % MOD;\\n                dp[n][start] = dp[n][start] % MOD;\\n            }\\n        }        \\n        return dp[n][start] % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nvector <vector<int>> dp(5001, vector <int> (10, -1));\\nvector <vector<int>> reference(10);\\n\\nint MOD = 1000000007;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector <int> states(10);\\n        int ans = 0;\\n        reference[0] = {4,6};\\n        reference[1] = {8,6};\\n        reference[2] = {7,9};\\n        reference[3] = {4,8};\\n        reference[4] = {3,9,0};\\n        reference[5] = {};\\n        reference[6] = {1,7,0};\\n        reference[7] = {6,2};\\n        reference[8] = {1,3};\\n        reference[9] = {4,2};\\n        n--;\\n        if (n == 0) return 10;\\n        cout << MOD;\\n        for (int i = 0; i < 10; i++) {\\n            if (i == 5) continue;\\n            ans = (ans % MOD + solution(n, i) % MOD) % MOD;\\n        }\\n        return ans % MOD;\\n    }\\n    \\n    int solution(int n, int start) {\\n        //cout << \"YES\";\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[n][start] == -1) {\\n            dp[n][start] = 0;\\n            for (int i = 0; i < reference[start].size(); i++) {\\n                //cout << n << \" \"  << start << \" \" << dp[n][start] << \" \" << \"\\\\n\";\\n                dp[n][start] = (dp[n][start] % MOD + solution(n - 1, reference[start][i]) % MOD) % MOD;\\n                dp[n][start] = dp[n][start] % MOD;\\n            }\\n        }        \\n        return dp[n][start] % MOD;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2169422,
                "title": "java-dp-graph-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    final int LIMIT = (int)Math.pow(10, 9) + 7;\\n    \\n    final int[][] moves = new int[][] {\\n        { 4, 6 },    // 0\\n        { 6, 8 },    // 1\\n        { 7, 9 },    // 2\\n        { 4, 8 },    // 3\\n        { 3, 9, 0 }, // 4\\n        { },         // 5\\n        { 1, 7, 0 }, // 6\\n        { 2, 6 },    // 7\\n        { 1, 3 },    // 8\\n        { 2, 4 },    // 9\\n    };\\n    \\n    public int knightDialer(int n) {\\n        long[] prev = new long[10];\\n        for (int i = 0 ; i < 10; i++) {\\n            prev[i] = 1;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            long[] curr = new long[10];\\n            for (int v = 0; v < 10; v++) {\\n                for (int u : moves[v]) {\\n                    curr[u] = (curr[u] + prev[v]) % LIMIT; \\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        long total = 0;\\n        for (int i = 0; i < 10; i++) {\\n            total = (total + prev[i]) % LIMIT;\\n        }\\n        return (int) (total % LIMIT);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    final int LIMIT = (int)Math.pow(10, 9) + 7;\\n    \\n    final int[][] moves = new int[][] {\\n        { 4, 6 },    // 0\\n        { 6, 8 },    // 1\\n        { 7, 9 },    // 2\\n        { 4, 8 },    // 3\\n        { 3, 9, 0 }, // 4\\n        { },         // 5\\n        { 1, 7, 0 }, // 6\\n        { 2, 6 },    // 7\\n        { 1, 3 },    // 8\\n        { 2, 4 },    // 9\\n    };\\n    \\n    public int knightDialer(int n) {\\n        long[] prev = new long[10];\\n        for (int i = 0 ; i < 10; i++) {\\n            prev[i] = 1;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            long[] curr = new long[10];\\n            for (int v = 0; v < 10; v++) {\\n                for (int u : moves[v]) {\\n                    curr[u] = (curr[u] + prev[v]) % LIMIT; \\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        long total = 0;\\n        for (int i = 0; i < 10; i++) {\\n            total = (total + prev[i]) % LIMIT;\\n        }\\n        return (int) (total % LIMIT);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668711,
                "title": "python3-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dct={1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\\n        dp=[1]*10\\n        for _ in range(n-1):\\n            new=[0]*10\\n            for el in dct:\\n                for num in dct[el]:\\n                    new[num]+=dp[el]\\n            dp=new\\n        return sum(dp)%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dct={1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\\n        dp=[1]*10\\n        for _ in range(n-1):\\n            new=[0]*10\\n            for el in dct:\\n                for num in dct[el]:\\n                    new[num]+=dp[el]\\n            dp=new\\n        return sum(dp)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549261,
                "title": "python-simple-top-down-approach-recursion-with-memoization",
                "content": "1. Construct a matrix to represent a dialer.\\n2. Defined in valid cells for entry.\\n3. Create helper function to return valid jumps.\\n4. Iterate over the each cell and find the possible numbers and add them.\\n\\n\\n\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.mat = [[1, 2, 3], [4,5,6], [7,8,9], [\\'*\\', 0, \\'#\\']]\\n        self.nrows = len(self.mat)\\n        self.ncols = len(self.mat[0])\\n        self.in_valid = set([(3,0), (3,2)])\\n    \\n    def valid_jumps(self, row, col):\\n        valid = []\\n        for r_inc, c_inc in [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1,-2), (-1, -2)]:\\n            n_row, n_col = row + r_inc, col + c_inc\\n            if 0<= n_row < self.nrows and 0 <= n_col < self.ncols and (n_row, n_col) not in self.in_valid:\\n                valid.append((n_row, n_col))\\n        return valid\\n    \\n    def recursive_dialer(self, row, col, jumps, cache):\\n        if jumps == 0: return 1\\n        if (row,col, jumps) in cache: return cache[(row, col, jumps)]\\n        max_number = 0\\n        \\n        for n_row, n_col in self.valid_jumps(row, col):\\n            ret = self.recursive_dialer(n_row, n_col, jumps-1, cache)\\n            max_number += ret\\n        \\n        cache[(row, col, jumps)] = max_number\\n        \\n        return cache[(row, col, jumps)]\\n    \\n    def knightDialer(self, n: int) -> int:\\n        max_number = 0\\n        if n == 0: return max_number\\n        cache = {}\\n        \\n        for row in range(self.nrows):\\n            for col in range(self.ncols):\\n                if (row, col) not in self.in_valid:\\n                    max_number += self.recursive_dialer(row, col, n-1, cache)\\n        \\n        return max_number % (10**9 + 7)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.mat = [[1, 2, 3], [4,5,6], [7,8,9], [\\'*\\', 0, \\'#\\']]\\n        self.nrows = len(self.mat)\\n        self.ncols = len(self.mat[0])\\n        self.in_valid = set([(3,0), (3,2)])\\n    \\n    def valid_jumps(self, row, col):\\n        valid = []\\n        for r_inc, c_inc in [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1,-2), (-1, -2)]:\\n            n_row, n_col = row + r_inc, col + c_inc\\n            if 0<= n_row < self.nrows and 0 <= n_col < self.ncols and (n_row, n_col) not in self.in_valid:\\n                valid.append((n_row, n_col))\\n        return valid\\n    \\n    def recursive_dialer(self, row, col, jumps, cache):\\n        if jumps == 0: return 1\\n        if (row,col, jumps) in cache: return cache[(row, col, jumps)]\\n        max_number = 0\\n        \\n        for n_row, n_col in self.valid_jumps(row, col):\\n            ret = self.recursive_dialer(n_row, n_col, jumps-1, cache)\\n            max_number += ret\\n        \\n        cache[(row, col, jumps)] = max_number\\n        \\n        return cache[(row, col, jumps)]\\n    \\n    def knightDialer(self, n: int) -> int:\\n        max_number = 0\\n        if n == 0: return max_number\\n        cache = {}\\n        \\n        for row in range(self.nrows):\\n            for col in range(self.ncols):\\n                if (row, col) not in self.in_valid:\\n                    max_number += self.recursive_dialer(row, col, n-1, cache)\\n        \\n        return max_number % (10**9 + 7)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031451,
                "title": "c-dfs-with-memoization-easiest-to-understand",
                "content": "Standard DFS + memo \\n```\\nclass Solution {\\npublic:\\n    int dp[5001][4][3] = {0}; \\n    int mod = 1000000007; \\n    int memo(int n, int i, int j){\\n        if(i<0 || j <0 || i>3 || j > 2 || (i ==3 && j == 0) || (i == 3 && j ==2)) return 0;\\n        if(n == 0) return 1; \\n        if(dp[n][i][j] > 0) return dp[n][i][j]; \\n        return dp[n][i][j] = (((((((\\n            memo(n-1, i+2, j-1)+ memo(n-1, i+2, j+1))%mod +memo(n-1, i-2, j-1))%mod+ \\n            memo(n-1, i-2, j+1))%mod + memo(n-1, i+1, j-2))%mod+ memo(n-1, i+1, j+2))%mod+ \\n            memo(n-1, i-1, j-2))%mod+  memo(n-1, i-1, j+2))%mod; \\n    }\\n    int knightDialer(int n) {\\n        int res = 0; \\n        for(int i=0; i<4; i++){\\n            for(int j =0; j<3; j++){\\n                res = (res+memo(n-1, i,j))%mod; \\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5001][4][3] = {0}; \\n    int mod = 1000000007; \\n    int memo(int n, int i, int j){\\n        if(i<0 || j <0 || i>3 || j > 2 || (i ==3 && j == 0) || (i == 3 && j ==2)) return 0;\\n        if(n == 0) return 1; \\n        if(dp[n][i][j] > 0) return dp[n][i][j]; \\n        return dp[n][i][j] = (((((((\\n            memo(n-1, i+2, j-1)+ memo(n-1, i+2, j+1))%mod +memo(n-1, i-2, j-1))%mod+ \\n            memo(n-1, i-2, j+1))%mod + memo(n-1, i+1, j-2))%mod+ memo(n-1, i+1, j+2))%mod+ \\n            memo(n-1, i-1, j-2))%mod+  memo(n-1, i-1, j+2))%mod; \\n    }\\n    int knightDialer(int n) {\\n        int res = 0; \\n        for(int i=0; i<4; i++){\\n            for(int j =0; j<3; j++){\\n                res = (res+memo(n-1, i,j))%mod; \\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809858,
                "title": "javascript-o-n-time-o-1-space",
                "content": "First solution:\\n```\\n/**\\ndp[count][digit] = ways\\n\\nfor count 1 -> n\\n  for digit 0 -> 9\\n    foreach move\\n      dp[ c ][ d ] += dp[ c - 1 ][ m ]\\n */\\n\\nconst moves = {\\n    0: [ 4, 6 ],\\n    1: [ 6, 8 ],\\n    2: [ 7, 9 ],\\n    3: [ 4, 8 ],\\n    4: [ 0, 3, 9 ],\\n    5: [],\\n    6: [ 0, 1, 7 ],\\n    7: [ 2, 6 ],\\n    8: [ 1, 3 ],\\n    9: [ 2, 4 ],\\n}\\n\\nconst knightDialer = n => {\\n    const dp = Array.from({ length: n + 1 }, (_,i) => Array(10).fill(i===1?1:0) )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count <= n; count++ )\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dp[ count ][ digit ] += dp[ count - 1 ][ move ] % mod )\\n \\n    return dp[ n ].reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n```\\n\\nOptimized for space:\\n```\\nconst knightDialer = n => {\\n    let dpp = Array(10).fill( 0 )\\n    let dpn = Array(10).fill( 1 )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count < n; count++ ) {\\n        const hold = dpp\\n        dpp = dpn\\n        dpn = hold.fill( 0 )\\n\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dpn[ digit ] += dpp[ move ] % mod )\\n    }\\n\\n    return dpn.reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\ndp[count][digit] = ways\\n\\nfor count 1 -> n\\n  for digit 0 -> 9\\n    foreach move\\n      dp[ c ][ d ] += dp[ c - 1 ][ m ]\\n */\\n\\nconst moves = {\\n    0: [ 4, 6 ],\\n    1: [ 6, 8 ],\\n    2: [ 7, 9 ],\\n    3: [ 4, 8 ],\\n    4: [ 0, 3, 9 ],\\n    5: [],\\n    6: [ 0, 1, 7 ],\\n    7: [ 2, 6 ],\\n    8: [ 1, 3 ],\\n    9: [ 2, 4 ],\\n}\\n\\nconst knightDialer = n => {\\n    const dp = Array.from({ length: n + 1 }, (_,i) => Array(10).fill(i===1?1:0) )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count <= n; count++ )\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dp[ count ][ digit ] += dp[ count - 1 ][ move ] % mod )\\n \\n    return dp[ n ].reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n```\n```\\nconst knightDialer = n => {\\n    let dpp = Array(10).fill( 0 )\\n    let dpn = Array(10).fill( 1 )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count < n; count++ ) {\\n        const hold = dpp\\n        dpp = dpn\\n        dpn = hold.fill( 0 )\\n\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dpn[ digit ] += dpp[ move ] % mod )\\n    }\\n\\n    return dpn.reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766418,
                "title": "very-easy-to-understand-o-n-c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint mod = 1e9 + 7;\\n\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tvector<vector<int>> paths = {\\n\\t\\t\\t\\t{4,6}, {6,8}, {7,9}, {4,8},\\n\\t\\t\\t\\t{3,9,0}, {}, {1,7,0},\\n\\t\\t\\t\\t{6,2}, {1,3}, {2,4},\\n\\t\\t\\t};\\n\\t\\t\\tvector<vector<int>> dp(N+1, vector<int>(10, 0));\\n\\n\\t\\t\\tfor(int i=0; i<10; i++)\\n\\t\\t\\t\\tdp[1][i] = 1;\\n\\n\\t\\t\\tfor(int i=2; i<=N; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0; j<10; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int x : paths[j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j] + dp[i-1][x]) % mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong res = 0;\\n\\t\\t\\tfor(int i=0; i<10; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres = (res + dp[N][i]) % mod;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint mod = 1e9 + 7;\\n\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tvector<vector<int>> paths = {\\n\\t\\t\\t\\t{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 764265,
                "title": "python3-6-line-116ms-solution-using-maths",
                "content": "OK, this is a very over-engineered solution, but I find it really interesting nonetheless.\\n\\nIf we look closely at the transition graph of our positions, we can notice that there are actually 4 distinct kinds of positions:\\n* Group 1: positions 8 and 2, which can only transition to group 2,\\n* Group 2: positions 1, 3, 7 and 9, which can either transition to group 1 or 3,\\n* Group 3: positions 4 and 6, which can either transition to group 2 or 4,\\n* Group 4: position 0, which can only transition to group 3.\\n\\nLet me draw a graph of the transitions to make that more clear:\\n\\n```\\n1 -- 8 -- 3\\n|         |\\n6 -- 0 -- 4\\n|         |\\n7 -- 2 -- 9\\n```\\n\\nNow, if we call `a_k`, `b_k`, `c_k`, `d_k` the number of numbers ending in each of our four groups after k jumps, we can write the recursive relation between our values:\\n\\n* `a_(k+1) = b_k`: each knight in group 2 has one way to move at jump k + 1 to a position in group 1,\\n* `b_(k+1) = 2 * (a_k + c_k)`: each knight in group 1 has two ways to move to group 2; similarly, each knight in group 3 has two ways to move to group 2; therefore, we must count twice the numbers from both groups,\\n* `c_(k+1) = b_k + 2 * d_k`: each knight in group 2 has one way to move to a position in group 3, and each knight in group 4 has two ways to move to a position in group 3,\\n* `d_(k+1) = c_k`: each knight in group 3 has one way to move to a position in group 4.\\n\\nThis lets us write a concise recursion formula. We simply have to apply the recursion `N - 1` times from the initial state.\\n\\nThe complexity is the same as the optimized dynamic programming solution, `O(n)` time `O(1)` space.\\n\\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def knightDialer(self, N: int) -> int:\\n        if N <= 1:\\n            return 10\\n        a, b, c, d = 2, 4, 2, 1\\n        for _ in range(N - 1):\\n            a, b, c, d = (b, 2 * (a + c) % self.BASE, (b + 2 * d) % self.BASE, c)\\n        return (a + b + c + d) % self.BASE\\n```",
                "solutionTags": [],
                "code": "```\\n1 -- 8 -- 3\\n|         |\\n6 -- 0 -- 4\\n|         |\\n7 -- 2 -- 9\\n```\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def knightDialer(self, N: int) -> int:\\n        if N <= 1:\\n            return 10\\n        a, b, c, d = 2, 4, 2, 1\\n        for _ in range(N - 1):\\n            a, b, c, d = (b, 2 * (a + c) % self.BASE, (b + 2 * d) % self.BASE, c)\\n        return (a + b + c + d) % self.BASE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343847,
                "title": "easy-peasy-python-o-n-solution",
                "content": "\\t\\tmv = { 0: [4, 6], 1 : [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]  }\\n        \\n        rs = [1]*10\\n        \\n        for i in range(N-1):\\n            tmp = [0]*10\\n            for j in range(10):\\n                for k in mv[j]:\\n                    tmp[j] += rs[k]\\n            \\n            rs = tmp\\n    \\n        return sum(rs) % ((10**9) + 7)",
                "solutionTags": [],
                "code": "\\t\\tmv = { 0: [4, 6], 1 : [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]  }\\n        \\n        rs = [1]*10\\n        \\n        for i in range(N-1):\\n            tmp = [0]*10\\n            for j in range(10):\\n                for k in mv[j]:\\n                    tmp[j] += rs[k]\\n            \\n            rs = tmp\\n    \\n        return sum(rs) % ((10**9) + 7)",
                "codeTag": "Unknown"
            },
            {
                "id": 189244,
                "title": "straightforward-dp-java",
                "content": "The count of values that can be generated from a given starting position with **N hops** == Sum of the counts of hops that can be generated starting from each of its neighbors with **N-1 hops.** \n\n```\nclass Solution {\n    private Map<String,Long> posHopCountMap;\n\n    private Map<Integer,Integer[]> neighbourMap;\n\n    private int mod = (int) (Math.pow(10,9)+7);\n\n    public int knightDialer(int N) {\n\n        posHopCountMap = new HashMap<>();\n        neighbourMap = new HashMap<>();\n\n        neighbourMap.put(0,new Integer[]{4,6});\n        neighbourMap.put(1,new Integer[]{6,8});\n        neighbourMap.put(2,new Integer[]{7,9});\n        neighbourMap.put(3,new Integer[]{4,8});\n        neighbourMap.put(4,new Integer[]{3,9,0});\n        neighbourMap.put(5,null);\n        neighbourMap.put(6,new Integer[]{1,7,0});\n        neighbourMap.put(7,new Integer[]{2,6});\n        neighbourMap.put(8,new Integer[]{1,3});\n        neighbourMap.put(9,new Integer[]{2,4});\n\n\n        long sum = 0;\n        for (int i=0;i<=9;i++) {\n            sum=(sum+getDistinctCount(i,N-1))%mod;\n        }\n\n        return (int)sum;\n\n    }\n\n    private long getDistinctCount(int pos,int count) {\n        if(count==0) {\n            return 1;\n        }\n        String mapKey = pos+\"_\"+count;\n        if(posHopCountMap.get(mapKey)!=null) {\n            return (posHopCountMap.get(mapKey))%mod;\n        }\n\n        long c=0;\n        if(neighbourMap.get(pos)!=null) {\n            for (Integer ne : neighbourMap.get(pos)) {\n                c=(c+getDistinctCount(ne,count-1))%mod;\n            }\n            posHopCountMap.put(mapKey,c);\n        }\n\n        return c;\n\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private Map<String,Long> posHopCountMap;\n\n    private Map<Integer,Integer[]> neighbourMap;\n\n    private int mod = (int) (Math.pow(10,9)+7);\n\n    public int knightDialer(int N) {\n\n        posHopCountMap = new HashMap<>();\n        neighbourMap = new HashMap<>();\n\n        neighbourMap.put(0,new Integer[]{4,6});\n        neighbourMap.put(1,new Integer[]{6,8});\n        neighbourMap.put(2,new Integer[]{7,9});\n        neighbourMap.put(3,new Integer[]{4,8});\n        neighbourMap.put(4,new Integer[]{3,9,0});\n        neighbourMap.put(5,null);\n        neighbourMap.put(6,new Integer[]{1,7,0});\n        neighbourMap.put(7,new Integer[]{2,6});\n        neighbourMap.put(8,new Integer[]{1,3});\n        neighbourMap.put(9,new Integer[]{2,4});\n\n\n        long sum = 0;\n        for (int i=0;i<=9;i++) {\n            sum=(sum+getDistinctCount(i,N-1))%mod;\n        }\n\n        return (int)sum;\n\n    }\n\n    private long getDistinctCount(int pos,int count) {\n        if(count==0) {\n            return 1;\n        }\n        String mapKey = pos+\"_\"+count;\n        if(posHopCountMap.get(mapKey)!=null) {\n            return (posHopCountMap.get(mapKey))%mod;\n        }\n\n        long c=0;\n        if(neighbourMap.get(pos)!=null) {\n            for (Integer ne : neighbourMap.get(pos)) {\n                c=(c+getDistinctCount(ne,count-1))%mod;\n            }\n            posHopCountMap.put(mapKey,c);\n        }\n\n        return c;\n\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744139,
                "title": "java-dp-w-explanation-solution-easier-to-read",
                "content": "# Intuition\\nLet\\'s think about this problem w/o DP first:\\nLet\\'s say we start off on the \\'1\\' button first and N=5. I can either reach 6 or 8. If i go to \\'6\\' after wards i have n=5 more jumps i can do. If i go to \\'8\\' i also have n=5 more different moves i can do. We want to check both of them\\n\\nDP:\\nThe unique combinations in our DP array we can have is based on how many moves we have left (n) and which number we\\'re currently at. \\nFor example, if on one iteration i have 4 moves left and i\\'m at number \\'0\\', the next time on a differet iteration I happen to have 4 moves left and i\\'m also at \\'0\\' we don\\'t need to recompute from here. We just pull up dp[n][0]\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] pad = new int[][] {{1,2,3},{4,5,6},{7,8,9},{-1,0,-1}};\\n    int[][] dirs = new int[][] {{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1}};\\n    long[][] dp;    \\n    int modulus = (int)Math.pow(10,9)+7;\\n    long sol = 0;\\n    public int knightDialer(int n) {\\n        dp = new long[n+1][10];\\n        for(int r = 0; r<pad.length; r++){\\n            for(int c = 0; c<pad[0].length; c++){\\n                sol = (sol+helper(r,c,n))%modulus;\\n            }\\n        }\\n        return (int) sol;\\n    }\\n    public long helper(int r, int c, int n){\\n        if (n == 1 && validMove(r,c)){\\n            return 1;\\n        }\\n        if(!validMove(r,c)){\\n            return 0;\\n        }\\n        if(dp[n][pad[r][c]]>0){\\n            return dp[n][pad[r][c]];\\n        }\\n        long curr = 0;\\n        for(int[] d : dirs){\\n            int newR = d[0]+r;\\n            int newC = d[1]+c;\\n            curr = (curr+helper(newR,newC,n-1))%modulus;\\n        }\\n        dp[n][pad[r][c]] = curr;\\n        return curr;\\n    }\\n    public boolean validMove(int r, int c){\\n        if (r<0 || c<0 || r>=pad.length || c>=pad[0].length || pad[r][c] == -1){\\n            return false;\\n        }return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] pad = new int[][] {{1,2,3},{4,5,6},{7,8,9},{-1,0,-1}};\\n    int[][] dirs = new int[][] {{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1}};\\n    long[][] dp;    \\n    int modulus = (int)Math.pow(10,9)+7;\\n    long sol = 0;\\n    public int knightDialer(int n) {\\n        dp = new long[n+1][10];\\n        for(int r = 0; r<pad.length; r++){\\n            for(int c = 0; c<pad[0].length; c++){\\n                sol = (sol+helper(r,c,n))%modulus;\\n            }\\n        }\\n        return (int) sol;\\n    }\\n    public long helper(int r, int c, int n){\\n        if (n == 1 && validMove(r,c)){\\n            return 1;\\n        }\\n        if(!validMove(r,c)){\\n            return 0;\\n        }\\n        if(dp[n][pad[r][c]]>0){\\n            return dp[n][pad[r][c]];\\n        }\\n        long curr = 0;\\n        for(int[] d : dirs){\\n            int newR = d[0]+r;\\n            int newC = d[1]+c;\\n            curr = (curr+helper(newR,newC,n-1))%modulus;\\n        }\\n        dp[n][pad[r][c]] = curr;\\n        return curr;\\n    }\\n    public boolean validMove(int r, int c){\\n        if (r<0 || c<0 || r>=pad.length || c>=pad[0].length || pad[r][c] == -1){\\n            return false;\\n        }return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711116,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    int[][] canMove = {{4,6},{6,8},{7,9},{4,8},{0,3,7},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1_000_000_007;\\n    public int helper(int n, int curr, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][curr] != null)\\n            return dp[n][curr];\\n        int ans = 0;\\n        for(int i: canMove[curr]) {\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return dp[n][curr] = ans;\\n    }\\n    \\n    public int knightDialer(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n+1][10];\\n        for(int i=0;i<10;i++){\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] canMove = {{4,6},{6,8},{7,9},{4,8},{0,3,7},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1_000_000_007;\\n    public int helper(int n, int curr, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][curr] != null)\\n            return dp[n][curr];\\n        int ans = 0;\\n        for(int i: canMove[curr]) {\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return dp[n][curr] = ans;\\n    }\\n    \\n    public int knightDialer(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n+1][10];\\n        for(int i=0;i<10;i++){\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658072,
                "title": "constant-space-c-solution-with-explanation",
                "content": "# Intuition\\nJust for a second think about various positions on the dialpad and how they can be reached.\\n\\n# Approach\\nNow that you must have got an idea that every key on the dialpad can only be reached by certain keys. For example, the key 1 can only be reached by keys 8 and 6 and NONE other. Now that we know that, we can think that at every stage if we press the current button, the previous state must have had one of the possible path keys (in case of 1 - 8 and 6). Now this looks like a good problem for DP but, notice that we only need the last state of dialpad, hence can be done in constant space. \\nSo first initialise the curr vector, with 10 keys. If n=1, number of buttons pressed = 1. Initialise next vector same as current. Now at every next step ranging from 2 to n, we see that if the current button was x, what are the ways to reach x. For example x is 1, so the number of ways to reach 1 in next state is when current state is at 8 or 6. Following this logic, count the next state for every number on the dialpad. At last of iteration, assign curr to next, as this will become our current state for the next step. \\nAt last just add all the number of ways to each each key on the dialpad.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    \\n    int knightDialer(int n) {\\n        vector<long> curr(10, 1);\\n        vector<long> next = curr;\\n        for(int i=2; i<=n; i++)\\n        {\\n            next[0] = ((curr[4]%MOD)+(curr[6]%MOD))%MOD;\\n            next[1] = ((curr[8]%MOD)+(curr[6]%MOD))%MOD;\\n            next[2] = ((curr[9]%MOD)+(curr[7]%MOD))%MOD;\\n            next[3] = ((curr[4]%MOD)+(curr[8]%MOD))%MOD;\\n            next[4] = ((curr[3]%MOD)+(curr[9]%MOD)+(curr[0]%MOD))%MOD;\\n            next[5] = 0;\\n            next[6] = ((curr[1]%MOD)+(curr[7]%MOD)+(curr[0]%MOD))%MOD;\\n            next[7] = ((curr[2]%MOD)+(curr[6]%MOD))%MOD;\\n            next[8] = ((curr[1]%MOD)+(curr[3]%MOD))%MOD;\\n            next[9] = ((curr[4]%MOD)+(curr[2]%MOD))%MOD;\\n            curr = next;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<10; i++)\\n            ans=((ans+next[i])%MOD);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    \\n    int knightDialer(int n) {\\n        vector<long> curr(10, 1);\\n        vector<long> next = curr;\\n        for(int i=2; i<=n; i++)\\n        {\\n            next[0] = ((curr[4]%MOD)+(curr[6]%MOD))%MOD;\\n            next[1] = ((curr[8]%MOD)+(curr[6]%MOD))%MOD;\\n            next[2] = ((curr[9]%MOD)+(curr[7]%MOD))%MOD;\\n            next[3] = ((curr[4]%MOD)+(curr[8]%MOD))%MOD;\\n            next[4] = ((curr[3]%MOD)+(curr[9]%MOD)+(curr[0]%MOD))%MOD;\\n            next[5] = 0;\\n            next[6] = ((curr[1]%MOD)+(curr[7]%MOD)+(curr[0]%MOD))%MOD;\\n            next[7] = ((curr[2]%MOD)+(curr[6]%MOD))%MOD;\\n            next[8] = ((curr[1]%MOD)+(curr[3]%MOD))%MOD;\\n            next[9] = ((curr[4]%MOD)+(curr[2]%MOD))%MOD;\\n            curr = next;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<10; i++)\\n            ans=((ans+next[i])%MOD);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404843,
                "title": "python3-clean-top-down-dp-solution-with-lru-cache",
                "content": "```\\nclass Solution:\\n    # T: O(N) where N is the number of allowed moves \\n    possible_moves = {\\n        0: [4,6],\\n        1: [6,8],\\n        2: [7,9],\\n        3: [4,8],\\n        4: [0,3,9],\\n        5: [],\\n        6: [0,1,7],\\n        7: [2,6],\\n        8: [1,3],\\n        9: [2,4],\\n    }\\n    \\n    MOD = 1e9 + 7\\n    \\n    def knightDialer(self, n: int) -> int:\\n        return int(sum(self.dp(start, n-1) for start in range(10)) % self.MOD) # int() to cast float to int\\n        \\n    \\n    @lru_cache(maxsize=None)\\n    def dp(self, start: int, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        return sum(self.dp(next_move, n-1) for next_move in self.possible_moves[start]) % self.MOD\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    # T: O(N) where N is the number of allowed moves \\n    possible_moves = {\\n        0: [4,6],\\n        1: [6,8],\\n        2: [7,9],\\n        3: [4,8],\\n        4: [0,3,9],\\n        5: [],\\n        6: [0,1,7],\\n        7: [2,6],\\n        8: [1,3],\\n        9: [2,4],\\n    }\\n    \\n    MOD = 1e9 + 7\\n    \\n    def knightDialer(self, n: int) -> int:\\n        return int(sum(self.dp(start, n-1) for start in range(10)) % self.MOD) # int() to cast float to int\\n        \\n    \\n    @lru_cache(maxsize=None)\\n    def dp(self, start: int, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        return sum(self.dp(next_move, n-1) for next_move in self.possible_moves[start]) % self.MOD\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338188,
                "title": "easy-understanding-c-solution-o-n-tc-and-o-1-sc-using-math",
                "content": "### **Thinking:**\\n* Let\\'s part the numbers as follow:\\n* a{2,8} b{1,3,7,9} c{4,6} d{0} e{5}\\n* for n>1 there would no phone_numbers ending with 5 (not possible).\\n* For any new digit of group a, previous digit should be ending with group b.\\n\\t* Also notice that for each number, there can be only two previous numbers, both from group b.\\n\\t* i.e. for let say 2, previous digit should be either 7 or 9.\\n* For any new digit of group b, previous digit should be ending with group a or c.\\n\\t* Also notice that for each number, there can be only two previous numbers, that too one from group a, another from group c.\\n\\t* i.e. for let say 1, previous digit should be either 8 or 6.\\n*  For any new digit of group c, previous digit should be ending with group b or d.\\n\\t* Also notice that for each number, there can be only three previous numbers, that too two from group b, another from group d.\\n\\t* i.e. for let say 4, previous digit should be 3 or 9 or 0.\\n* For any new digit of group d, previous digit should be ending with group c.\\n\\t* Also notice that for each number, there can be only two previous number, both from group c.\\n\\t* i.e. for 0, previous digit should be either 4 or 6.\\n\\nLet\\'s store number of phone_numbers ending with the digit of certain group as variable a, b, c, d.\\nLet\\'s update the value for each increment of n.\\nFinally after n operations, We have the number of unique phone_numbers ending with certain group. So just multiplying those with the number of element of each group, we can find the total number of unique phone_numbers.\\n\\t\\n### **Code:**\\n```\\nclass Solution {\\n    int MOD=1e9+7;\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1) return 10;\\n        int a=2, b=2, c=3, d=2; //a{2,8} b{1,3,7,9} c{4,6} d{0}\\n        for(int i=3; i<=n; i++){\\n            int w, x, y, z;\\n            w = 2ll*b%MOD;\\n            x = (1ll*a + 1ll*c)%MOD;\\n            y = (2ll*b + 1ll*d)%MOD;\\n            z = 2ll*c%MOD;\\n            a = w; b = x; c = y; d = z;\\n        }\\n        int ans = (2ll*a + 4ll*b + 2ll*c + d)%MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Comment For any Explanation, Upvote if you like it...**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int MOD=1e9+7;\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1) return 10;\\n        int a=2, b=2, c=3, d=2; //a{2,8} b{1,3,7,9} c{4,6} d{0}\\n        for(int i=3; i<=n; i++){\\n            int w, x, y, z;\\n            w = 2ll*b%MOD;\\n            x = (1ll*a + 1ll*c)%MOD;\\n            y = (2ll*b + 1ll*d)%MOD;\\n            z = 2ll*c%MOD;\\n            a = w; b = x; c = y; d = z;\\n        }\\n        int ans = (2ll*a + 4ll*b + 2ll*c + d)%MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336836,
                "title": "dfs-brute-force-with-memoization",
                "content": "```\\nlong long int solve(int n,int i,int j,vector< vector<vector<int>>> &cache)\\n{\\n    if((i==3 && j!=1) || n<0 || i>=4 || j>=3 || j<0 || i<0 )\\n        return 0;\\n    \\n    if(n == 0)\\n        return 1;\\n    \\n    if(cache[n][i][j]!=-1)\\n        return cache[n][i][j];\\n    \\n    long long int res = 0;\\n    int mod = 1000000007;\\n    res+=solve(n-1,i+2,j+1,cache)%mod;\\n    res+=solve(n-1,i-2,j+1,cache)%mod;\\n    res+=solve(n-1,i+2,j-1,cache)%mod;\\n    res+=solve(n-1,i-2,j-1,cache)%mod;\\n    \\n    \\n    res+=solve(n-1,i+1,j+2,cache)%mod;\\n    res+=solve(n-1,i-1,j+2,cache)%mod;\\n    res+=solve(n-1,i+1,j-2,cache)%mod;\\n    res+=solve(n-1,i-1,j-2,cache)%mod;\\n    \\n    return(cache[n][i][j]=(res%mod));\\n}\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        long long int res=0;\\n        int mod = 1000000007;\\n        vector<vector<int>> t(5,vector<int>(4,-1));\\n        vector< vector<vector<int>>> cache(n+1,t);\\n        n-=1; //setting the knight to one of the dial pads\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=(solve(n,i,j,cache)%mod);\\n            }\\n        }\\n        \\n        return res%mod;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlong long int solve(int n,int i,int j,vector< vector<vector<int>>> &cache)\\n{\\n    if((i==3 && j!=1) || n<0 || i>=4 || j>=3 || j<0 || i<0 )\\n        return 0;\\n    \\n    if(n == 0)\\n        return 1;\\n    \\n    if(cache[n][i][j]!=-1)\\n        return cache[n][i][j];\\n    \\n    long long int res = 0;\\n    int mod = 1000000007;\\n    res+=solve(n-1,i+2,j+1,cache)%mod;\\n    res+=solve(n-1,i-2,j+1,cache)%mod;\\n    res+=solve(n-1,i+2,j-1,cache)%mod;\\n    res+=solve(n-1,i-2,j-1,cache)%mod;\\n    \\n    \\n    res+=solve(n-1,i+1,j+2,cache)%mod;\\n    res+=solve(n-1,i-1,j+2,cache)%mod;\\n    res+=solve(n-1,i+1,j-2,cache)%mod;\\n    res+=solve(n-1,i-1,j-2,cache)%mod;\\n    \\n    return(cache[n][i][j]=(res%mod));\\n}\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        long long int res=0;\\n        int mod = 1000000007;\\n        vector<vector<int>> t(5,vector<int>(4,-1));\\n        vector< vector<vector<int>>> cache(n+1,t);\\n        n-=1; //setting the knight to one of the dial pads\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=(solve(n,i,j,cache)%mod);\\n            }\\n        }\\n        \\n        return res%mod;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268842,
                "title": "o-n-time-complexity",
                "content": "possible moves for each number\\n0 -> 4,6\\n1 -> 8,6\\n2 -> 9,7\\n3 -> 4,8\\n4 -> 3,9,0\\n5 -> -\\n6 -> 1,7,0\\n7 -> 6,2\\n8 -> 1,3\\n9 -> 4,2\\n\\ninitially for n=1\\nwe can dial any no. but for n more than 2 we have to make combinations of moves associated to that number\\na=current row, b=prev row\\n```class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        int mod = pow(10, 9) + 7;\\n        vector<long long>a(10,1), b(10);\\n        for(int i=0;i<10;i++)\\n            b[i]=1;\\n        int i=1;\\n        long long sum=0;\\n        n--;\\n        while(n--){\\n            sum=0;\\n            sum+=a[0]=(b[4]+b[6])%mod;\\n            sum+=a[1]=(b[8]+b[6])%mod;\\n            sum+=a[2]=(b[9]+b[7])%mod;\\n            sum+=a[3]=(b[4]+b[8])%mod;\\n            sum+=a[4]=(b[3]+b[9]+b[0])%mod;\\n            sum+=a[5]=0;\\n            sum+=a[6]=(b[1]+b[7]+b[0])%mod;\\n            sum+=a[7]=(b[2]+b[6])%mod;\\n            sum+=a[8]=(b[1]+b[3])%mod;\\n            sum+=a[9]=(b[4]+b[2])%mod;\\n            b=a;\\n            i++;\\n        }\\n        return sum%mod;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        int mod = pow(10, 9) + 7;\\n        vector<long long>a(10,1), b(10);\\n        for(int i=0;i<10;i++)\\n            b[i]=1;\\n        int i=1;\\n        long long sum=0;\\n        n--;\\n        while(n--){\\n            sum=0;\\n            sum+=a[0]=(b[4]+b[6])%mod;\\n            sum+=a[1]=(b[8]+b[6])%mod;\\n            sum+=a[2]=(b[9]+b[7])%mod;\\n            sum+=a[3]=(b[4]+b[8])%mod;\\n            sum+=a[4]=(b[3]+b[9]+b[0])%mod;\\n            sum+=a[5]=0;\\n            sum+=a[6]=(b[1]+b[7]+b[0])%mod;\\n            sum+=a[7]=(b[2]+b[6])%mod;\\n            sum+=a[8]=(b[1]+b[3])%mod;\\n            sum+=a[9]=(b[4]+b[2])%mod;\\n            b=a;\\n            i++;\\n        }\\n        return sum%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194403,
                "title": "java-bottom-up-dp-explained-with-thinking-process",
                "content": "Given a Numeric Keypad where we can type a Number in a Knights Move, we need to calculate different number combinations of a given Length.\\nWe need some crucial Information before Proceeding ahead.\\n\\n```\\n1 | 2 | 3\\n4 | 5 | 6\\n7 | 8 | 9\\n* | 0 | #\\n```\\nFor every length, the Knight has multiple options to move from the Current Numeric Button to other Numeric Button. For every length we have 10 buttons to press. Let\\'s take a look on the Combinations:\\n```\\ni = 0: We can make a Knights move from 0 to both 4 & 6. So for current press if we choose i = 0, we are left with (n-1, 4) + (n-1, 6) presses Left.\\n\\nSimilarly I\\'ll list down all possibilities,\\n\\ni = 1: Can jump to 6 & 8 so (n-1, 6) + (n-1, 8)\\ni = 2: Can jump to 7 & 9 so (n-1, 7) + (n-1, 9)\\ni = 3: Can jump to 4 & 8 so (n-1, 4) + (n-1, 8)\\ni = 4: Can jump to 3 & 9 & 0 so (n-1, 3) + (n-1, 9) + (n-1, 0)\\ni = 5: Cannot jump anywhere so 0 for n > 1 ( Can actually jump to * & # but they are Forbidden)\\ni = 6: Can jump to 1 & 7 & 0 so (n-1, 1) + (n-1, 7) + (n-1, 0)\\ni = 7: Can jump to 2 & 6 so (n-1, 2) + (n-1, 6)\\ni = 8: Can jump to 1 & 3 so (n-1, 1) + (n-1, 3)\\ni = 9: Can jump to 2 & 4 so (n-1, 2) + (n-1, 4)\\n```\\n\\n\\nTo Simulate the Above process, we will run 2 For loops:\\n1. First for every n Length Combination that we can get.\\n2. Then for every Numeric Keypad Button from 0 to 9.\\n\\nWe would depend on the values for the Previous length Combinations that can be made. The further is explained below in the Code.\\n\\n```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        long[][] dp = new long[n][10];\\n        for(int i = 0; i < 10; i++)\\n            dp[0][i] = 1;\\n        for(int i = 1; i < n; i++)\\n            for(int j = 0; j < 10; j++)\\n                helper(dp, i, j);\\n        \\n        long ans = 0;\\n        for(int j = 0; j < 10; j++)\\n        {\\n            ans += dp[n-1][j];\\n            ans %= mod;\\n        }\\n        return (int)ans;\\n    }\\n    \\n    private void helper(long[][] dp, int i, int j)\\n    {\\n        if(j == 1)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n        else if(j == 3)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n        else if(j == 7)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][2]) % mod;\\n        else if(j == 9)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][2]) % mod;\\n        else if(j == 2)\\n            dp[i][j] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n        else if(j == 8)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n        else if(j == 4)\\n            dp[i][j] = (dp[i-1][3] + dp[i-1][9] + dp[i-1][0]) % mod;\\n        else if(j == 6)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][7] + dp[i-1][0]) % mod;\\n        else if(j == 0)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n1 | 2 | 3\\n4 | 5 | 6\\n7 | 8 | 9\\n* | 0 | #\\n```\n```\\ni = 0: We can make a Knights move from 0 to both 4 & 6. So for current press if we choose i = 0, we are left with (n-1, 4) + (n-1, 6) presses Left.\\n\\nSimilarly I\\'ll list down all possibilities,\\n\\ni = 1: Can jump to 6 & 8 so (n-1, 6) + (n-1, 8)\\ni = 2: Can jump to 7 & 9 so (n-1, 7) + (n-1, 9)\\ni = 3: Can jump to 4 & 8 so (n-1, 4) + (n-1, 8)\\ni = 4: Can jump to 3 & 9 & 0 so (n-1, 3) + (n-1, 9) + (n-1, 0)\\ni = 5: Cannot jump anywhere so 0 for n > 1 ( Can actually jump to * & # but they are Forbidden)\\ni = 6: Can jump to 1 & 7 & 0 so (n-1, 1) + (n-1, 7) + (n-1, 0)\\ni = 7: Can jump to 2 & 6 so (n-1, 2) + (n-1, 6)\\ni = 8: Can jump to 1 & 3 so (n-1, 1) + (n-1, 3)\\ni = 9: Can jump to 2 & 4 so (n-1, 2) + (n-1, 4)\\n```\n```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        long[][] dp = new long[n][10];\\n        for(int i = 0; i < 10; i++)\\n            dp[0][i] = 1;\\n        for(int i = 1; i < n; i++)\\n            for(int j = 0; j < 10; j++)\\n                helper(dp, i, j);\\n        \\n        long ans = 0;\\n        for(int j = 0; j < 10; j++)\\n        {\\n            ans += dp[n-1][j];\\n            ans %= mod;\\n        }\\n        return (int)ans;\\n    }\\n    \\n    private void helper(long[][] dp, int i, int j)\\n    {\\n        if(j == 1)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n        else if(j == 3)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n        else if(j == 7)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][2]) % mod;\\n        else if(j == 9)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][2]) % mod;\\n        else if(j == 2)\\n            dp[i][j] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n        else if(j == 8)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n        else if(j == 4)\\n            dp[i][j] = (dp[i-1][3] + dp[i-1][9] + dp[i-1][0]) % mod;\\n        else if(j == 6)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][7] + dp[i-1][0]) % mod;\\n        else if(j == 0)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124467,
                "title": "javascript-simple-and-clean-o-n-o-1",
                "content": "```\\nvar knightDialer = function(n) {\\n  // dp = the no. of possible combinations at each number\\n  let dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; // 0-9\\n  const mod = 10**9 + 7;\\n  for(let i=2; i<=n; i++) {\\n    dp = [\\n      (dp[4] + dp[6]) % mod, // 0\\n      (dp[6] + dp[8]) % mod, // 1\\n      (dp[7] + dp[9]) % mod, // 2 ...\\n      (dp[4] + dp[8]) % mod,\\n      (dp[3] + dp[9] + dp[0]) % mod,\\n      0,\\n      (dp[1] + dp[7] + dp[0]) % mod,\\n      (dp[2] + dp[6]) % mod,\\n      (dp[1] + dp[3]) % mod,\\n      (dp[4] + dp[2]) % mod\\n    ];\\n  }\\n  return dp.reduce((prev, next) => (prev + next) % mod, 0);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar knightDialer = function(n) {\\n  // dp = the no. of possible combinations at each number\\n  let dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; // 0-9\\n  const mod = 10**9 + 7;\\n  for(let i=2; i<=n; i++) {\\n    dp = [\\n      (dp[4] + dp[6]) % mod, // 0\\n      (dp[6] + dp[8]) % mod, // 1\\n      (dp[7] + dp[9]) % mod, // 2 ...\\n      (dp[4] + dp[8]) % mod,\\n      (dp[3] + dp[9] + dp[0]) % mod,\\n      0,\\n      (dp[1] + dp[7] + dp[0]) % mod,\\n      (dp[2] + dp[6]) % mod,\\n      (dp[1] + dp[3]) % mod,\\n      (dp[4] + dp[2]) % mod\\n    ];\\n  }\\n  return dp.reduce((prev, next) => (prev + next) % mod, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969250,
                "title": "c-recursive-and-memoization-dp-simple-and-easy",
                "content": "```\\nclass Solution {\\n    \\n    //For memoization\\n    vector<vector<vector<int>>>memo;\\n    long long int mod=1e9+7;\\n    \\n    //recursive calls to claculate all possible moves when horse at i,j th cell\\n    int help(int n,int i,int j){\\n        \\n        if(i<0 || j<0 || i>3 || j>2 || (i==3 && j==2) || (i==3 && j==0))\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        \\n        if(memo[i][j][n]!=-1)\\n            return memo[i][j][n];\\n        //all 8 possible moves\\n        int ans=0;\\n        ans=(ans%mod+help(n-1,i-2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j+2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j+2)%mod)%mod;\\n        return memo[i][j][n]=ans%mod;\\n   \\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        long long int ans=0;\\n        //find ans when horse at every i,j th cell\\n        for(int i=0;i<=3;i++)\\n            for(int j=0;j<=2;j++)\\n                ans+=help(n-1,i,j)%mod;\\n        \\n        return ans%mod;\\n    }\\n};\\n```\\n### if you like it upvote it",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //For memoization\\n    vector<vector<vector<int>>>memo;\\n    long long int mod=1e9+7;\\n    \\n    //recursive calls to claculate all possible moves when horse at i,j th cell\\n    int help(int n,int i,int j){\\n        \\n        if(i<0 || j<0 || i>3 || j>2 || (i==3 && j==2) || (i==3 && j==0))\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        \\n        if(memo[i][j][n]!=-1)\\n            return memo[i][j][n];\\n        //all 8 possible moves\\n        int ans=0;\\n        ans=(ans%mod+help(n-1,i-2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j+2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j+2)%mod)%mod;\\n        return memo[i][j][n]=ans%mod;\\n   \\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        long long int ans=0;\\n        //find ans when horse at every i,j th cell\\n        for(int i=0;i<=3;i++)\\n            for(int j=0;j<=2;j++)\\n                ans+=help(n-1,i,j)%mod;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923343,
                "title": "python3-dp-top-down",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        \\n        MOD = 10**9 + 7\\n        \\n        adj = {\\n            0: [6, 4], \\n            1: [6, 8], \\n            2: [9, 7], \\n            3: [4, 8], \\n            4: [9, 3, 0], \\n            5: [], \\n            6: [7, 1, 0], \\n            7: [6, 2], \\n            8: [3, 1], \\n            9: [4, 2]\\n        }\\n        \\n        @cache\\n        def res(k, num):\\n            if k == 1:\\n                return 1\\n            else:\\n                ret = 0\\n                for i in adj[num]:\\n                    ret = (ret + res(k - 1, i)) % MOD\\n                return ret\\n        \\n        ans = 0\\n        for i in range(10):\\n            ans = (ans + res(n, i)) % MOD\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        \\n        MOD = 10**9 + 7\\n        \\n        adj = {\\n            0: [6, 4], \\n            1: [6, 8], \\n            2: [9, 7], \\n            3: [4, 8], \\n            4: [9, 3, 0], \\n            5: [], \\n            6: [7, 1, 0], \\n            7: [6, 2], \\n            8: [3, 1], \\n            9: [4, 2]\\n        }\\n        \\n        @cache\\n        def res(k, num):\\n            if k == 1:\\n                return 1\\n            else:\\n                ret = 0\\n                for i in adj[num]:\\n                    ret = (ret + res(k - 1, i)) % MOD\\n                return ret\\n        \\n        ans = 0\\n        for i in range(10):\\n            ans = (ans + res(n, i)) % MOD\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892977,
                "title": "python-dp-bottom-up",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        memo = [1 for _ in range(10)]\\n        legaljumps = {\\n            0:[4,6],\\n            1:[8,6],\\n            2:[7,9],\\n            3:[4,8],\\n            4:[0,3,9],\\n            5:[],\\n            6:[0,1,7],\\n            7:[2,6],\\n            8:[1,3],\\n            9:[2,4]\\n        }\\n        m = 10**9 + 7\\n        for i in range(2, n+1):\\n            cur = [0 for _ in range(10)]\\n            for x in range(10):\\n                for end in legaljumps[x]:\\n                    cur[end] += memo[x] \\n            memo = cur\\n        return sum(memo) % m\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        memo = [1 for _ in range(10)]\\n        legaljumps = {\\n            0:[4,6],\\n            1:[8,6],\\n            2:[7,9],\\n            3:[4,8],\\n            4:[0,3,9],\\n            5:[],\\n            6:[0,1,7],\\n            7:[2,6],\\n            8:[1,3],\\n            9:[2,4]\\n        }\\n        m = 10**9 + 7\\n        for i in range(2, n+1):\\n            cur = [0 for _ in range(10)]\\n            for x in range(10):\\n                for end in legaljumps[x]:\\n                    cur[end] += memo[x] \\n            memo = cur\\n        return sum(memo) % m\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858519,
                "title": "python-easy-to-understand-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n#         init = {\\n# Note there is no key = 5, because once n >= 2, we go anywhere if we start with 5, so it is not an option\\n# E.g. 0 can come from 4 or 6\\n#             0: [4, 6],\\n#             1: [6, 8],\\n#             2: [7, 9],\\n#             3: [4, 8],\\n#             4: [0, 3, 9],\\n#             6: [0, 1, 7],\\n#             7: [2, 6],\\n#             8: [1, 3],\\n#             9: [2, 4]\\n#         }\\n        \\n        list1 = [1,1,1,1,1,0,1,1,1,1]\\n        list2 = [0,0,0,0,0,0,0,0,0,0]\\n        for i in range(n - 1):\\n\\t\\t# Just follow the init logic\\n            list2[0] = list1[4] + list1[6]\\n            list2[1] = list1[6] + list1[8]\\n            list2[2] = list1[7] + list1[9]\\n            list2[3] = list1[4] + list1[8]\\n            list2[4] = list1[0] + list1[3] + list1[9]\\n            list2[6] = list1[0] + list1[1] + list1[7]\\n            list2[7] = list1[2] + list1[6]\\n            list2[8] = list1[1] + list1[3]\\n            list2[9] = list1[2] + list1[4]\\n            list1 = list2[:]\\n        \\n        return sum(list2) % (1000000007)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n#         init = {\\n# Note there is no key = 5, because once n >= 2, we go anywhere if we start with 5, so it is not an option\\n# E.g. 0 can come from 4 or 6\\n#             0: [4, 6],\\n#             1: [6, 8],\\n#             2: [7, 9],\\n#             3: [4, 8],\\n#             4: [0, 3, 9],\\n#             6: [0, 1, 7],\\n#             7: [2, 6],\\n#             8: [1, 3],\\n#             9: [2, 4]\\n#         }\\n        \\n        list1 = [1,1,1,1,1,0,1,1,1,1]\\n        list2 = [0,0,0,0,0,0,0,0,0,0]\\n        for i in range(n - 1):\\n\\t\\t# Just follow the init logic\\n            list2[0] = list1[4] + list1[6]\\n            list2[1] = list1[6] + list1[8]\\n            list2[2] = list1[7] + list1[9]\\n            list2[3] = list1[4] + list1[8]\\n            list2[4] = list1[0] + list1[3] + list1[9]\\n            list2[6] = list1[0] + list1[1] + list1[7]\\n            list2[7] = list1[2] + list1[6]\\n            list2[8] = list1[1] + list1[3]\\n            list2[9] = list1[2] + list1[4]\\n            list1 = list2[:]\\n        \\n        return sum(list2) % (1000000007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767477,
                "title": "golang-o-n-time-o-1-mem-simple-dp",
                "content": "```go\\nconst MOD = 1_000_000_007\\n\\nfunc knightDialer(n int) int {\\n    var prev, current [10]int\\n    for i := range prev {\\n        prev[i] = 1\\n    }\\n    \\n    for i := 1; i < n; i++ {\\n        current[0] = (prev[4] + prev[6]) % MOD\\n        current[1] = (prev[6] + prev[8]) % MOD\\n        current[2] = (prev[7] + prev[9]) % MOD\\n        current[3] = (prev[4] + prev[8]) % MOD\\n        current[4] = (prev[3] + prev[9] + prev[0]) % MOD\\n        current[5] = 0\\n        current[6] = (prev[0] + prev[1] + prev[7]) % MOD\\n        current[7] = (prev[2] + prev[6]) % MOD\\n        current[8] = (prev[1] + prev[3]) % MOD\\n        current[9] = (prev[2] + prev[4]) % MOD\\n        \\n        prev, current = current, prev\\n    }\\n    \\n    sum := 0\\n    for i := range prev {\\n        sum += prev[i]\\n        if sum >= MOD {\\n            sum -= MOD\\n        }\\n    }\\n    \\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nconst MOD = 1_000_000_007\\n\\nfunc knightDialer(n int) int {\\n    var prev, current [10]int\\n    for i := range prev {\\n        prev[i] = 1\\n    }\\n    \\n    for i := 1; i < n; i++ {\\n        current[0] = (prev[4] + prev[6]) % MOD\\n        current[1] = (prev[6] + prev[8]) % MOD\\n        current[2] = (prev[7] + prev[9]) % MOD\\n        current[3] = (prev[4] + prev[8]) % MOD\\n        current[4] = (prev[3] + prev[9] + prev[0]) % MOD\\n        current[5] = 0\\n        current[6] = (prev[0] + prev[1] + prev[7]) % MOD\\n        current[7] = (prev[2] + prev[6]) % MOD\\n        current[8] = (prev[1] + prev[3]) % MOD\\n        current[9] = (prev[2] + prev[4]) % MOD\\n        \\n        prev, current = current, prev\\n    }\\n    \\n    sum := 0\\n    for i := range prev {\\n        sum += prev[i]\\n        if sum >= MOD {\\n            sum -= MOD\\n        }\\n    }\\n    \\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578340,
                "title": "python-dp",
                "content": "def knightDialer(self, n: int) -> int:\\n        move = {0:[4,6],1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],5:[],\\n               6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\\n        MOD = 10**9 + 7\\n        dp = [1] * 10\\n        for _ in range(1,n):\\n            dp2 = [0]* 10 \\n            for j in range(10):\\n                dp2[j] = sum([dp[i] for i in move[j]]) % MOD\\n            dp = dp2\\n        return sum(dp)%MOD",
                "solutionTags": [],
                "code": "def knightDialer(self, n: int) -> int:\\n        move = {0:[4,6],1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],5:[],\\n               6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\\n        MOD = 10**9 + 7\\n        dp = [1] * 10\\n        for _ in range(1,n):\\n            dp2 = [0]* 10 \\n            for j in range(10):\\n                dp2[j] = sum([dp[i] for i in move[j]]) % MOD\\n            dp = dp2\\n        return sum(dp)%MOD",
                "codeTag": "Python3"
            },
            {
                "id": 1542218,
                "title": "easy-to-understand-with-explanation-java",
                "content": "There are TEN total trees, with each 0, 1, 2 ... 9 being root nodes.\\nThe final answer, is just the sum of count of leaf nodes formed, with each 0, 1, 2, ... 9 as roots.\\n\\nNow, what does each tree look like?\\n\\nIts simple:\\nFor every root, there is a finite number of leaf nodes that one can reach. \\nFor instance: \\n* \\tWith 0 as the root node, it can reach nodes 4 and 6 ( children )\\n\\t* \\tFirst child, node 4, can form links with nodes 0, 9, 3 \\n\\t* \\tSecond child, node 6, can form links with nodes 0, 1, 7\\n\\t\\n\\tThis continues till level n.\\n\\tCount the number of leaf nodes, add it to a sum variable.\\n\\t\\nWith one particular exception, which is node with root as 5. No one can reach node 5, nor can node 5 form any children.\\n\\nBruteforce would obviously timeout, because it involves recursively traversing all branches, more than once.\\n\\nA simple straight forward solution, would be to count the number of parents, that a node can have, which eventually contributes to the number of pathways from the root node.\\n\\nFor n = 1, there are no parents. So the base case, is the number of root nodes themselves, i.e 10.\\nFor n = 2:\\n\\tNode 0 can be a parent of 4 and 6,\\n\\tNode 1 can be a parent of 6 and 8 \\n\\t...\\n\\t...\\n\\tSo the final parent counts of each node for n = 2 will be:\\n\\tFor node 0 => 2 possible parents;\\n\\t\\t  node 1 => 2 possible parents;\\n\\t\\t\\t\\t   2 => 2 possible parents; \\n\\t\\t\\t\\t   3 => 2 possible parents; \\n\\t\\t\\t\\t   4 => 3 possible parents;\\n\\t\\t\\t\\t   5 => 0 possible parents;\\n\\t\\t\\t\\t   6 => 3 possible parents;\\n\\t\\t\\t\\t   7 => 2 possible parents;\\n\\t\\t\\t\\t   8 => 2 possible parents; \\n\\t\\t\\t\\t   9 => 2 possible parents;\\n\\t\\t\\t\\t   \\nTotal parent count for all nodes from 0 to 9 is = 20 ( which is the expected answer );\\n\\nBelow is the code, where branches array indicate parent to child links, branch[0] is  parent, branch[1] is the child.\\n\\nFinal Solution:\\n```\\nclass Solution {\\n    public int knightDialer(int n) {        \\n        if(n == 1) {\\n            return 10;\\n        }\\n        \\n        int[][] branches = {{0, 4}, {0, 6}, {1, 6}, {1, 8}, {2, 7}, {2, 9},\\n                            {3, 4}, {3, 8}, {4, 0}, {4, 9}, {4, 3},\\n                            {6, 0}, {6, 1}, {6, 7}, {7, 2}, {7, 6}, {8, 1}, {8, 3},\\n                            {9, 2}, {9, 4}};\\n        \\n        long[] counts = new long[10];        \\n        Arrays.fill(counts, 1);\\n        \\n        final int MOD = 1_000_000_007;\\n        for(int i = 1; i < n; i++) {\\n            long[] nextCounts = new long[10];            \\n            for(int[] pair: branches) {\\n                nextCounts[pair[1]] = (nextCounts[pair[1]] + counts[pair[0]]) % MOD;\\n            }\\n            counts = nextCounts;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < 10; i++) {\\n            sum = (int)((sum + counts[i]) % MOD);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {        \\n        if(n == 1) {\\n            return 10;\\n        }\\n        \\n        int[][] branches = {{0, 4}, {0, 6}, {1, 6}, {1, 8}, {2, 7}, {2, 9},\\n                            {3, 4}, {3, 8}, {4, 0}, {4, 9}, {4, 3},\\n                            {6, 0}, {6, 1}, {6, 7}, {7, 2}, {7, 6}, {8, 1}, {8, 3},\\n                            {9, 2}, {9, 4}};\\n        \\n        long[] counts = new long[10];        \\n        Arrays.fill(counts, 1);\\n        \\n        final int MOD = 1_000_000_007;\\n        for(int i = 1; i < n; i++) {\\n            long[] nextCounts = new long[10];            \\n            for(int[] pair: branches) {\\n                nextCounts[pair[1]] = (nextCounts[pair[1]] + counts[pair[0]]) % MOD;\\n            }\\n            counts = nextCounts;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < 10; i++) {\\n            sum = (int)((sum + counts[i]) % MOD);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503880,
                "title": "python-o-log-n-solution-beats-100-with-fast-power",
                "content": "* By symmetry, when n >= 2 there are only four states s0: [1, 3, 7, 9], s1: [2, 8], s2: [4, 6], s3: [0]\\n* The transform is linear, thus, we are able to use the fast power of matrix to solve it\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # equivalence: 0: 1 = 3 = 7 = 9, 1: 2 = 8, 2: 4 = 6, 3: 0, 5\\n\\t\\t\\n        def matmul(a, b):\\n            m = len(a)\\n            n = len(b)\\n            p = len(b[0])\\n            res = [[0] * p for _ in range(m)]\\n            \\n            for i in range(m):\\n                for k in range(n):\\n                    for j in range(p):\\n                        res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % LARGE_PRIME\\n            return res\\n        \\n        def matpow(a, n):\\n            cur = a\\n            \\n            res = [[0] * len(a) for _ in range(len(a))]\\n            for i in range(len(a)):\\n                res[i][i] = 1\\n            \\n            while n > 0:\\n                if n % 2:\\n                    res = matmul(res, cur)\\n                cur = matmul(cur, cur)\\n                n //= 2\\n                \\n            return res\\n        \\n        if n == 1:\\n            return 10\\n        \\n        LARGE_PRIME = 10 ** 9 + 7\\n        \\n        res2 = [[2], [2], [3], [2]]\\n        T = [[0, 1, 1, 0],\\n            [2, 0, 0, 0],\\n            [2, 0, 0, 1],\\n            [0, 0, 2, 0]]\\n        \\n        Tn = matpow(T, n - 2)\\n        res = matmul(Tn, res2)\\n        return (4 * res[0][0] + 2 * res[1][0] + 2 * res[2][0] + res[3][0]) % LARGE_PRIME\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # equivalence: 0: 1 = 3 = 7 = 9, 1: 2 = 8, 2: 4 = 6, 3: 0, 5\\n\\t\\t\\n        def matmul(a, b):\\n            m = len(a)\\n            n = len(b)\\n            p = len(b[0])\\n            res = [[0] * p for _ in range(m)]\\n            \\n            for i in range(m):\\n                for k in range(n):\\n                    for j in range(p):\\n                        res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % LARGE_PRIME\\n            return res\\n        \\n        def matpow(a, n):\\n            cur = a\\n            \\n            res = [[0] * len(a) for _ in range(len(a))]\\n            for i in range(len(a)):\\n                res[i][i] = 1\\n            \\n            while n > 0:\\n                if n % 2:\\n                    res = matmul(res, cur)\\n                cur = matmul(cur, cur)\\n                n //= 2\\n                \\n            return res\\n        \\n        if n == 1:\\n            return 10\\n        \\n        LARGE_PRIME = 10 ** 9 + 7\\n        \\n        res2 = [[2], [2], [3], [2]]\\n        T = [[0, 1, 1, 0],\\n            [2, 0, 0, 0],\\n            [2, 0, 0, 1],\\n            [0, 0, 2, 0]]\\n        \\n        Tn = matpow(T, n - 2)\\n        res = matmul(Tn, res2)\\n        return (4 * res[0][0] + 2 * res[1][0] + 2 * res[2][0] + res[3][0]) % LARGE_PRIME\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443294,
                "title": "java-solution-top-down-dp",
                "content": "\\tclass Solution {\\n    char[][] board = new char[4][3];\\n    int mod = 1000000007;\\n    \\n    public int knightDialer(int n) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        map.put(0, new int[]{4,6});\\n        map.put(1, new int[]{8,6});\\n        map.put(2, new int[]{7,9});\\n        map.put(3, new int[]{4,8});\\n        map.put(4, new int[]{0,9,3});\\n        map.put(6, new int[]{7,0,1});\\n        map.put(7, new int[]{2,6});\\n        map.put(8, new int[]{1,3});\\n        map.put(9, new int[]{2,4});\\n        \\n        Map<String,Integer> memoization = new HashMap<String,Integer>();\\n        int ans = 0;\\n        for(int i = 0; i <= 9; i++)\\n        {\\n            ans = (ans + dfs(map, i, n, memoization))%mod;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int dfs(Map<Integer, int[]> map, int src, int n, Map<String,Integer> memoization)\\n    {\\n        if(n == 1)\\n        {\\n            return 1;\\n        }\\n        \\n        String key = src + \" \"+ n;\\n        if(memoization.containsKey(key))\\n        {\\n            return memoization.get(key);\\n        }\\n        \\n        int localAns = 0;\\n        if(map.containsKey(src))\\n        {\\n            for(int target : map.get(src))\\n            {\\n                localAns = (localAns + dfs(map, target, n-1, memoization))%mod;\\n            }\\n        }\\n        \\n        memoization.put(key, localAns);\\n        return memoization.get(key);\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    char[][] board = new char[4][3];\\n    int mod = 1000000007;\\n    \\n    public int knightDialer(int n) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        map.put(0, new int[]{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 1419970,
                "title": "java-o-1-space-dp",
                "content": "\\n```\\n    private int mod = 1_000_000_007 ;\\n    public int knightDialer(int n) {\\n        if(n==1) return 10;\\n        \\n        long[] cur = new long[10];\\n        long[] pre = new long[10];\\n        \\n        for(int i=0; i < 10 ;i++) \\n            pre[i] = 1;\\n        \\n        while(n>1) {\\n            cur[0] = (pre[4]+pre[6]) % mod;\\n            cur[1] = (pre[8]+pre[6]) % mod;\\n            cur[2] = (pre[7]+pre[9]) % mod;\\n            cur[3] = (pre[4]+pre[8]) % mod;\\n            cur[4] = (pre[0]+pre[3]+pre[9]) % mod;\\n            cur[6] = (pre[1]+pre[7]+pre[0]) % mod;\\n            cur[7] = (pre[2]+pre[6]) % mod;\\n            cur[8] = (pre[1]+pre[3]) % mod;\\n            cur[9] = (pre[2]+pre[4]) % mod;\\n            for(int i=0; i < 10 ;i++) pre[i] = cur[i];\\n            n--;\\n        }\\n        \\n        int numbers = 0;\\n        for(int i=0; i < 10; i++) \\n            numbers = (int) (numbers + cur[i]) % mod ;\\n        return numbers;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int mod = 1_000_000_007 ;\\n    public int knightDialer(int n) {\\n        if(n==1) return 10;\\n        \\n        long[] cur = new long[10];\\n        long[] pre = new long[10];\\n        \\n        for(int i=0; i < 10 ;i++) \\n            pre[i] = 1;\\n        \\n        while(n>1) {\\n            cur[0] = (pre[4]+pre[6]) % mod;\\n            cur[1] = (pre[8]+pre[6]) % mod;\\n            cur[2] = (pre[7]+pre[9]) % mod;\\n            cur[3] = (pre[4]+pre[8]) % mod;\\n            cur[4] = (pre[0]+pre[3]+pre[9]) % mod;\\n            cur[6] = (pre[1]+pre[7]+pre[0]) % mod;\\n            cur[7] = (pre[2]+pre[6]) % mod;\\n            cur[8] = (pre[1]+pre[3]) % mod;\\n            cur[9] = (pre[2]+pre[4]) % mod;\\n            for(int i=0; i < 10 ;i++) pre[i] = cur[i];\\n            n--;\\n        }\\n        \\n        int numbers = 0;\\n        for(int i=0; i < 10; i++) \\n            numbers = (int) (numbers + cur[i]) % mod ;\\n        return numbers;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1318678,
                "title": "java-dp-and-recursive-solution",
                "content": "Java DP\\n```\\nprivate int knightDialerDP(int n) {\\n        long[][] dp = new long[n][10];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][0] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n            dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n            dp[i][2] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n            dp[i][3] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n            dp[i][4] = (dp[i-1][0] + dp[i-1][3] + dp[i-1][9]) % mod;\\n            dp[i][6] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][7]) % mod;\\n            dp[i][7] = (dp[i-1][2] + dp[i-1][6]) % mod;\\n            dp[i][8] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n            dp[i][9] = (dp[i-1][2] + dp[i-1][4]) % mod;\\n        }\\n        long sum = 0;\\n        for(long val : dp[n-1]) sum = (sum + val) % mod;\\n        return (int)sum;\\n    }\\n    ```\\n\\tJava recursive\\n\\t```\\n    private int knightDialerRecur(int n) {\\n        long [][][] memo = new long [n+1][4][3];\\n        long sum = 0;\\n        for (int r = 0; r < 4; r++) {\\n            for (int c = 0; c < 3; c ++)\\n            sum = (sum + knightDialerRecurHelper(n, r, c, memo)) % mod;\\n        }\\n        \\n        return (int) sum;\\n    }\\n    \\n    private long knightDialerRecurHelper(int n, int r, int c, long[][][] memo) {\\n        if((r == 3 && c != 1) || r < 0 || c< 0 || r >= 4 || c >= 3) return 0;\\n        if(n == 1) return 1;\\n        if(memo[n][r][c] != 0) return memo[n][r][c];\\n        long sum = 0;\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c - 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c - 2, memo) % mod);\\n        memo[n][r][c] = sum;\\n        return sum;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nprivate int knightDialerDP(int n) {\\n        long[][] dp = new long[n][10];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][0] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n            dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n            dp[i][2] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n            dp[i][3] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n            dp[i][4] = (dp[i-1][0] + dp[i-1][3] + dp[i-1][9]) % mod;\\n            dp[i][6] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][7]) % mod;\\n            dp[i][7] = (dp[i-1][2] + dp[i-1][6]) % mod;\\n            dp[i][8] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n            dp[i][9] = (dp[i-1][2] + dp[i-1][4]) % mod;\\n        }\\n        long sum = 0;\\n        for(long val : dp[n-1]) sum = (sum + val) % mod;\\n        return (int)sum;\\n    }\\n    ```\n```\\n    private int knightDialerRecur(int n) {\\n        long [][][] memo = new long [n+1][4][3];\\n        long sum = 0;\\n        for (int r = 0; r < 4; r++) {\\n            for (int c = 0; c < 3; c ++)\\n            sum = (sum + knightDialerRecurHelper(n, r, c, memo)) % mod;\\n        }\\n        \\n        return (int) sum;\\n    }\\n    \\n    private long knightDialerRecurHelper(int n, int r, int c, long[][][] memo) {\\n        if((r == 3 && c != 1) || r < 0 || c< 0 || r >= 4 || c >= 3) return 0;\\n        if(n == 1) return 1;\\n        if(memo[n][r][c] != 0) return memo[n][r][c];\\n        long sum = 0;\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c - 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c - 2, memo) % mod);\\n        memo[n][r][c] = sum;\\n        return sum;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198572,
                "title": "faster-than-90-both-recursive-memo-dp-and-table-iterative-dp-solution",
                "content": "**Recursive+Memo Dp-Solution:**\\njava code is:\\n# \\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    Integer dp[][];\\n    int find(int curr,int n){\\n        if(n==0)return 1;\\n        if(dp[curr][n]!=null)return dp[curr][n];\\n        int res=0;\\n        for(int a : arr[curr]){\\n            res=(res+find(a,n-1))%mod;\\n        }\\n        return dp[curr][n]=res;\\n    }\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        dp=new Integer[10][n+1];\\n        int res=0;\\n        for(int i=0;i<=9;i++)\\n            res=(res+find(i,n-1))%mod;\\n        return res;\\n    }\\n}\\n```\\n\\n**Table-Dp(Iterative) Solution:**\\n# \\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        int dp[][]=new int[n][10];\\n        dp[0]=new int[]{1,1,1,1,1,1,1,1,1,1};\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<10;j++){\\n                for(int next : arr[j]){\\n                    dp[i+1][next]=(dp[i+1][next]+dp[i][j])%mod;\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int j=0;j<10;j++)res=(res+dp[n-1][j])%mod;\\n        return res;\\n    }\\n}\\n```\\n***Please,Upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    Integer dp[][];\\n    int find(int curr,int n){\\n        if(n==0)return 1;\\n        if(dp[curr][n]!=null)return dp[curr][n];\\n        int res=0;\\n        for(int a : arr[curr]){\\n            res=(res+find(a,n-1))%mod;\\n        }\\n        return dp[curr][n]=res;\\n    }\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        dp=new Integer[10][n+1];\\n        int res=0;\\n        for(int i=0;i<=9;i++)\\n            res=(res+find(i,n-1))%mod;\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        int dp[][]=new int[n][10];\\n        dp[0]=new int[]{1,1,1,1,1,1,1,1,1,1};\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<10;j++){\\n                for(int next : arr[j]){\\n                    dp[i+1][next]=(dp[i+1][next]+dp[i][j])%mod;\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int j=0;j<10;j++)res=(res+dp[n-1][j])%mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166451,
                "title": "vanilla-growing-dp",
                "content": "The idea is to grow from N=1;\\nWe create a dp array, this dp array stores all the possible combinations starting from the corresponding digit.\\nWe have 2 arrays, of new values of and old values. After every iteration the old values have to be updated as the new values. Let\\'s call our old array t1 and new array t2, based on the L paded phone. We can make the following recurrence relations for numbers starting with each digit.\\nt1 is the old array and t2 is the new array.\\nt2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\nSo for N=1 the array looks like this\\n# [1 1 1 1 1 1 1 1 1 1]\\nfor N=2 the possible combinations are;\\n{04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94} and the array looks like this\\n # [2 2 2 2 3 0 3 2 2 2]\\n For N=3, this is what the array looks like\\n # [6 5 4 4 6 0 6 5 4 5]\\n \\n\\n\\n**Here\\'s the code**\\n\\n```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n==1) return(10);\\n            long t1[]=new long[10];\\n            long t2[]=new long[10];\\n            Arrays.fill(t1,1);\\n            while(n-->1){\\n                t2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\n                for(int i=0;i<10;i++) t1[i]=t2[i]%1000000007;\\n            }\\n            long sum=0;\\n            for(int i=0;i<10;i++) sum=(sum+t1[i])%1000000007;\\n            return (int)sum;\\n    }}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n==1) return(10);\\n            long t1[]=new long[10];\\n            long t2[]=new long[10];\\n            Arrays.fill(t1,1);\\n            while(n-->1){\\n                t2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\n                for(int i=0;i<10;i++) t1[i]=t2[i]%1000000007;\\n            }\\n            long sum=0;\\n            for(int i=0;i<10;i++) sum=(sum+t1[i])%1000000007;\\n            return (int)sum;\\n    }}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141532,
                "title": "python-o-n-o-logn-beat-98",
                "content": "Python - O(n):\\n\\nDP[i, num]: the total ways of forming a string (length i) with last element (num)\\ncurrent ways [last element \\'num\\'] = previous ways which can jump on \\'num\\'\\nFor example, DP[i, 2] = DP[i-1, 7] + DP[i-1, 9]\\n\\nVectorize this idea: DP[i, :] = DP[i-1, :] * matrixA\\nmatrixA is a 10 x 10 matrix, which represents the rule of chess knight jump.\\n\\nSo final results, DP[n, :] = DP[1,:] * (matrixA ** (n-1))\\n\\n\\nHowever, 10 x 10 matrix is still huge. We can further simplify this.\\nBased on the knight jump rule, we can divide [0,1,2,3,4,6,7,8,9] (no 5 since no number can jump on 5)\\ninto 4 types: C (corner, 1, 3, 7, 9), E0 (Edge0, 4, 6, i.e. edge can jump to 0), E1 (Edge1, 2, 8), O (0)\\n\\nThe jump rule is:\\n1C   -> 1E0 + 1E1\\n1E0 -> 2C + 1O\\n1E1 -> 2C\\n1O  -> 2E0\\n\\nSo, if DP[i,:] = [numC, numE0, numE1, numO],\\nthen matrixA = [[ 0 1 1 0]\\n                          [ 2 0 0 1]\\n                          [ 2 0 0 0]\\n                          [ 0 2 0 0]]\\n\\nThis can be simplified as 4 x 4 matrix multiplication.\\nDP[i, :] = DP[i-1, :] * matrixA\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = self.update(numbers)\\n        return sum(numbers) % (10**9 + 7)            \\n        \\n\\tdef update(self,numbers):\\n\\t\\tnumC = 2*numbers[1] + 2*numbers[2]\\n\\t\\tnumE0 = numbers[0] + 2*numbers[3]\\n\\t\\tnumE1 = numbers[0]\\n\\t\\tnumO = numbers[1]\\n\\t\\treturn [numC, numE0, numE1, numO]\\n        \\n            \\n```\\n\\nIn short:\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = [2*numbers[1] + 2*numbers[2], numbers[0] + 2*numbers[3], numbers[0], numbers[1]]\\n        return sum(numbers) % (10**9 + 7)  \\n```\\n\\n\\n\\n\\nImprovement:\\n\\nDP[i, :] = DP[i-1, :] * matrixA <==> DP[n, :] = DP[1,:] * (matrixA ** (n-1))\\nThe problem is to calculate matrixB = matrixA ** (n-1)\\nwhich is O(logn) if we use divide and conqur in \\'Power (x, n)\\' problem\\n\\nPython - O(logn) :\\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10\\n        \\n        numbers = np.matrix([[4, 2, 2, 1]], dtype=object)\\n        A = np.matrix([[ 0, 1, 1, 0],\\n             [ 2, 0, 0, 1],\\n             [ 2, 0, 0, 0],\\n             [ 0, 2, 0, 0]], dtype=object)\\n        \\n        B, n = np.eye(4, dtype=object), n - 1\\n        while n > 0:\\n            n, res = n // 2, n % 2\\n            if res == 1: B = np.dot(B, A)  % (10**9+7)\\n            A = np.dot(A, A) % (10**9+7)\\n        return np.sum(np.dot(numbers, B)) % (10**9+7)\\n```\\n\\nThe O(N) method takes around 140-170 ms, 95% in Python.\\nHowever, due to the time complex of matrix multiplication, the final time for O(logN) is around 100 ms, 98% in Python.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = self.update(numbers)\\n        return sum(numbers) % (10**9 + 7)            \\n        \\n\\tdef update(self,numbers):\\n\\t\\tnumC = 2*numbers[1] + 2*numbers[2]\\n\\t\\tnumE0 = numbers[0] + 2*numbers[3]\\n\\t\\tnumE1 = numbers[0]\\n\\t\\tnumO = numbers[1]\\n\\t\\treturn [numC, numE0, numE1, numO]\\n        \\n            \\n```\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = [2*numbers[1] + 2*numbers[2], numbers[0] + 2*numbers[3], numbers[0], numbers[1]]\\n        return sum(numbers) % (10**9 + 7)  \\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10\\n        \\n        numbers = np.matrix([[4, 2, 2, 1]], dtype=object)\\n        A = np.matrix([[ 0, 1, 1, 0],\\n             [ 2, 0, 0, 1],\\n             [ 2, 0, 0, 0],\\n             [ 0, 2, 0, 0]], dtype=object)\\n        \\n        B, n = np.eye(4, dtype=object), n - 1\\n        while n > 0:\\n            n, res = n // 2, n % 2\\n            if res == 1: B = np.dot(B, A)  % (10**9+7)\\n            A = np.dot(A, A) % (10**9+7)\\n        return np.sum(np.dot(numbers, B)) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087365,
                "title": "python-top-down-hard-coding",
                "content": "Inspired by the solution on [https://leetcode.com/problems/knight-dialer/discuss/190787/How-to-solve-this-problem-explained-for-noobs!!!](http://) \\n[top rated top down solution](https://leetcode.com/problems/knight-dialer/discuss/190787/How-to-solve-this-problem-explained-for-noobs!!!) This solution is so generalized and not taking any advantage of only 10 numbers.\\nThe rule has known, so we could create a variable called \"paths\" to hard code all the possibilities.\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        bound = 10**9 + 7\\n        paths = {1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],\\\\\\n                 6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]} \\n        \\n        visited = {} # (num,n)\\n\\n        def dfs(num, n):\\n            if (num,n) in visited:\\n                return visited[(num,n)]\\n            \\n            if n==1:\\n                # if num!=5:\\n                # visited[(num,1)] = 1\\n                return 1\\n                    # return 0\\n            \\n            s = 0\\n            for i in paths[num]:\\n                s+=dfs(i,n-1)%bound\\n            \\n            visited[(num,n)] = s % bound\\n            return visited[(num,n)]\\n        \\n        \\n        res = 0\\n        for i in range(10):\\n            res+=dfs(i,n)%bound\\n        return res % bound\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        bound = 10**9 + 7\\n        paths = {1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],\\\\\\n                 6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]} \\n        \\n        visited = {} # (num,n)\\n\\n        def dfs(num, n):\\n            if (num,n) in visited:\\n                return visited[(num,n)]\\n            \\n            if n==1:\\n                # if num!=5:\\n                # visited[(num,1)] = 1\\n                return 1\\n                    # return 0\\n            \\n            s = 0\\n            for i in paths[num]:\\n                s+=dfs(i,n-1)%bound\\n            \\n            visited[(num,n)] = s % bound\\n            return visited[(num,n)]\\n        \\n        \\n        res = 0\\n        for i in range(10):\\n            res+=dfs(i,n)%bound\\n        return res % bound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007506,
                "title": "easy-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    char t[4][3]={{\\'1\\',\\'2\\',\\'3\\'},\\n                  {\\'4\\',\\'5\\',\\'6\\'},\\n                  {\\'7\\',\\'8\\',\\'9\\'},\\n                  {\\'*\\',\\'0\\',\\'#\\'}};\\n    \\n    int row=4,col=3;\\n    int dx[8]={-2,-2,-1,1,2,2,-1,1};\\n    int dy[8]={-1,1,2,2,-1,1,-2,-2};\\n    \\n    int dp[4][3][5001]={0};\\n    \\n    bool isValid(int x, int y){\\n        return (x>=0 && x<4 && y>=0 && y<3 && t[x][y]!=\\'*\\'&& t[x][y]!=\\'#\\');\\n    }\\n    \\n    int solve(int i, int j, int n){\\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[i][j][n]!=0)\\n            return dp[i][j][n];\\n        \\n        int s=0;\\n        for(int k=0;k<8;k++){\\n            if(isValid(i+dx[k], j+dy[k])){\\n                s=(s+solve(i+dx[k],j+dy[k],n-1))%1000000007;\\n            }\\n        }\\n        return dp[i][j][n]=s%1000000007;\\n    }\\n    \\n    int knightDialer(int n) {\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if(t[i][j]!=\\'*\\' && t[i][j]!=\\'#\\'){\\n                    ans=(ans+solve(i,j,n))%1000000007;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char t[4][3]={{\\'1\\',\\'2\\',\\'3\\'},\\n                  {\\'4\\',\\'5\\',\\'6\\'},\\n                  {\\'7\\',\\'8\\',\\'9\\'},\\n                  {\\'*\\',\\'0\\',\\'#\\'}};\\n    \\n    int row=4,col=3;\\n    int dx[8]={-2,-2,-1,1,2,2,-1,1};\\n    int dy[8]={-1,1,2,2,-1,1,-2,-2};\\n    \\n    int dp[4][3][5001]={0};\\n    \\n    bool isValid(int x, int y){\\n        return (x>=0 && x<4 && y>=0 && y<3 && t[x][y]!=\\'*\\'&& t[x][y]!=\\'#\\');\\n    }\\n    \\n    int solve(int i, int j, int n){\\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[i][j][n]!=0)\\n            return dp[i][j][n];\\n        \\n        int s=0;\\n        for(int k=0;k<8;k++){\\n            if(isValid(i+dx[k], j+dy[k])){\\n                s=(s+solve(i+dx[k],j+dy[k],n-1))%1000000007;\\n            }\\n        }\\n        return dp[i][j][n]=s%1000000007;\\n    }\\n    \\n    int knightDialer(int n) {\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if(t[i][j]!=\\'*\\' && t[i][j]!=\\'#\\'){\\n                    ans=(ans+solve(i,j,n))%1000000007;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929183,
                "title": "dp-memoization-approach-o-n-easy-to-understand-short-code",
                "content": "## Explanation\\n\\nFirst we need to realize what are **DP** depends on. It\\'s pretty clear that the length of the number **n** is one such parameter, the other one is our **Starting Point** say if we have n = 2\\nand we start from digit 1 then :\\n``` \\ndp[1][2] = dp[6][1] + dp[8][1];\\n```\\n**Hence we need to add answer for all possible starting points and get our answer**\\n\\n\\n# Code\\n```\\n#define mod 1000000007\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{4,6,-1}, {6,8,-1},{7,9,-1},{4,8,-1},{3,0,9},\\n                               {-1,-1,-1},{0,7,1},{6,2,-1},{1,3,-1},{2,4,-1}};  \\n\\t\\t\\t\\t\\t\\t\\t   // dir[i] represents the options that we have to jump to if starting from \\'i\\' digit\\n    \\n    ll solve(int start, int n, vector<vector<int>> &dp){\\n        \\n        if(start == -1) return 0; // can\\'t jump out here coz either out of bound or */#\\n        if(n == 1) return 1; // base case\\n\\n        if(dp[start][n] != -1) return dp[start][n];\\n        \\n        ll res = 0;\\n        for(int i = 0; i<dir[start].size(); i++)\\n            res = (res + solve(dir[start][i],n-1,dp)) %mod; // jumping to possible option\\n        \\n        return dp[start][n] = res;\\n        }\\n        \\n    int knightDialer(int n) {\\n     \\n        // LOGIC\\n        // result depends on n and where we start from except * and #\\n        ll ans = 0;\\n        for(int i = 0; i< 10; i++){  // for all possible starting points\\n            vector<vector<int>> dp(10,vector<int>(n+1,-1));\\n            ans += solve(i,n,dp);\\n            ans %= mod;\\n        }\\n    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` \\ndp[1][2] = dp[6][1] + dp[8][1];\\n```\n```\\n#define mod 1000000007\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{4,6,-1}, {6,8,-1},{7,9,-1},{4,8,-1},{3,0,9},\\n                               {-1,-1,-1},{0,7,1},{6,2,-1},{1,3,-1},{2,4,-1}};  \\n\\t\\t\\t\\t\\t\\t\\t   // dir[i] represents the options that we have to jump to if starting from \\'i\\' digit\\n    \\n    ll solve(int start, int n, vector<vector<int>> &dp){\\n        \\n        if(start == -1) return 0; // can\\'t jump out here coz either out of bound or */#\\n        if(n == 1) return 1; // base case\\n\\n        if(dp[start][n] != -1) return dp[start][n];\\n        \\n        ll res = 0;\\n        for(int i = 0; i<dir[start].size(); i++)\\n            res = (res + solve(dir[start][i],n-1,dp)) %mod; // jumping to possible option\\n        \\n        return dp[start][n] = res;\\n        }\\n        \\n    int knightDialer(int n) {\\n     \\n        // LOGIC\\n        // result depends on n and where we start from except * and #\\n        ll ans = 0;\\n        for(int i = 0; i< 10; i++){  // for all possible starting points\\n            vector<vector<int>> dp(10,vector<int>(n+1,-1));\\n            ans += solve(i,n,dp);\\n            ans %= mod;\\n        }\\n    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796049,
                "title": "very-easy-c-solution-with-detailed-comments",
                "content": "```\\n  public int KnightDialer(int N) {\\t\\t\\n  \\n           //all possible \"from\" paths for each digit (index)...\\n            var fromPath = new int[][] { new int[]{ 4, 6 }, new int[] { 6, 8 }, new int[] { 7, 9 }, new int[] { 4, 8 },\\n                                new int[]{ 3, 9, 0 }, new int[]{ }, new int[]{ 1, 7, 0 }, new int[]{ 2, 6 }, new int[]{ 1, 3 }, new int[]{ 2, 4 } };\\n            \\n\\t\\t\\t//this has to be long instead of int due to this number being this large\\n\\t\\t\\tlong MOD = 1000000007;\\n\\n            var steps = N + 1; //include step 0 so N+1\\n            var possibleNumbers = 10; //0 through 9 in the keypad\\n\\n            //row will have all the steps\\n            //col will have all possible numbers\\n\\n            var rowCol = new long[steps, possibleNumbers]; //this already initializes everything to 0\\n\\n            //initialize step 1 (row 1) to have 1\\'s for all columns\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                rowCol[1, col] = 1;\\n            }\\n\\n            //fill the rest...\\n            for (int row = 2; row < steps; row++)\\n            {\\n                for (int col = 0; col < possibleNumbers; col++)\\n                {\\n                    var possibleFromPaths = fromPath[col];\\n                    foreach (var path in possibleFromPaths)\\n                    {\\n                        rowCol[row, col] += rowCol[row - 1, path];\\n                    }\\n                    rowCol[row, col] %= MOD;\\n                }               \\n            }\\n            long totalSum = 0;\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                totalSum += rowCol[N,col];\\n            }\\n\\n            totalSum = totalSum % MOD;\\n\\t\\t\\n            return (int)totalSum;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n  public int KnightDialer(int N) {\\t\\t\\n  \\n           //all possible \"from\" paths for each digit (index)...\\n            var fromPath = new int[][] { new int[]{ 4, 6 }, new int[] { 6, 8 }, new int[] { 7, 9 }, new int[] { 4, 8 },\\n                                new int[]{ 3, 9, 0 }, new int[]{ }, new int[]{ 1, 7, 0 }, new int[]{ 2, 6 }, new int[]{ 1, 3 }, new int[]{ 2, 4 } };\\n            \\n\\t\\t\\t//this has to be long instead of int due to this number being this large\\n\\t\\t\\tlong MOD = 1000000007;\\n\\n            var steps = N + 1; //include step 0 so N+1\\n            var possibleNumbers = 10; //0 through 9 in the keypad\\n\\n            //row will have all the steps\\n            //col will have all possible numbers\\n\\n            var rowCol = new long[steps, possibleNumbers]; //this already initializes everything to 0\\n\\n            //initialize step 1 (row 1) to have 1\\'s for all columns\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                rowCol[1, col] = 1;\\n            }\\n\\n            //fill the rest...\\n            for (int row = 2; row < steps; row++)\\n            {\\n                for (int col = 0; col < possibleNumbers; col++)\\n                {\\n                    var possibleFromPaths = fromPath[col];\\n                    foreach (var path in possibleFromPaths)\\n                    {\\n                        rowCol[row, col] += rowCol[row - 1, path];\\n                    }\\n                    rowCol[row, col] %= MOD;\\n                }               \\n            }\\n            long totalSum = 0;\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                totalSum += rowCol[N,col];\\n            }\\n\\n            totalSum = totalSum % MOD;\\n\\t\\t\\n            return (int)totalSum;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 751674,
                "title": "swift-dfs-memo-dp",
                "content": "```\\nclass Solution {\\n    struct Position: Hashable {\\n        var n: Int\\n        var i: Int\\n    }\\n    var memo = [Position: Int]()\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        var comb = 0\\n        for start in moves.keys {\\n            comb += dial(N, start)  % mode\\n        }\\n\\n        return comb  % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        let pos = Position(n: N, i: i)\\n        if let c = memo[pos] { return c }\\n\\n        if N == 1 { return 1 }\\n\\n        var comb = 0\\n        for next in self.moves[i]! {\\n            comb = comb + dial(N-1, next)  % mode\\n        }\\n\\n        memo[pos, default: 0] = comb\\n        return memo[pos, default: 0]\\n    }\\n}\\n\\nclass Solution {\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    var dp = [[Int]]()\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        self.dp = Array(repeating: Array(repeating: 0, count: 10), count: N)\\n        dp[0] = [1,1,1,1,1,1,1,1,1,1]\\n        var res = 0\\n        for start in moves.keys {\\n            res += dial(N-1, start)\\n        }\\n\\n        return res % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        if dp[N][i] > 0 { return dp[N][i] }\\n\\n        for next in self.moves[i]! {\\n            dp[N][i] += dial(N-1, next)  % mode\\n        }\\n\\n        return dp[N][i]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct Position: Hashable {\\n        var n: Int\\n        var i: Int\\n    }\\n    var memo = [Position: Int]()\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        var comb = 0\\n        for start in moves.keys {\\n            comb += dial(N, start)  % mode\\n        }\\n\\n        return comb  % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        let pos = Position(n: N, i: i)\\n        if let c = memo[pos] { return c }\\n\\n        if N == 1 { return 1 }\\n\\n        var comb = 0\\n        for next in self.moves[i]! {\\n            comb = comb + dial(N-1, next)  % mode\\n        }\\n\\n        memo[pos, default: 0] = comb\\n        return memo[pos, default: 0]\\n    }\\n}\\n\\nclass Solution {\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    var dp = [[Int]]()\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        self.dp = Array(repeating: Array(repeating: 0, count: 10), count: N)\\n        dp[0] = [1,1,1,1,1,1,1,1,1,1]\\n        var res = 0\\n        for start in moves.keys {\\n            res += dial(N-1, start)\\n        }\\n\\n        return res % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        if dp[N][i] > 0 { return dp[N][i] }\\n\\n        for next in self.moves[i]! {\\n            dp[N][i] += dial(N-1, next)  % mode\\n        }\\n\\n        return dp[N][i]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693989,
                "title": "easy-java-top-down-iterative-approach-with-diagram",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int modulo = (int)Math.pow(10,9)+7;\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        map.put(0,new int[] {4,6}); //Knight at 0, can jump to 4 & 6 on keypad...\\n        map.put(1,new int[] {6,8});\\n        map.put(2,new int[] {7,9});\\n        map.put(3,new int[] {4,8});\\n        map.put(4,new int[] {0,9,3});\\n        map.put(5,new int[] {});\\n        map.put(6,new int[] {1,7,0});\\n        map.put(7,new int[] {2,6});\\n        map.put(8,new int[] {1,3});\\n        map.put(9,new int[] {2,4});\\n        \\n        int[][] dp = new int[N+1][10];\\n        Arrays.fill(dp[1],1);\\n        int dial = dp[0].length;\\n        \\n        for(int i=2;i<=N;i++){\\n            for(int j=0;j<dial;j++){\\n                for(int keyNum : map.get(j)){\\n                    dp[i][j] += dp[i-1][keyNum];\\n                    dp[i][j] %= modulo;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int c=0;c<dial;c++){\\n            count += dp[N][c];\\n            count %= modulo;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nExample: \\nIf N=3, then the answer is the sum of elements from dp[N][0]...+dp[N][9]\\n\\n![image](https://assets.leetcode.com/users/alphakiller/image_1592499072.png)\\n\\nTime Complexity: O(N). Derived from O(N * dial * keyNum) = Dial is a constant & has a value of 10. KeyNum is also a constant with value either 2 or 3.\\nSpace Complexity: O(N*dial)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int modulo = (int)Math.pow(10,9)+7;\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        map.put(0,new int[] {4,6}); //Knight at 0, can jump to 4 & 6 on keypad...\\n        map.put(1,new int[] {6,8});\\n        map.put(2,new int[] {7,9});\\n        map.put(3,new int[] {4,8});\\n        map.put(4,new int[] {0,9,3});\\n        map.put(5,new int[] {});\\n        map.put(6,new int[] {1,7,0});\\n        map.put(7,new int[] {2,6});\\n        map.put(8,new int[] {1,3});\\n        map.put(9,new int[] {2,4});\\n        \\n        int[][] dp = new int[N+1][10];\\n        Arrays.fill(dp[1],1);\\n        int dial = dp[0].length;\\n        \\n        for(int i=2;i<=N;i++){\\n            for(int j=0;j<dial;j++){\\n                for(int keyNum : map.get(j)){\\n                    dp[i][j] += dp[i-1][keyNum];\\n                    dp[i][j] %= modulo;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int c=0;c<dial;c++){\\n            count += dp[N][c];\\n            count %= modulo;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522714,
                "title": "c-dp-16ms-8-6mb-beat-100",
                "content": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n        long long int dp[N][10] = {0};\\n        for(int i = 0; i < 10; i ++){\\n            dp[0][i] = 1;\\n        }\\n        for(int i = 1; i < N; i++){\\n            for(int j = 0; j < 10; j++){\\n                switch(j){\\n                    case 1:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 2:\\n                        dp[i][j] = (dp[i - 1][7] + dp[i - 1][9]) % MOD;\\n                        break;\\n                    case 3:\\n                        dp[i][j] = (dp[i - 1][4] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 4:\\n                        dp[i][j] = (dp[i - 1][3] + dp[i - 1][9] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 5:\\n                        dp[i][j] = 0;\\n                        break;\\n                    case 6:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][7] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 7:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][2]) % MOD;\\n                        break;\\n                    case 8:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][3]) % MOD;\\n                        break;\\n                    case 9:\\n                        dp[i][j] = (dp[i - 1][2] + dp[i - 1][4]) % MOD;\\n                        break;\\n                    case 0:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][4]) % MOD;\\n                        break;\\n                }\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i = 0; i < 10; i++){\\n            sum += dp[N - 1][i];\\n            sum = sum % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n        long long int dp[N][10] = {0};\\n        for(int i = 0; i < 10; i ++){\\n            dp[0][i] = 1;\\n        }\\n        for(int i = 1; i < N; i++){\\n            for(int j = 0; j < 10; j++){\\n                switch(j){\\n                    case 1:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 2:\\n                        dp[i][j] = (dp[i - 1][7] + dp[i - 1][9]) % MOD;\\n                        break;\\n                    case 3:\\n                        dp[i][j] = (dp[i - 1][4] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 4:\\n                        dp[i][j] = (dp[i - 1][3] + dp[i - 1][9] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 5:\\n                        dp[i][j] = 0;\\n                        break;\\n                    case 6:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][7] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 7:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][2]) % MOD;\\n                        break;\\n                    case 8:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][3]) % MOD;\\n                        break;\\n                    case 9:\\n                        dp[i][j] = (dp[i - 1][2] + dp[i - 1][4]) % MOD;\\n                        break;\\n                    case 0:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][4]) % MOD;\\n                        break;\\n                }\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i = 0; i < 10; i++){\\n            sum += dp[N - 1][i];\\n            sum = sum % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426205,
                "title": "simple-c-dp-solution",
                "content": "```\\npublic class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n        private const int ROWS = 4;\\n        private const int COLUMNS = 3;\\n        private static readonly (int, int) _stub1 = (ROWS - 1, 0);\\n        private static readonly (int, int) _stub2 = (ROWS - 1, COLUMNS - 1);\\n\\n        private static (int, int)[] _steps =\\n            {(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)};\\n\\n        public int KnightDialer(int n)\\n        {\\n            checked\\n            {\\n                int[,,] dp = new int[n, ROWS, COLUMNS];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int r = 0; r < ROWS; r++)\\n                    {\\n                        for (int c = 0; c < COLUMNS; c++)\\n                        {\\n                            if ((r == _stub1.Item1 && c == _stub1.Item2) || (r == _stub2.Item1 && c == _stub2.Item2))\\n                            {\\n                                dp[i, r, c] = 0;\\n                                continue;\\n                            }\\n\\n                            if (i == 0)\\n                            {\\n                                dp[i, r, c] = 1;\\n                                continue;\\n                            }\\n\\n                            foreach (var step in _steps)\\n                            {\\n                                int nextRow = r + step.Item1;\\n                                int nextCol = c + step.Item2;\\n\\n                                if (nextRow >= 0 && nextRow < ROWS && nextCol >= 0 && nextCol < COLUMNS)\\n                                {\\n                                    dp[i, r, c] += dp[i - 1, nextRow, nextCol];\\n                                    dp[i, r, c] = dp[i, r, c] % MODULO;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                int res = 0;\\n                for (int r = 0; r < ROWS; r++)\\n                {\\n                    for (int c = 0; c < COLUMNS; c++)\\n                    {\\n                        res += dp[n - 1, r, c];\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n        private const int ROWS = 4;\\n        private const int COLUMNS = 3;\\n        private static readonly (int, int) _stub1 = (ROWS - 1, 0);\\n        private static readonly (int, int) _stub2 = (ROWS - 1, COLUMNS - 1);\\n\\n        private static (int, int)[] _steps =\\n            {(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)};\\n\\n        public int KnightDialer(int n)\\n        {\\n            checked\\n            {\\n                int[,,] dp = new int[n, ROWS, COLUMNS];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int r = 0; r < ROWS; r++)\\n                    {\\n                        for (int c = 0; c < COLUMNS; c++)\\n                        {\\n                            if ((r == _stub1.Item1 && c == _stub1.Item2) || (r == _stub2.Item1 && c == _stub2.Item2))\\n                            {\\n                                dp[i, r, c] = 0;\\n                                continue;\\n                            }\\n\\n                            if (i == 0)\\n                            {\\n                                dp[i, r, c] = 1;\\n                                continue;\\n                            }\\n\\n                            foreach (var step in _steps)\\n                            {\\n                                int nextRow = r + step.Item1;\\n                                int nextCol = c + step.Item2;\\n\\n                                if (nextRow >= 0 && nextRow < ROWS && nextCol >= 0 && nextCol < COLUMNS)\\n                                {\\n                                    dp[i, r, c] += dp[i - 1, nextRow, nextCol];\\n                                    dp[i, r, c] = dp[i, r, c] % MODULO;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                int res = 0;\\n                for (int r = 0; r < ROWS; r++)\\n                {\\n                    for (int c = 0; c < COLUMNS; c++)\\n                    {\\n                        res += dp[n - 1, r, c];\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375123,
                "title": "python-level-traversal",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        dp = [1]*10\\n        MOD = 10**9+7\\n        graph = [{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}]\\n        for i in range(N-1):\\n            temp = [0]*10\\n            for i,v in enumerate(dp):\\n                for nxt in graph[i]:\\n                    temp[nxt] += v\\n                    temp[nxt] %= MOD\\n            dp = temp\\n        return sum(dp) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        dp = [1]*10\\n        MOD = 10**9+7\\n        graph = [{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}]\\n        for i in range(N-1):\\n            temp = [0]*10\\n            for i,v in enumerate(dp):\\n                for nxt in graph[i]:\\n                    temp[nxt] += v\\n                    temp[nxt] %= MOD\\n            dp = temp\\n        return sum(dp) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332177,
                "title": "recursive-solution-cpp-this-is-more-reasonable-to-come-up-with-instead-of-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) \\n    {\\n        m_mem.assign(N, vector<int>(10, - 1));\\n        m_mem[0].assign(10, 1);\\n        int ans = 0;\\n        for(int i = 0; i <= 9; ++i)\\n            ans = (ans + dial(i, N - 1)) % mod;\\n        return ans;\\n    }\\nprivate:\\n    int dial(int num, int N)\\n    {\\n        if(m_mem[N][num] >= 0) return m_mem[N][num];\\n        int combo = 0;\\n        for(int prev : m_moves[num])\\n            combo = (combo + dial(prev, N - 1))%mod;\\n        return m_mem[N][num] = combo;\\n    }\\n    \\n    vector<vector<int>> m_moves{{4,6}, {8,6}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {6,2},{1,3}, {4,2}};\\n    vector<vector<int>> m_mem;\\n    const int mod = 1000000007;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) \\n    {\\n        m_mem.assign(N, vector<int>(10, - 1));\\n        m_mem[0].assign(10, 1);\\n        int ans = 0;\\n        for(int i = 0; i <= 9; ++i)\\n            ans = (ans + dial(i, N - 1)) % mod;\\n        return ans;\\n    }\\nprivate:\\n    int dial(int num, int N)\\n    {\\n        if(m_mem[N][num] >= 0) return m_mem[N][num];\\n        int combo = 0;\\n        for(int prev : m_moves[num])\\n            combo = (combo + dial(prev, N - 1))%mod;\\n        return m_mem[N][num] = combo;\\n    }\\n    \\n    vector<vector<int>> m_moves{{4,6}, {8,6}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {6,2},{1,3}, {4,2}};\\n    vector<vector<int>> m_mem;\\n    const int mod = 1000000007;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306446,
                "title": "python-4-line-solution",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        memo, dp = [[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[0,1,7],[2,6],[1,3],[2,4]], [1] * 10\\n        for i in range(N - 1):\\n            dp = [sum([dp[j] for j in memo[i]]) for i in range(10)]\\n        return sum(dp) % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        memo, dp = [[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[0,1,7],[2,6],[1,3],[2,4]], [1] * 10\\n        for i in range(N - 1):\\n            dp = [sum([dp[j] for j in memo[i]]) for i in range(10)]\\n        return sum(dp) % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 303437,
                "title": "straightforward-python-memoization",
                "content": "```\\nclass Solution(object):\\n    moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n    \\n    def knightDialer(self, N):\\n        return sum(self.knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n   \\n    def knightDialer_(self, N, i, dp={}):\\n        if N == 1: return 1\\n        if (N,i) not in dp:\\n            dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\\n        return dp[(N,i)]\\n```\\n\\nOr if you\\'d rather use a generic memoization decorator:\\n\\n```\\nclass memoize:\\n    def __init__(self, f):\\n        self.f,self.memo = f,{}\\n    def __call__(self, *args):\\n        if not args in self.memo: self.memo[args] = self.f(*args)\\n        return self.memo[args]\\n\\nmoves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n   \\n@memoize\\ndef knightDialer_(N, i):\\n    if N == 1: return 1\\n    return sum(knightDialer_(N-1, j) for j in moves[i])\\n\\nclass Solution(object):\\n    def knightDialer(self, N):\\n        return sum(knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n    \\n    def knightDialer(self, N):\\n        return sum(self.knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n   \\n    def knightDialer_(self, N, i, dp={}):\\n        if N == 1: return 1\\n        if (N,i) not in dp:\\n            dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\\n        return dp[(N,i)]\\n```\n```\\nclass memoize:\\n    def __init__(self, f):\\n        self.f,self.memo = f,{}\\n    def __call__(self, *args):\\n        if not args in self.memo: self.memo[args] = self.f(*args)\\n        return self.memo[args]\\n\\nmoves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n   \\n@memoize\\ndef knightDialer_(N, i):\\n    if N == 1: return 1\\n    return sum(knightDialer_(N-1, j) for j in moves[i])\\n\\nclass Solution(object):\\n    def knightDialer(self, N):\\n        return sum(knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294494,
                "title": "c-dynamic-programming-o-n-time-and-o-1-space",
                "content": "```\\npublic class Solution {\\n    private readonly Dictionary<int, int[]> _moves = new Dictionary<int, int[]>() { \\n        { 0, new[] { 4, 6 } },\\n        { 1, new[] { 6, 8 } },\\n        { 2, new[] { 7, 9 } },\\n        { 3, new[] { 4, 8 } },\\n        { 4, new[] { 0, 3, 9 } },\\n        { 5, new int[0] },\\n        { 6, new[] { 0, 1, 7 } },\\n        { 7, new[] { 2, 6 } },\\n        { 8, new[] { 1, 3 } },\\n        { 9, new[] { 2, 4 } }\\n    };\\n    \\n    private const int MOD = 1000000007;\\n    \\n    public int KnightDialer(int N) {\\n        int[,] dp = new int[2, 10];        \\n        int sum = 0;\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int num = 0; num < 10; num++) {\\n                if (i == 0) { dp[1, num] = 1; continue; }\\n\\n                foreach (int move in _moves[num]) {\\n                    dp[1, num] += dp[0, move]; \\n                    dp[1, num] %= MOD;\\n                }\\n            }\\n            \\n            for (int num = 0; num < 10; num++) {\\n                dp[0, num] = dp[1, num];\\n                dp[1, num] = 0;\\n            }\\n        }\\n        \\n        for (int num = 0; num < 10; num++) {\\n            sum += dp[0, num];   \\n            sum %= MOD;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private readonly Dictionary<int, int[]> _moves = new Dictionary<int, int[]>() { \\n        { 0, new[] { 4, 6 } },\\n        { 1, new[] { 6, 8 } },\\n        { 2, new[] { 7, 9 } },\\n        { 3, new[] { 4, 8 } },\\n        { 4, new[] { 0, 3, 9 } },\\n        { 5, new int[0] },\\n        { 6, new[] { 0, 1, 7 } },\\n        { 7, new[] { 2, 6 } },\\n        { 8, new[] { 1, 3 } },\\n        { 9, new[] { 2, 4 } }\\n    };\\n    \\n    private const int MOD = 1000000007;\\n    \\n    public int KnightDialer(int N) {\\n        int[,] dp = new int[2, 10];        \\n        int sum = 0;\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int num = 0; num < 10; num++) {\\n                if (i == 0) { dp[1, num] = 1; continue; }\\n\\n                foreach (int move in _moves[num]) {\\n                    dp[1, num] += dp[0, move]; \\n                    dp[1, num] %= MOD;\\n                }\\n            }\\n            \\n            for (int num = 0; num < 10; num++) {\\n                dp[0, num] = dp[1, num];\\n                dp[1, num] = 0;\\n            }\\n        }\\n        \\n        for (int num = 0; num < 10; num++) {\\n            sum += dp[0, num];   \\n            sum %= MOD;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274043,
                "title": "python-rolling-dp",
                "content": "We can count number of ways to dial with K moves based on that with K-1 moves.\\nE.g. If our last dial number (Kth move) if 1, the K-1th move is either 4 or 6 based on Knight moving rule. So number of ways to reach 1 at Kth move is number of ways to reach 4 or 6at Kth move. Or ```dp[K][1] = dp[K-1][4] + dp[K-1][6]```. Based on that, we can have our recurrence equation.\\nAnd the only array we used to calculate dp[K] is dp[K-1], we can use two rolling arrays here to reduce space compleixty to O(1).\\n```\\ndef knightDialer(N):\\n\\tpad, cnt = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]], [1]*10\\n\\tfor _ in range(N-1):\\n\\t\\tnext_cnt = [1]*10\\n\\t\\tfor i in range(10):\\n\\t\\t\\tnext_cnt[i] = sum(cnt[j] for j in pad[i]) % (10**9+7)\\n\\t\\tcnt = next_cnt\\n\\treturn sum(cnt) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[K][1] = dp[K-1][4] + dp[K-1][6]```\n```\\ndef knightDialer(N):\\n\\tpad, cnt = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]], [1]*10\\n\\tfor _ in range(N-1):\\n\\t\\tnext_cnt = [1]*10\\n\\t\\tfor i in range(10):\\n\\t\\t\\tnext_cnt[i] = sum(cnt[j] for j in pad[i]) % (10**9+7)\\n\\t\\tcnt = next_cnt\\n\\treturn sum(cnt) % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 261616,
                "title": "java-backtrack",
                "content": "Runtime : O(10 * N)\\nSpace: O(10 * N)\\n\\n```java\\nclass Solution {\\n    // Solve problem in top down manner\\n    // Let F(i) be # of distinct numbers after i moves\\n    // Assume F(i\\') holds for all i\\' < i\\n    // F(i) is related to F(i-1) depends on where the chess is on step i. Let K be number of distinct choice at step i, we have\\n    // If chess is on 0, 1, 2, 3, 7, 8, 9, K = 2\\n    // If chess is on 4, 6, K = 3\\n    // If chess is on 5, K = 0\\n    // Base case: F(1) = 1\\n\\n    private Integer[][] memo;\\n    private int[][] nextStep = {\\n            {4, 6},\\n            {6, 8},\\n            {7, 9},\\n            {4, 8},\\n            {3, 9, 0},\\n            {},\\n            {1, 7, 0},\\n            {2, 6},\\n            {1, 3},\\n            {4, 2},\\n    };\\n\\n    public int knightDialer(int N) {\\n        this.memo = new Integer[10][N + 1];\\n        int count = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            count += backtrack(i, N);\\n            count %= 1e9 + 7;\\n        }\\n        return count;\\n    }\\n\\n    private int backtrack(int curNum, int N) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n\\n        if (memo[curNum][N] != null) {\\n            return memo[curNum][N];\\n        }\\n\\n        memo[curNum][N] = 0;\\n        for (int nextNum : nextStep[curNum]) {\\n            memo[curNum][N] += backtrack(nextNum, N - 1);\\n            memo[curNum][N] %= (int)1e9 + 7;\\n        }\\n        return memo[curNum][N];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    // Solve problem in top down manner\\n    // Let F(i) be # of distinct numbers after i moves\\n    // Assume F(i\\') holds for all i\\' < i\\n    // F(i) is related to F(i-1) depends on where the chess is on step i. Let K be number of distinct choice at step i, we have\\n    // If chess is on 0, 1, 2, 3, 7, 8, 9, K = 2\\n    // If chess is on 4, 6, K = 3\\n    // If chess is on 5, K = 0\\n    // Base case: F(1) = 1\\n\\n    private Integer[][] memo;\\n    private int[][] nextStep = {\\n            {4, 6},\\n            {6, 8},\\n            {7, 9},\\n            {4, 8},\\n            {3, 9, 0},\\n            {},\\n            {1, 7, 0},\\n            {2, 6},\\n            {1, 3},\\n            {4, 2},\\n    };\\n\\n    public int knightDialer(int N) {\\n        this.memo = new Integer[10][N + 1];\\n        int count = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            count += backtrack(i, N);\\n            count %= 1e9 + 7;\\n        }\\n        return count;\\n    }\\n\\n    private int backtrack(int curNum, int N) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n\\n        if (memo[curNum][N] != null) {\\n            return memo[curNum][N];\\n        }\\n\\n        memo[curNum][N] = 0;\\n        for (int nextNum : nextStep[curNum]) {\\n            memo[curNum][N] += backtrack(nextNum, N - 1);\\n            memo[curNum][N] %= (int)1e9 + 7;\\n        }\\n        return memo[curNum][N];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241756,
                "title": "python-dp-solution",
                "content": "```\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        c = 10**9+7\\n        next_step = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\\n        dp = [1]*10\\n        for i in range(N-1):\\n            new_dp = [0]*10\\n            for j in range(10):\\n                for n in next_step[j]:\\n                    new_dp[j] += dp[n]%c\\n                new_dp[j] %=c\\n            dp = new_dp\\n        return sum(dp)%c\\n```",
                "solutionTags": [],
                "code": "```\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        c = 10**9+7\\n        next_step = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\\n        dp = [1]*10\\n        for i in range(N-1):\\n            new_dp = [0]*10\\n            for j in range(10):\\n                for n in next_step[j]:\\n                    new_dp[j] += dp[n]%c\\n                new_dp[j] %=c\\n            dp = new_dp\\n        return sum(dp)%c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 205506,
                "title": "c-13line",
                "content": "```\\n    int knightDialer(int N) {\\n        const long long mod = 1e9 + 7;\\n        const vector<vector<int>> g = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0},\\n            {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        vector<long long> pre(10,1), cur(10,0);\\n        for(int i=0; i<N-1;i++){\\n            for(int j=0;j<10;j++){\\n                cur[j] = 0;\\n                for(auto neighbor : g[j]) cur[j] += pre[neighbor];\\n                cur[j] %= mod;\\n            }\\n            swap(cur, pre);\\n        }\\n        return accumulate(pre.begin(), pre.end(), 0LL) % mod;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int knightDialer(int N) {\\n        const long long mod = 1e9 + 7;\\n        const vector<vector<int>> g = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0},\\n            {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        vector<long long> pre(10,1), cur(10,0);\\n        for(int i=0; i<N-1;i++){\\n            for(int j=0;j<10;j++){\\n                cur[j] = 0;\\n                for(auto neighbor : g[j]) cur[j] += pre[neighbor];\\n                cur[j] %= mod;\\n            }\\n            swap(cur, pre);\\n        }\\n        return accumulate(pre.begin(), pre.end(), 0LL) % mod;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 190620,
                "title": "c-o-logn-time-o-1-space-complexity",
                "content": "If you represent the digits as nodes in a graph and create their adjacency matrix, you can raise the matrix to the (N - 1)th power to get a new adjacency matrix, the values of which now mean the number of different paths from node `i` to node `j` after (N - 1) moves. Using this in combination with the fast power for matrices allows you to do this all in O(logN).\\n\\nI\\'ve left my output of the resulting matrix there so that you can easily see it if you want to.\\n\\nI\\'ve already seen this solution here, but it was written in Python so I decided to share mine too.\\n\\n```\\n#define MOD 1000000007\\n#define DIGITS 10\\n\\nclass Solution {\\npublic:\\n    vector<vector<long long>> identity;\\n    vector<vector<long long>> edges;\\n    \\n    vector<vector<long long>> multiply(vector<vector<long long>> &m1, vector<vector<long long>> &m2) {\\n        vector<vector<long long>> result(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                for (int k = 0; k < DIGITS; k++) {\\n                    result[i][j] = (result[i][j] + m1[i][k] * m2[k][j]) % MOD;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<vector<long long>> matrixPower(vector<vector<long long>> &matrix, int n) {\\n        if (n == 0) {\\n            return identity;\\n        }\\n        if (n == 1) {\\n            return matrix;\\n        }\\n        vector<vector<long long>> half = matrixPower(matrix, n / 2);\\n        vector<vector<long long>> halfSquared = multiply(half, half);\\n        return n % 2 == 0\\n            ? halfSquared\\n            : multiply(halfSquared, matrix);\\n    }\\n    \\n    void addEdge(int a, int b) {\\n        edges[a][b] = edges[b][a] = 1;\\n    }\\n    \\n    int knightDialer(int N) {\\n        identity = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            identity[i][i] = 1;\\n        }\\n        edges = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        \\n        addEdge(0, 4);\\n        addEdge(0, 6);\\n        addEdge(1, 6);\\n        addEdge(1, 8);\\n        addEdge(2, 7);\\n        addEdge(2, 9);\\n        addEdge(3, 4);\\n        addEdge(3, 8);\\n        addEdge(4, 9);\\n        addEdge(6, 7);\\n        \\n        vector<vector<long long>> power = matrixPower(edges, N - 1);\\n        // for (int i = 0; i < DIGITS; i++) {\\n        //     for (int j = 0; j < DIGITS; j++) {\\n        //         cout << power[i][j] << \" \";\\n        //     }\\n        //     cout << \"\\\\n\";\\n        // }\\n        long long sum = 0;\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                sum += power[i][j];\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD 1000000007\\n#define DIGITS 10\\n\\nclass Solution {\\npublic:\\n    vector<vector<long long>> identity;\\n    vector<vector<long long>> edges;\\n    \\n    vector<vector<long long>> multiply(vector<vector<long long>> &m1, vector<vector<long long>> &m2) {\\n        vector<vector<long long>> result(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                for (int k = 0; k < DIGITS; k++) {\\n                    result[i][j] = (result[i][j] + m1[i][k] * m2[k][j]) % MOD;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<vector<long long>> matrixPower(vector<vector<long long>> &matrix, int n) {\\n        if (n == 0) {\\n            return identity;\\n        }\\n        if (n == 1) {\\n            return matrix;\\n        }\\n        vector<vector<long long>> half = matrixPower(matrix, n / 2);\\n        vector<vector<long long>> halfSquared = multiply(half, half);\\n        return n % 2 == 0\\n            ? halfSquared\\n            : multiply(halfSquared, matrix);\\n    }\\n    \\n    void addEdge(int a, int b) {\\n        edges[a][b] = edges[b][a] = 1;\\n    }\\n    \\n    int knightDialer(int N) {\\n        identity = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            identity[i][i] = 1;\\n        }\\n        edges = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        \\n        addEdge(0, 4);\\n        addEdge(0, 6);\\n        addEdge(1, 6);\\n        addEdge(1, 8);\\n        addEdge(2, 7);\\n        addEdge(2, 9);\\n        addEdge(3, 4);\\n        addEdge(3, 8);\\n        addEdge(4, 9);\\n        addEdge(6, 7);\\n        \\n        vector<vector<long long>> power = matrixPower(edges, N - 1);\\n        // for (int i = 0; i < DIGITS; i++) {\\n        //     for (int j = 0; j < DIGITS; j++) {\\n        //         cout << power[i][j] << \" \";\\n        //     }\\n        //     cout << \"\\\\n\";\\n        // }\\n        long long sum = 0;\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                sum += power[i][j];\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 189237,
                "title": "java-solution",
                "content": "```\\npublic int knightDialer(int n) {\\n    long[] last = new long[10];\\n    for (int j = 0; j < 10; j++)\\n        last[j] = 1;\\n\\n    long mod = 1000000007;\\n    for (int i = 1; i < n; i++) {\\n        long[] temp = new long[10];\\n        temp[0] = ((last[4] + last[6]) % mod);\\n        temp[1] = ((last[6] + last[8]) % mod);\\n        temp[2] = ((last[7] + last[9]) % mod);\\n        temp[3] = ((last[4] + last[8]) % mod);\\n        temp[4] = ((last[0] + last[3] + last[9]) % mod);\\n        temp[6] = ((last[0] + last[1] + last[7]) % mod);\\n        temp[7] = ((last[2] + last[6]) % mod);\\n        temp[8] = ((last[1] + last[3]) % mod);\\n        temp[9] = ((last[4] + last[2]) % mod);\\n        last = temp;\\n    }\\n    long sum = 0;\\n    for (long num : last)\\n        sum += num % mod;\\n\\n    return (int) (sum % mod);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int knightDialer(int n) {\\n    long[] last = new long[10];\\n    for (int j = 0; j < 10; j++)\\n        last[j] = 1;\\n\\n    long mod = 1000000007;\\n    for (int i = 1; i < n; i++) {\\n        long[] temp = new long[10];\\n        temp[0] = ((last[4] + last[6]) % mod);\\n        temp[1] = ((last[6] + last[8]) % mod);\\n        temp[2] = ((last[7] + last[9]) % mod);\\n        temp[3] = ((last[4] + last[8]) % mod);\\n        temp[4] = ((last[0] + last[3] + last[9]) % mod);\\n        temp[6] = ((last[0] + last[1] + last[7]) % mod);\\n        temp[7] = ((last[2] + last[6]) % mod);\\n        temp[8] = ((last[1] + last[3]) % mod);\\n        temp[9] = ((last[4] + last[2]) % mod);\\n        last = temp;\\n    }\\n    long sum = 0;\\n    for (long num : last)\\n        sum += num % mod;\\n\\n    return (int) (sum % mod);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069244,
                "title": "dp-both-approaches",
                "content": "# Recursive and Memoized Version (kinda noob one) \\n# Code\\n```\\nfunction knightDialer(len: number): number {\\n\\n  const dialpad = [\\n      [\\'1\\', \\'2\\', \\'3\\'],\\n      [\\'4\\', \\'5\\', \\'6\\'],\\n      [\\'7\\', \\'8\\', \\'9\\'],\\n      [\\'*\\', \\'0\\', \\'#\\'],\\n  ]\\n\\n const knight = (dialpad, n, i, j) => {\\n   if (\\n     i < 0 ||\\n     i >= dialpad.length ||\\n     j < 0 ||\\n     j >= dialpad[0].length ||\\n     dialpad[i][j] === \\'*\\' ||\\n     dialpad[i][j] === \\'#\\'\\n   ) \\n   return 0\\n\\n   if (n === 0) \\n     return 1\\n\\n   const k = `${i} - ${j} - ${n}`\\n\\n   if (!!dp.has(k)) \\n      return dp.get(k)\\n\\n   const ans =\\n     (knight(dialpad, n - 1, i + 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i + 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j - 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j - 1) % mod)\\n \\n  dp.set(k, ans)\\n  return ans\\n  \\n }\\n\\n let ans = 0\\n const mod = 1e9 + 7\\n let dp = new Map()\\n\\n for (let i = 0; i < dialpad.length; i++) {\\n   for (let j = 0; j < dialpad[0].length; j++) {\\n     let currentAns = knight(dialpad, len-1, i, j)\\n     ans += currentAns\\n   }\\n }\\n\\n return ans % mod;\\n};\\n```  \\n\\n# Tabulation\\nThink like a function f(n, d) where n is the input and d is a numner from 0 to 9 basically if i need \\nf(n, 1) = f(n-1, 6) + f(n-1, 4) \\nthese are 2 possible ways that could get me to one \\n\\n```\\nfunction knightDialer(n: number): number { \\n    const dp = new Array(n+1); \\n    const mod = 1e9 + 7\\n    for( let i = 0; i <= n; i++) { \\n        dp[i] = new Array(10);\\n    } \\n\\n    for( let i = 0; i <= n; i++) { \\n        for (let j = 0; j < 10; j++) {\\n            if(i === 0) dp[i][j] = 0; \\n            if( i === 1) dp[i][j] = 1; \\n         }\\n    } \\n\\n\\n    for(let i = 2; i <= n; i++) { \\n        for ( let j = 0; j < 10; j++) { \\n            if(j === 0) { dp[i][0] = (dp[i-1][6] + dp[i-1][4]) % mod  } \\n            if(j === 1) { dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod } \\n            if(j === 2) { dp[i][2] = (dp[i-1][9] + dp[i-1][7]) % mod } \\n            if(j === 3) { dp[i][3] =  (dp[i-1][8] + dp[i-1][4]) % mod } \\n            if(j === 4) { dp[i][4] =  (dp[i-1][9] + dp[i-1][0] + dp[i-1][3]) % mod } \\n            if(j === 5) { (dp[i][5] = 0) % mod } \\n            if(j === 6) { dp[i][6] =  (dp[i-1][0] + dp[i-1][7] + dp[i-1][1]) % mod}\\n            if(j === 7) { dp[i][7] =  (dp[i-1][2] + dp[i-1][6]) % mod }\\n            if(j === 8) { dp[i][8] =  (dp[i-1][1] + dp[i-1][3] )% mod }\\n            if(j === 9) { dp[i][9] =  (dp[i-1][4] + dp[i-1][2]) % mod } \\n        }\\n    } \\n\\n    let sum = 0; \\n    for( let i = 0; i < 10; i++) { \\n        sum+=dp[n][i]\\n    }\\n\\n return sum % mod;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction knightDialer(len: number): number {\\n\\n  const dialpad = [\\n      [\\'1\\', \\'2\\', \\'3\\'],\\n      [\\'4\\', \\'5\\', \\'6\\'],\\n      [\\'7\\', \\'8\\', \\'9\\'],\\n      [\\'*\\', \\'0\\', \\'#\\'],\\n  ]\\n\\n const knight = (dialpad, n, i, j) => {\\n   if (\\n     i < 0 ||\\n     i >= dialpad.length ||\\n     j < 0 ||\\n     j >= dialpad[0].length ||\\n     dialpad[i][j] === \\'*\\' ||\\n     dialpad[i][j] === \\'#\\'\\n   ) \\n   return 0\\n\\n   if (n === 0) \\n     return 1\\n\\n   const k = `${i} - ${j} - ${n}`\\n\\n   if (!!dp.has(k)) \\n      return dp.get(k)\\n\\n   const ans =\\n     (knight(dialpad, n - 1, i + 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i + 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j - 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j - 1) % mod)\\n \\n  dp.set(k, ans)\\n  return ans\\n  \\n }\\n\\n let ans = 0\\n const mod = 1e9 + 7\\n let dp = new Map()\\n\\n for (let i = 0; i < dialpad.length; i++) {\\n   for (let j = 0; j < dialpad[0].length; j++) {\\n     let currentAns = knight(dialpad, len-1, i, j)\\n     ans += currentAns\\n   }\\n }\\n\\n return ans % mod;\\n};\\n```\n```\\nfunction knightDialer(n: number): number { \\n    const dp = new Array(n+1); \\n    const mod = 1e9 + 7\\n    for( let i = 0; i <= n; i++) { \\n        dp[i] = new Array(10);\\n    } \\n\\n    for( let i = 0; i <= n; i++) { \\n        for (let j = 0; j < 10; j++) {\\n            if(i === 0) dp[i][j] = 0; \\n            if( i === 1) dp[i][j] = 1; \\n         }\\n    } \\n\\n\\n    for(let i = 2; i <= n; i++) { \\n        for ( let j = 0; j < 10; j++) { \\n            if(j === 0) { dp[i][0] = (dp[i-1][6] + dp[i-1][4]) % mod  } \\n            if(j === 1) { dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod } \\n            if(j === 2) { dp[i][2] = (dp[i-1][9] + dp[i-1][7]) % mod } \\n            if(j === 3) { dp[i][3] =  (dp[i-1][8] + dp[i-1][4]) % mod } \\n            if(j === 4) { dp[i][4] =  (dp[i-1][9] + dp[i-1][0] + dp[i-1][3]) % mod } \\n            if(j === 5) { (dp[i][5] = 0) % mod } \\n            if(j === 6) { dp[i][6] =  (dp[i-1][0] + dp[i-1][7] + dp[i-1][1]) % mod}\\n            if(j === 7) { dp[i][7] =  (dp[i-1][2] + dp[i-1][6]) % mod }\\n            if(j === 8) { dp[i][8] =  (dp[i-1][1] + dp[i-1][3] )% mod }\\n            if(j === 9) { dp[i][9] =  (dp[i-1][4] + dp[i-1][2]) % mod } \\n        }\\n    } \\n\\n    let sum = 0; \\n    for( let i = 0; i < 10; i++) { \\n        sum+=dp[n][i]\\n    }\\n\\n return sum % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960054,
                "title": "best-solution-for-beginners-easily-explained",
                "content": "# Complexity\\n- Time complexity: $$O(10*8*n)$$ = O(n) \\n\\n- Space complexity: $$O(10*n)$$ = O(n)\\n\\n# Code\\n```\\n//dp[num][movesLeft] represents no. of ways to make a combination \\n//when I am standing at number = \\'num\\' and having \\'movesLeft\\' more moves to make\\nclass Solution {\\n    //these are the valid knight moves in x and y direction\\n    vector<int> moveInX = {-2,-2,-1,1,2, 2, 1,-1};\\n    vector<int> moveInY = {-1, 1, 2,2,1,-1,-2,-2};\\n    int solve(int i, int j, int num, int movesLeft, vector<vector<int>>& phonePad, vector<vector<int>>& dp)\\n    { //base case\\n      if(movesLeft == 0)\\n       return 1;\\n      \\n      if(dp[num][movesLeft] != -1) //memoization step\\n       return dp[num][movesLeft];\\n\\n     dp[num][movesLeft] = 0;\\n     //explore all valid possibilities for next move\\n     for(int k=0; k<8; k++)\\n     {\\n         int r = i + moveInX[k];\\n         int c = j + moveInY[k];\\n        \\n         if(r >= 0 && r < 4 && c >= 0 && c < 3 && phonePad[r][c] != -1)\\n         { //reduce movesLeft by 1\\n          dp[num][movesLeft] += solve(r,c,phonePad[r][c],movesLeft-1,phonePad,dp);\\n          dp[num][movesLeft] = dp[num][movesLeft] % 1000000007; //to avoid overflow\\n         }\\n     }\\n    return dp[num][movesLeft];\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        int movesLeft = n;\\n        vector<vector<int>> phonePad;\\n        vector<vector<int>> dp(10,vector<int>(movesLeft+1,-1));\\n\\n        //draw a phone pad as shown in problem statement\\n        phonePad.push_back({ 1, 2, 3 });\\n        phonePad.push_back({ 4, 5, 6 });\\n        phonePad.push_back({ 7, 8, 9 });\\n        phonePad.push_back({-1, 0,-1 });\\n\\n        int ans = 0;\\n        for(int i=0; i<4; i++)\\n        {\\n            for(int j=0; j<3; j++)\\n            {\\n             if(phonePad[i][j] == -1)\\n              continue;\\n             //make n-1 moves starting from position [i,j]\\n             ans += solve(i,j,phonePad[i][j],movesLeft-1,phonePad,dp);\\n             ans = ans % 1000000007;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//dp[num][movesLeft] represents no. of ways to make a combination \\n//when I am standing at number = \\'num\\' and having \\'movesLeft\\' more moves to make\\nclass Solution {\\n    //these are the valid knight moves in x and y direction\\n    vector<int> moveInX = {-2,-2,-1,1,2, 2, 1,-1};\\n    vector<int> moveInY = {-1, 1, 2,2,1,-1,-2,-2};\\n    int solve(int i, int j, int num, int movesLeft, vector<vector<int>>& phonePad, vector<vector<int>>& dp)\\n    { //base case\\n      if(movesLeft == 0)\\n       return 1;\\n      \\n      if(dp[num][movesLeft] != -1) //memoization step\\n       return dp[num][movesLeft];\\n\\n     dp[num][movesLeft] = 0;\\n     //explore all valid possibilities for next move\\n     for(int k=0; k<8; k++)\\n     {\\n         int r = i + moveInX[k];\\n         int c = j + moveInY[k];\\n        \\n         if(r >= 0 && r < 4 && c >= 0 && c < 3 && phonePad[r][c] != -1)\\n         { //reduce movesLeft by 1\\n          dp[num][movesLeft] += solve(r,c,phonePad[r][c],movesLeft-1,phonePad,dp);\\n          dp[num][movesLeft] = dp[num][movesLeft] % 1000000007; //to avoid overflow\\n         }\\n     }\\n    return dp[num][movesLeft];\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        int movesLeft = n;\\n        vector<vector<int>> phonePad;\\n        vector<vector<int>> dp(10,vector<int>(movesLeft+1,-1));\\n\\n        //draw a phone pad as shown in problem statement\\n        phonePad.push_back({ 1, 2, 3 });\\n        phonePad.push_back({ 4, 5, 6 });\\n        phonePad.push_back({ 7, 8, 9 });\\n        phonePad.push_back({-1, 0,-1 });\\n\\n        int ans = 0;\\n        for(int i=0; i<4; i++)\\n        {\\n            for(int j=0; j<3; j++)\\n            {\\n             if(phonePad[i][j] == -1)\\n              continue;\\n             //make n-1 moves starting from position [i,j]\\n             ans += solve(i,j,phonePad[i][j],movesLeft-1,phonePad,dp);\\n             ans = ans % 1000000007;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927716,
                "title": "ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        prev = [1 for j in range(10)]\\n        for i in range(1,n):\\n            curr = [0 for j in range(10)]\\n            for j in range(10):\\n                \\n                curr[0] = prev[4] + prev[6]\\n                curr[1] = prev[8] + prev[6]\\n                curr[2] = prev[7] + prev[9]\\n                curr[3] = prev[4] + prev[8]\\n                curr[4] = prev[0] + prev[3] + prev[9]\\n                curr[5] = 0\\n                curr[6] = prev[7] + prev[1] + prev[0]\\n                curr[7] = prev[2] + prev[6]\\n                curr[8] = prev[1] + prev[3]\\n                curr[9] = prev[4] + prev[2]\\n            prev = curr\\n        \\n        return sum(prev)%1000000007\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        prev = [1 for j in range(10)]\\n        for i in range(1,n):\\n            curr = [0 for j in range(10)]\\n            for j in range(10):\\n                \\n                curr[0] = prev[4] + prev[6]\\n                curr[1] = prev[8] + prev[6]\\n                curr[2] = prev[7] + prev[9]\\n                curr[3] = prev[4] + prev[8]\\n                curr[4] = prev[0] + prev[3] + prev[9]\\n                curr[5] = 0\\n                curr[6] = prev[7] + prev[1] + prev[0]\\n                curr[7] = prev[2] + prev[6]\\n                curr[8] = prev[1] + prev[3]\\n                curr[9] = prev[4] + prev[2]\\n            prev = curr\\n        \\n        return sum(prev)%1000000007\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598919,
                "title": "python-solution-taking-each-possible-case-into-consideration-recursive-forumla-dp",
                "content": "Each number has only certain numbers Knight can move from\\nEg. From 1, Knight can move to 8 or 6 Similarly, we can map for all the numbers\\n\\nNow we can specify a recursive formula\\ndp[start, len]: Mentions the possibilities of len length phone numbers starting from start\\nfor all numbers in mapping[start]\\ndp[start, len] = sum(dp[num, len-1])\\n\\nNow, if we are at a number, the next move can be to any of the numbers it can go to\\n# Code\\n```python \\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        mapping = {\\n            0:[6,4],\\n            1:[6,8],\\n            2:[9,7],\\n            3:[4,8],\\n            4:[0,9,3],\\n            5:[],\\n            6:[0,7,1],\\n            7:[6,2],\\n            8:[3,1],\\n            9:[4,2]\\n        }\\n        mod = 1e9+7\\n        @cache\\n        def helper(num, l):\\n            if l == 0:\\n                return 1\\n            ans = 0\\n            for to in mapping[num]:\\n                ans = (ans+helper(to, l-1))%mod\\n            return ans\\n        ret = 0\\n        for i in range(10):\\n            ret = (ret+helper(i,n-1))%mod\\n        return int(ret)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python \\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        mapping = {\\n            0:[6,4],\\n            1:[6,8],\\n            2:[9,7],\\n            3:[4,8],\\n            4:[0,9,3],\\n            5:[],\\n            6:[0,7,1],\\n            7:[6,2],\\n            8:[3,1],\\n            9:[4,2]\\n        }\\n        mod = 1e9+7\\n        @cache\\n        def helper(num, l):\\n            if l == 0:\\n                return 1\\n            ans = 0\\n            for to in mapping[num]:\\n                ans = (ans+helper(to, l-1))%mod\\n            return ans\\n        ret = 0\\n        for i in range(10):\\n            ret = (ret+helper(i,n-1))%mod\\n        return int(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521767,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long c=1e9+7;\\n        if(n==1){\\n          return 10;\\n        }\\n        long long g0=10,g4=6,g2=4;\\n        long long l0=2,l1=8,l4=6,l2=4;\\n        for(int i=3;i<=n;i++){\\n            long long tl0=l0,tl1=l1,tl4=l4,tl2=l2;\\n            g0=((3*tl4)%c+(2*tl2)%c)%c;\\n            l0=tl4;\\n            g4=((2*tl0)%c+(tl1%c))%c;\\n            g2=tl1;\\n            l4=g4;\\n            l2=g2;\\n            l1=(g0%c-l0%c+c)%c;\\n        }\\n        long long sum=(g0+g4+g2)%c;\\n        return sum;\\n    }\\n};\\n```\\n\\n```Python3 []\\nadj = (\\n    (4, 6),\\n    (6, 8),\\n    (7, 9),\\n    (4, 8),\\n    (0, 3, 9),\\n    (),\\n    (0, 1, 7),\\n    (2, 6),\\n    (1, 3),\\n    (2, 4),\\n)\\n@functools.cache\\ndef knightDialerRec(positions, n):\\n    if n == 1:\\n        return len(positions)\\n    else:\\n        t = 0\\n        for p in positions:\\n            t += knightDialerRec(adj[p], n - 1)\\n            t %= 1000000007\\n        return t\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        return knightDialerRec(range(10), n)\\n```\\n\\n```Java []\\nclass Solution {\\n    long array[][],matrix[][],mod=1000000007;\\n    public void multiply(long ref1[][],long ref2[][]){\\n        long[][] ref=new long[ref1.length][ref2[0].length];\\n        for(int i=0;i<ref.length;i++)\\n            for(int j=0;j<ref2[0].length;j++)\\n                for(int k=0;k<ref2.length;k++)\\n                    ref[i][j]=(int)((ref[i][j]+ref1[i][k]*ref2[k][j]%mod)%mod);\\n        if(ref1!=ref2)array=ref;\\n        else matrix=ref;\\n    }\\n    public int knightDialer(int n) {\\n        matrix=new long[][]{{0,0,0,2}, {0,0,1,1}, {0,2,0,0}, {1,2,0,0}};\\n        array=new long[][]{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};\\n        if(n==1)return 10;n-=2;\\n        while(n!=0){\\n            if(n%2==1){multiply(array,matrix);n--;}\\n            else {multiply(matrix,matrix);n/=2;}\\n        }\\n        multiply(array,new long[][]{{2},{2},{2},{3}});\\n        return (int)((((array[0][0]+array[1][0]*4%mod)%mod+array[2][0]*2%mod)%mod+array[3][0]*2%mod)%mod);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long c=1e9+7;\\n        if(n==1){\\n          return 10;\\n        }\\n        long long g0=10,g4=6,g2=4;\\n        long long l0=2,l1=8,l4=6,l2=4;\\n        for(int i=3;i<=n;i++){\\n            long long tl0=l0,tl1=l1,tl4=l4,tl2=l2;\\n            g0=((3*tl4)%c+(2*tl2)%c)%c;\\n            l0=tl4;\\n            g4=((2*tl0)%c+(tl1%c))%c;\\n            g2=tl1;\\n            l4=g4;\\n            l2=g2;\\n            l1=(g0%c-l0%c+c)%c;\\n        }\\n        long long sum=(g0+g4+g2)%c;\\n        return sum;\\n    }\\n};\\n```\n```Python3 []\\nadj = (\\n    (4, 6),\\n    (6, 8),\\n    (7, 9),\\n    (4, 8),\\n    (0, 3, 9),\\n    (),\\n    (0, 1, 7),\\n    (2, 6),\\n    (1, 3),\\n    (2, 4),\\n)\\n@functools.cache\\ndef knightDialerRec(positions, n):\\n    if n == 1:\\n        return len(positions)\\n    else:\\n        t = 0\\n        for p in positions:\\n            t += knightDialerRec(adj[p], n - 1)\\n            t %= 1000000007\\n        return t\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        return knightDialerRec(range(10), n)\\n```\n```Java []\\nclass Solution {\\n    long array[][],matrix[][],mod=1000000007;\\n    public void multiply(long ref1[][],long ref2[][]){\\n        long[][] ref=new long[ref1.length][ref2[0].length];\\n        for(int i=0;i<ref.length;i++)\\n            for(int j=0;j<ref2[0].length;j++)\\n                for(int k=0;k<ref2.length;k++)\\n                    ref[i][j]=(int)((ref[i][j]+ref1[i][k]*ref2[k][j]%mod)%mod);\\n        if(ref1!=ref2)array=ref;\\n        else matrix=ref;\\n    }\\n    public int knightDialer(int n) {\\n        matrix=new long[][]{{0,0,0,2}, {0,0,1,1}, {0,2,0,0}, {1,2,0,0}};\\n        array=new long[][]{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};\\n        if(n==1)return 10;n-=2;\\n        while(n!=0){\\n            if(n%2==1){multiply(array,matrix);n--;}\\n            else {multiply(matrix,matrix);n/=2;}\\n        }\\n        multiply(array,new long[][]{{2},{2},{2},{3}});\\n        return (int)((((array[0][0]+array[1][0]*4%mod)%mod+array[2][0]*2%mod)%mod+array[3][0]*2%mod)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404090,
                "title": "hashmap-dp-c",
                "content": "# Code\\n```\\nclass Solution {\\n    long long int cnt=0;\\npublic:\\n    long long int solve(int i , unordered_map<int , vector<int>>& mp , int size ,vector <vector <long long int>>& dp)\\n    {\\n\\n        if(size==0){\\n            return 1;\\n        }\\n\\n        if(dp[i][size]!=-1) return dp[i][size];\\n\\n        long long int sum=0;\\n\\n        for(int j=0 ; j<mp[i].size() ; j++){\\n            sum+=solve(mp[i][j] ,mp , size-1 ,dp)%1000000007;\\n        }\\n\\n        dp[i][size]=sum;\\n        return dp[i][size];\\n    }\\n    int knightDialer(int n) {\\n        if(!n) return 0;\\n        cnt=0;\\n        vector <vector <long long int>> dp(10, vector<long long int> (n , -1));\\n        unordered_map<int , vector<int>> mp = {\\n            { 1 , {6,8} },\\n            { 2 , {7,9} },\\n            { 3 , {4,8} },\\n            { 4 , {0,3,9} },\\n            { 5 , {}},\\n            { 6 , {0,1,7}},\\n            { 7 , {2,6}},\\n            { 8 , {1,3}},\\n            { 9 , {2,4}},\\n            { 0 ,{4,6}}\\n        };\\n\\n        for(int it=0 ; it<=9 ; it++){\\n            cnt+=solve(it , mp ,n-1 , dp);\\n        }\\n\\n        return cnt % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long long int cnt=0;\\npublic:\\n    long long int solve(int i , unordered_map<int , vector<int>>& mp , int size ,vector <vector <long long int>>& dp)\\n    {\\n\\n        if(size==0){\\n            return 1;\\n        }\\n\\n        if(dp[i][size]!=-1) return dp[i][size];\\n\\n        long long int sum=0;\\n\\n        for(int j=0 ; j<mp[i].size() ; j++){\\n            sum+=solve(mp[i][j] ,mp , size-1 ,dp)%1000000007;\\n        }\\n\\n        dp[i][size]=sum;\\n        return dp[i][size];\\n    }\\n    int knightDialer(int n) {\\n        if(!n) return 0;\\n        cnt=0;\\n        vector <vector <long long int>> dp(10, vector<long long int> (n , -1));\\n        unordered_map<int , vector<int>> mp = {\\n            { 1 , {6,8} },\\n            { 2 , {7,9} },\\n            { 3 , {4,8} },\\n            { 4 , {0,3,9} },\\n            { 5 , {}},\\n            { 6 , {0,1,7}},\\n            { 7 , {2,6}},\\n            { 8 , {1,3}},\\n            { 9 , {2,4}},\\n            { 0 ,{4,6}}\\n        };\\n\\n        for(int it=0 ; it<=9 ; it++){\\n            cnt+=solve(it , mp ,n-1 , dp);\\n        }\\n\\n        return cnt % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387861,
                "title": "simple-and-easy-to-understand-approach-using-concept-of-dfs-and-memoization-clean-and-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimilar to problem [688. Knight Probability in Chessboard\\n](https://leetcode.com/problems/knight-probability-in-chessboard/\\n)\\nJust modified the constraints and base case\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(4x3xN)=O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Drow[8] = {2, 2, -2, -2, 1, 1, -1, -1};\\n    int Dcol[8] = {1, -1, 1, -1, 2, -2, 2, -2};\\n    vector<vector<vector<long long>>> dp;\\n    int mod = 1e9+7;\\n\\n    int knightDialer(int n) {\\n        dp.resize(4, vector<vector<long long>>(3, vector<long long>(n + 1, -1)));\\n        long long res = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                res = (res + solve(i, j, n)) % mod;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long solve(int row, int col, int n) {\\n        if (row < 0 || col < 0 || row >= 4 || col >= 3 || (row == 3 && (col == 0 || col == 2))) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (dp[row][col][n] != -1) {\\n            return dp[row][col][n]; \\n        }\\n        long long res = 0;\\n        for (int i = 0; i < 8; i++) {\\n            res = (res + solve(row + Drow[i], col + Dcol[i], n - 1))%mod ;\\n        }\\n        return dp[row][col][n] = res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Drow[8] = {2, 2, -2, -2, 1, 1, -1, -1};\\n    int Dcol[8] = {1, -1, 1, -1, 2, -2, 2, -2};\\n    vector<vector<vector<long long>>> dp;\\n    int mod = 1e9+7;\\n\\n    int knightDialer(int n) {\\n        dp.resize(4, vector<vector<long long>>(3, vector<long long>(n + 1, -1)));\\n        long long res = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                res = (res + solve(i, j, n)) % mod;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long solve(int row, int col, int n) {\\n        if (row < 0 || col < 0 || row >= 4 || col >= 3 || (row == 3 && (col == 0 || col == 2))) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (dp[row][col][n] != -1) {\\n            return dp[row][col][n]; \\n        }\\n        long long res = 0;\\n        for (int i = 0; i < 8; i++) {\\n            res = (res + solve(row + Drow[i], col + Dcol[i], n - 1))%mod ;\\n        }\\n        return dp[row][col][n] = res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362170,
                "title": "100-working-solution-in-java-recursion-memoization-dp",
                "content": "```\\nclass Solution {\\n    int mod= 1000000007;\\n    int[] dx= {-2,-1,1,2,2,1,-1,-2};\\n    int[] dy= {1,2,2,1,-1,-2,-2,-1};\\n    int[][][] dp= new int[5][4][5002];\\n    \\n    public int knightDialer(int n) {\\n        int[][] nums= new int[4][3];\\n        nums[3][1]= 0;\\n        nums[3][0]= -1;\\n        nums[3][2]= -1;\\n        int x=1;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                nums[i][j]=x;\\n                x++;\\n            }\\n        }\\n        \\n        for(int i=0; i<5; i++){\\n            for(int j=0; j<4; j++){\\n                for(int k=0; k<5002; k++){\\n                    dp[i][j][k]= -1;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(nums[i][j]!=-1){\\n                    ans= (ans+solve(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int solve(int[][] nums, int i, int j, int n){\\n        if(i<0 || j<0 || i>=4 || j>=3 || nums[i][j]==-1){\\n            return 0;\\n        }\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        \\n        if(dp[i][j][n]!=-1){\\n            return dp[i][j][n];\\n        }\\n        \\n        int t=0;\\n        for(int k=0; k<8; k++){\\n            int x= i+dx[k];\\n            int y= j+dy[k];\\n            \\n            t= (t+solve(nums,x,y,n-1))%mod;\\n        }\\n        \\n        return dp[i][j][n] = (t%mod);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    int mod= 1000000007;\\n    int[] dx= {-2,-1,1,2,2,1,-1,-2}",
                "codeTag": "Java"
            },
            {
                "id": 3040767,
                "title": "python-concise-dynamic-programming-bottom-up",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nObserve that, moving as a knight, you can only reach certain keys from certain others (we exclude `*` and `#` as they are not part of valid numbers)\\n\\nThus, the number of ways to reach a certain square is simply the sum of ways to reach each previous square that can lead to it. This screams dynamic programming!\\n \\n\\n# Code\\n```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # which keys can precede a certain key due to knight movement\\n        ways_to_reach_key = {\\n            0: [4, 6],\\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        # number of moves required to reach 0-9 as ending digit\\n        moves = [1 for _ in range(10)]\\n\\n        for _ in range(1, n):\\n            prev = deepcopy(moves)\\n            for j in range(10):\\n                moves[j] = sum([prev[k] % (10**9 + 7) for k in ways_to_reach_key[j]])  % (10**9 + 7)\\n            \\n        return sum(moves) % (10**9 + 7)\\n```\\n\\n# Optimization\\nWe make the code run a bit faster by taking advantage of mathematical property `( x + y ) % z == ( x % z + y % z ) % z` to make the intermediate numbers smaller. \\n\\nWe could make the code significantly faster by using a 2d array rather than updating it, but that would balloon the space complexity.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # which keys can precede a certain key due to knight movement\\n        ways_to_reach_key = {\\n            0: [4, 6],\\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        # number of moves required to reach 0-9 as ending digit\\n        moves = [1 for _ in range(10)]\\n\\n        for _ in range(1, n):\\n            prev = deepcopy(moves)\\n            for j in range(10):\\n                moves[j] = sum([prev[k] % (10**9 + 7) for k in ways_to_reach_key[j]])  % (10**9 + 7)\\n            \\n        return sum(moves) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904752,
                "title": "java-solution-easy-and-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int knightDialer(int n) {\\n       long mod = 1000000007;\\n\\t\\tlong[] dp = new long[10];\\n\\t\\tArrays.fill(dp, 1);\\n\\t\\tint ans = 0;\\n\\t\\t\\n\\t\\tfor(int i=1; i<n; i++) {\\n\\t\\t\\tlong[] temp = new long[10];\\n\\t\\t\\ttemp[0] = (dp[4] + dp[6]) % mod;\\n\\t\\t\\ttemp[1] = (dp[8] + dp[6]) % mod;\\n\\t\\t\\ttemp[2] = (dp[7] + dp[9]) % mod;\\n\\t\\t\\ttemp[3] = (dp[4] + dp[8]) % mod;\\n\\t\\t\\ttemp[4] = (((dp[3] + dp[9]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[6] = (((dp[7] + dp[1]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[7] = (dp[2] + dp[6]) % mod;\\n\\t\\t\\ttemp[8] = (dp[3] + dp[1]) % mod;\\n\\t\\t\\ttemp[9] = (dp[4] + dp[2]) % mod;\\n\\t\\t\\tdp = temp;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(long val : dp) {\\n\\t\\t\\tans = (int) ((ans + val) % mod);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n       long mod = 1000000007;\\n\\t\\tlong[] dp = new long[10];\\n\\t\\tArrays.fill(dp, 1);\\n\\t\\tint ans = 0;\\n\\t\\t\\n\\t\\tfor(int i=1; i<n; i++) {\\n\\t\\t\\tlong[] temp = new long[10];\\n\\t\\t\\ttemp[0] = (dp[4] + dp[6]) % mod;\\n\\t\\t\\ttemp[1] = (dp[8] + dp[6]) % mod;\\n\\t\\t\\ttemp[2] = (dp[7] + dp[9]) % mod;\\n\\t\\t\\ttemp[3] = (dp[4] + dp[8]) % mod;\\n\\t\\t\\ttemp[4] = (((dp[3] + dp[9]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[6] = (((dp[7] + dp[1]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[7] = (dp[2] + dp[6]) % mod;\\n\\t\\t\\ttemp[8] = (dp[3] + dp[1]) % mod;\\n\\t\\t\\ttemp[9] = (dp[4] + dp[2]) % mod;\\n\\t\\t\\tdp = temp;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(long val : dp) {\\n\\t\\t\\tans = (int) ((ans + val) % mod);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730909,
                "title": "c-dfs-recursion-memoization",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/7556f7f2-d573-40a0-b5a1-43b70eb0d6f2_1666409793.871762.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1},{-2,1},{2,-1},{2,1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n\\t\\tint mod=1e9+7;\\n\\t\\tint dfs(int i,int j,int n){\\n\\t\\t\\tif(!n) return 1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(auto d:dir){\\n\\t\\t\\t\\tint r=i+d.first;\\n\\t\\t\\t\\tint c=j+d.second;\\n\\t\\t\\t\\tif(r<3 && r>=0 && c<3 && c>=0) ans+=dfs(r,c,n-1)%mod;\\n\\t\\t\\t\\telse if(r==3 && c==1) ans+=dfs(r,c,n-1)%mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans%mod;\\n\\t\\t}\\n\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\tfor(int j=0;j<3;j++){\\n\\t\\t\\t\\t\\tif((i==3 && j==0) || (i==3 && j==2)) continue;\\n\\t\\t\\t\\t\\tcount+=dfs(i,j,n-1)%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count%mod;\\n\\t\\t}\\n\\t};\\n\\n\\n# Method -2 [Memoization]\\n![image](https://assets.leetcode.com/users/images/a669d023-8e91-4f93-af77-84df93d8d6ea_1666409807.1825833.png)\\n\\n**T->O(12 * n) && S->O(12 * n) && O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1},{-2,1},{2,-1},{2,1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n\\t\\tint mod=1e9+7;\\n\\t\\tint dfs(int i,int j,int n,vector<vector<vector<int>>>& dp){\\n\\t\\t\\tif(!n) return 1;\\n\\t\\t\\tif(dp[i][j][n]!=-1) return dp[i][j][n];\\n\\t\\t\\tlong long ans=0;\\n\\t\\t\\tfor(auto d:dir){\\n\\t\\t\\t\\tint r=i+d.first;\\n\\t\\t\\t\\tint c=j+d.second;\\n\\t\\t\\t\\tif(r<3 && r>=0 && c<3 && c>=0) ans+=dfs(r,c,n-1,dp)%mod;\\n\\t\\t\\t\\telse if(r==3 && c==1) ans+=dfs(r,c,n-1,dp)%mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][j][n]=ans%mod;\\n\\t\\t}\\n\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tvector<vector<vector<int>>> dp(4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\tfor(int j=0;j<3;j++){\\n\\t\\t\\t\\t\\tif((i==3 && j==0) || (i==3 && j==2)) continue;\\n\\t\\t\\t\\t\\tcount+=dfs(i,j,n-1,dp)%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count%mod;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2608668,
                "title": "935",
                "content": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tjumps ={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[6,2],8:[1,3],9:[2,4]}\\n\\t\\t\\tdp = [1]*10\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tfor _ in range(n-1):\\n\\t\\t\\t\\tnewdp = [0]*10\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tfor j in jumps[i]:\\n\\t\\t\\t\\t\\t\\tnewdp[i] += dp[j]\\n\\t\\t\\t\\t\\t\\tnewdp[i] %= mod\\n\\t\\t\\t\\tdp = newdp\\n\\n\\t\\t\\treturn sum(dp)%mod",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tjumps ={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[6,2],8:[1,3],9:[2,4]}",
                "codeTag": "Java"
            },
            {
                "id": 2569606,
                "title": "java-completely-explained-tabulation-efficient",
                "content": "```\\nclass Solution {\\n    // this stores the cells  we can reach from every index after executing a chess movement\\n    int[][] cells = {{4,6}, {6,8}, {7,9},{4,8},{3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};\\n    public int knightDialer(int n) {\\n        \\n        /*\\n           we decide that in the beggining all the actions and movements by the knight has been completed and for each \\n           cell we check from which positions it has come like for eg. to come to zero we can arrive from 4 and 6 and so on and\\n           we traverse back to initial positions with each increasing n.\\n        */\\n        \\n        int [][] dp =new int[n+1][10];\\n        \\n        // first row is filled with zeroes and second row is filled with ones \\n        // cause we have to move n-1 times\\n        for(int j=0;j<dp[0].length;j++)\\n        {\\n            dp[1][j]=1;\\n        }\\n        \\n        for(int i=2;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                 for(int cell :cells[j])\\n                 {\\n                     dp[i][j] = (dp[i][j] +dp[i-1][cell]) % 1000000007;\\n                 }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int k=0;k<dp[0].length;k++)\\n        {\\n            res= (res + dp[n][k])  % 1000000007;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    // this stores the cells  we can reach from every index after executing a chess movement\\n    int[][] cells = {{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 2547327,
                "title": "python3-dp-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tM = 1000000007\\n\\t\\t\\tdp = [[0] * n for _ in range(10)]\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tdp[i][0] = 1\\n\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tdp[1][i] = dp[6][i - 1] + dp[8][i - 1]\\n\\t\\t\\t\\tdp[2][i] = dp[7][i - 1] + dp[9][i - 1]\\n\\t\\t\\t\\tdp[3][i] = dp[8][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tdp[4][i] = dp[3][i - 1] + dp[9][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[5][i] = 0\\n\\t\\t\\t\\tdp[6][i] = dp[1][i - 1] + dp[7][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[7][i] = dp[2][i - 1] + dp[6][i - 1]\\n\\t\\t\\t\\tdp[8][i] = dp[3][i - 1] + dp[1][i - 1]\\n\\t\\t\\t\\tdp[9][i] = dp[4][i - 1] + dp[2][i - 1]\\n\\t\\t\\t\\tdp[0][i] = dp[6][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tfor j in range(10):\\n\\t\\t\\t\\t\\tdp[j][i] %= M\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tres += dp[i][n - 1]\\n\\t\\t\\treturn res % M",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tM = 1000000007\\n\\t\\t\\tdp = [[0] * n for _ in range(10)]\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tdp[i][0] = 1\\n\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tdp[1][i] = dp[6][i - 1] + dp[8][i - 1]\\n\\t\\t\\t\\tdp[2][i] = dp[7][i - 1] + dp[9][i - 1]\\n\\t\\t\\t\\tdp[3][i] = dp[8][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tdp[4][i] = dp[3][i - 1] + dp[9][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[5][i] = 0\\n\\t\\t\\t\\tdp[6][i] = dp[1][i - 1] + dp[7][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[7][i] = dp[2][i - 1] + dp[6][i - 1]\\n\\t\\t\\t\\tdp[8][i] = dp[3][i - 1] + dp[1][i - 1]\\n\\t\\t\\t\\tdp[9][i] = dp[4][i - 1] + dp[2][i - 1]\\n\\t\\t\\t\\tdp[0][i] = dp[6][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tfor j in range(10):\\n\\t\\t\\t\\t\\tdp[j][i] %= M\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tres += dp[i][n - 1]\\n\\t\\t\\treturn res % M",
                "codeTag": "Java"
            },
            {
                "id": 2453739,
                "title": "c-dp-tabulation-method-tc-o-n-sc-o-1",
                "content": "* Using constant extra space of number of numeric digits in the keypad ,i.e, 10.\\n* Time Complexity is O(n*number_of_numeric_digits).\\n* Upvote if you like the solution.\\n```\\n#define ll long long\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector<ll> prev(10,1);\\n        vector<ll> curr=prev;ll lastSum=10;\\n        for(int j=0;j<n-1;j++){\\n            lastSum=0;\\n                for(int i=0;i<=9;i++){\\n                if(i==0) curr[i]=(prev[4]+prev[6])%mod;\\n                else if(i==1) curr[i]=(prev[6]+prev[8])%mod;\\n                else if(i==2) curr[i]=(prev[7]+prev[9])%mod;\\n                else if(i==3) curr[i]=(prev[4]+prev[8])%mod;\\n                else if(i==4) curr[i]=(prev[3]+prev[9]+prev[0])%mod;\\n                else if(i==5) curr[i]=0;\\n                else if(i==6) curr[i]=(prev[7]+prev[1]+prev[0])%mod;\\n                else if(i==7) curr[i]=(prev[2]+prev[6])%mod;\\n                else if(i==8) curr[i]=(prev[1]+prev[3])%mod;\\n                else curr[i]=(prev[4]+prev[2])%mod;\\n                    lastSum+=curr[i]%mod;\\n            }\\n            prev=curr;\\n        }\\n        return lastSum%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector<ll> prev(10,1);\\n        vector<ll> curr=prev;ll lastSum=10;\\n        for(int j=0;j<n-1;j++){\\n            lastSum=0;\\n                for(int i=0;i<=9;i++){\\n                if(i==0) curr[i]=(prev[4]+prev[6])%mod;\\n                else if(i==1) curr[i]=(prev[6]+prev[8])%mod;\\n                else if(i==2) curr[i]=(prev[7]+prev[9])%mod;\\n                else if(i==3) curr[i]=(prev[4]+prev[8])%mod;\\n                else if(i==4) curr[i]=(prev[3]+prev[9]+prev[0])%mod;\\n                else if(i==5) curr[i]=0;\\n                else if(i==6) curr[i]=(prev[7]+prev[1]+prev[0])%mod;\\n                else if(i==7) curr[i]=(prev[2]+prev[6])%mod;\\n                else if(i==8) curr[i]=(prev[1]+prev[3])%mod;\\n                else curr[i]=(prev[4]+prev[2])%mod;\\n                    lastSum+=curr[i]%mod;\\n            }\\n            prev=curr;\\n        }\\n        return lastSum%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422753,
                "title": "python-different-solution-with-thorough-explanation",
                "content": "# Method One: Smart\\nWe have `x0` through `x9` for each of the digits on the number pad that represent the amount of possible phone numbers that it can dial (we continuously update it as we move iterations).\\n\\nThe intuition is that we iterate through `n-1` times and each time we update `x0` through `x9` to be the sum of the total possible paths that they can do. \\n\\nFor example, from `x1` the knight can jump to `x6` or `x8`, so we update `x1` to be the sum of `x6` and `x8`. After that, the amount of total combinations will be the sum of the total combinations of each pad. Of course, we handle the mod.\\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(n-1):\\n            x1,x2,x3,x4,x5,x6,x7,x8,x9,x0 = x6+x8, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x4+x2, x4+x6\\n        return (x1+x2+x3+x4+x5+x6+x7+x8+x9+x0) % (10**9+7)\\n```\\n\\t\\n# Method 2: Recursion with Memo\\nWe use recursion with memorization here to avoid the nasty TLE errors.\\nThe intuition is the same as method 1, but implemented a bit differently. \\n\\nWe map each cell to the possible paths it could take the the next ceoo. I used `-1` as the pad before the knight is on the number pad, since the knight can start at any cell. We use a helper function to recurse and get the count of total possible paths. \\n\\nWe pass our paths dictionary, `n` as the index (amount of digits dialed), `-1` as the starting cell, but `curr` will eventually be the current cell, and our cache (initialized to `{}`). \\n\\nInside the helper function:\\n1. check if current index + path are already saved: if yes, just return it (that\\'s literally the entire point of caching and memo)\\n2. if the index is 0 (we haven\\'t even started yet), we can only dial 1 number: the number we are on right now\\n\\nNow the real stuff is starting:\\n3. initialize count to be total amount of paths\\n4. for every possible path from this current cell,\\n5. we recurse the previous index and add that to our count\\n6. save it to the cache\\n7. the helper function returns an integer `count`: the total number of paths from `curr` at index `n`. \\n\\nNote: the initial call for the helper function has parameter `idx` of `n`, not `n-1` since we start from the dummy pad -1. \\n\\nAnd we return the function return mod 10^9 + 7.\\n\\nRecursion expansion:\\n[![image](https://assets.leetcode.com/users/images/3c66d256-869d-4146-85ae-6a10b5addbfa_1660512488.936091.png)\\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(n-1):\\n            x1,x2,x3,x4,x5,x6,x7,x8,x9,x0 = x6+x8, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x4+x2, x4+x6\\n        return (x1+x2+x3+x4+x5+x6+x7+x8+x9+x0) % (10**9+7)\\n```\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396607,
                "title": "java-recursion-memoization-easy-solution",
                "content": "```\\nclass Solution {\\n    int[] dx = {-2, -2, 2, 2, 1, -1, 1, -1};\\n    int[] dy = {1, -1, -1, 1, 2, 2, -2, -2};\\n    int[][] nums;\\n    long MOD = 1000000000+7;\\n    Long[][][] dp;\\n    boolean isValid(int i, int j, int n, int m){\\n        if(i < 0 || i >= n || j < 0 || j >= m || nums[i][j] == -1) return false;\\n        else return true;\\n    }\\n    \\n    long helper(int i, int j, int n, int r, int c){\\n        if(n == 0) return 1;\\n        \\n        if(dp[i][j][n] != null) return dp[i][j][n];\\n        \\n        long ans = 0;\\n        for(int k = 0; k < 8; k++){\\n            int nx = i + dx[k];\\n            int ny = j + dy[k];\\n            if(isValid(nx, ny, r, c)){\\n                ans += helper(nx, ny, n-1, r, c);\\n                ans = ans%MOD;\\n            }\\n        }\\n        \\n        return dp[i][j][n] = ans;\\n    }\\n    public int knightDialer(int n) {\\n        nums = new int[4][3];\\n        nums[3][0] = -1;\\n        nums[3][2] = -1;\\n        dp = new Long[5][5][n+1];\\n        long ans = 0L;\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < 3; j++){\\n                if(nums[i][j] != -1){\\n                    ans += helper(i, j, n-1, 4, 3);\\n                    ans = ans%MOD;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] dx = {-2, -2, 2, 2, 1, -1, 1, -1};\\n    int[] dy = {1, -1, -1, 1, 2, 2, -2, -2};\\n    int[][] nums;\\n    long MOD = 1000000000+7;\\n    Long[][][] dp;\\n    boolean isValid(int i, int j, int n, int m){\\n        if(i < 0 || i >= n || j < 0 || j >= m || nums[i][j] == -1) return false;\\n        else return true;\\n    }\\n    \\n    long helper(int i, int j, int n, int r, int c){\\n        if(n == 0) return 1;\\n        \\n        if(dp[i][j][n] != null) return dp[i][j][n];\\n        \\n        long ans = 0;\\n        for(int k = 0; k < 8; k++){\\n            int nx = i + dx[k];\\n            int ny = j + dy[k];\\n            if(isValid(nx, ny, r, c)){\\n                ans += helper(nx, ny, n-1, r, c);\\n                ans = ans%MOD;\\n            }\\n        }\\n        \\n        return dp[i][j][n] = ans;\\n    }\\n    public int knightDialer(int n) {\\n        nums = new int[4][3];\\n        nums[3][0] = -1;\\n        nums[3][2] = -1;\\n        dp = new Long[5][5][n+1];\\n        long ans = 0L;\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < 3; j++){\\n                if(nums[i][j] != -1){\\n                    ans += helper(i, j, n-1, 4, 3);\\n                    ans = ans%MOD;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392430,
                "title": "c-wrong-what-s-wrong",
                "content": "```\\n\\nGetting wrong answer what i missing anyone ?????\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n     long int one=1,two=1,three=1,four=1,five=1,six=1,seven=1,eight=1,nine=1,zero=1,star=0,hash=0;\\n      long int  one1,two1,three1,four1,five1,six1,seven1,eight1,nine1,zero1,star1,hash1; \\n        long mod=pow(10,9)+7;\\n        for(int j=2;j<=n;j++){\\n            one1=(eight+six)%mod;\\n                two1=(seven+nine)%mod;\\n                three1=(eight+four)%mod;\\n                four1=(zero+three)%mod;\\n                // five1=()%mod;\\n            five1=(star+hash)%mod;\\n                six1=(zero+one)%mod;\\n            seven1=(six+two+hash)%mod;\\n                eight1=(three+one)%mod;\\n                nine1=(two+four+star)%mod;\\nzero1= (six+four)%mod;\\n            star1=(five+nine)%mod;\\n            hash1=(five+seven)%mod;\\none=one1,two=two1,three=three1,four=four1,five=five1,six=six1,seven=seven1,eight=eight1,nine=nine1,zero=zero1,star=star1,hash=hash1;\\n        }\\n        return (one+two+three+four+five+six+seven+eight+nine+zero+star+hash)%mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int knightDialer(int n) {\\n     long int one=1,two=1,three=1,four=1,five=1,six=1,seven=1,eight=1,nine=1,zero=1,star=0,hash=0;\\n      long int  one1,two1,three1,four1,five1,six1,seven1,eight1,nine1,zero1,star1,hash1; \\n        long mod=pow(10,9)+7;\\n        for(int j=2;j<=n;j++){\\n            one1=(eight+six)%mod;\\n                two1=(seven+nine)%mod;\\n                three1=(eight+four)%mod;\\n                four1=(zero+three)%mod;\\n                // five1=()%mod;\\n            five1=(star+hash)%mod;\\n                six1=(zero+one)%mod;\\n            seven1=(six+two+hash)%mod;\\n                eight1=(three+one)%mod;\\n                nine1=(two+four+star)%mod;\\nzero1= (six+four)%mod;\\n            star1=(five+nine)%mod;\\n            hash1=(five+seven)%mod;\\none=one1,two=two1,three=three1,four=four1,five=five1,six=six1,seven=seven1,eight=eight1,nine=nine1,zero=zero1,star=star1,hash=hash1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2369123,
                "title": "java-dp-o-1-space-o-n-time",
                "content": "```java\\nclass Solution {\\n    public int knightDialer(int n) {\\n        var dp = new long[10];\\n        var tmp = new long[10];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < n; i++) {\\n            tmp[1] = dp[6]+dp[8];\\n            tmp[2] = dp[7]+dp[9];\\n            tmp[3] = dp[4]+dp[8];\\n            tmp[4] = dp[0]+dp[3]+dp[9];\\n            tmp[5] = 0;\\n            tmp[6] = dp[0]+dp[1]+dp[7];\\n            tmp[7] = dp[2]+dp[6];\\n            tmp[8] = dp[1]+dp[3];\\n            tmp[9] = dp[2]+dp[4];\\n            tmp[0] = dp[4]+dp[6];\\n            for (int j = 0; j < 10; j++) tmp[j] = tmp[j] % 1000000007;\\n            var arr = dp;\\n            dp = tmp;\\n            tmp = arr;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 10; i++) {\\n            res = (res+dp[i]) % 1000000007;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int knightDialer(int n) {\\n        var dp = new long[10];\\n        var tmp = new long[10];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < n; i++) {\\n            tmp[1] = dp[6]+dp[8];\\n            tmp[2] = dp[7]+dp[9];\\n            tmp[3] = dp[4]+dp[8];\\n            tmp[4] = dp[0]+dp[3]+dp[9];\\n            tmp[5] = 0;\\n            tmp[6] = dp[0]+dp[1]+dp[7];\\n            tmp[7] = dp[2]+dp[6];\\n            tmp[8] = dp[1]+dp[3];\\n            tmp[9] = dp[2]+dp[4];\\n            tmp[0] = dp[4]+dp[6];\\n            for (int j = 0; j < 10; j++) tmp[j] = tmp[j] % 1000000007;\\n            var arr = dp;\\n            dp = tmp;\\n            tmp = arr;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 10; i++) {\\n            res = (res+dp[i]) % 1000000007;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363389,
                "title": "python-matrix-multiplication-solution",
                "content": "Start with identity matrix and multiply by M^2i at the relevant bits!\\nI mistook the bit breakdown (addition) and forgot it\\'s actually in the power when solving the problem\\nWe just keep multiplying till the end, and finally sum all the elements up\\n\\nSimilar problem: [Leetcode 552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/)\\n\\nThat one is little harder to arrive at the state transitions though\\n```\\nclass Solution:\\n    # This look like a matrix multiplication problem\\n    # At least, we see that there are well defined transitions possible\\n    # 1 -> 6, 8\\n    # 2 -> 7, 9\\n    # 3 -> 4, 8\\n    # 4 -> 3, 9, 0\\n    # 5 -> {}\\n    # 6 -> 1, 7, 0\\n    # 7 -> 2, 6\\n    # 8 -> 1, 3\\n    # 9 -> 2, 4\\n    # 0 -> 4, 6\\n    # The transition matrix M is well defined\\n    # Then we can break down n into power of 2s. (n >> i = 1 or not)\\n    # And just sum up the matrix contribution each time it is squared\\n    def matrix_multiply(self, A, C):\\n        n = len(A)\\n        B = [[0 for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    B[i][j] += A[i][k]*C[k][j] \\n                    B[i][j] %= self.MOD\\n        return B\\n    \\n    def knightDialer(self, n: int) -> int:\\n        self.MOD = pow(10, 9) + 7\\n        M = [[0,0,0,0,1,0,1,0,0,0],\\n             [0,0,0,0,0,0,1,0,1,0],\\n             [0,0,0,0,0,0,0,1,0,1],\\n             [0,0,0,0,1,0,0,0,1,0],\\n             [1,0,0,1,0,0,0,0,0,1],\\n             [0,0,0,0,0,0,0,0,0,0],\\n             [1,1,0,0,0,0,0,1,0,0],\\n             [0,0,1,0,0,0,1,0,0,0],\\n             [0,1,0,1,0,0,0,0,0,0],\\n             [0,0,1,0,1,0,0,0,0,0]]\\n        seed = [[0 for i in range(10)] for j in range(10)] \\n        for i in range(10):\\n            seed[i][i] = 1\\n        \\n        \\n        for i in range((n-1).bit_length()):\\n            if (n-1) & (1 << i) != 0:\\n                seed = self.matrix_multiply(seed, M)\\n            M = self.matrix_multiply(M, M)\\n        \\n        result = 0    \\n        for j in range(10):\\n            for k in range(10):\\n                result += seed[j][k]\\n                result %= self.MOD\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # This look like a matrix multiplication problem\\n    # At least, we see that there are well defined transitions possible\\n    # 1 -> 6, 8\\n    # 2 -> 7, 9\\n    # 3 -> 4, 8\\n    # 4 -> 3, 9, 0\\n    # 5 -> {}\\n    # 6 -> 1, 7, 0\\n    # 7 -> 2, 6\\n    # 8 -> 1, 3\\n    # 9 -> 2, 4\\n    # 0 -> 4, 6\\n    # The transition matrix M is well defined\\n    # Then we can break down n into power of 2s. (n >> i = 1 or not)\\n    # And just sum up the matrix contribution each time it is squared\\n    def matrix_multiply(self, A, C):\\n        n = len(A)\\n        B = [[0 for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    B[i][j] += A[i][k]*C[k][j] \\n                    B[i][j] %= self.MOD\\n        return B\\n    \\n    def knightDialer(self, n: int) -> int:\\n        self.MOD = pow(10, 9) + 7\\n        M = [[0,0,0,0,1,0,1,0,0,0],\\n             [0,0,0,0,0,0,1,0,1,0],\\n             [0,0,0,0,0,0,0,1,0,1],\\n             [0,0,0,0,1,0,0,0,1,0],\\n             [1,0,0,1,0,0,0,0,0,1],\\n             [0,0,0,0,0,0,0,0,0,0],\\n             [1,1,0,0,0,0,0,1,0,0],\\n             [0,0,1,0,0,0,1,0,0,0],\\n             [0,1,0,1,0,0,0,0,0,0],\\n             [0,0,1,0,1,0,0,0,0,0]]\\n        seed = [[0 for i in range(10)] for j in range(10)] \\n        for i in range(10):\\n            seed[i][i] = 1\\n        \\n        \\n        for i in range((n-1).bit_length()):\\n            if (n-1) & (1 << i) != 0:\\n                seed = self.matrix_multiply(seed, M)\\n            M = self.matrix_multiply(M, M)\\n        \\n        result = 0    \\n        for j in range(10):\\n            for k in range(10):\\n                result += seed[j][k]\\n                result %= self.MOD\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308692,
                "title": "o-logn-solution",
                "content": "```\\npublic class Solution {\\n    public int KnightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        long[,] matrix = {\\n            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},\\n            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\\n            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},\\n            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},\\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\\n            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},                     \\n            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},\\n            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},\\n            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0},            \\n        };\\n        long[,] res = {\\n            {1,1,1,1,1,1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){ \\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n=n/2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n--;\\n            }\\n        }\\n        long count=0;\\n        for(int c=0;c<10;c++){\\n            count= (count+res[0,c])%1000000007;\\n        }\\n        return (int)count;\\n        \\n    }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[10,10];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    product[i,j] = (product[i,j] + matrix1[i,k]*matrix2[j,k])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int KnightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        long[,] matrix = {\\n            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},\\n            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\\n            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},\\n            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},\\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\\n            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},                     \\n            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},\\n            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},\\n            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0},            \\n        };\\n        long[,] res = {\\n            {1,1,1,1,1,1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){ \\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n=n/2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n--;\\n            }\\n        }\\n        long count=0;\\n        for(int c=0;c<10;c++){\\n            count= (count+res[0,c])%1000000007;\\n        }\\n        return (int)count;\\n        \\n    }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[10,10];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    product[i,j] = (product[i,j] + matrix1[i,k]*matrix2[j,k])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267066,
                "title": "70-86-faster-pyhton-dynamic-programming-tabulation-d-p",
                "content": "If you think you are weak in Dynamic Programming please watch the Dynamic playlist by Striver on youtube the link is given below .It helped me a lot.\\n[https://www.youtube.com/watch?v=FfXoiwwnxFw&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY](http://)\\nThe dpTab is the ap array keeps the track of the previous iteration with all the numbers excluding 5 as 5 can never be obtained n>=2 .\\nThe code for the same is given below .\\nI will request you all to understand the recursive code first then move on to Tabulated one .\\n\\n\\n**RECURSIVE CODE:---(WILL GIVE TLE)**\\n```\\nimport collections\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        def moves(adj,n,curr,dp):\\n            mod=10**9+7\\n            if(n==0):\\n                return 1\\n            if(dp[str(n)+\\'.\\'+str(curr)]!=-1):\\n                return dp[str(n)+\\'.\\'+str(curr)]\\n            a=0\\n            for j in adj[curr]:\\n                a=(a+ moves(adj,n-1,j,dp))%mod\\n            dp[str(n)+\\'.\\'+str(curr)]=a%mod\\n            return dp[str(n)+\\'.\\'+str(curr)]\\n        \\n        sumi=0\\n        def re():\\n            return -1\\n        dp=collections.defaultdict(re)\\n        mod=10**9+7\\n        for i in range(10):\\n            if(i==5):\\n                continue\\n            sumi=(sumi+moves(adj,n-1,i,dp))%mod\\n        return sumi\\n```\\n\\n\\n\\n**TABULATED CODE (ACCEPTED!)**\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        mod=10**9+7\\n        def tab():\\n            dpTab=[[0 for i in range(10)] for _ in range(n)]\\n            for i in range(10):\\n                dpTab[0][i]=1\\n            for i in range(1,n):\\n                for curr in range(10):\\n                    if(curr==5):\\n                        continue\\n                    a=0\\n                    for j in adj[curr]:\\n                        a=(a+dpTab[i-1][j])%mod\\n                    dpTab[i][curr]=a%mod\\n            return sum(dpTab[n-1])%mod\\n        return tab()\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        def moves(adj,n,curr,dp):\\n            mod=10**9+7\\n            if(n==0):\\n                return 1\\n            if(dp[str(n)+\\'.\\'+str(curr)]!=-1):\\n                return dp[str(n)+\\'.\\'+str(curr)]\\n            a=0\\n            for j in adj[curr]:\\n                a=(a+ moves(adj,n-1,j,dp))%mod\\n            dp[str(n)+\\'.\\'+str(curr)]=a%mod\\n            return dp[str(n)+\\'.\\'+str(curr)]\\n        \\n        sumi=0\\n        def re():\\n            return -1\\n        dp=collections.defaultdict(re)\\n        mod=10**9+7\\n        for i in range(10):\\n            if(i==5):\\n                continue\\n            sumi=(sumi+moves(adj,n-1,i,dp))%mod\\n        return sumi\\n```\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        mod=10**9+7\\n        def tab():\\n            dpTab=[[0 for i in range(10)] for _ in range(n)]\\n            for i in range(10):\\n                dpTab[0][i]=1\\n            for i in range(1,n):\\n                for curr in range(10):\\n                    if(curr==5):\\n                        continue\\n                    a=0\\n                    for j in adj[curr]:\\n                        a=(a+dpTab[i-1][j])%mod\\n                    dpTab[i][curr]=a%mod\\n            return sum(dpTab[n-1])%mod\\n        return tab()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247460,
                "title": "easy-java-solution-dp",
                "content": "**Please upvote if you like the solution, Happy learning!**\\n**Explanation:**\\n1. First fill the map with possible positions knight can move from every number from `0 - 9`\\n2. Since now you know from every position, where is the next step, start running  a path finder from `0-9`\\n\\n```\\nclass Solution {\\n    private void init(Map<Integer, List<Integer>> map) {\\n        map.put(0, Arrays.asList(4, 6));\\n        map.put(1, Arrays.asList(6, 8));\\n        map.put(2, Arrays.asList(7, 9));\\n        map.put(3, Arrays.asList(4, 8));\\n        map.put(4, Arrays.asList(0, 3, 9));\\n        map.put(5, Arrays.asList());\\n        map.put(6, Arrays.asList(0, 1, 7));\\n        map.put(7, Arrays.asList(2, 6));\\n        map.put(8, Arrays.asList(1, 3));\\n        map.put(9, Arrays.asList(2, 4));\\n    }\\n    private Map<Integer, List<Integer>> map = new HashMap();\\n    private static final int mod = (int) 1e9 + 7;\\n    private Integer dp[][];\\n    public int knightDialer(int n) {\\n        init(map);\\n        this.dp = new Integer[10][n+1];\\n        int ans = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            ans = (ans + paths(i, n - 1)) % mod;\\n        }\\n        return ans;\\n    }\\n    \\n    private int paths(int num, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[num][n] != null) {\\n            return dp[num][n];\\n        }\\n        int ans = 0;\\n        for (int nextNum: map.get(num)) {\\n            ans = (ans + paths(nextNum, n - 1)) % mod;\\n        }\\n        return dp[num][n] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private void init(Map<Integer, List<Integer>> map) {\\n        map.put(0, Arrays.asList(4, 6));\\n        map.put(1, Arrays.asList(6, 8));\\n        map.put(2, Arrays.asList(7, 9));\\n        map.put(3, Arrays.asList(4, 8));\\n        map.put(4, Arrays.asList(0, 3, 9));\\n        map.put(5, Arrays.asList());\\n        map.put(6, Arrays.asList(0, 1, 7));\\n        map.put(7, Arrays.asList(2, 6));\\n        map.put(8, Arrays.asList(1, 3));\\n        map.put(9, Arrays.asList(2, 4));\\n    }\\n    private Map<Integer, List<Integer>> map = new HashMap();\\n    private static final int mod = (int) 1e9 + 7;\\n    private Integer dp[][];\\n    public int knightDialer(int n) {\\n        init(map);\\n        this.dp = new Integer[10][n+1];\\n        int ans = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            ans = (ans + paths(i, n - 1)) % mod;\\n        }\\n        return ans;\\n    }\\n    \\n    private int paths(int num, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[num][n] != null) {\\n            return dp[num][n];\\n        }\\n        int ans = 0;\\n        for (int nextNum: map.get(num)) {\\n            ans = (ans + paths(nextNum, n - 1)) % mod;\\n        }\\n        return dp[num][n] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238560,
                "title": "python-dp",
                "content": "```\\n def knightDialer(self, n: int) -> int:\\n        mod=10**9+7\\n        dp=[[0 for j in range(10)]  for i in range(1+n)]\\n        dp[1]=[1 for j in range(10)]\\n        m={}\\n        m[0]=[4,6]\\n        m[1]=[6,8]\\n        m[2]=[7,9]\\n        m[3]=[4,8]\\n        m[4]=[0,9,3]\\n        m[5]=[]\\n        m[6]=[0,1,7]\\n        m[7]=[2,6]\\n        m[8]=[1,3]\\n        m[9]=[2,4]\\n        for i in range(2,n+1):\\n            for j in range(10):\\n                sources=m[j]\\n                for prev in sources:\\n                    dp[i][j]+=dp[i-1][prev]\\n                    dp[i][j]=dp[i][j]%mod\\n        res=sum(dp[n])%mod\\n        return res",
                "solutionTags": [],
                "code": "```\\n def knightDialer(self, n: int) -> int:\\n        mod=10**9+7\\n        dp=[[0 for j in range(10)]  for i in range(1+n)]\\n        dp[1]=[1 for j in range(10)]\\n        m={}\\n        m[0]=[4,6]\\n        m[1]=[6,8]\\n        m[2]=[7,9]\\n        m[3]=[4,8]\\n        m[4]=[0,9,3]\\n        m[5]=[]\\n        m[6]=[0,1,7]\\n        m[7]=[2,6]\\n        m[8]=[1,3]\\n        m[9]=[2,4]\\n        for i in range(2,n+1):\\n            for j in range(10):\\n                sources=m[j]\\n                for prev in sources:\\n                    dp[i][j]+=dp[i-1][prev]\\n                    dp[i][j]=dp[i][j]%mod\\n        res=sum(dp[n])%mod\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2206866,
                "title": "very-simple-dp-approach",
                "content": "\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    long long dp[10][5003];\\n       \\n      long long func(int key,int n){\\n          \\n          if(n==1)return 1;\\n          if(dp[key][n]!=-1) return dp[key][n];\\n          if(key==1){\\n              return  dp[key][n]=(func(8,n-1)%M+ func(6,n-1)%M)%M;\\n          }\\n             if(key==2){\\n              return  dp[key][n]= (func(7,n-1)%M+ func(9,n-1)%M)%M;\\n          }\\n             if(key==3){\\n              return  dp[key][n]= (func(8,n-1)%M+ func(4,n-1)%M)%M;\\n          }\\n             if(key==4){\\n              return  dp[key][n]= (func(3,n-1)%M+ func(9,n-1)%M+func(0,n-1)%M)%M;\\n          }\\n             if(key==5){\\n              return  dp[key][n]= 0;\\n          }\\n             if(key==6){\\n              return  dp[key][n]= (func(1,n-1)%M+ func(7,n-1)%M+func(0,n-1)%M)%M;\\n          }\\n             if(key==7){\\n              return   dp[key][n]=( func(2,n-1)%M + func(6,n-1)%M )%M;\\n          }\\n             if(key==8){ \\n              return  dp[key][n]= (func(1,n-1)%M+ func(3,n-1)%M)%M;\\n          }\\n             if(key==9){\\n              return  dp[key][n]= (func(4,n-1)%M+ func(2,n-1)%M)%M;\\n          }\\n           if(key==0){\\n              return   dp[key][n]=(func(4,n-1)%M+ func(6,n-1)%M)%M;\\n          }\\n          return 0;\\n      }\\n    int knightDialer(int n) {\\n         int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=9;i++){\\n             ans= (ans%M+func(i,n)%M)%M;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int M=1e9+7;\\n    long long dp[10][5003];\\n       \\n      long long func(int key,int n){\\n          \\n          if(n==1)return 1;\\n          if(dp[key][n]!=-1) return dp[key][n];\\n          if(key==1){\\n              return  dp[key][n]=(func(8,n-1)%M+ func(6,n-1)%M)%M;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2172077,
                "title": "python-dp-clean-code",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        jumps = {\\n            0: [4, 6], \\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        prevDp = [1] * 10\\n        \\n        for length in range(n - 1):\\n            dp = [0] * 10\\n            \\n            for digit in range(10):\\n                for jump in jumps[digit]:\\n                    dp[jump] += prevDp[digit]\\n            \\n            prevDp = dp\\n        \\n        return sum(prevDp) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        jumps = {\\n            0: [4, 6], \\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        prevDp = [1] * 10\\n        \\n        for length in range(n - 1):\\n            dp = [0] * 10\\n            \\n            for digit in range(10):\\n                for jump in jumps[digit]:\\n                    dp[jump] += prevDp[digit]\\n            \\n            prevDp = dp\\n        \\n        return sum(prevDp) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141399,
                "title": "java-solution-2d-dp-memoization",
                "content": "```\\nclass Solution {\\n    \\n    public long mod= 1000000007;\\n    public int knightDialer(int n) {\\n        \\n        int[][] grid= { {1,2,3}, {4,5,6}, {7,8,9}, {-1,0,-1} };\\n        \\n        long[][] dp= new long[10][n+1];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++)\\n                dp[i][j]= -1;\\n        }\\n        \\n        //iterate over all digits and count the valid Knight numbers\\n        long count=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i][j]!= -1){\\n                    count= (count+ validNumbers(n,i,j,dp,grid))%mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)count; \\n    }\\n    \\n    private long validNumbers(int n,int i,int j,long[][] dp,int[][] grid){\\n        \\n        int row =grid.length, col =grid[0].length;\\n        \\n        if(i<0 || i>=row || j<0 || j>=col)\\n            return 0;\\n        \\n        if(grid[i][j]== -1)\\n            return 0;\\n        \\n        \\n        int num=grid[i][j];\\n        \\n        if(n ==1)\\n            return 1;\\n        \\n        if(dp[num][n]!= -1)\\n            return dp[num][n];\\n        \\n        long value=0;\\n        value+= validNumbers(n-1,i-2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j-1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-2,j-1,dp,grid)%mod;\\n        \\n        \\n        return dp[num][n]= value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long mod= 1000000007;\\n    public int knightDialer(int n) {\\n        \\n        int[][] grid= { {1,2,3}, {4,5,6}, {7,8,9}, {-1,0,-1} };\\n        \\n        long[][] dp= new long[10][n+1];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++)\\n                dp[i][j]= -1;\\n        }\\n        \\n        //iterate over all digits and count the valid Knight numbers\\n        long count=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i][j]!= -1){\\n                    count= (count+ validNumbers(n,i,j,dp,grid))%mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)count; \\n    }\\n    \\n    private long validNumbers(int n,int i,int j,long[][] dp,int[][] grid){\\n        \\n        int row =grid.length, col =grid[0].length;\\n        \\n        if(i<0 || i>=row || j<0 || j>=col)\\n            return 0;\\n        \\n        if(grid[i][j]== -1)\\n            return 0;\\n        \\n        \\n        int num=grid[i][j];\\n        \\n        if(n ==1)\\n            return 1;\\n        \\n        if(dp[num][n]!= -1)\\n            return dp[num][n];\\n        \\n        long value=0;\\n        value+= validNumbers(n-1,i-2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j-1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-2,j-1,dp,grid)%mod;\\n        \\n        \\n        return dp[num][n]= value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136453,
                "title": "python-somewhat-ok-solution",
                "content": "```python\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        Mod = 10**9 + 7\\n        pad = [\\n            (4, 6), (8, 6), (7, 9), (4, 8), (3, 9, 0),\\n            (), (1, 7, 0), (2, 6), (1, 3), (2, 4)\\n        ]\\n        \\n        @cache\\n        def dfs(i, n):\\n\\t\\t   # search reached the end, found 1 solution\\n            if n == 0: return 1\\n\\t\\t\\t# search not reach the end, keep looking for solution for n - 1\\n            return sum(dfs(nxt, n - 1) for nxt in pad[i]) % Mod\\n\\n        # starting from each number, count the total solution to n\\n\\t\\t# because placing the chess to i takes 1 count, so search for n - 1\\n        return sum(dfs(i, n - 1)  for i in range(10)) % Mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        Mod = 10**9 + 7\\n        pad = [\\n            (4, 6), (8, 6), (7, 9), (4, 8), (3, 9, 0),\\n            (), (1, 7, 0), (2, 6), (1, 3), (2, 4)\\n        ]\\n        \\n        @cache\\n        def dfs(i, n):\\n\\t\\t   # search reached the end, found 1 solution\\n            if n == 0: return 1\\n\\t\\t\\t# search not reach the end, keep looking for solution for n - 1\\n            return sum(dfs(nxt, n - 1) for nxt in pad[i]) % Mod\\n\\n        # starting from each number, count the total solution to n\\n\\t\\t# because placing the chess to i takes 1 count, so search for n - 1\\n        return sum(dfs(i, n - 1)  for i in range(10)) % Mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118758,
                "title": "c-easy-and-concise-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    long long dp[4][3][5005];\\n    int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 }, dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n    bool isValid(int i,int j,vector<vector<char>>&mat)\\n    {\\n        return (i>=0 && i<4 && j>=0 && j<3 && mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')? true:false;\\n    }\\n    long long solve(vector<vector<char>>&mat,int n,int i,int j)\\n    {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(dp[i][j][n]>0) return dp[i][j][n];\\n        long long ans=0;\\n        for(int k=0;k<8;k++)\\n        {\\n            if(isValid(i+dx[k],j+dy[k],mat))\\n            {\\n                ans+=solve(mat,n-1,i+dx[k],j+dy[k]);\\n            }\\n        }\\n       return dp[i][j][n]=ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<char>>mat(4,vector<char>(3));\\n        int k=1;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                mat[i][j]=(k+\\'0\\');\\n                k++;\\n            }\\n        }\\n        mat[3][0]=\\'*\\',mat[3][1]=\\'0\\',mat[3][2]=\\'#\\';\\n        long long ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')\\n                ans+=solve(mat,n,i,j);\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    long long dp[4][3][5005];\\n    int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 }, dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n    bool isValid(int i,int j,vector<vector<char>>&mat)\\n    {\\n        return (i>=0 && i<4 && j>=0 && j<3 && mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')? true:false;\\n    }\\n    long long solve(vector<vector<char>>&mat,int n,int i,int j)\\n    {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(dp[i][j][n]>0) return dp[i][j][n];\\n        long long ans=0;\\n        for(int k=0;k<8;k++)\\n        {\\n            if(isValid(i+dx[k],j+dy[k],mat))\\n            {\\n                ans+=solve(mat,n-1,i+dx[k],j+dy[k]);\\n            }\\n        }\\n       return dp[i][j][n]=ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<char>>mat(4,vector<char>(3));\\n        int k=1;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                mat[i][j]=(k+\\'0\\');\\n                k++;\\n            }\\n        }\\n        mat[3][0]=\\'*\\',mat[3][1]=\\'0\\',mat[3][2]=\\'#\\';\\n        long long ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')\\n                ans+=solve(mat,n,i,j);\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056965,
                "title": "memoized-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9)+7;\\n\\n\\t// creating a map for maintaning all those indexes that can be reached from a given index.\\n\\t// for ex: 0 can reach 4 and 6. Similarily 1 can reach 6 , 8 and so on.\\n\\t\\n    vector<vector<int>> graph = {\\n        {4,6},\\n        {6,8},\\n        {7,9},\\n        {4,8},\\n        {0,3,9},\\n        {},\\n        {0,1,7},\\n        {2,6},\\n        {1,3},\\n        {2,4}\\n    };\\n    \\n    vector<vector<int>> dp;\\n    \\n\\t// int i = currentNumber \\n\\t// int len = length Of Current Number on Dialpad.\\n\\t\\n    int helper(int i,int len,int n){\\n        int ans = 0;\\n        if(len == n){\\n            return dp[i][len]=1;\\n        }\\n        \\n        if(dp[i][len] != -1) return dp[i][len];\\n        \\n        for(auto d:g[i]){\\n            ans += helper(d,len+1,n);\\n            ans = ans % mod;\\n        }\\n        \\n        return dp[i][len] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n        int ans = 0;\\n        dp.resize(10,vector<int>(n,-1));\\n        for(int i=0;i<=9;i++){\\n            ans += helper(i,0,n-1);\\n            ans = ans % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9)+7;\\n\\n\\t// creating a map for maintaning all those indexes that can be reached from a given index.\\n\\t// for ex: 0 can reach 4 and 6. Similarily 1 can reach 6 , 8 and so on.\\n\\t\\n    vector<vector<int>> graph = {\\n        {4,6},\\n        {6,8},\\n        {7,9},\\n        {4,8},\\n        {0,3,9},\\n        {},\\n        {0,1,7},\\n        {2,6},\\n        {1,3},\\n        {2,4}\\n    };\\n    \\n    vector<vector<int>> dp;\\n    \\n\\t// int i = currentNumber \\n\\t// int len = length Of Current Number on Dialpad.\\n\\t\\n    int helper(int i,int len,int n){\\n        int ans = 0;\\n        if(len == n){\\n            return dp[i][len]=1;\\n        }\\n        \\n        if(dp[i][len] != -1) return dp[i][len];\\n        \\n        for(auto d:g[i]){\\n            ans += helper(d,len+1,n);\\n            ans = ans % mod;\\n        }\\n        \\n        return dp[i][len] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n        int ans = 0;\\n        dp.resize(10,vector<int>(n,-1));\\n        for(int i=0;i<=9;i++){\\n            ans += helper(i,0,n-1);\\n            ans = ans % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052655,
                "title": "dp-c",
                "content": "```\\n// dp[i][j][k]=count of i digits no\\'s that can be formed if start moving from from (j,k)\\n//from (i,j) we have 8 choices to move as per the move of knight\\n\\n#define lln long long int\\nlln mod=1e9+7;\\n\\nint dx[8]={2,2,-2,-2,1,1,-1,-1};\\nint dy[8]={1,-1,1,-1,2,-2,2,-2};\\n\\nlln dp[5001][4][4]; \\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        lln ans=0;\\n        \\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if((i==3 && j==0) || (i==3 && j==2))\\n                    continue;\\n                \\n                ans=(ans%mod+find(i,j,1,n)%mod)%mod;\\n            }\\n        }\\n        \\n        return ans%mod;\\n    }\\n    \\n    lln find(int i,int j,int len,int n){\\n    \\n        if(len==n){\\n            return 1;\\n        }\\n        \\n        if(dp[len][i][j]!=-1)\\n            return dp[len][i][j];\\n        \\n        lln count=0;\\n        \\n        for(int x=0;x<8;x++){\\n            int i1=i+dx[x];\\n            int j1=j+dy[x];\\n            \\n         if((i1==3 && j1==0) || (i1==3 && j1==2))\\n             continue;\\n    \\n        if(i1>=4 || i1<0 || j1>=3 || j1<0)\\n            continue;\\n                \\n         count=(count%mod+find(i1,j1,len+1,n)%mod)%mod;\\n\\n        }\\n        \\n        return dp[len][i][j]=count%mod;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        lln ans=0;\\n        \\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if((i==3 && j==0) || (i==3 && j==2))\\n                    continue;\\n                \\n                ans=(ans%mod+find(i,j,1,n)%mod)%mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2030753,
                "title": "java-dp-memoization-solution",
                "content": "```\\nclass Solution {\\n     int mod = 1000000007;\\n    public  int knightDialer(int n) {\\n        int[][] dp = new int[n+1][10];\\n        for (int [] d : dp)Arrays.fill(d,-1);\\n        HashMap<Integer, List<Integer>> routes = new HashMap<>();\\n        routes.put(0, Arrays.asList(4,6));\\n        routes.put(1, Arrays.asList(6,8));\\n        routes.put(2, Arrays.asList(7,9));\\n        routes.put(3, Arrays.asList(4,8));\\n        routes.put(4, Arrays.asList(0,3,9));\\n        routes.put(5, Arrays.asList());\\n        routes.put(6, Arrays.asList(0,1,7));\\n        routes.put(7, Arrays.asList(2,6));\\n        routes.put(8, Arrays.asList(1,3));\\n        routes.put(9, Arrays.asList(2,4));\\n        int count =0;\\n        for (int i=0;i<=9;i++){\\n            count = count  + helper(routes,i,2,n,dp)%mod;\\n            count = count%mod;\\n        }\\n\\n        return count;\\n    }\\n\\n    private  int helper(HashMap<Integer, List<Integer>> routes, int i, int pos, int n, int [][] dp) {\\n\\n        if (pos == n+1) return 1;\\n        if (dp[pos][i] != -1) return dp[pos][i];\\n        int count = 0;\\n        for (int val : routes.get(i)) {\\n            count = count + helper(routes, val, pos + 1, n,dp) % mod;\\n            count = count % mod;\\n        }\\n        return dp[pos][i] = count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n     int mod = 1000000007;\\n    public  int knightDialer(int n) {\\n        int[][] dp = new int[n+1][10];\\n        for (int [] d : dp)Arrays.fill(d,-1);\\n        HashMap<Integer, List<Integer>> routes = new HashMap<>();\\n        routes.put(0, Arrays.asList(4,6));\\n        routes.put(1, Arrays.asList(6,8));\\n        routes.put(2, Arrays.asList(7,9));\\n        routes.put(3, Arrays.asList(4,8));\\n        routes.put(4, Arrays.asList(0,3,9));\\n        routes.put(5, Arrays.asList());\\n        routes.put(6, Arrays.asList(0,1,7));\\n        routes.put(7, Arrays.asList(2,6));\\n        routes.put(8, Arrays.asList(1,3));\\n        routes.put(9, Arrays.asList(2,4));\\n        int count =0;\\n        for (int i=0;i<=9;i++){\\n            count = count  + helper(routes,i,2,n,dp)%mod;\\n            count = count%mod;\\n        }\\n\\n        return count;\\n    }\\n\\n    private  int helper(HashMap<Integer, List<Integer>> routes, int i, int pos, int n, int [][] dp) {\\n\\n        if (pos == n+1) return 1;\\n        if (dp[pos][i] != -1) return dp[pos][i];\\n        int count = 0;\\n        for (int val : routes.get(i)) {\\n            count = count + helper(routes, val, pos + 1, n,dp) % mod;\\n            count = count % mod;\\n        }\\n        return dp[pos][i] = count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997235,
                "title": "java-dp-memoization-intuitive-approach",
                "content": "The idea is to find the repeatitive subproblems with optimal substructure property. \\nHere we can see that all the states when which have \\'1\\' (or any other digit) in previous position will not be same. (1_ and 1 _ _  are not same subproblems, as these two states have different answers).\\nSo what our subproblem will be?\\nCan we say that whenever our previous position =1 (for example) and if the number of remaining digits are same, then these 2 will be same subproblems.\\nex - 231_ _ and 51_ _ => are same states, as now onward both will produce same answer, since both have 2 digits remaining and for both states last filled digit is same.\\nThus in our dp solution, we will be be caching previous digit and number of remaining digits as one state. \\n\\nclass Solution {\\n    \\n    int mod = (int) (1e9+7);\\n    public int knightDialer(int n) {\\n        if(n==1)    return 10;\\n        Map<Integer,List<Integer>> adjMap = new HashMap<>();\\n        getAdjMap(adjMap);\\n                \\n        int dp[][] = new int[10][n+1];\\n        for(int row[]:dp)  Arrays.fill(row,-1);\\n        \\n        int cnt=0;\\n        int pos=2;\\n        for(int i=0;i<=9;i++){\\n            cnt += dfs(adjMap, i, pos, n, dp);\\n            cnt = cnt%mod;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    // dp states - prev, n-pos+1          \\n\\t// prev - digit present at previous position. \\n\\t// n-pos+1 - number of left positions to be filled\\n\\t// (pos: current position to be filled; n: lenght of phone number)\\n    \\n    private int dfs(Map<Integer,List<Integer>> adjMap, int prev, int pos, int n, int dp[][]){\\n        \\n        if(pos == n+1)                      \\n            return 1;                \\n        \\n        if(dp[prev][n-pos+1]!=-1)   return dp[prev][n-pos+1];\\n        \\n        int t=0;\\n        for(int child: adjMap.get(prev)){\\n            t += dfs(adjMap, child, pos+1, n, dp);  \\n            t=t%mod;\\n        }\\n        \\n        return dp[prev][n-pos+1] = t;\\n    }\\n    \\n    private void getAdjMap(Map<Integer,List<Integer>> map){\\n        for(int i=0;i<=9;i++)\\n            map.put(i, new ArrayList<>());\\n        \\n        map.put(0, List.of(4,6));\\n        map.put(1, List.of(6,8));\\n        map.put(2, List.of(7,9));\\n        map.put(3, List.of(4,8));\\n        map.put(4, List.of(0,3,9));\\n        map.put(6, List.of(0,1,7));\\n        map.put(7, List.of(2,6));\\n        map.put(8, List.of(1,3));\\n        map.put(9, List.of(2,4));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int mod = (int) (1e9+7);\\n    public int knightDialer(int n) {\\n        if(n==1)    return 10;\\n        Map<Integer,List<Integer>> adjMap = new HashMap<>();\\n        getAdjMap(adjMap);\\n                \\n        int dp[][] = new int[10][n+1];\\n        for(int row[]:dp)  Arrays.fill(row,-1);\\n        \\n        int cnt=0;\\n        int pos=2;\\n        for(int i=0;i<=9;i++){\\n            cnt += dfs(adjMap, i, pos, n, dp);\\n            cnt = cnt%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978970,
                "title": "simple-recursive-dp-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f605fb70-db83-41d3-bbb2-902297aa2039_1650817004.5904217.png)\\n```\\nconst int mod = (int)1e9 + 7 ; \\n\\nclass Solution {\\npublic:\\n    /*\\n    Its clear we have to use recursion !\\n    From the constraint we are clear that DP is needed \\n    \\n    ans -> Solution(0, n) + Solution(1, n) + .. Solution(9, n) ;\\n    \\n    */\\n    long long dp[10][5001] ; \\n    vector<vector<int>> valid_places = {{4, 6}, {6, 8},\\n                                        {7, 9}, {4, 8},\\n                                        {3, 9, 0}, {}, {1, 7, 0},\\n                                        {2 ,6}, {1, 3}, {4, 2}} ; \\n    \\n    long long util(int src, int n) {\\n        if(n == 1) return 1LL ;\\n        if(dp[src][n] != -1) return dp[src][n] ; \\n        long long total = 0; \\n        for(auto &p : valid_places[src]){\\n           total = (total + util(p, n-1)) % mod ; \\n        }\\n        return dp[src][n] = total ; \\n    }\\n    \\n    int knightDialer(int n) {\\n        memset(dp, -1, sizeof(dp)) ; \\n        long long ans = 0 ; \\n        for(int i = 0 ; i<10 ; i++)\\n            ans = (ans + util(i, n)) % mod ; \\n        return (int)ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int mod = (int)1e9 + 7 ; \\n\\nclass Solution {\\npublic:\\n    /*\\n    Its clear we have to use recursion !\\n    From the constraint we are clear that DP is needed \\n    \\n    ans -> Solution(0, n) + Solution(1, n) + .. Solution(9, n) ;\\n    \\n    */\\n    long long dp[10][5001] ; \\n    vector<vector<int>> valid_places = {{4, 6}, {6, 8},\\n                                        {7, 9}, {4, 8},\\n                                        {3, 9, 0}, {}, {1, 7, 0},\\n                                        {2 ,6}, {1, 3}, {4, 2}} ; \\n    \\n    long long util(int src, int n) {\\n        if(n == 1) return 1LL ;\\n        if(dp[src][n] != -1) return dp[src][n] ; \\n        long long total = 0; \\n        for(auto &p : valid_places[src]){\\n           total = (total + util(p, n-1)) % mod ; \\n        }\\n        return dp[src][n] = total ; \\n    }\\n    \\n    int knightDialer(int n) {\\n        memset(dp, -1, sizeof(dp)) ; \\n        long long ans = 0 ; \\n        for(int i = 0 ; i<10 ; i++)\\n            ans = (ans + util(i, n)) % mod ; \\n        return (int)ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967691,
                "title": "c-60-fast-solution-top-down-dp-very-easy-approach",
                "content": "```\\nvector<vector<int>>moves{\\n    {4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}\\n};\\nint mod=1e9+7;\\nclass Solution {\\n    long long count_no(int n,int x,vector<vector<int>>&dp){\\n       if(n==0)return 1;\\n        if(dp[n][x]!=-1)return dp[n][x];\\n        long long n1=0;\\n        for(int val:moves[x])\\n            n1=(n1+count_no(n-1,val,dp))%mod;\\n        return dp[n][x]=n1;\\n    }\\n    \\npublic:\\n    int knightDialer(int n) {\\n        long long res=0;\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        for(int i=0;i<10;i++)\\n            res=(res+count_no(n-1, i,dp))%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>>moves{\\n    {4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}\\n};\\nint mod=1e9+7;\\nclass Solution {\\n    long long count_no(int n,int x,vector<vector<int>>&dp){\\n       if(n==0)return 1;\\n        if(dp[n][x]!=-1)return dp[n][x];\\n        long long n1=0;\\n        for(int val:moves[x])\\n            n1=(n1+count_no(n-1,val,dp))%mod;\\n        return dp[n][x]=n1;\\n    }\\n    \\npublic:\\n    int knightDialer(int n) {\\n        long long res=0;\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        for(int i=0;i<10;i++)\\n            res=(res+count_no(n-1, i,dp))%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894969,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int mod=1000000000+7;\\n    int moves[8][2]={{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};\\n    vector<vector<vector<int>>>memo;\\n    int findAns(int r,int c,int n){\\n        if(r<0 or r>3 or c<0 or c>2 or (r==3 and c==2) or (r==3 and c==0)){\\n            return 0;\\n        } else if(n==0){\\n            return 1;\\n        } else if(memo[r][c][n]!=-1){\\n            return memo[r][c][n];\\n        } else {\\n            int ans=0;\\n            for(int i=0;i<8;i++){\\n                int nr=r+moves[i][0];\\n                int nc=c+moves[i][1];\\n                if(nr<0 or nc<0 or nr>3 or nc>2 or (nr==3 and (nc==0 or nc==2))){\\n                    continue;\\n                } else {\\n                    ans=(ans%mod+findAns(nr,nc,n-1)%mod)%mod;\\n                }\\n            }\\n            return memo[r][c][n]=ans%mod;\\n        }\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                ans=(ans%mod+findAns(i,j,n-1)%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    int mod=1000000000+7;\\n    int moves[8][2]={{1,2}",
                "codeTag": "Java"
            },
            {
                "id": 1857693,
                "title": "c-recursion-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    int mod = 1e9 + 7; \\n    int dp[10][5005];\\n    int solve(int num, int n, map<int, vector<int>> & v){\\n          if(n == 1) return 1;\\n          int ans = 0;\\n          if(dp[num][n] != -1) return dp[num][n];\\n          for(int i : v[num]){\\n              ans = (ans + solve(i, n - 1, v)) % mod;\\n          }\\n        return dp[num][n] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n          map<int, vector<int>> v;\\n    v[1] = {6,8},v[2] = {7,9}, v[3] = {4,8}, v[4] = {0,3,9}, v[5] = {}, v[6] = {0,1,7}, v[7] = {2,6}, v[8] = {1,3}, v[9] = {2,4}, v[0] = {4,6};\\n         memset(dp, -1, sizeof(dp));\\n         int ans = 0;\\n         for(int i=0; i<=9; i++){\\n             ans = (ans + solve(i,n, v)) % mod;\\n         }\\n        \\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n  \\n    int mod = 1e9 + 7; \\n    int dp[10][5005];\\n    int solve(int num, int n, map<int, vector<int>> & v){\\n          if(n == 1) return 1;\\n          int ans = 0;\\n          if(dp[num][n] != -1) return dp[num][n];\\n          for(int i : v[num]){\\n              ans = (ans + solve(i, n - 1, v)) % mod;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1847842,
                "title": "javascript-top-down-recursive-memoization-explanation",
                "content": "```\\n/** https://leetcode.com/problems/knight-dialer/\\n * @param {number} n\\n * @return {number}\\n */\\nvar knightDialer = function(n) {\\n  // Memo\\n  this.memo = new Map();\\n  \\n  // Modulo\\n  this.mod = (10 ** 9) + 7;\\n  \\n  // All valid knight\\'s directions and valid keypad numeric\\'s coordinates\\n  let directions = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]];\\n  let numericCoord = [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2], [3, 1]];\\n  \\n  let count = 0;\\n  \\n  // Starting coordinate of every valid key in the keypad\\n  for (let [r, c] of numericCoord) {\\n    count += dp(n, directions, r, c, n - 1);\\n  }\\n  \\n  // Return result with modulo\\n  return count % this.mod;\\n};\\n\\nvar dp = function(n, directions, r, c, remain) {\\n  let key = `${r}_${c}_${remain}`;\\n  \\n  // Base case\\n  if (remain === 0) {\\n    return 1;\\n  }\\n  \\n  // Return from memo\\n  if (this.memo.has(key) === true) {\\n    return this.memo.get(key);\\n  }\\n  \\n  let count = 0;\\n  \\n  // Try to go every valid directions a knight can go\\n  for (let [nextR, nextC] of directions) {\\n    // If the next direction is invalid, try another direction\\n    if (isValid(r + nextR, c + nextC) === false) {\\n      continue;\\n    }\\n    \\n    // Next direction is valid, result could be huge so we perform modulo\\n    count += dp(n, directions, r + nextR, c + nextC, remain - 1) % this.mod;\\n  }\\n  \\n  // Set memo\\n  this.memo.set(key, count);\\n  \\n  return count;\\n};\\n\\nvar isValid = function(r, c) {\\n  // Check if coordinate is in keypad coordinate boundary, except the asterisk (3, 0) and hashtag (3, 2)\\n  return (r >= 0 && r < 4 && c >= 0 && c < 3) &&\\n    !(r === 3 && c === 0) &&\\n    !(r === 3 && c === 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/** https://leetcode.com/problems/knight-dialer/\\n * @param {number} n\\n * @return {number}\\n */\\nvar knightDialer = function(n) {\\n  // Memo\\n  this.memo = new Map();\\n  \\n  // Modulo\\n  this.mod = (10 ** 9) + 7;\\n  \\n  // All valid knight\\'s directions and valid keypad numeric\\'s coordinates\\n  let directions = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]];\\n  let numericCoord = [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2], [3, 1]];\\n  \\n  let count = 0;\\n  \\n  // Starting coordinate of every valid key in the keypad\\n  for (let [r, c] of numericCoord) {\\n    count += dp(n, directions, r, c, n - 1);\\n  }\\n  \\n  // Return result with modulo\\n  return count % this.mod;\\n};\\n\\nvar dp = function(n, directions, r, c, remain) {\\n  let key = `${r}_${c}_${remain}`;\\n  \\n  // Base case\\n  if (remain === 0) {\\n    return 1;\\n  }\\n  \\n  // Return from memo\\n  if (this.memo.has(key) === true) {\\n    return this.memo.get(key);\\n  }\\n  \\n  let count = 0;\\n  \\n  // Try to go every valid directions a knight can go\\n  for (let [nextR, nextC] of directions) {\\n    // If the next direction is invalid, try another direction\\n    if (isValid(r + nextR, c + nextC) === false) {\\n      continue;\\n    }\\n    \\n    // Next direction is valid, result could be huge so we perform modulo\\n    count += dp(n, directions, r + nextR, c + nextC, remain - 1) % this.mod;\\n  }\\n  \\n  // Set memo\\n  this.memo.set(key, count);\\n  \\n  return count;\\n};\\n\\nvar isValid = function(r, c) {\\n  // Check if coordinate is in keypad coordinate boundary, except the asterisk (3, 0) and hashtag (3, 2)\\n  return (r >= 0 && r < 4 && c >= 0 && c < 3) &&\\n    !(r === 3 && c === 0) &&\\n    !(r === 3 && c === 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821648,
                "title": "c-3d-dp",
                "content": "Hopefully it helps average peeps like me get some intuition.\\n```\\nconst vector<vector<int>> pad = {\\n            {  1,  2,  3 },\\n            {  4,  5,  6 },\\n            {  7,  8,  9 },\\n            { -1,  0, -1 }\\n};\\nconst int MOD = (int)1e9 + 7;\\nclass Solution {\\n    vector<vector<vector<int>>> dp;\\n    vector<int> dr = { -2, -2, 2, 2, -1, 1, -1, 1 };\\n    vector<int> dc = { -1, 1, -1, 1, -2, -2, 2, 2 };\\npublic:\\n    int f(int i, int j, int n)\\n    {\\n        if (i < 0 || j < 0) return 0;\\n        if (i > 3 || j > 2) return 0;\\n        if (pad[i][j] == -1) return 0;\\n        if (n == 0) return 1;\\n        if (dp[i][j][n] != -1) return dp[i][j][n];\\n\\n        dp[i][j][n] = 0;\\n        for (int k = 0; k < 8; ++k) {\\n            dp[i][j][n] = (dp[i][j][n] + f(i + dr[k], j + dc[k], n - 1)) % MOD;\\n        }\\n        return dp[i][j][n] % MOD;\\n    }\\n    int knightDialer(int n)\\n    {\\n        vector<vector<vector<int>>> t(5, vector<vector<int>>(4, vector<int>(5005, -1)));\\n        dp = t;\\n        int sum = 0;\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                sum = (sum + f(i, j, n - 1)) % MOD;\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst vector<vector<int>> pad = {\\n            {  1,  2,  3 },\\n            {  4,  5,  6 },\\n            {  7,  8,  9 },\\n            { -1,  0, -1 }\\n};\\nconst int MOD = (int)1e9 + 7;\\nclass Solution {\\n    vector<vector<vector<int>>> dp;\\n    vector<int> dr = { -2, -2, 2, 2, -1, 1, -1, 1 };\\n    vector<int> dc = { -1, 1, -1, 1, -2, -2, 2, 2 };\\npublic:\\n    int f(int i, int j, int n)\\n    {\\n        if (i < 0 || j < 0) return 0;\\n        if (i > 3 || j > 2) return 0;\\n        if (pad[i][j] == -1) return 0;\\n        if (n == 0) return 1;\\n        if (dp[i][j][n] != -1) return dp[i][j][n];\\n\\n        dp[i][j][n] = 0;\\n        for (int k = 0; k < 8; ++k) {\\n            dp[i][j][n] = (dp[i][j][n] + f(i + dr[k], j + dc[k], n - 1)) % MOD;\\n        }\\n        return dp[i][j][n] % MOD;\\n    }\\n    int knightDialer(int n)\\n    {\\n        vector<vector<vector<int>>> t(5, vector<vector<int>>(4, vector<int>(5005, -1)));\\n        dp = t;\\n        int sum = 0;\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                sum = (sum + f(i, j, n - 1)) % MOD;\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794663,
                "title": "java-easy-clean-and-detailed-solution",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n == 1)\\n            return 10;\\n        int[] og = new int[10];\\n        int mod = 1000000007;\\n        Arrays.fill(og, 1);\\n        int[][] reach = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        for(int i = 2; i <= n; i++){\\n            int[] newarr = new int[10];\\n            int sum = 0;\\n            for(int j = 0; j < reach.length; j++){\\n                for(int k = 0; k < reach[j].length; k++){\\n                    newarr[j] = (newarr[j] + og[reach[j][k]]) % mod;\\n                }\\n                sum = (sum + newarr[j]) % mod;\\n            }\\n            og = newarr;\\n            if(i == n)\\n            \\treturn sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n == 1)\\n            return 10;\\n        int[] og = new int[10];\\n        int mod = 1000000007;\\n        Arrays.fill(og, 1);\\n        int[][] reach = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        for(int i = 2; i <= n; i++){\\n            int[] newarr = new int[10];\\n            int sum = 0;\\n            for(int j = 0; j < reach.length; j++){\\n                for(int k = 0; k < reach[j].length; k++){\\n                    newarr[j] = (newarr[j] + og[reach[j][k]]) % mod;\\n                }\\n                sum = (sum + newarr[j]) % mod;\\n            }\\n            og = newarr;\\n            if(i == n)\\n            \\treturn sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773547,
                "title": "c-ez-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long dp[n+1][10];\\n        int m = 1e9+7;\\n        memset(dp,0,sizeof(dp));\\n        for(int i = 0;i<10;i++){\\n            dp[1][i] = 1;//with length = 1 and end with 0,1,...9 = 1 way\\n        }\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0;j<10;j++){\\n                if(j == 0){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][6])%m; \\n                    ///with length = i we will have result = sum of ways with length = i-1 end with 4 and end with 6, because 4 and 6 will jump to 0. \\n\\t\\t\\t\\t\\t///Similar for other case\\n                }\\n                else if(j == 1){\\n                    dp[i][j] = (dp[i-1][6]+dp[i-1][8])%m;\\n                }\\n                else if(j == 2){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9])%m;\\n                }\\n                else if(j == 3){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][8])%m;\\n                }\\n                else if(j == 4){\\n                    dp[i][j] = (dp[i-1][3]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 6){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 7){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][6])%m;\\n                }\\n                else if(j == 8){\\n                    dp[i][j] = (dp[i-1][1]+dp[i-1][3])%m;\\n                }\\n                else if(j == 9){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][4])%m;\\n                }\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = 0;i<10;i++){\\n            res = (res+dp[n][i])%m;\\n        }\\n        return res;\\n    }\\n};\\n```\\nif this help, pls upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long dp[n+1][10];\\n        int m = 1e9+7;\\n        memset(dp,0,sizeof(dp));\\n        for(int i = 0;i<10;i++){\\n            dp[1][i] = 1;//with length = 1 and end with 0,1,...9 = 1 way\\n        }\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0;j<10;j++){\\n                if(j == 0){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][6])%m; \\n                    ///with length = i we will have result = sum of ways with length = i-1 end with 4 and end with 6, because 4 and 6 will jump to 0. \\n\\t\\t\\t\\t\\t///Similar for other case\\n                }\\n                else if(j == 1){\\n                    dp[i][j] = (dp[i-1][6]+dp[i-1][8])%m;\\n                }\\n                else if(j == 2){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9])%m;\\n                }\\n                else if(j == 3){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][8])%m;\\n                }\\n                else if(j == 4){\\n                    dp[i][j] = (dp[i-1][3]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 6){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 7){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][6])%m;\\n                }\\n                else if(j == 8){\\n                    dp[i][j] = (dp[i-1][1]+dp[i-1][3])%m;\\n                }\\n                else if(j == 9){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][4])%m;\\n                }\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = 0;i<10;i++){\\n            res = (res+dp[n][i])%m;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772664,
                "title": "c-sol-recursion-memoization",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int NumOfWays(int i, int j, int len, vector<vector<vector<int>>> &dp)\\n    {\\n        if ( (i == 3 && j == 0) || (i == 3 && j == 2) || (i > 3) || (j > 2) || (i < 0) || (j < 0))\\n            return 0;\\n        if ( len == 1)\\n            return 1;\\n        if (dp[i][j][len] != -1)\\n            return dp[i][j][len];\\n        \\n        int ans = 0;\\n        ans = (ans +(NumOfWays(i-2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j+2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j+2,len-1,dp)%mod))%mod;\\n        return dp[i][j][len] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp (4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                ans += (NumOfWays(i,j,n,dp)%mod);\\n                ans%= mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity -: O(n x 4 x 3) = O(n);",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int NumOfWays(int i, int j, int len, vector<vector<vector<int>>> &dp)\\n    {\\n        if ( (i == 3 && j == 0) || (i == 3 && j == 2) || (i > 3) || (j > 2) || (i < 0) || (j < 0))\\n            return 0;\\n        if ( len == 1)\\n            return 1;\\n        if (dp[i][j][len] != -1)\\n            return dp[i][j][len];\\n        \\n        int ans = 0;\\n        ans = (ans +(NumOfWays(i-2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j+2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j+2,len-1,dp)%mod))%mod;\\n        return dp[i][j][len] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp (4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                ans += (NumOfWays(i,j,n,dp)%mod);\\n                ans%= mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723487,
                "title": "python3-bottom-up-approach-dp",
                "content": "**consider after ith jump we reach digit 1 , then on (i-1)th jump we will be at either 6 or 8\\nso dp relation becomes dp[i][1]=dp[i-1][6]+dp[i-1][8]. Similar for every number .**\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr=[[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[1,0,7],[2,6],[1,3],[2,4]] #arr[i] stores the position to which we can go next from i\\n        dp=[[0 for i in range(10)] for j in range(n)]\\n        mod=10**9+7\\n        for i in range(10):\\n            dp[0][i]=1\\n        for i in range(1,n):\\n            for j in range(10):\\n                for k in range(len(arr[j])):\\n                    dp[i][j]+=dp[i-1][arr[j][k]]\\n        return sum(dp[n-1])%mod\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr=[[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[1,0,7],[2,6],[1,3],[2,4]] #arr[i] stores the position to which we can go next from i\\n        dp=[[0 for i in range(10)] for j in range(n)]\\n        mod=10**9+7\\n        for i in range(10):\\n            dp[0][i]=1\\n        for i in range(1,n):\\n            for j in range(10):\\n                for k in range(len(arr[j])):\\n                    dp[i][j]+=dp[i-1][arr[j][k]]\\n        return sum(dp[n-1])%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701719,
                "title": "c-solution-dynamic-programming-recursive-bottom-up",
                "content": "\\n\\tint mod = 1000000007;\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &v, int i,int j,int n,int count)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[i].size() || v[i][j]==\\'*\\' || v[i][j]==\\'#\\')\\n            return 0;\\n        if(count==n)\\n            return 1;\\n        if(dp[count][i][j]>0)\\n            return dp[count][i][j];\\n        long long int run1=solve(dp,v,i-2,j-1,n,count+1)%mod;\\n        long long int run2=solve(dp,v,i-2,j+1,n,count+1)%mod;\\n        long long int run3=solve(dp,v,i-1,j-2,n,count+1)%mod;\\n        long long int run4=solve(dp,v,i-1,j+2,n,count+1)%mod;\\n        long long int run5=solve(dp,v,i+2,j+1,n,count+1)%mod;\\n        long long int run6=solve(dp,v,i+2,j-1,n,count+1)%mod;\\n        long long int run7=solve(dp,v,i+1,j+2,n,count+1)%mod;\\n        long long int run8=solve(dp,v,i+1,j-2,n,count+1)%mod;\\n        return dp[count][i][j]=((run1+run2+run3+run4+run5+run6+run7+run8)%mod)%mod;\\n        \\n    }\\n    int knightDialer(int n) {\\n        vector<vector<char>> v={{\\'1\\',\\'2\\',\\'3\\'},{\\'4\\',\\'5\\',\\'6\\'},{\\'7\\',\\'8\\',\\'9\\'},{\\'*\\',\\'0\\',\\'#\\'}};\\n       // vector<string> ans;\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(4,vector<int> (4,0)));\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n                ans+=( solve(dp,v,i,j,n-1,0)%mod);\\n        }\\n        return ans%mod;\\n\\t\\t\\nPlease upvote if you like this solution.\\nThanks",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\n\\tint mod = 1000000007;\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &v, int i,int j,int n,int count)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[i].size() || v[i][j]==\\'*\\' || v[i][j]==\\'#\\')\\n            return 0;\\n        if(count==n)\\n            return 1;\\n        if(dp[count][i][j]>0)\\n            return dp[count][i][j];\\n        long long int run1=solve(dp,v,i-2,j-1,n,count+1)%mod;\\n        long long int run2=solve(dp,v,i-2,j+1,n,count+1)%mod;\\n        long long int run3=solve(dp,v,i-1,j-2,n,count+1)%mod;\\n        long long int run4=solve(dp,v,i-1,j+2,n,count+1)%mod;\\n        long long int run5=solve(dp,v,i+2,j+1,n,count+1)%mod;\\n        long long int run6=solve(dp,v,i+2,j-1,n,count+1)%mod;\\n        long long int run7=solve(dp,v,i+1,j+2,n,count+1)%mod;\\n        long long int run8=solve(dp,v,i+1,j-2,n,count+1)%mod;\\n        return dp[count][i][j]=((run1+run2+run3+run4+run5+run6+run7+run8)%mod)%mod;\\n        \\n    }\\n    int knightDialer(int n) {\\n        vector<vector<char>> v={{\\'1\\',\\'2\\',\\'3\\'},{\\'4\\',\\'5\\',\\'6\\'},{\\'7\\',\\'8\\',\\'9\\'},{\\'*\\',\\'0\\',\\'#\\'}};\\n       // vector<string> ans;\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(4,vector<int> (4,0)));\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n                ans+=( solve(dp,v,i,j,n-1,0)%mod);\\n        }\\n        return ans%mod;\\n\\t\\t\\nPlease upvote if you like this solution.\\nThanks",
                "codeTag": "Unknown"
            },
            {
                "id": 1671885,
                "title": "python-top-down-dynamic-programming-time-out",
                "content": "Could someone explain why this is getting time-out errors?\\n\\nI\\'ve used top-down DP (recursion + memoization) and it\\'s still timing out:\\n\\n```{python}\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t\\trows = 3\\n\\t\\tcolumns = 2\\n\\t\\tcache = {}\\n\\t\\t# three state variables\\n\\n\\t\\tdef recurse(i, j, n):\\n\\t\\t\\tif i > rows or i < 0 or j > columns or j < 0 or [i,j] == [3,0] or [i,j] == [3,2]:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\telif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\tif (i ,j, n) in cache:\\n\\t\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\t\\tcache[(i, j, n)] =  sum([recurse(i - 2, j - 1, n - 1), recurse(i - 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i - 2, j + 1, n - 1), recurse(i - 1, j  + 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j - 1, n - 1), recurse(i + 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j + 1, n - 1), recurse(i + 1, j + 2, n - 1)])\\n\\n\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\treturn sum([recurse(0, 0, n - 1), recurse(0, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(0, 2, n - 1), recurse(1, 0, n - 1),\\n\\t\\t\\t\\t\\trecurse(1, 1, n - 1), recurse(1, 2, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 0, n - 1), recurse(2, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 2, n - 1), recurse(3, 1, n - 1)]) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```{python}\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t\\trows = 3\\n\\t\\tcolumns = 2\\n\\t\\tcache = {}\\n\\t\\t# three state variables\\n\\n\\t\\tdef recurse(i, j, n):\\n\\t\\t\\tif i > rows or i < 0 or j > columns or j < 0 or [i,j] == [3,0] or [i,j] == [3,2]:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\telif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\tif (i ,j, n) in cache:\\n\\t\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\t\\tcache[(i, j, n)] =  sum([recurse(i - 2, j - 1, n - 1), recurse(i - 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i - 2, j + 1, n - 1), recurse(i - 1, j  + 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j - 1, n - 1), recurse(i + 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j + 1, n - 1), recurse(i + 1, j + 2, n - 1)])\\n\\n\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\treturn sum([recurse(0, 0, n - 1), recurse(0, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(0, 2, n - 1), recurse(1, 0, n - 1),\\n\\t\\t\\t\\t\\trecurse(1, 1, n - 1), recurse(1, 2, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 0, n - 1), recurse(2, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 2, n - 1), recurse(3, 1, n - 1)]) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662475,
                "title": "python-2-ways-dfs-cache-dp",
                "content": "Solution1 : DFS + Memo\\n```\\ndef knightDialer(self, n: int) -> int:\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\n\\t@cache\\n\\tdef path(x, l): # x: current number, l :length\\n\\t\\tnonlocal mapping, n\\n\\t\\tif l == n:\\n\\t\\t\\treturn 1\\n\\t\\tnexts = mapping.get(x, [])\\n\\t\\tres = 0\\n\\t\\tfor n1 in nexts:\\n\\t\\t\\tres+=path(n1, l+1)\\n\\t\\treturn res\\n\\tresult = 0\\n\\tfor i in range(0, 10):\\n\\t\\tresult += path(i,1)\\n\\treturn result % (pow(10,9)+7)\\n```\\n\\nThink about when standing at number x, length=n , path(n) += each path(mapping(n-1)) , so if we solve all length=n-1 case for all numbers (0-9), can get number x when length=n , formular :\\ndp[n][x] += dp[n-1][mapping[n]] \\nso we could start with solving n=1 case, then n=2 , ... until n=n \\nSolution2 : DP\\n```\\ndef knightDialer(self, n: int) -> int:\\n\\t\"\"\"\\n\\t\\tDP. Sample keyboard :\\n\\t\\tb - c\\n\\t\\t- - -\\n\\t\\t- a -\\n\\t\\tstep 1.For length=1, easy to get dp[1][a]=1, dp[1][b]=1, dp[1][c]=1\\n\\t\\tstep 2.dp[2][a] = dp[1][b] + dp[1][c]\\n\\t\\t...\\n\\t\\tdp[n][a] = dp[n-1][b]+dp[n-1][c]\\n\\t\"\"\"\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\tdp = [[0]*10 for _ in range(n+1)]  #dp[length][count]\\n\\n\\tfor i in range(0, 10):  # length=1, only 1 way for each number (0-9)\\n\\t\\tdp[1][i] = 1\\n\\n\\tfor i in range(2, n+1):\\n\\t\\tfor j in range(0, 10):\\n\\t\\t\\tfor x in mapping.get(j, []):\\n\\t\\t\\t\\tdp[i][j] += dp[i-1][x]\\n\\treturn sum(dp[n][i] for i in range(0, 10))  % (pow(10,9)+7)\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef knightDialer(self, n: int) -> int:\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\n\\t@cache\\n\\tdef path(x, l): # x: current number, l :length\\n\\t\\tnonlocal mapping, n\\n\\t\\tif l == n:\\n\\t\\t\\treturn 1\\n\\t\\tnexts = mapping.get(x, [])\\n\\t\\tres = 0\\n\\t\\tfor n1 in nexts:\\n\\t\\t\\tres+=path(n1, l+1)\\n\\t\\treturn res\\n\\tresult = 0\\n\\tfor i in range(0, 10):\\n\\t\\tresult += path(i,1)\\n\\treturn result % (pow(10,9)+7)\\n```\n```\\ndef knightDialer(self, n: int) -> int:\\n\\t\"\"\"\\n\\t\\tDP. Sample keyboard :\\n\\t\\tb - c\\n\\t\\t- - -\\n\\t\\t- a -\\n\\t\\tstep 1.For length=1, easy to get dp[1][a]=1, dp[1][b]=1, dp[1][c]=1\\n\\t\\tstep 2.dp[2][a] = dp[1][b] + dp[1][c]\\n\\t\\t...\\n\\t\\tdp[n][a] = dp[n-1][b]+dp[n-1][c]\\n\\t\"\"\"\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\tdp = [[0]*10 for _ in range(n+1)]  #dp[length][count]\\n\\n\\tfor i in range(0, 10):  # length=1, only 1 way for each number (0-9)\\n\\t\\tdp[1][i] = 1\\n\\n\\tfor i in range(2, n+1):\\n\\t\\tfor j in range(0, 10):\\n\\t\\t\\tfor x in mapping.get(j, []):\\n\\t\\t\\t\\tdp[i][j] += dp[i-1][x]\\n\\treturn sum(dp[n][i] for i in range(0, 10))  % (pow(10,9)+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1661330,
                "title": "java-2ms-dp",
                "content": "`static` memo is the key.\\n\\n```\\nclass Solution {\\n    \\n    static int mod = 1000_000_007;\\n    static int[][] map = new int[10][];\\n    static List<int[]> memo = new ArrayList<>();\\n    static {\\n        map[0] = new int[] {4, 6};\\n        map[1] = new int[] {6, 8};\\n        map[2] = new int[] {7, 9};\\n        map[3] = new int[] {4, 8};\\n        map[4] = new int[] {3, 9, 0};\\n        map[5] = new int[0];\\n        map[6] = new int[] {1, 7, 0};\\n        map[7] = new int[] {2, 6};\\n        map[8] = new int[] {1, 3};\\n        map[9] = new int[] {2, 4};\\n        memo.add(new int[] {1, 1, 1, 1, 1, 0, 1, 1, 1, 1});\\n    }\\n\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        while (memo.size() < n) {\\n            int[] cur = memo.get(memo.size() - 1);\\n            int[] next = new int[10];\\n            for (int i = 0; i < 10; i++) {\\n                for (int d : map[i]) {\\n                    next[d] = (next[d] + cur[i]) % mod;\\n                }\\n            }\\n            memo.add(next);\\n        }\\n        int sum = 0;\\n        for (int x : memo.get(n - 1)) {\\n            sum = (sum + x) % mod;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static int mod = 1000_000_007;\\n    static int[][] map = new int[10][];\\n    static List<int[]> memo = new ArrayList<>();\\n    static {\\n        map[0] = new int[] {4, 6};\\n        map[1] = new int[] {6, 8};\\n        map[2] = new int[] {7, 9};\\n        map[3] = new int[] {4, 8};\\n        map[4] = new int[] {3, 9, 0};\\n        map[5] = new int[0];\\n        map[6] = new int[] {1, 7, 0};\\n        map[7] = new int[] {2, 6};\\n        map[8] = new int[] {1, 3};\\n        map[9] = new int[] {2, 4};\\n        memo.add(new int[] {1, 1, 1, 1, 1, 0, 1, 1, 1, 1});\\n    }\\n\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        while (memo.size() < n) {\\n            int[] cur = memo.get(memo.size() - 1);\\n            int[] next = new int[10];\\n            for (int i = 0; i < 10; i++) {\\n                for (int d : map[i]) {\\n                    next[d] = (next[d] + cur[i]) % mod;\\n                }\\n            }\\n            memo.add(next);\\n        }\\n        int sum = 0;\\n        for (int x : memo.get(n - 1)) {\\n            sum = (sum + x) % mod;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641780,
                "title": "c-o-n-time-o-1-space-0-ms-5-8-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) { \\n        // Edge case\\n        if( n == 1 ) {\\n            return 10;\\n        }\\n\\n        // Define all nodes(numbers) such a way:\\n        // Red nodes(4 and 6) derive three nodes in the next level\\n        // Each red node gives two green nodes and one zero\\n        long long redCount( 2 );\\n        // Green nodes(3, 9, 1, 7) derive red nodes in the next level\\n        // Each green node gives one red and one blue node\\n        long long greenCount( 4 );\\n        // Zero node(0) derives only TWO red nodes in the next level\\n        long long zeroCount( 1 );\\n        // Blue nodes(2 and 8) derive green nodes in the next level\\n        // Each blue node gives two green nodes\\n        long long blueCount( 2 );\\n\\n        // module\\n        constexpr int mod = 1000 * 1000 * 1000 + 7;\\n        \\n        // Calculate nodes count in each level from count in the previous level\\n        for( int i = 2; i <= n; i++ ) {\\n            long long newRedCount = zeroCount * 2 + greenCount;\\n            long long newGreenCount = redCount * 2 + blueCount * 2;\\n            long long newZeroCount = redCount;\\n            long long newBlueCount = greenCount;\\n\\n            // refresh values\\n            redCount = newRedCount % mod;\\n            greenCount = newGreenCount % mod;\\n            zeroCount = newZeroCount % mod;\\n            blueCount = newBlueCount % mod;\\n        }\\n\\n        // Calculate phone numbers count        \\n        long long allNumbersCount = redCount + greenCount + zeroCount + blueCount;\\n        return allNumbersCount % mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) { \\n        // Edge case\\n        if( n == 1 ) {\\n            return 10;\\n        }\\n\\n        // Define all nodes(numbers) such a way:\\n        // Red nodes(4 and 6) derive three nodes in the next level\\n        // Each red node gives two green nodes and one zero\\n        long long redCount( 2 );\\n        // Green nodes(3, 9, 1, 7) derive red nodes in the next level\\n        // Each green node gives one red and one blue node\\n        long long greenCount( 4 );\\n        // Zero node(0) derives only TWO red nodes in the next level\\n        long long zeroCount( 1 );\\n        // Blue nodes(2 and 8) derive green nodes in the next level\\n        // Each blue node gives two green nodes\\n        long long blueCount( 2 );\\n\\n        // module\\n        constexpr int mod = 1000 * 1000 * 1000 + 7;\\n        \\n        // Calculate nodes count in each level from count in the previous level\\n        for( int i = 2; i <= n; i++ ) {\\n            long long newRedCount = zeroCount * 2 + greenCount;\\n            long long newGreenCount = redCount * 2 + blueCount * 2;\\n            long long newZeroCount = redCount;\\n            long long newBlueCount = greenCount;\\n\\n            // refresh values\\n            redCount = newRedCount % mod;\\n            greenCount = newGreenCount % mod;\\n            zeroCount = newZeroCount % mod;\\n            blueCount = newBlueCount % mod;\\n        }\\n\\n        // Calculate phone numbers count        \\n        long long allNumbersCount = redCount + greenCount + zeroCount + blueCount;\\n        return allNumbersCount % mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612327,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    long mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        Map<Integer, int[]> moves = new HashMap<>();\\n        moves.put(0, new int[]{4, 6});\\n        moves.put(1, new int[]{6, 8});\\n        moves.put(2, new int[]{7, 9});\\n        moves.put(3, new int[]{4, 8});\\n        moves.put(4, new int[]{0, 3, 9});\\n        moves.put(5, new int[]{});\\n        moves.put(6, new int[]{0, 1, 7});\\n        moves.put(7, new int[]{2, 6});\\n        moves.put(8, new int[]{1, 3});\\n        moves.put(9, new int[]{2, 4});\\n        \\n        long[][] dp = new long[10][n + 1];\\n        for (int i = 0; i < 10; i++) \\n            Arrays.fill(dp[i], -1);\\n        \\n        long res = 0;\\n        for (int i = 0; i < 10; i++) \\n            res += knightDialerHelper(i, 1, n, moves, dp);\\n        return (int) (res % mod);\\n    }\\n    \\n    public long knightDialerHelper(int step, int level, int targetLevel, Map<Integer, int[]> moves, long[][] dp) {\\n        if (level == targetLevel) return 1;\\n        if (dp[step][level] != -1) return dp[step][level];\\n        \\n        long res = 0;\\n        for (int neighbors : moves.get(step)) \\n            res += knightDialerHelper(neighbors, level + 1, targetLevel, moves, dp) % mod;\\n        \\n        dp[step][level] = res;\\n        return dp[step][level];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    long mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        Map<Integer, int[]> moves = new HashMap<>();\\n        moves.put(0, new int[]{4, 6}",
                "codeTag": "Java"
            },
            {
                "id": 1591091,
                "title": "clean-dp-c-11-solution",
                "content": "```\\nclass Solution {\\n    \\n    public:\\n    int knightDialer(int n) {        \\n        unordered_map<int,vector<int>> movesMap; // num to {num,...,num}\\n        movesMap[0] = {4,6};\\n        movesMap[1] = {8,6};\\n        movesMap[2] = {7,9};\\n        movesMap[3] = {4,8};\\n        movesMap[4] = {0,3,9};\\n        movesMap[5] = {};\\n        movesMap[6] = {0,1,7};\\n        movesMap[7] = {2,6};\\n        movesMap[8] = {1,3};\\n        movesMap[9] = {2,4};\\n\\n        vector<int> dp(10,1); \\n\\n        const int modVal = 1000000007;\\n        auto safeAdd = [=](int a, int b) {return (a+b)%modVal;}; // why the fuck can\\'t i make this cleaner\\n        \\n        for (int j = 2; j <= n; j++) { \\n            vector<int> thisCol(10,0); \\n            \\n            for (int i = 0; i <= 9; i++)\\n                for (auto move : movesMap[i])\\n                    thisCol[i] = safeAdd(thisCol[i], dp[move]); // Aggregate dp values for j-1 \\n                \\n            std::swap(dp,thisCol); \\n        }\\n        \\n        return std::accumulate(dp.begin(), dp.end(),0, safeAdd); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public:\\n    int knightDialer(int n) {        \\n        unordered_map<int,vector<int>> movesMap; // num to {num,...,num}\\n        movesMap[0] = {4,6};\\n        movesMap[1] = {8,6};\\n        movesMap[2] = {7,9};\\n        movesMap[3] = {4,8};\\n        movesMap[4] = {0,3,9};\\n        movesMap[5] = {};\\n        movesMap[6] = {0,1,7};\\n        movesMap[7] = {2,6};\\n        movesMap[8] = {1,3};\\n        movesMap[9] = {2,4};\\n\\n        vector<int> dp(10,1); \\n\\n        const int modVal = 1000000007;\\n        auto safeAdd = [=](int a, int b) {return (a+b)%modVal;}; // why the fuck can\\'t i make this cleaner\\n        \\n        for (int j = 2; j <= n; j++) { \\n            vector<int> thisCol(10,0); \\n            \\n            for (int i = 0; i <= 9; i++)\\n                for (auto move : movesMap[i])\\n                    thisCol[i] = safeAdd(thisCol[i], dp[move]); // Aggregate dp values for j-1 \\n                \\n            std::swap(dp,thisCol); \\n        }\\n        \\n        return std::accumulate(dp.begin(), dp.end(),0, safeAdd); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589287,
                "title": "easy-c-dfs-memo-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> offsets={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\\n    int knightDialer(int n) {\\n        int rows=4;\\n        int cols=3;\\n        \\n        //use a dp to memoize the number of possible combinations on every stirng\\n        vector<vector<vector<long>>> dp(rows,vector<vector<long>>(cols,vector<long>(n+1,-1)));\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=solve(i,j,rows,cols,n-1,dp);\\n                res%=1000000007;\\n            }\\n        }\\n        \\n        //for the last 0 cell\\n        res+=solve(3,1,rows,cols,n-1,dp);\\n        return (int)res%1000000007;\\n    }\\n    long solve(int i,int j,int& rows,int& cols,int n,vector<vector<vector<long>>>& dp)\\n    {\\n        if(n<=0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][j][n]!=-1)\\n            return dp[i][j][n];\\n        long ans=0;\\n        //try all possible 8 directions\\n        for(int k=0;k<8;k++)\\n        {\\n            int x=i+offsets[k][0];\\n            int y=j+offsets[k][1];\\n            if(x<0 || y<0 || x>=rows || y>=cols || (x==3 && y==0) || (x==3 && y==2))\\n                continue;\\n            ans+=solve(x,y,rows,cols,n-1,dp);\\n        }\\n        return dp[i][j][n]=ans%1000000007;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> offsets={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\\n    int knightDialer(int n) {\\n        int rows=4;\\n        int cols=3;\\n        \\n        //use a dp to memoize the number of possible combinations on every stirng\\n        vector<vector<vector<long>>> dp(rows,vector<vector<long>>(cols,vector<long>(n+1,-1)));\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=solve(i,j,rows,cols,n-1,dp);\\n                res%=1000000007;\\n            }\\n        }\\n        \\n        //for the last 0 cell\\n        res+=solve(3,1,rows,cols,n-1,dp);\\n        return (int)res%1000000007;\\n    }\\n    long solve(int i,int j,int& rows,int& cols,int n,vector<vector<vector<long>>>& dp)\\n    {\\n        if(n<=0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][j][n]!=-1)\\n            return dp[i][j][n];\\n        long ans=0;\\n        //try all possible 8 directions\\n        for(int k=0;k<8;k++)\\n        {\\n            int x=i+offsets[k][0];\\n            int y=j+offsets[k][1];\\n            if(x<0 || y<0 || x>=rows || y>=cols || (x==3 && y==0) || (x==3 && y==2))\\n                continue;\\n            ans+=solve(x,y,rows,cols,n-1,dp);\\n        }\\n        return dp[i][j][n]=ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535517,
                "title": "python-recursion-memo",
                "content": "```\\nclass Solution:\\n    \\n    knight_motion = [(-1,2), (1,2), (2,1), (2,-1), (1,-2),(-1,-2),(-2,-1),(-2,1)]\\n    \\n    map = [[1,2,3],[4,5,6],[7,8,9],[-1, 0, -1]]\\n    const = int(pow(10,9))\\n    \\n    \\n    dp = {}\\n    \\n    def isvalid(self,row : int, col : int): \\n        return row < len(self.map) and col < len(self.map[0]) and col >= 0 and row >= 0 and self.map[row][col] >= 0\\n    \\n    def modulo(self, num : int) -> int: \\n        return num % (self.const + 7)\\n        \\n    def recurse(self, n : int, i : int, j : int) -> int: \\n        if n == 1: \\n            return 1 \\n        \\n        count = 0 \\n        \\n        if (i,j,n) in self.dp: \\n            return self.dp[(i,j,n)]\\n        \\n        for (row,col) in self.knight_motion: \\n            newrow = i + row \\n            newcol = j + col \\n\\n            if self.isvalid(newrow, newcol): \\n                count += self.modulo(self.recurse(n-1, newrow, newcol))\\n        \\n        self.dp[(i,j,n)] = self.modulo(count)\\n        \\n        return self.dp[(i,j,n)]\\n        \\n    \\n    def knightDialer(self, n: int) -> int:\\n        count = 0 \\n        \\n        for i in range(len(self.map)): \\n            for j in range(len(self.map[0])): \\n                \\n                if self.map[i][j] >= 0: \\n                    count+= self.recurse(n, i,j)\\n                    count = self.modulo(count)\\n        \\n        return count\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    knight_motion = [(-1,2), (1,2), (2,1), (2,-1), (1,-2),(-1,-2),(-2,-1),(-2,1)]\\n    \\n    map = [[1,2,3],[4,5,6],[7,8,9],[-1, 0, -1]]\\n    const = int(pow(10,9))\\n    \\n    \\n    dp = {}\\n    \\n    def isvalid(self,row : int, col : int): \\n        return row < len(self.map) and col < len(self.map[0]) and col >= 0 and row >= 0 and self.map[row][col] >= 0\\n    \\n    def modulo(self, num : int) -> int: \\n        return num % (self.const + 7)\\n        \\n    def recurse(self, n : int, i : int, j : int) -> int: \\n        if n == 1: \\n            return 1 \\n        \\n        count = 0 \\n        \\n        if (i,j,n) in self.dp: \\n            return self.dp[(i,j,n)]\\n        \\n        for (row,col) in self.knight_motion: \\n            newrow = i + row \\n            newcol = j + col \\n\\n            if self.isvalid(newrow, newcol): \\n                count += self.modulo(self.recurse(n-1, newrow, newcol))\\n        \\n        self.dp[(i,j,n)] = self.modulo(count)\\n        \\n        return self.dp[(i,j,n)]\\n        \\n    \\n    def knightDialer(self, n: int) -> int:\\n        count = 0 \\n        \\n        for i in range(len(self.map)): \\n            for j in range(len(self.map[0])): \\n                \\n                if self.map[i][j] >= 0: \\n                    count+= self.recurse(n, i,j)\\n                    count = self.modulo(count)\\n        \\n        return count\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511068,
                "title": "python-super-simple-bottom-up-dp",
                "content": "```\\nNumberToJumps = {\\n    1 : [8, 6],\\n    2: [7, 9],\\n    3: [4, 8],\\n    4: [3, 9, 0],\\n    5: [],\\n    6: [1, 7, 0],\\n    7: [2, 6],\\n    8: [1, 3],\\n    9: [4, 2],\\n    0: [4, 6],\\n}\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n        numberToNumPathsOfCurrentPathLength = [1]*10\\n        currentPathLength = 1\\n        while currentPathLength < n:\\n            numberToNumPathsOfNextPathLength = [0]*10\\n            \\n            for telephoneNumber in range(10):\\n                for numberToJumpTo in NumberToJumps[telephoneNumber]:\\n                    numberToNumPathsOfNextPathLength[telephoneNumber] += numberToNumPathsOfCurrentPathLength[numberToJumpTo]\\n            \\n            currentPathLength += 1\\n            numberToNumPathsOfCurrentPathLength = numberToNumPathsOfNextPathLength\\n        \\n        return sum(numberToNumPathsOfCurrentPathLength) % (pow(10, 9) + 7)",
                "solutionTags": [],
                "code": "```\\nNumberToJumps = {\\n    1 : [8, 6],\\n    2: [7, 9],\\n    3: [4, 8],\\n    4: [3, 9, 0],\\n    5: [],\\n    6: [1, 7, 0],\\n    7: [2, 6],\\n    8: [1, 3],\\n    9: [4, 2],\\n    0: [4, 6],\\n}\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n        numberToNumPathsOfCurrentPathLength = [1]*10\\n        currentPathLength = 1\\n        while currentPathLength < n:\\n            numberToNumPathsOfNextPathLength = [0]*10\\n            \\n            for telephoneNumber in range(10):\\n                for numberToJumpTo in NumberToJumps[telephoneNumber]:\\n                    numberToNumPathsOfNextPathLength[telephoneNumber] += numberToNumPathsOfCurrentPathLength[numberToJumpTo]\\n            \\n            currentPathLength += 1\\n            numberToNumPathsOfCurrentPathLength = numberToNumPathsOfNextPathLength\\n        \\n        return sum(numberToNumPathsOfCurrentPathLength) % (pow(10, 9) + 7)",
                "codeTag": "Java"
            },
            {
                "id": 1455243,
                "title": "dp-on-the-possible-paths-of-knight-c",
                "content": "```\\nclass Solution {\\npublic: int md=1e9+7;\\n    int knightDialer(int n) {\\n        unordered_map<int,vector<int>>mp;\\n        mp[0]={4,6};\\n        mp[1]={6,8};\\n        mp[2]={7,9};\\n        mp[3]={4,8};\\n        mp[4]={0,3,9};\\n        mp[5]={};\\n        mp[6]={0,1,7};\\n        mp[7]={2,6};\\n        mp[8]={1,3};\\n        mp[9]={2,4};\\n        vector<vector<int>>dp(n+1,vector<int>(10));\\n        for(int i=0;i<10;i++)dp[1][i]=1;\\n        for(int i=2;i<=n;i++)\\n            for(int j=0;j<10;j++)\\n                for(auto &n:mp[j])\\n                    dp[i][j]=(dp[i][j]+dp[i-1][n])%md;\\n        for(int j=0;j<9;j++)\\n            dp[n][9]=(dp[n][9]+dp[n][j])%md;\\n        return dp[n][9];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic: int md=1e9+7;\\n    int knightDialer(int n) {\\n        unordered_map<int,vector<int>>mp;\\n        mp[0]={4,6};\\n        mp[1]={6,8};\\n        mp[2]={7,9};\\n        mp[3]={4,8};\\n        mp[4]={0,3,9};\\n        mp[5]={};\\n        mp[6]={0,1,7};\\n        mp[7]={2,6};\\n        mp[8]={1,3};\\n        mp[9]={2,4};\\n        vector<vector<int>>dp(n+1,vector<int>(10));\\n        for(int i=0;i<10;i++)dp[1][i]=1;\\n        for(int i=2;i<=n;i++)\\n            for(int j=0;j<10;j++)\\n                for(auto &n:mp[j])\\n                    dp[i][j]=(dp[i][j]+dp[i-1][n])%md;\\n        for(int j=0;j<9;j++)\\n            dp[n][9]=(dp[n][9]+dp[n][j])%md;\\n        return dp[n][9];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431522,
                "title": "python-o-n-dp-and-thinking-process",
                "content": "We could start from a naive brutal force recursive solution as follows. Just iterate each possible next positions on the dial board.\\n\\n```\\n        board = [\\n            [1,2,3],\\n            [4,5,6],\\n            [7,8,9],\\n            [-1, 0, -1]\\n        ]\\n        \\n        r_lim = len(board)\\n        c_lim = len(board[0])\\n        \\n        offset_list = [\\n            [-1, -2],\\n            [-2, -1],\\n            [-2, 1],\\n            [-1, 2],\\n            [1, -2],\\n            [2, -1],\\n            [2, 1],\\n            [1, 2]     \\n        ]\\n        \\n        mod = 10**9+7\\n        \\n        def recur_f(c_r, c_c, c_steps):\\n            \\n            if(c_steps == n):\\n                return 1\\n            \\n            result = 0\\n            for offset in offset_list:\\n                n_r = c_r + offset[0]\\n                n_c = c_c + offset[1]\\n                \\n                if(0 <= n_r < r_lim \\n                    and \\n                   0 <= n_c < c_lim\\n                    and\\n                   board[n_r][n_c] != -1\\n                  ):\\n                    result+=recur_f(n_r, n_c, c_steps+1)\\n            \\n            return result%mod\\n        \\n        final_result = 0\\n        for r in range(0, r_lim):\\n            for c in range(0, c_lim):\\n                if(board[r][c] != -1):\\n                    final_result += recur_f(r, c, 1)\\n\\n        return final_result%mod\\n```\\n\\nSo we found the key is actually compute the **number of next position**, which is the **current end digit of the dial string**. And since the dial board is a small and fixed one, we could store all possible next positions given the current position. And keep updating number of strings with each ending digits.\\n\\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = (2, [6,8])\\n        pos_n_move_dict[2] = (2, [7,9])\\n        pos_n_move_dict[3] = (2, [4,8])\\n        pos_n_move_dict[4] = (3, [3,9,0])\\n        pos_n_move_dict[5] = (0, [])\\n        pos_n_move_dict[6] = (3, [1,7,0])\\n        pos_n_move_dict[7] = (2, [2,6])\\n        pos_n_move_dict[8] = (2, [1,3])\\n        pos_n_move_dict[9] = (2, [2,4])\\n        pos_n_move_dict[0] = (2, [4,6])\\n        \\n        c_pos_dict = {}\\n        for i in range(0, 10):\\n            c_pos_dict[i] = 1\\n        \\n        dp_list = [-1]*(n+1)\\n        \\n        dp_list[1] = 10\\n        \\n        for i in range(2, n+1):\\n            \\n            c_cnt = 0\\n            for pos, pos_cnt in c_pos_dict.items():\\n                c_cnt+= pos_cnt*pos_n_move_dict[pos][0]\\n            \\n            new_pos_dict = {}\\n            for pos, pos_cnt in c_pos_dict.items():\\n                n_pos_list = pos_n_move_dict[pos][1]\\n                \\n                for n_pos in n_pos_list:\\n                    if(n_pos in new_pos_dict):\\n                        new_pos_dict[n_pos]+=pos_cnt\\n                    else:\\n                        new_pos_dict[n_pos]=pos_cnt\\n                        \\n            c_pos_dict = new_pos_dict\\n            \\n            dp_list[i] = c_cnt%mod\\n        \\n        return dp_list[n]%mod\\n```\\n\\nAnd the final version is using a two-dim dp_array. The first dimension is the current step. And the second dimension is the **numbers of string with that ending digit**.\\n\\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = [6,8]\\n        pos_n_move_dict[2] = [7,9]\\n        pos_n_move_dict[3] = [4,8]\\n        pos_n_move_dict[4] = [3,9,0]\\n        pos_n_move_dict[5] = []\\n        pos_n_move_dict[6] = [1,7,0]\\n        pos_n_move_dict[7] = [2,6]\\n        pos_n_move_dict[8] = [1,3]\\n        pos_n_move_dict[9] = [2,4]\\n        pos_n_move_dict[0] = [4,6]\\n    \\n        \\n        dp_array = []\\n        for i in range(0, n+1):\\n            dp_array.append([0]*10)\\n        \\n        for i in range(0, 10):\\n            dp_array[1][i]=1\\n        \\n        for step in range(2, n+1):\\n            \\n            c_list = [0]*10\\n        \\n            for end_digit in range(0, 10):\\n                for next_end_digit in pos_n_move_dict[end_digit]:\\n                    dp_array[step][next_end_digit]+=dp_array[step-1][end_digit]\\n        \\n        result = 0\\n        for i in range(0, 10):\\n            result += dp_array[n][i]\\n            result = result%mod\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n        board = [\\n            [1,2,3],\\n            [4,5,6],\\n            [7,8,9],\\n            [-1, 0, -1]\\n        ]\\n        \\n        r_lim = len(board)\\n        c_lim = len(board[0])\\n        \\n        offset_list = [\\n            [-1, -2],\\n            [-2, -1],\\n            [-2, 1],\\n            [-1, 2],\\n            [1, -2],\\n            [2, -1],\\n            [2, 1],\\n            [1, 2]     \\n        ]\\n        \\n        mod = 10**9+7\\n        \\n        def recur_f(c_r, c_c, c_steps):\\n            \\n            if(c_steps == n):\\n                return 1\\n            \\n            result = 0\\n            for offset in offset_list:\\n                n_r = c_r + offset[0]\\n                n_c = c_c + offset[1]\\n                \\n                if(0 <= n_r < r_lim \\n                    and \\n                   0 <= n_c < c_lim\\n                    and\\n                   board[n_r][n_c] != -1\\n                  ):\\n                    result+=recur_f(n_r, n_c, c_steps+1)\\n            \\n            return result%mod\\n        \\n        final_result = 0\\n        for r in range(0, r_lim):\\n            for c in range(0, c_lim):\\n                if(board[r][c] != -1):\\n                    final_result += recur_f(r, c, 1)\\n\\n        return final_result%mod\\n```\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = (2, [6,8])\\n        pos_n_move_dict[2] = (2, [7,9])\\n        pos_n_move_dict[3] = (2, [4,8])\\n        pos_n_move_dict[4] = (3, [3,9,0])\\n        pos_n_move_dict[5] = (0, [])\\n        pos_n_move_dict[6] = (3, [1,7,0])\\n        pos_n_move_dict[7] = (2, [2,6])\\n        pos_n_move_dict[8] = (2, [1,3])\\n        pos_n_move_dict[9] = (2, [2,4])\\n        pos_n_move_dict[0] = (2, [4,6])\\n        \\n        c_pos_dict = {}\\n        for i in range(0, 10):\\n            c_pos_dict[i] = 1\\n        \\n        dp_list = [-1]*(n+1)\\n        \\n        dp_list[1] = 10\\n        \\n        for i in range(2, n+1):\\n            \\n            c_cnt = 0\\n            for pos, pos_cnt in c_pos_dict.items():\\n                c_cnt+= pos_cnt*pos_n_move_dict[pos][0]\\n            \\n            new_pos_dict = {}\\n            for pos, pos_cnt in c_pos_dict.items():\\n                n_pos_list = pos_n_move_dict[pos][1]\\n                \\n                for n_pos in n_pos_list:\\n                    if(n_pos in new_pos_dict):\\n                        new_pos_dict[n_pos]+=pos_cnt\\n                    else:\\n                        new_pos_dict[n_pos]=pos_cnt\\n                        \\n            c_pos_dict = new_pos_dict\\n            \\n            dp_list[i] = c_cnt%mod\\n        \\n        return dp_list[n]%mod\\n```\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = [6,8]\\n        pos_n_move_dict[2] = [7,9]\\n        pos_n_move_dict[3] = [4,8]\\n        pos_n_move_dict[4] = [3,9,0]\\n        pos_n_move_dict[5] = []\\n        pos_n_move_dict[6] = [1,7,0]\\n        pos_n_move_dict[7] = [2,6]\\n        pos_n_move_dict[8] = [1,3]\\n        pos_n_move_dict[9] = [2,4]\\n        pos_n_move_dict[0] = [4,6]\\n    \\n        \\n        dp_array = []\\n        for i in range(0, n+1):\\n            dp_array.append([0]*10)\\n        \\n        for i in range(0, 10):\\n            dp_array[1][i]=1\\n        \\n        for step in range(2, n+1):\\n            \\n            c_list = [0]*10\\n        \\n            for end_digit in range(0, 10):\\n                for next_end_digit in pos_n_move_dict[end_digit]:\\n                    dp_array[step][next_end_digit]+=dp_array[step-1][end_digit]\\n        \\n        result = 0\\n        for i in range(0, 10):\\n            result += dp_array[n][i]\\n            result = result%mod\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1422012,
                "title": "c-dp-98",
                "content": "public class Solution {\\n  \\n    long mod = 1000*1000*1000+7;\\n    \\n   \\n           \\n    public int KnightDialer(int n) {\\n        \\n         \\n        long[,] dp = new long[10,n+1];\\n        \\n        for(int i=0;i<10;i++)\\n        {\\n            dp[i,1] = 1;\\n        }\\n        \\n        for(int steps=2;steps<=n;steps++)\\n        {\\n            dp[0,steps] = (dp[4,steps-1] + dp[6,steps-1]) % mod;\\n            dp[1,steps] = (dp[6,steps-1] + dp[8,steps-1]) % mod;\\n            dp[2,steps] = (dp[7,steps-1] + dp[9,steps-1]) % mod;\\n            dp[3,steps] = (dp[4,steps-1] + dp[8,steps-1]) % mod;\\n            dp[4,steps] = (dp[0,steps-1] + dp[3,steps-1] + dp[9,steps-1]) % mod ;\\n            dp[6,steps] = (dp[1,steps-1] + dp[7,steps-1] + dp[0,steps-1]) % mod;\\n            dp[7,steps] = (dp[2,steps-1] + dp[6,steps-1]) % mod;\\n            dp[8,steps] = (dp[1,steps-1] + dp[3,steps-1]) % mod;\\n            dp[9,steps] = (dp[4,steps-1] + dp[2,steps-1]) % mod;\\n        }\\n        \\n        long total = 0;\\n        for(int i=0;i<10;i++)\\n        {\\n              total += dp[i,n] % mod;\\n        }\\n          \\n        return (int)(total % mod);\\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n  \\n    long mod = 1000*1000*1000+7;\\n    \\n   \\n           \\n    public int KnightDialer(int n) {\\n        \\n         \\n        long[,] dp = new long[10,n+1];\\n        \\n        for(int i=0;i<10;i++)\\n        {\\n            dp[i,1] = 1;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566349,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568198,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566837,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572988,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1979888,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873741,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576739,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1967464,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1966818,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1860704,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566349,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568198,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566837,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572988,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1979888,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873741,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576739,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1967464,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1966818,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1860704,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]