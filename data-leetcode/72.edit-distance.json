[
    {
        "title": "Edit Distance",
        "question_content": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\n\tInsert a character\n\tDelete a character\n\tReplace a character\n\n&nbsp;\nExample 1:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\nExample 2:\n\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n&nbsp;\nConstraints:\n\n\t0 <= word1.length, word2.length <= 500\n\tword1 and word2 consist of lowercase English letters.",
        "solutions": [
            {
                "id": 159295,
                "title": "python-solutions-and-intuition",
                "content": "For those having difficulty cracking dynamic programming solutions, I find it easiest to solve by first starting with a naive, but working recursive implementation. It\\'s essential to do so, because dynamic programming is basically recursion with caching. With this workflow, deciphering dynamic programming problems becomes just a little more manageable for us normal people. :)\\n\\n**Thought process:**\\nGiven two strings, we\\'re tasked with finding the minimum number of transformations we need to make to arrive with equivalent strings. From the get-go, there doesn\\'t seem to be any way around trying all possibilities, and in this, possibilities refers to inserting, deleting, or replacing a character. Recursion is usually a good choice for trying all possilbilities. \\n\\nWhenever we write recursive functions, we\\'ll need some way to terminate, or else we\\'ll end up overflowing the stack via infinite recursion. With strings, the natural state to keep track of is the index. We\\'ll need two indexes, one for word1 and one for word2. Now we just need to handle our base cases, and recursive cases. \\nWhat happens when we\\'re done with either word? Some thought will tell you that the minimum number of transformations is simply to insert the rest of the other word. This is our base case. What about when we\\'re not done with either string? We\\'ll either match the currently indexed characters in both strings, or mismatch. In the first case, we don\\'t incur any penalty, and we can continue to compare the rest of the strings by recursing on the rest of both strings. In the case of a mismatch, we either insert, delete, or replace. To recap:\\n1. base case: word1 = \"\" or word2 = \"\" => return length of other string\\n2. recursive case: word1[0] == word2[0] => recurse on word1[1:] and word2[1:]\\n3. recursive case: word1[0] != word2[0] => recurse by inserting, deleting, or replacing \\n\\nAnd in Python:\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Naive recursive solution\"\"\"\\n        if not word1 and not word2:\\n            return 0\\n        if not word1:\\n            return len(word2)\\n        if not word2:\\n            return len(word1)\\n        if word1[0] == word2[0]:\\n            return self.minDistance(word1[1:], word2[1:])\\n        insert = 1 + self.minDistance(word1, word2[1:])\\n        delete = 1 + self.minDistance(word1[1:], word2)\\n        replace = 1 + self.minDistance(word1[1:], word2[1:])\\n        return min(insert, replace, delete)\\n```\\n\\nWith a solution in hand, we\\'re ecstatic and we go to submit our code. All is well until we see the dreaded red text... **TIME LIMIT EXCEEDED**. What did we do wrong? Let\\'s look at a simple example, and for sake of brevity I\\'ll annotate the minDistance function as ```md```. \\n\\nword1 = \"horse\"\\nword2 = \"hello\"\\n\\nThe tree of recursive calls, 3 levels deep, looks like the following. I\\'ve highlighted recursive calls with multiple invocations. So now we see that we\\'re repeating work. I\\'m not going to try and analyze the runtime of this solution, but it\\'s exponential. \\n\\n```\\nmd(\"horse\", \"hello\")\\n\\tmd(\"orse\", \"ello\")\\n\\t\\tmd(\"orse\", \"llo\")\\n\\t\\t\\tmd(\"orse\", \"lo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <- \\n\\t\\t\\tmd(\"rse\", \"lo\")\\n\\t\\tmd(\"rse\", \"ello\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"ello\")\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\tmd(\"rse\", \"llo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\t\\tmd(\"se\", \"lo\")\\n```\\n\\nThe way we fix this is by **caching**. We save intermediate computations in a dictionary and if we recur on the same subproblem, instead of doing the same work again, we return the saved value. Here is the memoized solution, where we build from bigger subproblems to smaller subproblems (top-down).\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2, i, j, memo):\\n        \"\"\"Memoized solution\"\"\"\\n        if i == len(word1) and j == len(word2):\\n            return 0\\n        if i == len(word1):\\n            return len(word2) - j\\n        if j == len(word2):\\n            return len(word1) - i\\n\\n        if (i, j) not in memo:\\n            if word1[i] == word2[j]:\\n                ans = self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n            else: \\n                insert = 1 + self.minDistance2(word1, word2, i, j + 1, memo)\\n                delete = 1 + self.minDistance2(word1, word2, i + 1, j, memo)\\n                replace = 1 + self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n                ans = min(insert, delete, replace)\\n            memo[(i, j)] = ans\\n        return memo[(i, j)]\\n```\\n\\nOf course, an interative implementation is usually better than its recursive counterpart because we don\\'t risk blowing up our stack in case the number of recursive calls is very deep. We can also use a 2D array to do essentially the same thing as the dictionary of cached values. When we do this, we build up solutions from smaller subproblems to bigger subproblems (bottom-up). In this case, since we are no longer \"recurring\" in the traditional sense, we initialize our 2D table with base constraints. The first row and column of the table has known values since if one string is empty, we simply add the length of the non-empty string since that is the minimum number of edits necessary to arrive at equivalent strings. For both the memoized and dynamic programming solutions, the runtime is ```O(mn)``` and the space complexity is ```O(mn)``` where m and n are the lengths of word1 and word2, respectively.\\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Dynamic programming solution\"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        table = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(m + 1):\\n            table[i][0] = i\\n        for j in range(n + 1):\\n            table[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    table[i][j] = table[i - 1][j - 1]\\n                else:\\n                    table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1])\\n        return table[-1][-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Naive recursive solution\"\"\"\\n        if not word1 and not word2:\\n            return 0\\n        if not word1:\\n            return len(word2)\\n        if not word2:\\n            return len(word1)\\n        if word1[0] == word2[0]:\\n            return self.minDistance(word1[1:], word2[1:])\\n        insert = 1 + self.minDistance(word1, word2[1:])\\n        delete = 1 + self.minDistance(word1[1:], word2)\\n        replace = 1 + self.minDistance(word1[1:], word2[1:])\\n        return min(insert, replace, delete)\\n```\n```md```\n```\\nmd(\"horse\", \"hello\")\\n\\tmd(\"orse\", \"ello\")\\n\\t\\tmd(\"orse\", \"llo\")\\n\\t\\t\\tmd(\"orse\", \"lo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <- \\n\\t\\t\\tmd(\"rse\", \"lo\")\\n\\t\\tmd(\"rse\", \"ello\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"ello\")\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\tmd(\"rse\", \"llo\")\\n\\t\\t\\tmd(\"rse\", \"llo\") <-\\n\\t\\t\\tmd(\"se\", \"llo\") <<-\\n\\t\\t\\tmd(\"se\", \"lo\")\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1, word2, i, j, memo):\\n        \"\"\"Memoized solution\"\"\"\\n        if i == len(word1) and j == len(word2):\\n            return 0\\n        if i == len(word1):\\n            return len(word2) - j\\n        if j == len(word2):\\n            return len(word1) - i\\n\\n        if (i, j) not in memo:\\n            if word1[i] == word2[j]:\\n                ans = self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n            else: \\n                insert = 1 + self.minDistance2(word1, word2, i, j + 1, memo)\\n                delete = 1 + self.minDistance2(word1, word2, i + 1, j, memo)\\n                replace = 1 + self.minDistance2(word1, word2, i + 1, j + 1, memo)\\n                ans = min(insert, delete, replace)\\n            memo[(i, j)] = ans\\n        return memo[(i, j)]\\n```\n```O(mn)```\n```O(mn)```\n```\\nclass Solution:\\n    def minDistance(self, word1, word2):\\n        \"\"\"Dynamic programming solution\"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        table = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(m + 1):\\n            table[i][0] = i\\n        for j in range(n + 1):\\n            table[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    table[i][j] = table[i - 1][j - 1]\\n                else:\\n                    table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1], table[i - 1][j - 1])\\n        return table[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25846,
                "title": "c-o-n-space-dp",
                "content": "To apply DP, we define the state `dp[i][j]` to be the minimum number of operations to convert `word1[0..i)` to `word2[0..j)`.\\n\\nFor the base case, that is, to convert a string to an empty string, the mininum number of operations (deletions) is just the length of the string. So we have `dp[i][0] = i` and `dp[0][j] = j`.\\n\\nFor the general case to convert `word1[0..i)` to `word2[0..j)`, we break this problem down into sub-problems. Suppose we have already known how to convert `word1[0..i - 1)` to `word2[0..j - 1)` (`dp[i - 1][j - 1]`), if  `word1[i - 1] == word2[j - 1]`, then no more operation is needed and `dp[i][j] = dp[i - 1][j - 1]`.\\n\\nIf `word1[i - 1] != word2[j - 1]`, we need to consider three cases.\\n\\n 1. **Replace** `word1[i - 1]` by `word2[j - 1]` (`dp[i][j] = dp[i - 1][j - 1] + 1`);\\n 2. If `word1[0..i - 1) = word2[0..j)` then **delete** `word1[i - 1]` (`dp[i][j] = dp[i - 1][j] + 1`);\\n 3. If `word1[0..i) + word2[j - 1] = word2[0..j)` then **insert** `word2[j - 1]` to `word1[0..i)` (`dp[i][j] = dp[i][j - 1] + 1`).\\n\\nSo when `word1[i - 1] != word2[j - 1]`, `dp[i][j]` will just be the minimum of the above three cases.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nNote that each time when we update `dp[i][j]`, we only need `dp[i - 1][j - 1]`, `dp[i][j - 1]` and `dp[i - 1][j]`. We may optimize the space of the code to use only two vectors.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<int> pre(n + 1, 0), cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            pre[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre[j - 1];\\n                } else {\\n                    cur[j] = min(pre[j - 1], min(cur[j - 1], pre[j])) + 1;\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return pre[n];\\n    }\\n};\\n```\\n\\nOr even just one vector.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size(), pre;\\n        vector<int> cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            cur[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            pre = cur[0];\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                int temp = cur[j];\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre;\\n                } else {\\n                    cur[j] = min(pre, min(cur[j - 1], cur[j])) + 1;\\n                }\\n                pre = temp;\\n            }\\n        }\\n        return cur[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j])) + 1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size();\\n        vector<int> pre(n + 1, 0), cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            pre[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre[j - 1];\\n                } else {\\n                    cur[j] = min(pre[j - 1], min(cur[j - 1], pre[j])) + 1;\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return pre[n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size(), n = word2.size(), pre;\\n        vector<int> cur(n + 1, 0);\\n        for (int j = 1; j <= n; j++) {\\n            cur[j] = j;\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            pre = cur[0];\\n            cur[0] = i;\\n            for (int j = 1; j <= n; j++) {\\n                int temp = cur[j];\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    cur[j] = pre;\\n                } else {\\n                    cur[j] = min(pre, min(cur[j - 1], cur[j])) + 1;\\n                }\\n                pre = temp;\\n            }\\n        }\\n        return cur[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25895,
                "title": "step-by-step-explanation-of-how-to-optimize-the-solution-from-simple-recursion-to-dp",
                "content": "First we may want to consider recursion.\\n```\\npublic class Solution {\\n    /**\\n     * Recursive solution.\\n     * For each poisition, check three subproblem:\\n     * 1. insert\\n     * 2. delete\\n     * 3. replace\\n     * We only modify the first string since no matter which one we choose, the result is the same. \\n     * Got TLE since we recursively solve the same subproblem several times.\\n     * Appromixately O(len1 ^ 3) time in the worst case.\\n     * Need to optimize it using cache, which is the idea of dynamic programming. \\n     * The key point is to find out the subproblem we have solved duplicately and cache the recursion.\\n     * Noticed that each subproblem is specificed by i and j pointer, so we can cache the result of these subproblems. \\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word1.length() == 0) return word2.length();\\n        if (word2 == null || word2.length() == 0) return word1.length();\\n        \\n        return match(word1, word2, 0, 0);\\n    }\\n    \\n    private int match(String s1, String s2, int i, int j) {\\n        //If one of the string's pointer have reached the end of it\\n        if (s1.length() == i) {\\n            return s2.length() - j;\\n        }\\n        if (s2.length() == j) {\\n            return s1.length() - i;\\n        }\\n        \\n        int res;\\n        //If current poisition is the same.\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            res = match(s1, s2, i + 1, j + 1);\\n        } else {\\n            //Case1: insert\\n            int insert = match(s1, s2, i, j + 1);\\n            //Case2: delete\\n            int delete = match(s1, s2, i + 1, j);\\n            //Case3: replace\\n            int replace = match(s1, s2, i + 1, j + 1);\\n            res = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return res;\\n    }\\n}  \\n```\\nThis got TLE. based on the analysis above, we may try DP. \\n```\\npublic class Solution {\\n    /**\\n     * Optimization using dynamic programming\\n     * Top-down solution\\n     * O(len1 * len2) time, O(len1 * len2) space\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] cache = new int[c1.length][c2.length];\\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                cache[i][j] = -1;\\n            }\\n        }\\n        \\n        return match(c1, c2, 0, 0, cache);\\n    }\\n    \\n    private int match(char[] c1, char[] c2, int i, int j, int[][] cache) {\\n        if (c1.length == i) return c2.length - j;\\n        if (c2.length == j) return c1.length - i;\\n        \\n        if (cache[i][j] != -1) {\\n            return cache[i][j];\\n        }\\n        \\n        if (c1[i] == c2[j]) {\\n            cache[i][j] = match(c1, c2, i + 1, j + 1, cache);\\n        } else {\\n            //Case1: insert\\n            int insert = match(c1, c2, i, j + 1, cache);\\n            //Case2: delete\\n            int delete = match(c1, c2, i + 1, j, cache);\\n            //Case3: replace\\n            int replace = match(c1, c2, i + 1, j + 1, cache);\\n            \\n            cache[i][j] = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return cache[i][j];\\n    }\\n    \\n    \\n    \\n    \\n    /**\\n     * Bottom-up approach\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] matched = new int[c1.length + 1][c2.length + 1];\\n        //matched[length of c1 already been matched][length of c2 already been matched]\\n        \\n        for (int i = 0; i <= c1.length; i++) {\\n            matched[i][0] = i;\\n        }\\n        for (int j = 0; j <= c2.length; j++) {\\n            matched[0][j] = j;\\n        }\\n        \\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                if (c1[i] == c2[j]) {\\n                    matched[i + 1][j + 1] = matched[i][j];\\n                } else {\\n                    matched[i + 1][j + 1] = Math.min(Math.min(matched[i][j + 1], matched[i + 1][j]), matched[i][j]) + 1;\\n                    //Since it is bottom up, we are considering in the ascending order of indexes.\\n                    //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n                    //above sequence is delete, insert and replace. \\n                }\\n            }\\n        }\\n        \\n        return matched[c1.length][c2.length];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Recursive solution.\\n     * For each poisition, check three subproblem:\\n     * 1. insert\\n     * 2. delete\\n     * 3. replace\\n     * We only modify the first string since no matter which one we choose, the result is the same. \\n     * Got TLE since we recursively solve the same subproblem several times.\\n     * Appromixately O(len1 ^ 3) time in the worst case.\\n     * Need to optimize it using cache, which is the idea of dynamic programming. \\n     * The key point is to find out the subproblem we have solved duplicately and cache the recursion.\\n     * Noticed that each subproblem is specificed by i and j pointer, so we can cache the result of these subproblems. \\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word1.length() == 0) return word2.length();\\n        if (word2 == null || word2.length() == 0) return word1.length();\\n        \\n        return match(word1, word2, 0, 0);\\n    }\\n    \\n    private int match(String s1, String s2, int i, int j) {\\n        //If one of the string's pointer have reached the end of it\\n        if (s1.length() == i) {\\n            return s2.length() - j;\\n        }\\n        if (s2.length() == j) {\\n            return s1.length() - i;\\n        }\\n        \\n        int res;\\n        //If current poisition is the same.\\n        if (s1.charAt(i) == s2.charAt(j)) {\\n            res = match(s1, s2, i + 1, j + 1);\\n        } else {\\n            //Case1: insert\\n            int insert = match(s1, s2, i, j + 1);\\n            //Case2: delete\\n            int delete = match(s1, s2, i + 1, j);\\n            //Case3: replace\\n            int replace = match(s1, s2, i + 1, j + 1);\\n            res = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return res;\\n    }\\n}  \\n```\n```\\npublic class Solution {\\n    /**\\n     * Optimization using dynamic programming\\n     * Top-down solution\\n     * O(len1 * len2) time, O(len1 * len2) space\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] cache = new int[c1.length][c2.length];\\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                cache[i][j] = -1;\\n            }\\n        }\\n        \\n        return match(c1, c2, 0, 0, cache);\\n    }\\n    \\n    private int match(char[] c1, char[] c2, int i, int j, int[][] cache) {\\n        if (c1.length == i) return c2.length - j;\\n        if (c2.length == j) return c1.length - i;\\n        \\n        if (cache[i][j] != -1) {\\n            return cache[i][j];\\n        }\\n        \\n        if (c1[i] == c2[j]) {\\n            cache[i][j] = match(c1, c2, i + 1, j + 1, cache);\\n        } else {\\n            //Case1: insert\\n            int insert = match(c1, c2, i, j + 1, cache);\\n            //Case2: delete\\n            int delete = match(c1, c2, i + 1, j, cache);\\n            //Case3: replace\\n            int replace = match(c1, c2, i + 1, j + 1, cache);\\n            \\n            cache[i][j] = Math.min(Math.min(insert, delete), replace) + 1;\\n        }\\n        \\n        return cache[i][j];\\n    }\\n    \\n    \\n    \\n    \\n    /**\\n     * Bottom-up approach\\n     */\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) return -1;\\n        if (word1.length() == 0) return word2.length();\\n        if (word2.length() == 0) return word1.length();\\n        \\n        char[] c1 = word1.toCharArray();\\n        char[] c2 = word2.toCharArray();\\n        \\n        int[][] matched = new int[c1.length + 1][c2.length + 1];\\n        //matched[length of c1 already been matched][length of c2 already been matched]\\n        \\n        for (int i = 0; i <= c1.length; i++) {\\n            matched[i][0] = i;\\n        }\\n        for (int j = 0; j <= c2.length; j++) {\\n            matched[0][j] = j;\\n        }\\n        \\n        for (int i = 0; i < c1.length; i++) {\\n            for (int j = 0; j < c2.length; j++) {\\n                if (c1[i] == c2[j]) {\\n                    matched[i + 1][j + 1] = matched[i][j];\\n                } else {\\n                    matched[i + 1][j + 1] = Math.min(Math.min(matched[i][j + 1], matched[i + 1][j]), matched[i][j]) + 1;\\n                    //Since it is bottom up, we are considering in the ascending order of indexes.\\n                    //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n                    //above sequence is delete, insert and replace. \\n                }\\n            }\\n        }\\n        \\n        return matched[c1.length][c2.length];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25849,
                "title": "java-dp-solution-o-nm",
                "content": "Let following be the function definition :-\\n\\nf(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2\\n\\nCase 1: word1[i] == word2[j], i.e. the ith the jth character matches.\\n\\n> f(i, j) = f(i - 1, j - 1)\\n\\nCase 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaper\\n\\n> f(i, j) = 1 + min { f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) }\\n\\n1. f(i, j - 1) represents insert operation\\n2. f(i - 1, j) represents delete operation\\n3. f(i - 1, j - 1) represents replace operation\\n\\nHere, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well.\\n\\nNote that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction.\\n\\nAbove equations become the recursive definitions for DP.\\n\\nBase Case: \\n\\n> f(0, k) = f(k, 0) = k\\n\\nBelow is the direct bottom-up translation of this recurrent relation. It is only important to take care of 0-based index with actual code :-\\n\\n    public class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int m = word1.length();\\n            int n = word2.length();\\n            \\n            int[][] cost = new int[m + 1][n + 1];\\n            for(int i = 0; i <= m; i++)\\n                cost[i][0] = i;\\n            for(int i = 1; i <= n; i++)\\n                cost[0][i] = i;\\n            \\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(word1.charAt(i) == word2.charAt(j))\\n                        cost[i + 1][j + 1] = cost[i][j];\\n                    else {\\n                        int a = cost[i][j];\\n                        int b = cost[i][j + 1];\\n                        int c = cost[i + 1][j];\\n                        cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);\\n                        cost[i + 1][j + 1]++;\\n                    }\\n                }\\n            }\\n            return cost[m][n];\\n        }\\n    }\\n\\nTime complexity : If n is the length of word1, m of word2, because of the two indented loops, it is O(nm)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int m = word1.length();\\n            int n = word2.length();\\n            \\n            int[][] cost = new int[m + 1][n + 1];\\n            for(int i = 0; i <= m; i++)\\n                cost[i][0] = i;\\n            for(int i = 1; i <= n; i++)\\n                cost[0][i] = i;\\n            \\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(word1.charAt(i) == word2.charAt(j))\\n                        cost[i + 1][j + 1] = cost[i][j];\\n                    else {\\n                        int a = cost[i][j];\\n                        int b = cost[i][j + 1];\\n                        int c = cost[i + 1][j];\\n                        cost[i + 1][j + 1] = a < b ? (a < c ? a : c) : (b < c ? b : c);\\n                        cost[i + 1][j + 1]++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3230662,
                "title": "clean-codes-full-explanation-dynamic-programming-c-java-python3",
                "content": "# Intuition :\\n- Here we have to find the minimum edit distance problem between two strings word1 and word2. \\n- The minimum edit distance is defined as the minimum number of operations required to transform one string into another.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- The approach here that I am using is dynamic programming. The idea is to build a 2D matrix dp where `dp[i][j] `represents the minimum number of operations required to transform the substring `word1[0...i-1]` into the substring `word2[0...j-1].`\\n# How is Matrix built :\\n- The matrix is built iteratively using the following recurrence relation:\\n1. If `word1[i-1] == word2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`. That is, no operation is required because the characters at positions `i-1` and `j-1` are already the same.\\n2. Otherwise, `dp[i][j]` is the minimum of the following three values:\\n- `dp[i-1][j-1] + 1`: replace the character at position `i-1` in `word1` with the character at position `j-1` in` word2`.\\n- `dp[i-1][j] + 1`: delete the character at position `i-1` in `word1.`\\n- `dp[i][j-1] + 1`: insert the character at position `j-1` in `word2` into `word1` at position `i`.\\n# The base cases are:\\n- `dp[i][0] = i`: transforming `word1[0...i-1]` into an empty string requires `i` deletions.\\n- `dp[0][j] = j`: transforming an empty string into `word2[0...j-1] `requires `j` insertions.\\n<!-- Describe your approach to solving the problem. -->\\n# Final Step :\\n- Finally, return `dp[m][n]`, which represents the minimum number of operations required to transform `word1 `into `word2`, where `m` is the length of `word1` and `n` is the length of `word2`.\\n\\n# Complexity\\n- Time complexity : O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```C++ []\\nclass Solution {\\n public:\\n  int minDistance(string word1, string word2) {\\n    const int m = word1.length();//first word length\\n    const int n = word2.length();//second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1[i - 1] == word2[j - 1])//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                             //replace       //delete        //insert\\n    return dp[m][n];\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int minDistance(String word1, String word2) {\\n    final int m = word1.length();//first word length\\n    final int n = word2.length();///second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    int[][] dp = new int[m + 1][n + 1];\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                      //replace               //delete        //insert\\n\\n    return dp[m][n];\\n  }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n  def minDistance(self, word1: str, word2: str) -> int:\\n    m = len(word1)\\n    n = len(word2)\\n    # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for i in range(1, m + 1):\\n      dp[i][0] = i\\n\\n    for j in range(1, n + 1):\\n      dp[0][j] = j\\n\\n    for i in range(1, m + 1):\\n      for j in range(1, n + 1):\\n        if word1[i - 1] == word2[j - 1]:\\n          dp[i][j] = dp[i - 1][j - 1]\\n        else:\\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n\\n    return dp[m][n]\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/399bb888-6ae6-4614-a338-fe33088c118d_1677378017.7506878.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int minDistance(string word1, string word2) {\\n    const int m = word1.length();//first word length\\n    const int n = word2.length();//second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1[i - 1] == word2[j - 1])//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                             //replace       //delete        //insert\\n    return dp[m][n];\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int minDistance(String word1, String word2) {\\n    final int m = word1.length();//first word length\\n    final int n = word2.length();///second word length\\n    // dp[i][j] := min # of operations to convert word1[0..i) to word2[0..j)\\n    int[][] dp = new int[m + 1][n + 1];\\n\\n    for (int i = 1; i <= m; ++i)\\n      dp[i][0] = i;\\n\\n    for (int j = 1; j <= n; ++j)\\n      dp[0][j] = j;\\n\\n    for (int i = 1; i <= m; ++i)\\n      for (int j = 1; j <= n; ++j)\\n        if (word1.charAt(i - 1) == word2.charAt(j - 1))//same characters\\n          dp[i][j] = dp[i - 1][j - 1];//no operation\\n        else\\n          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;                      //replace               //delete        //insert\\n\\n    return dp[m][n];\\n  }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n  def minDistance(self, word1: str, word2: str) -> int:\\n    m = len(word1)\\n    n = len(word2)\\n    # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n    for i in range(1, m + 1):\\n      dp[i][0] = i\\n\\n    for j in range(1, n + 1):\\n      dp[0][j] = j\\n\\n    for i in range(1, m + 1):\\n      for j in range(1, n + 1):\\n        if word1[i - 1] == word2[j - 1]:\\n          dp[i][j] = dp[i - 1][j - 1]\\n        else:\\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n\\n    return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25911,
                "title": "my-o-mn-time-and-o-n-space-solution-using-dp-with-explanation",
                "content": "Use f[i][j] to represent the shortest edit distance between word1[0,i) and word2[0, j). Then compare the last character of word1[0,i) and word2[0,j), which are c and d respectively (c == word1[i-1], d == word2[j-1]):\\n\\nif c == d, then : f[i][j] = f[i-1][j-1]\\n\\nOtherwise we can use three operations to convert word1 to word2:\\n\\n(a) if we replaced c with d: f[i][j] = f[i-1][j-1] + 1;\\n\\n(b) if we added d after c: f[i][j] = f[i][j-1] + 1;\\n\\n(c) if we deleted c: f[i][j] = f[i-1][j] + 1;\\n\\n\\nNote that f[i][j] only depends on f[i-1][j-1], f[i-1][j] and f[i][j-1], therefore we can reduce the space to O(n) by using only the (i-1)th array and previous updated element(f[i][j-1]). \\n\\n\\n\\n     int minDistance(string word1, string word2) {\\n        \\n            int l1 = word1.size();\\n            int l2 = word2.size();\\n        \\n            vector<int> f(l2+1, 0);\\n            for (int j = 1; j <= l2; ++j)\\n                f[j] = j;\\n        \\n            for (int i = 1; i <= l1; ++i)\\n            {\\n                int prev = i;\\n                for (int j = 1; j <= l2; ++j)\\n                {\\n                    int cur;\\n                    if (word1[i-1] == word2[j-1]) {\\n                        cur = f[j-1];\\n                    } else {\\n                        cur = min(min(f[j-1], prev), f[j]) + 1;\\n                    }\\n        \\n                    f[j-1] = prev;\\n                    prev = cur;\\n                }\\n                f[l2] = prev;\\n            }\\n            return f[l2];\\n        \\n        }  \\n\\n\\nActually at first glance I thought this question was similar to Word Ladder and I tried to solve it using BFS(pretty stupid huh?). But in fact, the main difference is that there's a strict restriction on the intermediate words in Word Ladder problem, while there's no restriction in this problem.  If we added some restriction on intermediate words for this question, I don't think this DP solution would still work.",
                "solutionTags": [],
                "code": "Use f[i][j] to represent the shortest edit distance between word1[0,i) and word2[0, j). Then compare the last character of word1[0,i) and word2[0,j), which are c and d respectively (c == word1[i-1], d == word2[j-1]):\\n\\nif c == d, then : f[i][j] = f[i-1][j-1]\\n\\nOtherwise we can use three operations to convert word1 to word2:\\n\\n(a) if we replaced c with d: f[i][j] = f[i-1][j-1] + 1;\\n\\n(b) if we added d after c: f[i][j] = f[i][j-1] + 1;\\n\\n(c) if we deleted c: f[i][j] = f[i-1][j] + 1;\\n\\n\\nNote that f[i][j] only depends on f[i-1][j-1], f[i-1][j] and f[i][j-1], therefore we can reduce the space to O(n) by using only the (i-1)th array and previous updated element(f[i][j-1]). \\n\\n\\n\\n     int minDistance(string word1, string word2) {\\n        \\n            int l1 = word1.size();\\n            int l2 = word2.size();\\n        \\n            vector<int> f(l2+1, 0);\\n            for (int j = 1; j <= l2; ++j)\\n                f[j] = j;\\n        \\n            for (int i = 1; i <= l1; ++i)\\n            {\\n                int prev = i;\\n                for (int j = 1; j <= l2; ++j)\\n                {\\n                    int cur;\\n                    if (word1[i-1] == word2[j-1]) {\\n                        cur = f[j-1];\\n                    } else {\\n                        cur = min(min(f[j-1], prev), f[j]) + 1;\\n                    }\\n        \\n                    f[j-1] = prev;\\n                    prev = cur;\\n                }\\n                f[l2] = prev;\\n            }\\n            return f[l2];\\n        \\n        }  \\n\\n\\nActually at first glance I thought this question was similar to Word Ladder and I tried to solve it using BFS(pretty stupid huh?). But in fact, the main difference is that there's a strict restriction on the intermediate words in Word Ladder problem, while there's no restriction in this problem.  If we added some restriction on intermediate words for this question, I don't think this DP solution would still work.",
                "codeTag": "Unknown"
            },
            {
                "id": 662240,
                "title": "c-easy-dp-solution-well-commented",
                "content": "```\\nint minDistance(string word1, string word2) {\\n// Create a table to store results of subproblems\\n        int dp[word1.size()+1][word2.size()+1];\\n// If first string is empty, only option is to \\n// insert all characters of second string \\n        for(int k=0; k<=word1.size(); k++)\\n            dp[k][0] = k;\\n// If second string is empty, only option is to \\n// remove all characters of first string\\n        for(int k=0; k<=word2.size(); k++)\\n            dp[0][k] = k;\\n// Fill dp[][] in bottom up manner \\n        for(int i=1; i<=word1.size(); i++){\\n            for(int j=1; j<=word2.size(); j++){\\n//if characters at current position in 2 strings are equal\\n//there will be no new operation so copy value from previous position\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n// If the last character is different, consider all \\n// possibilities and find the minimum\\n                else\\n                    dp[i][j] = 1 + min({dp[i][j - 1], // Insert \\n                                   dp[i - 1][j], // Remove \\n                                   dp[i - 1][j - 1]}); // Replace \\n            }\\n        }\\n        \\n        return dp[word1.size()][word2.size()];\\n    }\\n```\\n**Upvotes are encouraging**",
                "solutionTags": [],
                "code": "```\\nint minDistance(string word1, string word2) {\\n// Create a table to store results of subproblems\\n        int dp[word1.size()+1][word2.size()+1];\\n// If first string is empty, only option is to \\n// insert all characters of second string \\n        for(int k=0; k<=word1.size(); k++)\\n            dp[k][0] = k;\\n// If second string is empty, only option is to \\n// remove all characters of first string\\n        for(int k=0; k<=word2.size(); k++)\\n            dp[0][k] = k;\\n// Fill dp[][] in bottom up manner \\n        for(int i=1; i<=word1.size(); i++){\\n            for(int j=1; j<=word2.size(); j++){\\n//if characters at current position in 2 strings are equal\\n//there will be no new operation so copy value from previous position\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n// If the last character is different, consider all \\n// possibilities and find the minimum\\n                else\\n                    dp[i][j] = 1 + min({dp[i][j - 1], // Insert \\n                                   dp[i - 1][j], // Remove \\n                                   dp[i - 1][j - 1]}); // Replace \\n            }\\n        }\\n        \\n        return dp[word1.size()][word2.size()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1217663,
                "title": "edit-distance-cpp-recursive-memoization-top-down-all-approaches-with-explanation",
                "content": "\\nThis problem is little bit tricky but don\\'t worry we will solve it together.\\nBasically, after reading the question carefully we can see that **we have two choices, either the character will be same or not same**.\\n\\n* So, In the first choice, if the character will be same we don\\'t have to do anything except for the fact that we have to call the function for the rest of the string.\\n\\n* For the second choice, if the character will not be the same we have three operations to do inorder to convert the word1 to word2\\n\\t1. Insert a character\\n\\t2. Delete a character\\n\\t3. Replace a character\\n\\nNow, Let\\'s talk about the operations that we have to perform on word1, I\\'m trying from the right side you can try from left also, depends on you.\\n\\n* So, for **Insert operation**, say for ex - we have two strings\\n`s1 = \"abc\" , s2 = \"bcd\" , m = 3 , n = 3` **i.e.** \\nlengths of the strings respectively `m` and `n` are pointing to the last characters of the string. So we will insert a character  from right side in `s1` and after inserting character string will be `\"abcd\"` and the `m` which  was pointing to `c` in `s1` will be at the same position but the `n` which was pointing to `d` in `s2` now, will point to `c` in `s2` i.e. `m, n-1` for the rest of the function calls.\\n\\n* Now, for **Delete operation**, same example\\n`s1 = \"abc\", s2=\"bcd\", m=3, n=3`\\n`m` and `n` are pointing to the last characters of the string. Now, after deleting a character from `s1` , the `m` will be `m-1` , but the `n`  will be same i.e. `m-1, n`  for the rest of the function calls.\\n\\n* Now, for the **Replace operation**, same example\\n`s1 = \"abc\", s2=\"bcd\", m=3, n=3`\\n`m` and `n` are pointing to the last characters of the string. Ultimately, the character at corresponding positions in strings will be the same after replacing the character in `s1` by\\nthe character in `s2`, \\n**Example** - `\"abc\", \"bcd\"` => replacing c by d => `\"abd\", \"bcd\"`\\nNow, call for the rest of the string, so here `m` will be `m-1` and `n` will be `n-1` , i.e. `m-1, n-1` for the rest of the function calls.\\n\\nNow, we have to take minimum of all the three operations and add to 1\\n\\n* And Let\\'s talk about **base conditions**\\n**Example** - `s1 = \"abc\", s2 = \"bcd\", m=3, n=3`  lengths of strings respectively\\n1. if `m = 0` , then Obviously, we have to insert `n`  characters from `s2`  in `s1`  to make `s2`. \\n2. if `n = 0` , then Obviously, we have to delete `m`  characters in `s1`  to make `s2`.\\n\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(min(3^m, 3^n)), Space: O(N);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        return editDistance(word1, word2, m, n);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n){\\n\\t\\t\\n\\t\\t//base condition\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        \\n        if(word1[m-1] == word2[n-1]) \\n\\t\\t\\treturn editDistance(word1, word2, m-1, n-1);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1);\\n            int deleteChar = editDistance(word1, word2, m-1, n);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1);\\n            \\n            return 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\\n\\n**Recursive + Memoization - TopDown**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\\n        return editDistance(word1, word2, m, n, memo);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n, vector<vector<int>>& memo){\\n        if(m == 0) return memo[m][n] = n;\\n        if(n == 0) return memo[m][n] = m;\\n        \\n        if(memo[m][n] != -1)\\n            return memo[m][n];\\n        \\n        if(word1[m-1] == word2[n-1]) \\n            return memo[m][n] = editDistance(word1, word2, m-1, n-1, memo);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1, memo);\\n            int deleteChar = editDistance(word1, word2, m-1, n, memo);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1, memo);\\n            \\n            return memo[m][n] = 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\\n\\n**BottomUp**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        //Base conditions\\n        for(int i=0; i<m+1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j=0; j<n+1; j++)\\n            dp[0][j] = j;\\n        \\n        //solving the sub-problems\\n        for(int i=1; i<m+1; i++){\\n            for(int j=1; j<n+1; j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insertChar = dp[i][j-1];\\n                    int deleteChar = dp[i-1][j];\\n                    int replaceChar = dp[i-1][j-1];\\n                    \\n                    dp[i][j] = 1 + min({insertChar, deleteChar, replaceChar});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(min(3^m, 3^n)), Space: O(N);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        return editDistance(word1, word2, m, n);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n){\\n\\t\\t\\n\\t\\t//base condition\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        \\n        if(word1[m-1] == word2[n-1]) \\n\\t\\t\\treturn editDistance(word1, word2, m-1, n-1);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1);\\n            int deleteChar = editDistance(word1, word2, m-1, n);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1);\\n            \\n            return 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> memo(m+1, vector<int>(n+1, -1));\\n        return editDistance(word1, word2, m, n, memo);\\n    }\\n    \\n    int editDistance(string& word1, string& word2, int m, int n, vector<vector<int>>& memo){\\n        if(m == 0) return memo[m][n] = n;\\n        if(n == 0) return memo[m][n] = m;\\n        \\n        if(memo[m][n] != -1)\\n            return memo[m][n];\\n        \\n        if(word1[m-1] == word2[n-1]) \\n            return memo[m][n] = editDistance(word1, word2, m-1, n-1, memo);\\n        else{\\n            int insertChar = editDistance(word1, word2, m, n-1, memo);\\n            int deleteChar = editDistance(word1, word2, m-1, n, memo);\\n            int replaceChar = editDistance(word1, word2, m-1, n-1, memo);\\n            \\n            return memo[m][n] = 1 + min({insertChar, deleteChar, replaceChar});\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(m*n), Space: O(m*n);\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length(), n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        //Base conditions\\n        for(int i=0; i<m+1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j=0; j<n+1; j++)\\n            dp[0][j] = j;\\n        \\n        //solving the sub-problems\\n        for(int i=1; i<m+1; i++){\\n            for(int j=1; j<n+1; j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insertChar = dp[i][j-1];\\n                    int deleteChar = dp[i-1][j];\\n                    int replaceChar = dp[i-1][j-1];\\n                    \\n                    dp[i][j] = 1 + min({insertChar, deleteChar, replaceChar});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475220,
                "title": "python-3-solutions-top-down-dp-bottom-up-dp-o-n-in-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP**\\n- Let `dp(i, j)` is the minimum number of operations required to convert `s1[0..i-1]` string to `s2[0..j-1]` string.\\n- Then `dp(len(s1), len(s2))` is our result.\\n- To compute `dp(i, j)`:\\n\\t- Base case: \\n\\t\\t- If `i == 0` then we need to insert `j` chars to convert `\"\"` into `s2[0..j-1]`\\n\\t\\t- If `j == 0` then we need to delete `i` chars to convert `s1[0..i-1]` into `\"\"`.\\n\\t- If `s1[i-1] == s2[j-1]` then `dp(i, j) = dp(i-1, j-1)`.\\n\\t- Else: Choose the minimum cost among 3 operators\\n\\t\\t- Delete: `dp(i-1, j) + 1`\\n\\t\\t- Insert: `dp(i, j-1) + 1`\\n\\t\\t- Replace: `dp(i-1, j-1) + 1`\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0: return j  # Need to insert j chars\\n            if j == 0: return i  # Need to delete i chars\\n            if s1[i-1] == s2[j-1]:\\n                return dp(i-1, j-1)\\n            return min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1\\n        \\n        return dp(len(s1), len(s2))\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Just convert **Top down DP** into **Bottom up DP**.\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[-1] * (n+1) for _ in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[i][j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[i][j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[m][n]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(M*N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom up DP (Space Optimized)**\\n- Since we build our dp rows by rows, we access only previous dp state `dpPrev` and current dp state `dp`.\\n- So we can optimize to `O(N)` in Space Complexity.\\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [-1] * (n+1), [-1] * (n+1)\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[j] = dpPrev[j-1]\\n                else:\\n                    dp[j] = min(dpPrev[j], dp[j-1], dpPrev[j-1]) + 1\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n]\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 500` is length of `s1` string, `N <= 500` is length of `s2` string.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i == 0: return j  # Need to insert j chars\\n            if j == 0: return i  # Need to delete i chars\\n            if s1[i-1] == s2[j-1]:\\n                return dp(i-1, j-1)\\n            return min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1\\n        \\n        return dp(len(s1), len(s2))\\n```\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp = [[-1] * (n+1) for _ in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[i][j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[i][j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[m][n]\\n```\n```python\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n        m, n = len(s1), len(s2)\\n        dp, dpPrev = [-1] * (n+1), [-1] * (n+1)\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i == 0:\\n                    dp[j] = j  # Need to insert `j` chars to become s2[:j]\\n                elif j == 0:\\n                    dp[j] = i  # Need to delete `i` chars to become \"\"\\n                elif s1[i-1] == s2[j-1]:\\n                    dp[j] = dpPrev[j-1]\\n                else:\\n                    dp[j] = min(dpPrev[j], dp[j-1], dpPrev[j-1]) + 1\\n            dp, dpPrev = dpPrev, dp\\n        return dpPrev[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501094,
                "title": "c-recursive-memoization-and-tabulation-method",
                "content": "Recursive \\n```\\nclass Solution {\\npublic:\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(word1[n1-1] == word2[n2-1]) {\\n            return editDis(word1, word2, n1-1, n2-1);\\n        }\\n            \\n        return 1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        return editDis(word1, word2, n1, n2);\\n        \\n    }\\n};\\n```\\nMemoization:\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(dp[n1][n2] !=-1)\\n        {\\n            return dp[n1][n2];\\n        }\\n        if(word1[n1-1] == word2[n2-1]) {\\n            dp[n1][n2] = editDis(word1, word2, n1-1, n2-1);\\n            return dp[n1][n2];\\n        }\\n            \\n        dp[n1][n2]=  1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n        return dp[n1][n2];\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        for(int i=0;i<=n1+1;i++)\\n        {\\n            for(int j=0;j<=n2+1;j++)\\n            {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        dp[n1][n2] = editDis(word1, word2, n1, n2);\\n        return dp[n1][n2];\\n        \\n    }\\n};\\n```\\n\\nTabulation\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        int dp[n1+2][n2+2];\\n        \\n        for(int i=0;i<n1+1;i++)\\n        {\\n             dp[i][0] = i;\\n        }\\n        \\n        for(int i=0;i<n2+1;i++)\\n        {\\n             dp[0][i] = i;\\n        }\\n        \\n        for(int i=1;i<n1+1;i++)\\n        {\\n            for(int j=1;j<n2+1;j++)\\n            {\\n                if(word1[i-1] == word2[j-1])\\n                {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                  dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1], dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(word1[n1-1] == word2[n2-1]) {\\n            return editDis(word1, word2, n1-1, n2-1);\\n        }\\n            \\n        return 1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        return editDis(word1, word2, n1, n2);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int editDis(string& word1, string& word2, int n1, int n2)\\n    {\\n        if(n1 == 0)\\n            return n2;\\n        if(n2 == 0)\\n            return n1;\\n       // cout<<n1<<\" \"<<n2<<endl;\\n        if(dp[n1][n2] !=-1)\\n        {\\n            return dp[n1][n2];\\n        }\\n        if(word1[n1-1] == word2[n2-1]) {\\n            dp[n1][n2] = editDis(word1, word2, n1-1, n2-1);\\n            return dp[n1][n2];\\n        }\\n            \\n        dp[n1][n2]=  1+min(editDis(word1, word2, n1, n2-1),\\n                  min(editDis(word1, word2, n1-1, n2),\\n                  editDis(word1, word2, n1-1, n2-1)));\\n        return dp[n1][n2];\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        for(int i=0;i<=n1+1;i++)\\n        {\\n            for(int j=0;j<=n2+1;j++)\\n            {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        dp[n1][n2] = editDis(word1, word2, n1, n2);\\n        return dp[n1][n2];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size();\\n        int dp[n1+2][n2+2];\\n        \\n        for(int i=0;i<n1+1;i++)\\n        {\\n             dp[i][0] = i;\\n        }\\n        \\n        for(int i=0;i<n2+1;i++)\\n        {\\n             dp[0][i] = i;\\n        }\\n        \\n        for(int i=1;i<n1+1;i++)\\n        {\\n            for(int j=1;j<n2+1;j++)\\n            {\\n                if(word1[i-1] == word2[j-1])\\n                {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                  dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1], dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 274951,
                "title": "python-classic-dp",
                "content": "Suppose ```dp[i][j]``` records the edit distance between ```word1[:i]``` and ```word2[:j]```. And now we proceed to ```word1[i]``` and ```word2[j]```. \\n1. If they are equal, then edit distance between ```word1[:i+1]``` and  ```word2[:j+1]``` are the same as ```dp[i][j]```. Or ```dp[i+1][j+1] = dp[i][j]```.\\n2. Otherwise, we need to determine which of \"delete\", \"insert\", \"replace\" produces the lowest edit distance. Since each operation cost 1 distance, \"delete\"\\'s cost is 1 extra distance plus edit distance between ```word1[:i]``` and ```word2[:j+1]``` as we delete ```word1[i]```. Or ```dp[i+1][j+1] = dp[i][j+1]+1```. Similiarly, \"insert\" produces ```dp[i+1][j+1] = dp[i+1][j]+1``` and \"replace\" produces ```dp[i+1][j+1] = dp[i][j]+1```. And we just pick the minimum from these three.\\n\\nThus, our recurrsion equation is \\n```\\ndp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n```\\nOne head row and left column are inserted in dp array for base. We can viewed it as each word has an empty string at the begining and empty string is not equal to any character. So initially, ```dp[0][j] = j``` and ```dp[i][0] = i```\\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)\\n\\tdp = [list(range(n+1))]+[[r+1]+[0]*n for r in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n\\treturn dp[m][n]\\n```\\nBoth time and space complexity is O(mn). m, n stands for length of word1 and word2.\\nAnd we can implement a rolling1D DP since only two rows of DP table are actually used. So space complexity could be reduced to O(min(m,n)):\\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)  # switch word1 and word2 if m < n to ensure n \\u2264 m\\n\\tcurr = list(range(n+1))\\n\\tfor i in range(m):\\n\\t\\tprev, curr = curr, [i+1] + [0] * n\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcurr[j+1] = prev[j] if word1[i] == word2[j] else min(curr[j], prev[j], prev[j+1]) + 1\\n\\treturn curr[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[i][j]```\n```word1[:i]```\n```word2[:j]```\n```word1[i]```\n```word2[j]```\n```word1[:i+1]```\n```word2[:j+1]```\n```dp[i][j]```\n```dp[i+1][j+1] = dp[i][j]```\n```word1[:i]```\n```word2[:j+1]```\n```word1[i]```\n```dp[i+1][j+1] = dp[i][j+1]+1```\n```dp[i+1][j+1] = dp[i+1][j]+1```\n```dp[i+1][j+1] = dp[i][j]+1```\n```\\ndp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n```\n```dp[0][j] = j```\n```dp[i][0] = i```\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)\\n\\tdp = [list(range(n+1))]+[[r+1]+[0]*n for r in range(m)]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tdp[i+1][j+1] = dp[i][j] if word1[i]==word2[j] else min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1\\n\\treturn dp[m][n]\\n```\n```\\ndef minDistance(word1, word2):\\n\\tm, n = len(word1), len(word2)  # switch word1 and word2 if m < n to ensure n \\u2264 m\\n\\tcurr = list(range(n+1))\\n\\tfor i in range(m):\\n\\t\\tprev, curr = curr, [i+1] + [0] * n\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcurr[j+1] = prev[j] if word1[i] == word2[j] else min(curr[j], prev[j], prev[j+1]) + 1\\n\\treturn curr[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25959,
                "title": "my-accepted-java-solution",
                "content": "Hi: \\n\\nThis is a very interesting question and I found a [youtube video][1] that helps a lot.\\nBasically the idea is to build up the solution step by step and keep track of the previous optimal solution in a 2D array. In this 2D array dp, dp[i][j] means the operation needed to transform word1(0, i) to word2(0,j). \\n\\nThere can be three conditions:\\n\\n1, word1[i] == word2[j] : then no operation needed. dp[i][j] == dp[i-1][j-1]\\n\\n2, Do one operation on word1[i-1][j]. dp[i][j] = dp[i-1][j] + 1\\n\\n3, Do one operation on word2[i][j-1]. dp[i][j] = dp[i][j-1] + 1\\n\\nfor 2 and 3, the reason it works is that we know the optimal ways to transfrom word1(0,i) to word2(0,j-1) and word1(0,i-1) to word(0,j) ( Delete (\"abc\" to \"ab\") or Insert (\"ab\" to \"abc\") ). Now all we need to one more operation.\\n\\nThe code will be:\\n\\n    public int minDistance(String word1, String word2) {\\n        if (word1.equals(word2)) {\\n            return 0;\\n        }\\n        if (word1.length() == 0 || word2.length() == 0) {\\n            return Math.abs(word1.length() - word2.length());\\n        }\\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int i = 0; i <= word2.length(); i++) {\\n            dp[0][i] = i;\\n        }\\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return dp[word1.length()][word2.length()];\\n    }\\n\\n Remeber that we start from dp[0][0], which is an empty string to an empty string. \\n\\n\\n  [1]: https://www.youtube.com/watch?v=z_CB7Gih_Mg",
                "solutionTags": [],
                "code": "Hi: \\n\\nThis is a very interesting question and I found a [youtube video][1] that helps a lot.\\nBasically the idea is to build up the solution step by step and keep track of the previous optimal solution in a 2D array. In this 2D array dp, dp[i][j] means the operation needed to transform word1(0, i) to word2(0,j). \\n\\nThere can be three conditions:\\n\\n1, word1[i] == word2[j] : then no operation needed. dp[i][j] == dp[i-1][j-1]\\n\\n2, Do one operation on word1[i-1][j]. dp[i][j] = dp[i-1][j] + 1\\n\\n3, Do one operation on word2[i][j-1]. dp[i][j] = dp[i][j-1] + 1\\n\\nfor 2 and 3, the reason it works is that we know the optimal ways to transfrom word1(0,i) to word2(0,j-1) and word1(0,i-1) to word(0,j) ( Delete (\"abc\" to \"ab\") or Insert (\"ab\" to \"abc\") ). Now all we need to one more operation.\\n\\nThe code will be:\\n\\n    public int minDistance(String word1, String word2) {\\n        if (word1.equals(word2)) {\\n            return 0;\\n        }\\n        if (word1.length() == 0 || word2.length() == 0) {\\n            return Math.abs(word1.length() - word2.length());\\n        }\\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        for (int i = 0; i <= word2.length(); i++) {\\n            dp[0][i] = i;\\n        }\\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return dp[word1.length()][word2.length()];\\n    }\\n\\n Remeber that we start from dp[0][0], which is an empty string to an empty string. \\n\\n\\n  [1]: https://www.youtube.com/watch?v=z_CB7Gih_Mg",
                "codeTag": "Unknown"
            },
            {
                "id": 1596206,
                "title": "java-dp-detailed-explanation-easy-to-understand",
                "content": "### Explanation:\\n\\n![image](https://assets.leetcode.com/users/images/70ee0a89-9a54-44b2-8106-70ef5054f543_1637868770.0880988.jpeg)\\n![image](https://assets.leetcode.com/users/images/89dc90b2-7c8e-4aee-82c8-b4988e78ed06_1637868770.3484263.jpeg)\\n![image](https://assets.leetcode.com/users/images/676e42a2-e7bd-4df2-9010-524be2f91a36_1637868769.804625.jpeg)\\n\\n<br/>\\n\\n### Code:\\n\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25951,
                "title": "standard-dp-solution",
                "content": "    int minDistance(string word1, string word2) {\\n        int  m = word1.length(), n = word2.length();\\n        if (m == 0) return n;\\n        if (n == 0) return m;\\n        \\n        // table[i][j]: distance from words1.substr(0, i) to words2.substr(0, j) \\n        int table[m+1][n+1];\\n        for (int i = 0; i <= m; ++i) table[i][0] = i;\\n        for (int j = 0; j <= n; ++j) table[0][j] = j;\\n        // table[i][j] is the min distance between the next three values\\n        // from table[i-1][j], table[i][j-1], or table[i-1][j-1] to table[i][j]\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                int cost = (word1[i-1] == word2[j-1] ? 0 : 1);\\n                table[i][j] = min(min(table[i-1][j] + 1, table[i][j-1] + 1), table[i-1][j-1] + cost);\\n            }\\n        }\\n        \\n        return table[m][n];\\n    }",
                "solutionTags": [],
                "code": "    int minDistance(string word1, string word2) {\\n        int  m = word1.length(), n = word2.length();\\n        if (m == 0) return n;\\n        if (n == 0) return m;\\n        \\n        // table[i][j]: distance from words1.substr(0, i) to words2.substr(0, j) \\n        int table[m+1][n+1];\\n        for (int i = 0; i <= m; ++i) table[i][0] = i;\\n        for (int j = 0; j <= n; ++j) table[0][j] = j;\\n        // table[i][j] is the min distance between the next three values\\n        // from table[i-1][j], table[i][j-1], or table[i-1][j-1] to table[i][j]\\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                int cost = (word1[i-1] == word2[j-1] ? 0 : 1);\\n                table[i][j] = min(min(table[i-1][j] + 1, table[i][j-1] + 1), table[i-1][j-1] + cost);\\n            }\\n        }\\n        \\n        return table[m][n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25896,
                "title": "easy-to-understand-recursive-dp-solution-beats-99-6",
                "content": "```\\npublic class Solution {\\n    int[][] dp;\\n    \\n    public int minDistance(String word1, String word2) {\\n\\tdp = new int[word1.length()][word2.length()];\\n\\t    \\n        return minDistanceHelper(word1, word2, 0, 0);\\n    }\\n    \\n    private int minDistanceHelper(String word1, String word2, int index1, int index2) {\\n        if (index1 == word1.length()) return word2.length() - index2;\\n        if (index2 == word2.length()) return word1.length() - index1;\\n\\t    \\n\\tif (dp[index1][index2] > 0) return dp[index1][index2];\\n        \\n        int result;\\n        if (word1.charAt(index1) == word2.charAt(index2)) {\\n            result = minDistanceHelper(word1, word2, index1+1, index2+1);\\n        } else {\\n            // replace char\\n            result = 1 + minDistanceHelper(word1, word2, index1+1, index2+1);\\n            \\n            // delete char from word1\\n            result = Math.min(result, 1 + minDistanceHelper(word1, word2, index1+1, index2));\\n            \\n            // delete char from word2\\n            result = Math.min(result, 1 + minDistanceHelper(word1, word2, index1, index2+1));\\n        }\\n        \\n\\tdp[index1][index2] = result;\\n\\treturn result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int[][] dp;\\n    \\n    public int minDistance(String word1, String word2) {\\n\\tdp = new int[word1.length()][word2.length()];\\n\\t    \\n        return minDistanceHelper(word1, word2, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2992667,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int solve(int i, int j, string &s, string &t){\\n        if(i<0 && j<0)\\n            return 0;\\n        \\n        if(i < 0 && j>=0){\\n            return j+1;\\n        }\\n        \\n        if(i>=0 && j<0){\\n            return i+1;\\n        }\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int l = 1000, r = 1000, z = 1000, p = 1000;\\n        if(s[i] == t[j]){\\n            l = solve(i-1,j-1,s,t);\\n        }\\n        else{\\n            r = 1 + solve(i-1,j,s,t);\\n            z = 1 + solve(i-1,j-1,s,t);\\n            p = 1 + solve(i,j-1,s,t);\\n        }\\n        \\n        return dp[i][j] = min(l,min(r,min(z,p)));\\n    }\\n    \\n    \\n    int minDistance(string s, string t) {\\n        dp.resize(s.size()+1,vector<int>(t.size()+1,-1));\\n        return solve(s.size(),t.size(),s,t);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        to_visit = [(0, 0)]\\n        visited = set()\\n        dist = 0\\n        while to_visit:\\n            nxt_lvl = []\\n            while to_visit:\\n                i, j = to_visit.pop()\\n                if (i, j) in visited:\\n                    continue\\n                while i < n and j < m and word1[i] == word2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == n and j == m:\\n                    return dist\\n                if (i, j + 1) not in visited:\\n                    nxt_lvl.append((i, j + 1))\\n                if (i + 1, j) not in visited:\\n                    nxt_lvl.append((i + 1, j))\\n                if (i + 1, j + 1) not in visited:\\n                    nxt_lvl.append((i + 1, j + 1))\\n                visited.add((i, j))\\n            dist += 1\\n            to_visit = nxt_lvl\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1.length() < word2.length()) {\\n            return minDistance(word2, word1);\\n        }\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[] dp = new int[w2.length];\\n        int last = 0;\\n        int diag = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = dp.length - i;\\n        }\\n        for (int i = w1.length - 1; i > -1; i--) {\\n            last = w1.length - i;\\n            diag = w1.length - 1 - i;\\n            for (int j = w2.length - 1; j > -1; j--) {\\n                int tmp = dp[j];\\n                if (w1[i] == w2[j]) {\\n                    last = dp[j] = diag;\\n                } else {\\n                    last = dp[j] = Math.min(diag, Math.min(dp[j], last)) + 1;\\n                }\\n                diag = tmp;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    \\n    int solve(int i, int j, string &s, string &t){\\n        if(i<0 && j<0)\\n            return 0;\\n        \\n        if(i < 0 && j>=0){\\n            return j+1;\\n        }\\n        \\n        if(i>=0 && j<0){\\n            return i+1;\\n        }\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int l = 1000, r = 1000, z = 1000, p = 1000;\\n        if(s[i] == t[j]){\\n            l = solve(i-1,j-1,s,t);\\n        }\\n        else{\\n            r = 1 + solve(i-1,j,s,t);\\n            z = 1 + solve(i-1,j-1,s,t);\\n            p = 1 + solve(i,j-1,s,t);\\n        }\\n        \\n        return dp[i][j] = min(l,min(r,min(z,p)));\\n    }\\n    \\n    \\n    int minDistance(string s, string t) {\\n        dp.resize(s.size()+1,vector<int>(t.size()+1,-1));\\n        return solve(s.size(),t.size(),s,t);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        to_visit = [(0, 0)]\\n        visited = set()\\n        dist = 0\\n        while to_visit:\\n            nxt_lvl = []\\n            while to_visit:\\n                i, j = to_visit.pop()\\n                if (i, j) in visited:\\n                    continue\\n                while i < n and j < m and word1[i] == word2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == n and j == m:\\n                    return dist\\n                if (i, j + 1) not in visited:\\n                    nxt_lvl.append((i, j + 1))\\n                if (i + 1, j) not in visited:\\n                    nxt_lvl.append((i + 1, j))\\n                if (i + 1, j + 1) not in visited:\\n                    nxt_lvl.append((i + 1, j + 1))\\n                visited.add((i, j))\\n            dist += 1\\n            to_visit = nxt_lvl\\n```\n```Java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1.length() < word2.length()) {\\n            return minDistance(word2, word1);\\n        }\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[] dp = new int[w2.length];\\n        int last = 0;\\n        int diag = 0;\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = dp.length - i;\\n        }\\n        for (int i = w1.length - 1; i > -1; i--) {\\n            last = w1.length - i;\\n            diag = w1.length - 1 - i;\\n            for (int j = w2.length - 1; j > -1; j--) {\\n                int tmp = dp[j];\\n                if (w1[i] == w2[j]) {\\n                    last = dp[j] = diag;\\n                } else {\\n                    last = dp[j] = Math.min(diag, Math.min(dp[j], last)) + 1;\\n                }\\n                diag = tmp;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25879,
                "title": "python-easy-to-understand-dp-solutions-o-m-n-o-n-space",
                "content": "```\\nclass Solution(object):\\n    # O(n) space\\n    def minDistance(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        pre = [i for i in range(w)]\\n        for i in range(1, h):\\n            cur = [i for _ in range(w)]\\n            for j in range(1, w):\\n                cur[j] = min(pre[j-1]+(word1[i-1] != word2[j-1]), pre[j]+1, cur[j-1]+1)\\n            pre = cur\\n        return pre[-1]\\n    \\n    # O(m*n) space\\n    def minDistance1(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        dp = [[0 for _ in range(w)] for _ in range(h)]\\n        for i in range(h):\\n            dp[i][0] = i\\n        for j in range(w):\\n            dp[0][j] = j\\n        for i in range(1, h):\\n            for j in range(1, w):\\n                dp[i][j] = min(dp[i-1][j-1]+(word1[i-1]!=word2[j-1]), dp[i-1][j]+1, dp[i][j-1]+1)\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    # O(n) space\\n    def minDistance(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        pre = [i for i in range(w)]\\n        for i in range(1, h):\\n            cur = [i for _ in range(w)]\\n            for j in range(1, w):\\n                cur[j] = min(pre[j-1]+(word1[i-1] != word2[j-1]), pre[j]+1, cur[j-1]+1)\\n            pre = cur\\n        return pre[-1]\\n    \\n    # O(m*n) space\\n    def minDistance1(self, word1, word2):\\n        h, w = len(word1)+1, len(word2)+1\\n        dp = [[0 for _ in range(w)] for _ in range(h)]\\n        for i in range(h):\\n            dp[i][0] = i\\n        for j in range(w):\\n            dp[0][j] = j\\n        for i in range(1, h):\\n            for j in range(1, w):\\n                dp[i][j] = min(dp[i-1][j-1]+(word1[i-1]!=word2[j-1]), dp[i-1][j]+1, dp[i][j-1]+1)\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25914,
                "title": "concise-java-dp-solution-with-comments",
                "content": "    public int minDistance(String word1, String word2) {\\n    \\t// dp[i][j] : minimum steps to convert i long word1 and j long word2\\n    \\tint dp[][] = new int[word1.length() + 1][word2.length() + 1];\\n    \\n    \\tfor (int i = 0; i <= word1.length(); i++) dp[i][0] = i;    \\t\\n    \\tfor (int j = 0; j <= word2.length(); j++) dp[0][j] = j; \\n    \\t \\n    \\tfor (int i = 1;i <= word1.length(); i++) {\\n    \\t\\tfor (int j = 1; j<= word2.length(); j++) {\\n    \\t\\t\\tif (word1.charAt(i-1) == word2.charAt(j-1))// <--\\n    \\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n    \\t\\t\\telse \\n                    // dp[i-1][j-1] : replace word1(i) with word2(j), because word1(0, i-1) == word2(0, j-1);\\n                    // dp[i  ][j-1] : delete word(j)\\n                    // dp[i-1][j  ] : delete word(i), because word1(0, i-1) == word2(0, j)\\n    \\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1; \\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[word1.length()][word2.length()];\\n    }",
                "solutionTags": [],
                "code": "    public int minDistance(String word1, String word2) {\\n    \\t// dp[i][j] : minimum steps to convert i long word1 and j long word2\\n    \\tint dp[][] = new int[word1.length() + 1][word2.length() + 1];\\n    \\n    \\tfor (int i = 0; i <= word1.length(); i++) dp[i][0] = i;    \\t\\n    \\tfor (int j = 0; j <= word2.length(); j++) dp[0][j] = j; \\n    \\t \\n    \\tfor (int i = 1;i <= word1.length(); i++) {\\n    \\t\\tfor (int j = 1; j<= word2.length(); j++) {\\n    \\t\\t\\tif (word1.charAt(i-1) == word2.charAt(j-1))// <--\\n    \\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n    \\t\\t\\telse \\n                    // dp[i-1][j-1] : replace word1(i) with word2(j), because word1(0, i-1) == word2(0, j-1);\\n                    // dp[i  ][j-1] : delete word(j)\\n                    // dp[i-1][j  ] : delete word(i), because word1(0, i-1) == word2(0, j)\\n    \\t\\t\\t\\tdp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1; \\n    \\t\\t}\\n    \\t}\\n    \\treturn dp[word1.length()][word2.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3230707,
                "title": "memoization-tabulation-space-optimization-dp-c-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\n    In this question we have to find the **Minimum Operations** to convert `word1` to `word2`.\\n    So, what are the posibilities : \\n        If both letters are equal then simply decrease index\\n        Otherwise there are three posibilities:\\n            We can `Insert` a letter\\n            We can `Delete` a letter\\n            We can `Replace` a letter\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Space Optimization**\\n```\\nclass Solution {\\npublic:\\n    // Space Optimization - TC: O(n * m), SC: O(m)\\n    int minDistance(string word1, string word2) {\\n    int n = word1.size(), m = word2.size();\\n    // We make dp array 1 indexed\\n    // Initialize two vectors to store the values of the previous and current rows of the dp array\\n    vector<int> prev(m+1, 0), curr(m+1, 0);\\n    // Initialize the first row of the dp array to the numbers 0, 1, 2, ..., m\\n    for(int j=0;j<=m;j++) prev[j] = j;\\n    // Iterate through each row of the dp array\\n    for(int i=1;i<=n;i++){\\n        // Set the first element of the current row to i\\n        curr[0] = i;\\n        // Iterate through each column of the dp array\\n        for(int j=1;j<=m;j++){\\n            // If the two characters are equal, no operation is needed\\n            if(word1[i-1] == word2[j-1])\\n                curr[j] = prev[j-1];\\n            else {\\n                // If the two characters are different, consider three possible operations:\\n                // Insertion: add 1 to the minimum value among prev[j], curr[j-1], and prev[j-1]\\n                curr[j] = 1 + min(prev[j], min(curr[j-1], prev[j-1]));\\n            }\\n        }\\n        // Update the previous row to be equal to the current row\\n        prev = curr;\\n    }\\n    // Return the value of the last element of the dp array, which represents the minimum edit distance\\n    return prev[m];\\n}\\n};\\n```\\n**Tabulation**\\n```\\n// Tabulation - TC: O(n * m), SC: O(n * m)\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        // We make dp array 1 indexed\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        for(int i=0;i<=n;i++) dp[i][0] = i;\\n        for(int j=0;j<=m;j++) dp[0][j] = j;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else\\n// Delete - dp[i-1][j], Insert - dp[i][j-1], Replace - dp[i-1][j-1]\\n                    dp[i][j] = 1 + min(dp[i-1][j], \\n        min(dp[i][j-1], dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n**Memoization** \\n```\\n//Memoization - TC: O(n * m), SC: O(n * m) + O(n + m)\\n    int find(string word1, string word2, int i, int j, vector<vector<int>>& dp){\\n        if(j < 0) return i+1;\\n        if(i < 0) return j+1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(word1[i] == word2[j]) return find(word1, word2, i-1, j-1, dp);\\n        return dp[i][j] = 1 + min(find(word1, word2, i-1, j, dp), \\n        min(find(word1, word2, i, j-1, dp), find(word1, word2, i-1, j-1, dp)));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return find(word1, word2, n-1, m-1, dp);\\n    }\\n```\\n```\\n            Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```\\nclass Solution {\\npublic:\\n    // Space Optimization - TC: O(n * m), SC: O(m)\\n    int minDistance(string word1, string word2) {\\n    int n = word1.size(), m = word2.size();\\n    // We make dp array 1 indexed\\n    // Initialize two vectors to store the values of the previous and current rows of the dp array\\n    vector<int> prev(m+1, 0), curr(m+1, 0);\\n    // Initialize the first row of the dp array to the numbers 0, 1, 2, ..., m\\n    for(int j=0;j<=m;j++) prev[j] = j;\\n    // Iterate through each row of the dp array\\n    for(int i=1;i<=n;i++){\\n        // Set the first element of the current row to i\\n        curr[0] = i;\\n        // Iterate through each column of the dp array\\n        for(int j=1;j<=m;j++){\\n            // If the two characters are equal, no operation is needed\\n            if(word1[i-1] == word2[j-1])\\n                curr[j] = prev[j-1];\\n            else {\\n                // If the two characters are different, consider three possible operations:\\n                // Insertion: add 1 to the minimum value among prev[j], curr[j-1], and prev[j-1]\\n                curr[j] = 1 + min(prev[j], min(curr[j-1], prev[j-1]));\\n            }\\n        }\\n        // Update the previous row to be equal to the current row\\n        prev = curr;\\n    }\\n    // Return the value of the last element of the dp array, which represents the minimum edit distance\\n    return prev[m];\\n}\\n};\\n```\n```\\n// Tabulation - TC: O(n * m), SC: O(n * m)\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        // We make dp array 1 indexed\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        for(int i=0;i<=n;i++) dp[i][0] = i;\\n        for(int j=0;j<=m;j++) dp[0][j] = j;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else\\n// Delete - dp[i-1][j], Insert - dp[i][j-1], Replace - dp[i-1][j-1]\\n                    dp[i][j] = 1 + min(dp[i-1][j], \\n        min(dp[i][j-1], dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```\\n//Memoization - TC: O(n * m), SC: O(n * m) + O(n + m)\\n    int find(string word1, string word2, int i, int j, vector<vector<int>>& dp){\\n        if(j < 0) return i+1;\\n        if(i < 0) return j+1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(word1[i] == word2[j]) return find(word1, word2, i-1, j-1, dp);\\n        return dp[i][j] = 1 + min(find(word1, word2, i-1, j, dp), \\n        min(find(word1, word2, i, j-1, dp), find(word1, word2, i-1, j-1, dp)));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        return find(word1, word2, n-1, m-1, dp);\\n    }\\n```\n```\\n            Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428527,
                "title": "javascript-solution",
                "content": "### The Idea\\n1. Use lavenshtein distance algorithm and dynamic programming implementation\\n2. Build a matrix from word1 and word2, each cell represents the minimum difference between the words up the current character\\n3. Each cell is trying to become the locally minimum difference, so we have 3 options, 1 + left cell, 1 + top cell, 1 + diagonal (two characters aren\\'t the same) or 0 + diagonal (two characters are the same)\\n``` javascript\\nvar minDistance = function(word1, word2) {\\n    let dp = Array(word1.length+1).fill(null).map(()=>(Array(word2.length+1).fill(0)));\\n\\n    for (let i=0;i<dp.length;i++) {\\n        dp[i][0] = i\\n    }\\n\\n    for (let i=0;i<dp[0].length;i++) {\\n        dp[0][i] = i\\n    }\\n\\n    for (let i = 1;i<dp.length;i++) {\\n        for (let j=1;j<dp[0].length;j++) {\\n            dp[i][j] = Math.min(\\n                            dp[i-1][j]+1, // left\\n                            dp[i][j-1]+1, // right\\n                            dp[i-1][j-1] + (word1[i-1]!=word2[j-1]?1:0) // diagonal\\n                        );\\n        }\\n    }\\n    return dp[dp.length-1][dp[0].length-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar minDistance = function(word1, word2) {\\n    let dp = Array(word1.length+1).fill(null).map(()=>(Array(word2.length+1).fill(0)));\\n\\n    for (let i=0;i<dp.length;i++) {\\n        dp[i][0] = i\\n    }\\n\\n    for (let i=0;i<dp[0].length;i++) {\\n        dp[0][i] = i\\n    }\\n\\n    for (let i = 1;i<dp.length;i++) {\\n        for (let j=1;j<dp[0].length;j++) {\\n            dp[i][j] = Math.min(\\n                            dp[i-1][j]+1, // left\\n                            dp[i][j-1]+1, // right\\n                            dp[i-1][j-1] + (word1[i-1]!=word2[j-1]?1:0) // diagonal\\n                        );\\n        }\\n    }\\n    return dp[dp.length-1][dp[0].length-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231367,
                "title": "python-3-8-lines-w-comments-t-m-100-78",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        w1, w2 = len(word1), len(word2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n\\n            if i >= w1             : return w2-j                # word1 used up, so all inserts\\n            if j >= w2             : return w1-i                # word2 used up, so all deletes\\n            if word1[i] == word2[j]: return dp(i+1, j+1)        # letters match, so no operation\\n\\n            return min(dp(i,j+1), dp(i+1,j), dp(i+1,j+1)) + 1   # insert, delete, replace\\n\\n        return dp(0,0)\\n```\\n[https://leetcode.com/problems/edit-distance/submissions/905093377/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is *O*(*MN*), in which *M, N* ~ `len(word1),len(word2)`.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        w1, w2 = len(word1), len(word2)\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n\\n            if i >= w1             : return w2-j                # word1 used up, so all inserts\\n            if j >= w2             : return w1-i                # word2 used up, so all deletes\\n            if word1[i] == word2[j]: return dp(i+1, j+1)        # letters match, so no operation\\n\\n            return min(dp(i,j+1), dp(i+1,j), dp(i+1,j+1)) + 1   # insert, delete, replace\\n\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980878,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/kMGrBJeX/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/kMGrBJeX/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 25987,
                "title": "dynamic-programming-solution-in-c-with-algorithm-description",
                "content": "**Algorithm Description**  \\n\\n\\n----------\\n\\n - Step 1:\\n\\nSet  n to be the length of *word1*;\\nSet m to be the length of *word2*.  \\nIf n = 0, return m and exit.  \\nIf m = 0, return n  and exit.  \\nConstruct a matrix containing 0...n rows and 0...m columns.  \\n  \\n\\n - Step 2:\\n\\nInitialize the first row       to 0...n.  \\nInitialize the first column to 0...m.  \\n  \\n\\n - Step 3:\\n\\nExamine each character of *word1* (i from 1 to  n).\\n\\n - Step 4:\\n\\nExamine each character of *word2*  (j from 1 to m).\\n\\n - Step 5:\\n\\nIf word1[i] == word2[j], the cost = 0.  \\nIf word1[i] !=  word2[j], the cost = 1.  \\n  \\n\\n - Step 6:\\n\\n   \\nSet cell A [i, j] of the matrix equal to the minimum of:  \\na) The cell immediately **above** plus 1:                               A[i - 1, j]    + 1.  \\nb) The cell immediately **to the left** plus 1:                          A[i,  j - 1]    + 1.  \\nc) The cell diagonally **above and to the left** plus the cost: A[i - 1, j - 1] + cost.  \\n  \\n\\n - Step 7:\\n\\n   \\nAfter the iteration steps (3, 4, 5, 6) are complete, the distance is found in cell A[n, m]. \\n\\n\\n----------\\n\\n\\nHere is the code:\\n\\n    int minDistance(string word1, string word2) {\\n        // Step 1\\n        int n = word1.size(), m = word2.size();\\n        if (n == 0)  return m;\\n        if (m == 0)  return n;\\n        int A[n + 1][m + 1];\\n\\n        // Step 2\\n        for (int i = 0; i <= n; ++i)  A[i][0] = i;\\n        for (int j = 0; j <= m; ++j)  A[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {  // Step 3\\n            char word1_i = word1[i-1];\\n            for (int j = 1; j <= m; ++j) {  // Step 4\\n                char word2_j = word2[j-1];\\n                int cost = (word1_i == word2_j) ? 0 : 1;  // Step 5\\n                A[i][j] = min(min(A[i-1][j]+1, A[i][j-1]+1), A[i-1][j-1]+cost);// Step 6\\n            }\\n        }\\n        return A[n][m];  // Step 7\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Algorithm Description**  \\n\\n\\n----------\\n\\n - Step 1:\\n\\nSet  n to be the length of *word1*;\\nSet m to be the length of *word2*.  \\nIf n = 0, return m and exit.  \\nIf m = 0, return n  and exit.  \\nConstruct a matrix containing 0...n rows and 0...m columns.  \\n  \\n\\n - Step 2:\\n\\nInitialize the first row       to 0...n.  \\nInitialize the first column to 0...m.  \\n  \\n\\n - Step 3:\\n\\nExamine each character of *word1* (i from 1 to  n).\\n\\n - Step 4:\\n\\nExamine each character of *word2*  (j from 1 to m).\\n\\n - Step 5:\\n\\nIf word1[i] == word2[j], the cost = 0.  \\nIf word1[i] !=  word2[j], the cost = 1.  \\n  \\n\\n - Step 6:\\n\\n   \\nSet cell A [i, j] of the matrix equal to the minimum of:  \\na) The cell immediately **above** plus 1:                               A[i - 1, j]    + 1.  \\nb) The cell immediately **to the left** plus 1:                          A[i,  j - 1]    + 1.  \\nc) The cell diagonally **above and to the left** plus the cost: A[i - 1, j - 1] + cost.  \\n  \\n\\n - Step 7:\\n\\n   \\nAfter the iteration steps (3, 4, 5, 6) are complete, the distance is found in cell A[n, m]. \\n\\n\\n----------\\n\\n\\nHere is the code:\\n\\n    int minDistance(string word1, string word2) {\\n        // Step 1\\n        int n = word1.size(), m = word2.size();\\n        if (n == 0)  return m;\\n        if (m == 0)  return n;\\n        int A[n + 1][m + 1];\\n\\n        // Step 2\\n        for (int i = 0; i <= n; ++i)  A[i][0] = i;\\n        for (int j = 0; j <= m; ++j)  A[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {  // Step 3\\n            char word1_i = word1[i-1];\\n            for (int j = 1; j <= m; ++j) {  // Step 4\\n                char word2_j = word2[j-1];\\n                int cost = (word1_i == word2_j) ? 0 : 1;  // Step 5\\n                A[i][j] = min(min(A[i-1][j]+1, A[i][j-1]+1), A[i-1][j-1]+cost);// Step 6\\n            }\\n        }\\n        return A[n][m];  // Step 7\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1519242,
                "title": "java-tc-o-mn-sc-o-min-m-n-space-optimized-dp-solution",
                "content": "```java\\n/**\\n * Space Optimized Dynamic Programming solution\\n *\\n * dp[i][j] = the minimum number of operations to convert word1[0 .. i-1] to word2[0 .. j-1]\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(min(M, N)).\\n *\\n * M = Length string word1. N = Length of string word2.\\n */\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int insertCost = 1;\\n        int deleteCost = 1;\\n        int replaceCost = 1;\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n\\n        if (l1 == 0) {\\n            return l2 * insertCost;\\n        }\\n        if (l2 == 0) {\\n            return l1 * deleteCost;\\n        }\\n        // Bellow condition can be used only if all three costs are same.\\n        if (l1 > l2) {\\n            return minDistance(word2, word1);\\n        }\\n\\n        int[] dp = new int[l1 + 1];\\n        // Setting DP array for 0th column of 2D DP array. Here l2 is blank, thus we\\n        // have to delete everything in l1.\\n        for (int i = 1; i <= l1; i++) {\\n            dp[i] = dp[i - 1] + deleteCost;\\n        }\\n\\n        for (int j = 1; j <= l2; j++) {\\n            int prev = dp[0];\\n            dp[0] += insertCost; // l1 is blank, Inserting l2 chars in l1.\\n            char c2 = word2.charAt(j - 1);\\n            for (int i = 1; i <= l1; i++) {\\n                char c1 = word1.charAt(i - 1);\\n                int temp = dp[i];\\n                // Both chars are same, so the distance will also remain same as dp[i-1][j-1]\\n                if (c1 == c2) {\\n                    dp[i] = prev;\\n                } else {\\n                    // Replace l1[i - 1] by l2[j - 1] ==> dp[i][j] = dp[i - 1][j - 1] + 1\\n                    // Delete l1[i-1] from l1[0..i-1] ==> dp[i-1][j] + 1\\n                    // Insert l2[j-1] into l1[0..i-1] ==> dp[i][j-1] + 1\\n                    dp[i] = Math.min(prev + replaceCost, Math.min(dp[i - 1] + deleteCost, dp[i] + insertCost));\\n                }\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[l1];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other similar questions on LeetCode:\\n- [221. Maximal Square](https://leetcode.com/problems/maximal-square/discuss/1519235/Java-or-TC:-O(MN)-or-SC:-O(min(MN))-or-Space-optimized-DP-solution)\\n- [161. One Edit Distance](https://leetcode.com/problems/one-edit-distance/discuss/1519249/Java-or-TC:-O(min(ST))-or-SC:-O(min(ST))-or-Optimal-One-Pass-solution)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n * Space Optimized Dynamic Programming solution\\n *\\n * dp[i][j] = the minimum number of operations to convert word1[0 .. i-1] to word2[0 .. j-1]\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(min(M, N)).\\n *\\n * M = Length string word1. N = Length of string word2.\\n */\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        if (word1 == null || word2 == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int insertCost = 1;\\n        int deleteCost = 1;\\n        int replaceCost = 1;\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n\\n        if (l1 == 0) {\\n            return l2 * insertCost;\\n        }\\n        if (l2 == 0) {\\n            return l1 * deleteCost;\\n        }\\n        // Bellow condition can be used only if all three costs are same.\\n        if (l1 > l2) {\\n            return minDistance(word2, word1);\\n        }\\n\\n        int[] dp = new int[l1 + 1];\\n        // Setting DP array for 0th column of 2D DP array. Here l2 is blank, thus we\\n        // have to delete everything in l1.\\n        for (int i = 1; i <= l1; i++) {\\n            dp[i] = dp[i - 1] + deleteCost;\\n        }\\n\\n        for (int j = 1; j <= l2; j++) {\\n            int prev = dp[0];\\n            dp[0] += insertCost; // l1 is blank, Inserting l2 chars in l1.\\n            char c2 = word2.charAt(j - 1);\\n            for (int i = 1; i <= l1; i++) {\\n                char c1 = word1.charAt(i - 1);\\n                int temp = dp[i];\\n                // Both chars are same, so the distance will also remain same as dp[i-1][j-1]\\n                if (c1 == c2) {\\n                    dp[i] = prev;\\n                } else {\\n                    // Replace l1[i - 1] by l2[j - 1] ==> dp[i][j] = dp[i - 1][j - 1] + 1\\n                    // Delete l1[i-1] from l1[0..i-1] ==> dp[i-1][j] + 1\\n                    // Insert l2[j-1] into l1[0..i-1] ==> dp[i][j-1] + 1\\n                    dp[i] = Math.min(prev + replaceCost, Math.min(dp[i - 1] + deleteCost, dp[i] + insertCost));\\n                }\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[l1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25878,
                "title": "evolve-from-brute-force-to-dp",
                "content": "We only need to edit one word because insert a char to word1 is equivalent to delete a char in word2 and vise versa. Replace a char in word1 is equivalent to replace a char in word2.\\n1. O(3^max(n1,n2)) We edit word 1 only and there are 3 operations\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        return minDistance(0,0,word1,word2);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2) {\\n        if(p1==word1.size()) return word2.size()-p2; //dist between a string and an empty string\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(word1[p1]==word2[p2]) return minDistance(p1+1,p2+1,word1,word2);\\n        int ins = minDistance(p1,p2+1,word1,word2);\\n        int del = minDistance(p1+1,p2,word1,word2);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2);\\n        return min(ins,min(del,rpl))+1;\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        return minDist(0,0,word1,word2);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return minDist(p1+1,p2+1,word1,word2);\\n        int ins = minDist(p1,p2+1,word1,word2);\\n        int del = minDist(p1+1,p2,word1,word2);\\n        int rep = minDist(p1+1,p2+1,word1,word2);\\n        return Math.min(ins, Math.min(del, rep))+1;\\n    }\\n}\\n```\\n2. O(n1n2) memorization\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> mem(word1.size(),vector<int>(word2.size(),-1));\\n        return minDistance(0,0,word1,word2,mem);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2,vector<vector<int>>& mem) {\\n        if(p1==word1.size()) return word2.size()-p2;\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(mem[p1][p2]>=0) return mem[p1][p2];\\n        if(word1[p1]==word2[p2]) return mem[p1][p2]=minDistance(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDistance(p1,p2+1,word1,word2,mem);\\n        int del = minDistance(p1+1,p2,word1,word2,mem);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2] = min(ins,min(del,rpl))+1;\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        Integer[][] mem=new Integer[word1.length()][word2.length()];\\n        return minDist(0,0,word1,word2,mem);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2, Integer[][] mem) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(mem[p1][p2]!=null) return mem[p1][p2];\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return mem[p1][p2]=minDist(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDist(p1,p2+1,word1,word2,mem);\\n        int del = minDist(p1+1,p2,word1,word2,mem);\\n        int rep = minDist(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2]=Math.min(ins, Math.min(del, rep))+1;\\n    }\\n```\\n3. O(n1n2) dp\\n* c++\\n```\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size(),n2=word2.size();\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1));\\n        for(int i=0;i<n1;i++) dp[i][n2] = n1-i;\\n        for(int j=0;j<n2;j++) dp[n1][j] = n2-j;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) \\n                dp[i][j] = word1[i]==word2[j]? dp[i+1][j+1] : min(min(dp[i][j+1],dp[i+1][j]),dp[i+1][j+1])+1;\\n        return dp[0][0];\\n    }\\n```\\n* java\\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        int n1=word1.length(), n2=word2.length();\\n        int[][] dp=new int[n1+1][n2+1];\\n        for(int i=0;i<n1;i++) dp[i][n2]=n1-i;\\n        for(int i=0;i<n2;i++) dp[n1][i]=n2-i;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) {\\n                if(word1.charAt(i)==word2.charAt(j))\\n                    dp[i][j]=dp[i+1][j+1];\\n                else {\\n                    dp[i][j]=Math.min(dp[i][j+1],Math.min(dp[i+1][j],dp[i+1][j+1]))+1;\\n                }\\n            }\\n        return dp[0][0];  \\n    }\\n```\\n4. linear space dp\\n```\\n    int minDistance(string word1, string word2) {\\n        int s1=word1.size(),s2=word2.size();\\n        vector<int> dp(s1+1);\\n        iota(dp.rbegin(),dp.rend(),0);\\n        for(int i=s2-1;i>=0;i--) {\\n            int i1j1 = dp[s1];\\n            dp[s1] = s2-i;\\n            for(int j=s1-1;j>=0;j--) {\\n                int temp=dp[j];\\n                dp[j]=min(dp[j+1]+1,min(dp[j]+1,i1j1+(word2[i]!=word1[j])));\\n                i1j1=temp;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        return minDistance(0,0,word1,word2);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2) {\\n        if(p1==word1.size()) return word2.size()-p2; //dist between a string and an empty string\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(word1[p1]==word2[p2]) return minDistance(p1+1,p2+1,word1,word2);\\n        int ins = minDistance(p1,p2+1,word1,word2);\\n        int del = minDistance(p1+1,p2,word1,word2);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2);\\n        return min(ins,min(del,rpl))+1;\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        return minDist(0,0,word1,word2);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return minDist(p1+1,p2+1,word1,word2);\\n        int ins = minDist(p1,p2+1,word1,word2);\\n        int del = minDist(p1+1,p2,word1,word2);\\n        int rep = minDist(p1+1,p2+1,word1,word2);\\n        return Math.min(ins, Math.min(del, rep))+1;\\n    }\\n}\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> mem(word1.size(),vector<int>(word2.size(),-1));\\n        return minDistance(0,0,word1,word2,mem);\\n    }\\n    int minDistance(int p1, int p2, string &word1, string &word2,vector<vector<int>>& mem) {\\n        if(p1==word1.size()) return word2.size()-p2;\\n        if(p2==word2.size()) return word1.size()-p1;\\n        if(mem[p1][p2]>=0) return mem[p1][p2];\\n        if(word1[p1]==word2[p2]) return mem[p1][p2]=minDistance(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDistance(p1,p2+1,word1,word2,mem);\\n        int del = minDistance(p1+1,p2,word1,word2,mem);\\n        int rpl = minDistance(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2] = min(ins,min(del,rpl))+1;\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        Integer[][] mem=new Integer[word1.length()][word2.length()];\\n        return minDist(0,0,word1,word2,mem);  \\n    }\\n    private int minDist(int p1, int p2, String word1, String word2, Integer[][] mem) {\\n        int s1=word1.length(),s2=word2.length();\\n        if(p1==s1) return s2-p2; //We only edit word1, but since both insert and delete are allowed, word1 may not finish first\\n        if(p2==s2) return s1-p1; //The two ternimation checks make sure both indexes are valid\\n        if(mem[p1][p2]!=null) return mem[p1][p2];\\n        if(word1.charAt(p1)==word2.charAt(p2)) \\n            return mem[p1][p2]=minDist(p1+1,p2+1,word1,word2,mem);\\n        int ins = minDist(p1,p2+1,word1,word2,mem);\\n        int del = minDist(p1+1,p2,word1,word2,mem);\\n        int rep = minDist(p1+1,p2+1,word1,word2,mem);\\n        return mem[p1][p2]=Math.min(ins, Math.min(del, rep))+1;\\n    }\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size(),n2=word2.size();\\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1));\\n        for(int i=0;i<n1;i++) dp[i][n2] = n1-i;\\n        for(int j=0;j<n2;j++) dp[n1][j] = n2-j;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) \\n                dp[i][j] = word1[i]==word2[j]? dp[i+1][j+1] : min(min(dp[i][j+1],dp[i+1][j]),dp[i+1][j+1])+1;\\n        return dp[0][0];\\n    }\\n```\n```\\n\\tpublic int minDistance(String word1, String word2) {\\n        int n1=word1.length(), n2=word2.length();\\n        int[][] dp=new int[n1+1][n2+1];\\n        for(int i=0;i<n1;i++) dp[i][n2]=n1-i;\\n        for(int i=0;i<n2;i++) dp[n1][i]=n2-i;\\n        for(int i=n1-1;i>=0;i--)\\n            for(int j=n2-1;j>=0;j--) {\\n                if(word1.charAt(i)==word2.charAt(j))\\n                    dp[i][j]=dp[i+1][j+1];\\n                else {\\n                    dp[i][j]=Math.min(dp[i][j+1],Math.min(dp[i+1][j],dp[i+1][j+1]))+1;\\n                }\\n            }\\n        return dp[0][0];  \\n    }\\n```\n```\\n    int minDistance(string word1, string word2) {\\n        int s1=word1.size(),s2=word2.size();\\n        vector<int> dp(s1+1);\\n        iota(dp.rbegin(),dp.rend(),0);\\n        for(int i=s2-1;i>=0;i--) {\\n            int i1j1 = dp[s1];\\n            dp[s1] = s2-i;\\n            for(int j=s1-1;j>=0;j--) {\\n                int temp=dp[j];\\n                dp[j]=min(dp[j+1]+1,min(dp[j]+1,i1j1+(word2[i]!=word1[j])));\\n                i1j1=temp;\\n            }\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25989,
                "title": "my-dp-solution-in-c-with-comments",
                "content": "   \\n\\n    int minDistance(string word1, string word2) {\\n        // DP talbe, i is the position in word1, and j is the position in word2\\n        vector<vector<int>> distance(word1.length()+1, vector<int>(word2.length()+1, 0));\\n        \\n        // when i or j=0 means empty string, the distance is the length of another string\\n        for(int i=0; i<distance.size(); i++)\\n            for(int j=0; j< distance[0].size();j++){\\n                if(i == 0)\\n                    distance[i][j] = j;\\n                else if(j == 0)\\n                    distance[i][j] = i;\\n            }\\n        \\n        // if word1[i]==word2[j], then the distance of i and j is the previous i and j\\n        // otherwise we either replace, insert or delete a char\\n        // when insert a char to word1 it means we are trying to match word1 at i-1 to word2 at j\\n        // when delete a char from word1 it equals to insert a char to word2, which\\n        // means we are trying to match word1 at i to word2 at j-1\\n        // when replace a char to word1, then we add one step to previous i and j\\n        for(int i=1; i< distance.size(); i++)\\n            for(int j=1; j<distance[0].size(); j++){\\n                if(word1[i-1] == word2[j-1])\\n                    distance[i][j] = distance[i-1][j-1];\\n                else\\n                    distance[i][j] = 1+ min(distance[i-1][j-1], min(distance[i-1][j], distance[i][j-1]));\\n            }\\n            \\n        return distance[word1.length()][word2.length()];\\n    }",
                "solutionTags": [],
                "code": "   \\n\\n    int minDistance(string word1, string word2) {\\n        // DP talbe, i is the position in word1, and j is the position in word2\\n        vector<vector<int>> distance(word1.length()+1, vector<int>(word2.length()+1, 0));\\n        \\n        // when i or j=0 means empty string, the distance is the length of another string\\n        for(int i=0; i<distance.size(); i++)\\n            for(int j=0; j< distance[0].size();j++){\\n                if(i == 0)\\n                    distance[i][j] = j;\\n                else if(j == 0)\\n                    distance[i][j] = i;\\n            }\\n        \\n        // if word1[i]==word2[j], then the distance of i and j is the previous i and j\\n        // otherwise we either replace, insert or delete a char\\n        // when insert a char to word1 it means we are trying to match word1 at i-1 to word2 at j\\n        // when delete a char from word1 it equals to insert a char to word2, which\\n        // means we are trying to match word1 at i to word2 at j-1\\n        // when replace a char to word1, then we add one step to previous i and j\\n        for(int i=1; i< distance.size(); i++)\\n            for(int j=1; j<distance[0].size(); j++){\\n                if(word1[i-1] == word2[j-1])\\n                    distance[i][j] = distance[i-1][j-1];\\n                else\\n                    distance[i][j] = 1+ min(distance[i-1][j-1], min(distance[i-1][j], distance[i][j-1]));\\n            }\\n            \\n        return distance[word1.length()][word2.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1915729,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        let row = word1.count + 1\\n        let col = word2.count + 1\\n        let chs1  = Array(word1)\\n        let chs2  = Array(word2)\\n        var dp: [[Int]] = Array(repeating: Array(repeating: 0, count: col), count: row)\\n        \\n        for i in 0..<row { \\n            for j in 0..<col {\\n                if i == 0 {\\n                    dp[i][j] = j\\n                \\n                } else if j == 0 {\\n                    dp[i][j] = i\\n                \\n                } else if chs1[i - 1] == chs2[j - 1] {\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                \\n                } else {\\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        let row = word1.count + 1\\n        let col = word2.count + 1\\n        let chs1  = Array(word1)\\n        let chs2  = Array(word2)\\n        var dp: [[Int]] = Array(repeating: Array(repeating: 0, count: col), count: row)\\n        \\n        for i in 0..<row { \\n            for j in 0..<col {\\n                if i == 0 {\\n                    dp[i][j] = j\\n                \\n                } else if j == 0 {\\n                    dp[i][j] = i\\n                \\n                } else if chs1[i - 1] == chs2[j - 1] {\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                \\n                } else {\\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359663,
                "title": "java-recursion-memoization-easy",
                "content": "Memoization Code is much better than recursion, yes DP is more fast than memoization. I put this because lots of students get confused while doing memoization\\n To do any Dp question, follow these three steps :-\\n1. Try to make solution via recursion\\n2. Try to make solution via memoization\\n3. then move to Dp\\n```    \\n    //Memoization Code\\n     public int minDistance(String word1, String word2) {\\n         int m = word1.length();\\n         int n = word2.length();\\n         int storage[][] = new int[m+1][n+1];\\n         for(int i=0;i<=m;i++){\\n             for(int j=0;j<=n;j++){\\n             storage[i][j] = -1;\\n             }\\n         }\\n         \\n         return editMemo(word1,word2,storage);\\n     }\\n    \\n    public int editMemo(String word1, String word2, int storage[][]){\\n        int m = word1.length();\\n         int n = word2.length();\\n        if(storage[m][n] != -1){\\n            return storage[m][n];\\n        }\\n        if(m==0) return storage[m][n] = n;\\n        if(n==0) return storage[m][n] = m;\\n         if(word1.charAt(0) == word2.charAt(0)){\\n            return storage[m][n] = editMemo(word1.substring(1),word2.substring(1),storage);\\n         }else{\\n               //insert\\n            int insert = editMemo(word1,word2.substring(1),storage);\\n             //delete\\n            int delete = editMemo(word1.substring(1),word2,storage);\\n             //replace \\n            int replace = editMemo(word1.substring(1),word2.substring(1),storage);\\n              storage[m][n] = 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n        return storage[m][n];\\n    }\\n    \\n```    \\n    \\n\\t\\n   It gives us TLE, because strings present in test cases can be so long\\n   ```\\n   // Recursion Solution\\n    public int minDistance(String word1, String word2) {\\n         if(word1.length() == 0){\\n             return word2.length();\\n         }\\n         if(word2.length() == 0){\\n             return word1.length();\\n         }\\n        \\n         if(word1.charAt(0) == word2.charAt(0)){\\n             return minDistance(word1.substring(1),word2.substring(1));\\n        }else{\\n             //insert\\n             int insert = minDistance(word1,word2.substring(1));\\n              //delete\\n             int delete = minDistance(word1.substring(1),word2);\\n              //replace \\n             int replace = minDistance(word1.substring(1),word2.substring(1));\\n               return 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n     }\\n\\t ```\\n**If you like this, please upvote and like this**",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```    \\n    //Memoization Code\\n     public int minDistance(String word1, String word2) {\\n         int m = word1.length();\\n         int n = word2.length();\\n         int storage[][] = new int[m+1][n+1];\\n         for(int i=0;i<=m;i++){\\n             for(int j=0;j<=n;j++){\\n             storage[i][j] = -1;\\n             }\\n         }\\n         \\n         return editMemo(word1,word2,storage);\\n     }\\n    \\n    public int editMemo(String word1, String word2, int storage[][]){\\n        int m = word1.length();\\n         int n = word2.length();\\n        if(storage[m][n] != -1){\\n            return storage[m][n];\\n        }\\n        if(m==0) return storage[m][n] = n;\\n        if(n==0) return storage[m][n] = m;\\n         if(word1.charAt(0) == word2.charAt(0)){\\n            return storage[m][n] = editMemo(word1.substring(1),word2.substring(1),storage);\\n         }else{\\n               //insert\\n            int insert = editMemo(word1,word2.substring(1),storage);\\n             //delete\\n            int delete = editMemo(word1.substring(1),word2,storage);\\n             //replace \\n            int replace = editMemo(word1.substring(1),word2.substring(1),storage);\\n              storage[m][n] = 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n        return storage[m][n];\\n    }\\n    \\n```\n```\\n   // Recursion Solution\\n    public int minDistance(String word1, String word2) {\\n         if(word1.length() == 0){\\n             return word2.length();\\n         }\\n         if(word2.length() == 0){\\n             return word1.length();\\n         }\\n        \\n         if(word1.charAt(0) == word2.charAt(0)){\\n             return minDistance(word1.substring(1),word2.substring(1));\\n        }else{\\n             //insert\\n             int insert = minDistance(word1,word2.substring(1));\\n              //delete\\n             int delete = minDistance(word1.substring(1),word2);\\n              //replace \\n             int replace = minDistance(word1.substring(1),word2.substring(1));\\n               return 1 + Math.min(insert,Math.min(delete,replace));\\n         }\\n     }\\n\\t ```",
                "codeTag": "Unknown"
            },
            {
                "id": 662992,
                "title": "javascript-dynamic-programming-concise-code-with-explanation",
                "content": "This is one of the problems taken directly from a farily well known algorithm.\\n\\nMinimum edit distance / Levenshtein Distance\\nWhat are the minimal # of edits (change, add, delete char) to convert 1 string to another\\nIt\\'s a DP problem, looking at a character at a time.  \\n\\nFor each chacter, you either don\\'t need to change it, you need to delete it, or you need to change it.\\nKeep doing that character after character for each possibility and since we are interested in the minimum number of changes, just keep track of the lowest #.\\n\\nTake a look at this great visual explanation:\\nhttps://www.youtube.com/watch?v=We3YDTzNXEk\\n\\n```\\nvar minDistance = function(word1, word2) {\\n  let dp = Array(word1.length+1).fill().map(()=>Array(word2.length+1)); // Get our DP matrix setup, no need for default values since we\\'ll be filling each each of them\\n  \\n  for (let r=0; r<=word1.length; r++) {\\n    for (let c=0; c<=word2.length; c++) {\\n      if (r==0) dp[0][c] = c; // here we setup the initial row\\n      else if (c==0) dp[r][0] = r; // here the initial column\\n      else if (word1[r-1] == word2[c-1]) //now, if the letter is the same, cost is the same as the upper left cost\\n        dp[r][c] = dp[r-1][c-1];\\n      else //letters are different, so we will either need to change or delete one of the letters so prev cost +1 operation\\n        dp[r][c] = Math.min(dp[r][c-1],dp[r-1][c-1], dp[r-1][c]) +1;\\n    }\\n  }\\n  return dp[word1.length][word2.length]; //return the cost at the end of the string\\n};\\n```\\n\\nIf this explanation helped, please upvote this post so others can notice it.  Cheers!",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minDistance = function(word1, word2) {\\n  let dp = Array(word1.length+1).fill().map(()=>Array(word2.length+1)); // Get our DP matrix setup, no need for default values since we\\'ll be filling each each of them\\n  \\n  for (let r=0; r<=word1.length; r++) {\\n    for (let c=0; c<=word2.length; c++) {\\n      if (r==0) dp[0][c] = c; // here we setup the initial row\\n      else if (c==0) dp[r][0] = r; // here the initial column\\n      else if (word1[r-1] == word2[c-1]) //now, if the letter is the same, cost is the same as the upper left cost\\n        dp[r][c] = dp[r-1][c-1];\\n      else //letters are different, so we will either need to change or delete one of the letters so prev cost +1 operation\\n        dp[r][c] = Math.min(dp[r][c-1],dp[r-1][c-1], dp[r-1][c]) +1;\\n    }\\n  }\\n  return dp[word1.length][word2.length]; //return the cost at the end of the string\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662497,
                "title": "java-c-python3-with-detailed-explanation",
                "content": "```\\nEXPLANATION:-\\n\\nIn this problem, we need to convert w1 to w2 with minimum number of operations\\n\\nLet\\'s see how to solve this problem.\\n\\nCase 1:-\\n   w1 = ab,  w2 = \"\"\\n   result = 2.\\n   we can convert w1 to w2 by \\n   deleting all the characters in w1.\\n   So, result is 2.\\nCase 2:-\\n   w1 = \"\", w2 = ab\\n   we can convert w1 to w2, \\n   by inserting a and b it w1.\\n   So, result is 2.\\nCase 3:-\\n   w1 = a,  w2 = a\\n   w1 and w2 are equal.\\n   So, result is 0.\\n   \\nCase 4:-\\n    w1 = a,  w2 = b\\n\\tHere, w1 and w2 are not equal.\\n\\tSo, What to do now.\\n\\tWe have three operations\\n\\t1. insert\\n\\t2. delete\\n\\t3. replace\\n\\tperform three operations on w1.\\n\\tand take minimum result.\\n\\t\\n\\tw1 = a,  w2 = b.\\n\\tindex1 = 0\\n\\tindex2 = 0\\n\\toperations = 0\\n\\t\\n\\t1.insert \\n\\t\\n\\tinsert b to w1.\\n\\tSo, w1 = ba, w2 = b\\n\\toperations is increased by since we have inserted a character.\\n\\toperations = 1\\n\\tNow, w1[index1] == w2[index2],\\n\\tSo, ignore those characters and check remaining characters.\\n    So, w1 = a, w2 = \"\" (after ignoring first characters as they are same)\\n\\tThis is same as case 1.\\n\\twe can w2 from w1 by deleting \\'a\\'.\\n\\tSo, delete \\'a\\'\\n\\t- >  operations = 2.\\n\\n\\t 2. Delete:-\\n\\n\\t w1 = a, w2 = b, operations = 0\\n\\t delete a character from w1\\n\\t So, operations = 1\\n\\t w1 = \"\", w2 = b\\n\\t this is same as case 2.\\n\\t we can w2 from w1 by inserting \\'b\\' to w1.\\n\\t So, insert \\'b\\'.\\n\\t - > operations = 2.\\n\\n\\t 3. replace:\\n\\t \\n\\t  w1 = a, w2 = b, operations = 0\\n\\t  replace a with b.\\n\\t  operations = 1.\\n\\t  w1 = w2\\n\\t  So, operations = 1.\\n  \\n\\t  Now, choose minimum of (insert, delete, replace) = min(2, 2, 1)\\n  \\n\\t  So, result = 1 to convert a to b.\\n  \\n  This is the idea behind this.\\n  \\n  IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK.\\n \\xA0IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\\n```\\n\\nJava : -\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n\\t\\tint M = word1.length();\\n\\t\\tint N = word2.length();\\n\\t\\tint dp[][] = new int[M + 1][N + 1];\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n\\n\\t}\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n\\t\\tint M = word1.size();\\n\\t\\tint N = word2.size();\\n\\t\\tvector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.at(i - 1) == word2.at(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n    }\\n};\\n\\nPython3:-\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        M, N = len(word1), len(word2)\\n        if M * N == 0:\\n            return M + N\\n        dp = [[0] * (N + 1) for i in range(M + 1)]\\n\\n        for i in range(M + 1):\\n            dp[i][0] = i\\n        for i in range(N + 1):\\n            dp[0][i] = i\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1]))\\n        return dp[M][N]\\n```",
                "solutionTags": [],
                "code": "```\\nEXPLANATION:-\\n\\nIn this problem, we need to convert w1 to w2 with minimum number of operations\\n\\nLet\\'s see how to solve this problem.\\n\\nCase 1:-\\n   w1 = ab,  w2 = \"\"\\n   result = 2.\\n   we can convert w1 to w2 by \\n   deleting all the characters in w1.\\n   So, result is 2.\\nCase 2:-\\n   w1 = \"\", w2 = ab\\n   we can convert w1 to w2, \\n   by inserting a and b it w1.\\n   So, result is 2.\\nCase 3:-\\n   w1 = a,  w2 = a\\n   w1 and w2 are equal.\\n   So, result is 0.\\n   \\nCase 4:-\\n    w1 = a,  w2 = b\\n\\tHere, w1 and w2 are not equal.\\n\\tSo, What to do now.\\n\\tWe have three operations\\n\\t1. insert\\n\\t2. delete\\n\\t3. replace\\n\\tperform three operations on w1.\\n\\tand take minimum result.\\n\\t\\n\\tw1 = a,  w2 = b.\\n\\tindex1 = 0\\n\\tindex2 = 0\\n\\toperations = 0\\n\\t\\n\\t1.insert \\n\\t\\n\\tinsert b to w1.\\n\\tSo, w1 = ba, w2 = b\\n\\toperations is increased by since we have inserted a character.\\n\\toperations = 1\\n\\tNow, w1[index1] == w2[index2],\\n\\tSo, ignore those characters and check remaining characters.\\n    So, w1 = a, w2 = \"\" (after ignoring first characters as they are same)\\n\\tThis is same as case 1.\\n\\twe can w2 from w1 by deleting \\'a\\'.\\n\\tSo, delete \\'a\\'\\n\\t- >  operations = 2.\\n\\n\\t 2. Delete:-\\n\\n\\t w1 = a, w2 = b, operations = 0\\n\\t delete a character from w1\\n\\t So, operations = 1\\n\\t w1 = \"\", w2 = b\\n\\t this is same as case 2.\\n\\t we can w2 from w1 by inserting \\'b\\' to w1.\\n\\t So, insert \\'b\\'.\\n\\t - > operations = 2.\\n\\n\\t 3. replace:\\n\\t \\n\\t  w1 = a, w2 = b, operations = 0\\n\\t  replace a with b.\\n\\t  operations = 1.\\n\\t  w1 = w2\\n\\t  So, operations = 1.\\n  \\n\\t  Now, choose minimum of (insert, delete, replace) = min(2, 2, 1)\\n  \\n\\t  So, result = 1 to convert a to b.\\n  \\n  This is the idea behind this.\\n  \\n  IF YOU HAVE ANY DOUBTS, FEEL FREE TO ASK.\\n \\xA0IF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\n```\\n\\nJava : -\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n\\t\\tint M = word1.length();\\n\\t\\tint N = word2.length();\\n\\t\\tint dp[][] = new int[M + 1][N + 1];\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.charAt(i - 1) == word2.charAt(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n\\n\\t}\\n}\\n\\nC++:-\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n\\t\\tint M = word1.size();\\n\\t\\tint N = word2.size();\\n\\t\\tvector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));\\n\\t\\tif (M * N == 0)\\n\\t\\t\\treturn M + N;\\n\\n\\t\\tfor (int i = 0; i <= M; i++) {\\n\\t\\t\\tdp[i][0] = i;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i <= N; i++) {\\n\\t\\t\\tdp[0][i] = i;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= M; i++) {\\n\\t\\t\\tfor (int j = 1; j <= N; j++) {\\n\\t\\t\\t\\tif (word1.at(i - 1) == word2.at(j - 1)) {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[M][N];\\n    }\\n};\\n\\nPython3:-\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        M, N = len(word1), len(word2)\\n        if M * N == 0:\\n            return M + N\\n        dp = [[0] * (N + 1) for i in range(M + 1)]\\n\\n        for i in range(M + 1):\\n            dp[i][0] = i\\n        for i in range(N + 1):\\n            dp[0][i] = i\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1]))\\n        return dp[M][N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162330,
                "title": "very-detailed-explanation-recursive-dp-in-java",
                "content": "The first step towards solving a DP problem is to build up the recursion tree. Once you have done it, it could be optimized using memoization, or a bottoms-up. Memoization is no brainer but bottoms-up takes a bit to get it right. I will try to outline how to build up the recursive solution and then move to DP from there. \\n\\nThis algorithm is based on standard L-distance, where would you do something of this sort:\\n```\\nif two characters are not equal:\\n\\t//cost to replace\\n\\tint replaceCount = 1 + function(s1, i+1, s2, j+1); // add 1 to the cost of replacing a character and go to the next set of characters.\\n\\t//cost to delete.\\n\\tint deleteCount = 1 + function(s1, i+1, s2, j); //add 1 to the cost of deleting the current char from string 1 and move to the next character from the first string assuming the current character won\\'t be considered anymore.\\n\\t//cost to add.\\n\\tint addCount = 1 + function(s1, i, s2, j+1);//add 1 to the cost of adding a new character to the second string and compare it with the current character from string 1. \\n```\\n\\nBased on the fact above, you could come up with the following recursive code:\\n```\\nprivate int helper(String s1,  int i, String s2, int j) {\\n        if (i == s1.length()) {\\n            //the first word came to an end.\\n            return s2.length()-j;\\n        } else if (j == s2.length()) {\\n            return s1.length() - i;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper(s1, i+1, s2, j+1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper(s1, i+1, s2, j+1);\\n            //delete.\\n            int deleteCount = 1 + helper(s1, i+1, s2, j);\\n            //add.\\n            int addCount = 1 + helper(s1, i, s2, j+1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n\\t\\t\\nAnd, call it with helper(word1,0,word2,0).\\n```\\n\\nThe above does exhaustive traversal causing an exponential time complexity. You could fix it to make O(m*n) by doing memoization and I won\\'t discuss it here.\\n\\nDoing a bottoms-up DP requires us to think differently. You solve the first problem and then use that to solve the next problem. If you look at our recursive solution above, we are doing exactly the oppostive. We can\\'t use the recursive equation as it is since our solution of the current stack depends on the next stack and DP requires us to think it in the opposite way. So we will rewrite our recursive equation to suit this need. Here is the code for that:\\n\\n```\\n    private int helper_rec(String s1,  int i, String s2, int j) {\\n        if (i < 0) {\\n            //the first word came to an end.\\n            return j+1;\\n        } else if (j < 0) {\\n            return i+1;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper_rec(s1, i-1, s2, j-1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper_rec(s1, i-1, s2, j-1);\\n            //delete.\\n            int deleteCount = 1 + helper_rec(s1, i-1, s2, j);\\n            //add.\\n            int addCount = 1 + helper_rec(s1, i, s2, j-1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n```\\n\\nWe are now good. We are building the solution from the previous solution and this is what the DP requires. Now to use the DP, here is what we need to consider:\\n1. Creating a 2-d array that may represent both words.\\n2. Thinking about an index \"0\" that is always initialized with some value for both i and j.\\n3. How to use the recursive condition from the above.\\n\\n```\\n1. For the first part, just create an array with the size of those words.\\nint[][] arr = new int[word1.length()+1][word2.length()+1];\\n\\n2. Initialization is a bit tricky but we could assume that the index \\'0\\' is basically an empty  string and how could we convert a string  to an empty string. Here is how we initialize that part:\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n\\t\\t\\t\\t\\n3. Using recursive condition: it is pretty much straight-foward:\\n //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tThe above is an equivalent of our recursive equation where the position of the index is actually a subscript of an  array.\\n\\t\\t\\t\\n\\t\\t\\t\\nThe only other thing to remember is when the characters match, we want to reuse the last known cost. That\\'s if the characters match at arr[i][j], the new cost will be arr[i-1][j-1] since that will still apply to our next set of iterations.\\n```\\n\\nHere is the working code for the above:\\n```\\n    public int minDistance(String word1, String word2) {\\n        //return helper_rec(word1, word1.length()-1, word2, word2.length()-1);        \\n        int[][] arr = new int[word1.length()+1][word2.length()+1];\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n        \\n         for (int i=1; i<=word1.length();i++){\\n             for (int j=1; j<=word2.length() ;j++) {\\n                 if (word1.charAt(i-1) != word2.charAt(j-1)) {\\n                     //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n                 } else {\\n                     arr[i][j] = arr[i-1][j-1];\\n                 }\\n             }\\n         }   \\n        \\n        return arr[word1.length()][word2.length()];\\n    }\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nif two characters are not equal:\\n\\t//cost to replace\\n\\tint replaceCount = 1 + function(s1, i+1, s2, j+1); // add 1 to the cost of replacing a character and go to the next set of characters.\\n\\t//cost to delete.\\n\\tint deleteCount = 1 + function(s1, i+1, s2, j); //add 1 to the cost of deleting the current char from string 1 and move to the next character from the first string assuming the current character won\\'t be considered anymore.\\n\\t//cost to add.\\n\\tint addCount = 1 + function(s1, i, s2, j+1);//add 1 to the cost of adding a new character to the second string and compare it with the current character from string 1. \\n```\n```\\nprivate int helper(String s1,  int i, String s2, int j) {\\n        if (i == s1.length()) {\\n            //the first word came to an end.\\n            return s2.length()-j;\\n        } else if (j == s2.length()) {\\n            return s1.length() - i;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper(s1, i+1, s2, j+1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper(s1, i+1, s2, j+1);\\n            //delete.\\n            int deleteCount = 1 + helper(s1, i+1, s2, j);\\n            //add.\\n            int addCount = 1 + helper(s1, i, s2, j+1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n\\t\\t\\nAnd, call it with helper(word1,0,word2,0).\\n```\n```\\n    private int helper_rec(String s1,  int i, String s2, int j) {\\n        if (i < 0) {\\n            //the first word came to an end.\\n            return j+1;\\n        } else if (j < 0) {\\n            return i+1;\\n        } else if (s1.charAt(i) == s2.charAt(j)) {\\n            return helper_rec(s1, i-1, s2, j-1);            \\n        }\\n        else {\\n            //replace.\\n            int replaceCount = 1 + helper_rec(s1, i-1, s2, j-1);\\n            //delete.\\n            int deleteCount = 1 + helper_rec(s1, i-1, s2, j);\\n            //add.\\n            int addCount = 1 + helper_rec(s1, i, s2, j-1);\\n            return Math.min(replaceCount,Math.min(deleteCount, addCount));\\n        }\\n    }\\n```\n```\\n1. For the first part, just create an array with the size of those words.\\nint[][] arr = new int[word1.length()+1][word2.length()+1];\\n\\n2. Initialization is a bit tricky but we could assume that the index \\'0\\' is basically an empty  string and how could we convert a string  to an empty string. Here is how we initialize that part:\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n\\t\\t\\t\\t\\n3. Using recursive condition: it is pretty much straight-foward:\\n //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tThe above is an equivalent of our recursive equation where the position of the index is actually a subscript of an  array.\\n\\t\\t\\t\\n\\t\\t\\t\\nThe only other thing to remember is when the characters match, we want to reuse the last known cost. That\\'s if the characters match at arr[i][j], the new cost will be arr[i-1][j-1] since that will still apply to our next set of iterations.\\n```\n```\\n    public int minDistance(String word1, String word2) {\\n        //return helper_rec(word1, word1.length()-1, word2, word2.length()-1);        \\n        int[][] arr = new int[word1.length()+1][word2.length()+1];\\n        //set the boundary conditions.\\n        for (int i = 0; i<arr.length; i++) {\\n            arr[i][0] = i; \\n        }\\n        \\n        for (int j = 0; j<arr[0].length; j++) {\\n            arr[0][j] = j; \\n        }\\n        \\n         for (int i=1; i<=word1.length();i++){\\n             for (int j=1; j<=word2.length() ;j++) {\\n                 if (word1.charAt(i-1) != word2.charAt(j-1)) {\\n                     //replace.\\n                    int replaceCount = 1 + arr[i-1][j-1];\\n                    //delete.\\n                    int deleteCount = 1 + arr[i-1][j]; \\n                    //add.\\n                    int addCount = 1 + arr[i][j-1];\\n                    arr[i][j] =  Math.min(replaceCount,Math.min(deleteCount, addCount));\\n                 } else {\\n                     arr[i][j] = arr[i-1][j-1];\\n                 }\\n             }\\n         }   \\n        \\n        return arr[word1.length()][word2.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25969,
                "title": "my-clean-java-solution-with-o-n-space-in-17-lines",
                "content": "    public class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int[] d = new int[word2.length() + 1];\\n            for (int i = 0; i <= word2.length(); ++i) d[i] = i;\\n            for (int i = 1; i <= word1.length(); ++i) {\\n                int prev = d[0];\\n                d[0] = i;\\n                for (int j = 1; j <= word2.length(); ++j) {\\n                    int tmp = d[j];\\n                    d[j] = Math.min(d[j - 1], d[j]) + 1;\\n                    d[j] = Math.min(d[j], prev + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\\n                    prev = tmp;\\n                }\\n            }\\n            return d[word2.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minDistance(String word1, String word2) {\\n            int[] d = new int[word2.length() + 1];\\n            for (int i = 0; i <= word2.length(); ++i) d[i] = i;\\n            for (int i = 1; i <= word1.length(); ++i) {\\n                int prev = d[0];\\n                d[0] = i;\\n                for (int j = 1; j <= word2.length(); ++j) {\\n                    int tmp = d[j];\\n                    d[j] = Math.min(d[j - 1], d[j]) + 1;\\n                    d[j] = Math.min(d[j], prev + (word1.charAt(i -1) == word2.charAt(j - 1) ? 0: 1));\\n                    prev = tmp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3230647,
                "title": "look-at-once-solutions-in-java-python-and-c-with-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use dynamic programming. We will create a 2D array to store the minimum number of operations required to convert a substring of word1 to a substring of word2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet dp[i][j] be the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2. We will fill up this 2D array from top to bottom and from left to right.\\n\\nIf `word1[i-1] == word2[j-1]`, then no operation is required to convert `word1[0:i-1]` to `word2[0:j-1]`. Therefore, `dp[i][j] = dp[i-1][j-1]`.\\n\\nIf `word1[i-1] != word2[j-1]`, then we have three options:\\n\\n1. Replace: Replace the i-th character of word1 with the j-th character of word2. `dp[i][j] = dp[i-1][j-1] + 1`.\\n\\n2. Delete: Delete the i-th character of word1.` dp[i][j] = dp[i-1][j] + 1`.\\n\\n3. Insert: Insert the j-th character of word2 into word1. `dp[i][j] = dp[i][j-1] + 1`.\\n\\nThe final answer will be stored in `dp[word1.length()][word2.length()]`.\\n\\n# Video reference\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZkgBinDx9Kg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n![image.png](https://assets.leetcode.com/users/images/2b37d2cc-3ca9-4b0c-866d-48abc59d8fa5_1677216789.1769023.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the dynamic programming solution is $$O(mn)$$, where m and n are the lengths of word1 and word2, respectively. This is because we fill up a 2D array of size (m+1) x (n+1) using nested loops.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nThe space complexity of the dynamic programming solution is $$O(mn)$$, where m and n are the lengths of word1 and word2, respectively. This is because we use a 2D array of size (m+1) x (n+1) to store the minimum number of operations required to convert substrings of word1 to substrings of word2.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int[][] dp = new int[word1.length()+1][word2.length()+1];\\n        \\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= word2.length(); j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i-1) == word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[word1.length()][word2.length()];\\n    }\\n}\\n\\n```\\n```javascript []\\nvar minDistance = function(word1, word2) {\\n    const m = word1.length;\\n    const n = word2.length;\\n    const dp = new Array(m+1).fill(null).map(() => new Array(n+1).fill(null));\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i][0] = i;\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = j;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (word1[i-1] === word2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        for i in range(m+1):\\n            dp[i][0] = i\\n        \\n        for j in range(n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\\n        \\n        return dp[m][n]\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n`````\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int[][] dp = new int[word1.length()+1][word2.length()+1];\\n        \\n        for (int i = 0; i <= word1.length(); i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= word2.length(); j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= word1.length(); i++) {\\n            for (int j = 1; j <= word2.length(); j++) {\\n                if (word1.charAt(i-1) == word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[word1.length()][word2.length()];\\n    }\\n}\\n\\n```\n```javascript []\\nvar minDistance = function(word1, word2) {\\n    const m = word1.length;\\n    const n = word2.length;\\n    const dp = new Array(m+1).fill(null).map(() => new Array(n+1).fill(null));\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i][0] = i;\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = j;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            if (word1[i-1] === word2[j-1]) {\\n                dp[i][j] = dp[i-1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n];\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n+1) for _ in range(m+1)]\\n        \\n        for i in range(m+1):\\n            dp[i][0] = i\\n        \\n        for j in range(n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\\n        \\n        return dp[m][n]\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707160,
                "title": "leetcode-the-hard-way-0072-edit-distance-hard",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=5by6g9bxPW8&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=26) if you are interested.\\n\\n---\\n\\nEdit distance is a classic DP problem. It is used to quantify the dissimilarity of two given strings by counting the minimum possible number of operations required to transform one string into the other. \\n\\nGiven that the constraints, we assume that a O(m * n) solution would pass. \\n\\nLet\\'s define ``dp[i][j]`` as the minimum edit distance between the first i character of ``word1`` and the first ``j`` characters of ``word2``. In example 1, ``dp[3][2]``would be the edit distance between ``word1[1..3]`` (HOR) and ``word2[1..2]``(RO). \\n\\nIf the last character is the same, then ``dp[i][j]`` would be ``dp[i - 1][j - 1]`` because we don\\'t need to perform any operation. Otherwise, we need to perform either one. There are three possible ways to do the transformation.\\n\\n- We can transform ``word1[1..i]`` to ``word2[1..j-1]`` by adding ``word2[j]`` afterwards to get ``word2[1..j]``.\\n- We can transform ``word1[1..i-1]`` to ``word2[1..j]`` by deleting ``word1[i]``.\\n- We can transform ``word1[1..i-1]`` to ``word2[1..j-1]`` by exchanging the original ``word1[i]`` for ``word2[j]``.\\n\\nTherefore, the transition would be ``dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])`` if ``word1[i]`` is not equal to ``word2[j]``.\\n\\nWhat is the base case then? The base case is simply an edit distance between the empty string and non-empty string, i.e. ``dp[i][0] = i`` and ``dp[0][j] = j``. The answer would be ``dp[m][n]``. This algorithm is also known as Wagner\\u2013Fischer algorithm.\\n\\n![image](https://assets.leetcode.com/users/images/00774ca9-da4e-4873-a6c5-9d7596b60b19_1642775600.173192.png)\\n\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = (int) word1.size();\\n        int n = (int) word2.size();\\n        int dp[m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for (int i = 1; i <= m; i++) dp[i][0] = i;\\n        for (int j = 1; j <= n; j++) dp[0][j] = j;\\n        for (int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(word1[i - 1] == word2[j - 1]) { // a = b\\n                    dp[i][j] = dp[i - 1][j - 1]; \\n                } else {\\n                    // find out the min cost for all three actions\\n                    dp[i][j] = 1 + min({\\n                        dp[i - 1][j - 1], // replace a with b\\n                        dp[i - 1][j],     // delete a\\n                        dp[i][j - 1]      // insert b after a\\n                    });\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1): dp[i][0] = i\\n        for j in range(1, n + 1): dp[0][j] = j\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    # a == b\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    # find out the min cost for all three actions\\n                    # dp[i - 1][j - 1]: replace a with b\\n                    # dp[i - 1][j]: delete a\\n                    # dp[i - 1][j]: insert b after a\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\\n        return dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = (int) word1.size();\\n        int n = (int) word2.size();\\n        int dp[m + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for (int i = 1; i <= m; i++) dp[i][0] = i;\\n        for (int j = 1; j <= n; j++) dp[0][j] = j;\\n        for (int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(word1[i - 1] == word2[j - 1]) { // a = b\\n                    dp[i][j] = dp[i - 1][j - 1]; \\n                } else {\\n                    // find out the min cost for all three actions\\n                    dp[i][j] = 1 + min({\\n                        dp[i - 1][j - 1], // replace a with b\\n                        dp[i - 1][j],     // delete a\\n                        dp[i][j - 1]      // insert b after a\\n                    });\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(1, m + 1): dp[i][0] = i\\n        for j in range(1, n + 1): dp[0][j] = j\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if word1[i - 1] == word2[j - 1]:\\n                    # a == b\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                else:\\n                    # find out the min cost for all three actions\\n                    # dp[i - 1][j - 1]: replace a with b\\n                    # dp[i - 1][j]: delete a\\n                    # dp[i - 1][j]: insert b after a\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])\\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402780,
                "title": "begineerfriendly-java-c",
                "content": "**\\nFirstly go and read the code this is further explaination to my code you will get the explaination better after reading the code once\\nand this explaination is also covering the aswer to the comment .\\n\\ni m just checking at every index whether that character is equal or not, if equal I just have to move further  , but in case characters are not equal we can have 3 operations, ins, del, replace. and we are storing the minimum out of these three in the DP array.\\n\\nlet\\'s say s1 as \"abc\" and s2 as \"abd\" ,and we are at index 2, always if found both characters are different \\n\\n// Insertion (dp[i][j-1])\\nI m always inserting at the right of the current char\\n\\ns1 - \"abc\" s2 - \"abd\"\\ni is at c in s1 \\nj is at d in s2.\\n\\nafter insertion\\ns1 become \"abcd\", s2 remain the same \"abd\" ,\\ni is currently at c in s1 \\nand j  is currently at d in s2 , but as we have inserted a \\'d\\' in s1 we have to decrement j , i remains the same \\ni = I;    j = j-1;\\n\\n// deletion   ( dp[i-1][j] )\\n\\n if I chooses to delete c , instead of inserting d  , in this case if I m deleting c then I have to decrement i , but j remains the same.\\ns1 - \"abc\" s2 - \"abd\"\\n          i is at c in s1\\n\\t\\t  j is at d in s2\\n\\t\\t  \\nafter deletion s1 - \"ab\" s2 - \"abd\"\\n          as we have deleted c from s1 we should decrement i , but we will only decrement j once we found character equal to d in s1\\n         I = i-1 , j = j;\\n\\n// replace (dp[i-1][j-1])\\n\\nif I choose to replace i m making the current characters equal then I need to decrement both indices , I, j , because current characters are equal \\nnow we only have to check for remaining string\\n\\nex ----- s1 - \"abc\" s2 - \"abd\"\\nif I choose to replace  \\'c\\'  by  \\'d\\'   then both the strings become\\ns1 ---- \"abd\" s2 ---- \"abd\"\\n              as i is at d in s1 \\n\\t\\t\\t  and also j is at d in s2 , and both the characters are equal we just have to decrement both.\\n   I = i-1 , j = j-1;\\t\\n   \\n   \\n\\t\\nNote we are decrementing j only when both the character matches**\\n\\t\\n\\t//\\tif character matches then just decrement both the index , but if they don\\'t matches then store the minimum possibl;e value by applying\\n\\t\\t// each operation at that particular index.\\n\\t\\t\\n\\t\\tJava code\\n\\t\\t\\t\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic int minDistance(String s1, String s2) {\\n\\t\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\t\\tint[][] dp = new int[n+1][m+1];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int i=0;i<=m;i++){\\n\\t\\t\\t\\t\\t\\tdp[0][i] = i;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\t\\t\\tif(s1.charAt(i-1) == s2.charAt(j-1)){\\n\\t\\t\\t\\t\\t\\t\\t//as characters are the same we are just decreasing the index\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t//chars are not the same now we have to put the minimum ans out of ans obtained by  insertion,deletion,replace  \\n\\t\\t\\t\\t\\t\\t\\t\\t//\\tminimum answer              min(insertion , deletion )          min(deletion,replace)             \\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = 1 + Math.min( Math.min(dp[i][j-1] ,dp[i-1][j]) , Math.min(dp[i-1][j] ,dp[i-1][j-1]) );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn dp[n][m];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t//If the post was helpful please upvote , any query can be asked in the comments\\n\\t\\t\\t//thankyou for your upvote\\n\\t\\t\\t\\n\\t\\t\\t\\nC++ Code --------- Logic is same in both only difference is in syntax............\\n\\n\\t//\\tif character matches then just decrement both the index , but if they don\\'t matches then store the minimum possibl;e value by applying\\n\\t\\t// each operation at that particular index.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\tint dp[n+1][m+1];\\n\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<=m;i++){\\n\\t\\t\\t\\t\\tdp[0][i] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\t\\tfor(int j =1;j<=m;j++){\\n\\t\\t\\t\\t\\t//as characters are the same we are just decreasing the index\\n\\t\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t//chars are not the same now we have to put the minimum ans out of ans obtained by  insertion,deletion,replace \\n\\t//\\tminimum answer    =          min(  min(insertion , deletion )  ,  min(deletion,replace)   )          \\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = 1+ min(min(dp[i][j-1] , dp[i-1][j]) , min(dp[i-1][j-1] , dp[i-1][j-1]));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn dp[n][m];\\n\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//If the post was helpful please upvote , any query can be asked in the comments\\n\\t\\t\\t//thankyou for your upvote\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic int minDistance(String s1, String s2) {\\n\\t\\t\\t\\t\\tint n = s1.length();\\n\\t\\t\\t\\t\\tint m = s2.length();\\n\\t\\t\\t\\t\\tint[][] dp = new int[n+1][m+1];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// base cases will contain the length of string which is not empty\\n\\t\\t\\t\\t\\t//because to convert empty string to another string we need no of operations = length of string\\n\\t\\t\\t\\t\\tfor(int i=0;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tdp[i][0] = i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1391563,
                "title": "c-3-steps-solution-easy-concise-explanation-complexities",
                "content": "* ###  **THIS PROBLEM IS A VERY CLASSICAL PROBLEM OF DP**\\n**EXPLANATION:**\\n1. **`THE IDEA IS VERY VERY SIMPLE, IF YOU UNDERSTAND THE RECURSIVE CODE LOGIC THEN, CONVERT IT INTO DP IS CAKEWALK !!! :)`**\\n\\n1. **`IN THIS PROBLEM WE\\'RE GIVEN A TWO STRINGS \"Word1\" && \"Word2\". WE NEED TO CONVERT FIRST STRING TO SECOND, WITH THE HELP OF THREE OPERATIONS (INSERT, DELETE, REPLACE)..`**\\n\\n1. **`STEP 1: WHEN BOTH CHARACTERS OF STRING MATCHES WE DO NOT HAVE TO DO ANYTHING (ANY OPERATIONS). JUST SIMPLY RECURR FOR NEXT ELEMENTS IN BOTH STRINGS`!**\\n1. **`STEP 2: WHEN CHARACTERS DOESN\\'T MATCH, WE NEED TO DO THREE OPERATIONS THAT IS`:**\\n        **`a) INSERT :  editDist(w1, w2, n, m - 1) :- Decrement second string size, cuz we have to insert character according to second string`** \\n        **`b) DELETE :  editDist(w1, w2, n - 1, m) :- Decrement first string size, cuz we to convert first string to second string =, by deleting characters`** \\n        **`c) REPLACE : editDist(w1, w2, n - 1, m - 1) :- Again, decrement Both string size, cuz let assume we replaced the character of second string with the character                                                    of first string. Hence, both characters are same again.`**  \\n1. **`STEP 3: TAKE THE MINIMUM OF THREE SUB-RESULTS.`**\\n### **RECURSIVE SOLUTION :- T.L.E. (Not Accepted)**\\n```\\n// Recursive Code\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty, simply return second string len. Because, we need atleast second\\n            return m;                       //               string size or len to convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(w1[n - 1] == w2[m - 1])\\n               return editDist(w1, w2, n - 1, m - 1); //  when both characters are matched don\\'t need to do any operations \\n        else               \\n            return 1 + min({editDist(w1, w2, n, m - 1), editDist(w1, w2, n - 1, m), editDist(w1, w2, n - 1, m - 1)});  // When characters Doesn\\'t match \\n    }                                                                                                          // we need to do Three Operations as \\n    int minDistance(string word1, string word2) {                                                          // Mentioned Above & Take the minimum of them\\n        int n = word1.size(), m = word2.size();\\n        return editDist(word1, word2, n, m);\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(3^N)`, Where, `N = (m + n)`, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY : `O(constant)`, ignoring recusrion stack**\\n```\\n```\\n### **DP SOLUTION: TOP-DOWN OR MEMOIZATION (Accepted)**\\n* **Runtime : 10ms**\\n```\\n// Memoized Code (Top-Down)\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m, vector<vector<int>>& memo){\\n        if(n == 0)\\n            return m;\\n        if(m == 0)\\n                return n;\\n        if(memo[n][m] != -1)\\n            return memo[n][m];\\n        if(w1[n - 1] == w2[m - 1]){\\n            memo[n][m] = editDist(w1, w2, n - 1, m - 1, memo); //  when both characters are matched don\\'t need to do any operations\\n            return memo[n][m];\\n        }\\n        else{               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n            memo[n][m] = 1 + min({editDist(w1, w2, n, m - 1, memo), editDist(w1, w2, n - 1, m, memo), editDist(w1, w2, n - 1, m - 1, memo)});\\n            return memo[n][m];\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> memo(n + 1, vector<int> (m + 1, -1));\\n        return editDist(word1, word2, n, m, memo);\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n * m)`, Where, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY : `O(n * m)`, For using 2D array Aux space & Again, ignoring recusrion stack**\\n```\\n```\\n### **DP SOLUTION: BOTTOM-UP OR TABULATION (Accepted)**\\n* **Runtime : 4ms**\\n```\\n// Tabulation Code (Bottom-Up)\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.size(), m = w2.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n        for(int i = 0; i <= n; ++i)     // Base Case 1:\\n            dp[i][0] = i;\\n        \\n        for(int j = 0; j <=m; ++j)      // Base Case 2: \\n            dp[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if(w1[i - 1] == w2[j - 1])          //  when both characters are matched don\\'t need to do any operations\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else                               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n                    dp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n * m)`, Where, n : size of word1 & m  : size of word2** \\n**SPACE COMPLEXITY :  `O(n * m)`, For using 2D array Aux space**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense **Pls Upvote :)**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n// Recursive Code\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty, simply return second string len. Because, we need atleast second\\n            return m;                       //               string size or len to convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(w1[n - 1] == w2[m - 1])\\n               return editDist(w1, w2, n - 1, m - 1); //  when both characters are matched don\\'t need to do any operations \\n        else               \\n            return 1 + min({editDist(w1, w2, n, m - 1), editDist(w1, w2, n - 1, m), editDist(w1, w2, n - 1, m - 1)});  // When characters Doesn\\'t match \\n    }                                                                                                          // we need to do Three Operations as \\n    int minDistance(string word1, string word2) {                                                          // Mentioned Above & Take the minimum of them\\n        int n = word1.size(), m = word2.size();\\n        return editDist(word1, word2, n, m);\\n    }\\n};\\n```\n```\\n```\n```\\n// Memoized Code (Top-Down)\\nclass Solution {\\npublic:\\n    int editDist(string &w1, string &w2, int n, int m, vector<vector<int>>& memo){\\n        if(n == 0)\\n            return m;\\n        if(m == 0)\\n                return n;\\n        if(memo[n][m] != -1)\\n            return memo[n][m];\\n        if(w1[n - 1] == w2[m - 1]){\\n            memo[n][m] = editDist(w1, w2, n - 1, m - 1, memo); //  when both characters are matched don\\'t need to do any operations\\n            return memo[n][m];\\n        }\\n        else{               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n            memo[n][m] = 1 + min({editDist(w1, w2, n, m - 1, memo), editDist(w1, w2, n - 1, m, memo), editDist(w1, w2, n - 1, m - 1, memo)});\\n            return memo[n][m];\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> memo(n + 1, vector<int> (m + 1, -1));\\n        return editDist(word1, word2, n, m, memo);\\n    }\\n};\\n```\n```\\n```\n```\\n// Tabulation Code (Bottom-Up)\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.size(), m = w2.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n        for(int i = 0; i <= n; ++i)     // Base Case 1:\\n            dp[i][0] = i;\\n        \\n        for(int j = 0; j <=m; ++j)      // Base Case 2: \\n            dp[0][j] = j;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j <= m; ++j) {\\n                if(w1[i - 1] == w2[j - 1])          //  when both characters are matched don\\'t need to do any operations\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else                               // When characters Doesn\\'t match we need to do Three Operations as Mentioned Above & Take the minimum of them\\n                    dp[i][j] = 1 + min({dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006113,
                "title": "recursion-and-memoization-aditya-verma-approach",
                "content": "Do upvote, if found helpful.\\n\\nRecursive - \\n\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(a[i]==b[j])\\n        return fun(a,b,i-1,j-1);\\n\\n        else\\n        return 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```\\n\\nMemoization - \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n\\n        if(a[i]==b[j])\\n        return dp[i][j] = fun(a,b,i-1,j-1);\\n\\n        else\\n        return dp[i][j] = 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        dp.clear();\\n        dp.resize(n+1,vector<int> (m+1,-1));\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(a[i]==b[j])\\n        return fun(a,b,i-1,j-1);\\n\\n        else\\n        return 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n\\n    int fun(string a, string b, int i, int j)\\n    {\\n        if(i<0)\\n        return j+1; \\n\\n        if(j<0)\\n        return i+1;\\n\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n\\n        if(a[i]==b[j])\\n        return dp[i][j] = fun(a,b,i-1,j-1);\\n\\n        else\\n        return dp[i][j] = 1 + min(fun(a,b,i-1,j), min(fun(a,b,i,j-1),fun(a,b,i-1,j-1))); \\n    }\\n\\n    \\n    int minDistance(string a, string b) \\n    {\\n        int n = a.size();\\n        int m = b.size();\\n\\n        dp.clear();\\n        dp.resize(n+1,vector<int> (m+1,-1));\\n        return fun(a,b,n-1,m-1);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273352,
                "title": "java-7m-dp-solution-with-detailed-explanation",
                "content": "we use a array ```dist``` to save the minimum distance of substring of ```word1``` and ```word2```, i.e., ```dist[i][j]``` denotes the minimum distance of ```word1.substring(0, i)``` and ```word2.substring(0, j)```.\\nApparently, ```dist[0][j] = j``` and ```dist[i][0] = i```.\\nWhen we calculate ```dist[i][j]```, we first compare ```word1[i]``` and ```word2[j]```, if ```word1[i]``` equals ```word2[j]```, then ```dist[i][j]``` equals ```dist[i - 1][j - 1]```. If ```word1[i] != word2[j]```, then we have three operations:\\n1. replace word1[i] with word2[j] (```dist[i - 1][j - 1] + 1```)\\n2. delete word1[i] (```dist[i - 1][j] + 1```)\\n3. delete word2[j] (```dist[i][j - 1] + 1```)\\n\\nNote that insert and delete are symmetric operations, so we choice 2 is equal to insert character to word2 and choice 3 is equal to insert character to word1.\\n```\\npublic int minDistance(String word1, String word2) {\\n\\tint dist[][] = new int[word1.length() + 1][word2.length() + 1];\\n\\tfor(int i = 0; i < word1.length(); i++) \\n\\t\\tdist[i + 1][0] = i + 1;\\n\\tfor(int i = 0; i < word2.length(); i++)\\n\\t\\tdist[0][i + 1] = i + 1;\\n\\tfor(int i = 0; i < word1.length(); i++) {\\n\\t\\tfor(int j = 0; j < word2.length(); j++) {\\n\\t\\t\\tif( word1.charAt(i) == word2.charAt(j) )\\n\\t\\t\\t\\tdist[i + 1][j + 1] = dist[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdist[i + 1][j + 1] = Math.min(Math.min(dist[i][j + 1], dist[i + 1][j]) + 1, dist[i][j] + 1);\\n\\t\\t}\\n\\t}\\n\\treturn dist[word1.length()][word2.length()];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```dist```\n```word1```\n```word2```\n```dist[i][j]```\n```word1.substring(0, i)```\n```word2.substring(0, j)```\n```dist[0][j] = j```\n```dist[i][0] = i```\n```dist[i][j]```\n```word1[i]```\n```word2[j]```\n```word1[i]```\n```word2[j]```\n```dist[i][j]```\n```dist[i - 1][j - 1]```\n```word1[i] != word2[j]```\n```dist[i - 1][j - 1] + 1```\n```dist[i - 1][j] + 1```\n```dist[i][j - 1] + 1```\n```\\npublic int minDistance(String word1, String word2) {\\n\\tint dist[][] = new int[word1.length() + 1][word2.length() + 1];\\n\\tfor(int i = 0; i < word1.length(); i++) \\n\\t\\tdist[i + 1][0] = i + 1;\\n\\tfor(int i = 0; i < word2.length(); i++)\\n\\t\\tdist[0][i + 1] = i + 1;\\n\\tfor(int i = 0; i < word1.length(); i++) {\\n\\t\\tfor(int j = 0; j < word2.length(); j++) {\\n\\t\\t\\tif( word1.charAt(i) == word2.charAt(j) )\\n\\t\\t\\t\\tdist[i + 1][j + 1] = dist[i][j];\\n\\t\\t\\telse\\n\\t\\t\\t\\tdist[i + 1][j + 1] = Math.min(Math.min(dist[i][j + 1], dist[i + 1][j]) + 1, dist[i][j] + 1);\\n\\t\\t}\\n\\t}\\n\\treturn dist[word1.length()][word2.length()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230529,
                "title": "c-easiest-approach-with-best-explanation-beats-100-using-dp",
                "content": "# Intuition\\nThe problem requires finding the minimum number of operations required to convert one string to another. We can perform three types of operations: insert a character, delete a character, or replace a character.\\n\\nTo solve this problem, we can use dynamic programming. We can create a matrix where the rows represent the characters in the first string and the columns represent the characters in the second string. We can fill the matrix using a bottom-up approach.\\n\\nThe base case is when one of the strings is empty. In this case, the minimum number of operations required is equal to the length of the non-empty string.\\n\\nFor the general case, we can use the following recurrence relation: if the current characters in the two strings match, the minimum number of operations required is the same as the minimum number of operations required to convert the first i-1 characters in the first string to the first j-1 characters in the second string. Otherwise, we can either insert a character, delete a character, or replace a character. We can take the minimum of these three options and add one to get the minimum number of operations required to convert the first i characters in the first string to the first j characters in the second string.\\n\\nThe final answer is stored in the bottom-right corner of the matrix.<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s the step-by-step approach:\\n\\n1. Initialize a matrix dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2, respectively.\\n2. Fill in the base cases:\\ndp[i][0] = i for i from 0 to m.\\ndp[0][j] = j for j from 0 to n.\\n3. For each i from 1 to m and each j from 1 to n, compute the value of dp[i][j] as follows:\\n4. If word1[i-1] is equal to word2[j-1], then dp[i][j] = dp[i-1][j-1]. Otherwise, dp[i][j] is the minimum of the following three values plus 1:\\na) dp[i][j-1], which represents inserting a character in word1.\\nb) dp[i-1][j], which represents deleting a character in word1.\\nc) dp[i-1][j-1], which represents replacing a character in word1.\\n5. Return dp[m][n], which is the minimum number of operations required to convert word1 to word2.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(mn), where m and n are the lengths of the input strings. This is because we need to fill in an (m+1) x (n+1) matrix, and each cell takes constant time to fill.\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = 1 + min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]});\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n//\\uD83D\\uDC47please upvote if you liked my approach and explanation\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;\\n        }\\n        \\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i-1] == word2[j-1]) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    dp[i][j] = 1 + min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]});\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n//\\uD83D\\uDC47please upvote if you liked my approach and explanation\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176745,
                "title": "python-recursive-memoization-tabular-dp-with-detailed-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/ebd26aeb-c4c8-45bd-90cb-1d01670b37b9_1655779370.086117.jpeg)\\n![image](https://assets.leetcode.com/users/images/8114c2a7-9765-4868-a01c-76eccc8d6c0f_1655779380.6150026.jpeg)\\n![image](https://assets.leetcode.com/users/images/fbf87ad1-e78e-4e9c-9c5f-d4b95385bf98_1655779388.4014256.jpeg)\\n\\n\\n\\n**Recursive**:\\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        def solve(w1, w2, n, m): \\n            # Base Case if any one of w1 or w2 is empty \\n            if n == 0 or m == 0: return m or n\\n            \\n            elif w1[n-1] == w2[m-1]:\\n                return solve(w1, w2, n-1, m-1)\\n            \\n            else:\\n                return 1 + min(\\n                                solve(w1, w2, n-1, m-1),  # Replace\\n                                solve(w1, w2, n-1, m),    # Delete\\n                                solve(w1, w2, n, m-1)     # Insert\\n                                )\\n        \\n        return solve(w1, w2, len(w1), len(w2))\\n    \\n\\n# Time Limit Exceeded\\n# We need to use Memoization in this Solution to avoid repetative same calculation of sub-problems\\n```\\n\\n**Memoization**:\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        memo = {}\\n        \\n        def dfs(i, j):\\n            if i == 0 or j == 0: return j or i\\n                        \\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            \\n            if word1[i-1] == word2[j-1]:\\n                ans = dfs(i-1, j-1)\\n            else: \\n                ans = 1 + min(dfs(i, j-1), dfs(i-1, j), dfs(i-1, j-1))\\n                \\n            memo[(i,j)] = ans\\n            return memo[(i,j)]\\n        \\n        return dfs(len(word1), len(word2))\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\\n\\n\\n**Tabular DP**:\\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        n = len(w1); m = len(w2)\\n        \\n        dp = [[0]*(m+1) for i in range(n+1)]\\n        \\n        for j in range(m+1): # Base Case 0th row where len(w1) = 0\\n            dp[0][j] = j\\n        \\n        for i in range(n+1): # Base Case 0th column where len(w2) = 0\\n            dp[i][0] = i\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if w1[i-1] == w2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(\\n                                        dp[i-1][j-1],  # Replace \\n                                        dp[i-1][j],    # Delete\\n                                        dp[i][j-1]     # Insert\\n                                        )\\n        \\n        return dp[-1][-1]\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\\n\\nAll Concepts of DP: **https://github.com/SamirPaul1/DSAlgo/tree/main/02_Dynamic-Programming**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        def solve(w1, w2, n, m): \\n            # Base Case if any one of w1 or w2 is empty \\n            if n == 0 or m == 0: return m or n\\n            \\n            elif w1[n-1] == w2[m-1]:\\n                return solve(w1, w2, n-1, m-1)\\n            \\n            else:\\n                return 1 + min(\\n                                solve(w1, w2, n-1, m-1),  # Replace\\n                                solve(w1, w2, n-1, m),    # Delete\\n                                solve(w1, w2, n, m-1)     # Insert\\n                                )\\n        \\n        return solve(w1, w2, len(w1), len(w2))\\n    \\n\\n# Time Limit Exceeded\\n# We need to use Memoization in this Solution to avoid repetative same calculation of sub-problems\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        memo = {}\\n        \\n        def dfs(i, j):\\n            if i == 0 or j == 0: return j or i\\n                        \\n            if (i,j) in memo:\\n                return memo[(i,j)]\\n            \\n            if word1[i-1] == word2[j-1]:\\n                ans = dfs(i-1, j-1)\\n            else: \\n                ans = 1 + min(dfs(i, j-1), dfs(i-1, j), dfs(i-1, j-1))\\n                \\n            memo[(i,j)] = ans\\n            return memo[(i,j)]\\n        \\n        return dfs(len(word1), len(word2))\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```\n```\\nclass Solution:\\n    def minDistance(self, w1: str, w2: str) -> int:\\n        n = len(w1); m = len(w2)\\n        \\n        dp = [[0]*(m+1) for i in range(n+1)]\\n        \\n        for j in range(m+1): # Base Case 0th row where len(w1) = 0\\n            dp[0][j] = j\\n        \\n        for i in range(n+1): # Base Case 0th column where len(w2) = 0\\n            dp[i][0] = i\\n        \\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if w1[i-1] == w2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(\\n                                        dp[i-1][j-1],  # Replace \\n                                        dp[i-1][j],    # Delete\\n                                        dp[i][j-1]     # Insert\\n                                        )\\n        \\n        return dp[-1][-1]\\n\\t\\t\\n# Time: O(N^2)\\n# Space: O(N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695493,
                "title": "dp-solution-easy-fast",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        #dp[i][j] will be the least distance from word1[:i] to word2[:j]\\n        dp = [[0 for _ in range(len(word2)+1)] for _ in range(len(word1)+1)]\\n        for i in range(len(word1)+1):\\n            dp[i][0] = i\\n            for j in range(1,len(word2)+1):\\n                if i == 0:\\n                    dp[0][j] = j\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1\\n        return dp[-1][-1]  \\n                                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        #dp[i][j] will be the least distance from word1[:i] to word2[:j]\\n        dp = [[0 for _ in range(len(word2)+1)] for _ in range(len(word1)+1)]\\n        for i in range(len(word1)+1):\\n            dp[i][0] = i\\n            for j in range(1,len(word2)+1):\\n                if i == 0:\\n                    dp[0][j] = j\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1\\n        return dp[-1][-1]  \\n                                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232992,
                "title": "3-best-approaches-recursion-memorization-tabulation",
                "content": "# Please upvote if you like these solutions\\n\\n# Approach\\n**Recursive Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(3^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         return minDistanceRec(word1, word2, n, m);\\n     }\\n\\n     public int minDistanceRec(String word1,  String word2, int n, int m) {\\n         if(n == 0 || m == 0){\\n             return n == 0 ? m : n;\\n         }\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             return minDistanceRec(word1, word2, n - 1, m - 1);\\n         }\\n         else{\\n             int replace = minDistanceRec(word1, word2, n - 1, m - 1);\\n             int delete = minDistanceRec(word1, word2, n - 1, m);\\n             int insert = minDistanceRec(word1, word2, n, m - 1);\\n             return Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n     }\\n }\\n\\n```\\n\\n\\n---\\n\\n\\n# Approach\\n**Memorization Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         int [][] memo = new int [n + 1][m + 1];\\n         for(int [] d : memo)\\n             Arrays.fill(d, -1);\\n\\n         return minDistanceMemo(word1, word2, n, m, memo);\\n     }\\n\\n     public int minDistanceMemo(String word1,  String word2, int n, int m, int [][] memo) {\\n         if(n == 0 || m == 0){\\n             return memo[n][m] = n == 0 ? m : n;\\n         }\\n\\n         if(memo[n][m] != -1)\\n             return memo[n][m];\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             memo[n][m] = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n         }\\n         else{\\n             int replace = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n             int delete = minDistanceMemo(word1, word2, n - 1, m, memo);\\n             int insert = minDistanceMemo(word1, word2, n, m - 1, memo);\\n             memo[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n         return memo[n][m];\\n     }\\n }\\n\\n```\\n\\n\\n---\\n\\n\\n# Approach\\n**Tabulation Approach**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n\\n        int [][] dp = new int [n + 1][m + 1];\\n        for(int [] d : dp)\\n            Arrays.fill(d, -1);\\n\\n        return minDistanceTab(word1, word2, n, m, dp);\\n    }\\n\\n    public int minDistanceTab(String word1,  String word2, int N, int M, int [][] dp) {\\n        for(int n = 0; n <= N; n++){\\n            for(int m = 0; m <= M; m++){\\n                if(n == 0 || m == 0){\\n                    dp[n][m] = n == 0 ? m : n;\\n                    continue;\\n                }\\n\\n                if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n                    dp[n][m] = dp[n - 1][m - 1];\\n                }\\n                else{\\n                    int replace = dp[n - 1][m - 1];;\\n                    int delete = dp[n - 1][m];;\\n                    int insert = dp[n][m - 1];;\\n                    dp[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n                }\\n            }\\n        }\\n        return dp[N][M];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         return minDistanceRec(word1, word2, n, m);\\n     }\\n\\n     public int minDistanceRec(String word1,  String word2, int n, int m) {\\n         if(n == 0 || m == 0){\\n             return n == 0 ? m : n;\\n         }\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             return minDistanceRec(word1, word2, n - 1, m - 1);\\n         }\\n         else{\\n             int replace = minDistanceRec(word1, word2, n - 1, m - 1);\\n             int delete = minDistanceRec(word1, word2, n - 1, m);\\n             int insert = minDistanceRec(word1, word2, n, m - 1);\\n             return Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n     }\\n }\\n\\n```\n```\\n class Solution {\\n     public int minDistance(String word1, String word2) {\\n         int n = word1.length();\\n         int m = word2.length();\\n\\n         int [][] memo = new int [n + 1][m + 1];\\n         for(int [] d : memo)\\n             Arrays.fill(d, -1);\\n\\n         return minDistanceMemo(word1, word2, n, m, memo);\\n     }\\n\\n     public int minDistanceMemo(String word1,  String word2, int n, int m, int [][] memo) {\\n         if(n == 0 || m == 0){\\n             return memo[n][m] = n == 0 ? m : n;\\n         }\\n\\n         if(memo[n][m] != -1)\\n             return memo[n][m];\\n\\n         if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n             memo[n][m] = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n         }\\n         else{\\n             int replace = minDistanceMemo(word1, word2, n - 1, m - 1, memo);\\n             int delete = minDistanceMemo(word1, word2, n - 1, m, memo);\\n             int insert = minDistanceMemo(word1, word2, n, m - 1, memo);\\n             memo[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n         }\\n         return memo[n][m];\\n     }\\n }\\n\\n```\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n\\n        int [][] dp = new int [n + 1][m + 1];\\n        for(int [] d : dp)\\n            Arrays.fill(d, -1);\\n\\n        return minDistanceTab(word1, word2, n, m, dp);\\n    }\\n\\n    public int minDistanceTab(String word1,  String word2, int N, int M, int [][] dp) {\\n        for(int n = 0; n <= N; n++){\\n            for(int m = 0; m <= M; m++){\\n                if(n == 0 || m == 0){\\n                    dp[n][m] = n == 0 ? m : n;\\n                    continue;\\n                }\\n\\n                if(word1.charAt(n - 1) == word2.charAt(m - 1)){\\n                    dp[n][m] = dp[n - 1][m - 1];\\n                }\\n                else{\\n                    int replace = dp[n - 1][m - 1];;\\n                    int delete = dp[n - 1][m];;\\n                    int insert = dp[n][m - 1];;\\n                    dp[n][m] = Math.min(replace, Math.min(delete, insert)) + 1;\\n                }\\n            }\\n        }\\n        return dp[N][M];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230538,
                "title": "python3-easy-solution",
                "content": "**Python3 Solution**\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        # base case - i steps away\\n        for i in range(1, m + 1):\\n            dp[i][0] = i\\n        for j in range(1, n + 1):\\n            dp[0][j] = j\\n        # each step has four possibilities\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # same character, i and j move ahead together\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                # find min of insert, replace, remove a character\\n                else:\\n                    dp[i][j] = min(\\n                        dp[i - 1][j] + 1,\\n                        dp[i][j - 1] + 1,\\n                        dp[i - 1][j - 1] + 1\\n                    )\\n        \\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        # base case - i steps away\\n        for i in range(1, m + 1):\\n            dp[i][0] = i\\n        for j in range(1, n + 1):\\n            dp[0][j] = j\\n        # each step has four possibilities\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                # same character, i and j move ahead together\\n                if word1[i - 1] == word2[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                # find min of insert, replace, remove a character\\n                else:\\n                    dp[i][j] = min(\\n                        dp[i - 1][j] + 1,\\n                        dp[i][j - 1] + 1,\\n                        dp[i - 1][j - 1] + 1\\n                    )\\n        \\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736119,
                "title": "dp-4-approaches-recursion-memoization-tabulation-and-space-optimization",
                "content": "**Approach 1 : Recursion**\\n\\n```\\nint solve(int i, int j, string &str1, string &str2){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(str1[i]==str2[j]){\\n            return solve(i-1,j-1,str1,str2);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2);\\n            int deleted = 1 + solve(i-1,j,str1,str2);\\n            int replace = 1 + solve(i-1,j-1,str1,str2);\\n            return min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        return solve(n-1,m-1,word1,word2);\\n    }\\n```\\n\\nTime : exponential\\nSpace : O(m+n) for stack space     => m = word1.size() and n = word2.size()\\n\\n**Approach 2 : Memoization**\\n\\n```\\nint solve(int i, int j, string &str1, string &str2, vector<vector<int>>&dp){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(str1[i]==str2[j]){\\n            return dp[i][j] = solve(i-1,j-1,str1,str2,dp);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2,dp);\\n            int deleted = 1 + solve(i-1,j,str1,str2,dp);\\n            int replace = 1 + solve(i-1,j-1,str1,str2,dp);\\n            return dp[i][j] = min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m+n) stack space and O(m.n)  for dp space\\n\\n**Approach 3 : Tabulation**\\n\\n```\\n       int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n       \\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=1;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n       \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insert = 1 + dp[i][j-1];\\n                    int deleted = 1 + dp[i-1][j];\\n                    int replace = 1 + dp[i-1][j-1];\\n                    dp[i][j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m.n)  for dp space\\n\\n**Approach 4 : Space optimized to O(m) **\\n\\n```\\n     int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<int>prev(m+1,0),curr(m+1,0);\\n        \\n        for(int i=0;i<m+1;i++){\\n            prev[i]=i;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            curr[0] = i;\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    curr[j] = prev[j-1];\\n                else{\\n                    int insert = 1 + curr[j-1];\\n                    int deleted = 1 + prev[j];\\n                    int replace = 1 + prev[j-1];\\n                    curr[j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m];\\n    }\\n```\\n\\nTime : O(m.n)   => m = word1.size() and n = word2.size()\\nSpace : O(m)  for dp \\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(int i, int j, string &str1, string &str2){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(str1[i]==str2[j]){\\n            return solve(i-1,j-1,str1,str2);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2);\\n            int deleted = 1 + solve(i-1,j,str1,str2);\\n            int replace = 1 + solve(i-1,j-1,str1,str2);\\n            return min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        return solve(n-1,m-1,word1,word2);\\n    }\\n```\n```\\nint solve(int i, int j, string &str1, string &str2, vector<vector<int>>&dp){     \\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(str1[i]==str2[j]){\\n            return dp[i][j] = solve(i-1,j-1,str1,str2,dp);\\n        }\\n        else{\\n            int insert = 1 + solve(i,j-1,str1,str2,dp);\\n            int deleted = 1 + solve(i-1,j,str1,str2,dp);\\n            int replace = 1 + solve(i-1,j-1,str1,str2,dp);\\n            return dp[i][j] = min(min(insert,deleted),replace);\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n```\n```\\n       int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n       \\n        for(int i=0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=1;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n       \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int insert = 1 + dp[i][j-1];\\n                    int deleted = 1 + dp[i-1][j];\\n                    int replace = 1 + dp[i-1][j-1];\\n                    dp[i][j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```\\n     int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        vector<int>prev(m+1,0),curr(m+1,0);\\n        \\n        for(int i=0;i<m+1;i++){\\n            prev[i]=i;\\n        }\\n        for(int i=1;i<n+1;i++){\\n            curr[0] = i;\\n            for(int j=1;j<m+1;j++){\\n                if(word1[i-1]==word2[j-1])\\n                    curr[j] = prev[j-1];\\n                else{\\n                    int insert = 1 + curr[j-1];\\n                    int deleted = 1 + prev[j];\\n                    int replace = 1 + prev[j-1];\\n                    curr[j] = min(min(insert,deleted),replace);                    \\n                }        \\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605989,
                "title": "lcs-explained-python-c-javascript",
                "content": "* We can use **longest common subsequence** method with little bit modification.\\n* In **LCS** we only check that the corresponding letter is equal or not and according to it we fill out the matrix cell.\\n* Here in this problem we have to perform **three types** of operations so every cell of the dp matrix will be filled out with the operation that has **minimum step**.\\n* `if  word1[i-1] == word2[j-1]:`\\n\\t* ` dp[i][j] = dp[i][j] = dp[i-1][j-1]` means both letters are same so we don\\'t need to perform any operation so number of steps will remain same as previous step.\\n* `if word1[i-1] != word2[j-1]:`\\n\\t* case 1: we will replace the current letter of word1 with current letter of word2 --> `dp[i-1][j-1] + 1` steps.\\n\\t* case 2: we have reached at the end of word2 but in word1 there is an extra letter that we have to delete from word1 -->` dp[i-1][j] + 1` steps.\\n\\t* case 3: we have reached at the end of the word1 but there is an extra letter in word2 that we have to insert in word1 --> `dp[i][j-1] + 1` steps.\\n\\t* `dp[i][j] = min(case1, case2, case3)`\\n--------------------\\n<iframe src=\"https://leetcode.com/playground/XwdC88g8/shared\" frameBorder=\"0\" width=\"800\" height=\"520\"></iframe>\\n\\n-----------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "* We can use **longest common subsequence** method with little bit modification.\\n* In **LCS** we only check that the corresponding letter is equal or not and according to it we fill out the matrix cell.\\n* Here in this problem we have to perform **three types** of operations so every cell of the dp matrix will be filled out with the operation that has **minimum step**.\\n* `if  word1[i-1] == word2[j-1]:`\\n\\t* ` dp[i][j] = dp[i][j] = dp[i-1][j-1]` means both letters are same so we don\\'t need to perform any operation so number of steps will remain same as previous step.\\n* `if word1[i-1] != word2[j-1]:`\\n\\t* case 1: we will replace the current letter of word1 with current letter of word2 --> `dp[i-1][j-1] + 1` steps.\\n\\t* case 2: we have reached at the end of word2 but in word1 there is an extra letter that we have to delete from word1 -->` dp[i-1][j] + 1` steps.\\n\\t* case 3: we have reached at the end of the word1 but there is an extra letter in word2 that we have to insert in word1 --> `dp[i][j-1] + 1` steps.\\n\\t* `dp[i][j] = min(case1, case2, case3)`\\n--------------------\\n<iframe src=\"https://leetcode.com/playground/XwdC88g8/shared\" frameBorder=\"0\" width=\"800\" height=\"520\"></iframe>\\n\\n-----------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "codeTag": "Unknown"
            },
            {
                "id": 1821599,
                "title": "easy-solution-dp-based-c-95-fast-solution",
                "content": "```\\n  int minDistance(string word1, string word2) {\\n        \\n        int m=word1.length(),n=word2.length();\\n        \\n        int dp[m+1][n+1];\\n        \\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=i;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=i;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = 1+ min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1]));\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n  int minDistance(string word1, string word2) {\\n        \\n        int m=word1.length(),n=word2.length();\\n        \\n        int dp[m+1][n+1];\\n        \\n        for(int i=0;i<=m;i++)\\n            dp[i][0]=i;\\n        \\n        for(int i=0;i<=n;i++)\\n            dp[0][i]=i;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = 1+ min(dp[i][j - 1], min(dp[i - 1][j], dp[i - 1][j - 1]));\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262290,
                "title": "maybe-better-than-o-mn-heap-solution-python-beats-99-o-m-n-log-m-n-not-sure",
                "content": "![image](https://assets.leetcode.com/users/images/1e61e11a-f3e8-4d0a-92c3-f2565c7360b0_1623299142.487367.png)\\n\\n\\nKeep a minheap and chop off 1 character at a time. To avoid using too much space with substring splicing, we can move pointers `i` and `j` instead.\\n\\nKeep a minheap with items in there form `(distance, i, j)`\\nWhere `word1[:i]` and `word[:j]` have an edit distance of `distance`\\n\\n1. Pop from the heap to give current lowest edit distance and string index pair\\n2. If word1 and word2 from pointers  `i` and `j`  are **both exactly exact same**:\\n\\t=>  return the `distance` , don\\'t need to increment the distance anymore\\n\\t\\n3. Do the following if `i` and `j` are unvisited (if we are visiting the same `i` and `j` again, that means the distance is not lower than previously seen, so we should ignore it)\\n\\t4.  if the characters at `i` and `j` match, **no change needed** , increment both word pointers but keep distance the same\\n\\t5.  Otherwise, increment distance and:\\n\\t\\t6. Add **delete from word1** case (`i+1`)\\n\\t\\t7. Add **delete from word2** case (`j+1`)\\n\\t\\t8. Add **replace current character** case (`i+1`) and (`j+1`)\\n\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        heap = [(0, 0, 0)]\\n        seen = set()\\n        \\n        while heap:\\n            distance, i, j = heappop(heap)\\n            if word1[i:] == word2[j:]:\\n                return distance\\n\\t\\t\\n            if ((i, j) not in seen):\\n                seen.add((i, j))\\n                if (i < m and j < n and word1[i] == word2[j]):\\n                    heappush(heap, (distance, i+1, j+1))\\n                else:\\n                    for di, dj in (1,0), (0,1), (1,1):\\n                        next_i, next_j = i+di, j+dj\\n                        if (next_i <= m and next_j <= n):\\n                            heappush(heap, (distance+1, next_i, next_j))\\n```\\n\\n\\n**Time complexity**\\n\\nAssuming length of `word1` is `m` and length of `word2` is `n`\\nFor each of the `m` characters and `n` that modify the heap at most 3 times. Thus the heap size can be at most `(m+n)*3` = `m+n`\\n\\nThus all heap operations are  `O(log(m+n))`\\nWhich is done for all `m+n` items thus `O((m+n)log(m+n))`\\nIf this is true, than this is better than the typical `O(mn)` DP solution.\\nThough it might just be `O(mn*log(mn))` with a good average case...\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        heap = [(0, 0, 0)]\\n        seen = set()\\n        \\n        while heap:\\n            distance, i, j = heappop(heap)\\n            if word1[i:] == word2[j:]:\\n                return distance\\n\\t\\t\\n            if ((i, j) not in seen):\\n                seen.add((i, j))\\n                if (i < m and j < n and word1[i] == word2[j]):\\n                    heappush(heap, (distance, i+1, j+1))\\n                else:\\n                    for di, dj in (1,0), (0,1), (1,1):\\n                        next_i, next_j = i+di, j+dj\\n                        if (next_i <= m and next_j <= n):\\n                            heappush(heap, (distance+1, next_i, next_j))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854887,
                "title": "diagram-explanation-recursion-memoization-dp-o-3-n-to-o-n-m",
                "content": "# Recursive Solution (Naive Approach)\\n## How ?\\n\\n1. Pure Recursive Approach (`PureRecursive` function):\\nThe `PureRecursive` function calculates the minimum edit distance between two strings `word1` and `word2` using a purely recursive approach. It tries to find the minimum number of operations (insert, delete, or replace) required to convert `word1` into `word2`. The function starts from the last characters of both strings and recursively checks if the characters are the same or different. If they are the same, it moves to the previous characters and continues the comparison. If they are different, it explores all three possible operations (insert, delete, replace) and calculates the minimum distance for each case. The function returns the minimum distance obtained.\\n\\nTime complexity: Exponential. Since for each character in `word1`, the function has three recursive calls (insert, delete, replace), the time complexity grows exponentially with the length of the strings.\\n\\nSpace complexity: O(m+n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The space complexity is determined by the depth of the recursive calls and the maximum size of the function call stack.\\n\\n```\\nint PureRecursive(string &word1, string &word2,int m, int n){\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        if(word1[m-1] == word2[n-1]){\\n            return PureRecursive(word1,word2,m-1,n-1);\\n        }\\n        else{\\n            return 1 + min(PureRecursive(word1,word2,m-1,n-1),min(PureRecursive(word1,word2,m-1,n),PureRecursive(word1,word2,m,n-1)));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> dp(word1.size() + 1, std::vector<int>(word2.size() + 1, -1));\\n        return bottomUpDp(word1,word2,word1.size(),word2.size(),dp);\\n    }\\n};\\n\\n```\\n\\n# Memoization Approach\\n\\n## How?\\nThe given function `recur` is a recursive solution to the Minimum Edit Distance problem with memoization  (also known as memoization). It calculates the minimum edit distance between two strings `word1` and `word2`.\\n\\nThe function takes the following parameters:\\n- `word1`: A reference to the first string.\\n- `word2`: A reference to the second string.\\n- `m`: The current index in `word1` (0-based).\\n- `n`: The current index in `word2` (0-based).\\n- `dp`: A 2D vector representing the memoization table to store intermediate results.\\n\\nThe idea behind the memoization approach is to store the results of subproblems in the `dp` table to avoid redundant computations. This way, if we encounter the same subproblem during the recursion, we can directly use the precomputed value from the `dp` table instead of recalculating it.\\n\\nHere\\'s how the function works:\\n1. Base cases:\\n   - If `m` (index in `word1`) becomes 0, it means we have processed all characters in `word1`, so we return the remaining length of `word2` (`n`). This is because, at this point, we would need to insert `n` characters from `word2` into `word1` to match them.\\n   - If `n` (index in `word2`) becomes 0, it means we have processed all characters in `word2`, so we return the remaining length of `word1` (`m`). This is because, at this point, we would need to delete `m` characters from `word1` to match them with the empty string.\\n\\n2. Check if the result for the current subproblem exists in the `dp` table (`dp[m - 1][n - 1]`). If it does, we directly return the precomputed value, avoiding redundant computation.\\n\\n3. If the characters at the current indices (`word1[m - 1]` and `word2[n - 1]`) are equal, it means no edit is required, and we can move on to the previous characters (index `m - 1` and `n - 1`) to find the solution for the subproblem. We recursively call `recur(word1, word2, m - 1, n - 1, dp)` to compute the minimum edit distance for this case.\\n\\n4. If the characters at the current indices are different, it means we have three options: insert, delete, or replace a character to make the strings similar. We recursively call `recur` for each option and compute the minimum edit distance among them. The result is stored in the `dp` table (`dp[m - 1][n - 1]`) for future reference.\\n\\n5. Finally, we return the computed value for the current subproblem.\\n\\nOverall, the memoization approach reduces the time complexity by avoiding redundant calculations of the same subproblems and improves the performance compared to the pure recursive solution.\\n\\nPlease note that before calling the `recur` function, you need to initialize the `dp` table with `-1` to indicate that the results for subproblems are not yet computed. The `minDistance` function takes care of this initialization and calls the `recur` function with the appropriate arguments.\\n\\nMemoizationn Table:\\n\\n\\n|     | e | x | e | c | u | t | i | o | n |\\n|-----|---|---|---|---|---|---|---|---|---|\\n| i   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| t   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| e   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| t   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| i   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| o   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n| n   | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |\\n\\nIn this table, the headers for both rows and columns represent the characters from \"intention\" and \"execution.\" The cells are filled with -1, indicating that the minimum edit distance has not been computed for any of the substrings yet.\\n\\nConverts to :\\n<body>\\n    <table>\\n        <tr>\\n            <td></td>\\n            <td>e</td>\\n            <td>x</td>\\n            <td>e</td>\\n            <td>c</td>\\n            <td>u</td>\\n            <td>t</td>\\n            <td>i</td>\\n            <td>o</td>\\n            <td>n</td>\\n            <td>-</td>\\n        </tr>\\n        <tr>\\n            <td>i</td>\\n            <td>1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td>2</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>t</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>e</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td style=\"background-color: grey\">4</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>t</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>i</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>o</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td>5</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>n</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: skyblue; color : black;\">5<sup>(m-1,n-1)</sup></td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n        <tr>\\n            <td>-</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n            <td style=\"background-color: grey\">-1</td>\\n        </tr>\\n    </table>\\n</body>\\n</html>\\n\\nMemoization Solution\\n\\n```\\nint Memoization(string &word1, string &word2,int m, int n,vector<vector<int>>&mem){\\n            if (m == 0)\\n                return n; //If the word1 length becomes zero, obvious that we are left with the cost of n\\n            if (n == 0)\\n                return m; //If the word2 length becomes zero, obvious that we are left with the cost of m\\n\\n            if (mem[m - 1][n - 1] != -1)\\n                return mem[m - 1][n - 1];\\n\\n            if (word1[m - 1] == word2[n - 1])\\n            {\\n                mem[m - 1][n - 1] = Memoization(word1, word2, m - 1, n - 1, mem);\\n                return mem[m - 1][n - 1];\\n            }\\n            else\\n            {\\n                mem[m - 1][n - 1] = 1 + min(Memoization(word1, word2, m - 1, n - 1, mem), min(Memoization(word1, word2, m - 1, n, mem), Memoization(word1, word2, m, n - 1, mem)));\\n                return mem[m - 1][n - 1];\\n            }\\n        }\\n\\n```\\n\\n# DP Solution :\\n## How ?\\n1. Bottom-Up Dynamic Programming Approach (`minDistance` function):\\nThe `minDistance` function calculates the minimum edit distance between two strings `word1` and `word2` using the Bottom-Up Dynamic Programming approach. It creates a DP table (2D array) of size `(m+1) x (n+1)` to store the minimum edit distance values for all subproblems.\\n\\nThe idea behind the Bottom-Up DP approach is to fill the DP table from smaller subproblems to the larger ones iteratively, avoiding redundant computations. The DP table `dp[i][j]` represents the minimum edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`.\\n\\nThe DP table is filled in a bottom-up manner as follows:\\n- For `i = 0` or `j = 0`, `dp[i][j]` is initialized to `i` or `j`, respectively. This is because the minimum edit distance between an empty string and a string of length \\'x\\' is \\'x\\' (number of insertions or deletions needed).\\n- For `i > 0` and `j > 0`, if `word1[i-1]` is equal to `word2[j-1]`, then there is no edit needed, and `dp[i][j]` is set to `dp[i-1][j-1]`.\\n- If `word1[i-1]` is not equal to `word2[j-1]`, then `dp[i][j]` is calculated as the minimum of three cases: \\n    1. Replace: `1 + dp[i-1][j-1]`\\n    2. Insert: `1 + dp[i][j-1]`\\n    3. Delete: `1 + dp[i-1][j]`\\n\\nThe final answer is stored in `dp[m][n]`, which represents the minimum edit distance between the entire `word1` and `word2`.\\n\\nTime complexity: O(m * n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The DP table is filled iteratively in a bottom-up manner, so each cell takes constant time to compute.\\n\\nSpace complexity: O(m * n), where \\'m\\' is the length of `word1` and \\'n\\' is the length of `word2`. The DP table of size `(m+1) x (n+1)` is used to store the intermediate results.\\nTable will look like this after the Complete assignment\\n<body>\\n    <table>\\n        <tr>\\n            <th> </th>\\n            <th>0</th>\\n            <th>1</th>\\n            <th>2</th>\\n            <th>3</th>\\n            <th>4</th>\\n            <th>5</th>\\n            <th>6</th>\\n            <th>7</th>\\n            <th>8</th>\\n            <th>9</th>\\n        </tr>\\n        <tr>\\n            <th>0</th>\\n            <td>0</td>\\n            <td>1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n            <td>9</td>\\n        </tr>\\n        <tr>\\n            <th>1</th>\\n            <td>1</td>\\n            <td style=\"background-color: gray; color: black;\">1</td>\\n            <td>2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>2</th>\\n            <td>2</td>\\n            <td>2</td>\\n            <td style=\"background-color: gray; color: black;\">2</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>3</th>\\n            <td>3</td>\\n            <td>3</td>\\n            <td>3</td>\\n            <td style=\"background-color: gray; color: black;\">3</td>\\n            <td>4</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>4</th>\\n            <td>3</td>\\n            <td>4</td>\\n            <td>3</td>\\n            <td>4</td>\\n            <td style=\"background-color: gray; color: black;\">4</td>\\n            <td>5</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>5</th>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td>4</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>6</th>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td>5</td>\\n            <td style=\"background-color: gray; color: black;\">6</td>\\n            <td>7</td>\\n            <td>8</td>\\n            <td>8</td>\\n        </tr>\\n        <tr>\\n            <th>7</th>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td>6</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n            <td>7</td>\\n        </tr>\\n        <tr>\\n            <th>8</th>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>7</td>\\n            <td>6</td>\\n            <td style=\"background-color: gray; color: black;\">5</td>\\n            <td>6</td>\\n        </tr>\\n        <tr>\\n            <th>9</th>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>8</td>\\n            <td>7</td>\\n            <td>6</td>\\n            <td style=\"background-color: skyblue; color : black;\">5<sup>(m,n)</sup></td>\\n        </tr>\\n    </table>\\n</body>\\n</html>\\n\\n## Code :\\n\\n```\\nclass Solution {\\npublic:\\n    int bottomUpDp(string &word1, string &word2, int m, int n, vector<vector<int>>& dp){\\n        // Initialize base cases\\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;   //rows\\n        }\\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;   //columns\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));\\n                // Carefully observe the recursive code is converted to iterative approach which tries to find the solution in dp table instead of recursive calls\\n                }\\n            }\\n\\n        }\\n\\n        return dp[m][n];\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint PureRecursive(string &word1, string &word2,int m, int n){\\n        if(m == 0) return n;\\n        if(n == 0) return m;\\n        if(word1[m-1] == word2[n-1]){\\n            return PureRecursive(word1,word2,m-1,n-1);\\n        }\\n        else{\\n            return 1 + min(PureRecursive(word1,word2,m-1,n-1),min(PureRecursive(word1,word2,m-1,n),PureRecursive(word1,word2,m,n-1)));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>> dp(word1.size() + 1, std::vector<int>(word2.size() + 1, -1));\\n        return bottomUpDp(word1,word2,word1.size(),word2.size(),dp);\\n    }\\n};\\n\\n```\n```\\nint Memoization(string &word1, string &word2,int m, int n,vector<vector<int>>&mem){\\n            if (m == 0)\\n                return n; //If the word1 length becomes zero, obvious that we are left with the cost of n\\n            if (n == 0)\\n                return m; //If the word2 length becomes zero, obvious that we are left with the cost of m\\n\\n            if (mem[m - 1][n - 1] != -1)\\n                return mem[m - 1][n - 1];\\n\\n            if (word1[m - 1] == word2[n - 1])\\n            {\\n                mem[m - 1][n - 1] = Memoization(word1, word2, m - 1, n - 1, mem);\\n                return mem[m - 1][n - 1];\\n            }\\n            else\\n            {\\n                mem[m - 1][n - 1] = 1 + min(Memoization(word1, word2, m - 1, n - 1, mem), min(Memoization(word1, word2, m - 1, n, mem), Memoization(word1, word2, m, n - 1, mem)));\\n                return mem[m - 1][n - 1];\\n            }\\n        }\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int bottomUpDp(string &word1, string &word2, int m, int n, vector<vector<int>>& dp){\\n        // Initialize base cases\\n        for (int i = 0; i <= m; i++) {\\n            dp[i][0] = i;   //rows\\n        }\\n        for (int j = 0; j <= n; j++) {\\n            dp[0][j] = j;   //columns\\n        }\\n\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (word1[i - 1] == word2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));\\n                // Carefully observe the recursive code is converted to iterative approach which tries to find the solution in dp table instead of recursive calls\\n                }\\n            }\\n\\n        }\\n\\n        return dp[m][n];\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027225,
                "title": "c-dp-solution-recursive-memorization-tabulation-space-optimized-to-single-1d-array",
                "content": "### Recursive\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(s1[i]==s2[j]) return solve(i-1,j-1,s1,s2);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2);\\n        \\n        return 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        return solve(m,n,s1,s2);\\n    }\\n};\\n```\\n\\n### Memorization\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i]==s2[j]) return dp[i][j] = solve(i-1,j-1,s1,s2, dp);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2, dp); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2, dp); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2, dp);\\n        \\n        return dp[i][j] = 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return solve(m-1,n-1,s1,s2,dp);\\n    }\\n};\\n```\\n\\n### Tabulation\\n```\\n// Used 1-Based Indexing\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        //Base Case\\n        for(int j=0;j<=n;j++) dp[0][j] = j;\\n        for(int i=0;i<=m;i++) dp[i][0] = i;\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int ins = dp[i][j-1];\\n                    int del = dp[i-1][j];\\n                    int rep = dp[i-1][j-1];\\n                    dp[i][j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n### Space-Optimized\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1), cur(n+1);\\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) cur[j] = j;\\n                else if(j==0) cur[j] = i;\\n                else if(s1[i-1]==s2[j-1]) cur[j] = prev[j-1];\\n                else{\\n                    int ins = cur[j-1];\\n                    int del = prev[j];\\n                    int rep = prev[j-1];\\n                    cur[j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n};\\n```\\n\\n### Further Optimized\\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1);\\n        int topLeft, top, left;\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) left = j;\\n                else if(j==0) left = i;\\n                else{\\n                    top = prev[j];\\n                    if(s1[i-1]==s2[j-1]) left = topLeft;\\n                    else left = 1 + min({topLeft, top, left});   \\n                }\\n                topLeft = prev[j];\\n                prev[j] = left;\\n            }\\n        }\\n        return prev[n];\\n    }\\n};\\n```\\n#### Please Upvote if you like the solution and comment your queries",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(s1[i]==s2[j]) return solve(i-1,j-1,s1,s2);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2);\\n        \\n        return 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        return solve(m,n,s1,s2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //Base Case\\n        if(i<0) return j + 1;\\n        if(j<0) return i + 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s1[i]==s2[j]) return dp[i][j] = solve(i-1,j-1,s1,s2, dp);\\n        \\n        //Insert the matching character so reduce the j no effect on i due to insertion\\n        int ins = solve(i,j-1,s1,s2, dp); \\n        \\n        // Delete the character so reduce the i but no effect on j\\n        int del = solve(i-1,j,s1,s2, dp); \\n        \\n        // Replace with matching character so reduce i and j both\\n        int rep = solve(i-1,j-1,s1,s2, dp);\\n        \\n        return dp[i][j] = 1 + min({ins, del, rep});\\n    }\\n    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return solve(m-1,n-1,s1,s2,dp);\\n    }\\n};\\n```\n```\\n// Used 1-Based Indexing\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        \\n        //Base Case\\n        for(int j=0;j<=n;j++) dp[0][j] = j;\\n        for(int i=0;i<=m;i++) dp[i][0] = i;\\n        \\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];\\n                else{\\n                    int ins = dp[i][j-1];\\n                    int del = dp[i-1][j];\\n                    int rep = dp[i-1][j-1];\\n                    dp[i][j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1), cur(n+1);\\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) cur[j] = j;\\n                else if(j==0) cur[j] = i;\\n                else if(s1[i-1]==s2[j-1]) cur[j] = prev[j-1];\\n                else{\\n                    int ins = cur[j-1];\\n                    int del = prev[j];\\n                    int rep = prev[j-1];\\n                    cur[j] = 1 + min({ins, del, rep});\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minDistance(string s1, string s2) {\\n        int m = s1.size(), n = s2.size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        vector<int> prev(n+1);\\n        int topLeft, top, left;\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0) left = j;\\n                else if(j==0) left = i;\\n                else{\\n                    top = prev[j];\\n                    if(s1[i-1]==s2[j-1]) left = topLeft;\\n                    else left = 1 + min({topLeft, top, left});   \\n                }\\n                topLeft = prev[j];\\n                prev[j] = left;\\n            }\\n        }\\n        return prev[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817536,
                "title": "c-recursive-memoization-and-dp",
                "content": "**Recursive:**\\n```\\nint editDistance(string s, string t)\\n{\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (s[0] == t[0])\\n        return editDistance(s.substr(1), t.substr(1));\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance(s.substr(1), t);\\n        // delete\\n        int b = 1 + editDistance(s, t.substr(1));\\n        // replace\\n        int c = 1 + editDistance(s.substr(1), t.substr(1));\\n        return min(a, min(b, c));\\n    }\\n}\\n\\nint minDistance(string s, string t) {\\n\\treturn editDistance(s,t)\\n}\\n```\\n\\n**Memoization:**\\n```\\nint editDistance2(string s, string t, vector<vector<int>> ans)\\n{\\n    int m = s.size();\\n    int n = t.size();\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (ans[m][n] != -1)\\n        return ans[m][n];\\n    if (s[0] == t[0])\\n    {\\n        ans[m][n] = editDistance2(s.substr(1), t.substr(1), ans);\\n        return ans[m][n];\\n    }\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance2(s.substr(1), t, ans);\\n        // delete\\n        int b = 1 + editDistance2(s, t.substr(1), ans);\\n        // replace\\n        int c = 1 + editDistance2(s.substr(1), t.substr(1), ans);\\n        ans[m][n] = min(a, min(b, c));\\n        return ans[m][n];\\n    }\\n}\\nint minDistance(string s, string t) {\\n    vector<vector<int>> ans(s.size() + 1, vector<int>(t.size() + 1, -1));\\n\\treturn editDistance2(s,t)\\n}\\n```\\n\\n**DP:**\\n```\\nint minDistance(string s, string t) {\\n        int m = s.size();\\n    int n = t.size();\\n\\n    int **ans = new int *[m + 1];\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i] = new int[n + 1];\\n    }\\n\\n    // Fill the 0th row with 0\\n    for (int j = 0; j <= n; j++)\\n    {\\n        ans[0][j] = j;\\n    }\\n    // Fill the 0th row with 0\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i][0] = i;\\n    }\\n    // Fill the remaining row with shortest Distances\\n    for (int i = 1; i <= m; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            if (s[m - i] == t[n - j])\\n                ans[i][j] = ans[i - 1][j - 1];\\n            else\\n            {\\n                int a = 1 + ans[i - 1][j];\\n                int b = 1 + ans[i][j - 1];\\n                int c = 1 + ans[i - 1][j - 1];\\n                ans[i][j] = min(a, min(b, c));\\n            }\\n        }\\n    }\\n    return ans[m][n];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint editDistance(string s, string t)\\n{\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (s[0] == t[0])\\n        return editDistance(s.substr(1), t.substr(1));\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance(s.substr(1), t);\\n        // delete\\n        int b = 1 + editDistance(s, t.substr(1));\\n        // replace\\n        int c = 1 + editDistance(s.substr(1), t.substr(1));\\n        return min(a, min(b, c));\\n    }\\n}\\n\\nint minDistance(string s, string t) {\\n\\treturn editDistance(s,t)\\n}\\n```\n```\\nint editDistance2(string s, string t, vector<vector<int>> ans)\\n{\\n    int m = s.size();\\n    int n = t.size();\\n    if (s.size() == 0 || t.size() == 0)\\n        return max(s.size(), t.size());\\n    if (ans[m][n] != -1)\\n        return ans[m][n];\\n    if (s[0] == t[0])\\n    {\\n        ans[m][n] = editDistance2(s.substr(1), t.substr(1), ans);\\n        return ans[m][n];\\n    }\\n    else\\n    {\\n        // insert\\n        int a = 1 + editDistance2(s.substr(1), t, ans);\\n        // delete\\n        int b = 1 + editDistance2(s, t.substr(1), ans);\\n        // replace\\n        int c = 1 + editDistance2(s.substr(1), t.substr(1), ans);\\n        ans[m][n] = min(a, min(b, c));\\n        return ans[m][n];\\n    }\\n}\\nint minDistance(string s, string t) {\\n    vector<vector<int>> ans(s.size() + 1, vector<int>(t.size() + 1, -1));\\n\\treturn editDistance2(s,t)\\n}\\n```\n```\\nint minDistance(string s, string t) {\\n        int m = s.size();\\n    int n = t.size();\\n\\n    int **ans = new int *[m + 1];\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i] = new int[n + 1];\\n    }\\n\\n    // Fill the 0th row with 0\\n    for (int j = 0; j <= n; j++)\\n    {\\n        ans[0][j] = j;\\n    }\\n    // Fill the 0th row with 0\\n    for (int i = 0; i <= m; i++)\\n    {\\n        ans[i][0] = i;\\n    }\\n    // Fill the remaining row with shortest Distances\\n    for (int i = 1; i <= m; i++)\\n    {\\n        for (int j = 1; j <= n; j++)\\n        {\\n            if (s[m - i] == t[n - j])\\n                ans[i][j] = ans[i - 1][j - 1];\\n            else\\n            {\\n                int a = 1 + ans[i - 1][j];\\n                int b = 1 + ans[i][j - 1];\\n                int c = 1 + ans[i - 1][j - 1];\\n                ans[i][j] = min(a, min(b, c));\\n            }\\n        }\\n    }\\n    return ans[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662522,
                "title": "java-dp-easy-solution-with-explanation-well-commented",
                "content": "```\\nclass Solution {\\n    public int minDistance(String str1, String str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[][] = new int[m + 1][n + 1]; \\n        // Fill d[][] in bottom up manner \\n        for (int i = 0; i <= m; i++) { \\n            for (int j = 0; j <= n; j++) { \\n                // If first string is empty, only option is to \\n                // insert all characters of second string \\n                \\n                if (i == 0) dp[i][j] = j; // Min. operations = j \\n                \\n                // If second string is empty, only option is to \\n                // remove all characters of second string \\n                \\n                else if (j == 0) \\n                    dp[i][j] = i; // Min. operations = i \\n                \\n                // If last characters are same, ignore last char \\n                // and recur for remaining string \\n                \\n                else if (str1.charAt(i - 1) == str2.charAt(j - 1)) \\n                    dp[i][j] = dp[i - 1][j - 1]; \\n  \\n                // If the last character is different, consider all \\n                // possibilities and find the minimum \\n                else\\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i][j - 1], // Insert \\n                                       dp[i - 1][j]), // Remove \\n                                       dp[i - 1][j - 1]); // Replace \\n            } \\n        } \\n  \\n        return dp[m][n]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String str1, String str2) {\\n        int m = str1.length();\\n        int n = str2.length();\\n        int dp[][] = new int[m + 1][n + 1]; \\n        // Fill d[][] in bottom up manner \\n        for (int i = 0; i <= m; i++) { \\n            for (int j = 0; j <= n; j++) { \\n                // If first string is empty, only option is to \\n                // insert all characters of second string \\n                \\n                if (i == 0) dp[i][j] = j; // Min. operations = j \\n                \\n                // If second string is empty, only option is to \\n                // remove all characters of second string \\n                \\n                else if (j == 0) \\n                    dp[i][j] = i; // Min. operations = i \\n                \\n                // If last characters are same, ignore last char \\n                // and recur for remaining string \\n                \\n                else if (str1.charAt(i - 1) == str2.charAt(j - 1)) \\n                    dp[i][j] = dp[i - 1][j - 1]; \\n  \\n                // If the last character is different, consider all \\n                // possibilities and find the minimum \\n                else\\n                    dp[i][j] = 1 + Math.min(Math.min(dp[i][j - 1], // Insert \\n                                       dp[i - 1][j]), // Remove \\n                                       dp[i - 1][j - 1]); // Replace \\n            } \\n        } \\n  \\n        return dp[m][n]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662340,
                "title": "c-dp",
                "content": "**Case 1 :**\\nIf first string is empty, only option is to insert all characters of second string\\n**Case 2 :**\\nIf second string is empty, only option is to remove all characters of second string\\n**Options :**\\n* dp [i-1][j - 1] -> If we replace the character.\\n* dp [i][j - 1] -> If we delete the character.\\n* dp [i - 1][j] -> If we insert the character.\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n\\t\\t\\n        for(int i = 1; i <= n; i++){ \\n            dp[i][0] = 1 + dp[i - 1][0];\\n        }\\n        for(int i = 1; i <= m; i++){\\n            dp[0][i] = 1 + dp[0][i - 1];\\n        }\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n              \\n                if(word2[i - 1] == word1[j - 1]){\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else{\\n                    dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]});\\n                }\\n               \\n            } \\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\\n\\t\\t\\n        for(int i = 1; i <= n; i++){ \\n            dp[i][0] = 1 + dp[i - 1][0];\\n        }\\n        for(int i = 1; i <= m; i++){\\n            dp[0][i] = 1 + dp[0][i - 1];\\n        }\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= m; j++){\\n              \\n                if(word2[i - 1] == word1[j - 1]){\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else{\\n                    dp[i][j] = 1 + min({dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]});\\n                }\\n               \\n            } \\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234043,
                "title": "c-well-commented-solution-with-explanation-dp",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minDistance(string word1, string word2);\\n};\\n\\n/* Returns the minimum edit distance between the 2 strings */\\nint Solution :: minDistance(string str_1, string str_2)\\n{\\n    // Store the length of the two strings\\n    int lenFirst = str_1.length();\\n    int lenSecond = str_2.length();\\n    \\n    // Make a 2d vector of (len_first+1)*(len_second+1), since we are going to access the [len_first][len_second] element\\n    vector<vector<int>> dp;\\n    \\n    // Resize the vector to appropriate dimensions and initialise it with zero\\n    dp.resize(lenFirst+1);\\n    for(auto &row_vec : dp)\\n        row_vec.resize(lenSecond+1);\\n    \\n    /* DP definitions */\\n    /* dp[i][j] returns the edit distance of the first i elements of str_1 and first j elements of str_2 */\\n    \\n    \\n    /* dp[0][0] = 0\\n     * dp[0][j] = j First string is empty,  only insertions can happen\\n     * dp[i][0] = i Second string is empty, only deletions can happen\\n     * Compactly, dp[i][j] = max(i,j) if one of them is zero\\n     */\\n    \\n    // Fill the rest of the matrix \\n    for(int i=0; i<=(lenFirst); i++)\\n    {\\n        for(int j=0; j<=(lenSecond); j++)\\n        {\\n            // Base case, as discussed above\\n            if(i==0 || j==0)\\n                dp[i][j] = max(i,j);\\n                \\n            // If the last characters match, just remove them and calclulate for the left half\\n            else if(str_1[i-1] == str_2[j-1]) dp[i][j] = dp[i-1][j-1];\\n            \\n            // Else, the last character doesn\\'t match\\n            else\\n            {\\n                // Insert a new matching character at the end of first string. The last character matches now. \\n                int insert = 1 + dp[i][j-1];\\n                \\n                // Delete the last character of the first string\\n                int _delete = 1 + dp[i-1][j];\\n                \\n                // Replace the last character of the first string. Now, the last character matches. \\n                int replace = 1 + dp[i-1][j-1];\\n                \\n                // Take the best possible of all outcomes\\n                dp[i][j] = min({insert, _delete, replace});\\n            }\\n        }\\n    }\\n    \\n    // Return the edit distance of str_1 and str_2\\n    return dp[lenFirst][lenSecond];\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minDistance(string word1, string word2);\\n};\\n\\n/* Returns the minimum edit distance between the 2 strings */\\nint Solution :: minDistance(string str_1, string str_2)\\n{\\n    // Store the length of the two strings\\n    int lenFirst = str_1.length();\\n    int lenSecond = str_2.length();\\n    \\n    // Make a 2d vector of (len_first+1)*(len_second+1), since we are going to access the [len_first][len_second] element\\n    vector<vector<int>> dp;\\n    \\n    // Resize the vector to appropriate dimensions and initialise it with zero\\n    dp.resize(lenFirst+1);\\n    for(auto &row_vec : dp)\\n        row_vec.resize(lenSecond+1);\\n    \\n    /* DP definitions */\\n    /* dp[i][j] returns the edit distance of the first i elements of str_1 and first j elements of str_2 */\\n    \\n    \\n    /* dp[0][0] = 0\\n     * dp[0][j] = j First string is empty,  only insertions can happen\\n     * dp[i][0] = i Second string is empty, only deletions can happen\\n     * Compactly, dp[i][j] = max(i,j) if one of them is zero\\n     */\\n    \\n    // Fill the rest of the matrix \\n    for(int i=0; i<=(lenFirst); i++)\\n    {\\n        for(int j=0; j<=(lenSecond); j++)\\n        {\\n            // Base case, as discussed above\\n            if(i==0 || j==0)\\n                dp[i][j] = max(i,j);\\n                \\n            // If the last characters match, just remove them and calclulate for the left half\\n            else if(str_1[i-1] == str_2[j-1]) dp[i][j] = dp[i-1][j-1];\\n            \\n            // Else, the last character doesn\\'t match\\n            else\\n            {\\n                // Insert a new matching character at the end of first string. The last character matches now. \\n                int insert = 1 + dp[i][j-1];\\n                \\n                // Delete the last character of the first string\\n                int _delete = 1 + dp[i-1][j];\\n                \\n                // Replace the last character of the first string. Now, the last character matches. \\n                int replace = 1 + dp[i-1][j-1];\\n                \\n                // Take the best possible of all outcomes\\n                dp[i][j] = min({insert, _delete, replace});\\n            }\\n        }\\n    }\\n    \\n    // Return the edit distance of str_1 and str_2\\n    return dp[lenFirst][lenSecond];\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933524,
                "title": "step-by-step-explanation-from-brute-force-to-optimised-dp",
                "content": "\\n***It took a lot of time and efforts to make this post please upvote if you like it and found helpful !*** \\n\\n**Step By Step Explanation :-**\\n\\n For each poisition, check three subproblem:\\n      1. insert\\n      2. delete\\n      3. replace\\n\\nI was having trouble with this and figuring out the recurrences for the edit operations. i and j basically keep track of the current characters that are getting compared, each operation shifts them differently. **The important thing to note is that we are simulating the edit operations by moving i and j around**, not actually changing the input strings.\\n\\n**EXAMPLE**\\nc1 = sample, c2 = example\\ni = 0 (s), j = 0 (e)\\n**Replace** is simplest for me to understand, we replace the cur char with the char we need from word2. We then increment i and j to look at the next char.\\n*Replace -> match(c1,c2, i+1, j+1)*\\nc1 = eample, c2 = example\\ni = 1 (a), j = 1 (x)\\n\\n**Delete** removes the first character, shifting word 1 character to left. Since we do not actually delete the char, incrementing i simulates skipping this char.\\n*Delete -> match(c1, c2, i+1, j)*\\nc1 = sample, c2 = example\\ni = 1 (a) , j = 0 (e)\\n\\n**Insert** is the opposite of delete, we insert the char we need, shifting word 1 to the right. Since we do not actually add a char, leave i alone. It\\'s the similar as doing:\\n\\n  c1 = \"e\" + c1;\\n  match(c1,c2,i+1,j+1) //Since we added \"e\", i+1 would point to \"s\"\\n*Insert -> match(c1, c2, i, j+1)*\\nc1 = esample, c2 = example\\ni = 0 (s), j = 1 (x)\\n\\nHopefully I made sense, let me know if I can try to clarify more. I only recently was able to understand. Now lets jump to the Code part !\\n\\n***Method 1 : Recursion \\nTime Complexity : O(3^(min(len1,len2))  \\nSpace Complexity : O(n)***\\n\\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2)\\n    {\\n        if (i == word1.size()) return word2.size() - j;\\n        if (j == word2.size()) return word1.size() - i;\\n        if( s1[i] == s2[j] ) return editDistance(i+1 , j+1, s1, s2);\\n        return 1 + min( editDistance(i , j+1, s1, s2), min( editDistance(i+1 , j, s1, s2),  editDistance(i+1 , j+1, s1, s2)));  // Didn\\'t Got it , No issue again go through the explanation !\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    return editDistance(0, 0, word1 , word2);\\n    }\\n};\\n```\\nOfcourse It will give TLE , so for it we will precompute sub - problem and will store it in bottom - up and top - down manner using Dynamic Programming!\\n\\n\\n***Method 2 : Recursion + Memorisation ( Top - Down Approach )***\\n Time Complexity   :  O(len1 x len2) \\n Space Complexity : O(len1 x len2) \\n\\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2, vector<vector<int>>&dp)\\n    {\\n        if(i == size(s1) ) return size(s2) - j;\\n        if(j == size(s2) ) return size(s1) - i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if( s1[i] == s2[j] ) return dp[i][j] = editDistance(i+1 , j+1, s1, s2, dp);\\n        return dp[i][j] = 1 + min( editDistance(i , j+1, s1, s2, dp), min( editDistance(i+1 , j, s1, s2, dp),  editDistance(i+1 , j+1, s1, s2, dp)));\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    vector<vector<int>>dp(size(word1), vector<int>(size(word2), -1));\\n    return editDistance(0, 0, word1 , word2, dp);\\n    }\\n};\\n```\\n\\n\\n***Method 3 : Tabulation ( Bottom - Up Approach)*** \\n***Time Complexity   : O(len1 x len2)\\nSpace Complexity : O(len1 x len2)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n    int n = size(word1); int m = size(word2);\\n    vector<vector<int>>dp(n+1, vector<int>(m+1,0));\\n    for(int i = 0 ; i <= n; i++) dp[i][0] = i;\\n    for(int j = 0 ; j <= m; j++) dp[0][j] = j;\\n    \\n    for(int i = 0 ; i < n; i++)\\n    {\\n        for(int j = 0 ; j < m; j++)\\n        {\\n           if( word1[i] == word2[j] ) \\n           dp[i+1][j+1] = dp[i][j];\\n           else\\n           dp[i + 1][j + 1] = min({dp[i][j + 1], dp[i + 1][j], dp[i][j]}) + 1;\\n\\t\\t   //Since it is bottom up, we are considering in the ascending order of indexes.\\n           //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n           //above sequence is delete, insert and replace. \\n        }\\n    }\\n    \\n    return dp[n][m];\\n    }\\n};\\n```\\n\\n***It took a lot of time and efforts to make this post please upvote if you like it and found helpful !***",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2)\\n    {\\n        if (i == word1.size()) return word2.size() - j;\\n        if (j == word2.size()) return word1.size() - i;\\n        if( s1[i] == s2[j] ) return editDistance(i+1 , j+1, s1, s2);\\n        return 1 + min( editDistance(i , j+1, s1, s2), min( editDistance(i+1 , j, s1, s2),  editDistance(i+1 , j+1, s1, s2)));  // Didn\\'t Got it , No issue again go through the explanation !\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    return editDistance(0, 0, word1 , word2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int editDistance(int i , int j , string& s1 , string& s2, vector<vector<int>>&dp)\\n    {\\n        if(i == size(s1) ) return size(s2) - j;\\n        if(j == size(s2) ) return size(s1) - i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if( s1[i] == s2[j] ) return dp[i][j] = editDistance(i+1 , j+1, s1, s2, dp);\\n        return dp[i][j] = 1 + min( editDistance(i , j+1, s1, s2, dp), min( editDistance(i+1 , j, s1, s2, dp),  editDistance(i+1 , j+1, s1, s2, dp)));\\n    }\\n   \\n    int minDistance(string word1, string word2) {\\n    vector<vector<int>>dp(size(word1), vector<int>(size(word2), -1));\\n    return editDistance(0, 0, word1 , word2, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n    int n = size(word1); int m = size(word2);\\n    vector<vector<int>>dp(n+1, vector<int>(m+1,0));\\n    for(int i = 0 ; i <= n; i++) dp[i][0] = i;\\n    for(int j = 0 ; j <= m; j++) dp[0][j] = j;\\n    \\n    for(int i = 0 ; i < n; i++)\\n    {\\n        for(int j = 0 ; j < m; j++)\\n        {\\n           if( word1[i] == word2[j] ) \\n           dp[i+1][j+1] = dp[i][j];\\n           else\\n           dp[i + 1][j + 1] = min({dp[i][j + 1], dp[i + 1][j], dp[i][j]}) + 1;\\n\\t\\t   //Since it is bottom up, we are considering in the ascending order of indexes.\\n           //Insert means plus 1 to j, delete means plus 1 to i, replace means plus 1 to both i and j. \\n           //above sequence is delete, insert and replace. \\n        }\\n    }\\n    \\n    return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928349,
                "title": "java-top-down-memo",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        final int m = word1.length();\\n        final int n = word2.length();\\n        final int[][] memo = new int[m][n];\\n        \\n        return minDistHelper(word1, word2, m, n, memo);\\n    }\\n    \\n    private int minDistHelper(String word1, String word2, int m, int n, int[][] memo) {\\n        \\n        if(m == 0) {\\n            return n;\\n        }\\n        \\n        if(n == 0) {\\n            return m;\\n        }\\n        \\n        if(memo[m - 1][n - 1] != 0) {\\n            return memo[m - 1][n - 1];\\n        }\\n        \\n        if(word1.charAt(m - 1) == word2.charAt(n - 1)) {\\n            return minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        }\\n        \\n        int insert = minDistHelper(word1, word2, m, n - 1, memo);\\n        int remove = minDistHelper(word1, word2, m - 1, n, memo);\\n        int replace = minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        \\n        memo[m - 1][n - 1] = 1 + Math.min(insert, Math.min(remove, replace));\\n        return memo[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        final int m = word1.length();\\n        final int n = word2.length();\\n        final int[][] memo = new int[m][n];\\n        \\n        return minDistHelper(word1, word2, m, n, memo);\\n    }\\n    \\n    private int minDistHelper(String word1, String word2, int m, int n, int[][] memo) {\\n        \\n        if(m == 0) {\\n            return n;\\n        }\\n        \\n        if(n == 0) {\\n            return m;\\n        }\\n        \\n        if(memo[m - 1][n - 1] != 0) {\\n            return memo[m - 1][n - 1];\\n        }\\n        \\n        if(word1.charAt(m - 1) == word2.charAt(n - 1)) {\\n            return minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        }\\n        \\n        int insert = minDistHelper(word1, word2, m, n - 1, memo);\\n        int remove = minDistHelper(word1, word2, m - 1, n, memo);\\n        int replace = minDistHelper(word1, word2, m - 1, n - 1, memo);\\n        \\n        memo[m - 1][n - 1] = 1 + Math.min(insert, Math.min(remove, replace));\\n        return memo[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894150,
                "title": "a-straightforward-solution-python-faster-than-98-6",
                "content": "The idea is to find the recursive relation. \\n\\nIf `s1[i] == s2[j]`, then `f(i, j) = f(i - 1, j - 1)`\\nOtherwise, \\n    `f(i, j) = min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))`\\nwhich corresponds to insert, delete and replace.\\n\\n```\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n\\n        @lru_cache(maxsize=None)\\n        def f(i, j):\\n            if i == 0 and j == 0: return 0\\n            if i == 0 or j == 0: return i or j\\n            if s1[i - 1] == s2[j - 1]:\\n                return f(i - 1, j - 1)\\n            return min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))\\n\\n        m, n = len(s1), len(s2)\\n        return f(m, n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, s1: str, s2: str) -> int:\\n\\n        @lru_cache(maxsize=None)\\n        def f(i, j):\\n            if i == 0 and j == 0: return 0\\n            if i == 0 or j == 0: return i or j\\n            if s1[i - 1] == s2[j - 1]:\\n                return f(i - 1, j - 1)\\n            return min(1 + f(i, j - 1), 1 + f(i - 1, j), 1 + f(i - 1, j - 1))\\n\\n        m, n = len(s1), len(s2)\\n        return f(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662356,
                "title": "easiest-solution-dp-w-explanation",
                "content": "This is also considered as levenshtein distance algorithm. \\nTime = O(mn)\\nSpace = O(mn)\\nHere, we can improve this method by using only 2 rows instead of the entire 2d array.\\n\\nHere, we have to find the minimum no of operations to convert one string to another. \\nAlso, this will get harder with longer strings so our best friend here will be dynamic programming.\\nWe can construct a 2d array/matrix to store all the possible least no. operations to convert one string to another.\\n\\n\\t0 1 2 3 4\\n0\\n1\\n2\\n3\\n4\\n5\\nWe have to initialize our matrix like this^ to add values into it. \\nHere these two axis represent two strings.\\nWe have taken 0 in the beginning which acts as our base case. So it will look something like this:\\n       \\n\\t0 1 2 3 4\\n0  0 0 0 0 0 \\n1  0\\n2  0\\n3  0\\n4  0\\n5  0\\nThis is our base case and now we\\'ll just use dp to find all the values. \\nOur formula will be \\nif string2[i] == string1[j] # means if two letters are equal:\\nmatrix[i][j] = matrix[i - 1][j - 1] because it will give us min no of operations\\n\\nelse:(if the letters that we\\'re comparing are not equal, then well check all the values, above it, to the left if it and to the left diagonal) find min of these and add 1 to it.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\nCode:\\n\\n\\tclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        edits = [[x for x in range(len(word1) + 1)] for y in range(len(word2) + 1)] #initialize 2d\\n        for i in range(1, len(word2) + 1): #initailize first column(012345)\\n            edits[i][0] = edits[i - 1][0] + 1\\n        for i in range(1, len(word2) + 1):\\n            for j in range(1, len(word1) + 1):\\n                if word2[i - 1] == word1[j - 1]: #if same just check diaginal\\n                    edits[i][j] = edits[i - 1][j - 1]\\n                else:\\n                    edits[i][j] = 1 + min(edits[i - 1][j - 1], edits[i][j - 1], edits[i - 1][j]) #check all three vals, find min and add 1\\n        return edits[-1][-1] #return final val of our 2d matrix(last row last col)\\n\\t\\t\\nIf you have any questions, feel free to comment down below. I\\'m also gonna implement this using only two rows which will save some space. \\n                        \\n            \\n        \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "This is also considered as levenshtein distance algorithm. \\nTime = O(mn)\\nSpace = O(mn)\\nHere, we can improve this method by using only 2 rows instead of the entire 2d array.\\n\\nHere, we have to find the minimum no of operations to convert one string to another. \\nAlso, this will get harder with longer strings so our best friend here will be dynamic programming.\\nWe can construct a 2d array/matrix to store all the possible least no. operations to convert one string to another.\\n\\n\\t0 1 2 3 4\\n0\\n1\\n2\\n3\\n4\\n5\\nWe have to initialize our matrix like this^ to add values into it. \\nHere these two axis represent two strings.\\nWe have taken 0 in the beginning which acts as our base case. So it will look something like this:\\n       \\n\\t0 1 2 3 4\\n0  0 0 0 0 0 \\n1  0\\n2  0\\n3  0\\n4  0\\n5  0\\nThis is our base case and now we\\'ll just use dp to find all the values. \\nOur formula will be \\nif string2[i] == string1[j] # means if two letters are equal:\\nmatrix[i][j] = matrix[i - 1][j - 1] because it will give us min no of operations\\n\\nelse:(if the letters that we\\'re comparing are not equal, then well check all the values, above it, to the left if it and to the left diagonal) find min of these and add 1 to it.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\nCode:\\n\\n\\tclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        edits = [[x for x in range(len(word1) + 1)] for y in range(len(word2) + 1)] #initialize 2d\\n        for i in range(1, len(word2) + 1): #initailize first column(012345)\\n            edits[i][0] = edits[i - 1][0] + 1\\n        for i in range(1, len(word2) + 1):\\n            for j in range(1, len(word1) + 1):\\n                if word2[i - 1] == word1[j - 1]: #if same just check diaginal\\n                    edits[i][j] = edits[i - 1][j - 1]\\n                else:\\n                    edits[i][j] = 1 + min(edits[i - 1][j - 1], edits[i][j - 1], edits[i - 1][j]) #check all three vals, find min and add 1\\n        return edits[-1][-1] #return final val of our 2d matrix(last row last col)\\n\\t\\t\\nIf you have any questions, feel free to comment down below. I\\'m also gonna implement this using only two rows which will save some space. \\n                        \\n            \\n        \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 479377,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The **ART** of dynamic programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n            var b = 1 + go(i + 1, j)\\n            var c = 1 + go(i, j + 1)\\n            return listOf(a, b, c).min()!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n                var b = 1 + go(i + 1, j)\\n                var c = 1 + go(i, j + 1)\\n                m[k] = listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in 1..M) dp[i][0] = 1 + dp[i - 1][0]\\n        for (j in 1..N) dp[0][j] = 1 + dp[0][j - 1]\\n        for (i in 1..M) {\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + dp[i - 1][j - 1]\\n                var b = 1 + dp[i - 1][j]\\n                var c = 1 + dp[i][j - 1]\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[M][N]\\n    }\\n}\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var cur = IntArray(N + 1) { 0 }\\n        for (j in 1..N) cur[j] = 1 + cur[j - 1]\\n        for (i in 1..M) {\\n            var pre = cur.copyOf()\\n            ++cur[0]\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + pre[j - 1]\\n                var b = 1 + pre[j]\\n                var c = 1 + cur[j - 1]\\n                cur[j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return cur[N]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nlet minDistance = (s, t) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n            b = 1 + go(i + 1, j),\\n            c = 1 + go(i, j + 1);\\n        return Math.min(a, b, c);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n                b = 1 + go(i + 1, j),\\n                c = 1 + go(i, j + 1);\\n            m.set(k, Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = 1; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n    for (let j = 1; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                b = 1 + dp[i - 1][j],\\n                c = 1 + dp[i][j - 1];\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[M][N];\\n};\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let cur = Array(N + 1).fill(0);\\n    for (let j = 1; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        let pre = [...cur];\\n        ++cur[0];\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                b = 1 + pre[j],\\n                c = 1 + cur[j - 1];\\n            cur[j] = Math.min(a, b, c);\\n        }\\n    }\\n    return cur[N];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(1, M + 1): dp[i][0] = 1 + dp[i - 1][0]\\n        for j in range(1, N + 1): dp[0][j] = 1 + dp[0][j - 1]\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1]\\n                b = 1 + dp[i - 1][j]\\n                c = 1 + dp[i][j - 1]\\n                dp[i][j] = min(a, b, c)\\n        return dp[M][N]\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        cur = [0] * (N + 1)\\n        for j in range(1, N + 1): cur[j] = 1 + cur[j - 1]\\n        for i in range(1, M + 1):\\n            pre = cur[:]\\n            cur[0] += 1\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + pre[j - 1]\\n                b = 1 + pre[j]\\n                c = 1 + cur[j - 1]\\n                cur[j] = min(a, b, c)\\n        return cur[N]\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                 b = 1 + go(i + 1, j),\\n                 c = 1 + go(i, j + 1);\\n            return min({ a, b, c });\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minDistance(string s, string t, Map m = {}) {\\n        int M = s.size(),\\n            N = t.size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                     b = 1 + go(i + 1, j),\\n                     c = 1 + go(i, j + 1);\\n                m[k] = min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ 1 }; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n        for (auto j{ 1 }; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                     b = 1 + dp[i - 1][j],\\n                     c = 1 + dp[i][j - 1];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing `dp` matrix with previous/current rows\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VI cur(N + 1);\\n        for (auto j{ 1 }; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            auto pre{ cur };\\n            ++cur[0];\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                     b = 1 + pre[j],\\n                     c = 1 + cur[j - 1];\\n                cur[j] = min({ a, b, c });\\n            }\\n        }\\n        return cur[N];\\n    }\\n};\\n```\\n\\n---\\n\\n**Legacy Solutions from October 2, 2020:**\\n\\nLet `i` and `j` be non-inclusive indexes of strings `A` and `B` which denote each corresponding substring of `A[0..i)` and `B[0..j)`.  Let `M` and `N` be the length of `A` and `B`.  Thus initially `i = M` and `j = N` (ie. `A == A[0..i=M)` and `B == B[0..j=N)`).  Recursively consider the last character of `A` and `B`, ie. `A[i - 1]` and `B[j - 1]`, there are 4 use cases:\\n\\n1. If the last characters match, then there is no penalty, move onto the sub-problems without the last characters\\n2. If the last characters mismatch, then the last character in `A` can be replaced with the last character in `B` xor the last character in `B` can be replaced with the last character in `A` to make these characters match.  This replacement is an arbitrary choice with penalty of `1`\\n3. If the last characters mismatch, then we can insert a character in `A` xor we can delete a character from `B`.  The insertion/deletion is an arbitrary choice with penalty of `1`\\n4. If the last characters mismatch, then we can insert a character in `B` xor we can delete a character from `A`.  The insertion/deletion is an arbitrary choice with penalty of `1`\\n\\n---\\n\\n**Example use case 1:** the last character `x` is a match.  There is no penalty.\\n```\\nA = ...x\\nB = ...x\\n```\\n\\n**Example use case 2:** the last character `x` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this replacement.\\n```\\nA = ...x\\nB = ...y\\n```\\n\\n* If we replace `x` with `y` in `A`, then this use case 2 mismatch is \"fixed\" as follows:\\n```\\nA = ...y\\nB = ...y\\n```\\n\\n* If we replace `y` with `x` in `B`, then this use case 2 mismatch is \"fixed\" as follows:\\n```\\nA = ...x\\nB = ...x\\n```\\n\\n**Example use case 3:** the last character `z` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this insertion/deletion.\\n```\\nA = xy\\nB = xyz\\n```\\n\\n* If we insert `z` in `A`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xyz\\nB = xyz\\n```\\n\\n* If we delete `z` from `B`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xy\\nB = xy\\n```\\n\\n**Example use case 4:** the last character `z` is a mismatch.  Regardless of the arbitrary \"fix\" choosen, there is a penalty of `1` for this insertion/deletion.\\n```\\nA = xyz\\nB = xy\\n```\\n\\n* If we insert `z` in `B`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xyz\\nB = xyz\\n```\\n\\n* If we delete `z` from `A`, then this use case 3 mismatch is \"fixed\" as follows:\\n```\\nA = xy\\nB = xy\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n*Javascript: Top-Down TLE without Memo*\\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j) => {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return Math.min(\\n            go(A, B, i - 1, j - 1) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\\n\\n*Javascript: Top-Down with Memo*\\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j, memo = {}) => {\\n        let key = `${i},${j}`; // \\uD83D\\uDD11 \\n        if (memo[key])\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return memo[key] = Math.min(\\n            go(A, B, i - 1, j - 1, memo) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, memo) + 1, // \\u274C insertion \\n            go(A, B, i, j - 1, memo) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\\n\\n*Javascript: Bottom-Up with full DP matrix*\\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let dp = [...Array(M + 1)].map(row => Array(N + 1).fill(0)); // \\uD83E\\uDD14 memo\\n    for (let i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n    for (let j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i)\\n        for (let j = 1; j <= N; ++j)\\n            dp[i][j] = Math.min(\\n                dp[i - 1][j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                dp[i - 1][j] + 1, // \\u274C insertion \\n                dp[i][j - 1] + 1, // \\u274C deletion\\n            );\\n    return dp[M][N];\\n};\\n```\\n\\n*Javascript: Bottom-Up with memory optimization to only store previous and current rows of the DP matrix*\\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let pre = [...Array(N + 1)].map((_, i) => i); // \\uD83E\\uDD14 memo \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i) {\\n        let cur = [...pre]; // \\uD83E\\uDD14 generate current from previous\\n        cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        for (let j = 1; j <= N; ++j) {\\n            cur[j] = Math.min(\\n                pre[j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                pre[j] + 1,     // \\u274C insertion \\n                cur[j - 1] + 1, // \\u274C deletion\\n            );\\n        }\\n        [pre, cur] = [cur, pre]; // swap\\n    }\\n    return pre[N];\\n};\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n*C++: Top-Down TLE without Memo*\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    int go(string& A, string& B, int i, int j) {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return min({\\n            go(A, B, i - 1, j - 1) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\\n\\n*C++: Top-Down with Memo*\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    using Memo = unordered_map<string, int>;\\n    int go(string& A, string& B, int i, int j, Memo&& memo = {}) {\\n        stringstream ss; ss << i << \",\" << j;\\n        auto key = ss.str(); // \\uD83D\\uDD11\\n        if (memo.find(key) != memo.end())\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j;\\n        return memo[key] = min({\\n            go(A, B, i - 1, j - 1, move(memo)) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, move(memo)) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1, move(memo)) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\\n\\n*C++: Bottom-Up with full DP matrix*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VVI dp(M + 1, VI(N + 1)); // \\uD83E\\uDD14 memo\\n        for (auto i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n        for (auto j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i)\\n            for (auto j = 1; j <= N; ++j)\\n                dp[i][j] = min({\\n                    dp[i - 1][j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    dp[i - 1][j] + 1, // \\u274C insertion \\n                    dp[i][j - 1] + 1, // \\u274C deletion\\n                });\\n        return dp[M][N];\\n    }\\n};\\n```\\n\\n*C++: Bottom-Up with memory optimization to only store previous and current rows of the DP matrix*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VI pre(N + 1); // \\uD83E\\uDD14 memo\\n        iota(pre.begin(), pre.end(), 0); // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i) {\\n            auto cur{ pre }; // \\uD83E\\uDD14 generate current from previous\\n            cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n            for (auto j = 1; j <= N; ++j) {\\n                cur[j] = min({\\n                    pre[j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    pre[j] + 1,     // \\u274C insertion \\n                    cur[j - 1] + 1, // \\u274C deletion\\n                });\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n            var b = 1 + go(i + 1, j)\\n            var c = 1 + go(i, j + 1)\\n            return listOf(a, b, c).min()!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, j: Int = 0): Int {\\n            if (i == M || j == N)\\n                return M - i + N - j\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = (if (s[i] != t[j]) 1 else 0) + go(i + 1, j + 1)\\n                var b = 1 + go(i + 1, j)\\n                var c = 1 + go(i, j + 1)\\n                m[k] = listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var dp = Array(M + 1) { IntArray(N + 1) { 0 } }\\n        for (i in 1..M) dp[i][0] = 1 + dp[i - 1][0]\\n        for (j in 1..N) dp[0][j] = 1 + dp[0][j - 1]\\n        for (i in 1..M) {\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + dp[i - 1][j - 1]\\n                var b = 1 + dp[i - 1][j]\\n                var c = 1 + dp[i][j - 1]\\n                dp[i][j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return dp[M][N]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minDistance(s: String, t: String): Int {\\n        var (M, N) = listOf(s.length, t.length)\\n        var cur = IntArray(N + 1) { 0 }\\n        for (j in 1..N) cur[j] = 1 + cur[j - 1]\\n        for (i in 1..M) {\\n            var pre = cur.copyOf()\\n            ++cur[0]\\n            for (j in 1..N) {\\n                var a = (if (s[i - 1] != t[j - 1]) 1 else 0) + pre[j - 1]\\n                var b = 1 + pre[j]\\n                var c = 1 + cur[j - 1]\\n                cur[j] = listOf(a, b, c).min()!!\\n            }\\n        }\\n        return cur[N]\\n    }\\n}\\n```\n```\\nlet minDistance = (s, t) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n            b = 1 + go(i + 1, j),\\n            c = 1 + go(i, j + 1);\\n        return Math.min(a, b, c);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let go = (i = 0, j = 0) => {\\n        if (i == M || j == N)\\n            return M - i + N - j;\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = Number(s[i] != t[j]) + go(i + 1, j + 1),\\n                b = 1 + go(i + 1, j),\\n                c = 1 + go(i, j + 1);\\n            m.set(k, Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    return go();\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n    for (let i = 1; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n    for (let j = 1; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                b = 1 + dp[i - 1][j],\\n                c = 1 + dp[i][j - 1];\\n            dp[i][j] = Math.min(a, b, c);\\n        }\\n    }\\n    return dp[M][N];\\n};\\n```\n```\\nlet minDistance = (s, t, m = new Map()) => {\\n    let [M, N] = [s.length, t.length];\\n    let cur = Array(N + 1).fill(0);\\n    for (let j = 1; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n    for (let i = 1; i <= M; ++i) {\\n        let pre = [...cur];\\n        ++cur[0];\\n        for (let j = 1; j <= N; ++j) {\\n            let a = Number(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                b = 1 + pre[j],\\n                c = 1 + cur[j - 1];\\n            cur[j] = Math.min(a, b, c);\\n        }\\n    }\\n    return cur[N];\\n};\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        @cache\\n        def go(i = 0, j = 0):\\n            if i == M or j == N:\\n                return M - i + N - j\\n            a = int(s[i] != t[j]) + go(i + 1, j + 1)\\n            b = 1 + go(i + 1, j)\\n            c = 1 + go(i, j + 1)\\n            return min(a, b, c)\\n        return go()\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        dp = [[0] * (N + 1) for _ in range(M + 1)]\\n        for i in range(1, M + 1): dp[i][0] = 1 + dp[i - 1][0]\\n        for j in range(1, N + 1): dp[0][j] = 1 + dp[0][j - 1]\\n        for i in range(1, M + 1):\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1]\\n                b = 1 + dp[i - 1][j]\\n                c = 1 + dp[i][j - 1]\\n                dp[i][j] = min(a, b, c)\\n        return dp[M][N]\\n```\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        M, N = len(s), len(t)\\n        cur = [0] * (N + 1)\\n        for j in range(1, N + 1): cur[j] = 1 + cur[j - 1]\\n        for i in range(1, M + 1):\\n            pre = cur[:]\\n            cur[0] += 1\\n            for j in range(1, N + 1):\\n                a = int(s[i - 1] != t[j - 1]) + pre[j - 1]\\n                b = 1 + pre[j]\\n                c = 1 + cur[j - 1]\\n                cur[j] = min(a, b, c)\\n        return cur[N]\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                 b = 1 + go(i + 1, j),\\n                 c = 1 + go(i, j + 1);\\n            return min({ a, b, c });\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minDistance(string s, string t, Map m = {}) {\\n        int M = s.size(),\\n            N = t.size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (i == M || j == N)\\n                return M - i + N - j;\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = int(s[i] != t[j]) + go(i + 1, j + 1),\\n                     b = 1 + go(i + 1, j),\\n                     c = 1 + go(i, j + 1);\\n                m[k] = min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        return go(0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VVI dp(M + 1, VI(N + 1));\\n        for (auto i{ 1 }; i <= M; ++i) dp[i][0] = 1 + dp[i - 1][0];\\n        for (auto j{ 1 }; j <= N; ++j) dp[0][j] = 1 + dp[0][j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + dp[i - 1][j - 1],\\n                     b = 1 + dp[i - 1][j],\\n                     c = 1 + dp[i][j - 1];\\n                dp[i][j] = min({ a, b, c });\\n            }\\n        }\\n        return dp[M][N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minDistance(string s, string t) {\\n        int M = s.size(),\\n            N = t.size();\\n        VI cur(N + 1);\\n        for (auto j{ 1 }; j <= N; ++j) cur[j] = 1 + cur[j - 1];\\n        for (auto i{ 1 }; i <= M; ++i) {\\n            auto pre{ cur };\\n            ++cur[0];\\n            for (auto j{ 1 }; j <= N; ++j) {\\n                auto a = int(s[i - 1] != t[j - 1]) + pre[j - 1],\\n                     b = 1 + pre[j],\\n                     c = 1 + cur[j - 1];\\n                cur[j] = min({ a, b, c });\\n            }\\n        }\\n        return cur[N];\\n    }\\n};\\n```\n```\\nA = ...x\\nB = ...x\\n```\n```\\nA = ...x\\nB = ...y\\n```\n```\\nA = ...y\\nB = ...y\\n```\n```\\nA = ...x\\nB = ...x\\n```\n```\\nA = xy\\nB = xyz\\n```\n```\\nA = xyz\\nB = xyz\\n```\n```\\nA = xy\\nB = xy\\n```\n```\\nA = xyz\\nB = xy\\n```\n```\\nA = xyz\\nB = xyz\\n```\n```\\nA = xy\\nB = xy\\n```\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j) => {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return Math.min(\\n            go(A, B, i - 1, j - 1) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let go = (A, B, i, j, memo = {}) => {\\n        let key = `${i},${j}`; // \\uD83D\\uDD11 \\n        if (memo[key])\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return memo[key] = Math.min(\\n            go(A, B, i - 1, j - 1, memo) + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, memo) + 1, // \\u274C insertion \\n            go(A, B, i, j - 1, memo) + 1  // \\u274C deletion\\n        );\\n    };\\n    return go(A, B, A.length, B.length);\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let dp = [...Array(M + 1)].map(row => Array(N + 1).fill(0)); // \\uD83E\\uDD14 memo\\n    for (let i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n    for (let j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i)\\n        for (let j = 1; j <= N; ++j)\\n            dp[i][j] = Math.min(\\n                dp[i - 1][j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                dp[i - 1][j] + 1, // \\u274C insertion \\n                dp[i][j - 1] + 1, // \\u274C deletion\\n            );\\n    return dp[M][N];\\n};\\n```\n```\\nlet minDistance = (A, B) => {\\n    let [M, N] = [A.length, B.length];\\n    let pre = [...Array(N + 1)].map((_, i) => i); // \\uD83E\\uDD14 memo \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n    for (let i = 1; i <= M; ++i) {\\n        let cur = [...pre]; // \\uD83E\\uDD14 generate current from previous\\n        cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        for (let j = 1; j <= N; ++j) {\\n            cur[j] = Math.min(\\n                pre[j - 1] + Number(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                pre[j] + 1,     // \\u274C insertion \\n                cur[j - 1] + 1, // \\u274C deletion\\n            );\\n        }\\n        [pre, cur] = [cur, pre]; // swap\\n    }\\n    return pre[N];\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    int go(string& A, string& B, int i, int j) {\\n        if (!i || !j)\\n            return i + j; // \\uD83D\\uDED1 base case: we have exhausted A or B, return \"leftover\" distance\\n        return min({\\n            go(A, B, i - 1, j - 1) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string A, string B) {\\n        return go(A, B, A.size(), B.size());\\n    }\\nprivate:\\n    using Memo = unordered_map<string, int>;\\n    int go(string& A, string& B, int i, int j, Memo&& memo = {}) {\\n        stringstream ss; ss << i << \",\" << j;\\n        auto key = ss.str(); // \\uD83D\\uDD11\\n        if (memo.find(key) != memo.end())\\n            return memo[key]; // \\uD83E\\uDD14 memo\\n        if (!i || !j)\\n            return memo[key] = i + j;\\n        return memo[key] = min({\\n            go(A, B, i - 1, j - 1, move(memo)) + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n            go(A, B, i - 1, j, move(memo)) + 1, // \\u274C insertion\\n            go(A, B, i, j - 1, move(memo)) + 1  // \\u274C deletion\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VVI dp(M + 1, VI(N + 1)); // \\uD83E\\uDD14 memo\\n        for (auto i = 0; i <= M; ++i) dp[i][0] = i; // \\uD83D\\uDED1 base case: we have exhausted B, return \"leftover\" distance\\n        for (auto j = 0; j <= N; ++j) dp[0][j] = j; // \\uD83D\\uDED1 base case: we have exhausted A, return \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i)\\n            for (auto j = 1; j <= N; ++j)\\n                dp[i][j] = min({\\n                    dp[i - 1][j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    dp[i - 1][j] + 1, // \\u274C insertion \\n                    dp[i][j - 1] + 1, // \\u274C deletion\\n                });\\n        return dp[M][N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minDistance(string A, string B) {\\n        auto [M, N] = make_tuple(A.size(), B.size());\\n        VI pre(N + 1); // \\uD83E\\uDD14 memo\\n        iota(pre.begin(), pre.end(), 0); // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n        for (auto i = 1; i <= M; ++i) {\\n            auto cur{ pre }; // \\uD83E\\uDD14 generate current from previous\\n            cur[0] = i; // \\uD83D\\uDED1 base case: we have exhausted A or B, i is the \"leftover\" distance\\n            for (auto j = 1; j <= N; ++j) {\\n                cur[j] = min({\\n                    pre[j - 1] + int(A[i - 1] != B[j - 1]), // \\u2705 match xor \\u274C mismatch\\n                    pre[j] + 1,     // \\u274C insertion \\n                    cur[j - 1] + 1, // \\u274C deletion\\n                });\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151449,
                "title": "python-dp-solution",
                "content": "```\\ndef minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i== 0:\\n                    dp[i][j] = j\\n                elif j == 0:\\n                    dp[i][j] = i\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\\n        return dp[m][n]   \\n```",
                "solutionTags": [],
                "code": "```\\ndef minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        m = len(word1)\\n        n = len(word2)\\n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\\n        for i in range(m+1):\\n            for j in range(n+1):\\n                if i== 0:\\n                    dp[i][j] = j\\n                elif j == 0:\\n                    dp[i][j] = i\\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])\\n        return dp[m][n]   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 133086,
                "title": "from-brute-force-to-dp",
                "content": "### Brute Force\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n\\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\\n### Top-down DP\\nA two-dimensional array might be used to store results of all subproblems, in order to overcome overlapping subproblems.\\n```\\nclass Solution {\\n    private Integer[][] dp;\\n    public int minDistance(String word1, String word2) {\\n        dp = new Integer[word1.length() + 1][word2.length() + 1];\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n        \\n        if (dp[i1][i2] != null)\\n            return dp[i1][i2];\\n        \\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return dp[i1][i2] = minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\\n### Bottom-up DP\\n```\\n    public int minDistance(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i1 = 0; i1 <= s1.length(); i1++)\\n            dp[i1][0] = i1;\\n\\n        for (int i2 = 0; i2 <= s2.length(); i2++)\\n            dp[0][i2] = i2;\\n\\n        for (int i1 = 1; i1 <= s1.length(); i1++) {\\n            for (int i2 = 1; i2 <= s2.length(); i2++) {\\n                if (s1.charAt(i1 - 1) == s2.charAt(i2 - 1)) {\\n                    dp[i1][i2] = dp[i1 - 1][i2 - 1];\\n                } else {\\n                    int dist1 = 1 + dp[i1 - 1][i2]; // Deletes s1[i1] from s1\\n                    int dist2 = 1 + dp[i1][i2 - 1]; // Inserts s2[i2] to s1\\n                    int dist3 = 1 + dp[i1 - 1][i2 - 1]; // Replaces s1[i1] with s2[i2]\\n                    \\n                    dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n                }\\n            }\\n        }\\n\\n        return dp[s1.length()][s2.length()];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n\\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Integer[][] dp;\\n    public int minDistance(String word1, String word2) {\\n        dp = new Integer[word1.length() + 1][word2.length() + 1];\\n        return minDistanceFrom(word1, word2, 0, 0);\\n    }\\n    private int minDistanceFrom(String s1, String s2, int i1, int i2) {\\n        if (i1 == s1.length()) // Inserts all the remaining characters of s2\\n            return s2.length() - i2;\\n\\n        if (i2 == s2.length()) // Deletes all the remaining characters of s1\\n            return s1.length() - i1;\\n        \\n        if (dp[i1][i2] != null)\\n            return dp[i1][i2];\\n        \\n        if (s1.charAt(i1) == s2.charAt(i2)) {\\n            return dp[i1][i2] = minDistanceFrom(s1, s2, i1 + 1, i2 + 1);\\n        } else {\\n            int dist1 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2); // Deletes s1[i1] from s1\\n            int dist2 = 1 + minDistanceFrom(s1, s2, i1, i2 + 1); // Inserts s2[i2] to s1\\n            int dist3 = 1 + minDistanceFrom(s1, s2, i1 + 1, i2 + 1); // Replaces s1[i1] with s2[i2]\\n\\n            return dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n        }\\n    }\\n}\\n```\n```\\n    public int minDistance(String s1, String s2) {\\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\\n\\n        for (int i1 = 0; i1 <= s1.length(); i1++)\\n            dp[i1][0] = i1;\\n\\n        for (int i2 = 0; i2 <= s2.length(); i2++)\\n            dp[0][i2] = i2;\\n\\n        for (int i1 = 1; i1 <= s1.length(); i1++) {\\n            for (int i2 = 1; i2 <= s2.length(); i2++) {\\n                if (s1.charAt(i1 - 1) == s2.charAt(i2 - 1)) {\\n                    dp[i1][i2] = dp[i1 - 1][i2 - 1];\\n                } else {\\n                    int dist1 = 1 + dp[i1 - 1][i2]; // Deletes s1[i1] from s1\\n                    int dist2 = 1 + dp[i1][i2 - 1]; // Inserts s2[i2] to s1\\n                    int dist3 = 1 + dp[i1 - 1][i2 - 1]; // Replaces s1[i1] with s2[i2]\\n                    \\n                    dp[i1][i2] = Math.min(dist1, Math.min(dist2, dist3));\\n                }\\n            }\\n        }\\n\\n        return dp[s1.length()][s2.length()];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25902,
                "title": "c-recursive-dfs-8ms",
                "content": "Scan from the start while backtracking and exploring insert, delete and replace options, of course only when characters mismatch. As you can see below, memoization helps to short-circuit numerous paths.\\nMore details at [link](https://msreekan.com/2016/08/13/edit-distance/)\\n![alt text](https://tekrants.files.wordpress.com/2016/08/editdistance.jpg)\\n\\n```\\nvoid ml(char* w1, int o1, int l1, char* w2, int o2, int l2,\\n        unsigned char *dp)\\n{\\n    int offst = o1 * (l2 + 1) + o2, od = (o1 + 1) * (l2 + 1) + o2;\\n    int oi = o1 * (l2 + 1) + o2 + 1, r = 0;\\n\\n    if (o1 == l1 || o2 == l2) // end of string, return remaining bytes\\n        dp[offst] = (o1 == l1) ? l2 - o2 : l1 - o1;\\n\\n    /* If the minimum distance for strings at [o1..l1] & [o2..l2] is\\n       not already calculated, then figure out the same */\\n    else if (dp[offst] == MAX_CHAR)\\n    {\\n        if (w1[o1] != w2[o2]) // unequal characters\\n        {\\n            ml(w1, o1 + 1, l1, w2, o2, l2, dp); // delete\\n            ml(w1, o1, l1, w2, o2 + 1, l2, dp); // insert\\n            r++;\\n        }\\n\\n        ml(w1, o1 + 1, l1, w2, o2 + 1, l2, dp); // replace/chars equal\\n        dp[offst] = (r > 0) ? (MIN_INT(dp[od + 1] + r, dp[od] + r,\\n                    dp[oi] + r)) : dp[od + 1]; // pick minimum\\n    }\\n}\\n\\nint minDistance(char *word1, char * word2)\\n{\\n    int l1 = strlen(word1), l2 = strlen(word2), md = 0;\\n    unsigned char *dp = malloc((l1 + 1) * (l2 + 1) * sizeof(unsigned char));\\n\\n    /* Validate */\\n    if (!dp) return 0;\\n\\n    /* Initialize buffer */\\n    memset(dp, MAX_CHAR, (l1 + 1) * (l2 + 1));\\n\\n    /* Get the minimum distance */\\n    ml(word1, 0, l1, word2, 0, l2, dp);\\n    md = dp[0];\\n    free(dp);\\n    return md;\\n}\\n```\\n\\nEDIT : Just posted more details at the blog [link](https://msreekan.com/2016/08/13/edit-distance/)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid ml(char* w1, int o1, int l1, char* w2, int o2, int l2,\\n        unsigned char *dp)\\n{\\n    int offst = o1 * (l2 + 1) + o2, od = (o1 + 1) * (l2 + 1) + o2;\\n    int oi = o1 * (l2 + 1) + o2 + 1, r = 0;\\n\\n    if (o1 == l1 || o2 == l2) // end of string, return remaining bytes\\n        dp[offst] = (o1 == l1) ? l2 - o2 : l1 - o1;\\n\\n    /* If the minimum distance for strings at [o1..l1] & [o2..l2] is\\n       not already calculated, then figure out the same */\\n    else if (dp[offst] == MAX_CHAR)\\n    {\\n        if (w1[o1] != w2[o2]) // unequal characters\\n        {\\n            ml(w1, o1 + 1, l1, w2, o2, l2, dp); // delete\\n            ml(w1, o1, l1, w2, o2 + 1, l2, dp); // insert\\n            r++;\\n        }\\n\\n        ml(w1, o1 + 1, l1, w2, o2 + 1, l2, dp); // replace/chars equal\\n        dp[offst] = (r > 0) ? (MIN_INT(dp[od + 1] + r, dp[od] + r,\\n                    dp[oi] + r)) : dp[od + 1]; // pick minimum\\n    }\\n}\\n\\nint minDistance(char *word1, char * word2)\\n{\\n    int l1 = strlen(word1), l2 = strlen(word2), md = 0;\\n    unsigned char *dp = malloc((l1 + 1) * (l2 + 1) * sizeof(unsigned char));\\n\\n    /* Validate */\\n    if (!dp) return 0;\\n\\n    /* Initialize buffer */\\n    memset(dp, MAX_CHAR, (l1 + 1) * (l2 + 1));\\n\\n    /* Get the minimum distance */\\n    ml(word1, 0, l1, word2, 0, l2, dp);\\n    md = dp[0];\\n    free(dp);\\n    return md;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3527933,
                "title": "dynamic-programming-logic-bottom-to-up",
                "content": "# Dynamic programming:\\n```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        dp=[[0]*(len(t)+1) for i in range(len(s)+1)]\\n        for k in range(len(s)+1):\\n            dp[k][len(t)]=len(s)-k\\n        for k in range(len(t)+1):\\n            dp[len(s)][k]=len(t)-k\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(len(t)-1,-1,-1):\\n                if s[i]==t[j]:\\n                    dp[i][j]=dp[i+1][j+1]\\n                else:\\n                    dp[i][j]=1+min(dp[i+1][j+1],dp[i+1][j],dp[i][j+1])\\n        return dp[0][0]        \\t\\t\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, s: str, t: str) -> int:\\n        dp=[[0]*(len(t)+1) for i in range(len(s)+1)]\\n        for k in range(len(s)+1):\\n            dp[k][len(t)]=len(s)-k\\n        for k in range(len(t)+1):\\n            dp[len(s)][k]=len(t)-k\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(len(t)-1,-1,-1):\\n                if s[i]==t[j]:\\n                    dp[i][j]=dp[i+1][j+1]\\n                else:\\n                    dp[i][j]=1+min(dp[i+1][j+1],dp[i+1][j],dp[i][j+1])\\n        return dp[0][0]        \\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232410,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        if(i < 0){\\n            return j+1;\\n        }\\n        if(j < 0){\\n            return i+1;\\n        }\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        if(i < 0){\\n            return j+1;\\n        }\\n        if(j < 0){\\n            return i+1;\\n        }\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231996,
                "title": "c-bottom-top-dp-o-n-space",
                "content": "\\n# Code with O(nm) space\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        var dp = new int[m+1, n+1];\\n\\n        for(var i = 0; i <= m; i++)\\n        {\\n            dp[i, 0] = i;\\n        }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            dp[0, j] = j;    \\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                }\\n                else\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                }\\n            }\\n        }\\n\\n        return dp[m, n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```\\n\\n# Optimized Code with O(n) space\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        // var dp = new int[m+1, n+1];\\n        var prevRow = new int[n+1];\\n\\n        // for(var i = 0; i <= m; i++)\\n        // {\\n        //     dp[i, 0] = i;\\n        // }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            // dp[0, j] = j;    \\n            prevRow[j] = j;\\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            var curRow = new int[n+1];\\n            curRow[0] = i + 1;\\n\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1] + 1, curRow[j] + 1);\\n                }\\n                else\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1], curRow[j]) + 1;\\n                }\\n            }\\n            prevRow = curRow;\\n        }\\n\\n        // return dp[m, n];\\n        return prevRow[n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        var dp = new int[m+1, n+1];\\n\\n        for(var i = 0; i <= m; i++)\\n        {\\n            dp[i, 0] = i;\\n        }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            dp[0, j] = j;    \\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                }\\n                else\\n                {\\n                    dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                }\\n            }\\n        }\\n\\n        return dp[m, n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        var m = word1.Length;\\n        var n = word2.Length;\\n        // var dp = new int[m+1, n+1];\\n        var prevRow = new int[n+1];\\n\\n        // for(var i = 0; i <= m; i++)\\n        // {\\n        //     dp[i, 0] = i;\\n        // }\\n\\n        for(var j = 0; j <= n; j++)\\n        {\\n            // dp[0, j] = j;    \\n            prevRow[j] = j;\\n        }\\n\\n        for(var i = 0; i < m; i++)\\n        {\\n            var curRow = new int[n+1];\\n            curRow[0] = i + 1;\\n\\n            for(var j = 0; j < n; j++)\\n            {\\n                if(word1[i] == word2[j])\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1] + 1, dp[i+1, j] + 1);\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1] + 1, curRow[j] + 1);\\n                }\\n                else\\n                {\\n                    // dp[i+1, j+1] = Min(dp[i, j], dp[i, j+1], dp[i+1, j]) + 1;\\n                    curRow[j+1] = Min(prevRow[j], prevRow[j+1], curRow[j]) + 1;\\n                }\\n            }\\n            prevRow = curRow;\\n        }\\n\\n        // return dp[m, n];\\n        return prevRow[n];\\n\\n        int Min(params int[] arr)\\n        {\\n            return arr.Min();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231533,
                "title": "golang-dynamic-programming-with-explanation",
                "content": "# Intuition\\nWe will have to draw a table to help understand how DP works in this solution:\\n\\n||empty str|r|o|s|\\n|:-:|:-:|:-:|:-:|:-:|\\n|empty str|0|1|2|3|\\n|h|1|1|2|3|\\n|o|2|2|1|2|\\n|r|3|2|2|2|\\n|s|4|3|3|2|\\n|e|5|4|4|**3**|\\n\\nIn this table, the number in the cells stands for **the minimum operation times** needed to transform from `word1` to `word2`. Note we only care about the first `n` chars when we fill the `nth` row or cols!\\n\\nFor example, we only care about `hor` when we are dealing with `row \\'r\\'`.\\n\\nMore specifically:\\n1. In `row \\'h\\'`, `col \\'r\\'`, we only care about how to transform from \\'h\\' to \\'r\\'.\\n2. In `row \\'o\\'`, `col \\'r\\'`, we only care about how to transform from \\'ho\\' to \\'r\\'.\\n3.  In `row \\'r\\'`, `col \\'o\\'`, we only care about how to transform from \\'hor\\' to \\'ro\\'.\\n4. ... I believe you get the point! \\uD83D\\uDE0A\\n\\nWhat we will do is to find a way to quickly fill the table! The number in the bottom-right of the table will be our answer.\\n\\nWhen you mannually fill this table, I believe you can find some certain rules:\\n+ the number in the first col (i.e. `col \\'empty str\\'`) always equals to the **row index**. This is because we need to remove every char in `word2` to get a empty `word1`!\\n+ If the last char of `word2` is identical to the last char of `word1`, the operation number should be the same as `table[i-1][j-1]` (just imagine we are dealing with `table[i][j]`)! This is because **if the last char of the two words are the same, we need no more extra operation**!\\n+ If the last char of `word2` is different from the last char of `word1`, we will have to look at these 3 cells: `table[i][j - 1]`, `table[i - 1][j - 1]` and `table[i - 1][j]`. We will fill `table[i][j]` with the minimum number plus 1. This is because **we have to deal with this char difference (plus 1), and we will choose the optimal way to conduct the former transformation**!\\n\\n# Code\\n```\\nfunc minDistance(word1 string, word2 string) int {\\n    pre := make([]int, len(word2) + 1)\\n    cur := make([]int, len(word2) + 1)\\n    for i := 0; i < len(pre); i++ {\\n        pre[i] = i\\n    }\\n    for i := 1; i <= len(word1); i++ {\\n        cur[0] = i\\n        for j := 1; j < len(pre); j++ {\\n            if word1[i - 1] != word2[j - 1] {\\n                cur[j] = min(cur[j - 1], pre[j - 1], pre[j]) + 1\\n            } else {\\n                cur[j] = pre[j - 1]\\n            }\\n        }\\n        tmp := make([]int, len(cur))\\n        copy(tmp, cur)\\n        pre = tmp\\n    }\\n    return pre[len(word2)]\\n}\\n\\nfunc min(nums ...int) int {\\n    ans := nums[0]\\n    for _, v := range nums {\\n        if v < ans {\\n            ans = v\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc minDistance(word1 string, word2 string) int {\\n    pre := make([]int, len(word2) + 1)\\n    cur := make([]int, len(word2) + 1)\\n    for i := 0; i < len(pre); i++ {\\n        pre[i] = i\\n    }\\n    for i := 1; i <= len(word1); i++ {\\n        cur[0] = i\\n        for j := 1; j < len(pre); j++ {\\n            if word1[i - 1] != word2[j - 1] {\\n                cur[j] = min(cur[j - 1], pre[j - 1], pre[j]) + 1\\n            } else {\\n                cur[j] = pre[j - 1]\\n            }\\n        }\\n        tmp := make([]int, len(cur))\\n        copy(tmp, cur)\\n        pre = tmp\\n    }\\n    return pre[len(word2)]\\n}\\n\\nfunc min(nums ...int) int {\\n    ans := nums[0]\\n    for _, v := range nums {\\n        if v < ans {\\n            ans = v\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230623,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int fun(int i,int j,string& word1,string& word2,vector<vector<int>> &dp)\\n    {\\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=fun(i-1,j-1,word1,word2,dp);\\n        }\\n        int ins=1+fun(i,j-1,word1,word2,dp);\\n        int del=1+fun(i-1,j,word1,word2,dp);\\n        int rep=1+fun(i-1,j-1,word1,word2,dp);\\n        return dp[i][j]=min(ins,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return fun(m-1,n-1,word1,word2,dp);\\n    }\\n};\\n```\\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int j=0;j<=n;j++){\\n            dp[0][j]=j;\\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++){\\n                if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1];\\n                    continue;\\n                }\\n                int ins=1+dp[i][j-1];\\n                int del=1+dp[i-1][j];\\n                int rep=1+dp[i-1][j-1];\\n                dp[i][j]=min(ins,min(del,rep));        \\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int fun(int i,int j,string& word1,string& word2,vector<vector<int>> &dp)\\n    {\\n        if(j<0){\\n            return i+1;\\n        }\\n        if(i<0){\\n            return j+1;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=fun(i-1,j-1,word1,word2,dp);\\n        }\\n        int ins=1+fun(i,j-1,word1,word2,dp);\\n        int del=1+fun(i-1,j,word1,word2,dp);\\n        int rep=1+fun(i-1,j-1,word1,word2,dp);\\n        return dp[i][j]=min(ins,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return fun(m-1,n-1,word1,word2,dp);\\n    }\\n};\\n```\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(int j=0;j<=n;j++){\\n            dp[0][j]=j;\\n        }\\n        for(int i=0;i<=m;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++){\\n                if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]=dp[i-1][j-1];\\n                    continue;\\n                }\\n                int ins=1+dp[i][j-1];\\n                int del=1+dp[i-1][j];\\n                int rep=1+dp[i-1][j-1];\\n                dp[i][j]=min(ins,min(del,rep));        \\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063353,
                "title": "optimized-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each index in string S1, there are three options for matching that index with string S2. Replace a character, delete a character, or insert a character at its index. So you can think in terms of string match paths. With no consistent data, there\\'s no way to find out other than trying all possible methods. To do this, you have to use recursion.\\n\\n**Step 1: Index the problem**:\\n\\n>  We need two indices for iterating over both the strings.\\n\\n\\n**Step 2: Try all possible options given the index.**\\n\\n> We have the cases of MATCH and MISMATCH\\n\\n1. MATCH: If the i and the j characters of word1 and word2 match, then we must reduce both the indices and calculate the solution for f(i-1,j-1)\\n2. MISMATCH : If the i and the j characters of word1 and word2 mismatch, then we  have three possiblities: \\n      - **Insert**: We insert word2[j] in word1 at position i and thus call the function f(i, j-1).\\n      - **Delete**: We delete the word1[i] character and thus call the function f(i-1,j).\\n      - **Replace**: We simply replace the word1[i] with word2[j], thus we should call f(i-1,j-1).\\n\\n**Step 3: Return the minimum value of all choices.**\\n1. MATCH: return f(i-1,j-1)\\n2. MISMATCH: return 1 + min({f(i-1,j), f(i,j-1), f(i-1,j-1)})\\n\\n#### BASE CASES\\n\\n1. if i<0 then return j;\\n2. if j<0 then return i;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can memoize the above recursive formula, but we will use Tabulation to avoid extra recursive stack space and Recursion Overhead.\\n\\n> In order to implement the Tabulation, we need to take care of the negative indices. Thus we shift ourselves to 1-based indexing.\\n\\nPROCEDURE:\\n\\n1. We initialise a 2D vector with the first col filled with the row numbers and the first row filled with row numbers.\\n2. Fill the matrix using the recursive formulation.\\n3. Return dp[n][m] as the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &word1, string &word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n        for(int row = 1;row<=n;row++)\\n            dp[row][0] = row;\\n        for(int col = 1;col<=m;col++)\\n            dp[0][col] = col;\\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j], dp[i-1][j-1], dp[i][j-1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string &word1, string &word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n        for(int row = 1;row<=n;row++)\\n            dp[row][0] = row;\\n        for(int col = 1;col<=m;col++)\\n            dp[0][col] = col;\\n        for(int i = 1;i<=n;i++){\\n            for(int j = 1;j<=m;j++){\\n                if(word1[i-1] == word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j], dp[i-1][j-1], dp[i][j-1]});\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818044,
                "title": "java-dp-tabulation",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n        int ans;\\n\\n        for(int i = 0; i <= m; i++){\\n            dp[i][0] = i;\\n        }\\n        for(int i = 0; i <= n; i++){\\n            dp[0][i] = i;\\n        }\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                ans = dp[i - 1][j - 1];\\n\\n                if(word1.charAt(m - i) != word2.charAt(n - j)){\\n                    ans = 1 + Math.min(ans, Math.min(dp[i][j - 1], dp[i - 1][j]));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n\\n        int[][] dp = new int[m + 1][n + 1];\\n        int ans;\\n\\n        for(int i = 0; i <= m; i++){\\n            dp[i][0] = i;\\n        }\\n        for(int i = 0; i <= n; i++){\\n            dp[0][i] = i;\\n        }\\n\\n        for(int i = 1; i <= m; i++){\\n            for(int j = 1; j <= n; j++){\\n                ans = dp[i - 1][j - 1];\\n\\n                if(word1.charAt(m - i) != word2.charAt(n - j)){\\n                    ans = 1 + Math.min(ans, Math.min(dp[i][j - 1], dp[i - 1][j]));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579271,
                "title": "c-most-detailed-from-recursive-to-space-optmisation",
                "content": "## Approach:\\n\\n--> Here we can follow string matching method where we will match every character using 2 variables `i and j where i will traverse s1 and j will traverse s2` and then we will have 2 conditions:\\n\\n1. If they are matching:\\n\\t- then we will simply decrease both i and j \\n\\t- we are not applying any step here\\n2. If they are not matching:\\n\\t- Then we have 3 possibilities here:\\n\\t\\t- Insert s[j] character at that place\\n\\t\\t- Delete this character and decrease i\\n\\t\\t- Replace ith character with s[j]\\n\\t\\t- we are applying any one of the step here so we will add 1 to total steps.\\n\\t\\t\\n--> Let\\'s see all these conditions in bit detail:\\n\\n### If they are not matching:\\n\\n**1. If we insert s[j] character at that place:**\\n\\nTake a look at this example:\\n\\n![image](https://assets.leetcode.com/users/images/92c6e07c-3694-4fa5-8efc-5bbb83e3243c_1663240869.4235468.png)\\n\\nHere we will just decrease `j` because we have added jth character so they are matched.\\n```cpp\\n1 + solve(i,j-1);\\n```\\n\\n**2. If we delete the ith character:**\\n\\nThen we will simply decrease `i`.\\n```cpp\\n1 + solve(i-1,j);\\n```\\n\\n**3. If we replace the ith character:**\\n\\nHere we will ofcourse replace the ith character with s[j] and then they both will match and we will decrease both `i and j`.\\n```cpp\\n1 + solve(i-1,j-1);\\n```\\n\\nAt last take the `minimum` of these 3 steps:\\n\\n### If they are matching:\\n\\njust decrease both i and j but don\\'t add 1 in steps because we haven\\'t performed any step here.\\n\\n```cpp\\nsolve(i-1,j-1);\\n```\\n\\n## Base case:\\n\\nHere we will have 2 conditions:\\n\\n1. If we have traversed all s1 string means i is negative and j is still have some value.\\n\\t- For example we have to make `ros` from `horse` and we have traversed whole horse string and j is at character `o` then we will have to make `ro` from empty string, so here we will perform `2 insert operations`.\\n\\t- so if i becomes negative then we will return `j+1`.\\n2. If we have traversed all s2 string means j is negative and i is still have some value.\\n\\t- For example in `ros and horse` we have traversed whole `ros` and i is at `r` character so that means we have to make empty string from `hor` so we will have to perform `3 deletion operation to make it empty string`. \\n\\t- So if j becomes negative then we will return `i+1`.\\n\\n```cpp\\nif(i < 0){\\n\\treturn j+1;\\n}\\nif(j < 0){\\n\\treturn i+1;\\n}\\n```\\n\\n## Recursive code:\\n\\n```cpp\\nint solve(int i,int j,string &s1,string &s2){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn solve(i-1,j-1,s1,s2);\\n\\t}\\n\\telse{\\n\\t\\treturn 1 + min(min(solve(i,j-1,s1,s2),solve(i-1,j,s1,s2)), solve(i-1,j-1,s1,s2));\\n\\t}\\n}\\n```\\n\\n## Memoization Code:\\n\\n```cpp\\nint solve(int i,int j,string &s1,string &s2,vector<vector<int>>&dp){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s1,s2,dp);\\n\\t}\\n\\telse{\\n\\t\\treturn dp[i][j] =  1 + min(min(solve(i,j-1,s1,s2,dp),solve(i-1,j,s1,s2,dp)), solve(i-1,j-1,s1,s2,dp));\\n\\t}\\n}\\nint main(){\\n\\t// n is size of s1 and m is size of s2\\n\\tvector<vector<int>>dp(n,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s1,s2,dp);\\n}\\n```\\n\\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(NxM) + stack space of O(N+M)\\n```\\n\\n## Tabulation Code:\\n\\n--> Let\\'s use tabulation to remove the stack space.\\n\\nSo in tabulation we just have to do one smaller change which will be `we will use 1 based indexing here` because in base case we are checking if i or j becomes negative but it\\'s not possible here so that\\'s why we will use 1 based indexing and our dp array size will be `N+1xM+1`\\n\\nAlso during checking the characters we will have to check like this:\\n```cpp\\nif(s1[i-1] == s2[j-1]);\\n```\\n\\nAlso in base case if `i` is 0 then we will add `j` for it instead of j+1 because we are following 1 based indexing and same for j also.\\n\\n```cpp\\nint minDistance(string s1, string s2) {\\n        int n = s1.size(),m = s2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        // if j is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = i;\\n        }\\n        // if i is 0\\n\\t\\t// starting from 1 because we have already considered dp[0][0] in above loop\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = 1 + min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\n## Space optimisation:\\n\\n--> Here we can see that we are only required previous row(dp[i-1]) and current row (dp[i]) to find answer for current row.\\n\\nSo we will make 2 separate arrays `prev and curr` which will act as rows and after each inner iteration, we will swap them.\\n\\nNow here we can see for every `i=0` we have to put `0,1,2,3..` as j so we will initialise prev as `0,1,2,3...` and also for every `j=0` we have to put `0,1,2,3...` i.e every row\\'s first element will be current index so after each inner iteration we will do `curr[0] = i`.\\n\\nSo let\\'s optimise the space complexity:\\n\\n```cpp\\nint minDistance(string s1, string s2) {\\n\\tint n = s1.size(),m = s2.size();\\n\\tvector<int>prev(m+1,0),curr(m+1,0);\\n\\tfor(int j=1;j<=m;j++){\\n\\t\\tprev[j] = j;\\n\\t}\\n\\tfor(int i=1;i<=n;i++){\\n\\t// Initialising first element after each iteration\\n\\t\\tcurr[0] = i;\\n\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\tcurr[j] = prev[j-1];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tcurr[j] = 1 + min(min(curr[j-1],prev[j]),prev[j-1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// swapping prev and curr\\n\\t\\tprev = curr;\\n\\t}\\n\\treturn prev[m];\\n}\\n```\\n\\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(M)\\n```\\n\\n----\\n\\nIf you want to see more solutions like this find it [here](https://github.com/shivam1317/DSA-Notes)\\nThanks for reading.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n1 + solve(i,j-1);\\n```\n```cpp\\n1 + solve(i-1,j);\\n```\n```cpp\\n1 + solve(i-1,j-1);\\n```\n```cpp\\nsolve(i-1,j-1);\\n```\n```cpp\\nif(i < 0){\\n\\treturn j+1;\\n}\\nif(j < 0){\\n\\treturn i+1;\\n}\\n```\n```cpp\\nint solve(int i,int j,string &s1,string &s2){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn solve(i-1,j-1,s1,s2);\\n\\t}\\n\\telse{\\n\\t\\treturn 1 + min(min(solve(i,j-1,s1,s2),solve(i-1,j,s1,s2)), solve(i-1,j-1,s1,s2));\\n\\t}\\n}\\n```\n```cpp\\nint solve(int i,int j,string &s1,string &s2,vector<vector<int>>&dp){\\n\\tif(i < 0){\\n\\t\\treturn j+1;\\n\\t}\\n\\tif(j < 0){\\n\\t\\treturn i+1;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(s1[i] == s2[j]){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s1,s2,dp);\\n\\t}\\n\\telse{\\n\\t\\treturn dp[i][j] =  1 + min(min(solve(i,j-1,s1,s2,dp),solve(i-1,j,s1,s2,dp)), solve(i-1,j-1,s1,s2,dp));\\n\\t}\\n}\\nint main(){\\n\\t// n is size of s1 and m is size of s2\\n\\tvector<vector<int>>dp(n,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s1,s2,dp);\\n}\\n```\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(NxM) + stack space of O(N+M)\\n```\n```cpp\\nif(s1[i-1] == s2[j-1]);\\n```\n```cpp\\nint minDistance(string s1, string s2) {\\n        int n = s1.size(),m = s2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        // if j is 0\\n        for(int i=0;i<=n;i++){\\n            dp[i][0] = i;\\n        }\\n        // if i is 0\\n\\t\\t// starting from 1 because we have already considered dp[0][0] in above loop\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s1[i-1] == s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = 1 + min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```cpp\\nint minDistance(string s1, string s2) {\\n\\tint n = s1.size(),m = s2.size();\\n\\tvector<int>prev(m+1,0),curr(m+1,0);\\n\\tfor(int j=1;j<=m;j++){\\n\\t\\tprev[j] = j;\\n\\t}\\n\\tfor(int i=1;i<=n;i++){\\n\\t// Initialising first element after each iteration\\n\\t\\tcurr[0] = i;\\n\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\tif(s1[i-1] == s2[j-1]){\\n\\t\\t\\t\\tcurr[j] = prev[j-1];\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tcurr[j] = 1 + min(min(curr[j-1],prev[j]),prev[j-1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// swapping prev and curr\\n\\t\\tprev = curr;\\n\\t}\\n\\treturn prev[m];\\n}\\n```\n```\\nTime complexity: O(NxM)\\nSpace complexity: O(M)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2268259,
                "title": "java-solution-memoization-tabulation-dp",
                "content": "Both Memoization And Tabulation solutions are given below, you can choose any.\\nIf you like the approach, then UPVOTE :) please\\n\\nMemoization Solution:\\ndist(s1 , s2 , i , j-1 , dp) => It implies insertion at end (I have not said replacing) hypothetically\\ndist(s1 , s2 , i-1 , j , dp) => It implies deletion\\ndist(s1 , s2 , i-1 , j-1 , dp) => It implies replacing\\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1][l2];\\n        for(int i = 0 ; i < l1 ; i++)\\n            for(int j = 0 ; j < l2 ; j++)\\n                dp[i][j] = -1;\\n        return dist(w1 , w2 , l1-1, l2-1 , dp);    \\n    }\\n    \\n    public int dist(String s1, String s2 , int i , int j , int[][] dp){\\n        if(i < 0)   return j+1;\\n        if(j < 0) return i+1;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s1.charAt(i) == s2.charAt(j))    return dp[i][j] = dist(s1 , s2 , i-1 , j-1 , dp);\\n        \\n        return dp[i][j] = 1+Math.min(dist(s1 , s2 , i , j-1 , dp) , Math.min(dist(s1 , s2 , i-1 , j , dp) , dist(s1 , s2 , i-1 , j-1 , dp)));\\n    }\\n}\\n```\\n\\nTabulation Solution:\\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1+1][l2+1];\\n        for(int i = 0 ; i <= l1 ; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j = 0 ; j <= l2 ; j++)\\n            dp[0][j] = j;\\n        \\n        for(int i = 1 ; i <= l1 ; i++)\\n            for(int j = 1 ; j <= l2 ; j++){\\n                if(w1.charAt(i-1) == w2.charAt(j-1))   dp[i][j] = dp[i-1][j-1];\\n        \\n                else    dp[i][j] = 1 + Math.min(dp[i][j-1] , Math.min(dp[i-1][j] , dp[i-1][j-1]));\\n            }\\n        \\n        return dp[l1][l2];\\n    }\\n} \\n```\\nHaven\\'t UPVOTED yet, can do it now :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1][l2];\\n        for(int i = 0 ; i < l1 ; i++)\\n            for(int j = 0 ; j < l2 ; j++)\\n                dp[i][j] = -1;\\n        return dist(w1 , w2 , l1-1, l2-1 , dp);    \\n    }\\n    \\n    public int dist(String s1, String s2 , int i , int j , int[][] dp){\\n        if(i < 0)   return j+1;\\n        if(j < 0) return i+1;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s1.charAt(i) == s2.charAt(j))    return dp[i][j] = dist(s1 , s2 , i-1 , j-1 , dp);\\n        \\n        return dp[i][j] = 1+Math.min(dist(s1 , s2 , i , j-1 , dp) , Math.min(dist(s1 , s2 , i-1 , j , dp) , dist(s1 , s2 , i-1 , j-1 , dp)));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDistance(String w1, String w2) {\\n        int l1 = w1.length();\\n        int l2 = w2.length();\\n        \\n        int[][] dp = new int[l1+1][l2+1];\\n        for(int i = 0 ; i <= l1 ; i++)\\n            dp[i][0] = i;\\n        \\n        for(int j = 0 ; j <= l2 ; j++)\\n            dp[0][j] = j;\\n        \\n        for(int i = 1 ; i <= l1 ; i++)\\n            for(int j = 1 ; j <= l2 ; j++){\\n                if(w1.charAt(i-1) == w2.charAt(j-1))   dp[i][j] = dp[i-1][j-1];\\n        \\n                else    dp[i][j] = 1 + Math.min(dp[i][j-1] , Math.min(dp[i-1][j] , dp[i-1][j-1]));\\n            }\\n        \\n        return dp[l1][l2];\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180656,
                "title": "python3-solution-using-dp-top-down-approach",
                "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        dp = {}\\n        \\n        def getResult(i,j):\\n            if i == len(word1) and j == len(word2):\\n                return 0\\n            if i == len(word1):\\n                return len(word2) - j\\n            if j == len(word2):\\n                return len(word1) - i\\n\\n            if (i, j) not in dp:\\n                if word1[i] == word2[j]:\\n                    ans = getResult(i + 1, j + 1)\\n                else: \\n                    insert = 1 + getResult(i, j + 1)\\n                    delete = 1 + getResult(i + 1, j)\\n                    replace = 1 + getResult(i + 1, j + 1)\\n                    ans = min(insert, delete, replace)\\n                dp[(i, j)] = ans\\n            return dp[(i, j)]\\n        \\n        return getResult(0,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        dp = {}\\n        \\n        def getResult(i,j):\\n            if i == len(word1) and j == len(word2):\\n                return 0\\n            if i == len(word1):\\n                return len(word2) - j\\n            if j == len(word2):\\n                return len(word1) - i\\n\\n            if (i, j) not in dp:\\n                if word1[i] == word2[j]:\\n                    ans = getResult(i + 1, j + 1)\\n                else: \\n                    insert = 1 + getResult(i, j + 1)\\n                    delete = 1 + getResult(i + 1, j)\\n                    replace = 1 + getResult(i + 1, j + 1)\\n                    ans = min(insert, delete, replace)\\n                dp[(i, j)] = ans\\n            return dp[(i, j)]\\n        \\n        return getResult(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204823,
                "title": "c-three-solutions-recursion-top-down-bottom-up-dp",
                "content": "**Recursive Solution\\nTime Complexity - O (3 ^ max(a, b))\\nSpace Complexity - O (1)**\\n\\n```\\nint minDist(string a, string b, int i, int j) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (a[i] == b[j]) {\\n            return minDist(a, b, i - 1, j - 1);\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1);\\n            int replace = minDist(a, b, i - 1, j - 1);\\n            int remove = minDist(a, b, i - 1, j);\\n            \\n            return 1 + min(min(add, replace), remove);\\n        }\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Top Down DP Solution**\\n\\n```\\nint minDist(string a, string b, int i, int j, vector <vector <int>> dp) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        if (a[i] == b[j]) {\\n            dp[i][j] =  minDist(a, b, i - 1, j - 1, dp);\\n            return dp[i][j];\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1, dp);\\n            int replace = minDist(a, b, i - 1, j - 1, dp);\\n            int remove = minDist(a, b, i - 1, j, dp);\\n            \\n            dp[i][j] =  1 + min(min(add, replace), remove);\\n            return dp[i][j];\\n        }\\n    }\\n```\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Bottom Up DP Solution\\nTime Complexity - O (a * b)\\nSpace Complexity - O (a * b)**\\n\\n```\\nint minDist(string a, string b) {\\n        vector <vector <int>> dp(a.length() + 1, vector <int>(b.length() + 1, -1));\\n        \\n        for (int i = 0; i < a.length() + 1; i++) {\\n            for (int j = 0; j < b.length() + 1; j++) {\\n                if (i == 0) {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0) {\\n                    dp[i][j] = i;\\n                }\\n                else {\\n                    if (a[i - 1] == b[j - 1]) {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else {\\n                        int add = dp[i][j - 1];\\n                        int replace = dp[i- 1][j - 1];\\n                        int remove = dp[i - 1][j];\\n                        \\n                        dp[i][j] = 1 + min(min(add, replace), remove);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[a.length()][b.length()];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint minDist(string a, string b, int i, int j) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (a[i] == b[j]) {\\n            return minDist(a, b, i - 1, j - 1);\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1);\\n            int replace = minDist(a, b, i - 1, j - 1);\\n            int remove = minDist(a, b, i - 1, j);\\n            \\n            return 1 + min(min(add, replace), remove);\\n        }\\n    }\\n```\n```\\nint minDist(string a, string b, int i, int j, vector <vector <int>> dp) {\\n        if (i == -1) {\\n            return j + 1;\\n        }\\n        if (j == -1) {\\n            return i + 1;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        if (a[i] == b[j]) {\\n            dp[i][j] =  minDist(a, b, i - 1, j - 1, dp);\\n            return dp[i][j];\\n        }\\n        else {\\n            int add = minDist(a, b, i, j - 1, dp);\\n            int replace = minDist(a, b, i - 1, j - 1, dp);\\n            int remove = minDist(a, b, i - 1, j, dp);\\n            \\n            dp[i][j] =  1 + min(min(add, replace), remove);\\n            return dp[i][j];\\n        }\\n    }\\n```\n```\\nint minDist(string a, string b) {\\n        vector <vector <int>> dp(a.length() + 1, vector <int>(b.length() + 1, -1));\\n        \\n        for (int i = 0; i < a.length() + 1; i++) {\\n            for (int j = 0; j < b.length() + 1; j++) {\\n                if (i == 0) {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0) {\\n                    dp[i][j] = i;\\n                }\\n                else {\\n                    if (a[i - 1] == b[j - 1]) {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else {\\n                        int add = dp[i][j - 1];\\n                        int replace = dp[i- 1][j - 1];\\n                        int remove = dp[i - 1][j];\\n                        \\n                        dp[i][j] = 1 + min(min(add, replace), remove);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[a.length()][b.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776867,
                "title": "javascript-clean-recursive-dp",
                "content": "```javascript\\nvar minDistance = function(word1, word2) {\\n    const memo = new Map();\\n    \\n    function run(w1, w2) {\\n        if(memo.has(`${w1}-${w2}`)) return memo.get(`${w1}-${w2}`)\\n        if(w1 >= word1.length && w2 >= word2.length) return 0;\\n        \\n        // if it\\'s a match\\n        if(word1[w1] === word2[w2]) return run(w1+1, w2+1);\\n        \\n        let insert = Infinity, del = Infinity, replace = Infinity;\\n        \\n        // insert\\n        if(w2 < word2.length) insert = run(w1, w2+1);\\n        \\n        // delete\\n        if(w1 < word1.length) del = run(w1+1, w2);\\n        \\n        // replace\\n        if(w1 < word1.length && w2 < word2.length) replace = run(w1+1, w2+1);\\n        \\n        const res = Math.min(insert, del, replace) + 1;\\n        memo.set(`${w1}-${w2}`, res);\\n        return res;\\n    }\\n    return run(0, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```javascript\\nvar minDistance = function(word1, word2) {\\n    const memo = new Map();\\n    \\n    function run(w1, w2) {\\n        if(memo.has(`${w1}-${w2}`)) return memo.get(`${w1}-${w2}`)\\n        if(w1 >= word1.length && w2 >= word2.length) return 0;\\n        \\n        // if it\\'s a match\\n        if(word1[w1] === word2[w2]) return run(w1+1, w2+1);\\n        \\n        let insert = Infinity, del = Infinity, replace = Infinity;\\n        \\n        // insert\\n        if(w2 < word2.length) insert = run(w1, w2+1);\\n        \\n        // delete\\n        if(w1 < word1.length) del = run(w1+1, w2);\\n        \\n        // replace\\n        if(w1 < word1.length && w2 < word2.length) replace = run(w1+1, w2+1);\\n        \\n        const res = Math.min(insert, del, replace) + 1;\\n        memo.set(`${w1}-${w2}`, res);\\n        return res;\\n    }\\n    return run(0, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662438,
                "title": "recursion-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string s1, string s2, vector<vector<int>> &dp)\\n    {\\n        if(i == s1.length() && j == s2.length()) return 0;\\n        if(i == s1.length()) return s2.length()-j;\\n        if(j == s2.length()) return s1.length()-i;\\n        int &ans = dp[i][j];\\n        if(ans != -1) return ans;\\n        ans = INT_MAX;\\n        if(s1[i] == s2[j])\\n        {\\n            ans = solve(i+1, j+1, s1, s2, dp);\\n        }\\n        else\\n        {\\n            ans = min(ans, solve(i, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j, s1, s2, dp));\\n            ans = ans + 1;\\n        }\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        return solve(0, 0, s1, s2, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, string s1, string s2, vector<vector<int>> &dp)\\n    {\\n        if(i == s1.length() && j == s2.length()) return 0;\\n        if(i == s1.length()) return s2.length()-j;\\n        if(j == s2.length()) return s1.length()-i;\\n        int &ans = dp[i][j];\\n        if(ans != -1) return ans;\\n        ans = INT_MAX;\\n        if(s1[i] == s2[j])\\n        {\\n            ans = solve(i+1, j+1, s1, s2, dp);\\n        }\\n        else\\n        {\\n            ans = min(ans, solve(i, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j+1, s1, s2, dp));\\n            ans = min(ans, solve(i+1, j, s1, s2, dp));\\n            ans = ans + 1;\\n        }\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        return solve(0, 0, s1, s2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662428,
                "title": "rust-bottom-up-dp-with-explanations-o-m-n-time-o-n-space-0-ms-faster-than-100",
                "content": "#### Solution\\n\\n```rust\\nimpl Solution {\\n    pub fn min_distance(word1: String, word2: String) -> i32 {\\n        // Treat characters as raw bytes, as it allows us to directly access the underlying arrays:\\n        let (word1, word2) = (word1.as_bytes(), word2.as_bytes());\\n\\n        // Allocate memory in one-go, as it is typically faster:\\n        let mut dist = Vec::with_capacity(word2.len() + 1);\\n\\n        // Base case: we need to delete j characters in word2 in order to match the empty string word1:\\n        for j in 0..=word2.len() {\\n            dist.push(j)\\n        }\\n\\n        // Use a second vector to store distances for i - 1.\\n\\t\\t// This uses less memory than having a matrix of size (m, n), \\n\\t\\t// and we always just use the previous row in the matrix anyway:\\n        let mut prev_dist = dist.clone();\\n\\n        for i in 1..=word1.len() {\\n            for j in 0..=word2.len() {\\n                if j == 0 {\\n                    dist[j] += 1; // Base case: we need to insert a character in order to match word1.\\n                } else if word1[i - 1] == word2[j - 1] {\\n                    // No difference, don\\'t increment the edit distance:\\n                    dist[j] = prev_dist[j - 1];\\n                } else {\\n                    // Either insert, delete or replace a character: increment the edit distance by one:\\n                    dist[j] = dist[j].min(dist[j - 1]).min(prev_dist[j - 1]) + 1;\\n                }\\n            }\\n            prev_dist.copy_from_slice(&dist); // Backup the distances for this row using memcpy.\\n        }\\n        dist[word2.len()] as i32\\n    }\\n}\\n```\\n\\nThis algorithm gradually calculates the edit distance by iterating over the characters of the two provided words. `dist` and `prev_dist` represent two consecutive rows in the following distances matrix:\\n\\n<img src=\"https://assets.leetcode.com/users/marccarre/image_1590915262.png\" width=\"180px\" />\\n\\n#### Performance\\n\\n> Runtime: 0 ms, faster than 100.00% of Rust online submissions for Edit Distance.\\n> Memory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Edit Distance.\\n",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_distance(word1: String, word2: String) -> i32 {\\n        // Treat characters as raw bytes, as it allows us to directly access the underlying arrays:\\n        let (word1, word2) = (word1.as_bytes(), word2.as_bytes());\\n\\n        // Allocate memory in one-go, as it is typically faster:\\n        let mut dist = Vec::with_capacity(word2.len() + 1);\\n\\n        // Base case: we need to delete j characters in word2 in order to match the empty string word1:\\n        for j in 0..=word2.len() {\\n            dist.push(j)\\n        }\\n\\n        // Use a second vector to store distances for i - 1.\\n\\t\\t// This uses less memory than having a matrix of size (m, n), \\n\\t\\t// and we always just use the previous row in the matrix anyway:\\n        let mut prev_dist = dist.clone();\\n\\n        for i in 1..=word1.len() {\\n            for j in 0..=word2.len() {\\n                if j == 0 {\\n                    dist[j] += 1; // Base case: we need to insert a character in order to match word1.\\n                } else if word1[i - 1] == word2[j - 1] {\\n                    // No difference, don\\'t increment the edit distance:\\n                    dist[j] = prev_dist[j - 1];\\n                } else {\\n                    // Either insert, delete or replace a character: increment the edit distance by one:\\n                    dist[j] = dist[j].min(dist[j - 1]).min(prev_dist[j - 1]) + 1;\\n                }\\n            }\\n            prev_dist.copy_from_slice(&dist); // Backup the distances for this row using memcpy.\\n        }\\n        dist[word2.len()] as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313925,
                "title": "swift-85-beat-using-dynamic-programming-solution-o-n-m-quadratic-speed-eazy-breezy",
                "content": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        \\n        if word1.count == 0 { return word2.count }\\n        if word2.count == 0 { return word1.count }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: word2.count + 1), count: word1.count + 1)\\n        \\n        for x in 0...word1.count { grid[x][0] = x }\\n        for y in 0...word2.count { grid[0][y] = y }\\n        \\n        var word1 = Array(word1)\\n        var word2 = Array(word2)\\n        \\n        for x in 1...word1.count {\\n            for y in 1...word2.count {\\n                if word1[x - 1] == word2[y - 1] {\\n                    grid[x][y] = grid[x-1][y-1]\\n                } else {   \\n                    grid[x][y] = min(grid[x-1][y], min(grid[x-1][y-1], grid[x][y-1])) + 1\\n                }       \\n            }\\n        }\\n        return grid[word1.count][word2.count]\\n    }\\n}\\n```\\n\\nBoom, you\\'re on the payroll now. Winner winner, chicken dinner. I guess that\\'s why they call it the blues.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minDistance(_ word1: String, _ word2: String) -> Int {\\n        \\n        if word1.count == 0 { return word2.count }\\n        if word2.count == 0 { return word1.count }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: word2.count + 1), count: word1.count + 1)\\n        \\n        for x in 0...word1.count { grid[x][0] = x }\\n        for y in 0...word2.count { grid[0][y] = y }\\n        \\n        var word1 = Array(word1)\\n        var word2 = Array(word2)\\n        \\n        for x in 1...word1.count {\\n            for y in 1...word2.count {\\n                if word1[x - 1] == word2[y - 1] {\\n                    grid[x][y] = grid[x-1][y-1]\\n                } else {   \\n                    grid[x][y] = min(grid[x-1][y], min(grid[x-1][y-1], grid[x][y-1])) + 1\\n                }       \\n            }\\n        }\\n        return grid[word1.count][word2.count]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261880,
                "title": "java-dp-solution-beats-99-81-on-runtime-bottonup-space-o-n",
                "content": "\\n__Recursive Approach__(TLE) : In this Approach for Word1 we have 3 Operations which are Insert, Delete or Replace.\\n\\nIf the First character of both of the Words are same then we need not to perform any of the Operation but if the Character is not same then we need to check which of the Operation among the insert, delete or replace will give the minimum answer.\\n\\nSo to find the minimum answer we need to check all of the 3 Possible Operations and then we will check among them which is minimum and then simply return the answer.\\n\\n**In Case the Character of both of the Word is Matching**\\nSimply Skip the similar character and hunt for the dissimilar One in the Word1.\\n\\n**In Case the Character we are Checking is not matching with the Character of Word1**\\n1. __Insert__ : In this Case we will Insert in Word1 the same Character as that of the Word2 so that we can make the Word1 to match Word2.\\n2. __Delete__ : In this Case we will Delete the Character from the Word1 as the character was not matching with the Word2.\\n3. __Replace__ : We will replace the dissimilar Character of the Word1 with Word2.\\n\\nNote : After calculating the Minimum of all of the Possible 3 Operations then we need to Add 1 to the answer as We have not included the cost of current Operation. \\nFor e.g.,\\nword1 = \"horse\"\\nword2 = \"ros\"\\n\\n```\\n                          (horse, ros)\\n// First Character of both the Words are Different then 3 Operations will be Performed\\n\\t\\t\\t      /             |            \\\\\\n\\t\\t     (Insert)        (Delete)       (Replace)\\n\\t\\t\\t   |                |                |\\n\\t\\t(rhorse, ros)       (orse,ros)       (rorse,ros) \\n// It is to be noted that the first Character of Word1 will surely become same as that of the Word2. In order to get minimun answer we need to perfrom such Operations Otherwise we will not get the Optimized answer.\\n               |                |                |  // We can directly write this stage in next Operations\\n          (horse, os)      (orse, ros)        (orse, os) \\n\\t\\t /     |     \\\\          .                  |  //Simply Skip the Character\\n(horse, s) (orse, ros) (orse, s).               (rse, s)\\n    .           .          .    .                   .\\n    .           .          .                        .\\n    .           .          .                        .\\n\\tSo on.\\n```\\n**Base Case** : Base Condition should be if any of the Word is consumed completely then we need to stop working as not we cannot check if the characters are same or not.\\n\\nIn the Base case, 3 Cases are Possible :\\n1. **Both of the Word are Consumed** : Then ans is zero as the empty Strings are also equal.\\n2. **Word1 is Consumed** : In this case Word2 is available and now our work is to convert the empty String into the Word1, So we need to perform Insertions Equal to length of the Word2. Hence we can return the Length of the Word2.\\n3.  **Word2 is Consumed** : In this case Word1 is available and now our work is to convert the this String into the Empty, So we need to perform deletions Equal to length of the Word1. Hence we can return the Length of the Word1.\\n\\nSo we will return Math.max(Word1.length(), Word1.length());\\n```\\npublic static int helper(String s1, String s2){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){ // If length any of the Length is Consumed completely\\n\\t\\t\\treturn Math.max(s1.length(), s2.length()); // Discussed Above\\n\\t\\t}\\n\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){ // If the Character matches\\n\\t\\t\\treturn helper(s1.substring(1),s2.substring(1)); // Skip both of the Characters\\n\\t\\t}else{\\n\\t\\t\\tint insert = helper(s1, s2.substring(1)); // In case of Insertion Consume the S2 character\\n\\t\\t\\tint delete = helper(s1.substring(1), s2); // In case of Deletion Consume the S1 character\\n\\t\\t\\tint replace = helper(s1.substring(1), s2.substring(1)); // In case of Replace Consume the characters from both of the Strings\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\treturn Math.min(insert, Math.min(delete, replace)) + 1; //Return the minimum Operations among the 3 Operations + 1.\\n\\t\\t}\\n\\t}\\n```\\n\\n**TopDown Approach** : This Approach is Similar as discussed Above but In this Approach we will create and Save the calculated answer in an Array called as Storage.\\n```\\npublic static int helperTD(String s1, String s2, int[][] strg){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){\\n\\t\\t\\treturn Math.max(s1.length(), s2.length());\\n\\t\\t}\\n\\t\\tint n = s1.length();\\n\\t\\tint m = s2.length();\\n\\t\\tif(strg[n][m] != 0){  //If we have Already Calculated the Answer\\n\\t\\t\\treturn strg[n][m]; // return the Saved Answer\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){\\n\\t\\t\\tstrg[n][m] = helperTD(s1.substring(1),s2.substring(1), strg); // Saving Answer\\n\\t\\t\\treturn strg[n][m];\\n\\t\\t}else{\\n\\t\\t\\tint insert = helperTD(s1, s2.substring(1), strg);\\n\\t\\t\\tint delete = helperTD(s1.substring(1), s2, strg);\\n\\t\\t\\tint replace = helperTD(s1.substring(1), s2.substring(1), strg);\\n\\t\\t\\tstrg[n][m] = Math.min(insert, Math.min(delete, replace)) + 1; // Storing the calculated answer\\n\\t\\t\\treturn strg[n][m]; // return the Calculated Answer\\n\\t\\t}\\n\\t}\\n```\\n\\n**BottomUp Approach** : \\n```\\npublic static int helperBU(String s1, String s2){\\n\\t\\tint[][] strg = new int[s1.length() + 1][s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tstrg[i][j] = strg[i + 1][j + 1];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[i][j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[i + 1][j];\\n\\t\\t\\t\\t\\tint replace = strg[i + 1][j + 1];\\n\\t\\t\\t\\t\\tstrg[i][j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0][0];\\n\\t}\\n```\\n\\n**BottomUp Efficient(Beats 99.81 % on Runtime)**\\n\\n```\\npublic static int helperBU_Eff(String s1, String s2){\\n\\t\\tint[] strg = new int[s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tint save = 0;\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tint temp = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = temp;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[j];\\n\\t\\t\\t\\t\\tint replace = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0];\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n                          (horse, ros)\\n// First Character of both the Words are Different then 3 Operations will be Performed\\n\\t\\t\\t      /             |            \\\\\\n\\t\\t     (Insert)        (Delete)       (Replace)\\n\\t\\t\\t   |                |                |\\n\\t\\t(rhorse, ros)       (orse,ros)       (rorse,ros) \\n// It is to be noted that the first Character of Word1 will surely become same as that of the Word2. In order to get minimun answer we need to perfrom such Operations Otherwise we will not get the Optimized answer.\\n               |                |                |  // We can directly write this stage in next Operations\\n          (horse, os)      (orse, ros)        (orse, os) \\n\\t\\t /     |     \\\\          .                  |  //Simply Skip the Character\\n(horse, s) (orse, ros) (orse, s).               (rse, s)\\n    .           .          .    .                   .\\n    .           .          .                        .\\n    .           .          .                        .\\n\\tSo on.\\n```\n```\\npublic static int helper(String s1, String s2){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){ // If length any of the Length is Consumed completely\\n\\t\\t\\treturn Math.max(s1.length(), s2.length()); // Discussed Above\\n\\t\\t}\\n\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){ // If the Character matches\\n\\t\\t\\treturn helper(s1.substring(1),s2.substring(1)); // Skip both of the Characters\\n\\t\\t}else{\\n\\t\\t\\tint insert = helper(s1, s2.substring(1)); // In case of Insertion Consume the S2 character\\n\\t\\t\\tint delete = helper(s1.substring(1), s2); // In case of Deletion Consume the S1 character\\n\\t\\t\\tint replace = helper(s1.substring(1), s2.substring(1)); // In case of Replace Consume the characters from both of the Strings\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\treturn Math.min(insert, Math.min(delete, replace)) + 1; //Return the minimum Operations among the 3 Operations + 1.\\n\\t\\t}\\n\\t}\\n```\n```\\npublic static int helperTD(String s1, String s2, int[][] strg){\\n\\t\\tif(s1.length() == 0 || s2.length() == 0){\\n\\t\\t\\treturn Math.max(s1.length(), s2.length());\\n\\t\\t}\\n\\t\\tint n = s1.length();\\n\\t\\tint m = s2.length();\\n\\t\\tif(strg[n][m] != 0){  //If we have Already Calculated the Answer\\n\\t\\t\\treturn strg[n][m]; // return the Saved Answer\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(s1.charAt(0) == s2.charAt(0)){\\n\\t\\t\\tstrg[n][m] = helperTD(s1.substring(1),s2.substring(1), strg); // Saving Answer\\n\\t\\t\\treturn strg[n][m];\\n\\t\\t}else{\\n\\t\\t\\tint insert = helperTD(s1, s2.substring(1), strg);\\n\\t\\t\\tint delete = helperTD(s1.substring(1), s2, strg);\\n\\t\\t\\tint replace = helperTD(s1.substring(1), s2.substring(1), strg);\\n\\t\\t\\tstrg[n][m] = Math.min(insert, Math.min(delete, replace)) + 1; // Storing the calculated answer\\n\\t\\t\\treturn strg[n][m]; // return the Calculated Answer\\n\\t\\t}\\n\\t}\\n```\n```\\npublic static int helperBU(String s1, String s2){\\n\\t\\tint[][] strg = new int[s1.length() + 1][s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tstrg[i][j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tstrg[i][j] = strg[i + 1][j + 1];\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[i][j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[i + 1][j];\\n\\t\\t\\t\\t\\tint replace = strg[i + 1][j + 1];\\n\\t\\t\\t\\t\\tstrg[i][j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0][0];\\n\\t}\\n```\n```\\npublic static int helperBU_Eff(String s1, String s2){\\n\\t\\tint[] strg = new int[s2.length() + 1];\\n\\t\\tfor(int i = s1.length();i >= 0;i--){\\n\\t\\t\\tint save = 0;\\n\\t\\t\\tfor(int j = s2.length();j >= 0;j--){\\n\\t\\t\\t\\tif(i == s1.length()){\\n\\t\\t\\t\\t\\tstrg[j] = s2.length() - j;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j == s2.length()){\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = s1.length() - i;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s1.charAt(i) == s2.charAt(j)){\\n\\t\\t\\t\\t\\tint temp = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = temp;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tint insert = strg[j + 1];\\n\\t\\t\\t\\t\\tint delete = strg[j];\\n\\t\\t\\t\\t\\tint replace = save;\\n\\t\\t\\t\\t\\tsave = strg[j];\\n\\t\\t\\t\\t\\tstrg[j] = Math.min(insert, Math.min(delete, replace)) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn strg[0];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25921,
                "title": "easy-understanding-java-solution-using-dp-with-memorization-beats-about-99-solutions",
                "content": "\\n    public int minDistance(String word1, String word2) {\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[][] memo = new int[w1.length+1][w2.length+1];\\n        return minDistanceHelper(w1, w2, 0, 0, memo);\\n    }\\n    \\n    public int minDistanceHelper(char[] w1, char[] w2, int w1Index, int w2Index, int[][] memo) {\\n        if(w1Index == w1.length) return w2.length - w2Index;\\n        if(w2Index == w2.length) return w1.length - w1Index;\\n\\n        if(memo[w1Index][w2Index] != 0) return memo[w1Index][w2Index];\\n\\n        if(w1[w1Index] == w2[w2Index]) {\\n            memo[w1Index][w2Index] = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n        } else {\\n            int opt1 = minDistanceHelper(w1, w2, w1Index+1, w2Index, memo);\\n            int opt2 = minDistanceHelper(w1, w2, w1Index, w2Index+1, memo);\\n            int opt3 = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n            memo[w1Index][w2Index] = Math.min(opt1, Math.min(opt2, opt3)) + 1;\\n        }\\n        return memo[w1Index][w2Index];\\n    }",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "\\n    public int minDistance(String word1, String word2) {\\n        char[] w1 = word1.toCharArray(), w2 = word2.toCharArray();\\n        int[][] memo = new int[w1.length+1][w2.length+1];\\n        return minDistanceHelper(w1, w2, 0, 0, memo);\\n    }\\n    \\n    public int minDistanceHelper(char[] w1, char[] w2, int w1Index, int w2Index, int[][] memo) {\\n        if(w1Index == w1.length) return w2.length - w2Index;\\n        if(w2Index == w2.length) return w1.length - w1Index;\\n\\n        if(memo[w1Index][w2Index] != 0) return memo[w1Index][w2Index];\\n\\n        if(w1[w1Index] == w2[w2Index]) {\\n            memo[w1Index][w2Index] = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n        } else {\\n            int opt1 = minDistanceHelper(w1, w2, w1Index+1, w2Index, memo);\\n            int opt2 = minDistanceHelper(w1, w2, w1Index, w2Index+1, memo);\\n            int opt3 = minDistanceHelper(w1, w2, w1Index+1, w2Index+1, memo);\\n            memo[w1Index][w2Index] = Math.min(opt1, Math.min(opt2, opt3)) + 1;\\n        }\\n        return memo[w1Index][w2Index];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25939,
                "title": "ac-python-212-ms-dp-solution-o-mn-time-o-n-space",
                "content": "This is similar to the longest common subsequence problem. Dynamic programming is intuitive.\\n\\n    def minDistance(self, word1, word2):\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))\\n        dist = range(len(word2) + 1)\\n        for i in xrange(len(word1)):\\n            dist_ij, dist[0] = i, i + 1\\n            for j in xrange(len(word2)):\\n                if word1[i] == word2[j]:\\n                    dist_ij, dist[j + 1] = dist[j + 1], dist_ij\\n                else:\\n                    dist_ij, dist[j + 1] = dist[j + 1], min(dist[j], dist[j + 1], dist_ij) + 1\\n        return dist[-1]\\n\\n\\n    # 1146 / 1146 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 212 ms\\n    # 96.23%\\n\\n\\nThe relations of DP are\\n\\n    # keep the last char:      dist(i + 1, j + 1) = dist(i, j)\\n    # insert the last char:    dist(i + 1, j + 1) = dist(i + 1, j) + 1\\n    # replace the last char:   dist(i + 1, j + 1) = dist(i, j)     + 1\\n    # remove the last char:    dist(i + 1, j + 1) = dist(i, j + 1) + 1",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "This is similar to the longest common subsequence problem. Dynamic programming is intuitive.\\n\\n    def minDistance(self, word1, word2):\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))\\n        dist = range(len(word2) + 1)\\n        for i in xrange(len(word1)):\\n            dist_ij, dist[0] = i, i + 1\\n            for j in xrange(len(word2)):\\n                if word1[i] == word2[j]:\\n                    dist_ij, dist[j + 1] = dist[j + 1], dist_ij\\n                else:\\n                    dist_ij, dist[j + 1] = dist[j + 1], min(dist[j], dist[j + 1], dist_ij) + 1\\n        return dist[-1]\\n\\n\\n    # 1146 / 1146 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 212 ms\\n    # 96.23%\\n\\n\\nThe relations of DP are\\n\\n    # keep the last char:      dist(i + 1, j + 1) = dist(i, j)\\n    # insert the last char:    dist(i + 1, j + 1) = dist(i + 1, j) + 1\\n    # replace the last char:   dist(i + 1, j + 1) = dist(i, j)     + 1\\n    # remove the last char:    dist(i + 1, j + 1) = dist(i, j + 1) + 1",
                "codeTag": "Python3"
            },
            {
                "id": 25870,
                "title": "my-none-recursive-solution",
                "content": "Hello, I've finish this problem without recursion. Any comment on how i can improve on the code?   Thanks. \\nIs there a reason why people are doing recursive builds? (Space vs time?)\\n\\n\\n    public class Solution {\\n            public int minDistance(String word1, String word2) {\\n                int [][] result = new int[word1.length()+1][word2.length()+1];\\n                //set up deletion into null string;\\n                for(int i=0;i<=word1.length();i++) result[i][0]=i;\\n                for(int j=0;j<=word2.length();j++) result[0][j]=j;\\n                for(int i=1;i<=word1.length();i++)\\n                {\\n                    for(int j=1;j<=word2.length();j++)\\n                    {\\n                        int del = result[i-1][j] +1;\\n                        int ins = result[i][j-1] +1;\\n                        int rep = result[i-1][j-1];\\n                        if(word1.charAt(i-1)!=word2.charAt(j-1)) \\n                        {\\n                            rep+=1;\\n                        }\\n                        int min = Math.min(del,ins);\\n                        min = Math.min(min,rep);\\n                        result[i][j]=min;\\n                    }\\n                }\\n                return result[word1.length()][word2.length()];\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public int minDistance(String word1, String word2) {\\n                int [][] result = new int[word1.length()+1][word2.length()+1];\\n                //set up deletion into null string;\\n                for(int i=0;i<=word1.length();i++) result[i][0]=i;\\n                for(int j=0;j<=word2.length();j++) result[0][j]=j;\\n                for(int i=1;i<=word1.length();i++)\\n                {\\n                    for(int j=1;j<=word2.length();j++)\\n                    {\\n                        int del = result[i-1][j] +1;\\n                        int ins = result[i][j-1] +1;\\n                        int rep = result[i-1][j-1];\\n                        if(word1.charAt(i-1)!=word2.charAt(j-1)) \\n                        {\\n                            rep+=1;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 3817915,
                "title": "0-n-space-solution",
                "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\\n# Dynamic Programming (Tabulation) with Space Optimization:\\n# Approach\\nThe function spacopti is used to find the minimum edit distance using dynamic programming (tabulation) with space optimization.\\nIt initializes two vectors curr and next to store intermediate results during the computation.\\nThe next vector is pre-filled with values representing the minimum number of operations needed to transform the suffix of string b into an empty string (i.e., characters are deleted).\\nTabulation Loop:\\n\\nThe tabulation loop iterates over the indices of a and b from the end to the beginning.\\nIt computes the minimum edit distance for each pair of substrings a[i:] and b[j:], storing the result in the curr vector.\\nThe curr vector is updated iteratively as the loop progresses.\\nMatching Characters:\\n\\nIf the characters at a[i] and b[j] are the same, the function updates the ans variable with the value from next[j+1]. This represents the minimum edit distance for the remaining substrings a[i+1:] and b[j+1:].\\nMismatching Characters:\\n\\nIf the characters at a[i] and b[j] are different, the function calculates three possible operations (insertion, deletion, and replacement) and updates the ans variable with the minimum value among them.\\nSpace Optimization:\\n\\nInstead of using two separate vectors for curr and next, the function uses only curr for tabulation. The next vector is effectively replaced by curr in each iteration, updating the values accordingly.\\nOutput:\\n\\nThe minDistance function returns the result of the dynamic programming (tabulation) function spacopti(word1, word2), which represents the minimum number of operations required to transform word1 into word2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# CODE\\n```\\nclass Solution {\\npublic:\\n\\nint spacopti(string& a, string& b)\\n{\\n    vector<int>curr(b.length()+11,0);\\n    vector<int>next(b.length()+111,0);\\n    for(int j =0;j<b.length();j++)\\n    {\\n        next[j]=b.length()-j;\\n    }\\n\\n\\n    for(int i=a.length();i>=0;i--)\\n    {\\n        for(int j = b.length();j>=0;j--)\\n        {\\n            int ans=0;\\n            curr[b.length()]=a.length()-i;\\n            if(a[i]==b[j])\\n            {\\n                ans= next[j+1];\\n            }\\n            else\\n            {\\n                int insert= 1 + curr[j+1];\\n                int deleteans= 1 + next[j];\\n                int replace= 1 + next[j+1];\\n                ans = min(insert , min(deleteans , replace));\\n            }\\n            curr[j]=ans;\\n        }\\n        next=curr;\\n    }\\n    return next[0];\\n}\\n\\n    int minDistance(string word1, string word2) {\\n        return spacopti(word1,word2);\\n\\n    }\\n};\\n```\\n# Recursive Function with Memoization:\\n# Approach\\n\\n\\nThe function solve is a recursive function that takes two strings a and b, along with two indices i and j, representing the current position in a and b.\\nThe function calculates the minimum distance (number of operations) required to transform the substring a[i:] into the substring b[j:].\\nThe function uses memoization to store the results of subproblems in a 2D dp array. The dp array is used to avoid redundant calculations for overlapping subproblems.\\nBase Cases:\\n\\nIf the index i reaches the end of string a, the remaining characters in b need to be inserted to match a, so the function returns b.length() - j.\\nIf the index j reaches the end of string b, the remaining characters in a need to be deleted to match b, so the function returns a.length() - i.\\nMemoization:\\n\\nThe function checks if the result for the current subproblem (i.e., solve(a, b, i, j, dp)) is already calculated and stored in the dp array. If so, it returns the stored result, avoiding redundant calculations.\\nMatching Characters:\\n\\nIf the characters at a[i] and b[j] are the same, no operation is required, so the function calls itself with i+1 and j+1.\\nMismatching Characters:\\n\\nIf the characters at a[i] and b[j] are different, the function considers three possible operations (insertion, deletion, and replacement) and calculates the minimum distance by recursively calling itself with different indices and adding one for the operation performed.\\nMain Function:\\n\\nThe minDistance function initializes the dp array with -1 and calls the recursive function solve with the two strings word1 and word2, along with initial indices 0 and 0.\\nOutput:\\n\\nThe minDistance function returns the minimum number of operations required to transform word1 into word2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(string& a, string& b,int i,int j ,vector<vector<int>>& dp)\\n{\\n      int ans=0;\\n    if(a.length()==i)\\n    {\\n        return b.length()-j;\\n    }\\n    if(b.length()==j)\\n    {\\n        return a.length()-i;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(a[i]==b[j])\\n    {\\n        return solve(a,b,i+1,j+1,dp);\\n    }\\n  \\n    else\\n    {\\n        int insert= 1 + solve(a,b,i,j+1,dp);\\n\\n        int deleteans= 1 + solve(a,b,i+1,j,dp);\\n\\n        int replace= 1 + solve(a,b,i+1,j+1,dp);\\n        ans = min(insert , min(deleteans , replace));\\n    }\\n    return dp[i][j]=ans;\\n\\n}\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>>dp(word1.length()+11,vector<int>(word2.length()+11,-1));\\n        return solve(word1,word2,0,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint spacopti(string& a, string& b)\\n{\\n    vector<int>curr(b.length()+11,0);\\n    vector<int>next(b.length()+111,0);\\n    for(int j =0;j<b.length();j++)\\n    {\\n        next[j]=b.length()-j;\\n    }\\n\\n\\n    for(int i=a.length();i>=0;i--)\\n    {\\n        for(int j = b.length();j>=0;j--)\\n        {\\n            int ans=0;\\n            curr[b.length()]=a.length()-i;\\n            if(a[i]==b[j])\\n            {\\n                ans= next[j+1];\\n            }\\n            else\\n            {\\n                int insert= 1 + curr[j+1];\\n                int deleteans= 1 + next[j];\\n                int replace= 1 + next[j+1];\\n                ans = min(insert , min(deleteans , replace));\\n            }\\n            curr[j]=ans;\\n        }\\n        next=curr;\\n    }\\n    return next[0];\\n}\\n\\n    int minDistance(string word1, string word2) {\\n        return spacopti(word1,word2);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint solve(string& a, string& b,int i,int j ,vector<vector<int>>& dp)\\n{\\n      int ans=0;\\n    if(a.length()==i)\\n    {\\n        return b.length()-j;\\n    }\\n    if(b.length()==j)\\n    {\\n        return a.length()-i;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(a[i]==b[j])\\n    {\\n        return solve(a,b,i+1,j+1,dp);\\n    }\\n  \\n    else\\n    {\\n        int insert= 1 + solve(a,b,i,j+1,dp);\\n\\n        int deleteans= 1 + solve(a,b,i+1,j,dp);\\n\\n        int replace= 1 + solve(a,b,i+1,j+1,dp);\\n        ans = min(insert , min(deleteans , replace));\\n    }\\n    return dp[i][j]=ans;\\n\\n}\\n    int minDistance(string word1, string word2) {\\n        vector<vector<int>>dp(word1.length()+11,vector<int>(word2.length()+11,-1));\\n        return solve(word1,word2,0,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592016,
                "title": "dp-c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &n,int &m,string &a,string &b,vector<vector<int>> &dp){\\n    if(i==n)return m-j;\\n    if(j==m)return n-i;\\n    if(dp[i][j] != -1)return dp[i][j];\\n    if(a[i]==b[j]){\\n        dp[i][j] = solve(i+1,j+1,n,m,a,b,dp);\\n    }else{\\n        dp[i][j] = min({solve(i+1,j,n,m,a,b,dp),solve(i,j+1,n,m,a,b,dp),solve(i+1,j+1,n,m,a,b,dp)})+1;\\n    }\\n    return dp[i][j];\\n}\\n    int minDistance(string a, string b) {\\n        int n = a.length(),m=b.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,a,b,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &n,int &m,string &a,string &b,vector<vector<int>> &dp){\\n    if(i==n)return m-j;\\n    if(j==m)return n-i;\\n    if(dp[i][j] != -1)return dp[i][j];\\n    if(a[i]==b[j]){\\n        dp[i][j] = solve(i+1,j+1,n,m,a,b,dp);\\n    }else{\\n        dp[i][j] = min({solve(i+1,j,n,m,a,b,dp),solve(i,j+1,n,m,a,b,dp),solve(i+1,j+1,n,m,a,b,dp)})+1;\\n    }\\n    return dp[i][j];\\n}\\n    int minDistance(string a, string b) {\\n        int n = a.length(),m=b.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(0,0,n,m,a,b,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281006,
                "title": "easy-python-solution-using-dp-75-runtime",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[0]*(l2+1) for i in range(l1+1)]\\n        cnt=0\\n        for i in range(l1+1):\\n            for j in range(l2+1):\\n                if i==0:\\n                    dp[i][j]=j\\n                elif j==0:\\n                    dp[i][j]=i\\n                elif word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[0]*(l2+1) for i in range(l1+1)]\\n        cnt=0\\n        for i in range(l1+1):\\n            for j in range(l2+1):\\n                if i==0:\\n                    dp[i][j]=j\\n                elif j==0:\\n                    dp[i][j]=i\\n                elif word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231326,
                "title": "python-short-and-clean-2-solutions-recursive-dp-optimised-iterative-dp",
                "content": "# Approach: Recursive DP\\n1. Let `min_dist` be a function which takes indices `i1` and `i2` from `word1` and `word2` respectively, and returns the minimum operations needed to make `word1[:i1] == word2[:i2]`.\\n\\n2. Notice that if `word1[i1] == word2[i2]`, then no operations, i.e\\n    `min_dist(i1, i2) = min_dist(i1 - 1, i2 - 1)`\\n\\n3. And if `word1[i1] != word2[i2]`, then check all 3 operations, i.e\\n    `a = min_dist(i1 - 1, i2 - 1)` (Replace `word1[i1]` with `word2[i2]`)\\n    `b = min_dist(i1, i2 - 1)` (Insert `word2[i2]` in `word1`)\\n    `c = min_dist(i1 - 1, i2)` (Delete `word1[i1]`)\\n    `min_dist(i1, i2) = min(a, b, c)` (Best of all)\\n\\n4. This can be implemented by recursively calling the `min_dist` function.\\n\\n5. Since the problem has overlapping sub-problems and optimal sub-structure we can memoize the calls to `min_dist` to optimize the complexity.\\n\\n# Complexity\\n- Time complexity: $$O(n1 * n2)$$\\n\\n- Space complexity: $$O(n1 * n2)$$\\n\\nwhere,\\n`n1 is length of word1`,\\n`n2 is length of word2`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        @cache\\n        def min_distance(i1: int, i2: int) -> int:\\n            if not i1 or not i2: return max(i1, i2)\\n            \\n            return (\\n                min_distance(i1 - 1, i2 - 1)\\n                if word1[i1 - 1] == word2[i2 - 1] \\n                else 1 + min(\\n                    min_distance(i1 - 1, i2 - 1),\\n                    min_distance(i1, i2 - 1),\\n                    min_distance(i1 - 1, i2),\\n                )\\n            )\\n        \\n        return min_distance(len(word1), len(word2))\\n\\n\\n```\\n\\n---\\n# Approach: Iterative Space Optimized DP\\n1. Same as the recursive approach, but notice that at any given time we are only interesting in 3 previous states `min_dist(i, j) = min(a, b, c)`.\\n\\n2. We can optimise the space complexity by reducing the memoization from 2D space of `i and j` into 1D space of `i or j`.\\n\\n# Complexity\\n- Time complexity: $$O(n1 * n2)$$\\n\\n- Space complexity: $$O(min(n1, n2))$$\\n\\nwhere,\\n`n1 is length of word1`,\\n`n2 is length of word2`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        w1, w2 = (word1, word2) if len(word1) < len(word2) else (word2, word1)\\n        n1, n2 = len(w1), len(w2)\\n\\n        dp = list(range(n1 + 1))\\n        for i in range(n2):\\n            prev, dp[0] = dp[0], dp[0] + 1\\n            for j in range(n1):\\n                k = j + 1\\n                prev, dp[k] = dp[k], prev if w1[j] == w2[i] else min(prev, dp[k - 1], dp[k]) + 1\\n        \\n        return dp[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        @cache\\n        def min_distance(i1: int, i2: int) -> int:\\n            if not i1 or not i2: return max(i1, i2)\\n            \\n            return (\\n                min_distance(i1 - 1, i2 - 1)\\n                if word1[i1 - 1] == word2[i2 - 1] \\n                else 1 + min(\\n                    min_distance(i1 - 1, i2 - 1),\\n                    min_distance(i1, i2 - 1),\\n                    min_distance(i1 - 1, i2),\\n                )\\n            )\\n        \\n        return min_distance(len(word1), len(word2))\\n\\n\\n```\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        w1, w2 = (word1, word2) if len(word1) < len(word2) else (word2, word1)\\n        n1, n2 = len(w1), len(w2)\\n\\n        dp = list(range(n1 + 1))\\n        for i in range(n2):\\n            prev, dp[0] = dp[0], dp[0] + 1\\n            for j in range(n1):\\n                k = j + 1\\n                prev, dp[k] = dp[k], prev if w1[j] == w2[i] else min(prev, dp[k - 1], dp[k]) + 1\\n        \\n        return dp[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230679,
                "title": "python-easy-to-understand-bottom-up-dp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Upvote Please\\uD83D\\uDE09\\uD83D\\uDC4D and Help Me \\uD83D\\uDE4C\\uD83E\\uDD1E\\u2764\\n```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def minDistance(self, word1, word2):\\n        \"\"\"\\n        :type word1: str\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        len1 = len(word1)\\n        len2 = len(word2)\\n        dp = [[-1] * (len2+1) for _ in range(len1+1)]\\n        \\n        for i in range(len1+1):\\n            for j in range(len2+1):\\n                if i == 0:\\n                    dp[i][j] = j  \\n                elif j == 0:\\n                    dp[i][j] = i  \\n                elif word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n        return dp[len1][len2]\\n        \\n        \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230499,
                "title": "daily-leetcoding-challenge-february-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/edit-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/edit-distance/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2656519,
                "title": "memoization-tabulation-space-optimisation-c-beginner-friendly",
                "content": "```\\n// MEMOIZATION\\n// class Solution {\\n// public:\\n//     int f(int i, int j, string word1, string word2,vector<vector<int>> &dp){\\n//         if(i == 0) return j;\\n//         if(j == 0) return i;\\n//         if(dp[i][j] != -1) return dp[i][j];\\n//         if(word1[i-1] == word2[j-1]){\\n//             return dp[i][j] = f(i-1,j-1,word1,word2,dp);\\n//         }\\n//         return dp[i][j] = 1 + min(f(i-1,j-1,word1,word2,dp),min(f(i,j-1,word1,word2,dp),f(i-1,j,word1,word2,dp)));     \\n//     }\\n//     int minDistance(string word1, string word2) {\\n//         int n = word1.length();\\n//         int m = word2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n//         return f(n,m,word1,word2,dp);\\n//     }\\n// };\\n// TABULATION\\n// class Solution {\\n// public:\\n//     int minDistance(string w1, string w2) {\\n//         int n = w1.length();\\n//         int m = w2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        \\n//         for(int j=0;j<=m;j++) dp[0][j] = j;\\n//         for(int i=0;i<=n;i++) dp[i][0] = i;\\n        \\n//         for(int i=1;i<=n;i++){\\n//             for(int j=1;j<=m;j++){\\n//                 if(w1[i-1] == w2[j-1]){\\n//                     dp[i][j] = dp[i-1][j-1];    \\n//                 }else{\\n//                     dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n//                 }\\n                \\n//             }\\n//         }\\n//         return dp[n][m];\\n//     }\\n// };\\n// SPACE OPTIMISATION\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.length();\\n        int m = w2.length();\\n        vector<int> curr(m+1,0),prev(m+1,0);\\n        \\n        for(int j=0;j<=m;j++) prev[j] = j;\\n        \\n        for(int i=1;i<=n;i++){\\n            curr[0] = i;\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1] == w2[j-1]){\\n                    curr[j] = prev[j-1];    \\n                }else{\\n                    curr[j] = 1 + min(prev[j-1],min(prev[j],curr[j-1]));\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// MEMOIZATION\\n// class Solution {\\n// public:\\n//     int f(int i, int j, string word1, string word2,vector<vector<int>> &dp){\\n//         if(i == 0) return j;\\n//         if(j == 0) return i;\\n//         if(dp[i][j] != -1) return dp[i][j];\\n//         if(word1[i-1] == word2[j-1]){\\n//             return dp[i][j] = f(i-1,j-1,word1,word2,dp);\\n//         }\\n//         return dp[i][j] = 1 + min(f(i-1,j-1,word1,word2,dp),min(f(i,j-1,word1,word2,dp),f(i-1,j,word1,word2,dp)));     \\n//     }\\n//     int minDistance(string word1, string word2) {\\n//         int n = word1.length();\\n//         int m = word2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n//         return f(n,m,word1,word2,dp);\\n//     }\\n// };\\n// TABULATION\\n// class Solution {\\n// public:\\n//     int minDistance(string w1, string w2) {\\n//         int n = w1.length();\\n//         int m = w2.length();\\n//         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        \\n//         for(int j=0;j<=m;j++) dp[0][j] = j;\\n//         for(int i=0;i<=n;i++) dp[i][0] = i;\\n        \\n//         for(int i=1;i<=n;i++){\\n//             for(int j=1;j<=m;j++){\\n//                 if(w1[i-1] == w2[j-1]){\\n//                     dp[i][j] = dp[i-1][j-1];    \\n//                 }else{\\n//                     dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n//                 }\\n                \\n//             }\\n//         }\\n//         return dp[n][m];\\n//     }\\n// };\\n// SPACE OPTIMISATION\\nclass Solution {\\npublic:\\n    int minDistance(string w1, string w2) {\\n        int n = w1.length();\\n        int m = w2.length();\\n        vector<int> curr(m+1,0),prev(m+1,0);\\n        \\n        for(int j=0;j<=m;j++) prev[j] = j;\\n        \\n        for(int i=1;i<=n;i++){\\n            curr[0] = i;\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1] == w2[j-1]){\\n                    curr[j] = prev[j-1];    \\n                }else{\\n                    curr[j] = 1 + min(prev[j-1],min(prev[j],curr[j-1]));\\n                }\\n                \\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571257,
                "title": "simple-python-solution-recursive-and-dp-both-solutions",
                "content": "\\nRecursive (with memoization - lrucache)\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        @cache\\n        def mdistance(i, j):\\n\\n            if i == n or j == m:\\n                return (m - j) + (n - i) #if i is n, we will need m-j insert operations\\n\\n            operations = min(\\n                mdistance(i + 1, j) + 1, #deletion\\n                mdistance(i, j + 1) + 1, # insertion\\n                mdistance(i + 1, j + 1) + (0 if word1[i] == word2[j] else 1), # if char is not same replace\\n            )\\n            return operations\\n\\n        return mdistance(0, 0)\\n\\n```\\n\\nDP (tabular)\\n\\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        mem = [([0] * (n + 1)) for _ in range(m + 1)]\\n\\n        for i in range(1, m + 1):\\n            mem[i][0] = i\\n        for j in range(1, n + 1):\\n            mem[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mem[i][j] = min(\\n                    mem[i - 1][j] + 1,\\n                    mem[i][j - 1] + 1,\\n                    mem[i - 1][j - 1] + (0 if word1[j - 1] == word2[i - 1] else 1),\\n                )\\n\\n        return mem[m][n]\\n```\\n\\nTime complexity: `O(n*m)` for both\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        @cache\\n        def mdistance(i, j):\\n\\n            if i == n or j == m:\\n                return (m - j) + (n - i) #if i is n, we will need m-j insert operations\\n\\n            operations = min(\\n                mdistance(i + 1, j) + 1, #deletion\\n                mdistance(i, j + 1) + 1, # insertion\\n                mdistance(i + 1, j + 1) + (0 if word1[i] == word2[j] else 1), # if char is not same replace\\n            )\\n            return operations\\n\\n        return mdistance(0, 0)\\n\\n```\n```python\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n\\n        n = len(word1)\\n        m = len(word2)\\n\\n        mem = [([0] * (n + 1)) for _ in range(m + 1)]\\n\\n        for i in range(1, m + 1):\\n            mem[i][0] = i\\n        for j in range(1, n + 1):\\n            mem[0][j] = j\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                mem[i][j] = min(\\n                    mem[i - 1][j] + 1,\\n                    mem[i][j - 1] + 1,\\n                    mem[i - 1][j - 1] + (0 if word1[j - 1] == word2[i - 1] else 1),\\n                )\\n\\n        return mem[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344318,
                "title": "reach-form-recursion-to-dp-in-simple-change-in-code",
                "content": "**Recursive Function - **\\n```\\n   int fun(string &s1, string &s2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty return second string len. Because, we need to put all the characters from scratch\\n            return m;                       //               string size convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(s1[n - 1] == s2[m - 1])\\n               return fun(s1, s2, n - 1, m - 1); //  when both characters are matched call the function for smaller input by reducing the size of both the strings\\n        else               \\n            return 1 + min({fun(s1,s2, n, m - 1), fun(s1, s2, n - 1, m), fun(s1, s2, n - 1, m - 1)});  // When characters Doesn\\'t match we will perform all the 3 operations insert , delete , replace and give the minimum one.\\n    } \\n```\\nNow let us try to convert the recursive code in dp - In Aditya Verma\\'s style\\uD83D\\uDE0E\\nreplace n with i and m with j in bottom-up dp. In initialization put the values of i and j.\\n```\\n    int minDistance(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        \\n        int dp[n+1][m+1];                       //Initialization based on our base condition of recursion.\\n        for(int i = 0 ; i<=n ; i++)\\n            dp[i][0] = i;\\n        for(int j = 0 ; j<=m ; j++)\\n            dp[0][j] = j;\\n\\t\\t\\t\\n\\t\\t\\t//Inserting values in dp table- same as recursion condition.\\n        \\n        for(int i = 1 ; i<=n ; i++){\\n            for(int j = 1 ; j<=m ; j++){\\n                if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]});\\n            }\\n        }\\n        \\n        return dp[n][m];\\n         }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n   int fun(string &s1, string &s2, int n, int m){\\n        if(n == 0)                          // Base Case 1 : If first string is empty return second string len. Because, we need to put all the characters from scratch\\n            return m;                       //               string size convert first into second\\n        else if(m == 0)\\n                return n;                   // Base Case2 2: Vice-Versa of above base case\\n        else if(s1[n - 1] == s2[m - 1])\\n               return fun(s1, s2, n - 1, m - 1); //  when both characters are matched call the function for smaller input by reducing the size of both the strings\\n        else               \\n            return 1 + min({fun(s1,s2, n, m - 1), fun(s1, s2, n - 1, m), fun(s1, s2, n - 1, m - 1)});  // When characters Doesn\\'t match we will perform all the 3 operations insert , delete , replace and give the minimum one.\\n    } \\n```\n```\\n    int minDistance(string str1, string str2) {\\n        int n = str1.size();\\n        int m = str2.size();\\n        \\n        int dp[n+1][m+1];                       //Initialization based on our base condition of recursion.\\n        for(int i = 0 ; i<=n ; i++)\\n            dp[i][0] = i;\\n        for(int j = 0 ; j<=m ; j++)\\n            dp[0][j] = j;\\n\\t\\t\\t\\n\\t\\t\\t//Inserting values in dp table- same as recursion condition.\\n        \\n        for(int i = 1 ; i<=n ; i++){\\n            for(int j = 1 ; j<=m ; j++){\\n                if(str1[i-1]==str2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + min({dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]});\\n            }\\n        }\\n        \\n        return dp[n][m];\\n         }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1608072,
                "title": "c-clean-recursive-dp-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    int recurs(string& word1, string& word2,int i,int j)\\n    {\\n        if(i>=word1.size()&&j>=word2.size())\\n             return 0;\\n        \\n        if(i>=word1.size())\\n             return word2.size()-j; // all remaining need to be added\\n        \\n        if(j>=word2.size())\\n             return word1.size()-i; // all remaining need to be removed\\n        \\n        if(dp[i][j]!=-1)\\n              return dp[i][j];\\n        \\n        if(word1[i]==word2[j])\\n             return dp[i][j]=recurs(word1,word2,i+1,j+1);\\n        else\\n        {\\n            int a=recurs(word1,word2,i+1,j+1)+1;//replace\\n            int b=recurs(word1,word2,i+1,j)+1;//delete\\n            int c=recurs(word1,word2,i,j+1)+1;//insert\\n            c=min(b,c);\\n            return dp[i][j]=min(a,c);\\n        }\\n        \\n       \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    int minDistance(string word1, string word2) {\\n        dp.resize(word1.size(),vector<int>(word2.size(),-1));\\n        \\n        return recurs(word1,word2,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>dp;\\n    \\n    int recurs(string& word1, string& word2,int i,int j)\\n    {\\n        if(i>=word1.size()&&j>=word2.size())\\n             return 0;\\n        \\n        if(i>=word1.size())\\n             return word2.size()-j; // all remaining need to be added\\n        \\n        if(j>=word2.size())\\n             return word1.size()-i; // all remaining need to be removed\\n        \\n        if(dp[i][j]!=-1)\\n              return dp[i][j];\\n        \\n        if(word1[i]==word2[j])\\n             return dp[i][j]=recurs(word1,word2,i+1,j+1);\\n        else\\n        {\\n            int a=recurs(word1,word2,i+1,j+1)+1;//replace\\n            int b=recurs(word1,word2,i+1,j)+1;//delete\\n            int c=recurs(word1,word2,i,j+1)+1;//insert\\n            c=min(b,c);\\n            return dp[i][j]=min(a,c);\\n        }\\n        \\n       \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    int minDistance(string word1, string word2) {\\n        dp.resize(word1.size(),vector<int>(word2.size(),-1));\\n        \\n        return recurs(word1,word2,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603750,
                "title": "memoized-commented-solution",
                "content": "class Solution {\\npublic:\\n    \\n    string w1, w2;\\n    \\n    int dp[505][505];\\n    \\n    int solve(int i, int j){\\n        int ans = INT_MAX;\\n        \\n        if(i==w1.length() && j<w2.length()){\\n            //use insert op\\n            return dp[i][j]= min(ans,1+solve(i,j+1));\\n        }\\n        \\n        if(j==w2.length() && i<w1.length()){\\n            //use delete op\\n            return dp[i][j]= min(ans,1+solve(i+1,j));\\n        }\\n        \\n        if(i==w1.length() && j==w2.length()){\\n            return dp[i][j]=0;\\n        }\\n        \\n        if(dp[i][j]!=INT_MAX){\\n            return dp[i][j];\\n        }\\n        \\n        if(w1[i]==w2[j]){\\n            ans = min(ans,solve(i+1,j+1));\\n        }\\n        else{\\n            //insert\\n            ans = min(ans,1+solve(i,j+1));\\n            //delete\\n            ans = min(ans,1+solve(i+1,j));\\n            //replace\\n            ans = min(ans,1+solve(i+1,j+1));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        //O(N^2)\\n        w1 = word1;\\n        w2 = word2;\\n        for(int i=0;i<505;i++){\\n            for(int j=0;j<505;j++){\\n                dp[i][j]=INT_MAX;\\n            }\\n        }\\n        return solve(0,0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string w1, w2;\\n    \\n    int dp[505][505];\\n    \\n    int solve(int i, int j){\\n        int ans = INT_MAX;\\n        \\n        if(i==w1.length() && j<w2.length()){\\n            //use insert op\\n            return dp[i][j]= min(ans,1+solve(i,j+1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1413460,
                "title": "c-o-n-n-time-o-n-n-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        // Code here\\n        // This is a dp arroach :\\n        int n = s.size();\\n        int m = t.size();\\n        int dp[n+1][m+1];\\n        // dp[i][j] => edit distance for the string s[0...i-1] && t[0...j-1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0] = i;\\n        }\\n        for(int j=0;j<m+1;j++)\\n        {\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1] == t[j-1])\\n                dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n        \\n    \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        // Code here\\n        // This is a dp arroach :\\n        int n = s.size();\\n        int m = t.size();\\n        int dp[n+1][m+1];\\n        // dp[i][j] => edit distance for the string s[0...i-1] && t[0...j-1];\\n        for(int i=0;i<n+1;i++)\\n        {\\n            dp[i][0] = i;\\n        }\\n        for(int j=0;j<m+1;j++)\\n        {\\n            dp[0][j] = j;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1] == t[j-1])\\n                dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368674,
                "title": "java-using-dp-simple-and-clean",
                "content": "```\\nclass Solution {\\n    public int minDistance(String s, String t) {\\n\\t\\tif (s.isEmpty() || t.isEmpty())\\n\\t\\t\\treturn Math.max(s.length(), t.length());\\n\\t\\tint[][] dp = new int[s.length() + 1][t.length() + 1];\\n\\t\\tfor (int i = 0; i < t.length() + 1; i++) dp[0][i] = i;\\n\\t\\tfor (int i = 0; i < s.length() + 1; i++) dp[i][0] = i;\\n\\t\\tfor (int i = 1; i < s.length() + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < t.length() + 1; j++) {\\n\\t\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\telse dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[s.length()][t.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String s, String t) {\\n\\t\\tif (s.isEmpty() || t.isEmpty())\\n\\t\\t\\treturn Math.max(s.length(), t.length());\\n\\t\\tint[][] dp = new int[s.length() + 1][t.length() + 1];\\n\\t\\tfor (int i = 0; i < t.length() + 1; i++) dp[0][i] = i;\\n\\t\\tfor (int i = 0; i < s.length() + 1; i++) dp[i][0] = i;\\n\\t\\tfor (int i = 1; i < s.length() + 1; i++) {\\n\\t\\t\\tfor (int j = 1; j < t.length() + 1; j++) {\\n\\t\\t\\t\\tif (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\telse dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[s.length()][t.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077256,
                "title": "recursion-dp",
                "content": "recursion, exponential\\n```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return recur(word1,word2,0,0);\\n    }\\n    \\n    int recur(String word1, String word2, int index1, int index2) {\\n        int n1 = word1.length(), n2 = word2.length();\\n        if(n2==index2) return n1-index1;\\n        if(n1==index1) return n2-index2;\\n        \\n        if(word1.charAt(index1)== word2.charAt(index2)) {\\n            return recur(word1,word2,index1+1,index2+1);\\n        } else {\\n            int c1 = 1+recur(word1, word2,index1,index2+1); //insert\\n            int c2 = 1+recur(word1, word2,index1+1,index2); //delete\\n            int c3 = 1+recur(word1, word2,index1+1,index2+1); //replace\\n            return Math.min(c1,Math.min(c2,c3));\\n        }\\n    }\\n}\\n```\\ndp, time = O(mn), space = O(mn)\\n```\\nclass Solution {\\n\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n1= word1.length(), n2=word2.length();\\n        if(n1==0) return n2;\\n        if(n2==0) return n1;\\n        int[][] dp = new int[n1+1][n2+1];\\n        //base\\n         for(int i =0;i<n1+1;i++)  {    \\n            dp[i][0] = i; //delete \\n         }\\n\\n         for(int j =0;j<n2+1;j++)  {    \\n            dp[0][j] = j; //add \\n         }\\n         \\n        for(int i = 1;i<n1+1; i++) {\\n            for(int j = 1;j<n2+1; j++) {\\n            \\n                if(word1.charAt(i-1) ==word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    int c1 = dp[i-1][j]; //insert \\n                    int c2 = dp[i][j-1]; //delete\\n                    int c3 = dp[i-1][j-1]; //replace            \\n                    dp[i][j] =1+ Math.min(Math.min(c1,c2),c3);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        return recur(word1,word2,0,0);\\n    }\\n    \\n    int recur(String word1, String word2, int index1, int index2) {\\n        int n1 = word1.length(), n2 = word2.length();\\n        if(n2==index2) return n1-index1;\\n        if(n1==index1) return n2-index2;\\n        \\n        if(word1.charAt(index1)== word2.charAt(index2)) {\\n            return recur(word1,word2,index1+1,index2+1);\\n        } else {\\n            int c1 = 1+recur(word1, word2,index1,index2+1); //insert\\n            int c2 = 1+recur(word1, word2,index1+1,index2); //delete\\n            int c3 = 1+recur(word1, word2,index1+1,index2+1); //replace\\n            return Math.min(c1,Math.min(c2,c3));\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n1= word1.length(), n2=word2.length();\\n        if(n1==0) return n2;\\n        if(n2==0) return n1;\\n        int[][] dp = new int[n1+1][n2+1];\\n        //base\\n         for(int i =0;i<n1+1;i++)  {    \\n            dp[i][0] = i; //delete \\n         }\\n\\n         for(int j =0;j<n2+1;j++)  {    \\n            dp[0][j] = j; //add \\n         }\\n         \\n        for(int i = 1;i<n1+1; i++) {\\n            for(int j = 1;j<n2+1; j++) {\\n            \\n                if(word1.charAt(i-1) ==word2.charAt(j-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else {\\n                    int c1 = dp[i-1][j]; //insert \\n                    int c2 = dp[i][j-1]; //delete\\n                    int c3 = dp[i-1][j-1]; //replace            \\n                    dp[i][j] =1+ Math.min(Math.min(c1,c2),c3);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043703,
                "title": "java-recursion-memoization-explanation",
                "content": "## For any DP question there are 2 parts: \\n1) Base case: Always think of what the smallest possible input could be. In our case, lengths of string word1 and word2 (let M = length of word1 & N = length of word2).\\nSo, base case is if(M==0 || N==0). \\nIf M==0, we simply insert all n characters of word2 into it and return N.\\nIf N==0, we simply delete all m characters in word2 and return M.\\nBasically we return Max(M,N). If both are 0, it returns 0.\\n\\n2) Choice tree\\nLet\\'s say at an instant we have the first m characters of word1 and the first n characters of word2. How do we solve the question for this instance? ```minDist(word1, word2, m, n)  ```\\nOur strategy is to keep on reducing the input step-by-step and check the last characters of both the inputs. For the last characters, we have 2 possibilities.\\n* Both characters are same ( word1.charAt(m) == word2.charAt(n) )\\nWe don\\'t need any operation because both characters are same.\\nSimply reduce the input length and return ```minDist(word1, word2, m-1, n-1) ```\\n* Characters are different  ( word1.charAt(m-1) != word2.charAt(n-1) )\\nNow we have 3 possibilities:\\n\\t1.  Insert the character word2.charAt(n) after the current index \\'m\\' of word1 \\n\\tSince we inserted a new character in word1 to match word2.charAt(n). keep m same and reduce n by 1. ```return 1 + minDist(word1, word2, m, n-1)``` (1 is the cost of the insertion operation).\\n\\t2.  Delete the character word1.charAt(m). \\n\\tSince we deleted a character from word1 because it didn\\'t match with word2.charAt(n).\\n\\tDecrease m by 1 and keep n the same. ```return 1 + minDist(word1, word2, m-1, n)``` (1 is the cost of the deletion operation). \\n\\t3.  Substitute the character word1.charAt(m) with word2.charAt(n). Decrease m and n both by 1. ```return 1 + minDist(word1, word2, m-1, n-1)``` (1 is the cost of the substitution operation). \\n\\n\\tNow, simply take the minimum of what these 3 possibilities and return it as the answer for this instance of the function call ```minDist(word1, word2, m, n)```\\n\\tThen just use a 2D matrix(dp) to store the solution for memoization.\\n\\tTime complexity: O(MN)\\n```\\n\\tpublic int minDist(String x, String y, int m, int n, int dp[][]){\\n        if(m==0 || n==0)\\n            return Math.max(m,n);\\n        if(x.charAt(m-1)==y.charAt(n-1))\\n            return minDist(x,y,m-1,n-1, dp);\\n    \\n        if(dp[m][n-1]==-1) dp[m][n-1] = 1+minDist(x, y, m, n-1, dp);\\n        if(dp[m-1][n]==-1) dp[m-1][n] = 1+minDist(x, y, m-1, n, dp);\\n        if(dp[m-1][n-1]==-1) dp[m-1][n-1] = 1+minDist(x, y, m-1, n-1, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(dp[m-1][n-1],dp[m-1][n]), dp[m][n-1]);\\n        \\n    }\\n    public int minDistance(String word1, String word2) {\\n        int m=word1.length(), n=word2.length();\\n        int t[][]=new int[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            for(int j=0;j<=n;j++)\\n                t[i][j]=-1;\\n        return minDist(word1, word2, m, n, t);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```minDist(word1, word2, m, n)  ```\n```minDist(word1, word2, m-1, n-1) ```\n```return 1 + minDist(word1, word2, m, n-1)```\n```return 1 + minDist(word1, word2, m-1, n)```\n```return 1 + minDist(word1, word2, m-1, n-1)```\n```minDist(word1, word2, m, n)```\n```\\n\\tpublic int minDist(String x, String y, int m, int n, int dp[][]){\\n        if(m==0 || n==0)\\n            return Math.max(m,n);\\n        if(x.charAt(m-1)==y.charAt(n-1))\\n            return minDist(x,y,m-1,n-1, dp);\\n    \\n        if(dp[m][n-1]==-1) dp[m][n-1] = 1+minDist(x, y, m, n-1, dp);\\n        if(dp[m-1][n]==-1) dp[m-1][n] = 1+minDist(x, y, m-1, n, dp);\\n        if(dp[m-1][n-1]==-1) dp[m-1][n-1] = 1+minDist(x, y, m-1, n-1, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(dp[m-1][n-1],dp[m-1][n]), dp[m][n-1]);\\n        \\n    }\\n    public int minDistance(String word1, String word2) {\\n        int m=word1.length(), n=word2.length();\\n        int t[][]=new int[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n            for(int j=0;j<=n;j++)\\n                t[i][j]=-1;\\n        return minDist(word1, word2, m, n, t);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313920,
                "title": "c-96-beaten-using-dp-o-n-m-quadratic-speed-using-smart-lawz-kaboom",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        \\n        int aGrid[word1.size() + 1][word2.size() + 1];\\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 0;\\n        for (int x=1;x<=word1.size();x++) { aGrid[x][0] = x; }\\n        for (int y=1;y<=word2.size();y++) { aGrid[0][y] = y; }\\n        \\n        for (int x=1;x<=word1.size();x++) {\\n            for (int y=1;y<=word2.size();y++) {\\n                if (word1[x-1] == word2[y-1]) {\\n                    aGrid[x][y] = aGrid[x-1][y-1];\\n                } else {   \\n                    aGrid[x][y] = 1 + min(aGrid[x-1][y-1], min(aGrid[x-1][y], aGrid[x][y-1]));\\n                }\\n            }\\n        }\\n        \\n        return aGrid[word1.size()][word2.size()];\\n    }\\n};\\n```\\n\\nShip it in, ship it out. Now you\\'re on the payroll, living large. Boom, baby.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        \\n        int aGrid[word1.size() + 1][word2.size() + 1];\\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 0;\\n        for (int x=1;x<=word1.size();x++) { aGrid[x][0] = x; }\\n        for (int y=1;y<=word2.size();y++) { aGrid[0][y] = y; }\\n        \\n        for (int x=1;x<=word1.size();x++) {\\n            for (int y=1;y<=word2.size();y++) {\\n                if (word1[x-1] == word2[y-1]) {\\n                    aGrid[x][y] = aGrid[x-1][y-1];\\n                } else {   \\n                    aGrid[x][y] = 1 + min(aGrid[x-1][y-1], min(aGrid[x-1][y], aGrid[x][y-1]));\\n                }\\n            }\\n        }\\n        \\n        return aGrid[word1.size()][word2.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301791,
                "title": "wrong-test-case",
                "content": "Hi guys, I think this case is wrong. \\n```\\nInput:\\n\"zoologicoarchaeologist\"\\n\"zoogeologist\"\\nOutput:\\n9\\nExpected:\\n10\\n```\\nThe expected response should be 9. I confirmed it with different methods:\\n* Online Levenshtein calculator: https://planetcalc.com/1721/\\n* Manual:\\n![image](https://assets.leetcode.com/users/no6thing/image_1559170315.png)\\n\\nWhat you think?\\n\\n",
                "solutionTags": [],
                "code": "```\\nInput:\\n\"zoologicoarchaeologist\"\\n\"zoogeologist\"\\nOutput:\\n9\\nExpected:\\n10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227181,
                "title": "javascript-solution",
                "content": "```\\nvar minDistance = function(word1, word2) {\\n    const dp = initializeDp(word1, word2)\\n    constructDp(dp, word1, word2)\\n    return dp[word1.length][word2.length]\\n}\\n\\nconst initializeDp = (word1, word2) => {\\n    const dp = Array(word1.length + 1).fill().map(() => Array(word2.length + 1).fill())\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 0; i < rows; i++) {\\n        dp[i][0] = i\\n    }\\n    for (let i = 1; i < cols; i++) {\\n        dp[0][i] = i\\n    }\\n    return dp\\n}\\n\\nconst constructDp = (dp, word1, word2) => {\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 1; i < rows; i++) {\\n        for (let j = 1; j < cols; j++) {\\n            if (word1[i - 1] === word2[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1]\\n            } else {\\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDistance = function(word1, word2) {\\n    const dp = initializeDp(word1, word2)\\n    constructDp(dp, word1, word2)\\n    return dp[word1.length][word2.length]\\n}\\n\\nconst initializeDp = (word1, word2) => {\\n    const dp = Array(word1.length + 1).fill().map(() => Array(word2.length + 1).fill())\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 0; i < rows; i++) {\\n        dp[i][0] = i\\n    }\\n    for (let i = 1; i < cols; i++) {\\n        dp[0][i] = i\\n    }\\n    return dp\\n}\\n\\nconst constructDp = (dp, word1, word2) => {\\n    const rows = dp.length\\n    const cols = dp[0].length\\n    for (let i = 1; i < rows; i++) {\\n        for (let j = 1; j < cols; j++) {\\n            if (word1[i - 1] === word2[j - 1]) {\\n                dp[i][j] = dp[i - 1][j - 1]\\n            } else {\\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25954,
                "title": "uses-longest-increasing-subsequence-subset-enumeration-dfs",
                "content": "My solution finds the longest matching pattern of string 1 in  string 2. \\nSo for word1 = \"adbac\" and word2 = \"abc\" , the longest matching pattern (not necessarily continuous) is \"abc\" \\nHow ? we can remove 'd' & second 'a' from \"adbac\" to get \"abc\". \\nThe way I find the longest matching pattern is through longest increasing subsequence . (standard dp)          \\nAfter than, the minimum can be found using simple math.\\n\\n\\n    public class Solution {\\n    \\n    List<List<Integer>> sequences = new ArrayList<List<Integer>>();\\n    void printer(List<Integer> seq){\\n        for(int i=0;i<seq.size();i++)\\n            System.out.print(seq.get(i) + \" \");\\n        System.out.println();\\n    }\\n    void form(int cur,List<Integer> sequence,List<List<Integer>>array){\\n        if(cur == array.size()){\\n            List<Integer> copy = new ArrayList<Integer>();\\n            for(int i=0; i<sequence.size();i++)\\n                copy.add(sequence.get(i));\\n            sequences.add(copy);\\n            return;\\n        }\\n        List<Integer> options = array.get(cur);\\n        for(int i=0;i<options.size();i++){\\n            sequence.add(options.get(i));\\n            form(cur+1,sequence,array);\\n            sequence.remove(sequence.size()-1);\\n        }\\n    }\\n    \\n    # find longest increasing subsequence for a given sequence\\n    List<Integer> get_lis (List<Integer> sequence){\\n        List<Integer> dp = new ArrayList<Integer>();\\n        Map<Integer,Integer> path = new HashMap<Integer,Integer>();\\n        List<Integer> lis = new ArrayList<Integer>();\\n        dp.add(1);\\n        path.put(0,-1);\\n        int maxpos = 0;\\n        for(int i=1;i<sequence.size();i++){\\n            if(sequence.get(i) == -1){\\n                dp.add(-1);\\n                continue;\\n            }\\n            dp.add(1);\\n            path.put(i,-1);\\n            for(int j=0;j<i;j++){\\n                if(sequence.get(j) < sequence.get(i) && dp.get(j) >= dp.get(i)){\\n                    dp.set(i,dp.get(j)+1);\\n                    path.put(i,j);\\n                }\\n            }\\n            if(dp.get(i)>dp.get(maxpos))\\n                maxpos = i;\\n        }\\n        Set<Integer> in_lis = new HashSet<Integer>();\\n        int pos = maxpos;\\n        while(true){\\n            if(pos == -1)\\n                break;\\n            in_lis.add(pos);\\n            pos = path.get(pos);\\n        }\\n        int count = 0;\\n        for(int i=0;i<sequence.size();i++){\\n            if(in_lis.contains(i)){\\n                lis.add(sequence.get(i));\\n                count++;\\n            }\\n            else\\n                lis.add(-1);\\n        }\\n        lis.add(count);\\n        return lis;\\n    }\\n    \\n    public int minDistance(String word1, String word2) {\\n        \\n       # form a map from characters that appear in word2 to a list of indices they appear in\\n        \\n        HashMap<Character,List<Integer>> map = new HashMap<Character,List<Integer>>();\\n        for(int i=0;i<word2.length();i++){\\n            char c = word2.charAt(i);\\n            if(!map.containsKey(c)){\\n                ArrayList<Integer> l = new ArrayList<Integer>();\\n                l.add(i);\\n                map.put(c,l);\\n            }\\n            else{\\n                List<Integer> l = map.get(c);\\n                l.add(i);\\n            }\\n        }\\n        \\n        # form a map from each index in word1 to the possible positions of that character in word2\\n        List<List<Integer>> array = new ArrayList<List<Integer>>();\\n        for(int i=0;i<word1.length();i++){\\n            char c = word1.charAt(i);\\n            List<Integer> l;\\n            if(!map.containsKey(c)){\\n               l = new ArrayList<Integer>();\\n               l.add(-1);\\n            }\\n            else\\n                l = map.get(c);\\n            array.add(l);\\n        }\\n        \\n        \\n        List<Integer> sequence = new ArrayList<Integer>();      #empty sequence just for the purpose of DFS\\n        \\n        # from the above map, each index in word1 can have multiple values. For example, for word1 = \"abc\"\\n        and word2 = \"aad\" , the values for index 0 ('a') for word1 are 0 and 1, because  'a' appears at\\n        indices 0 and 1 in word2. So we form all sequences for all possible values of each index of word1.\\n        \\n        form(0,sequence,array);                 # form all possible sequences\\n        \\n        \\n        # the following part gets the maximum longest possible subsequence from all possible sequences\\n        List<Integer> final_lis = new ArrayList<Integer>();\\n        int maxlen=0;\\n        for(int i=0; i<sequences.size();i++){\\n            sequence = sequences.get(i);\\n            List<Integer> lis = get_lis(sequence);\\n            int lislen = lis.get(lis.size()-1);\\n            if(lislen>maxlen){\\n                maxlen = lislen;\\n                lis.remove(lis.size()-1);\\n                final_lis = lis;\\n            }\\n        }\\n        \\n        #simple math to get the final answer\\n        int answer = 0;\\n        int i=0;\\n        int previ=0;\\n        int prevval=0;\\n        while(i<final_lis.size()){\\n            if(final_lis.get(i) == -1){\\n                i++;\\n                continue;\\n            }\\n            \\n            int diff1 = final_lis.get(i) - prevval -1;\\n            int diff2 = i - previ -1;\\n            answer += Math.max(diff1,diff2);\\n            previ = i;\\n            prevval = final_lis.get(i);\\n            i++;\\n        }\\n        \\n        int diff1 = word1.length() - previ;\\n        int diff2 = word2.length() - prevval;\\n        answer += Math.max(diff1,diff2);\\n        return answer;\\n    }\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    List<List<Integer>> sequences = new ArrayList<List<Integer>>();\\n    void printer(List<Integer> seq){\\n        for(int i=0;i<seq.size();i++)\\n            System.out.print(seq.get(i) + \" \");\\n        System.out.println();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3926498,
                "title": "python-91-89-faster-dp-memoization-tabulation",
                "content": "```\\n\\'\\'\\'\\nExample: s1: \\'horse\\'\\n         s2: \\'ros\\'\\n\\nCase1: Inserting a Character\\n\\nNow if we have to match the strings by insertions, what would we do?: \\n\\nWe would have placed an \\u2018s\\u2019 at index 5 of S1.\\nSuppose i now point to s at index 5 of S1 and j points are already pointing to s at index j of S2.\\nNow, we hit the condition, where characters do match. (as mentioned in case 1).\\nTherefore, we will decrement i and j by 1. They will now point to index 4 and 1 respectively.\\n\\nNow, the number of operations we did were only 1 (inserting s at index 5) but do we need to really insert the \\u2018s\\u2019 at index 5 and modify the string? The answer is simply NO. As we see that inserting a character (here \\u2018s\\u2019 at index 5), we will eventually get to the third step. So we can just return 1+ f(i,j-1) as i remains there only after insertion and j decrements by 1. We can say that we have hypothetically inserted character s.\\n\\nCase 2: Deleting a character \\n\\nConsider the same example,\\n\\nWe can simply delete the character at index 4 and check from the next index.\\n\\nNow, j remains at its original index and we decrement i by 1. We perform 1 operation, therefore we will recursively call 1+f(i-1,j).\\n\\nCase3: Replacing a character \\n\\nConsider the same example,\\n\\n\\nIf we replace the character \\u2018e\\u2019 at index 4 of S1 with \\u2018s\\u2019, we have matched both the characters ourselves. We again hit the case of character matching, therefore we decrement both i and j by 1. As the number of operations performed is 1, we will return 1+f(i-1,j-1).\\n\\nTo summarise, these are the three choices we have in case characters don\\u2019t match:\\n\\nreturn 1+f(i-1,j) // Insertion of character.\\nreturn 1+f(i,j-1) // Deletion of character.\\nreturn 1+f(i-1,j-1) // Replacement of character.\\n\\'\\'\\'\\n\\n#Recursion \\n#Time Complexity: O(2^(m+n))\\n#Space Complexity: O(m+n)\\nclass Solution1:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if word1[i-1]==word2[j-1]:\\n                return solve(i-1,j-1)\\n            else:\\n                return 1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n        m,n=len(word1),len(word2)\\n        return solve(m,n)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(m+n) + O(m*n)\\nclass Solution2:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            if word1[i-1]==word2[j-1]:\\n                dp[i][j]=solve(i-1,j-1)\\n                return dp[i][j]\\n            else:\\n                dp[i][j]=1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n                return dp[i][j]\\n        m,n=len(word1),len(word2)\\n        dp=[[-1 for j in range(n+1)] for i in range(m+1)]\\n        return solve(m,n)\\n    \\nclass Solution3:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0] = i\\n        for j in range(n+1):\\n            dp[0][j] = j\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\\n        return dp[m][n]\\n    \\n#Space Optimization\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        prev=[0]*(n+1)\\n        curr=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    curr[j] = prev[j-1]\\n                else:\\n                    curr[j] = 1 + min(prev[j-1], prev[j], curr[j-1])\\n            prev=curr[:]\\n        return prev[n]\\n```\\n**An upovte will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\'\\'\\'\\nExample: s1: \\'horse\\'\\n         s2: \\'ros\\'\\n\\nCase1: Inserting a Character\\n\\nNow if we have to match the strings by insertions, what would we do?: \\n\\nWe would have placed an \\u2018s\\u2019 at index 5 of S1.\\nSuppose i now point to s at index 5 of S1 and j points are already pointing to s at index j of S2.\\nNow, we hit the condition, where characters do match. (as mentioned in case 1).\\nTherefore, we will decrement i and j by 1. They will now point to index 4 and 1 respectively.\\n\\nNow, the number of operations we did were only 1 (inserting s at index 5) but do we need to really insert the \\u2018s\\u2019 at index 5 and modify the string? The answer is simply NO. As we see that inserting a character (here \\u2018s\\u2019 at index 5), we will eventually get to the third step. So we can just return 1+ f(i,j-1) as i remains there only after insertion and j decrements by 1. We can say that we have hypothetically inserted character s.\\n\\nCase 2: Deleting a character \\n\\nConsider the same example,\\n\\nWe can simply delete the character at index 4 and check from the next index.\\n\\nNow, j remains at its original index and we decrement i by 1. We perform 1 operation, therefore we will recursively call 1+f(i-1,j).\\n\\nCase3: Replacing a character \\n\\nConsider the same example,\\n\\n\\nIf we replace the character \\u2018e\\u2019 at index 4 of S1 with \\u2018s\\u2019, we have matched both the characters ourselves. We again hit the case of character matching, therefore we decrement both i and j by 1. As the number of operations performed is 1, we will return 1+f(i-1,j-1).\\n\\nTo summarise, these are the three choices we have in case characters don\\u2019t match:\\n\\nreturn 1+f(i-1,j) // Insertion of character.\\nreturn 1+f(i,j-1) // Deletion of character.\\nreturn 1+f(i-1,j-1) // Replacement of character.\\n\\'\\'\\'\\n\\n#Recursion \\n#Time Complexity: O(2^(m+n))\\n#Space Complexity: O(m+n)\\nclass Solution1:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if word1[i-1]==word2[j-1]:\\n                return solve(i-1,j-1)\\n            else:\\n                return 1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n        m,n=len(word1),len(word2)\\n        return solve(m,n)\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(m+n) + O(m*n)\\nclass Solution2:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def solve(i,j):\\n            if i==0:\\n                return j\\n            if j==0:\\n                return i\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            if word1[i-1]==word2[j-1]:\\n                dp[i][j]=solve(i-1,j-1)\\n                return dp[i][j]\\n            else:\\n                dp[i][j]=1 + min(solve(i,j-1),solve(i-1,j),solve(i-1,j-1))\\n                return dp[i][j]\\n        m,n=len(word1),len(word2)\\n        dp=[[-1 for j in range(n+1)] for i in range(m+1)]\\n        return solve(m,n)\\n    \\nclass Solution3:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0] = i\\n        for j in range(n+1):\\n            dp[0][j] = j\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\\n        return dp[m][n]\\n    \\n#Space Optimization\\n#Time Complexity: O(m*n)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m,n = len(word1),len(word2)\\n        prev=[0]*(n+1)\\n        curr=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1] == word2[j-1]:\\n                    curr[j] = prev[j-1]\\n                else:\\n                    curr[j] = 1 + min(prev[j-1], prev[j], curr[j-1])\\n            prev=curr[:]\\n        return prev[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759099,
                "title": "c-solution-using-memoization-with-explaination",
                "content": "# Approach\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Perameters**\\nHere we are maintaining 2 indexes.i1 is for s1 and i2 is for s2.\\nn1 is size of s1 and n2 is size of s2.\\n\\n- **All possiblities**\\n\\nwe have 2 possiblites for each of the indexes.\\n1.first is if both indexes contains smae character if it is then we increase both of the indexes.\\n2.If it is not then\\nwe can do one of 3 operations.\\n1)insert 2)replace 3)delete\\n-->for insertion : When performing an insertion operation, we assume that we have added the character s2[i2] at the position s1[i1] in s1. At this point, both s1[i1] and s2[i2] contain the same character.\\nIdeally, since both indexes should cover the same characters, we would increase both i1 and i2. However, in this case, we are considering the modified s1, which hypothetically has one additional character. But since we are not actually changing s1, we do not increment i1. Instead, we only increment i2 to move to the next character in s2.\\n\\n-->for deletion we assume we have deleted s1[i1] so we increment by 1.\\n\\n-->for replacement we assume we replace s1[i1] is replaced by s2[i2] so we increment both i1 and i2.\\n\\n- **Base cases**\\n\\ni1>=n1 : we can understand this base cases by one example\\n\\ns1 : horse\\ns2 : ros\\n\\nsuppose we delete all the element of s1 so now our i1 is pointing to n1 and i2 is pointing to 0.as we have delete all the element of s1 now we have to insert all the element of s2. so number of operation should be size of s2 this base case will cover all of these scenario.\\n so it will return n2-0 which is n2. which is our answer.\\n\\ni2>=n2 : for same example \\n\\nsuppose we insert all the element of s2 into s1 but we haven\\'t deleted any of the element of s2.so now we have to delete all the old characters of n2 . this base cases will cover all of these kind of scenario. so it will return n1-0 which is n1. which is our answer.\\n\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n1 * n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n1 * n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int i1,int i2,string s1,string s2,int n1,int n2,vector<vector<int>>& dp)\\n    {\\n        if(i1>=n1)\\n            return n2-i2;\\n        if(i2>=n2)\\n            return n1-i1;\\n        if(dp[i1][i2]!=-1)\\n            return dp[i1][i2];\\n        if(s1[i1]==s2[i2])\\n            return helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        int insert=helper(i1,i2+1,s1,s2,n1,n2,dp);\\n        int del=helper(i1+1,i2,s1,s2,n1,n2,dp);\\n        int rep=helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        return dp[i1][i2]=1+min(insert,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        \\n        int n1=word1.size();\\n        int n2=word2.size();\\n        vector<vector<int>> dp(n1,vector<int>(n2,-1));\\n        return helper(0,0,word1,word2,n1,n2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i1,int i2,string s1,string s2,int n1,int n2,vector<vector<int>>& dp)\\n    {\\n        if(i1>=n1)\\n            return n2-i2;\\n        if(i2>=n2)\\n            return n1-i1;\\n        if(dp[i1][i2]!=-1)\\n            return dp[i1][i2];\\n        if(s1[i1]==s2[i2])\\n            return helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        int insert=helper(i1,i2+1,s1,s2,n1,n2,dp);\\n        int del=helper(i1+1,i2,s1,s2,n1,n2,dp);\\n        int rep=helper(i1+1,i2+1,s1,s2,n1,n2,dp);\\n        return dp[i1][i2]=1+min(insert,min(del,rep));\\n    }\\n    int minDistance(string word1, string word2) {\\n        \\n        int n1=word1.size();\\n        int n2=word2.size();\\n        vector<vector<int>> dp(n1,vector<int>(n2,-1));\\n        return helper(0,0,word1,word2,n1,n2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753229,
                "title": "tabulation-dp-c-easy-to-understand",
                "content": "### Please upvote if you found it useful!\\n\\n```\\n    int minDistance(string word1, string word2) {\\n        const int l1 = word1.size();\\n        const int l2 = word2.size();\\n        vector<vector<int>> dp(l1+1,vector<int>(l2+1,0));\\n        for(int i=0;i<=l1;++i){\\n            dp[i][0] = i;\\n        }\\n        for(int i=0;i<=l2;++i){\\n            dp[0][i] = i;\\n        }\\n        dp[0][0] = 0;\\n        for(int i=1;i<=l1;++i){\\n            for(int j=1;j<=l2;++j){\\n                if(word1[i-1]==word2[j-1]){dp[i][j] = dp[i-1][j-1];}\\n                else{dp[i][j] = 1+min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]});}\\n            }\\n        }\\n        return dp[l1][l2];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        const int l1 = word1.size();\\n        const int l2 = word2.size();\\n        vector<vector<int>> dp(l1+1,vector<int>(l2+1,0));\\n        for(int i=0;i<=l1;++i){\\n            dp[i][0] = i;\\n        }\\n        for(int i=0;i<=l2;++i){\\n            dp[0][i] = i;\\n        }\\n        dp[0][0] = 0;\\n        for(int i=1;i<=l1;++i){\\n            for(int j=1;j<=l2;++j){\\n                if(word1[i-1]==word2[j-1]){dp[i][j] = dp[i-1][j-1];}\\n                else{dp[i][j] = 1+min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]});}\\n            }\\n        }\\n        return dp[l1][l2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3296233,
                "title": "iterative-short-sweet-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s1, string s2) {\\n        int m = s1.length(),n=s2.length(),i,j;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(i = 0; i <= m; i++){\\n            for(j = 0; j <= n; j++){\\n                if(i==0&&j==0){\\n                    dp[i][j] = 0;\\n                }else if(i==0){\\n                    dp[i][j] = j;\\n                }else if(j==0){\\n                    dp[i][j] = i;\\n                }\\n                else if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string s1, string s2) {\\n        int m = s1.length(),n=s2.length(),i,j;\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        for(i = 0; i <= m; i++){\\n            for(j = 0; j <= n; j++){\\n                if(i==0&&j==0){\\n                    dp[i][j] = 0;\\n                }else if(i==0){\\n                    dp[i][j] = j;\\n                }else if(j==0){\\n                    dp[i][j] = i;\\n                }\\n                else if(s1[i-1]==s2[j-1]){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else{\\n                    dp[i][j] = min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235589,
                "title": "beginner-friendly-step-by-step-elaboration-with-video-solution-java",
                "content": "# Intuition\\nThe solution below is self explanatory. \\nIf you understand **Bangla**, you can see this video for step by step clear explanation:\\n\\nhttps://youtu.be/lWocPDgqFIo\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRecursion With Memorization. Bottom Up Approach.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code [Java]\\n```\\nclass Solution {\\n    Integer memo[][];\\n    int w1Len, w2Len;\\n    public int minDistance(String word1, String word2) {\\n        memo = new Integer[word1.length() + 1][word2.length() + 1];\\n        w1Len = word1.length();\\n        w2Len = word2.length();\\n        return minDistanceRecur(word1, word2, 0, 0);\\n    }\\n\\n    int minDistanceRecur(String word1, String word2, int word1Index, int word2Index) {\\n        if (word1Index == w1Len) {\\n            // return how many remaining for word2\\n            return w2Len-word2Index;\\n        }\\n        if (word2Index == w2Len) {\\n            // return how many remaining for word1\\n            return w1Len-word1Index;\\n        }\\n        if (memo[word1Index][word2Index] != null) {\\n            return memo[word1Index][word2Index];\\n        }\\n        int minEditDistance = 0;\\n        if (word1.charAt(word1Index) == word2.charAt(word2Index)) {\\n            minEditDistance = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n        }\\n        else {\\n            // insert in word1 or, delete from word1\\n            int insertOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index);\\n            // delete from word2 or, insert in word2\\n            int deleteOperation = minDistanceRecur(word1, word2, word1Index, word2Index+1);\\n            // replace so, the i\\'th index of both word1 and word2 becomes equal. Now we move to i+1 th index for both.\\n            int replaceOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n            minEditDistance = Math.min(insertOperation, Math.min(deleteOperation, replaceOperation)) + 1;\\n        }\\n        memo[word1Index][word2Index] = minEditDistance;\\n        return minEditDistance;\\n    }\\n}\\n```\\n\\n![3549-pepepopcorn.png](https://assets.leetcode.com/users/images/3ec73dd1-878d-4bc2-bf53-1096d00472ab_1677485929.702025.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer memo[][];\\n    int w1Len, w2Len;\\n    public int minDistance(String word1, String word2) {\\n        memo = new Integer[word1.length() + 1][word2.length() + 1];\\n        w1Len = word1.length();\\n        w2Len = word2.length();\\n        return minDistanceRecur(word1, word2, 0, 0);\\n    }\\n\\n    int minDistanceRecur(String word1, String word2, int word1Index, int word2Index) {\\n        if (word1Index == w1Len) {\\n            // return how many remaining for word2\\n            return w2Len-word2Index;\\n        }\\n        if (word2Index == w2Len) {\\n            // return how many remaining for word1\\n            return w1Len-word1Index;\\n        }\\n        if (memo[word1Index][word2Index] != null) {\\n            return memo[word1Index][word2Index];\\n        }\\n        int minEditDistance = 0;\\n        if (word1.charAt(word1Index) == word2.charAt(word2Index)) {\\n            minEditDistance = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n        }\\n        else {\\n            // insert in word1 or, delete from word1\\n            int insertOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index);\\n            // delete from word2 or, insert in word2\\n            int deleteOperation = minDistanceRecur(word1, word2, word1Index, word2Index+1);\\n            // replace so, the i\\'th index of both word1 and word2 becomes equal. Now we move to i+1 th index for both.\\n            int replaceOperation = minDistanceRecur(word1, word2, word1Index + 1, word2Index + 1);\\n            minEditDistance = Math.min(insertOperation, Math.min(deleteOperation, replaceOperation)) + 1;\\n        }\\n        memo[word1Index][word2Index] = minEditDistance;\\n        return minEditDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233545,
                "title": "python3-56-ms-faster-than-99-95-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/222526f8-ed70-43bf-a0c4-72c76ed4f424_1677429728.1260953.png)\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        if word1 == word2:\\n            return 0\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))            \\n        w1 = list(word1)\\n        w2 = list(word2)        \\n        num = 0\\n        queue = deque()\\n        queue.append((0, 0))\\n        visited = set()\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if (i, j) in visited:\\n                    continue\\n                visited.add((i, j))\\n                while i < len(w1) and j < len(w2) and w1[i] == w2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == len(w1) and j == len(w2):\\n                    return num\\n                queue.append((i, j + 1))\\n                queue.append((i + 1, j + 1))\\n                queue.append((i + 1, j))\\n            num += 1\\n```\\nThis code is an implementation of a Breadth-First Search (BFS) algorithm to solve the minimum edit distance problem between two words. The minimum edit distance is defined as the minimum number of operations (insertions, deletions, substitutions) needed to transform one string into another.\\n\\nHere\\'s a step-by-step breakdown of the code:\\n1. The function minDistance takes two string arguments word1 and word2 and returns an integer representing the minimum edit distance between the two strings.\\n1. The function first checks if the two input strings are the same. If they are, the minimum edit distance is zero, and the function returns immediately.\\n1. If either of the input strings is empty, the minimum edit distance is the length of the non-empty string. Therefore, the function returns the maximum length between the two strings.\\n1. Next, the input strings are converted into lists of characters w1 and w2.\\n1. A variable num is initialized to zero. This variable will be used to keep track of the number of operations needed to transform word1 into word2.\\n1. A deque object queue is created to hold the coordinates of the current position in the matrix. The initial position is (0, 0), which corresponds to the first character of both strings.\\n1. A set visited is created to keep track of visited positions.\\n1. A while loop runs until the queue is empty. Within the loop, a for loop is used to process all the elements currently in the queue.\\n1. The i and j indices of the current position are obtained from the leftmost element of the queue, and the leftmost element is removed from the queue.\\n1. If the position (i, j) has been visited before, it is skipped.\\n1. The loop moves the i and j indices until the characters at positions w1[i] and w2[j] are different. This means that there is an operation needed at this position.\\n1. If both i and j have reached the end of their respective strings, the minimum edit distance has been found, and the function returns the current value of num.\\n1. The three possible edit operations (insertion, deletion, and substitution) are added to the queue.\\n1. The num variable is incremented at the end of each iteration of the while loop.\\n1. If the end of the function is reached without finding a solution, the function returns num, which represents the minimum number of operations needed to transform word1 into word2.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        if word1 == word2:\\n            return 0\\n        if len(word1) == 0 or len(word2) == 0:\\n            return max(len(word1), len(word2))            \\n        w1 = list(word1)\\n        w2 = list(word2)        \\n        num = 0\\n        queue = deque()\\n        queue.append((0, 0))\\n        visited = set()\\n        while len(queue) > 0:\\n            for _ in range(len(queue)):\\n                i, j = queue.popleft()\\n                if (i, j) in visited:\\n                    continue\\n                visited.add((i, j))\\n                while i < len(w1) and j < len(w2) and w1[i] == w2[j]:\\n                    i += 1\\n                    j += 1\\n                if i == len(w1) and j == len(w2):\\n                    return num\\n                queue.append((i, j + 1))\\n                queue.append((i + 1, j + 1))\\n                queue.append((i + 1, j))\\n            num += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232618,
                "title": "c-code-dp-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nApplication of DP\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n        {\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<=n;j++)\\n        {\\n            dp[0][j]=j;\\n\\n        }\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                    \\n                }\\n                else \\n                {   int mini=min(dp[i-1][j],dp[i][j-1]);\\n                    dp[i][j]=1+ min(dp[i-1][j-1],mini);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.size();\\n        int n=word2.size();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++)\\n        {\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<=n;j++)\\n        {\\n            dp[0][j]=j;\\n\\n        }\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                    \\n                }\\n                else \\n                {   int mini=min(dp[i-1][j],dp[i][j-1]);\\n                    dp[i][j]=1+ min(dp[i-1][j-1],mini);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231952,
                "title": "dynamic-programming",
                "content": "# Intuition & Approach\\nhttps://youtu.be/rOHeIwyAO9g\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; ++i) {\\n            for (int j = 0; j <= m; ++j) {\\n                if (!i || !j)\\n                    dp[i][j] = i + j;\\n                else if (word1[i - 1] == word2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + min({\\n                        dp[i][j - 1],    // insert\\n                        dp[i - 1][j],    // delete\\n                        dp[i - 1][j - 1] // replace\\n                    });\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> dp;\\n    \\n    int minDistance(string word1, string word2) {\\n        n = word1.size(), m = word2.size();\\n        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, -1));\\n        \\n        return solve(n, m, word1, word2);\\n    }\\n    \\n    int solve(int i, int j, string &str1, string &str2) {\\n        if (!i || !j) return i + j;\\n        \\n        int &ret = dp[i][j];\\n        if (~ret) return ret;\\n        \\n        if (str1[i - 1] == str2[j - 1])\\n            return ret = solve(i - 1, j - 1, str1, str2);\\n\\n        return ret = 1 + min({\\n            solve(i, j - 1, str1, str2),    // insert\\n            solve(i - 1, j, str1, str2),    // delete\\n            solve(i - 1, j - 1, str1, str2) // replace\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size(), m = word2.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for (int i = 0; i <= n; ++i) {\\n            for (int j = 0; j <= m; ++j) {\\n                if (!i || !j)\\n                    dp[i][j] = i + j;\\n                else if (word1[i - 1] == word2[j - 1])\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + min({\\n                        dp[i][j - 1],    // insert\\n                        dp[i - 1][j],    // delete\\n                        dp[i - 1][j - 1] // replace\\n                    });\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> dp;\\n    \\n    int minDistance(string word1, string word2) {\\n        n = word1.size(), m = word2.size();\\n        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, -1));\\n        \\n        return solve(n, m, word1, word2);\\n    }\\n    \\n    int solve(int i, int j, string &str1, string &str2) {\\n        if (!i || !j) return i + j;\\n        \\n        int &ret = dp[i][j];\\n        if (~ret) return ret;\\n        \\n        if (str1[i - 1] == str2[j - 1])\\n            return ret = solve(i - 1, j - 1, str1, str2);\\n\\n        return ret = 1 + min({\\n            solve(i, j - 1, str1, str2),    // insert\\n            solve(i - 1, j, str1, str2),    // delete\\n            solve(i - 1, j - 1, str1, str2) // replace\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231173,
                "title": "c-solution-with-explanation-let-s-code-it",
                "content": "# Upvote if you found this solution helpful\\uD83D\\uDD25\\n\\n# Approach\\nTo solve this question the first approach which comes to my mind is to explore all the paths and return the path with minimum number of steps.\\nTo solve these kind of questions try to first solve them using recursion and then use memoization to reduce the complexity.\\nWe can start comparing the strings from back, one character at a time.\\nThere are three main cases which we need to keep in mind:-\\n1. Replace the character\\n2. Insert a character\\n3. Remove a character\\n\\nBase condition:-\\n1. String 1 -> empty\\n2. String 2 -> empty\\n3. Both the characters are same\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        //initialize a dp vector\\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n\\n        //start comparing the strings from end\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //if string 1 is empty\\n        if(i < 0){\\n            return j+1;\\n        }\\n        //if string 2 is empty\\n        if(j < 0){\\n            return i+1;\\n        }\\n        //if both the characters are same\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n\\n        //if we have already calculate the result for corresponding i and j\\n        //there is no need to solve further and return the ans\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        //if we remove an element\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        //if we insert an element\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        //if we replace an element\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n1 = word1.size();\\n        int n2 = word2.size(); \\n        //initialize a dp vector\\n        vector<vector<int>> dp(n1, vector<int>(n2, -1));\\n\\n        //start comparing the strings from end\\n        return helper(n1-1, n2-1, word1, word2, dp);\\n    }\\n\\n    int helper(int i, int j, string &s1, string &s2,vector<vector<int>> &dp){\\n        //if string 1 is empty\\n        if(i < 0){\\n            return j+1;\\n        }\\n        //if string 2 is empty\\n        if(j < 0){\\n            return i+1;\\n        }\\n        //if both the characters are same\\n        if(s1[i] ==  s2[j]){\\n            return dp[i][j] = helper(i-1, j-1, s1, s2, dp);\\n        }\\n\\n        //if we have already calculate the result for corresponding i and j\\n        //there is no need to solve further and return the ans\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        //if we remove an element\\n        int min1 = helper(i-1, j, s1, s2, dp);\\n        //if we insert an element\\n        int min2 = helper(i, j-1, s1, s2, dp);\\n        //if we replace an element\\n        int min3 = helper(i-1, j-1, s1, s2, dp);\\n\\n        return dp[i][j] = 1 + min(min(min1, min2), min3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230771,
                "title": "simple-tabulation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) \\n    {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int h[n+1][m+1];\\n        for(int i=0;i<m+1;i++)\\n        {\\n           h[0][i]=i;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n           h[i][0]=i;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n           for(int j=1;j<m+1;j++)\\n           {\\n              if(word1[i-1]==word2[j-1])\\n              {\\n                 h[i][j]=h[i-1][j-1];\\n              }\\n              else\\n              {\\n                 h[i][j]=min(1+h[i-1][j-1],min(1+h[i-1][j],1+h[i][j-1]));\\n              }\\n           }\\n        }\\n        return h[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) \\n    {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int h[n+1][m+1];\\n        for(int i=0;i<m+1;i++)\\n        {\\n           h[0][i]=i;\\n        }\\n        for(int i=0;i<n+1;i++)\\n        {\\n           h[i][0]=i;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n           for(int j=1;j<m+1;j++)\\n           {\\n              if(word1[i-1]==word2[j-1])\\n              {\\n                 h[i][j]=h[i-1][j-1];\\n              }\\n              else\\n              {\\n                 h[i][j]=min(1+h[i-1][j-1],min(1+h[i-1][j],1+h[i][j-1]));\\n              }\\n           }\\n        }\\n        return h[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181609,
                "title": "72-edit-distance-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We use a 2D dp array dp with dimensions (m+1) x (n+1), where m and n are the lengths of word1 and word2, respectively.\\n- dp[i][j] represents the minimum number of operations required to convert the first i characters of word1 to the first j characters of word2.\\n- Initially, if one of the strings is empty, the min number of operations is inserting all characters from the other string, so we fill the first row and first column with i and j, respectively.\\n- For each i and j, we compare the characters word1[i-1] and word2[j-1]. If they are the same, we don\\'t need to perform any operation, so dp[i][j] takes the value of dp[i-1][j-1]. If they are different, we find the minimum of three operations: replace, insert, delete, and update dp[i][j] accordingly.\\n- Finally, the minimum number of operations required is stored in dp[m][n].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        \\n        # if one of the strings is empty, the min number of operations is inserting all characters from the other string\\n        for i in range(1, m+1):\\n            dp[i][0] = i\\n        for j in range(1, n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                # if the characters are the same, we don\\'t need to perform any operation\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    # find the minimum of three operations: replace, insert, delete\\n                    dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)\\n        \\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m, n = len(word1), len(word2)\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        \\n        # if one of the strings is empty, the min number of operations is inserting all characters from the other string\\n        for i in range(1, m+1):\\n            dp[i][0] = i\\n        for j in range(1, n+1):\\n            dp[0][j] = j\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                # if the characters are the same, we don\\'t need to perform any operation\\n                if word1[i-1] == word2[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    # find the minimum of three operations: replace, insert, delete\\n                    dp[i][j] = min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)\\n        \\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076353,
                "title": "c-easy-solution-tabulation-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:  \\n    int f(int i,int j,string w1, string w2,vector<vector<int>>&dp){\\n        if(i==0) return j;\\n        if(j==0) return i;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(w1[i-1]==w2[j-1]) return 0+f(i-1,j-1,w1,w2,dp);\\n        else return dp[i][j]= 1+min(f(i-1,j-1,w1,w2,dp),min(f(i,j-1,w1,w2,dp),f(i-1,j,w1,w2,dp)));\\n        \\n    }\\n    int minDistance(string w1, string w2) {\\n        int n=w1.size();\\n        int m=w2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        for(int i=0;i<=n;i++) dp[i][0]=i;\\n        for(int j=0;j<=m;j++) dp[0][j]=j;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else  dp[i][j]= 1+min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    int f(int i,int j,string w1, string w2,vector<vector<int>>&dp){\\n        if(i==0) return j;\\n        if(j==0) return i;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(w1[i-1]==w2[j-1]) return 0+f(i-1,j-1,w1,w2,dp);\\n        else return dp[i][j]= 1+min(f(i-1,j-1,w1,w2,dp),min(f(i,j-1,w1,w2,dp),f(i-1,j,w1,w2,dp)));\\n        \\n    }\\n    int minDistance(string w1, string w2) {\\n        int n=w1.size();\\n        int m=w2.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        for(int i=0;i<=n;i++) dp[i][0]=i;\\n        for(int j=0;j<=m;j++) dp[0][j]=j;\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(w1[i-1]==w2[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else  dp[i][j]= 1+min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050516,
                "title": "memoization-tabulation-space-optimization-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, string &s, string &t, vector<vector<int>> &dp) {\\n        if(j == 0) return i;\\n        if(i == 0) return j;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        if(s[i - 1] == t[j - 1]) return dp[i][j] = dfs(i - 1, j - 1, s, t, dp);\\n        return dp[i][j] = 1 + min(dfs(i - 1, j - 1, s, t, dp), min(dfs(i, j - 1, s, t, dp), dfs(i - 1, j, s, t, dp)));\\n    }\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n\\n        return dfs(n, m, s, t, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for(int i=0; i<=n; i++) dp[i][0] = i;\\n        for(int j=0; j<=m; j++) dp[0][j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n                else dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<int> dp(m + 1), temp(m + 1);\\n\\n        for(int j=0; j<=m; j++) dp[j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            temp[0] = i;\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) temp[j] = dp[j - 1];\\n                else temp[j] = 1 + min(dp[j - 1], min(temp[j - 1], dp[j]));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, string &s, string &t, vector<vector<int>> &dp) {\\n        if(j == 0) return i;\\n        if(i == 0) return j;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        if(s[i - 1] == t[j - 1]) return dp[i][j] = dfs(i - 1, j - 1, s, t, dp);\\n        return dp[i][j] = 1 + min(dfs(i - 1, j - 1, s, t, dp), min(dfs(i, j - 1, s, t, dp), dfs(i - 1, j, s, t, dp)));\\n    }\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));\\n\\n        return dfs(n, m, s, t, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\\n\\n        for(int i=0; i<=n; i++) dp[i][0] = i;\\n        for(int j=0; j<=m; j++) dp[0][j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1];\\n                else dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i][j - 1], dp[i - 1][j]));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string s, string t) {\\n        int n = s.size(), m = t.size();\\n        vector<int> dp(m + 1), temp(m + 1);\\n\\n        for(int j=0; j<=m; j++) dp[j] = j;\\n\\n        for(int i=1; i<=n; i++) {\\n            temp[0] = i;\\n            for(int j=1; j<=m; j++) {\\n                if(s[i - 1] == t[j - 1]) temp[j] = dp[j - 1];\\n                else temp[j] = 1 + min(dp[j - 1], min(temp[j - 1], dp[j]));\\n            }\\n            dp = temp;\\n        }\\n        return dp[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015013,
                "title": "3-java-solution-from-brute-force-to-top-down-to-bottom-up",
                "content": "It is quite similar to below leetcode problem ->\\nhttps://leetcode.com/problems/delete-operation-for-two-strings/solutions/3014824/3-java-solution-from-brute-force-to-top-down-to-bottomup/?orderBy=most_votes\\n\\nThe only addition here is that instead of two operations we have third also.\\n# Brute force (TLE)\\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1);\\n}\\nprivate int helper(String s,String t,int i,int j) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return helper(s,t,i-1,j-1);\\n    }\\n    return Math.min(helper(s,t,i-1,j),Math.min(helper(s,t,i-1,j-1),helper(s,t,i,j-1)))+1;\\n}\\n```\\n# TOP Down DP\\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1,new Integer[n][m]);\\n}\\nprivate int helper(String s,String t,int i,int j,Integer[][] memo) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(memo[i][j]!=null) {\\n        return memo[i][j];\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return memo[i][j]=helper(s,t,i-1,j-1,memo);\\n    }\\n    return memo[i][j]=Math.min(helper(s,t,i-1,j,memo),Math.min(helper(s,t,i-1,j-1,memo),helper(s,t,i,j-1,memo)))+1;\\n}\\n```\\n\\n# Bottom Up DP\\n```\\npublic int minDistance(String s, String t) {\\n    int n = s.length();\\n    int m = t.length();\\n    int[][] memo = new int[n+1][m+1];\\n    for(int i=0;i<=n;i++) {\\n        for(int j=0;j<=m;j++) {\\n            if(i==0||j==0) {\\n                memo[i][j]=i==0?j:i;\\n            }\\n            else if(s.charAt(i-1)==t.charAt(j-1)) {\\n                memo[i][j]=memo[i-1][j-1];\\n            } else {\\n                memo[i][j]=Math.min(memo[i][j-1],Math.min(memo[i-1][j],memo[i-1][j-1]))+1;\\n            }\\n        }\\n    }\\n    return memo[n][m];\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1);\\n}\\nprivate int helper(String s,String t,int i,int j) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return helper(s,t,i-1,j-1);\\n    }\\n    return Math.min(helper(s,t,i-1,j),Math.min(helper(s,t,i-1,j-1),helper(s,t,i,j-1)))+1;\\n}\\n```\n```\\npublic int minDistance(String word1, String word2) {\\n    int n = word1.length();\\n    int m = word2.length();\\n    return helper(word1,word2,n-1,m-1,new Integer[n][m]);\\n}\\nprivate int helper(String s,String t,int i,int j,Integer[][] memo) {\\n    if(i<0) {\\n        return j+1;\\n    }\\n    if(j<0) {\\n        return i+1;\\n    }\\n    if(memo[i][j]!=null) {\\n        return memo[i][j];\\n    }\\n    if(s.charAt(i)==t.charAt(j)) {\\n        return memo[i][j]=helper(s,t,i-1,j-1,memo);\\n    }\\n    return memo[i][j]=Math.min(helper(s,t,i-1,j,memo),Math.min(helper(s,t,i-1,j-1,memo),helper(s,t,i,j-1,memo)))+1;\\n}\\n```\n```\\npublic int minDistance(String s, String t) {\\n    int n = s.length();\\n    int m = t.length();\\n    int[][] memo = new int[n+1][m+1];\\n    for(int i=0;i<=n;i++) {\\n        for(int j=0;j<=m;j++) {\\n            if(i==0||j==0) {\\n                memo[i][j]=i==0?j:i;\\n            }\\n            else if(s.charAt(i-1)==t.charAt(j-1)) {\\n                memo[i][j]=memo[i-1][j-1];\\n            } else {\\n                memo[i][j]=Math.min(memo[i][j-1],Math.min(memo[i-1][j],memo[i-1][j-1]))+1;\\n            }\\n        }\\n    }\\n    return memo[n][m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2966079,
                "title": "c-clean-and-easy-solution-dp-recursive-top-down-bottom-up-space-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string &a, string &b, int i, int j){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }\\n        if(j >= b.size()){\\n            return (a.size()-i);\\n        }\\n\\n        int ans;\\n        if(a[i] == b[j]){\\n            ans = solve(a, b, i+1, j+1);\\n        }\\n        else{\\n            int ins = 1 + solve(a, b, i, j+1);\\n            int dlt = 1 + solve(a, b, i+1, j);\\n            int rep = 1 + solve(a, b, i+1, j+1);\\n\\n            ans = min(ins, min(dlt, rep));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int solveMem(string &a, string &b, int i, int j, vector<vector<int>> &dp){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }\\n        if(j >= b.size()){\\n            return (a.size()-i);\\n        }\\n\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        int ans;\\n        if(a[i] == b[j]){\\n            ans = solveMem(a, b, i+1, j+1, dp);\\n        }\\n        else{\\n            int ins = 1 + solveMem(a, b, i, j+1, dp);\\n            int dlt = 1 + solveMem(a, b, i+1, j, dp);\\n            int rep = 1 + solveMem(a, b, i+1, j+1, dp);\\n\\n            ans = min(ins, min(dlt, rep));\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n\\n    int solveTab(string &a, string &b){\\n        vector<vector<int>> dp(a.size()+1, vector<int>(b.size()+1, 0));\\n\\n        for(int j = 0; j <= b.size(); j++){\\n            dp[a.size()][j] = b.size() - j; \\n        }\\n\\n        for(int i = 0; i <= a.size(); i++){\\n            dp[i][b.size()] = a.size() - i;\\n        }\\n\\n        for(int i = a.size()-1; i >= 0; i--){\\n            for(int j = b.size()-1; j >= 0; j--){\\n\\n                int ans;\\n                if(a[i] == b[j]){\\n                    ans = dp[i+1][j+1];\\n                }\\n                else{\\n                    int ins = 1 + dp[i][j+1];\\n                    int dlt = 1 + dp[i+1][j];\\n                    int rep = 1 + dp[i+1][j+1];\\n\\n                    ans = min(ins, min(dlt, rep));\\n                }\\n\\n                dp[i][j] = ans;\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n\\n    int solveSO(string a, string b){\\n\\n        vector<int> curr(b.size() + 1, 0);\\n        vector<int> next(b.size() + 1, 0);\\n\\n        for(int j = 0; j <= b.size(); j++){\\n            next[j] = b.size() - j;\\n        }\\n\\n        for(int i = a.size()-1; i >= 0; i--){\\n\\n            // Very Imp, This came from base case\\n            curr[b.size()] = a.size() - i;\\n\\n            for(int j = b.size()-1; j >= 0; j--){\\n\\n                int ans;\\n                if(a[i] == b[j]){\\n                    ans = next[j+1];\\n                }\\n                else{\\n                    int ins = 1 + curr[j+1];\\n                    int dlt = 1 + next[j];\\n                    int rep = 1 + next[j+1];\\n\\n                    ans = min(ins, min(dlt, rep));\\n                }\\n\\n                curr[j] = ans;\\n            }\\n\\n            next = curr;\\n        }\\n\\n        return curr[0];\\n    }\\n\\n    int minDistance(string a, string b) {\\n\\n        // vector<vector<int>> dp(a.size(), vector<int>(b.size(), -1));\\n        // return solveMem(a, b, 0, 0);\\n\\n        if(a.size() == 0) return b.size();\\n        if(b.size() == 0) return a.size();\\n\\n        return solveSO(a, b);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(string &a, string &b, int i, int j){\\n        if(i >= a.size()){\\n            return (b.size()-j);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2798723,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    string s, t;\\n\\n    int solve(int i, int j) {     \\n        if(i == s.size()) return t.size()-j;\\n        if(j == t.size()) return s.size()-i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans;\\n        if(s[i] == t[j]) ans = solve(i+1, j+1);\\n        else {\\n            int deleted = 1 + solve(i+1, j);\\n            int inserted = 1 + solve(i, j+1);\\n            int replaced = 1 + solve(i+1, j+1);\\n            ans = min({deleted, inserted, replaced});\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        memset(dp, -1, sizeof(dp));\\n        s = word1;\\n        t = word2;\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    string s, t;\\n\\n    int solve(int i, int j) {     \\n        if(i == s.size()) return t.size()-j;\\n        if(j == t.size()) return s.size()-i;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans;\\n        if(s[i] == t[j]) ans = solve(i+1, j+1);\\n        else {\\n            int deleted = 1 + solve(i+1, j);\\n            int inserted = 1 + solve(i, j+1);\\n            int replaced = 1 + solve(i+1, j+1);\\n            ans = min({deleted, inserted, replaced});\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        memset(dp, -1, sizeof(dp));\\n        s = word1;\\n        t = word2;\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793686,
                "title": "linear-python-solution-top-down-and-bottom-up",
                "content": "# Intuition\\nStep 1: Express the problem in terms of indexes.\\nStep 2: Explore all possibilities at a given index\\nStep 3: Return the minimum of the choices\\n\\n\\n# Approach\\n\\nAs we see there are overlapping subproblems in the recursive tree, \\n1.\\tCreate a dp array of size [N][M] where N and M are lengths of S1 and S2    respectively.\\n2.\\tWe initialize the dp array to -1.\\n3.\\tWhenever we want to find the answer of particular parameters (say f(ind1, ind2)), we first check whether the answer is  already calculated using the dp array (i.e. dp[ind][ind2]!= -1 ). If yes, simply return the value from the dp array\\n4.\\tIf not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][ind2] to the solution we get.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n\\n- Space complexity: O(n*M)\\n\\n\\n**Dp( Tabulation)**\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[-1]*(l1+1) for i in range(l2+1)]\\n        for i in range(l1+1):\\n            (dp[0])[i]=i\\n        for i in range(l2+1):\\n            (dp[i])[0]=i\\n\\n        for j in range(1,l2+1):\\n            for i in range(1,l1+1):\\n                if word1[i-1]==word2[j-1]:\\n                    (dp[j])[i]=(dp[j-1])[i-1]\\n                else:\\n                    insert=(dp[j-1])[i]\\n                    delete=(dp[j])[i-1]\\n                    replace=(dp[j-1])[i-1]\\n                    (dp[j])[i]=1+ min(insert,delete,replace)\\n                    \\n  \\n  \\n\\n\\n        return (dp[l2])[l1]\\n        \\n\\n\\n\\n\\n```\\n# Dp Memoization  Method\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def fun(word1,word2,i,j,dp):\\n            if i<0:\\n                return j+1\\n            if j<0:\\n                return i+1\\n            if (dp[j])[i]!=-1:\\n                return (dp[j])[i]\\n            elif word1[i]==word2[j]:\\n\\n                (dp[j])[i]=fun(word1,word2,i-1,j-1,dp)\\n                return (dp[j])[i]\\n            insert=fun(word1,word2,i,j-1,dp)\\n            delete=fun(word1,word2,i-1,j,dp)\\n            replace=fun(word1,word2,i-1,j-1,dp)\\n            (dp[j])[i]=1+ min(insert,delete,replace)\\n            return (dp[j])[i]\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        l1=len(word1)\\n        l2=len(word2)\\n        dp=[[-1]*(l1+1) for i in range(l2+1)]\\n        for i in range(l1+1):\\n            (dp[0])[i]=i\\n        for i in range(l2+1):\\n            (dp[i])[0]=i\\n\\n        for j in range(1,l2+1):\\n            for i in range(1,l1+1):\\n                if word1[i-1]==word2[j-1]:\\n                    (dp[j])[i]=(dp[j-1])[i-1]\\n                else:\\n                    insert=(dp[j-1])[i]\\n                    delete=(dp[j])[i-1]\\n                    replace=(dp[j-1])[i-1]\\n                    (dp[j])[i]=1+ min(insert,delete,replace)\\n                    \\n  \\n  \\n\\n\\n        return (dp[l2])[l1]\\n        \\n\\n\\n\\n\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        def fun(word1,word2,i,j,dp):\\n            if i<0:\\n                return j+1\\n            if j<0:\\n                return i+1\\n            if (dp[j])[i]!=-1:\\n                return (dp[j])[i]\\n            elif word1[i]==word2[j]:\\n\\n                (dp[j])[i]=fun(word1,word2,i-1,j-1,dp)\\n                return (dp[j])[i]\\n            insert=fun(word1,word2,i,j-1,dp)\\n            delete=fun(word1,word2,i-1,j,dp)\\n            replace=fun(word1,word2,i-1,j-1,dp)\\n            (dp[j])[i]=1+ min(insert,delete,replace)\\n            return (dp[j])[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769402,
                "title": "java-solutions",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        int l1 = word1.length();\\n        int l2 = word2.length();\\n        int[][] dp = new int[l1+1][l2+1];\\n        \\n        // Base cases\\n        // Initializing First row\\n        for(int i=0; i <= l2; i++)\\n            dp[0][i] = i;        \\n        // Initializing First col\\n        for(int i=0; i <= l1; i++)\\n            dp[i][0] = i;\\n        \\n        for(int i=1; i <= l1; i++){\\n            for(int j=1; j <= l2; j++){\\n                if(word1.charAt(i-1) == word2.charAt(j-1))\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], // replace\\n                                            Math.min(dp[i-1][j], // delete\\n                                                     dp[i][j-1]) // insert\\n                                           ); \\n            }\\n        }\\n        \\n        return dp[l1][l2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766502,
                "title": "i-tried-to-give-a-proper-explaination-of-both-dp-and-recursive-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string s1,string s2,int m,int n,vector<vector<int>> & dp){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n\\t\\t\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\t\\t\\n        if(s1[m-1]==s2[n-1])\\n            return dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n\\t\\t\\t\\n        if(s1[m-1]!=s2[n-1]){ \\n            dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n            dp[m][n-1]=solve(s1,s2,m,n-1,dp);\\n            dp[m-1][n]=solve(s1,s2,m-1,n,dp);\\n            return 1+min(dp[m-1][n],min(dp[m-1][n-1],dp[m][n-1]));}\\n\\t\\t\\t\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n         vector<vector<int>> vec(word1.size() +1 , vector<int> (word2.size()+1, -1));\\n        return solve(word1,word2,word1.size(),word2.size(),vec);\\n    }\\n};\\n\\n\\nclass Solution1 {//Recursive solution TLE\\npublic:\\n    int solve(string s1,string s2,int m,int n){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n        if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);\\n        if(s1[m-1]!=s2[n-1]) return 1+min(solve(s1,s2,m-1,n),min(solve(s1,s2,m-1,n-1),solve(s1,s2,m,n-1)));\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        return solve(word1,word2,word1.size(),word2.size());\\n    }\\n};\\n```\\n\\n\\nA.) So to understand this solution you gotta know the recursive solution of this so lets see some cases here :\\n1.  what if we have any of the strings empty what would be the number of operation here obviously that would be      length of the other non empty array yepp it would be :                                                                                                                                                                       ` if(m==0) return n;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  if(n==0) return m;`\\n2. well now case 2 what if both of the last charectors are same obviously it would require no operations so yeah we move to the next charectors of the string without any count to the charectors : \\n                                              ` if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);`\\n3. now now lets see the three operation : \\n\\t\\t\\t\\t\\t\\t\\tlets take first operation that would be delete :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"execun\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would delete that g so you would move to the                                                                                               left by one in 1st word : solve(s1,s2,m-1,n)\\n\\t\\t\\t\\t\\t\\t\\tlets take second operation that would be replace :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"execg\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would replace that g so you would move to the                                                                                             left by one in 1st word  and 2nd word: solve(s1,s2,m-1,n)\\n\\t\\t\\t\\t\\t\\t\\tlets take second operation that would be insert :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\twhat if the 2 strings are : \"exec\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\"execu\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tyeah you would replace that g so you would move to the                                                                                             left by one in 1st word  and 2nd word: solve(s1,s2,m-1,n-1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t    now that min is there cuz obviously we need to return that min operation value (just think it as the                           division of to sub problems )\\n\\t\\t\\t\\t\\t\\t\\nB.) and that code with dp vector we actually used that one to reduce the number of recursive calll\\nnote -  sorry if couldnt explain it that well any suggestions from you guys are really appreciable Thankyou!\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string s1,string s2,int m,int n,vector<vector<int>> & dp){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n\\t\\t\\n        if(dp[m][n]!=-1) return dp[m][n];\\n\\t\\t\\n        if(s1[m-1]==s2[n-1])\\n            return dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n\\t\\t\\t\\n        if(s1[m-1]!=s2[n-1]){ \\n            dp[m-1][n-1]=solve(s1,s2,m-1,n-1,dp);\\n            dp[m][n-1]=solve(s1,s2,m,n-1,dp);\\n            dp[m-1][n]=solve(s1,s2,m-1,n,dp);\\n            return 1+min(dp[m-1][n],min(dp[m-1][n-1],dp[m][n-1]));}\\n\\t\\t\\t\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n         vector<vector<int>> vec(word1.size() +1 , vector<int> (word2.size()+1, -1));\\n        return solve(word1,word2,word1.size(),word2.size(),vec);\\n    }\\n};\\n\\n\\nclass Solution1 {//Recursive solution TLE\\npublic:\\n    int solve(string s1,string s2,int m,int n){\\n        if(m==0) return n;\\n        if(n==0) return m;\\n        if(s1[m-1]==s2[n-1]) return solve(s1,s2,m-1,n-1);\\n        if(s1[m-1]!=s2[n-1]) return 1+min(solve(s1,s2,m-1,n),min(solve(s1,s2,m-1,n-1),solve(s1,s2,m,n-1)));\\n        return 0;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        return solve(word1,word2,word1.size(),word2.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721083,
                "title": "o-n-space-dp-100-working-c-striver",
                "content": "These were the mistake done by mean while coding and I was trying to compare it with longest common subsequence \\uD83E\\uDD79. It take my lot of time.\\nEdit Distance\\n\\n*     1. no idea of basic case \\n         recursion code of 0 based indexing\\n*     2. if(i < 0 or j < 0) <- 0 => if(i < 0) <- j+1 , if(j < 0) <- i+1\\n*     3. <- 1 + common(i-1,j-1,s1,s2), min(common(i-1,j,s1,s2),common(i,j-1,s1,s2)) => min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) })\\n         recursion code of 1 based indexing\\n*     4. base conditon\\n         if(i == 0) <- j+1 , if(j == 0) <- i+1 => if(i == 0) <- j , if(j == 0) <- i\\n*     5. writing base condtion of optimize \\n          curr[0] = 1 => curr[0] = i;\\n\\n**Brute 0 Index : TLE**\\n\\n```\\n    // brute 0 index : TLE\\n        class Solution {\\n        public:\\n            int common(int i,int j,string &s1,string &s2){\\n                if(i < 0) return j+1;  // \\u2B50\\n                if(j < 0) return i+1;  // \\u2B50\\n                \\n                if(s1[i] == s2[j])\\n                    return 0 + common(i-1,j-1,s1,s2);  // \\u2B50\\n                else return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) }); // \\u2B50\\n                        //              delete              insert                        replace\\n            }\\n            int minDistance(string s1, string s2) {\\n                int n = s1.size(),m = s2.size();\\n                return common(n-1,m-1,s1,s2);\\n            }\\n        };\\n```\\n    \\n**Brute 1 Index : TLE**\\n\\n```\\n// brute 1 indexing : TLE\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2){\\n\\t\\t\\tif(i == 0) return j;  // \\u2B50\\n\\t\\t\\tif(j == 0) return i;  // \\u2B50\\n\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn 0 + common(i-1,j-1,s1,s2);\\n\\t\\t\\telse return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) });\\n\\t\\t\\t\\t\\t//              delete              insert                        replace\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\treturn common(n,m,s1,s2);\\n\\t\\t}\\n\\t};\\n```\\n\\n**Memorization**\\n\\n```\\n// memo\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == 0) return j;\\n\\t\\t\\tif(j == 0) return i;\\n\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn dp[i][j] = 0 + common(i-1,j-1,s1,s2,dp);\\n\\t\\t\\telse return dp[i][j] = min({ 1 + common(i-1,j,s1,s2,dp) , 1 + common(i,j-1,s1,s2,dp) , 1 + common(i-1,j-1,s1,s2,dp) });\\n\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n\\t\\t\\treturn common(n,m,s1,s2,dp);\\n\\t\\t}\\n\\t};\\n```\\n\\n**Tabulation**\\n\\n```\\n// tab\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n\\n\\t\\t\\tfor(int i=0;i<=n;i++) dp[i][0] = i;\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[0][j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min({1 + dp[i-1][j],1 + dp[i][j-1], 1 + dp[i-1][j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[n][m];\\n\\t\\t}\\n\\t};\\n```\\n\\n**Optimize**\\n\\n```\\n// optimize\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<int> dp(m+1,0),curr(m+1,0);\\n\\n\\t\\t\\t// curr[0] = 1; \\u2B50\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tcurr[0] = i; // \\u2B50\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tcurr[j] = dp[j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcurr[j] = min({1 + dp[j],1 + curr[j-1], 1 + dp[j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp = curr;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[m];\\n\\t\\t}\\n\\t};\\n```\\n\\nHappy coding , please do upvote this post.\\n![image](https://assets.leetcode.com/users/images/749bbd83-b0bc-4cc8-8e29-916a9e8b4478_1666164359.9013052.gif)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    // brute 0 index : TLE\\n        class Solution {\\n        public:\\n            int common(int i,int j,string &s1,string &s2){\\n                if(i < 0) return j+1;  // \\u2B50\\n                if(j < 0) return i+1;  // \\u2B50\\n                \\n                if(s1[i] == s2[j])\\n                    return 0 + common(i-1,j-1,s1,s2);  // \\u2B50\\n                else return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) }); // \\u2B50\\n                        //              delete              insert                        replace\\n            }\\n            int minDistance(string s1, string s2) {\\n                int n = s1.size(),m = s2.size();\\n                return common(n-1,m-1,s1,s2);\\n            }\\n        };\\n```\n```\\n// brute 1 indexing : TLE\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2){\\n\\t\\t\\tif(i == 0) return j;  // \\u2B50\\n\\t\\t\\tif(j == 0) return i;  // \\u2B50\\n\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn 0 + common(i-1,j-1,s1,s2);\\n\\t\\t\\telse return min({ 1 + common(i-1,j,s1,s2) , 1 + common(i,j-1,s1,s2) , 1 + common(i-1,j-1,s1,s2) });\\n\\t\\t\\t\\t\\t//              delete              insert                        replace\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\treturn common(n,m,s1,s2);\\n\\t\\t}\\n\\t};\\n```\n```\\n// memo\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint common(int i,int j,string &s1,string &s2,vector<vector<int>> &dp){\\n\\t\\t\\tif(i == 0) return j;\\n\\t\\t\\tif(j == 0) return i;\\n\\n\\t\\t\\tif(dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\treturn dp[i][j] = 0 + common(i-1,j-1,s1,s2,dp);\\n\\t\\t\\telse return dp[i][j] = min({ 1 + common(i-1,j,s1,s2,dp) , 1 + common(i,j-1,s1,s2,dp) , 1 + common(i-1,j-1,s1,s2,dp) });\\n\\n\\t\\t}\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n\\t\\t\\treturn common(n,m,s1,s2,dp);\\n\\t\\t}\\n\\t};\\n```\n```\\n// tab\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int> (m+1,0));\\n\\n\\t\\t\\tfor(int i=0;i<=n;i++) dp[i][0] = i;\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[0][j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tdp[i][j] = min({1 + dp[i-1][j],1 + dp[i][j-1], 1 + dp[i-1][j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[n][m];\\n\\t\\t}\\n\\t};\\n```\n```\\n// optimize\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minDistance(string s1, string s2) {\\n\\t\\t\\tint n = s1.size(),m = s2.size();\\n\\t\\t\\tvector<int> dp(m+1,0),curr(m+1,0);\\n\\n\\t\\t\\t// curr[0] = 1; \\u2B50\\n\\t\\t\\tfor(int j=0;j<=m;j++) dp[j] = j;\\n\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tcurr[0] = i; // \\u2B50\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(s1[i-1] == s2[j-1])\\n\\t\\t\\t\\t\\t\\tcurr[j] = dp[j-1];\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tcurr[j] = min({1 + dp[j],1 + curr[j-1], 1 + dp[j-1]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp = curr;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn dp[m];\\n\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469726,
                "title": "striver-code-python-solution-easy-explained",
                "content": "```\\n# Recursive \\nclass Solution:\\n    def f(self,i,j,s,t):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if s[i]==t[j]:\\n            return 0 + self.f(i-1,j-1,s,t)\\n        else:\\n            return min((1+self.f(i-1,j,s,t)),(1+self.f(i,j-1,s,t)),(1+self.f(i-1,j-1,s,t)))\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        return self.f(m-1,n-1,word1,word2)\\n\\n     \\n#Memoisation \\n\\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i]==t[j]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n)]for j in range(m)]\\n        return self.f(m-1,n-1,word1,word2,dp)\\n      \\n                         OR \\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i-1]==t[j-1]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n+1)]for j in range(m+1)]\\n        return self.f(m,n,word1,word2,dp)\\n      \\n      \\n# Tabulation :\\n\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0 for i in range(n+1)]for j in range(m+1)]\\n        \\n        for j in range(n+1):\\n            dp[0][j]=j\\n        for i in range(m+1):\\n            dp[i][0]=i\\n        \\n            \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]= 0 + dp[i-1][j-1]\\n                else:\\n                    dp[i][j]= 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])\\n        return dp[m][n]\\n\\n# Space Optimised :\\ndef editDistance(word1, word2) :\\n        m=len(word1)\\n        n=len(word2)\\n        prev=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr=[0]*(n+1)\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    curr[j]=prev[j-1]\\n                else:\\n                    curr[j]= 1 + min(prev[j],min(curr[j-1],prev[j-1]))\\n            prev=curr\\n        return curr[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Combinatorics"
                ],
                "code": "```\\n# Recursive \\nclass Solution:\\n    def f(self,i,j,s,t):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if s[i]==t[j]:\\n            return 0 + self.f(i-1,j-1,s,t)\\n        else:\\n            return min((1+self.f(i-1,j,s,t)),(1+self.f(i,j-1,s,t)),(1+self.f(i-1,j-1,s,t)))\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        return self.f(m-1,n-1,word1,word2)\\n\\n     \\n#Memoisation \\n\\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i<0:\\n            return j+1\\n        if j<0:\\n            return i+1\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i]==t[j]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n)]for j in range(m)]\\n        return self.f(m-1,n-1,word1,word2,dp)\\n      \\n                         OR \\nclass Solution:\\n    def f(self,i,j,s,t,dp):\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if dp[i][j]!=-1:\\n            return dp[i][j]\\n        if s[i-1]==t[j-1]:\\n            dp[i][j]= 0 + self.f(i-1,j-1,s,t,dp)\\n        else:\\n            dp[i][j]= min((1+self.f(i-1,j,s,t,dp)),(1+self.f(i,j-1,s,t,dp)),(1+self.f(i-1,j-1,s,t,dp)))\\n        return dp[i][j]\\n        \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[-1 for i in range(n+1)]for j in range(m+1)]\\n        return self.f(m,n,word1,word2,dp)\\n      \\n      \\n# Tabulation :\\n\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0 for i in range(n+1)]for j in range(m+1)]\\n        \\n        for j in range(n+1):\\n            dp[0][j]=j\\n        for i in range(m+1):\\n            dp[i][0]=i\\n        \\n            \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]= 0 + dp[i-1][j-1]\\n                else:\\n                    dp[i][j]= 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])\\n        return dp[m][n]\\n\\n# Space Optimised :\\ndef editDistance(word1, word2) :\\n        m=len(word1)\\n        n=len(word2)\\n        prev=[0]*(n+1)\\n        for j in range(n+1):\\n            prev[j]=j\\n        for i in range(1,m+1):\\n            curr=[0]*(n+1)\\n            curr[0]=i\\n            for j in range(1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    curr[j]=prev[j-1]\\n                else:\\n                    curr[j]= 1 + min(prev[j],min(curr[j-1],prev[j-1]))\\n            prev=curr\\n        return curr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448115,
                "title": "easy-c-recursion-memoization-tabulation-space-optimization",
                "content": "Recursion : (gives TLE)\\nTC: Exponential\\nSC : O(n+m) ; where n = length of str1 and m=length of str2\\n\\nMemoization code: \\n```\\nclass Solution {\\npublic:\\n    int func(int i, int j, string s, string t, vector<vector<int>> &dp){\\n        //base cases\\n        if(i<0){\\n            //str1 exhausted\\n            return j+1;\\n        }\\n        if(j<0){\\n            //str2 exhausted\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(s[i]==t[j]){\\n            //if string chars match, do nothing, just shrink strings and continue checking\\n            return dp[i][j]=0+func(i-1, j-1, s, t, dp);\\n        }\\n        else{\\n            //if there\\'s no string matching\\n            //we can perform 3 operations -> insert, delete, replace\\n            int ins=1+func(i, j-1, s, t, dp);\\n            int del=1+func(i-1, j, s, t, dp);\\n            int repl=1+func(i-1, j-1, s, t, dp);\\n            return dp[i][j]=min(ins, min(del, repl));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        return func(n-1, m-1, word1, word2, dp);\\n    }\\n};\\n```\\nTC : O(n * m)\\nSC : O(n+m) + O(n * m) \\n\\nTo avoid the Auxiliary Stack Space(ASS), we further perform tabulation.\\n\\nTabulation code :\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (m+1, 0));\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0; j<=m; j++){\\n            dp[0][j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    dp[i][j] = 0+dp[i-1][j-1];\\n                }\\n                else {\\n                    int ins=1+dp[i][j-1];\\n                    int del=1+dp[i-1][j];\\n                    int repl=1+dp[i-1][j-1];\\n                    dp[i][j] = min(ins, min(del, repl));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\nTC : O(n * m)\\nSC : O(n * m) [eliminated extra auxiliary stack space]\\n\\nTo eliminate this extra auxiliary space, we carry out space optimization.\\n\\nSpace Optimization code :\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<int> prev(m+1, 0), curr(m+1, 0);\\n        \\n        for(int j=0; j<=m; j++){\\n            prev[j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            curr[0]=i;\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    curr[j] = 0+prev[j-1];\\n                }\\n                else {\\n                    int ins=1+curr[j-1];\\n                    int del=1+prev[j];\\n                    int repl=1+prev[j-1];\\n                    curr[j] = min(ins, min(del, repl));\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```\\nTC : O(n * m) [2 nested for loops]\\nSC : O(m)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int i, int j, string s, string t, vector<vector<int>> &dp){\\n        //base cases\\n        if(i<0){\\n            //str1 exhausted\\n            return j+1;\\n        }\\n        if(j<0){\\n            //str2 exhausted\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(s[i]==t[j]){\\n            //if string chars match, do nothing, just shrink strings and continue checking\\n            return dp[i][j]=0+func(i-1, j-1, s, t, dp);\\n        }\\n        else{\\n            //if there\\'s no string matching\\n            //we can perform 3 operations -> insert, delete, replace\\n            int ins=1+func(i, j-1, s, t, dp);\\n            int del=1+func(i-1, j, s, t, dp);\\n            int repl=1+func(i-1, j-1, s, t, dp);\\n            return dp[i][j]=min(ins, min(del, repl));\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        return func(n-1, m-1, word1, word2, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<vector<int>> dp(n+1, vector<int> (m+1, 0));\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0; j<=m; j++){\\n            dp[0][j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    dp[i][j] = 0+dp[i-1][j-1];\\n                }\\n                else {\\n                    int ins=1+dp[i][j-1];\\n                    int del=1+dp[i-1][j];\\n                    int repl=1+dp[i-1][j-1];\\n                    dp[i][j] = min(ins, min(del, repl));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string &s, string &t) {\\n        int n=s.length();\\n        int m=t.length();\\n        \\n        vector<int> prev(m+1, 0), curr(m+1, 0);\\n        \\n        for(int j=0; j<=m; j++){\\n            prev[j]=j;\\n        }\\n        \\n        for(int i=1; i<n+1; i++){\\n            curr[0]=i;\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1]==t[j-1]){\\n                    curr[j] = 0+prev[j-1];\\n                }\\n                else {\\n                    int ins=1+curr[j-1];\\n                    int del=1+prev[j];\\n                    int repl=1+prev[j-1];\\n                    curr[j] = min(ins, min(del, repl));\\n                }\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420042,
                "title": "c-memoization-tabulation",
                "content": "**Memoization**\\n```\\nint memoization(string& s,string& d,int sin,\\n                   int din,vector<vector<int>>& memory)\\n    {\\n        if(din==0)\\n            return sin;\\n        if(sin==0)\\n            return din;\\n        if(memory[sin][din]!=-1)\\n            return memory[sin][din];\\n        if(s[sin-1]==d[din-1])\\n            return memory[sin][din]=\\n            memoization(s,d,sin-1,din-1,memory);\\n        return memory[sin][din]=\\n            1+min(memoization(s,d,sin-1,din,memory),\\n                  min(\\n                 memoization(s,d,sin-1,din-1,memory),\\n                 memoization(s,d,sin,din-1,memory)));\\n    }\\n```\\n**Tabulation**\\n```\\n int tabulation(string& s,string& d,\\n                   vector<vector<int>>& dp)\\n    {\\n        int sin=s.length(),din=d.length();\\n        for(int i=0;i<=sin;i++)\\n            dp[i][0]=i;\\n        for(int j=0;j<=din;j++)\\n            dp[0][j]=j;\\n        for(int i=1;i<=sin;i++)\\n            for(int j=1;j<=din;j++)\\n            {\\n                if(s[i-1]==d[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else\\n                    dp[i][j]=1+min(dp[i-1][j-1],\\n                                  min(dp[i][j-1],\\n                                     dp[i-1][j]));\\n            }\\n        return dp[sin][din];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint memoization(string& s,string& d,int sin,\\n                   int din,vector<vector<int>>& memory)\\n    {\\n        if(din==0)\\n            return sin;\\n        if(sin==0)\\n            return din;\\n        if(memory[sin][din]!=-1)\\n            return memory[sin][din];\\n        if(s[sin-1]==d[din-1])\\n            return memory[sin][din]=\\n            memoization(s,d,sin-1,din-1,memory);\\n        return memory[sin][din]=\\n            1+min(memoization(s,d,sin-1,din,memory),\\n                  min(\\n                 memoization(s,d,sin-1,din-1,memory),\\n                 memoization(s,d,sin,din-1,memory)));\\n    }\\n```\n```\\n int tabulation(string& s,string& d,\\n                   vector<vector<int>>& dp)\\n    {\\n        int sin=s.length(),din=d.length();\\n        for(int i=0;i<=sin;i++)\\n            dp[i][0]=i;\\n        for(int j=0;j<=din;j++)\\n            dp[0][j]=j;\\n        for(int i=1;i<=sin;i++)\\n            for(int j=1;j<=din;j++)\\n            {\\n                if(s[i-1]==d[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else\\n                    dp[i][j]=1+min(dp[i-1][j-1],\\n                                  min(dp[i][j-1],\\n                                     dp[i-1][j]));\\n            }\\n        return dp[sin][din];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2350419,
                "title": "cpp-dp-memorization-inline-comments-simple",
                "content": "Please upvote if you understood !\\n\\n\\tint count(string &word1,string &word2,int i,int j,vector<vector<int>> &dp){\\n\\t\\t// if second string exhausted , return length of first string as min number of operatons.\\n        if(j<0) return i+1;\\n\\t\\t// if first string exhausted , return length of second string as min number of operatons.\\n        if(i<0) return j+1;\\n        \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        \\n\\t\\t// if match found of characters just shift to previous index.\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=count(word1,word2,i-1,j-1,dp);\\n        }\\n        else{\\n\\t\\t\\t// insert operation\\n            int insert=1+count(word1,word2,i,j-1,dp);\\n\\t\\t\\t// delete operation\\n            int del=1+count(word1,word2,i-1,j,dp);\\n\\t\\t\\t// replace operation\\n            int replace=1+count(word1,word2,i-1,j-1,dp);\\n\\t\\t\\t// return minimum of the three operations.\\n            return dp[i][j]=min(insert,min(del,replace));\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n\\t\\t// start from end of strings\\n        return count(word1,word2,n-1,m-1,dp);\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "Please upvote if you understood !\\n\\n\\tint count(string &word1,string &word2,int i,int j,vector<vector<int>> &dp){\\n\\t\\t// if second string exhausted , return length of first string as min number of operatons.\\n        if(j<0) return i+1;\\n\\t\\t// if first string exhausted , return length of second string as min number of operatons.\\n        if(i<0) return j+1;\\n        \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        \\n\\t\\t// if match found of characters just shift to previous index.\\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=count(word1,word2,i-1,j-1,dp);\\n        }\\n        else{\\n\\t\\t\\t// insert operation\\n            int insert=1+count(word1,word2,i,j-1,dp);\\n\\t\\t\\t// delete operation\\n            int del=1+count(word1,word2,i-1,j,dp);\\n\\t\\t\\t// replace operation\\n            int replace=1+count(word1,word2,i-1,j-1,dp);\\n\\t\\t\\t// return minimum of the three operations.\\n            return dp[i][j]=min(insert,min(del,replace));\\n        }\\n    }\\n    \\n    int minDistance(string word1, string word2) {\\n        int n=word1.length();\\n        int m=word2.length();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n\\t\\t// start from end of strings\\n        return count(word1,word2,n-1,m-1,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2227245,
                "title": "c-dp-with-memoization-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        /* dp formulation\\n         *\\n         * dp[i][j] shall represent the minimum number of edits\\n         * required to get word1[:i] to match word2[:j].\\n         *\\n         * propagation:\\n         * if word1[i-1] == word2[j-1] then no extra edits are necessary,\\n         *     then dp[i][j] = dp[i-1][j-1]\\n         *\\n         * otherwise,\\n         * dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n         *               ,dp[i][j-1] + 1 // insertion\\n         *               ,dp[i-1][j] + 1 // deletion\\n         *               )\\n         */\\n        int m = word1.size(); int n = word2.size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        for (int i = 0; i <= m; i++)\\n        {\\n            for (int j = 0; j <= n; j++)\\n            {\\n                if (i == 0)\\n                {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0)\\n                {\\n                    dp[i][j] = i;\\n                }\\n                else\\n                {\\n                    if (word1[i-1] == word2[j-1])\\n                    {\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n                                      ,min(dp[i][j-1] + 1 // insertion\\n                                          ,dp[i-1][j] + 1 // deletion\\n                                          )\\n                                      );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        /* dp formulation\\n         *\\n         * dp[i][j] shall represent the minimum number of edits\\n         * required to get word1[:i] to match word2[:j].\\n         *\\n         * propagation:\\n         * if word1[i-1] == word2[j-1] then no extra edits are necessary,\\n         *     then dp[i][j] = dp[i-1][j-1]\\n         *\\n         * otherwise,\\n         * dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n         *               ,dp[i][j-1] + 1 // insertion\\n         *               ,dp[i-1][j] + 1 // deletion\\n         *               )\\n         */\\n        int m = word1.size(); int n = word2.size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        for (int i = 0; i <= m; i++)\\n        {\\n            for (int j = 0; j <= n; j++)\\n            {\\n                if (i == 0)\\n                {\\n                    dp[i][j] = j;\\n                }\\n                else if (j == 0)\\n                {\\n                    dp[i][j] = i;\\n                }\\n                else\\n                {\\n                    if (word1[i-1] == word2[j-1])\\n                    {\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = min(dp[i-1][j-1] + 1 // replacement\\n                                      ,min(dp[i][j-1] + 1 // insertion\\n                                          ,dp[i-1][j] + 1 // deletion\\n                                          )\\n                                      );\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp.back().back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223204,
                "title": "top-down-bottom-up-and-optimized-dynamic-programming",
                "content": "We can either inesrt, delete or replace a character in word1.\\n\\nOur goal is to get to word2 in minimum moves.\\n\\nWe don\\'t have to actually perform this operations, but logically trace the result by manipulating the pointers. Let\\'s have a pointer starting at 0 for word1, and starting at 0 for word2 (for bottom-up, it will be in reverse)\\n\\n* Replace - to replace we move both points and add 1\\n* Delete - to delete we move word1_pointer and don\\'t touch word2_pointer\\n* Insert - we move word2_pointer and don\\'t touch word1_pointer\\n\\nReturn the minimum out of these 3 options to solve each sub-problem.\\n\\n# Top-down memoized\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.find_distance(word1, 0, word2, 0, {})\\n\\n    def find_distance(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        if word1_pointer == len(word1) and word2_pointer == len(word2):\\n            return 0\\n        \\n        if word1_pointer == len(word1) or word2_pointer == len(word2):\\n            return max(len(word1) - word1_pointer, len(word2) - word2_pointer)\\n        \\n        key = (word1_pointer, word2_pointer)\\n        if key in memo: return memo[key]\\n        \\n        word1_len = len(word1) - word1_pointer\\n        word2_len = len(word2) - word2_pointer\\n        \\n        if word1[word1_pointer] == word2[word2_pointer]:\\n            memo[key] = self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo)\\n        else:\\n            memo[key] =  1 + self.make_move(word1, word1_pointer, word2, word2_pointer, memo)\\n            \\n        return memo[key]\\n    \\n    \\n    def make_move(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        return min(\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo), # update\\n                self.find_distance(word1, word1_pointer, word2, word2_pointer + 1, memo), # insert\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer, memo) # delete\\n            )\\n        \\n        \\n```\\n\\n\\n# Bottom-up DP\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        dp = [[0 for _ in range(word1_len + 1)] for _ in range(word2_len + 1)]\\n        \\n        # Base cases\\n        \\n        # When no words = 0 moves needed\\n        dp[word2_len][word1_len] = 0\\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        for r in range(word2_len - 1, -1, -1):\\n            dp[r][word1_len] = word2_len - r\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            dp[word2_len][c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    dp[word2_p][word1_p] = dp[word2_p+1][word1_p+1]\\n                else:\\n                    dp[word2_p][word1_p] = 1 + min(\\n                        dp[word2_p][word1_p+1], # delete\\n                        dp[word2_p+1][word1_p], # insert\\n                        dp[word2_p+1][word1_p+1] # replace\\n                    )\\n\\n        return dp[0][0]\\n```\\n\\n\\n# Optimized DP\\nSince we only need the last row in each iteration, we can trim to O(n) space complexity by only saving the last row result.\\n\\n\\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        last_row = [0] * (word1_len+1)\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            last_row[c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            cur_row = [0] * (word1_len+1)\\n            cur_row[word1_len] = word2_len - word2_p\\n            \\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    cur_row[word1_p] = last_row[word1_p+1]\\n                else:\\n                    cur_row[word1_p] = 1 + min(\\n                        cur_row[word1_p+1], # delete\\n                        last_row[word1_p], # insert\\n                        last_row[word1_p+1] # replace\\n                    )\\n            \\n            last_row = cur_row\\n\\n        return last_row[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.find_distance(word1, 0, word2, 0, {})\\n\\n    def find_distance(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        if word1_pointer == len(word1) and word2_pointer == len(word2):\\n            return 0\\n        \\n        if word1_pointer == len(word1) or word2_pointer == len(word2):\\n            return max(len(word1) - word1_pointer, len(word2) - word2_pointer)\\n        \\n        key = (word1_pointer, word2_pointer)\\n        if key in memo: return memo[key]\\n        \\n        word1_len = len(word1) - word1_pointer\\n        word2_len = len(word2) - word2_pointer\\n        \\n        if word1[word1_pointer] == word2[word2_pointer]:\\n            memo[key] = self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo)\\n        else:\\n            memo[key] =  1 + self.make_move(word1, word1_pointer, word2, word2_pointer, memo)\\n            \\n        return memo[key]\\n    \\n    \\n    def make_move(self, word1, word1_pointer, word2, word2_pointer, memo):\\n        return min(\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer + 1, memo), # update\\n                self.find_distance(word1, word1_pointer, word2, word2_pointer + 1, memo), # insert\\n                self.find_distance(word1, word1_pointer + 1, word2, word2_pointer, memo) # delete\\n            )\\n        \\n        \\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        dp = [[0 for _ in range(word1_len + 1)] for _ in range(word2_len + 1)]\\n        \\n        # Base cases\\n        \\n        # When no words = 0 moves needed\\n        dp[word2_len][word1_len] = 0\\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        for r in range(word2_len - 1, -1, -1):\\n            dp[r][word1_len] = word2_len - r\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            dp[word2_len][c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    dp[word2_p][word1_p] = dp[word2_p+1][word1_p+1]\\n                else:\\n                    dp[word2_p][word1_p] = 1 + min(\\n                        dp[word2_p][word1_p+1], # delete\\n                        dp[word2_p+1][word1_p], # insert\\n                        dp[word2_p+1][word1_p+1] # replace\\n                    )\\n\\n        return dp[0][0]\\n```\n```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        word1_len = len(word1)\\n        word2_len = len(word2)\\n        \\n        \\n        # When one of the strings is missing. the other one\\'s length is required (either delete or insert)\\n        last_row = [0] * (word1_len+1)\\n            \\n        for c in range(word1_len - 1, -1, -1):\\n            last_row[c] = word1_len - c\\n        \\n        # Transitions\\n        for word2_p in range(word2_len - 1, -1, -1):\\n            cur_row = [0] * (word1_len+1)\\n            cur_row[word1_len] = word2_len - word2_p\\n            \\n            for word1_p in range(word1_len -1, -1, -1):\\n                if word1[word1_p] == word2[word2_p]:\\n                    cur_row[word1_p] = last_row[word1_p+1]\\n                else:\\n                    cur_row[word1_p] = 1 + min(\\n                        cur_row[word1_p+1], # delete\\n                        last_row[word1_p], # insert\\n                        last_row[word1_p+1] # replace\\n                    )\\n            \\n            last_row = cur_row\\n\\n        return last_row[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179297,
                "title": "recursive-memoized-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        return helper(word1, word2, m, n, dp);\\n    }\\n    int helper(string word1, string word2, int m, int n, vector<vector<int>> &dp) {\\n        if (m == 0) {\\n            return n; // need to remove n characters from word2\\n        }\\n        if (n == 0) {\\n            return m; // need to add m characters to word1\\n        }\\n        if (dp[m][n] != -1) {\\n            return dp[m][n]; // memoization\\n        }\\n        if (word1[m-1] == word2[n-1]) { // same character so do nothing\\n            return dp[m][n] = helper(word1, word2, m-1, n-1, dp);\\n        }\\n        // check min value from all cases\\n        int ans = INT_MAX;\\n        ans = min(ans, helper(word1, word2, m-1, n-1, dp)); // replace\\n        ans = min(ans, helper(word1, word2, m-1, n, dp)); // delete \\n        ans = min(ans, helper(word1, word2, m, n-1, dp)); // addition\\n        return dp[m][n] = 1 + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.length();\\n        int n = word2.length();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        return helper(word1, word2, m, n, dp);\\n    }\\n    int helper(string word1, string word2, int m, int n, vector<vector<int>> &dp) {\\n        if (m == 0) {\\n            return n; // need to remove n characters from word2\\n        }\\n        if (n == 0) {\\n            return m; // need to add m characters to word1\\n        }\\n        if (dp[m][n] != -1) {\\n            return dp[m][n]; // memoization\\n        }\\n        if (word1[m-1] == word2[n-1]) { // same character so do nothing\\n            return dp[m][n] = helper(word1, word2, m-1, n-1, dp);\\n        }\\n        // check min value from all cases\\n        int ans = INT_MAX;\\n        ans = min(ans, helper(word1, word2, m-1, n-1, dp)); // replace\\n        ans = min(ans, helper(word1, word2, m-1, n, dp)); // delete \\n        ans = min(ans, helper(word1, word2, m, n-1, dp)); // addition\\n        return dp[m][n] = 1 + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170099,
                "title": "c-easy-tabulation-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int dp[n+1][m+1]; \\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = max(i,j);\\n                }\\n                else if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n            else if(word1[i-1]!=word2[j-1]){\\n                dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1])) +1;\\n              }\\n            }\\n        }\\n     return dp[n][m];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int dp[n+1][m+1]; \\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                if(i==0||j==0){\\n                    dp[i][j] = max(i,j);\\n                }\\n                else if(word1[i-1]==word2[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n            else if(word1[i-1]!=word2[j-1]){\\n                dp[i][j]=min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1])) +1;\\n              }\\n            }\\n        }\\n     return dp[n][m];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110592,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans[502][502];\\n\\tint dp(string s1, string s2, int n, int m)\\n\\t{\\n\\t\\tif (ans[n][m] != -1)\\n\\t\\t\\treturn ans[n][m];\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn ans[n][m] = m;\\n\\t\\tif (m == 0)\\n\\t\\t\\treturn ans[n][m] = n;\\n\\t\\tif (s1[n - 1] == s2[m - 1])\\n\\t\\t\\treturn ans[n][m] = dp(s1, s2, n - 1, m - 1);\\n\\t\\telse\\n\\t\\t\\treturn ans[n][m] = 1 + min(dp(s1, s2, n - 1, m), min(dp(s1, s2, n, m - 1), dp(s1, s2, n - 1, m - 1)));\\n\\t}\\n\\tint minDistance(string s1, string s2)\\n\\t{\\n\\t\\tmemset(ans, -1, sizeof(ans));\\n\\t\\treturn dp(s1, s2, s1.length(), s2.length());\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint ans[502][502];\\n\\tint dp(string s1, string s2, int n, int m)\\n\\t{\\n\\t\\tif (ans[n][m] != -1)\\n\\t\\t\\treturn ans[n][m];\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn ans[n][m] = m;\\n\\t\\tif (m == 0)\\n\\t\\t\\treturn ans[n][m] = n;\\n\\t\\tif (s1[n - 1] == s2[m - 1])\\n\\t\\t\\treturn ans[n][m] = dp(s1, s2, n - 1, m - 1);\\n\\t\\telse\\n\\t\\t\\treturn ans[n][m] = 1 + min(dp(s1, s2, n - 1, m), min(dp(s1, s2, n, m - 1), dp(s1, s2, n - 1, m - 1)));\\n\\t}\\n\\tint minDistance(string s1, string s2)\\n\\t{\\n\\t\\tmemset(ans, -1, sizeof(ans));\\n\\t\\treturn dp(s1, s2, s1.length(), s2.length());\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025208,
                "title": "c-5-line-super-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(string &a,string &b,int i,int j,int n,int m)\\n    {\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==n)return m-j;//if a string is traversed return whats left in b string\\n        if(j==m)return n-i;// and vice verse\\n        if(a[i]==b[j])return dp[i][j]=solve(a,b,i+1,j+1,n,m);//if a and b char are same do i++ and j++\\n        return dp[i][j]=1+min(solve(a,b,i+1,j,n,m),min(solve(a,b,i,j+1,n,m),solve(a,b,i+1,j+1,n,m)));\\n\\t\\t//else check for 3 conditions \\n\\t\\t1.del the character\\n\\t\\t2.insert the character\\n\\t\\t3.replace the character\\n\\t\\t//dry run these 3 conditions and u will get this one\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(word1,word2,0,0,word1.size(),word2.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(string &a,string &b,int i,int j,int n,int m)\\n    {\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(i==n)return m-j;//if a string is traversed return whats left in b string\\n        if(j==m)return n-i;// and vice verse\\n        if(a[i]==b[j])return dp[i][j]=solve(a,b,i+1,j+1,n,m);//if a and b char are same do i++ and j++\\n        return dp[i][j]=1+min(solve(a,b,i+1,j,n,m),min(solve(a,b,i,j+1,n,m),solve(a,b,i+1,j+1,n,m)));\\n\\t\\t//else check for 3 conditions \\n\\t\\t1.del the character\\n\\t\\t2.insert the character\\n\\t\\t3.replace the character\\n\\t\\t//dry run these 3 conditions and u will get this one\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(word1,word2,0,0,word1.size(),word2.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005424,
                "title": "c-dp-o-m-n-easiest-explanation-so-far",
                "content": "\\n\\n \\xA0  int minDistance(string word1, string word2) {\\n        int m= word1.length(), n= word2.length();\\n        vector<vector<int>>tab(m+1, vector<int>(n+1));\\n        \\n        //if word1 is empty, then we have to add all n chars of word2\\n        if(m== 0)\\n            return n;\\n        //if word2 is empty, then we have to delete all m chars of word1\\n        if(n== 0)\\n            return m;\\n        \\n        for(int i =0;i<=m;i++){\\n            for(int j = 0;j<=n;j++){\\n                \\n                /*       g e s e k\\n                     g   0 1 2 3 4\\n                     e   1\\n                     e   2\\n                     k   3\\n                     */\\n                //you can see from dp table, word1 = g(i= 0), (and word2 = g(j ==0))\\n                //so g== g, we need 0 operation, as j== 1 word1 = g & word2 =ge\\n                //g--> ge need 1 operations(addition of e)\\n                //0th row = 0 1 2 3...j\\n                if(i== 0)\\n                    tab[i][j] = j;\\n                else if(j == 0)\\n                    tab[i][j] = i;\\n                //chars are same no operation required\\n                else if(word1[i-1] == word2[j-1])\\n                    tab[i][j] = tab[i-1][j-1];\\n                else{\\n    \\t                tab[i][j] = 1+min(tab[i][j-1], min(tab[i-1][j], tab[i-1][j-1]));\\n                    \\n                        /*insert: word1 = geek, word2 = gesek\\n                        at i = 1 & j= 2, we are ignoring s (by j-1) of word2 and adding\\n                        1 as insret operation, we are not actually adding, we are assuming\\n                        these operations only, remove and replace can be assumed */\\n                }\\n            }\\n            \\n        }\\n        return tab[m][n];\\n    }\\n};",
                "solutionTags": [],
                "code": "\\n\\n \\xA0  int minDistance(string word1, string word2) {\\n        int m= word1.length(), n= word2.length();\\n        vector<vector<int>>tab(m+1, vector<int>(n+1));\\n        \\n        //if word1 is empty, then we have to add all n chars of word2\\n        if(m== 0)\\n            return n;\\n        //if word2 is empty, then we have to delete all m chars of word1\\n        if(n== 0)\\n            return m;\\n        \\n        for(int i =0;i<=m;i++){\\n            for(int j = 0;j<=n;j++){\\n                \\n                /*       g e s e k\\n                     g   0 1 2 3 4\\n                     e   1\\n                     e   2\\n                     k   3\\n                     */\\n                //you can see from dp table, word1 = g(i= 0), (and word2 = g(j ==0))\\n                //so g== g, we need 0 operation, as j== 1 word1 = g & word2 =ge\\n                //g--> ge need 1 operations(addition of e)\\n                //0th row = 0 1 2 3...j\\n                if(i== 0)\\n                    tab[i][j] = j;\\n                else if(j == 0)\\n                    tab[i][j] = i;\\n                //chars are same no operation required\\n                else if(word1[i-1] == word2[j-1])\\n                    tab[i][j] = tab[i-1][j-1];\\n                else{\\n    \\t                tab[i][j] = 1+min(tab[i][j-1], min(tab[i-1][j], tab[i-1][j-1]));\\n                    \\n                        /*insert: word1 = geek, word2 = gesek\\n                        at i = 1 & j= 2, we are ignoring s (by j-1) of word2 and adding\\n                        1 as insret operation, we are not actually adding, we are assuming\\n                        these operations only, remove and replace can be assumed */\\n                }\\n            }\\n            \\n        }\\n        return tab[m][n];\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1945530,
                "title": "c-100-faster-all-approach-included",
                "content": "Suggestion : \\nTrust me if you were able to write the recurrence then the problem is just a cake for you. So now Try yourself and find the recurrence to solve this problem. If you were not able to figure out then no worries please read the full editorial. I will try to make it super easy for you. \\nLets dive deep what the problem is all about ? and note the imp points:\\n1. convert string S1 to string S2 \\n2. operation allowed are:\\n  a. insertion \\n  b. deletion \\n  c. replace \\n3. return min number of operations \\n\\nNow lets observe the worst case : \\nif s1 = \"horse\" and s2= \"ros\" then what my mind says is that delete every character of s1 and then insert every character of s2. so max number of operations are : N(length of s1) + M (length of s2). \\nnow optimized this; \\n**One observation i can deduce is that if only insertion and deletion is allowed then this question will be similar to \"min number of insertion/deletion to convert s1 to s2\"** which is solved using the concept of lcs. \\nbut till now we have not consider the importance of replace operation. \\n\\nNow lets try to form the solution together. \\n\\nif you observe there can be only 2 cases formed (like every sting dp question)\\n**case 1:**\\nif s1[i]==s2[j] then no operation is require hence **F(i,j) = F(i-1,j-1)**\\n**case 2:**\\nif s1[i]!=s2[j] so there are 3 possibilites as given in question now if you were able to write the recurrence for each condition and take the min out of them . Hurrah!! you are done with the solution. Congrats!! . \\n1. replace \\n**F(i,j) = F(i-1,j-1)**\\n2. delete \\n**F(i,j) = F(i-1,j)**\\n3. insert\\n**F(i,j)= F(i,j-1)**\\nans = min (replace , delete, insert)\\n\\nI hope you understand the approach. Lets see code of all approaches\\n**1. Memoization**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n    int solve(int i,int j,string word1,string word2,vector<vector<int>> &dp){\\n        \\n        if(i<0) return j+1;\\n        if(j<0) return i+1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=solve(i-1,j-1,word1,word2,dp);\\n        }\\n        \\n            char c= word1[i];\\n            word1[i]=word2[j];\\n            int rep= 1 + solve(i-1,j-1,word1,word2,dp);\\n            word1[i]=c;\\n            int del= 1+ solve(i-1,j,word1,word2,dp);\\n            int ins= 1+ solve(i,j-1,word1,word2,dp);\\n        return dp[i][j]=min(rep,min(del,ins));;\\n    }\\n};\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(stack space) + O(n*m)**\\n\\n**2. Tabulation**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            dp[0][i]= i;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1]==word2[j-1]) dp[i][j]= dp[i-1][j-1];\\n                else {\\n                    dp[i][j]= 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(n*m)\\nRuntime : 0ms (100% faster)**\\n\\n**3. Space Optimization**\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int prev[m+1],temp[m+1];\\n        for(int i=0;i<=m;i++){\\n            prev[i]= i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            temp[0]=i;\\n            for(int j=1;j<=m;j++){\\n           \\n                if(word1[i-1]==word2[j-1]) temp[j]= prev[j-1];\\n                else {\\n                    temp[j]= 1 + min(prev[j-1],min(prev[j],temp[j-1]));\\n                }\\n            }\\n            for(int i=0;i<=m;i++) prev[i]= temp[i];\\n        }\\n        return prev[m];\\n    }\\n \\n};\\n```\\n**Time Complexity: O(n*m)\\nSpace Complexity: O(m)**\\n\\n**Upvote If you like my approach.**\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return solve(n-1,m-1,word1,word2,dp);\\n    }\\n    int solve(int i,int j,string word1,string word2,vector<vector<int>> &dp){\\n        \\n        if(i<0) return j+1;\\n        if(j<0) return i+1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(word1[i]==word2[j]){\\n            return dp[i][j]=solve(i-1,j-1,word1,word2,dp);\\n        }\\n        \\n            char c= word1[i];\\n            word1[i]=word2[j];\\n            int rep= 1 + solve(i-1,j-1,word1,word2,dp);\\n            word1[i]=c;\\n            int del= 1+ solve(i-1,j,word1,word2,dp);\\n            int ins= 1+ solve(i,j-1,word1,word2,dp);\\n        return dp[i][j]=min(rep,min(del,ins));;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=m;i++){\\n            dp[0][i]= i;\\n        }\\n        for(int i=0;i<=n;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(word1[i-1]==word2[j-1]) dp[i][j]= dp[i-1][j-1];\\n                else {\\n                    dp[i][j]= 1 + min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]));\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.size();\\n        int m= word2.size();\\n        int prev[m+1],temp[m+1];\\n        for(int i=0;i<=m;i++){\\n            prev[i]= i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            temp[0]=i;\\n            for(int j=1;j<=m;j++){\\n           \\n                if(word1[i-1]==word2[j-1]) temp[j]= prev[j-1];\\n                else {\\n                    temp[j]= 1 + min(prev[j-1],min(prev[j],temp[j-1]));\\n                }\\n            }\\n            for(int i=0;i<=m;i++) prev[i]= temp[i];\\n        }\\n        return prev[m];\\n    }\\n \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929959,
                "title": "c-memoization-recursion-with-explanation",
                "content": "In this question you just have 3 options for non matching character and no need to do any operation for matching character.\\n\\nthe main key point of this question is base case.\\n\\nthere are 3 base case\\'s \\n1. when we have reached the end of both the strings, return 0.\\n2. when we have reached end of any of the string just return the diff of i and j plus one that it.\\n\\nhope understand.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int rec(string word1,string word2,int i,int j)\\n    {\\n        if(i<0 && j<0)\\n        {\\n            return 0;\\n        }\\n        if(i<0 && j>=0)\\n        {\\n            return j+1;\\n        }\\n        if(i>=0 && j<0)\\n        {\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(word1[i]!=word2[j])\\n        {\\n            int a=1+rec(word1,word2,i,j-1);\\n            int b=1+rec(word1,word2,i-1,j);\\n            int c=1+rec(word1,word2,i-1,j-1);\\n            ans=min(a,min(b,c));\\n        }else\\n        {\\n            ans=rec(word1,word2,i-1,j-1);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof dp);\\n        int n=word1.size();\\n        int m=word2.size();\\n        if(n==0 || m==0)\\n        {\\n            return abs(m-n);\\n        }\\n        return rec(word1,word2,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int rec(string word1,string word2,int i,int j)\\n    {\\n        if(i<0 && j<0)\\n        {\\n            return 0;\\n        }\\n        if(i<0 && j>=0)\\n        {\\n            return j+1;\\n        }\\n        if(i>=0 && j<0)\\n        {\\n            return i+1;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(word1[i]!=word2[j])\\n        {\\n            int a=1+rec(word1,word2,i,j-1);\\n            int b=1+rec(word1,word2,i-1,j);\\n            int c=1+rec(word1,word2,i-1,j-1);\\n            ans=min(a,min(b,c));\\n        }else\\n        {\\n            ans=rec(word1,word2,i-1,j-1);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof dp);\\n        int n=word1.size();\\n        int m=word2.size();\\n        if(n==0 || m==0)\\n        {\\n            return abs(m-n);\\n        }\\n        return rec(word1,word2,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888200,
                "title": "explained-step-by-step-description-and-solution-easy-to-understand-answering-the-why",
                "content": "\\nThe post will follow the flow: Choices -> Examples -> Recurrence Relation -> Filling out table -> Solution\\n\\n*Sorry if there are any typos but comment and I\\'ll try to make edits*\\n\\n# Edit Distance\\nTo begin working on really any dynamic programming problem you want to think about those sub problems and about what decisions we can make throughout the process of solving the problem. The decisions we are able to make at any given letter are in this problem explicitly given to us as the following three:\\n\\n1. We can **delete** a letter\\n2. We can **insert** a letter\\n3. We can **replace** a letter\\n\\nLets look at some examples to get a better grasp of what exactly those decisions look like\\n\\n```\\nInput: word1 = \"java\", word2 = \"swift\"\\n```\\nThroughout these decisions our focus will be on the last letters of each string. Our larger goal is to get the two words to be the same but we will focus on letter by letter starting from the end. \\n\\n**Decision 1: We can delete a letter**\\n![image](https://assets.leetcode.com/users/images/fa4261a8-fff4-410a-88f9-7dd78f25b838_1648371955.8076708.png)\\nWe are trying to get \"java\" to become \"swift.\" If we can delete a letter from \"java\" and our goal is to get the last letter to equal the last of \"swift\" then we will remove the letter \\'a\\'. If we delete the last letter in \"java\" it now becomes \"jav\" but \"jav\" still isn\\'t equal to swift. So our subproblem now is to get \"jav\" to become \"swift.\" Notice how we chose to make a decision and now we have a sub problem.\\n\\n\\n**Decision 2: We can insert a letter**\\n![image](https://assets.leetcode.com/users/images/af9d5024-5ef7-4d17-b378-96d727f90816_1648372005.563788.png)\\nWe are trying to get \"java\" to become \"swift.\" If we can insert a letter into \"java\" and our goal is to get the last letter to equal the last letter of \"swift\" then the letter we will insert will be a \\'t\\'. If we insert a \\'t\\' then we get \\'javat\\' and now the last letters are equal but the rest of the word isn\\'t. So our subproblem is now to look at the remaining letters in the words (\\'java\\', \\'swif\\')\\n\\n**Decision 3: We can replace a letter**\\n![image](https://assets.leetcode.com/users/images/1619d600-6085-4c83-ac18-94eacbffc7fc_1648372049.465201.png)\\n\\nAs before we are trying to get \"java\" to become \"swift.\" If we can replace a letter in \"java\" so that the last letter equals the last letter of \"swift\" then we will replace the \\'a\\' to a \\'t\\'. This will result in \"javt\" and \"swift\" and now the last letters are equal but the rest of the word isn\\'t equal. Our new subproblem becomes to get \"jav\" to equal \"swif\"\\n\\n**Important Note**\\nWe talked about the 3 explicitly named decisions for this problem but there is a subtle 4th decision, we can do nothing. This decision would be the decision we choose if the last letter is already the same because there\\'s no need to delete, insert, or replace that last letter. So in this case we will just do nothing to that last letter and continue looking at the rest of the word\\n\\n# Table setup\\n![image](https://assets.leetcode.com/users/images/dfd5f9fe-ffc2-40ab-b76d-6c8b1704e9aa_1648372147.6479256.png)\\nLets explain these cells and the logic being used to fill them so far. The columns represent letters of the word we currently have and the rows represent letters of the word we want. \\n\\nSo table[0][0] can be read as \"Whats the minimum number of steps to turn an empty string into an empty string?\"\\nWell 0 steps are needed to do that. \\n\\nTable[0][4] can be read as \"Whats the minimum number of steps to turn an empty string into java?\" You would need 4 steps to do that, more specifically 4 inserts to do that. You would need to insert \\'j\\' then \\'a\\' then \\'v\\' and then \\'a\\'.\\n\\n**Relating our decisions to a recurrence relation** \\n\\n**1. Decision 1: We can delete a letter**\\n![image](https://assets.leetcode.com/users/images/62eddf11-6b28-4283-8cf6-da3f08a4f8ea_1648372248.910796.png)\\n\\n **2. Decision 2: We can insert a letter**\\n ![image](https://assets.leetcode.com/users/images/31a79fa2-969a-4aca-8b3c-af10336c1029_1648372279.6259208.png)\\n \\n **3. Decision 3: We can replace a letter**\\n ![image](https://assets.leetcode.com/users/images/c6c837d0-ceeb-4d2e-806d-52953582a16e_1648372350.494664.png)\\n\\nThe problem asks for the **minimum** steps to turn our start string to the goal string. So we need to take the minimum of these decisions\\n\\n![image](https://assets.leetcode.com/users/images/d7f858ef-290d-47e8-b4a5-7ac57757d989_1648372386.15309.png)\\n\\nThe +1 is because when we choose which decision to make we then have to execute it and all decisions have a +1 step cost. \\n\\n![image](https://assets.leetcode.com/users/images/71dba42d-84cf-495e-a336-2a0dd14b35b0_1648372415.5852163.png)\\n\\nIf these recurrence relations are a little confusing make sure to go back up to where we explained our decisions\\n\\n# Using our recurrence relations on our visual 2D table\\nBased on our recurrence relation this is a key we can use to quickly find our delete, insert, and replace values.\\n\\n![image](https://assets.leetcode.com/users/images/539cf57d-4dad-4cad-aa91-5edb57d9f053_1648372481.8830466.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a9b606a-1220-4b90-941f-0d09a03491a6_1648372563.230859.png)\\n\\n![image](https://assets.leetcode.com/users/images/5e6b917e-fd16-4493-b627-5bc7c85f821f_1648372584.0092237.png)\\n\\n![image](https://assets.leetcode.com/users/images/02184174-5af2-4da0-a113-017cfacd96e0_1648372593.0742426.png)\\n\\n![image](https://assets.leetcode.com/users/images/2d51b865-5edb-4100-8e0c-1a4b6beba8fe_1648372599.10186.png)\\n\\n![image](https://assets.leetcode.com/users/images/79a88905-8f72-4396-8538-c66996288639_1648372605.4986908.png)\\n\\nIt would take 5 steps to turn \"java\" into \"swift.\" This makes sense because they don\\'t have any of the same letters so we would have to replace all 4 letters in \"java\" and then insert another one because \"swift\" is 5 letters\\n\\nIn case it would be helpful this is the table at the end of filling out the table for the \"horse\" and \"ros\" example\\n\\n![image](https://assets.leetcode.com/users/images/c6820cb4-29db-4bfc-9b26-ff53930a6f64_1648372673.2579377.png)\\n\\n# Solution\\n**Time Complexity: O(nm)**\\n**Space Complexity: O(nm)**\\n\\n```\\nfunc minDistance(_ word1: String, _ word2: String) -> Int {\\n\\tvar table = Array(repeating: Array(repeating: 0, count: word1.count + 1), count: word2.count + 1)\\n\\t\\n\\t// adding the empty string state\\n\\tlet word1Arr = Array(\" \" + word1)\\n\\tlet word2Arr = Array(\" \" + word2)\\n\\t\\n\\t// Table setup for the empty string state\\n\\tfor row in 0..<table.count {\\n\\t\\ttable[row][0] = row\\n\\t}\\n\\tfor col in 0..<table[0].count {\\n\\t\\ttable[0][col] = col\\n\\t}\\n\\t\\n\\t// Begin iterating at index 1 to word2.count - this is the first letter of word2\\n\\tfor i in 1..<table.count {\\n\\t\\n\\t\\tfor j in 1..<table[i].count {\\n\\t\\t\\t\\n\\t\\t\\tlet insert: Int = table[i-1][j]\\n\\t\\t\\tlet remove: Int = table[i][j-1]\\n\\t\\t\\tlet replace: Int = table[i-1][j-1]\\n\\t\\t\\t\\n\\t\\t\\tif word2Arr[i] == word1Arr[j] {\\n\\t\\t\\t\\ttable[i][j] = replace\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttable[i][j] = min(insert, remove, replace) + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Return the value at the bottom right\\n\\treturn table[word2.count][word1.count]\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nInput: word1 = \"java\", word2 = \"swift\"\\n```\n```\\nfunc minDistance(_ word1: String, _ word2: String) -> Int {\\n\\tvar table = Array(repeating: Array(repeating: 0, count: word1.count + 1), count: word2.count + 1)\\n\\t\\n\\t// adding the empty string state\\n\\tlet word1Arr = Array(\" \" + word1)\\n\\tlet word2Arr = Array(\" \" + word2)\\n\\t\\n\\t// Table setup for the empty string state\\n\\tfor row in 0..<table.count {\\n\\t\\ttable[row][0] = row\\n\\t}\\n\\tfor col in 0..<table[0].count {\\n\\t\\ttable[0][col] = col\\n\\t}\\n\\t\\n\\t// Begin iterating at index 1 to word2.count - this is the first letter of word2\\n\\tfor i in 1..<table.count {\\n\\t\\n\\t\\tfor j in 1..<table[i].count {\\n\\t\\t\\t\\n\\t\\t\\tlet insert: Int = table[i-1][j]\\n\\t\\t\\tlet remove: Int = table[i][j-1]\\n\\t\\t\\tlet replace: Int = table[i-1][j-1]\\n\\t\\t\\t\\n\\t\\t\\tif word2Arr[i] == word1Arr[j] {\\n\\t\\t\\t\\ttable[i][j] = replace\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttable[i][j] = min(insert, remove, replace) + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Return the value at the bottom right\\n\\treturn table[word2.count][word1.count]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1796988,
                "title": "lcs-variation-dp-solution-cpp",
                "content": "DP matrix initialization and Dry run for the sample case\\n![image](https://assets.leetcode.com/users/images/2c43a3fa-d3b3-442b-bf09-fb1332a2a765_1659076991.6366894.jpeg)\\n\\nMechanism\\nIf after comaparing we are finding the same character we will copy the value from the diagonal cell\\notherwise the value will be 1+ the minimum value of updation deletion and insertion\\n![image](https://assets.leetcode.com/users/images/cc3eb444-ea30-414a-8b07-6320539fa79e_1659077075.7195187.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n     int LCS(string x,string y, int n, int m){\\n        int dp[n+1][m+1];\\n        for(int i =0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n        \\n                \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(x[i-1]== y[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];   \\n        \\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        \\n        return LCS(word1,word2,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int LCS(string x,string y, int n, int m){\\n        int dp[n+1][m+1];\\n        for(int i =0;i<n+1;i++){\\n            dp[i][0]=i;\\n        }\\n        for(int j=0;j<m+1;j++){\\n            dp[0][j]=j;\\n        }\\n        \\n                \\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(x[i-1]== y[j-1]){\\n                    dp[i][j]= dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];   \\n        \\n    }\\n    int minDistance(string word1, string word2) {\\n        int n = word1.size();\\n        int m = word2.size();\\n        \\n        return LCS(word1,word2,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770392,
                "title": "python-simple-recursive-dp-with-memorization-o-mn-84ms-beats-99",
                "content": "Here is a simple recursive python solution:\\n\\nuse two pointers to track which index of word1 and word2 I\\'m evaluating in the function call, at each call:\\n- if one or both the pointers have reached the end return the remaining chars to insert / delete\\n- if the two pointers point to the same value no operation required: p1 + 1, p2 + 1\\n- otherwise keep the minimum distance between insert (p1, p2 + 1), delete (p1 + 1, p2) and replace (p1 + 1, p2 + 1)\\n\\nwith memorization each combination of letters in word1 and word2 is evaluated only once:\\n- time complexity: O(m*n)\\n- space complexity: O(m*n)\\n```\\ndef minDistance(self, word1: str, word2: str) -> int:\\n\\n\\t@lru_cache(None)\\n\\tdef min_dist(p1, p2):\\n\\n\\t\\tif p1 == len(word1) or p2 == len(word2):\\n\\t\\t\\treturn len(word1) - p1 + len(word2) - p2\\n\\n\\t\\t# no change required\\n\\t\\tif word1[p1] == word2[p2]:\\n\\t\\t\\treturn min_dist(p1 + 1, p2 + 1)\\n\\n\\t\\treturn 1 + min(\\n\\t\\t\\tmin_dist(p1, p2 + 1),      # insert character\\n\\t\\t\\tmin_dist(p1 + 1, p2),      # delete character\\n\\t\\t\\tmin_dist(p1 + 1, p2 + 1),  # replace character\\n\\t\\t)\\n\\n\\treturn min_dist(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef minDistance(self, word1: str, word2: str) -> int:\\n\\n\\t@lru_cache(None)\\n\\tdef min_dist(p1, p2):\\n\\n\\t\\tif p1 == len(word1) or p2 == len(word2):\\n\\t\\t\\treturn len(word1) - p1 + len(word2) - p2\\n\\n\\t\\t# no change required\\n\\t\\tif word1[p1] == word2[p2]:\\n\\t\\t\\treturn min_dist(p1 + 1, p2 + 1)\\n\\n\\t\\treturn 1 + min(\\n\\t\\t\\tmin_dist(p1, p2 + 1),      # insert character\\n\\t\\t\\tmin_dist(p1 + 1, p2),      # delete character\\n\\t\\t\\tmin_dist(p1 + 1, p2 + 1),  # replace character\\n\\t\\t)\\n\\n\\treturn min_dist(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1710466,
                "title": "simple-c-top-down-approach",
                "content": "```  int dp[501][501];\\n    int solve(string &s1,string &s2,int m,int n){\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];//if any string become zero then minimum insertion required is  second string length\\n        if(m==0)\\n            return dp[m][n]= n;\\n        if(n==0)\\n            return dp[m][n]= m;\\n        if(s1[m-1]==s2[n-1]){\\n            return dp[m][n]=solve(s1,s2,m-1,n-1);//both  last character match then call by removing last character from both string\\n        }\\n        else\\n        {\\n\\t\\t//we are doing 1 operation so adding 1 to result and taking minimum of insert,delete and replace.\\n            return dp[m][n]= 1+min(solve(s1,s2,m,n-1),min(solve(s1,s2,m-1,n),solve(s1,s2,m-1,n-1)));//when both last character not match then\\n\\t\\t\\t//insert the charcter in string one so 1st string remain same  and string 2 reduces by 1 (after inserting both matches);\\n\\t\\t\\t//delete the last character in string 1 and  second string remain same (after deleting both matches)\\n\\t\\t\\t//replace the  last character in string 1 so both both character match so both string reduces by 1 (after replacing both matches)\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n       return solve(word1,word2,word1.length(),word2.length());\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```  int dp[501][501];\\n    int solve(string &s1,string &s2,int m,int n){\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];//if any string become zero then minimum insertion required is  second string length\\n        if(m==0)\\n            return dp[m][n]= n;\\n        if(n==0)\\n            return dp[m][n]= m;\\n        if(s1[m-1]==s2[n-1]){\\n            return dp[m][n]=solve(s1,s2,m-1,n-1);//both  last character match then call by removing last character from both string\\n        }\\n        else\\n        {\\n\\t\\t//we are doing 1 operation so adding 1 to result and taking minimum of insert,delete and replace.\\n            return dp[m][n]= 1+min(solve(s1,s2,m,n-1),min(solve(s1,s2,m-1,n),solve(s1,s2,m-1,n-1)));//when both last character not match then\\n\\t\\t\\t//insert the charcter in string one so 1st string remain same  and string 2 reduces by 1 (after inserting both matches);\\n\\t\\t\\t//delete the last character in string 1 and  second string remain same (after deleting both matches)\\n\\t\\t\\t//replace the  last character in string 1 so both both character match so both string reduces by 1 (after replacing both matches)\\n        }\\n    }\\n    int minDistance(string word1, string word2) {\\n        memset(dp,-1,sizeof(dp));\\n       return solve(word1,word2,word1.length(),word2.length());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1517075,
                "title": "c-solution-with-explanation",
                "content": "```\\n    int minDistance(string word1, string word2) {\\n        int size1 = word1.size();\\n        int size2 = word2.size();\\n        int row = size1 + 1;\\n        int column = size2 + 1;\\n        vector<vector<int>> lm(row, vector<int>(column, 0));\\n        // the distance between \"\" and \"\" is zero\\n        lm[0][0] = 0;\\n        // the operations of converting \"\" to a length i word\\n        for (int i = 1; i < column; i++) {\\n            lm[0][i] = i;\\n        }\\n        // the operations of converting a length i word to \"\"\\n        for (int i = 1; i < row; i++) {\\n            lm[i][0] = i;\\n        }\\n        \\n        for (int r = 1; r < row; r++) {\\n            for (int c = 1; c < column; c++) {\\n                // if the last character of two strings are the same, then the distance is the same as lm[r-1][c-1]\\n                if (word1[r - 1] == word2[c - 1]) {\\n                    lm[r][c] = lm[r - 1][c - 1];\\n                } else {\\n                    // if we have known the min distance between s1[1...r-1] and s2[1...c-1]\\n                    // then we can replace s1[r] with s2[c] first then convert s1[1...r-1] to s2[1...c-1]\\n                    int replace = lm[r - 1][c - 1] + 1;\\n                    // if we have known the min distance bwtween s1[1...r-1] and s2[1...c]\\n\\t\\t\\t\\t\\t// we can  delete s1[r] first then convert s1[1...r-1] to s2[1...c]\\n                    int del = lm[r - 1][c] + 1;\\n                    // if we have known the min distance between s1[1...r] and s2[1...c-1]\\n\\t\\t\\t\\t\\t// we can convert s1[1...r] to s2[1...c-1] then insert s2[c] to the end of s1\\n                    int insert = lm[r][c - 1] + 1;\\n                    // find the min value among the above operation steps\\n                    int result = min(replace, del);\\n                    result = min(result, insert);\\n                    lm[r][c] = result;\\n                }\\n            }\\n        }\\n        return lm[size1][size2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minDistance(string word1, string word2) {\\n        int size1 = word1.size();\\n        int size2 = word2.size();\\n        int row = size1 + 1;\\n        int column = size2 + 1;\\n        vector<vector<int>> lm(row, vector<int>(column, 0));\\n        // the distance between \"\" and \"\" is zero\\n        lm[0][0] = 0;\\n        // the operations of converting \"\" to a length i word\\n        for (int i = 1; i < column; i++) {\\n            lm[0][i] = i;\\n        }\\n        // the operations of converting a length i word to \"\"\\n        for (int i = 1; i < row; i++) {\\n            lm[i][0] = i;\\n        }\\n        \\n        for (int r = 1; r < row; r++) {\\n            for (int c = 1; c < column; c++) {\\n                // if the last character of two strings are the same, then the distance is the same as lm[r-1][c-1]\\n                if (word1[r - 1] == word2[c - 1]) {\\n                    lm[r][c] = lm[r - 1][c - 1];\\n                } else {\\n                    // if we have known the min distance between s1[1...r-1] and s2[1...c-1]\\n                    // then we can replace s1[r] with s2[c] first then convert s1[1...r-1] to s2[1...c-1]\\n                    int replace = lm[r - 1][c - 1] + 1;\\n                    // if we have known the min distance bwtween s1[1...r-1] and s2[1...c]\\n\\t\\t\\t\\t\\t// we can  delete s1[r] first then convert s1[1...r-1] to s2[1...c]\\n                    int del = lm[r - 1][c] + 1;\\n                    // if we have known the min distance between s1[1...r] and s2[1...c-1]\\n\\t\\t\\t\\t\\t// we can convert s1[1...r] to s2[1...c-1] then insert s2[c] to the end of s1\\n                    int insert = lm[r][c - 1] + 1;\\n                    // find the min value among the above operation steps\\n                    int result = min(replace, del);\\n                    result = min(result, insert);\\n                    lm[r][c] = result;\\n                }\\n            }\\n        }\\n        return lm[size1][size2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475926,
                "title": "c-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(const string& s1, const string& s2, int m, int n,int i, int j,vector<vector<int>>& dp){\\n        if(s1[i] == \\'\\\\0\\'){\\n            return n;\\n        }\\n        if(s2[j] == \\'\\\\0\\'){\\n            return m;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int ans;\\n        if(s1[i] == s2[j]){\\n            ans = helper(s1,s2,m-1,n-1,i+1,j+1,dp);\\n        }\\n        else{\\n            ans = 1 + min(helper(s1,s2,m-1,n,i+1,j,dp),min(helper(s1,s2,m,n-                        1,i,j+1,dp),helper(s1,s2,m-1,n-1,i+1,j+1,dp)));\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    int minDistance(string s1, string s2) {\\n        int m = s1.size();\\n        int n = s2.size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return helper(s1,s2,m,n,0,0,dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(const string& s1, const string& s2, int m, int n,int i, int j,vector<vector<int>>& dp){\\n        if(s1[i] == \\'\\\\0\\'){\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1458851,
                "title": "java-memorization-3-ms-faster-than-99-35-submission",
                "content": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] mem : memo){\\n            Arrays.fill(mem, -1);\\n        }\\n        return Helper(word1, word2, n, m, memo);       \\n        \\n    }\\n    \\n    public static int Helper(String word1, String word2, int n, int m, int[][] memo){\\n        \\n        if(memo[n][m] != -1){\\n            return memo[n][m];\\n        }\\n        \\n        if(n == 0){\\n            return m;\\n        }\\n        if(m == 0){\\n            return n;\\n        }\\n        \\n        if(word1.charAt(n-1) == word2.charAt(m-1)){\\n            return memo[n][m] = Helper(word1, word2, n-1, m-1, memo);\\n        }\\n        else{\\n            int delete = 1 + Helper(word1, word2, n-1, m, memo);  // delete operation\\n            int replace = 1 + Helper(word1, word2, n-1, m-1, memo);  // replace operation\\n            int insert = 1 + Helper(word1, word2, n, m-1, memo); // insert operation\\n            \\n            return memo[n][m] = Math.min(delete, Math.min(replace, insert));\\n        }        \\n        \\n    }\\n    \\n}\\n```\\n\\nPlease help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\nLOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minDistance(String word1, String word2) {\\n        \\n        int n = word1.length();\\n        int m = word2.length();\\n        \\n        int[][] memo = new int[n+1][m+1];\\n        for(int[] mem : memo){\\n            Arrays.fill(mem, -1);\\n        }\\n        return Helper(word1, word2, n, m, memo);       \\n        \\n    }\\n    \\n    public static int Helper(String word1, String word2, int n, int m, int[][] memo){\\n        \\n        if(memo[n][m] != -1){\\n            return memo[n][m];\\n        }\\n        \\n        if(n == 0){\\n            return m;\\n        }\\n        if(m == 0){\\n            return n;\\n        }\\n        \\n        if(word1.charAt(n-1) == word2.charAt(m-1)){\\n            return memo[n][m] = Helper(word1, word2, n-1, m-1, memo);\\n        }\\n        else{\\n            int delete = 1 + Helper(word1, word2, n-1, m, memo);  // delete operation\\n            int replace = 1 + Helper(word1, word2, n-1, m-1, memo);  // replace operation\\n            int insert = 1 + Helper(word1, word2, n, m-1, memo); // insert operation\\n            \\n            return memo[n][m] = Math.min(delete, Math.min(replace, insert));\\n        }        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434648,
                "title": "c-dp-solution-by-kushalatolia",
                "content": "![image](https://assets.leetcode.com/users/images/2bf44bc5-6c1d-4369-9e84-3a7ff50a4ba5_1630319139.576023.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=i;\\n        for(int i=0;i<=m;i++)\\n            dp[0][i]=i;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else \\n                    dp[i][j]=min(dp[i][j-1]+1,min(dp[i-1][j]+1,dp[i-1][j-1]+1));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n=word1.size();\\n        int m=word2.size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i][0]=i;\\n        for(int i=0;i<=m;i++)\\n            dp[0][i]=i;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(word1[i-1]==word2[j-1])\\n                    dp[i][j]=dp[i-1][j-1];\\n                else \\n                    dp[i][j]=min(dp[i][j-1]+1,min(dp[i-1][j]+1,dp[i-1][j-1]+1));\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417454,
                "title": "python-dp-memoized-bottom-up-and-recursive-solution",
                "content": "Refer [this](https://en.wikipedia.org/wiki/Levenshtein_distance) article for the algorithm used in this solution.\\n\\n```\\n# DP (top-down) solution\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        t = [[0 for p in range(0,m+1)]\\n            for q in range(0,n+1)]\\n        \\n        for a in range(0,n+1):\\n            t[a][0] = a\\n        for b in range(1,m+1):\\n            t[0][b] = b\\n            \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                \\n                if word1[i-1] == word2[j-1]:\\n                    t[i][j] = t[i-1][j-1]\\n                    \\n                else:\\n                    t[i][j] = 1 + min(t[i][j-1], t[i-1][j], t[i-1][j-1])\\n                    \\n        return t[n][m]\\n\\t\\t\\n\\t\\t\\n# Recursive code\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.edit(word1,word2,len(word1), len(word2))\\n    \\n    def edit(self,x,y,n,m):\\n        if n == 0 or m == 0:\\n            if n == 0:\\n                return m\\n            else:\\n                return n\\n            \\n        if x[n-1] == y[m-1]:\\n            return self.edit(x,y,n-1,m-1)\\n        else:\\n            return 1 + min(self.edit(x,y,n,m-1), self.edit(x,y,n-1,m), self.edit(x,y,n-1,m-1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# DP (top-down) solution\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n = len(word1)\\n        m = len(word2)\\n        \\n        t = [[0 for p in range(0,m+1)]\\n            for q in range(0,n+1)]\\n        \\n        for a in range(0,n+1):\\n            t[a][0] = a\\n        for b in range(1,m+1):\\n            t[0][b] = b\\n            \\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                \\n                if word1[i-1] == word2[j-1]:\\n                    t[i][j] = t[i-1][j-1]\\n                    \\n                else:\\n                    t[i][j] = 1 + min(t[i][j-1], t[i-1][j], t[i-1][j-1])\\n                    \\n        return t[n][m]\\n\\t\\t\\n\\t\\t\\n# Recursive code\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        return self.edit(word1,word2,len(word1), len(word2))\\n    \\n    def edit(self,x,y,n,m):\\n        if n == 0 or m == 0:\\n            if n == 0:\\n                return m\\n            else:\\n                return n\\n            \\n        if x[n-1] == y[m-1]:\\n            return self.edit(x,y,n-1,m-1)\\n        else:\\n            return 1 + min(self.edit(x,y,n,m-1), self.edit(x,y,n-1,m), self.edit(x,y,n-1,m-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180587,
                "title": "memoized-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.length();\\n        int m = word2.length();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n        \\n        return solve(n,m,word1,word2,dp);\\n    }\\n    int solve(int n, int m, string word1, string word2, vector<vector<int>> &dp){\\n        if(n==0 || m==0) return max(n,m);\\n        if(dp[n][m]!=-1) return dp[n][m];\\n        if(word1[n-1]==word2[m-1]) return solve(n-1,m-1,word1,word2,dp);\\n        else{\\n            dp[n][m] = min(solve(n-1,m,word1,word2,dp),\\n                           min(solve(n-1,m-1,word1,word2,dp),\\n                               solve(n,m-1,word1,word2,dp))) +1;\\n            return dp[n][m];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int n= word1.length();\\n        int m = word2.length();\\n        vector<vector<int>> dp(n+1,vector<int> (m+1,-1));\\n        \\n        return solve(n,m,word1,word2,dp);\\n    }\\n    int solve(int n, int m, string word1, string word2, vector<vector<int>> &dp){\\n        if(n==0 || m==0) return max(n,m);\\n        if(dp[n][m]!=-1) return dp[n][m];\\n        if(word1[n-1]==word2[m-1]) return solve(n-1,m-1,word1,word2,dp);\\n        else{\\n            dp[n][m] = min(solve(n-1,m,word1,word2,dp),\\n                           min(solve(n-1,m-1,word1,word2,dp),\\n                               solve(n,m-1,word1,word2,dp))) +1;\\n            return dp[n][m];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119169,
                "title": "c-dp-4-ways-to-solve-memory-utilization-99-lesser",
                "content": "\\n**Approach 1**  \\nSo the code for this recursive solution would be  \\nBase Case:  \\n- if **i** reached till the end , in that case we have to see how many characters still left(**word2.size()-j**) in word2 and return that.  \\n- similary we do for j if it reached till the end.  \\n\\nMemoization: Use the index i and j.  \\nTime Complexity: O(M*N)\\nSpace Complexity: O(M*N) plus recursion stack which will also be same.\\n```\\nint dp[505][505];\\nclass Solution {\\n    string s;\\n    string t;\\n    int solve(int i, int j)\\n    {\\n        // If we have exhausted the first string\\n        // We have to take number of chars left in second string\\n        // which will be t.size()-current_index_t\\n        // Same logic goes if we have exhausted second string\\n        if(i==s.size())\\n            return t.size()-j;\\n        if(j==t.size())\\n            return s.size()-i;\\n        // Check if we have already evaluated?\\n        int& ret = dp[i][j];\\n        if(ret !=-1)\\n            return ret;\\n        ret =0;\\n        // Mismatch\\n        if(s[i]!=t[j])\\n        {\\n            // If we replace that means i,j now match lets go to next\\n            int rep = 1 + solve(i+1, j+1);\\n            // if delete that means , we go to next j, i remain same.\\n            int del = 1 + solve(i, j+1);\\n            // if insert same char , that mean i now matches \\n            // but we dont know abt j , so keep j same\\n            int ins = 1 + solve(i+1, j);\\n            // Take minimum of all 3 operation\\n            ret = min({rep, del, ins});\\n        }\\n        else\\n            // i and j match, so lets goto next \\n            ret = solve(i+1, j+1);\\n        return ret;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        t = word1;\\n        s = word2;\\n        memset(&dp, -1, sizeof dp);\\n        return solve(0, 0);\\n    }\\n};\\n```\\n**Approach 2**  \\nLets convert this memoization based recursive approach to tabulation based iterative approach.  \\nf(i, j) = 1 + min { f(i+1, j+1) , f(i+1, j), f(i, j+1) }  \\n**Step 1**  \\nTable constrction: create a dp table of size dp[1+m][1+n].  \\nExtra 1 size to handle case of string completely exhaausted.  \\nBase case value to initialized in table, remember in recursive solution whenever i==m we return word2.size()-j and vice versa.  \\nSo here in tabulation approach when i==m-> dp[i][j] = word2.size() -j and when j==n -> dp[i][j] = word1.size()-i  \\n\\n\\n**Step 2**   \\nHow to start the loops:  Notice that our recursive function is dependent on future values, hence we cant start from i=0 or j=0  \\nwe have to start backward, when working backward future value would have been already calculated.  \\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i = m ; i >=0; --i)\\n        {\\n            for(int j = n ; j >=0; --j)\\n            {\\n                if(i==m) // that means word1 is exhausted\\n                    dp[i][j] = n - j;\\n                else if(j==n)\\n                    dp[i][j] = m - i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[i][j] = 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]});\\n                }\\n                else\\n                    dp[i][j] = dp[i+1][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n**Approach 3**  \\nGenerally we are more familiar with starting the loop with 0 to n.   \\nThis problem can be solve using this way as well, only the base case change i.e. when i=0 , that mean we are left with entire j length of word2 so dp[i][j]= j;  \\nSimilar when j==0 , dp[i][j]=i  \\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i=0; i <= m; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0)\\n                    dp[i][j] = j;\\n                else if(j==0)\\n                    dp[i][j] = i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nLet me show you that Approach 2 and 3 are exactly opposite of each other.\\nWe will show with example word1=\"abc\", word2=\"bcd\"\\n\\n![image](https://user-images.githubusercontent.com/20656683/111882251-a63fb180-89da-11eb-88bb-7fbbbd107757.png)\\n\\n\\n\\n**Approach 4 : Space Optimized DP**  \\nAbove tabluation based DP approach consume space of O( M* N ), we can further reduce this to 1-D DP. \\nNotice that as per DP recursive statement we are only dependent on 1-future row or 1-previous  (Approach 2 vs Approach 3) to compute the current row.  \\nOne easy way is to maintain 2 row, one which we will fill in the value of current row and 1 row which has values from previous row operation and then toggle between this row. There is even a smarter way where 2nd row itself is also not required, lets discuss that.  \\nI am going to discuss 1-D verion of Approach 2 but it is also applicable for Approach 3 as well.  \\n\\nStep 1: Always create 1-D DP array for smaller string , for our problem, I will always make word2 as smaller, if its not smaller , call the function by reversing argument.  \\nStep 2: Recall our recusrive function\\n          f(i, j) = 1 + min { f(i+1, j+1) , f(i+1, j), f(i, j+1) }  \\n\\n![image](https://user-images.githubusercontent.com/20656683/111882720-13ecdd00-89dd-11eb-9c38-9f2f25c94621.png)\\n\\nStep 3: Base case value remain same, just that now its 1-D.\\nStep 4: Make sure everywhere dp[i+1][j+1] is replaced by **prev**, dp[i+1][j] is dp[j] itself and dp[i][j+1] is dp[j+1].  \\nprev is a way to store previous value of the cell , so that the same can be reused in next iteration\\n\\nCode for this looks somehing like this.\\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        \\n        int m = word1.size();\\n        int n = word2.size();\\n        if(m < n)\\n            return minDistance(word2, word1);\\n        \\n        // Space optimized 1-D DP version\\n        vector<int> dp(1+n, 0);\\n        dp[n] = 0;\\n        int prev;\\n        for(int i = m; i >=0; --i)\\n        {\\n            prev = dp[n];\\n            for(int j = n ; j >=0; --j)\\n            {\\n                int oldDP = dp[j];\\n                if(i==m)\\n                    dp[j] = n-j;\\n                else if(j==n)\\n                    dp[j] = m-i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[j] = 1 + min({dp[j], dp[j+1], prev});\\n                }\\n                else\\n                    dp[j] = prev;\\n                prev = oldDP;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\nConculsion:\\nApproach 4 when submitted reported 99% lesser memory usage.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[505][505];\\nclass Solution {\\n    string s;\\n    string t;\\n    int solve(int i, int j)\\n    {\\n        // If we have exhausted the first string\\n        // We have to take number of chars left in second string\\n        // which will be t.size()-current_index_t\\n        // Same logic goes if we have exhausted second string\\n        if(i==s.size())\\n            return t.size()-j;\\n        if(j==t.size())\\n            return s.size()-i;\\n        // Check if we have already evaluated?\\n        int& ret = dp[i][j];\\n        if(ret !=-1)\\n            return ret;\\n        ret =0;\\n        // Mismatch\\n        if(s[i]!=t[j])\\n        {\\n            // If we replace that means i,j now match lets go to next\\n            int rep = 1 + solve(i+1, j+1);\\n            // if delete that means , we go to next j, i remain same.\\n            int del = 1 + solve(i, j+1);\\n            // if insert same char , that mean i now matches \\n            // but we dont know abt j , so keep j same\\n            int ins = 1 + solve(i+1, j);\\n            // Take minimum of all 3 operation\\n            ret = min({rep, del, ins});\\n        }\\n        else\\n            // i and j match, so lets goto next \\n            ret = solve(i+1, j+1);\\n        return ret;\\n    }\\npublic:\\n    int minDistance(string word1, string word2) {\\n        t = word1;\\n        s = word2;\\n        memset(&dp, -1, sizeof dp);\\n        return solve(0, 0);\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i = m ; i >=0; --i)\\n        {\\n            for(int j = n ; j >=0; --j)\\n            {\\n                if(i==m) // that means word1 is exhausted\\n                    dp[i][j] = n - j;\\n                else if(j==n)\\n                    dp[i][j] = m - i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[i][j] = 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]});\\n                }\\n                else\\n                    dp[i][j] = dp[i+1][j+1];\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        vector<vector<int>> dp(1+m, vector<int>(1+n, 0));\\n        for(int i=0; i <= m; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0)\\n                    dp[i][j] = j;\\n                else if(j==0)\\n                    dp[i][j] = i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else\\n                {\\n                    dp[i][j] = 1 + min({dp[i-1][j-1], dp[i][j-1], dp[i-1][j]});\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        // Iterative version of recursive approach\\n        // Since recursive approach rely on future value\\n        // we should start backward i.e. i=m j=n\\n        \\n        int m = word1.size();\\n        int n = word2.size();\\n        if(m < n)\\n            return minDistance(word2, word1);\\n        \\n        // Space optimized 1-D DP version\\n        vector<int> dp(1+n, 0);\\n        dp[n] = 0;\\n        int prev;\\n        for(int i = m; i >=0; --i)\\n        {\\n            prev = dp[n];\\n            for(int j = n ; j >=0; --j)\\n            {\\n                int oldDP = dp[j];\\n                if(i==m)\\n                    dp[j] = n-j;\\n                else if(j==n)\\n                    dp[j] = m-i;\\n                else if(word1[i]!=word2[j])\\n                {\\n                    dp[j] = 1 + min({dp[j], dp[j+1], prev});\\n                }\\n                else\\n                    dp[j] = prev;\\n                prev = oldDP;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028828,
                "title": "python-easy-understanding-beats-95-in-time",
                "content": "\\tfrom functools import cache\\n\\tclass Solution:\\n\\t\\tdef minDistance(self, word1: str, word2: str) -> int:\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dp(i, j):\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn j+1\\n\\t\\t\\t\\tif j == -1:\\n\\t\\t\\t\\t\\treturn i+1\\n\\n\\t\\t\\t\\tif word1[i] == word2[j]:\\n\\t\\t\\t\\t\\treturn dp(i-1,j-1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn min(\\n\\t\\t\\t\\t\\t\\tdp(i,j-1)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j-1)+1\\n\\t\\t\\t\\t\\t)\\n\\n\\t\\t\\treturn dp(len(word1)-1, len(word2)-1)",
                "solutionTags": [],
                "code": "\\tfrom functools import cache\\n\\tclass Solution:\\n\\t\\tdef minDistance(self, word1: str, word2: str) -> int:\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dp(i, j):\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn j+1\\n\\t\\t\\t\\tif j == -1:\\n\\t\\t\\t\\t\\treturn i+1\\n\\n\\t\\t\\t\\tif word1[i] == word2[j]:\\n\\t\\t\\t\\t\\treturn dp(i-1,j-1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn min(\\n\\t\\t\\t\\t\\t\\tdp(i,j-1)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j)+1,\\n\\t\\t\\t\\t\\t\\tdp(i-1,j-1)+1\\n\\t\\t\\t\\t\\t)\\n\\n\\t\\t\\treturn dp(len(word1)-1, len(word2)-1)",
                "codeTag": "Java"
            },
            {
                "id": 1011449,
                "title": "c-bottom-up-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.length();\\n        int n=word2.length();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++) {\\n            for(int j=0;j<=n;j++)  {\\n                if(i==0) \\n                    dp[i][j]=j;\\n                else if(j==0) \\n                    dp[i][j]=i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = 1+min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m=word1.length();\\n        int n=word2.length();\\n        int dp[m+1][n+1];\\n        for(int i=0;i<=m;i++) {\\n            for(int j=0;j<=n;j++)  {\\n                if(i==0) \\n                    dp[i][j]=j;\\n                else if(j==0) \\n                    dp[i][j]=i;\\n                else if(word1[i-1]==word2[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n                else \\n                    dp[i][j] = 1+min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1]));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746823,
                "title": "python3-dynamic-programming-solution-faster-than-94-less-than-85",
                "content": "```\\n\\'\\'\\'\\nsolution 1\\n\\'\\'\\'\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        # base case\\n        i = len(word1) - 1\\n        j = len(word2) - 1\\n        \\n        # recording repeating sub-questions\\n        memo = dict()  \\n        \\n        def dp(i, j) -> int:\\n            if i == -1: return j + 1\\n            if j == -1: return i + 1\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            if word1[i] == word2[j]:\\n                memo[(i, j)] = dp(i-1, j-1)\\n            else:\\n                memo[(i, j)] = min(\\n                    dp(i-1, j) + 1,\\n                    dp(i, j-1) + 1,\\n                    dp(i-1, j-1) + 1\\n                )\\n            return memo[(i, j)]\\n        \\n        return dp(i, j)\\n```\\nIf you want to get how it work and understand Chinese, please refer to: [\\u7F16\\u8F91\\u8DDD\\u79BB-\\u52A8\\u6001\\u89C4\\u5212](https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bian-ji-ju-li).",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nsolution 1\\n\\'\\'\\'\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        # base case\\n        i = len(word1) - 1\\n        j = len(word2) - 1\\n        \\n        # recording repeating sub-questions\\n        memo = dict()  \\n        \\n        def dp(i, j) -> int:\\n            if i == -1: return j + 1\\n            if j == -1: return i + 1\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            \\n            if word1[i] == word2[j]:\\n                memo[(i, j)] = dp(i-1, j-1)\\n            else:\\n                memo[(i, j)] = min(\\n                    dp(i-1, j) + 1,\\n                    dp(i, j-1) + 1,\\n                    dp(i-1, j-1) + 1\\n                )\\n            return memo[(i, j)]\\n        \\n        return dp(i, j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717692,
                "title": "c",
                "content": "reference: https://www.youtube.com/watch?v=We3YDTzNXEk&t=0s&list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr&index=8\\n\\n```\\npublic class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        if (word1 == string.Empty)\\n            return word2.Length;\\n        else if (word2 == string.Empty)\\n            return word1.Length;\\n        \\n        int [,] res = new int[word1.Length + 1, word2.Length + 1];\\n        \\n        for (int i = 0; i <= word1.Length; i++)\\n            res[i, 0] = i;\\n        \\n        for (int i = 1; i <= word2.Length; i++)\\n            res[0, i] = i;\\n        \\n        for (int i = 1; i <= word1.Length; i++)\\n            for (int j = 1; j <= word2.Length; j++)\\n                if (word1[i - 1] == word2[j - 1])\\n                    res[i, j] = res[i - 1, j - 1];\\n                else\\n                    res[i, j] = Math.Min(res[i - 1, j -1], Math.Min(res[i - 1, j], res[i, j - 1])) + 1;\\n                \\n        return res[word1.Length, word2.Length];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int MinDistance(string word1, string word2) {\\n        if (word1 == string.Empty)\\n            return word2.Length;\\n        else if (word2 == string.Empty)\\n            return word1.Length;\\n        \\n        int [,] res = new int[word1.Length + 1, word2.Length + 1];\\n        \\n        for (int i = 0; i <= word1.Length; i++)\\n            res[i, 0] = i;\\n        \\n        for (int i = 1; i <= word2.Length; i++)\\n            res[0, i] = i;\\n        \\n        for (int i = 1; i <= word1.Length; i++)\\n            for (int j = 1; j <= word2.Length; j++)\\n                if (word1[i - 1] == word2[j - 1])\\n                    res[i, j] = res[i - 1, j - 1];\\n                else\\n                    res[i, j] = Math.Min(res[i - 1, j -1], Math.Min(res[i - 1, j], res[i, j - 1])) + 1;\\n                \\n        return res[word1.Length, word2.Length];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 662931,
                "title": "edit-distance-cpp-c-pictorial-representation-easy-to-understand",
                "content": "This is the one of the very common dp question:\\n**Basic Intution**: to conver a character how many operations are needed. with this intution we can solve this question\\n_________________________________________________________________________________________________\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590934817.png)\\n\\nFigure 1\\n_________________________________________________________________________________________________\\n\\nreference from the above image we will try to consturct the dp matrix for the solution, later we will try to find the recurrence for this solution.\\n_________________________________________________________________________________________________\\n\\n\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590935332.png)\\n\\nFigure 2\\n_________________________________________________________________________________________________\\n\\n\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590935730.png)\\n\\nFigure 3\\n_________________________________________________________________________________________________\\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590936072.png)\\n\\nFigure 4\\n_________________________________________________________________________________________________\\n\\n\\nFinally...: The DP Matrix looks like \\n\\n![image](https://assets.leetcode.com/users/bhaviripudi/image_1590943224.png)\\n\\nFigure 5\\n_________________________________________________________________________________________________\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int _firstStrng = word1.size();\\n        int _secondString = word2. size();\\n        \\n        vector<vector<int>> dp(_firstStrng+1,vector<int>(_secondString+1,0));\\n        \\n        for(int row =0; row<= _firstStrng ; row++){\\n            for(int col=0; col<=_secondString; col++){\\n                if(row == 0 ) dp[row][col] = col;\\n                else if( col== 0 ) dp[row][col] = row;\\n                \\n                else if (word1 [row-1] == word2[col-1]) dp[row][col] = dp[row-1][col-1];\\n                else\\n                    dp[row][col] = 1+ min(min(dp[row][col-1], dp[row-1][col]), dp[row-1][col-1]);\\n            }\\n        }\\n        return dp[_firstStrng][_secondString];\\n    }\\n};\\n```\\n\\nNote: Please let me know in the comments.. if you require any other help, or edits in the post.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int _firstStrng = word1.size();\\n        int _secondString = word2. size();\\n        \\n        vector<vector<int>> dp(_firstStrng+1,vector<int>(_secondString+1,0));\\n        \\n        for(int row =0; row<= _firstStrng ; row++){\\n            for(int col=0; col<=_secondString; col++){\\n                if(row == 0 ) dp[row][col] = col;\\n                else if( col== 0 ) dp[row][col] = row;\\n                \\n                else if (word1 [row-1] == word2[col-1]) dp[row][col] = dp[row-1][col-1];\\n                else\\n                    dp[row][col] = 1+ min(min(dp[row][col-1], dp[row-1][col]), dp[row-1][col-1]);\\n            }\\n        }\\n        return dp[_firstStrng][_secondString];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662426,
                "title": "c-dp-bottom-up-simple-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        int **output = new int*[m+1];\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i]=new int[n+1];\\n        }\\n        //fill first row\\n        for(int j=0; j<=n; j++)\\n        {\\n            output[0][j]=j;\\n        }\\n        //fill first col\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i][0]=i;\\n        }\\n\\n        for(int i=1; i<=m; i++)\\n        {\\n            for(int j=1; j<=n; j++)\\n            {\\n                if(word1[m-i]==word2[n-j])\\n                {\\n                    output[i][j]= output[i-1][j-1];\\n                }\\n                else\\n                {\\n                     output[i][j]= min(output[i][j-1],min(output[i-1][j],output[i-1][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return output[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDistance(string word1, string word2) {\\n        int m = word1.size();\\n        int n = word2.size();\\n        int **output = new int*[m+1];\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i]=new int[n+1];\\n        }\\n        //fill first row\\n        for(int j=0; j<=n; j++)\\n        {\\n            output[0][j]=j;\\n        }\\n        //fill first col\\n        for(int i=0; i<=m; i++)\\n        {\\n            output[i][0]=i;\\n        }\\n\\n        for(int i=1; i<=m; i++)\\n        {\\n            for(int j=1; j<=n; j++)\\n            {\\n                if(word1[m-i]==word2[n-j])\\n                {\\n                    output[i][j]= output[i-1][j-1];\\n                }\\n                else\\n                {\\n                     output[i][j]= min(output[i][j-1],min(output[i-1][j],output[i-1][j-1])) + 1;\\n                }\\n            }\\n        }\\n        return output[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655602,
                "title": "python3-memoization-solution-98-95-faster",
                "content": "```\\nclass Solution:\\n    def dp(self,A,B,i,j,aux):\\n        global ans\\n        if aux[i][j]:\\n            return aux[i][j]\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if A[i-1] == B[j-1]:\\n            ans = self.dp(A,B,i-1,j-1,aux)\\n        else:\\n            ans = 1 + min(self.dp(A,B,i-1,j-1,aux), self.dp(A,B,i-1,j,aux), self.dp(A,B,i,j-1,aux))\\n        aux[i][j] = ans\\n        return ans\\n    \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0]*(n+1) for _ in range(m+1)]\\n        b=self.dp(word1,word2,m,n,dp)\\n        return b if m < 1 or n < 1 else dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dp(self,A,B,i,j,aux):\\n        global ans\\n        if aux[i][j]:\\n            return aux[i][j]\\n        if i==0:\\n            return j\\n        if j==0:\\n            return i\\n        if A[i-1] == B[j-1]:\\n            ans = self.dp(A,B,i-1,j-1,aux)\\n        else:\\n            ans = 1 + min(self.dp(A,B,i-1,j-1,aux), self.dp(A,B,i-1,j,aux), self.dp(A,B,i,j-1,aux))\\n        aux[i][j] = ans\\n        return ans\\n    \\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[[0]*(n+1) for _ in range(m+1)]\\n        b=self.dp(word1,word2,m,n,dp)\\n        return b if m < 1 or n < 1 else dp[m][n]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1720630,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1564737,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815300,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1920807,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815477,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1566473,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815034,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1570128,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1569955,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1568243,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1720630,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1564737,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815300,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1920807,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815477,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1566473,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1815034,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1570128,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1569955,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 1568243,
                "content": [
                    {
                        "username": "Jaiff",
                        "content": "I strongly suggest the reader to not go directly to the solution because you will miss out on the dopamine hit that solving this problem gives. If you want a hint, draw the various options on a paper. You can also see the repeating problem this way.  I am including a [screenshot](https://drive.google.com/file/d/1lj7S3x_Yl01kTeGPKMfVpEfHf_ubZ5V5/view?usp=sharing) of my drawing for your reference.  "
                    },
                    {
                        "username": "harshvardhanchand",
                        "content": "Thanks man was able to solve the question because of you"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "How insert will work? if there is a mismatch in between word1[0] and word2[0], then will insert the word2 char at index 0 and then increment i and j."
                    },
                    {
                        "username": "thepasterover",
                        "content": "Thank you man. If it wasnt for you I would have given up as soon as I landed on the question. Looked at solution call it a day. I gave it an hour. I wrote the recursive and dp solution"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "vaibhavsaxena533",
                        "content": "Thanks Bro."
                    },
                    {
                        "username": "buzz_light",
                        "content": "If this ain\\'t social service, I don\\'t know what else is. "
                    },
                    {
                        "username": "sk4142",
                        "content": "Your picture, which is worth more than a thousand words, made this problem an easy-medium. Thank you for the encouragement. "
                    },
                    {
                        "username": "thewickeffect",
                        "content": "Thanks for the encouragement! this was a fun problem. "
                    },
                    {
                        "username": "boshraw_hehe",
                        "content": "THANKS BROTHER/SISTER. MADE IT BECAUSE OF YOU. GOT A LITTLE INSPIRATION FROM SOLUTIONS, BUT IM GLAD I DIDN\\'T COPY IT."
                    },
                    {
                        "username": "SamRod33",
                        "content": "Like others have said, your message encouraged me to push on!!! I had given up but seeing others that felt the same, didnt give up, and found success gave me a lot of power to solve it too!"
                    },
                    {
                        "username": "shryshkmr",
                        "content": "You are GOD!!!!\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Thanks so much, you\\'re a saint! I solved it without looking at the solution."
                    },
                    {
                        "username": "12_utkarsh",
                        "content": "thanks for leaving this comment here, pushed me to solve it without any hints. you\\'re doing gods\\' work bro. "
                    },
                    {
                        "username": "bamboo_steam",
                        "content": "Thanks for your comment! It helped me a lot for not giving up thinking about this problem."
                    },
                    {
                        "username": "denar50",
                        "content": "Thanks for the comment mate. I had given up and your comment pushed me back at it."
                    },
                    {
                        "username": "kanjenuw",
                        "content": "With your picture I was able to solve it on my own! Thanks so much, very helpful!"
                    },
                    {
                        "username": "balleater",
                        "content": "the drawing helps a lot hopefully i can get this one on my own thanks!"
                    },
                    {
                        "username": "SaiTeja44d",
                        "content": "Thanks bro[@Sidharth Kumar](/Jaiff) I solved it on my own after seeing your comment "
                    },
                    {
                        "username": "sravan_csed",
                        "content": "Me too have solved this problem after reading this comment. Great example of how right approach would solve the problem instead of getting feared"
                    },
                    {
                        "username": "daring-calf",
                        "content": "[@alt909](/alt909)  Your comment pushed me and I solved my second dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "alt909",
                        "content": "I was going to do just that but your comment pushed me and I solved my first dp hard with no hints, feels good thanks."
                    },
                    {
                        "username": "vikram_kuruguntla",
                        "content": "http://www.stanford.edu/class/cs124/lec/med.pdf"
                    },
                    {
                        "username": "ryan-gang",
                        "content": "[@ajayvkamath10](/ajayvkamath10) \\nIn slide 5, they have mentioned, that they are gonna take `substitution_cost = 2`. \\nBut, in this LC question, `substitution_cost = 1`. \\nThe equation is actually `D[i-1][j-1] + substitution_cost`."
                    },
                    {
                        "username": "ajayvkamath10",
                        "content": "The alogorithm in this says D[i-1][j-1] + 2 in the third case when word1[i] \\u2260 word2[j]\\nIt must be D[i-1][j-1] + 1"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Brain damage"
                    },
                    {
                        "username": "omerfarooq",
                        "content": "brain is never gets damaged for working on problems...it gets stronger"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Agreed :("
                    },
                    {
                        "username": "zenfred",
                        "content": "Earlier today, the problem\\'s difficulty label was changed from Hard to Medium. Do you agree with the change? I\\'m afraid I would not. The DP solution for this problem is analogous to that of Regular Expression Matching and Wildcard Matching, both of which are Hards."
                    },
                    {
                        "username": "Movsar",
                        "content": "Unfortunately, I could not solve it by myself. Table below helped me to solve this question. \n**DON'T OPEN if you just started working on the question!**\n\n![screenshot](https://i.ibb.co/d61gvvm/IMG-0033.jpg)\n\n`return table[lastRow][lastColumn]`"
                    },
                    {
                        "username": "csy1000",
                        "content": "Need clarification of the question..\\n\\nRegarding to the insert/delete operation, does it have to be the end of the word or any position?"
                    },
                    {
                        "username": "Ayush379",
                        "content": "any position\\n"
                    },
                    {
                        "username": "mulchb",
                        "content": "any position\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\n\\nIf either word1 or word2 is empty, return the maximum length of the two strings as the minimum edit distance.\\n\\nIf word1 is equal to word2, return 0 as the minimum edit distance.\\n\\nCreate a 2D array dp of size (m+1) x (n+1), where m and n are the lengths of word1 and word2 respectively. Each element of the array dp[i][j] represents the minimum edit distance between the first i characters of word1 and the first j characters of word2.\\n\\nInitialize the first row of dp to the values from 0 to n, and the first column of dp to the values from 0 to m. This is because the minimum edit distance between an empty string and a string of length j is j, and vice versa.\\n\\nIterate over each character in word1 and word2 and fill in the rest of the dp array based on the following conditions:\\n\\nIf i is 0, dp[i][j] is equal to j, because the minimum edit distance between an empty string and a string of length j is j.\\n\\nIf j is 0, dp[i][j] is equal to i, because the minimum edit distance between a string of length i and an empty string is i.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are equal, dp[i][j] is equal to dp[i-1][j-1], because no edit is needed.\\n\\nIf the characters at positions i-1 and j-1 of word1 and word2 respectively are not equal, dp[i][j] is equal to 1 + min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]), where dp[i-1][j-1] represents the minimum edit distance after replacing the character at position i-1 in word1 with the character at position j-1 in word2, dp[i][j-1] represents the minimum edit distance after inserting the character at position j-1 of word2 into word1, and dp[i-1][j] represents the minimum edit distance after deleting the character at position i-1 of word1.\\n\\nThe final answer is the value of dp[m][n], which represents the minimum edit distance between the entire strings word1 and word2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code for Help:-\\nhttps://leetcode.com/problems/edit-distance/solutions/3231491/6-ms-solution/"
                    },
                    {
                        "username": "priyanshu25",
                        "content": "Found this video really useful https://youtu.be/WgmZ-5qAHJ8 . Do watch if you are stuck or are a beginner to Dynamic Programming."
                    },
                    {
                        "username": "greensabath",
                        "content": "This video is incorrect right off the bat."
                    },
                    {
                        "username": "Gauravsah",
                        "content": "For video Editorial of Edit Distance visit this Youtube link. Both Top down and Bottom up approaches are taught in this video.\\nhttps://youtu.be/MQ7ErD7mkYE"
                    },
                    {
                        "username": "greensabath",
                        "content": "The person stops speaking English completely 5 minutes in."
                    },
                    {
                        "username": "beginner_20",
                        "content": "Hii All, \\nI have a doubt, When I submit same code again and again then I m getting different runtime and different memory usage. Is it a bug of leetcode or they are using different tastcases each time."
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "No it's completely fine. It's same code and same test case, the runtime depends on CPU throttling, thread context switching, Garbage collection, etc. If the CPU's temperature is high your application will take more time to complete. You might have noticed it while playing game. \nGC is a heavy operation and this can stop the show while it's running. It depends on the GC algo that LC is using. These are just concepts and internals of OS and JVM. Read about it, you will understand. "
                    }
                ]
            },
            {
                "id": 2025451,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1816568,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1814605,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1572780,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1568893,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1571170,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 2071330,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1986248,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1933173,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1815135,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "It may be called \\'medium\\', but it\\'s definitely at the top border between medium and hard."
                    },
                    {
                        "username": "wyldbill",
                        "content": "This is actually the [Levenshtein Distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\nIt is one of several different \"[Edit Distance](https://en.wikipedia.org/wiki/Edit_distance)\" problems (Hamming, Jaro, LCS, etc.)\n"
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "Please help me why LCS is Not Working here \\n\\n![image.png](https://assets.leetcode.com/users/images/6caacef5-7d03-46d7-ba7e-38925334ca7e_1677376352.0691617.png)"
                    },
                    {
                        "username": "pant_harshit007",
                        "content": "W1 : HORSE\\nW2: ROS\\nUNION: ROS\\nM-C = 2\\nN-C = 0\\nANS = 2\\n\\nACTUAL RESULT = 3"
                    },
                    {
                        "username": "SamoylenkoDmitry",
                        "content": "I think, because we have replacements"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Because order of characters is important here."
                    },
                    {
                        "username": "Sundow",
                        "content": "Many answers solve the problems but failed to explain why dynamic programming works  and why this problem has optimal structure. I have found a paper that contains a detail proof to the solution. Here is the link: http://www.inrg.csie.ntu.edu.tw/algorithm2013/homework/Wagner-74.pdf"
                    },
                    {
                        "username": "AyonAlfa",
                        "content": "hey are u alive??? then please reply :)"
                    },
                    {
                        "username": "p_next",
                        "content": "The min number of steps converting \"horse\" to \"ros\" I've found is 4:\\n\\n 1. horse -> orse (remove 'h')\\n  \\n 2. orse   -> ors   (remove 'e')\\n\\n 3. ors     -> oros (insert 'o')\\n\\n 4. oros   -> ros   (remove 'o')\\n\\nI can't figure out how to convert them in only 3 steps,pls help me,thx!"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "prompt_07",
                        "content": "horse -> rorse (replace \\'h\\' with \\'r\\')\\nrorse -> rose (remove \\'r\\')\\nrose -> ros (remove \\'e\\')"
                    },
                    {
                        "username": "quattrozhou",
                        "content": "My code pass the online judge, but I found my code could not correctly solve this problem:\\n\"abcdxabcde\", \"abcdeabcdx\"\\ngreedy method will likely fail on this test case.\\nThanks! :)"
                    },
                    {
                        "username": "seventhrankpawn",
                        "content": "I ask this question at Microsoft for the AI teams.\\n\\nIt\\'s fundamental to many derivative algorithms for sequence pattern matching, processing, error correction, error rate estimation. \\n\\nHeck most recently I\\'ve seen it applied to the attention outputs of a transformer. \\n\\nIf you\\'re serious about AI, you should know this snazzy DP."
                    },
                    {
                        "username": "ankush920",
                        "content": "ye question karte hue us time ki yaad aa gyi jab me or mera dost apni crush  ka love percentage nikalte the : )"
                    },
                    {
                        "username": "sjames8888",
                        "content": "\nfor anyone wishing to get a good hint without looking at a solution - It may be best to  think of a top down solution where \n\n1. we define a recursive function taking pointers i, j which represent substring of words 1 and 2 - these will be initialised to lengths of two strings.\n\n2. we will probably need to add memoisation later for [i][]j] but not needed for small examples like horse, hor\n\n3. we compute 3 costs - ic, dc, rp for insert, delete, replace\n\n4. for insert we call recursive function where i is reduced by 1 implying we want best cost for smaller substrng on i and cost is plus 1\n\n5. for delete as above but j is reduced by 1\n\n6. for base case if we arrive  into function when i is 0 means cost to get to substring j from empty string i is j we need to add j chars \n\n7. base case arrive where j is 0 we need cost to reduce i to empty string which is i\n\n8. replace is call where both i and j reduce by 1 but we add x where x is 1 when charAt(i-1) != charAt(j-1) else for match x is 0 implying we replace at no cost and cost for larger string i is same as that for both reduced sub strings\n\n9.  we return min of 3 above costs\n\n10. for memoise hand in int[s1.length+1]s2.length+1] before calcs above we check if we have computed - this pivots into the better dp solution which will now be obvious \n\n    if (dp[i][j] != 0) {\n            return dp[i][j];\n        }\n\n return dp[i][j] = min;\n\n11. try it on this case as well but only with above optimisation - and no printing debug!\n\n  @Test\n    void case3() {\n        final var res = new EditDistance().minDistance(\"dinitrophenylhydrazine\", \"acetylphenylhydrazine\");\n        Assertions.assertEquals(6, res);\n    }\n\nand here is trace for above where we print all these values for horse -> ros\n\n\ndepth = 6,  i = 1, j = 1, (ic = 2, dc = 2, rp = 1, x = 1), min = 1, si = h, sj = r \ndepth = 5,  i = 1, j = 2, (ic = 3, dc = 2, rp = 2, x = 1), min = 2, si = h, sj = ro \ndepth = 4,  i = 1, j = 3, (ic = 4, dc = 3, rp = 3, x = 1), min = 3, si = h, sj = ros \ndepth = 5,  i = 2, j = 1, (ic = 2, dc = 3, rp = 2, x = 1), min = 2, si = ho, sj = r \ndepth = 4,  i = 2, j = 2, (ic = 3, dc = 3, rp = 1, x = 0), min = 1, si = ho, sj = ro \ndepth = 3,  i = 2, j = 3, (ic = 4, dc = 2, rp = 3, x = 1), min = 2, si = ho, sj = ros \ndepth = 4,  i = 3, j = 1, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hor, sj = r \ndepth = 3,  i = 3, j = 2, (ic = 2, dc = 3, rp = 3, x = 1), min = 2, si = hor, sj = ro \ndepth = 2,  i = 3, j = 3, (ic = 3, dc = 3, rp = 2, x = 1), min = 2, si = hor, sj = ros \ndepth = 3,  i = 4, j = 1, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = hors, sj = r \ndepth = 2,  i = 4, j = 2, (ic = 3, dc = 4, rp = 3, x = 1), min = 3, si = hors, sj = ro \ndepth = 1,  i = 4, j = 3, (ic = 3, dc = 4, rp = 2, x = 0), min = 2, si = hors, sj = ros \ndepth = 2,  i = 5, j = 1, (ic = 4, dc = 6, rp = 5, x = 1), min = 4, si = horse, sj = r \ndepth = 1,  i = 5, j = 2, (ic = 4, dc = 5, rp = 4, x = 1), min = 4, si = horse, sj = ro \ndepth = 0,  i = 5, j = 3, (ic = 3, dc = 5, rp = 4, x = 1), min = 3, si = horse, sj = ros \n\n\n\n\n"
                    },
                    {
                        "username": "Mrinal2100",
                        "content": "you provided the solution , not the tip"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "<details>\n<summary>(Click) A hint which might be useful:</summary>\nTime & Space complexity is O(word1.len * word2.len).\n</details>"
                    }
                ]
            },
            {
                "id": 1814571,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1798109,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1574248,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 1573850,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2068551,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2053497,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2052528,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2046986,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2034681,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2028500,
                "content": [
                    {
                        "username": "Zein4",
                        "content": "It was a good run..."
                    },
                    {
                        "username": "pandey_nikhil",
                        "content": "what is the name \"EDIT DISTANCE \" suggest with respect to this question , I mean why the question name is EDIT DISTANCE ? I\\'m curious \\uD83E\\uDD14about it."
                    },
                    {
                        "username": "preetisushma",
                        "content": "https://codemummy.blogspot.com/2020/08/edit-distance-dynamic-programming.html\\n\\nvery easy"
                    },
                    {
                        "username": "greensabath",
                        "content": "This link doesn\\'t explain anything that the code is doing. It also does not use the minDistance function with 2 parms. It uses 2 additional parms which it does not explain what they are."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got in on an interview (c)"
                    },
                    {
                        "username": "eric0831",
                        "content": "By now I believe most of you understand dp[i - 1][j - 1] for `replace`, but how about `insert` and `delete`?\\n\\nFor instance, if we want to match `abbc` to `acc`, we need to take a look of the sub problem, what is the minimum steps we need to make `abb` to match `ac`.\\nHere we have our first case when 2 charactre are the same, we move both pointer to the left  `if(s1.charAt(j - 1) == s2.charAt(j - 1) ` -> `f[i][j] = f[i - 1][j - 1]`\\nWe continue our discussion here, now our goal is to make `abb` to match `ac`, three things we can do here, which is  `replace` , `insert`, and `delete`,\\nFor  `replace`, we replace the last character `b` to `c` and we will have `abc` to match `ac`, and our sub problem will be the min steps to match `ab` to `a`, which gives us `f[i][j] = f[i - 1][j - 1]`\\nFor `delete`, which means we delete the last character, now we need to match `ab` to `ac` which gives us `f[i][j] = f[i - 1][j - 1]`\\n\\nThe hardest part for this problem is to understand insert, so for our `abb` to match `ac` , we can add a `c` to our first string, and we will have `abbc` to match `ac`, now our sub problem become to mach `abb` to `a`, at this point we need to move our second string to the left, which gives us `f[i][j] = f[i][j - 1]`\\n\\nI\\'m sure from here you are smart enough to firgure out the rest."
                    },
                    {
                        "username": "mrigankkhandelwal300",
                        "content": "Hey all,\\n\\nI solved this problem using DP with TC O(mn). However it beats only 12~15% solutions. How do I improve time complexity beyond my algorithm i.e. what tricks can I use to give my code an edge with respect to time complexity."
                    },
                    {
                        "username": "zenfred",
                        "content": "1. Try waiting a while and resubmitting. LC servers are not stable in terms of runtime.\\n2. If your solution still runs slow, post the code so that we can diagnose it for you."
                    },
                    {
                        "username": "abhipatwari",
                        "content": "what\\'s different with use case \"distance\" and \"springbok\"?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "WTF !!! I some how solved this shit !!"
                    },
                    {
                        "username": "lipsapatel25",
                        "content": "This video explains the problem very well\\nhttps://youtu.be/CELw4LKLSeE"
                    },
                    {
                        "username": "bogdanctx",
                        "content": "This is easily done if Levenshtein distance algorithm is applied."
                    },
                    {
                        "username": "sad_python",
                        "content": "THIS IS HARD!!\\n"
                    }
                ]
            },
            {
                "id": 2018671,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 2007725,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 2001869,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1921440,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1919830,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1816391,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815338,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815308,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815230,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            },
            {
                "id": 1815225,
                "content": [
                    {
                        "username": "lin25_",
                        "content": "not them changing this to a medium"
                    },
                    {
                        "username": "dhruvsakariya",
                        "content": "What I thought was to do actual operations on strings \n\n\n    // Insert\n    word1.insert(i, 1, word2[j]);\n\n    // Delete\n    word1.erase(i, 1);\n\n    // Replace\n    word1.replace(i, 1, 1, word2[j]);\n\nBut it is not the way this problem solve. If you are thinking same like me you have to change your approach little bit. instead of doing this heavy operation on each charactor maintain helper row & column on 0th index with some value and do the operation using that helper row & column.\n\nHappy coding :)\n"
                    },
                    {
                        "username": "yash_4980",
                        "content": "The time when TLE on recursive approach don\\'t hurt you more, but your are happy of finding a brute force to the problem and enjoy the fact that now, you have good skills at creating recursive solutions than before."
                    },
                    {
                        "username": "Arunabh_Gupta",
                        "content": "I solved it on my own!!! Never been so much happy :-)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "Just can\\'t believe I have solved it without the solution!"
                    },
                    {
                        "username": "MukulDev007",
                        "content": "Draw the recursion tree for this problem, and then find the relation between indexes of both word.\\nWhat to do when the words match? If they dont match, try performing the 3 operations, see the index.\\nAfter recursive solution is established, try DP."
                    },
                    {
                        "username": "Arnius",
                        "content": "this seems challenging. nice lets see!"
                    },
                    {
                        "username": "Finesse",
                        "content": "A very similar problem: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)"
                    },
                    {
                        "username": "Zein4",
                        "content": "does it help if I solve an easier related problem? if so what is the name of the question"
                    },
                    {
                        "username": "aitachii",
                        "content": "wat\\nive read the paper but i still dont understand why those formulas were used"
                    }
                ]
            }
        ]
    }
]