[
    {
        "title": "Construct Smallest Number From DI String",
        "question_content": "You are given a 0-indexed string pattern of length n consisting of the characters 'I' meaning increasing and 'D' meaning decreasing.\nA 0-indexed string num of length n + 1 is created using the following conditions:\n\n\tnum consists of the digits '1' to '9', where each digit is used at most once.\n\tIf pattern[i] == 'I', then num[i] < num[i + 1].\n\tIf pattern[i] == 'D', then num[i] > num[i + 1].\n\nReturn the lexicographically smallest possible string num that meets the conditions.\n&nbsp;\nExample 1:\n\nInput: pattern = \"IIIDIDDD\"\nOutput: \"123549876\"\nExplanation:\nAt indices 0, 1, 2, and 4 we must have that num[i] < num[i+1].\nAt indices 3, 5, 6, and 7 we must have that num[i] > num[i+1].\nSome possible values of num are \"245639871\", \"135749862\", and \"123849765\".\nIt can be proven that \"123549876\" is the smallest possible num that meets the conditions.\nNote that \"123414321\" is not possible because the digit '1' is used more than once.\nExample 2:\n\nInput: pattern = \"DDD\"\nOutput: \"4321\"\nExplanation:\nSome possible values of num are \"9876\", \"7321\", and \"8742\".\nIt can be proven that \"4321\" is the smallest possible num that meets the conditions.\n\n&nbsp;\nConstraints:\n\n\t1 <= pattern.length <= 8\n\tpattern consists of only the letters 'I' and 'D'.",
        "solutions": [
            {
                "id": 2422380,
                "title": "java-c-python-easy-reverse",
                "content": "# **Intuition**\\nIf we meet `I`,`II`,`III`...\\nwe can greedily pick the smallest numebr.\\n\\nIf we meet `D`,\\nwe can pick second smallest and then pick the smallest,\\nlike 21.\\n\\nIf we meet `D`,\\nwe can pick the third smallest, then the second smallest, then the smallest,\\nlike 321.\\n<br>\\n\\n# **Explanation**\\n1 2 3 4 5 6 7 8 9\\nD D I D D I D D\\n\\nMatch the input string and the sequence 1,2,3,4,5,6,7,8,9.\\nReverse all numbers between \"I\".\\n\\nFor example:\\nfirst \\'I\\' at 3, then reverse `1,2,3`, we have `3,2,1`\\nsecond \\'I\\' at 6, then reverse `4,5,6`, we have `6,5,4`\\nReverse the last group `7,8,9`, we have `9,8,7`\\n\\nFinal result for D D I D D I D D,\\nis `3,2,1,6,5,4,9,8,7`\\n\\nWe can have multiple approach to implement this process.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public String smallestNumber(String s) {\\n        StringBuilder res = new StringBuilder(), stack = new StringBuilder();\\n        for (int i = 0; i <= s.length(); i++) {\\n            stack.append((char)(\\'1\\' + i));\\n            if (i == s.length() || s.charAt(i) == \\'I\\') {\\n                res.append(stack.reverse());\\n                stack = new StringBuilder();\\n            }\\n        }\\n        return res.toString();\\n    }\\n```\\n**C++**\\n```cpp\\n   string smallestNumber(string s) {\\n        string res, stack;\\n        for (int i = 0; i <= s.length(); i++) {\\n            stack.push_back(\\'1\\' + i);\\n            if (i == s.length() || s[i] == \\'I\\') {\\n                while (!stack.empty()) {\\n                    res.push_back(stack.back());\\n                    stack.pop_back();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    string smallestNumber(string s) {\\n        string res;\\n        int n = s.size(), j = 0;\\n        for (int i = 0; i <= s.size(); ++i) {\\n            res.push_back(\\'1\\' + i);\\n            if (i == n || s[i] == \\'I\\') {\\n                reverse(res.begin() + j, res.end());\\n                j = i + 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def smallestNumber(self, s):\\n        res, stack = [], []\\n        for i,c in enumerate(s + \\'I\\', 1):\\n            stack.append(str(i))\\n            if c == \\'I\\':\\n                res += stack[::-1]\\n                stack = []\\n        return \\'\\'.join(res)\\n\\n    def smallestNumber(self, s):\\n        res = []\\n        for i,c in enumerate(s + \\'I\\', 1):\\n            if c == \\'I\\':\\n                res += range(i, len(res), -1)\\n        return \\'\\'.join(map(str,res))\\n\\n    def smallestNumber(self, s):\\n        res, pool = [], list(\\'987654321\\')\\n        for k in map(len,s.split(\\'I\\')):\\n            res += [pool.pop() for _ in range(k + 1)][::-1]\\n        return \\'\\'.join(res)\\n```\\n<br>\\n\\n# **More DI string problems**\\n[942. DI String Match](https://leetcode.com/problems/di-string-match/discuss/194904/C%2B%2BJavaPython-Straight-Forward)\\n[903. Valid Permutations for DI Sequence](https://leetcode.com/problems/valid-permutations-for-di-sequence/discuss/168278/C%2B%2BJavaPython-DP-Solution-O(N2))\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public String smallestNumber(String s) {\\n        StringBuilder res = new StringBuilder(), stack = new StringBuilder();\\n        for (int i = 0; i <= s.length(); i++) {\\n            stack.append((char)(\\'1\\' + i));\\n            if (i == s.length() || s.charAt(i) == \\'I\\') {\\n                res.append(stack.reverse());\\n                stack = new StringBuilder();\\n            }\\n        }\\n        return res.toString();\\n    }\\n```\n```cpp\\n   string smallestNumber(string s) {\\n        string res, stack;\\n        for (int i = 0; i <= s.length(); i++) {\\n            stack.push_back(\\'1\\' + i);\\n            if (i == s.length() || s[i] == \\'I\\') {\\n                while (!stack.empty()) {\\n                    res.push_back(stack.back());\\n                    stack.pop_back();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    string smallestNumber(string s) {\\n        string res;\\n        int n = s.size(), j = 0;\\n        for (int i = 0; i <= s.size(); ++i) {\\n            res.push_back(\\'1\\' + i);\\n            if (i == n || s[i] == \\'I\\') {\\n                reverse(res.begin() + j, res.end());\\n                j = i + 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def smallestNumber(self, s):\\n        res, stack = [], []\\n        for i,c in enumerate(s + \\'I\\', 1):\\n            stack.append(str(i))\\n            if c == \\'I\\':\\n                res += stack[::-1]\\n                stack = []\\n        return \\'\\'.join(res)\\n\\n    def smallestNumber(self, s):\\n        res = []\\n        for i,c in enumerate(s + \\'I\\', 1):\\n            if c == \\'I\\':\\n                res += range(i, len(res), -1)\\n        return \\'\\'.join(map(str,res))\\n\\n    def smallestNumber(self, s):\\n        res, pool = [], list(\\'987654321\\')\\n        for k in map(len,s.split(\\'I\\')):\\n            res += [pool.pop() for _ in range(k + 1)][::-1]\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2422180,
                "title": "c-clean-stack-solution",
                "content": "```\\nstring smallestNumber(string pattern) {\\n        string result;\\n        stack<int> s;\\n        for (int i = 0; i <= pattern.length(); i++)\\n        {\\n            s.push(i + 1);\\n            if (i == pattern.length() || pattern[i] == \\'I\\')\\n            {\\n                while (!s.empty())\\n                {\\n                    result += to_string(s.top());\\n                    s.pop();\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring smallestNumber(string pattern) {\\n        string result;\\n        stack<int> s;\\n        for (int i = 0; i <= pattern.length(); i++)\\n        {\\n            s.push(i + 1);\\n            if (i == pattern.length() || pattern[i] == \\'I\\')\\n            {\\n                while (!s.empty())\\n                {\\n                    result += to_string(s.top());\\n                    s.pop();\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422098,
                "title": "c-using-stack-o-n-very-simple-and-easy-to-understand",
                "content": "<b>Up vote if you like the Solution\\n# Simple approach is to by using a stack. When u see a \\'D\\' or \\'I\\' simply push the number to stack and when see \\'I\\' add stack elements to answer.\\nHow I reached to proceed with stack : The pattern DDD => 321, suggest that it can be solved using stack - as stack can be used for pattern where there is some kind of reverse pattern.\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<int> s;\\n        string ans = \"\";\\n        if(pattern[0] == \\'I\\') ans += \\'1\\';\\n        else s.push(\\'1\\');\\n        for(int i = 1; i <= pattern.size(); i++){\\n            if(pattern[i-1] == \\'I\\'){\\n                while(!s.empty()){  ans += s.top(); s.pop(); }\\n            }\\n            s.push(\\'0\\' + i+1);\\n        }\\n        while(!s.empty()){ ans += s.top(); s.pop();  }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<int> s;\\n        string ans = \"\";\\n        if(pattern[0] == \\'I\\') ans += \\'1\\';\\n        else s.push(\\'1\\');\\n        for(int i = 1; i <= pattern.size(); i++){\\n            if(pattern[i-1] == \\'I\\'){\\n                while(!s.empty()){  ans += s.top(); s.pop(); }\\n            }\\n            s.push(\\'0\\' + i+1);\\n        }\\n        while(!s.empty()){ ans += s.top(); s.pop();  }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422290,
                "title": "dfs-vs-greedy",
                "content": "I solved it as DFS during the contest. Constraints allow that.\\n\\nThen, I realized that we can start with the smallest possible answer - \"123456789\" (all numbers increasing).\\n\\nIf we have decreasing intervals, we reverse the string for those intervals. \\n\\nFor example, if the pattern is \"IIIDDDID\", we will reverse `4567`and `89`, and the result will be `123 7654 98`.\\n\\n#### Greedy\\n**C++**\\n```cpp\\nstring smallestNumber(string p) {\\n    string res;\\n    for (int i = 0, j = 0; i <= p.size(); ++i) {\\n        res.push_back(\\'1\\' + i);\\n        if (i == p.size() || p[i] == \\'I\\') {\\n            reverse(begin(res) + j, end(res));\\n            j = i + 1;\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n#### DFS\\nJust try all combinations, based on the pattern. We use `mask` to make sure numbers do not repeat.\\n**C++**\\n```cpp\\nint dfs(string& p, int i, int n, int mask) {\\n    if (i > p.size())\\n        return n;\\n    int res = INT_MAX, last = n % 10, increment = i == 0 || p[i - 1] == \\'I\\';\\n    for (int d = 1; res == INT_MAX && d <= 9; ++d)\\n        if ((mask & (1 << d)) == 0 && last < d == increment)\\n            res = dfs(p, i + 1, n * 10 + d, mask + (1 << d));               \\n    return res;\\n}\\nstring smallestNumber(string pattern) {\\n    return to_string(dfs(pattern, 0, 0, 0));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring smallestNumber(string p) {\\n    string res;\\n    for (int i = 0, j = 0; i <= p.size(); ++i) {\\n        res.push_back(\\'1\\' + i);\\n        if (i == p.size() || p[i] == \\'I\\') {\\n            reverse(begin(res) + j, end(res));\\n            j = i + 1;\\n        }\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint dfs(string& p, int i, int n, int mask) {\\n    if (i > p.size())\\n        return n;\\n    int res = INT_MAX, last = n % 10, increment = i == 0 || p[i - 1] == \\'I\\';\\n    for (int d = 1; res == INT_MAX && d <= 9; ++d)\\n        if ((mask & (1 << d)) == 0 && last < d == increment)\\n            res = dfs(p, i + 1, n * 10 + d, mask + (1 << d));               \\n    return res;\\n}\\nstring smallestNumber(string pattern) {\\n    return to_string(dfs(pattern, 0, 0, 0));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422249,
                "title": "python3-greedy",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/abc9891d642b2454c148af46a140ff3497f7ce3c) for solutions of weekly 306. \\n\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        ans = [1]\\n        for ch in pattern: \\n            if ch == \\'I\\': \\n                m = ans[-1]+1\\n                while m in ans: m += 1\\n                ans.append(m)\\n            else: \\n                ans.append(ans[-1])\\n                for i in range(len(ans)-1, 0, -1): \\n                    if ans[i-1] == ans[i]: ans[i-1] += 1\\n        return \\'\\'.join(map(str, ans))\\n```\\n\\nFollowing @lee215\\'s solution\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        ans = []\\n        stack = []\\n        for i in range(len(pattern)+1): \\n            stack.append(str(i+1))\\n            if i == len(pattern) or pattern[i] == \\'I\\': \\n                while stack: ans.append(stack.pop())\\n        return \\'\\'.join(ans) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        ans = [1]\\n        for ch in pattern: \\n            if ch == \\'I\\': \\n                m = ans[-1]+1\\n                while m in ans: m += 1\\n                ans.append(m)\\n            else: \\n                ans.append(ans[-1])\\n                for i in range(len(ans)-1, 0, -1): \\n                    if ans[i-1] == ans[i]: ans[i-1] += 1\\n        return \\'\\'.join(map(str, ans))\\n```\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        ans = []\\n        stack = []\\n        for i in range(len(pattern)+1): \\n            stack.append(str(i+1))\\n            if i == len(pattern) or pattern[i] == \\'I\\': \\n                while stack: ans.append(stack.pop())\\n        return \\'\\'.join(ans) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422337,
                "title": "c-backtracking-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    string res=\"987654321\"; // max possible \\n    string smallestNumber(string pattern) {\\n        string s=\"\"; \\n        vector<int> vis(10,0);\\n        fun(vis,pattern,-1,s);\\n        return res;\\n    }\\n    void fun(vector<int>& vis,string& p,int i,string& s)\\n    {\\n        if(i==p.length())\\n        {\\n            if(res>s) // storing the min in res\\n                res=s;\\n            return;\\n        }\\n        \\n        if(i==-1)// choosing the first digit\\n        {\\n            for(int j=1;j<=9;j++)\\n            {\\n                if(vis[j]==0)\\n                {\\n                    vis[j]=1;// setting the vis\\n                    s+=j+\\'0\\'; // adding the digit j\\n                    fun(vis,p,i+1,s);\\n                    s.pop_back(); // removing the digit j, to go for other options\\n                    vis[j]=0; // reseting the vis \\n                }\\n            }\\n        }\\n        else\\n        {\\n            if(p[i]==\\'D\\')\\n            {\\n                int t=s[s.length()-1]-\\'0\\';\\n                for(int j=t-1;j>=1;j--)\\n                {\\n                    if(vis[j]==0)\\n                    {\\n                        vis[j]=1;\\n                        s+=j+\\'0\\';\\n                        fun(vis,p,i+1,s);\\n                        s.pop_back();\\n                        vis[j]=0;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                int t=s[s.length()-1]-\\'0\\';\\n                for(int j=t+1;j<=9;j++)\\n                {\\n                    if(vis[j]==0)\\n                    {\\n                        vis[j]=1;\\n                        s+=j+\\'0\\';\\n                        fun(vis,p,i+1,s);\\n                        s.pop_back();\\n                        vis[j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string res=\"987654321\"; // max possible \\n    string smallestNumber(string pattern) {\\n        string s=\"\"; \\n        vector<int> vis(10,0);\\n        fun(vis,pattern,-1,s);\\n        return res;\\n    }\\n    void fun(vector<int>& vis,string& p,int i,string& s)\\n    {\\n        if(i==p.length())\\n        {\\n            if(res>s) // storing the min in res\\n                res=s;\\n            return;\\n        }\\n        \\n        if(i==-1)// choosing the first digit\\n        {\\n            for(int j=1;j<=9;j++)\\n            {\\n                if(vis[j]==0)\\n                {\\n                    vis[j]=1;// setting the vis\\n                    s+=j+\\'0\\'; // adding the digit j\\n                    fun(vis,p,i+1,s);\\n                    s.pop_back(); // removing the digit j, to go for other options\\n                    vis[j]=0; // reseting the vis \\n                }\\n            }\\n        }\\n        else\\n        {\\n            if(p[i]==\\'D\\')\\n            {\\n                int t=s[s.length()-1]-\\'0\\';\\n                for(int j=t-1;j>=1;j--)\\n                {\\n                    if(vis[j]==0)\\n                    {\\n                        vis[j]=1;\\n                        s+=j+\\'0\\';\\n                        fun(vis,p,i+1,s);\\n                        s.pop_back();\\n                        vis[j]=0;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                int t=s[s.length()-1]-\\'0\\';\\n                for(int j=t+1;j<=9;j++)\\n                {\\n                    if(vis[j]==0)\\n                    {\\n                        vis[j]=1;\\n                        s+=j+\\'0\\';\\n                        fun(vis,p,i+1,s);\\n                        s.pop_back();\\n                        vis[j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422725,
                "title": "python-interesting-o-1-solution",
                "content": "Whenever we encounter a \\'D\\', we gotta append a greater value than it used to be in the list.\\n\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        dq = [1] # [1,2,3,5,4,6]\\n        tmp = [] # []\\n        i = 2\\n        for p in pattern:\\n            if p == \\'I\\':\\n                while tmp:\\n                    dq.append(tmp.pop())\\n                dq.append(i)\\n                i += 1\\n            else:\\n                tmp.append(dq.pop())\\n                dq.append(i)\\n                i += 1\\n        while tmp:\\n            dq.append(tmp.pop())\\n        s = \\'\\'\\n        for i in dq:\\n            s += str(i)\\n        return s\\n    \\n```\\n\\nTime: `O(N)=O(1)`\\nSpace: `O(N)=O(1)`\\nwhere `N = len(pattern) = O(9)`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        dq = [1] # [1,2,3,5,4,6]\\n        tmp = [] # []\\n        i = 2\\n        for p in pattern:\\n            if p == \\'I\\':\\n                while tmp:\\n                    dq.append(tmp.pop())\\n                dq.append(i)\\n                i += 1\\n            else:\\n                tmp.append(dq.pop())\\n                dq.append(i)\\n                i += 1\\n        while tmp:\\n            dq.append(tmp.pop())\\n        s = \\'\\'\\n        for i in dq:\\n            s += str(i)\\n        return s\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422405,
                "title": "c-0ms-100-fast-brute-force-swaping-simple",
                "content": "**First time i was able to solved 3 questions in contest** \\n### PLEASE UPVOTE\\nJust use brute force and use swap func.\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) \\n    {\\n        int n=pattern.size()+1;\\n        string ans=\"\";\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans.push_back(i+\\'0\\');\\n        }\\n        for(int i=0;i<n-1;i++)             // just checking for n-1 times\\n        {\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(pattern[j]==\\'I\\')\\n                {\\n                    if(ans[j]>ans[j+1])\\n                    {\\n                        swap(ans[j],ans[j+1]);\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans[j]<ans[j+1])\\n                    {\\n                        swap(ans[j],ans[j+1]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) \\n    {\\n        int n=pattern.size()+1;\\n        string ans=\"\";\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans.push_back(i+\\'0\\');\\n        }\\n        for(int i=0;i<n-1;i++)             // just checking for n-1 times\\n        {\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(pattern[j]==\\'I\\')\\n                {\\n                    if(ans[j]>ans[j+1])\\n                    {\\n                        swap(ans[j],ans[j+1]);\\n                    }\\n                }\\n                else\\n                {\\n                    if(ans[j]<ans[j+1])\\n                    {\\n                        swap(ans[j],ans[j+1]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423299,
                "title": "python3-visual-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/6d5cb992-32e3-4bdf-92b4-97c486aa6d85_1660460964.4023652.png)\\n\\nLets intialize the array with the most minimum possible number sequence of 123456789.\\nWhever there is a disparity,swap like how we do sifting in min-heap until the disparity is resolved.\\nEg; here the disparity we see first is between 4 and 5. To be in decreasing order, they need to be 5,4. Hence we swap them once.\\n\\nThe next disparity arises for 6,7. After swap: 7,6,8,9.\\n\\nNext disparity 6,8.\\nAfter swap 7,8,6,9.\\nBut this leads to 7,8 disparity.\\nHence we propogate the swap once more to get 8,7,6,9.\\n\\nNext disparity 6,9. After swap: 8,7,9,6.\\nBut this leads to 7,9 disparity. After swap: 8,9,7,6.\\nBut this leads to 8,9 disparity. After swap: 9,8,7,6.\\nNow after swap propogations, everything looks fine.\\n\\nWe can see a pattern that, the repeated swap propogations when there is sequence of DDD.... will lead to reversal of the segment.\\nEg: from 6,7,89 to 9,8,7,6\\nHence no need to do repeated swaps but just reverse entire seqeuence.\\n\\nPutting this to code:\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        n = len(pattern)\\n\\t\\t\\n\\t\\t#smallest possible string\\n        smallest = [f\\'{i+1}\\' for i in range(n+1)]\\n        \\n\\t\\t#inplace reversal\\n        def revserse(arr,start,end):\\n            if start>=end:\\n                return\\n            \\n            arr[start],arr[end] = arr[end],arr[start]\\n            revserse(arr,start+1,end-1)\\n        \\n        i = 0\\n        while i<n:\\n\\t\\t#starting of the sequence of Ds\\n            if pattern[i]==\\'D\\':\\n                j = i #ending index of sequence of Ds\\n                while j+1<n and pattern[j+1]==\\'D\\':\\n                    j+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#reverse the sequence\\n                revserse(smallest,i,j+1)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#move front\\n                i = j+1\\n            else:\\n                i+=1\\n                \\n        return \"\".join(smallest)\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        n = len(pattern)\\n\\t\\t\\n\\t\\t#smallest possible string\\n        smallest = [f\\'{i+1}\\' for i in range(n+1)]\\n        \\n\\t\\t#inplace reversal\\n        def revserse(arr,start,end):\\n            if start>=end:\\n                return\\n            \\n            arr[start],arr[end] = arr[end],arr[start]\\n            revserse(arr,start+1,end-1)\\n        \\n        i = 0\\n        while i<n:\\n\\t\\t#starting of the sequence of Ds\\n            if pattern[i]==\\'D\\':\\n                j = i #ending index of sequence of Ds\\n                while j+1<n and pattern[j+1]==\\'D\\':\\n                    j+=1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#reverse the sequence\\n                revserse(smallest,i,j+1)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#move front\\n                i = j+1\\n            else:\\n                i+=1\\n                \\n        return \"\".join(smallest)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422242,
                "title": "java-dfs",
                "content": "**Code:**\\n\\n    String pat, res = \"\";\\n    boolean[] vis = new boolean[10];\\n    \\n    public String smallestNumber(String pattern) {\\n        this.pat = pattern;\\n        for(int i=1; i<10; i++){\\n            if(dfs(i, 0, i+\"\")) break;\\n            vis[i] = false;\\n        }\\n        return res;\\n    }\\n    \\n    boolean dfs(int last, int idx, String s) {\\n        if(idx==pat.length()) {\\n            res = s; return true;\\n        }\\n        vis[last] = true;\\n        boolean flag = pat.charAt(idx)==\\'I\\';\\n        for(int i = flag?last+1:1; (flag&&i<=9) || (!flag&&i<=last-1); i++){\\n            if(vis[i]) continue;\\n            if(dfs(i, idx+1, s+i)) return true;\\n            vis[i] = false;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t\\n**for loop explaination:**\\nif `\\'I\\'` then it generates `i` from `last+1 to 9`\\nif `\"D\"` then it generates `i` from `1 to last-1`",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "**Code:**\\n\\n    String pat, res = \"\";\\n    boolean[] vis = new boolean[10];\\n    \\n    public String smallestNumber(String pattern) {\\n        this.pat = pattern;\\n        for(int i=1; i<10; i++){\\n            if(dfs(i, 0, i+\"\")) break;\\n            vis[i] = false;\\n        }\\n        return res;\\n    }\\n    \\n    boolean dfs(int last, int idx, String s) {\\n        if(idx==pat.length()) {\\n            res = s; return true;\\n        }\\n        vis[last] = true;\\n        boolean flag = pat.charAt(idx)==\\'I\\';\\n        for(int i = flag?last+1:1; (flag&&i<=9) || (!flag&&i<=last-1); i++){\\n            if(vis[i]) continue;\\n            if(dfs(i, idx+1, s+i)) return true;\\n            vis[i] = false;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t\\n**for loop explaination:**\\nif `\\'I\\'` then it generates `i` from `last+1 to 9`\\nif `\"D\"` then it generates `i` from `1 to last-1`",
                "codeTag": "Unknown"
            },
            {
                "id": 2422284,
                "title": "java-concise-one-pass-solution",
                "content": "``` java\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder res = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        char ch = \\'1\\';\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char cur = pattern.charAt(i);\\n            temp.append(ch++);\\n            if (cur == \\'I\\') {\\n                res.append(temp.reverse());\\n                temp = new StringBuilder();\\n            }\\n        }\\n        temp.append(ch++);\\n        res.append(temp.reverse());\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder res = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        char ch = \\'1\\';\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char cur = pattern.charAt(i);\\n            temp.append(ch++);\\n            if (cur == \\'I\\') {\\n                res.append(temp.reverse());\\n                temp = new StringBuilder();\\n            }\\n        }\\n        temp.append(ch++);\\n        res.append(temp.reverse());\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422256,
                "title": "c-iterative-approach-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        int i=0;\\n        string res=\"1\";\\n        char num=\\'1\\';\\n        for(auto ch:p){\\n            if(ch==\\'I\\'){\\n                res.push_back(++num);\\n                i=res.size()-1;\\n            }\\n            else{\\n                res.push_back(++num);\\n                for(int k=res.size()-1;k>i;k--){\\n                    swap(res[k],res[k-1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Do upvote if you like it!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        int i=0;\\n        string res=\"1\";\\n        char num=\\'1\\';\\n        for(auto ch:p){\\n            if(ch==\\'I\\'){\\n                res.push_back(++num);\\n                i=res.size()-1;\\n            }\\n            else{\\n                res.push_back(++num);\\n                for(int k=res.size()-1;k>i;k--){\\n                    swap(res[k],res[k-1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422625,
                "title": "java-stack-easy-to-understand",
                "content": "Think of a case of in which there are only I\\'s in String, you just have to add the num in String and inc the num.\\nNow Think of a case in which only D\\'s are present in String.\\nIt\\'s just reverse of I , so we will use Stack here.\\ni will add the number in stack and increase it. \\nAnd just pop the stack content after iterating all the characters to make answer.\\nNow Let\\'s Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder ans = new StringBuilder(\"\");\\n        int num = 1; \\n        Stack<Integer> st = new Stack<>();\\n        st.push(1); \\n        for(int i = 0 ; i < pattern.length() ; i++){\\n            char ch = pattern.charAt(i);\\n            if(ch == \\'I\\'){\\n                while(st.size() != 0){\\n                    ans.append(st.pop()); \\n                }\\n                num += 1;\\n                st.push(num);\\n            }else{\\n                num += 1;\\n                st.push(num);\\n            }\\n        }\\n        while(st.size() != 0){\\n            ans.append(st.pop());\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder ans = new StringBuilder(\"\");\\n        int num = 1; \\n        Stack<Integer> st = new Stack<>();\\n        st.push(1); \\n        for(int i = 0 ; i < pattern.length() ; i++){\\n            char ch = pattern.charAt(i);\\n            if(ch == \\'I\\'){\\n                while(st.size() != 0){\\n                    ans.append(st.pop()); \\n                }\\n                num += 1;\\n                st.push(num);\\n            }else{\\n                num += 1;\\n                st.push(num);\\n            }\\n        }\\n        while(st.size() != 0){\\n            ans.append(st.pop());\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425788,
                "title": "python-easy-to-understand-greedy-solution",
                "content": "This solution works by increasing the previous \"I\" by the total number of succeeding \"D\"s then decrementing 1 for every D. And then repeating the same process untill the loop ends. and check one last time out of the loop.\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        ans = []\\n        dec_count = 0\\n        for i in range(len(pattern)):\\n            if pattern[i] == \"I\":\\n                for j in range(i, i-dec_count-1,-1):\\n                    ans.append(str(j+1))\\n                dec_count = 0\\n            elif pattern[i] == \"D\":\\n                dec_count += 1\\n                \\n        # for the remaining dec_count if there is any\\n        for j in range(len(pattern), len(pattern)-dec_count-1,-1):\\n            ans.append(str(j+1))\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        ans = []\\n        dec_count = 0\\n        for i in range(len(pattern)):\\n            if pattern[i] == \"I\":\\n                for j in range(i, i-dec_count-1,-1):\\n                    ans.append(str(j+1))\\n                dec_count = 0\\n            elif pattern[i] == \"D\":\\n                dec_count += 1\\n                \\n        # for the remaining dec_count if there is any\\n        for j in range(len(pattern), len(pattern)-dec_count-1,-1):\\n            ans.append(str(j+1))\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424040,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        string ans ;\\n        char count = \\'1\\';\\n        int c = 1;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(p[i] == \\'D\\')\\n                c++;\\n            else\\n                break;\\n        }\\n        int t = c;\\n        while(c > 1)\\n        {\\n            ans += to_string(c);\\n            c--;\\n            \\n            count = \\'0\\' + t;\\n            flag = true;\\n        }\\n        \\n        ans += \\'1\\';\\n        t--;\\n        for(int i=t;i<p.size();i++)\\n        {\\n            if(p[i] == \\'I\\')\\n            {\\n                count++;\\n                ans += count;\\n            }\\n            else\\n            {\\n                count++;\\n                int temp = i;\\n\\n                while(ans[temp-1] > ans[temp])\\n                {\\n                    temp--;\\n                \\n                }\\n                string a;\\n                a += count;\\n                ans.insert(temp,a);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        string ans ;\\n        char count = \\'1\\';\\n        int c = 1;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(p[i] == \\'D\\')\\n                c++;\\n            else\\n                break;\\n        }\\n        int t = c;\\n        while(c > 1)\\n        {\\n            ans += to_string(c);\\n            c--;\\n            \\n            count = \\'0\\' + t;\\n            flag = true;\\n        }\\n        \\n        ans += \\'1\\';\\n        t--;\\n        for(int i=t;i<p.size();i++)\\n        {\\n            if(p[i] == \\'I\\')\\n            {\\n                count++;\\n                ans += count;\\n            }\\n            else\\n            {\\n                count++;\\n                int temp = i;\\n\\n                while(ans[temp-1] > ans[temp])\\n                {\\n                    temp--;\\n                \\n                }\\n                string a;\\n                a += count;\\n                ans.insert(temp,a);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422336,
                "title": "c-solution",
                "content": "void helper(int i, int prev, string &pattern, string &curr, string &ans, vector<bool> &vis)\\n    {\\n        if(i == pattern.size())\\n        {\\n            if(ans == \"\"){\\n                ans = curr;\\n            }else{\\n                ans = min(curr, ans);\\n            }\\n            return;\\n        }\\n        if(pattern[i] == \\'I\\'){\\n            for(int val = prev + 1; val <= 9; val++){\\n                if(!vis[val]){\\n                    curr += to_string(val);\\n                    vis[val] = true;\\n                    helper(i + 1, val, pattern, curr, ans, vis);\\n                    curr.pop_back();\\n                    vis[val] = false;\\n                }\\n            }\\n        }else{\\n            for(int val = prev - 1; val > 0; val--){\\n                if(!vis[val]){\\n                    curr += to_string(val);\\n                    vis[val] = true;\\n                    helper(i + 1, val, pattern, curr, ans, vis);\\n                    curr.pop_back();\\n                    vis[val] = false;\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    string smallestNumber(string pattern) {\\n        string ans;\\n        for(int i = 9; i > 0; i--){\\n            string curr = to_string(i);\\n            vector<bool> vis(10, false);\\n            vis[i] = true;\\n            helper(0, i, pattern, curr, ans, vis);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "void helper(int i, int prev, string &pattern, string &curr, string &ans, vector<bool> &vis)\\n    {\\n        if(i == pattern.size())\\n        {\\n            if(ans == \"\"){\\n                ans = curr;\\n            }else{\\n                ans = min(curr, ans);\\n            }\\n            return;\\n        }\\n        if(pattern[i] == \\'I\\'){\\n            for(int val = prev + 1; val <= 9; val++){\\n                if(!vis[val]){\\n                    curr += to_string(val);\\n                    vis[val] = true;\\n                    helper(i + 1, val, pattern, curr, ans, vis);\\n                    curr.pop_back();\\n                    vis[val] = false;\\n                }\\n            }\\n        }else{\\n            for(int val = prev - 1; val > 0; val--){\\n                if(!vis[val]){\\n                    curr += to_string(val);\\n                    vis[val] = true;\\n                    helper(i + 1, val, pattern, curr, ans, vis);\\n                    curr.pop_back();\\n                    vis[val] = false;\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    string smallestNumber(string pattern) {\\n        string ans;\\n        for(int i = 9; i > 0; i--){\\n            string curr = to_string(i);\\n            vector<bool> vis(10, false);\\n            vis[i] = true;\\n            helper(0, i, pattern, curr, ans, vis);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2422261,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        stack<int>st;\\n        string ans;\\n        int num=1;\\n        for(int i=0;i<pattern.length();i++){\\n            \\n            if(pattern[i]==\\'D\\'){\\n                st.push(num);\\n                num++;\\n            }\\n            else{\\n                st.push(num);\\n                num++;\\n                while(!st.empty()){\\n                    char ch=st.top()+\\'0\\';\\n                    ans+=ch;\\n                    st.pop();\\n                }\\n            } \\n        }\\n        st.push(num);\\n        while(!st.empty()){\\n            char ch=st.top()+\\'0\\';\\n            ans+=ch;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        stack<int>st;\\n        string ans;\\n        int num=1;\\n        for(int i=0;i<pattern.length();i++){\\n            \\n            if(pattern[i]==\\'D\\'){\\n                st.push(num);\\n                num++;\\n            }\\n            else{\\n                st.push(num);\\n                num++;\\n                while(!st.empty()){\\n                    char ch=st.top()+\\'0\\';\\n                    ans+=ch;\\n                    st.pop();\\n                }\\n            } \\n        }\\n        st.push(num);\\n        while(!st.empty()){\\n            char ch=st.top()+\\'0\\';\\n            ans+=ch;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428363,
                "title": "multiple-approaches-with-code-c-clean-code",
                "content": "---------------------------------------------------------------------\\n# Approach 1 : DFS + Backtracking \\n---------------------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    string result;\\n    \\n    void solve(const string& pattern, int idx, string& num, vector<bool>& vis) {\\n        \\n        if(idx == pattern.size()) {\\n            if(num.size() == pattern.size() + 1 && num < result) result = num;\\n            return;\\n        }\\n        \\n        if(idx == -1) {\\n            for(int i=1; i<=9; i++) {\\n                if(!vis[i]) {\\n                    vis[i] = true;\\n                    num += (i + \\'0\\');\\n                    solve(pattern, idx+1, num, vis);    \\n                    num.pop_back();\\n                    vis[i] = false;   \\n                }\\n            }\\n            return;\\n        }        \\n\\n\\t\\tint dgt = num.back() - \\'0\\';\\n        \\n\\t\\tif(pattern[idx] == \\'I\\') {\\n            for(int i=dgt+1; i<=9; i++) {\\n                if(!vis[i]) {\\n                    vis[i] = true;\\n                    num += (i + \\'0\\');\\n                    solve(pattern, idx+1, num, vis);\\n                    num.pop_back();\\n                    vis[i] = false;\\n                }\\n            }\\n        }\\n        else {\\n            for(int i=dgt-1; i>=1; i--) {\\n                if(!vis[i]) {\\n                    vis[i] = true;\\n                    num += (i + \\'0\\');\\n                    solve(pattern, idx+1, num, vis);\\n                    num.pop_back();\\n                    vis[i] = false;\\n                }\\n            }\\n        }            \\n    }\\n    \\n    string smallestNumber(string pattern) {\\n        result = \"987654321\";\\n        string num = \"\";\\n        \\n        vector<bool> vis(10, false);\\n        \\n        solve(pattern, -1, num, vis);\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------\\n# Approach 2 : Stack\\n---------------------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        int n = pattern.size();\\n        \\n        stack<int> st;\\n        \\n        string num = \"\";\\n        \\n        for(int i=0; i<=n; i++) {\\n            st.push(i);\\n            \\n            if(i == n || pattern[i] == \\'I\\') {\\n                while(st.size()) {\\n                    num += (st.top() + \\'1\\');\\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        return num;\\n    }\\n};\\n```\\n\\n---------------------------------------------------------------------\\n# Approach 3 : Reverse blocks\\n---------------------------------------------------------------------\\n\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        int n = pattern.size();\\n        \\n        string num = \"\";\\n\\n        int prev = 0;\\n        \\n        for(int i=0; i<=n; i++) {\\n            num += (i + \\'1\\');\\n            if(i == n || pattern[i] == \\'I\\') {\\n                reverse(num.begin() + prev, num.end());\\n                prev = i+1;\\n            }\\n            // cout << i << \" : \" << pattern[i] << \" -> \" << num << endl;\\n        }\\n        \\n        return num;\\n    }\\n};\\n```\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Stack",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string result;\\n    \\n    void solve(const string& pattern, int idx, string& num, vector<bool>& vis) {\\n        \\n        if(idx == pattern.size()) {\\n            if(num.size() == pattern.size() + 1 && num < result) result = num;\\n            return;\\n        }\\n        \\n        if(idx == -1) {\\n            for(int i=1; i<=9; i++) {\\n                if(!vis[i]) {\\n                    vis[i] = true;\\n                    num += (i + \\'0\\');\\n                    solve(pattern, idx+1, num, vis);    \\n                    num.pop_back();\\n                    vis[i] = false;   \\n                }\\n            }\\n            return;\\n        }        \\n\\n\\t\\tint dgt = num.back() - \\'0\\';\\n        \\n\\t\\tif(pattern[idx] == \\'I\\') {\\n            for(int i=dgt+1; i<=9; i++) {\\n                if(!vis[i]) {\\n                    vis[i] = true;\\n                    num += (i + \\'0\\');\\n                    solve(pattern, idx+1, num, vis);\\n                    num.pop_back();\\n                    vis[i] = false;\\n                }\\n            }\\n        }\\n        else {\\n            for(int i=dgt-1; i>=1; i--) {\\n                if(!vis[i]) {\\n                    vis[i] = true;\\n                    num += (i + \\'0\\');\\n                    solve(pattern, idx+1, num, vis);\\n                    num.pop_back();\\n                    vis[i] = false;\\n                }\\n            }\\n        }            \\n    }\\n    \\n    string smallestNumber(string pattern) {\\n        result = \"987654321\";\\n        string num = \"\";\\n        \\n        vector<bool> vis(10, false);\\n        \\n        solve(pattern, -1, num, vis);\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        int n = pattern.size();\\n        \\n        stack<int> st;\\n        \\n        string num = \"\";\\n        \\n        for(int i=0; i<=n; i++) {\\n            st.push(i);\\n            \\n            if(i == n || pattern[i] == \\'I\\') {\\n                while(st.size()) {\\n                    num += (st.top() + \\'1\\');\\n                    st.pop();\\n                }\\n            }\\n        }\\n        \\n        return num;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        int n = pattern.size();\\n        \\n        string num = \"\";\\n\\n        int prev = 0;\\n        \\n        for(int i=0; i<=n; i++) {\\n            num += (i + \\'1\\');\\n            if(i == n || pattern[i] == \\'I\\') {\\n                reverse(num.begin() + prev, num.end());\\n                prev = i+1;\\n            }\\n            // cout << i << \" : \" << pattern[i] << \" -> \" << num << endl;\\n        }\\n        \\n        return num;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2423449,
                "title": "java-1ms-100-faster",
                "content": "# Please Upvote\\n\\n```\\nStringBuilder res = new StringBuilder(), stack = new StringBuilder();\\n        for (int i = 0; i <= s.length(); i++) {\\n            stack.append((char)(\\'1\\' + i));\\n            if (i == s.length() || s.charAt(i) == \\'I\\') {\\n                res.append(stack.reverse());\\n                stack = new StringBuilder();\\n            }\\n        }\\n        return res.toString();\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nStringBuilder res = new StringBuilder(), stack = new StringBuilder();\\n        for (int i = 0; i <= s.length(); i++) {\\n            stack.append((char)(\\'1\\' + i));\\n            if (i == s.length() || s.charAt(i) == \\'I\\') {\\n                res.append(stack.reverse());\\n                stack = new StringBuilder();\\n            }\\n        }\\n        return res.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422470,
                "title": "c-using-next-permutation-brute-force",
                "content": "Construct an array from 1 to pattern.size()+1.\\nCheck for each permutation whether it satisfy the condition given in the pattern or not.\\n\\n```\\nclass Solution\\n{\\n    public:\\n        string smallestNumber(string s)\\n        {\\n            int n = s.size() + 1;\\n            int a[n + 1];\\n            for (int i = 1; i <= n; i++) \\n            {\\n                a[i] = i;\\n            }\\n\\n            do {\\n                bool ok = true;\\n                for (int i = 1; i < n; i++)\\n                {\\n                    char op = s[i - 1];\\n                    if (op == \\'I\\')\\n                    {\\n                        if (a[i] > a[i + 1]) ok = false;\\n                    }\\n                    else\\n                    {\\n                        if (a[i] < a[i + 1]) ok = false;\\n                    }\\n                }\\n                if (ok) // if the array satisfied the pattern return\\n                {\\n                    string res;\\n                    for (int i = 1; i <= n; i++) res += to_string(a[i]);\\n                    return res;\\n                }\\n            } while (next_permutation(a + 1, a + 1 + n)); // generate next permutation\\n\\n            return \" \";\\n        }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string smallestNumber(string s)\\n        {\\n            int n = s.size() + 1;\\n            int a[n + 1];\\n            for (int i = 1; i <= n; i++) \\n            {\\n                a[i] = i;\\n            }\\n\\n            do {\\n                bool ok = true;\\n                for (int i = 1; i < n; i++)\\n                {\\n                    char op = s[i - 1];\\n                    if (op == \\'I\\')\\n                    {\\n                        if (a[i] > a[i + 1]) ok = false;\\n                    }\\n                    else\\n                    {\\n                        if (a[i] < a[i + 1]) ok = false;\\n                    }\\n                }\\n                if (ok) // if the array satisfied the pattern return\\n                {\\n                    string res;\\n                    for (int i = 1; i <= n; i++) res += to_string(a[i]);\\n                    return res;\\n                }\\n            } while (next_permutation(a + 1, a + 1 + n)); // generate next permutation\\n\\n            return \" \";\\n        }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422096,
                "title": "easy-stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<int>st;\\n        string ans;\\n        int i = 0;\\n        for(i = 0; i < pattern.size(); i++){\\n            st.push(i+1);\\n            if(pattern[i] == \\'I\\'){ //if the pattern is increasing we have to just add number with i+1 value because num[i] < num[i+1] nxt number should greater\\n                while(!st.empty()){\\n                    int currNum = st.top();\\n                    st.pop();\\n                    ans += to_string(currNum);\\n                }\\n            }\\n        }\\n        st.push(i+1); //remaing n+1 ele will push\\n        while(!st.empty()){ //remaing ele in stacks will be Decreasing d seq\\n            int currNum = st.top();\\n            st.pop();\\n            ans += to_string(currNum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<int>st;\\n        string ans;\\n        int i = 0;\\n        for(i = 0; i < pattern.size(); i++){\\n            st.push(i+1);\\n            if(pattern[i] == \\'I\\'){ //if the pattern is increasing we have to just add number with i+1 value because num[i] < num[i+1] nxt number should greater\\n                while(!st.empty()){\\n                    int currNum = st.top();\\n                    st.pop();\\n                    ans += to_string(currNum);\\n                }\\n            }\\n        }\\n        st.push(i+1); //remaing n+1 ele will push\\n        while(!st.empty()){ //remaing ele in stacks will be Decreasing d seq\\n            int currNum = st.top();\\n            st.pop();\\n            ans += to_string(currNum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422092,
                "title": "cpp-backtracking-bit-mask",
                "content": "**Intuition** : Try out all the possibilities and take the minimum out of them.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void func(string &s,int i,int prevVal,string &ans,string &res,int mask){\\n        if(res.size()==s.length()+1){\\n            ans=min(ans,res);\\n            return ;\\n        }\\n        if(i==s.length()){\\n            return ;\\n        }\\n        for(int j=i;j<s.length();j++){\\n            if(s[j]==\\'I\\'){\\n                for(int k=prevVal+1;k<=9;k++){\\n                    if(mask & (1<<k)) continue;\\n                    mask = mask | (1<<k);\\n                    res.push_back(k+\\'0\\');\\n                    func(s,j+1,k,ans,res,mask);\\n                    res.pop_back();\\n                    mask = mask & ~(1<<k);\\n                }\\n            }\\n            else{\\n                for(int k=prevVal-1;k>=1;k--){\\n                    if(mask & (1<<k)) continue;\\n                    mask = mask | (1<<k);\\n                    res.push_back(k+\\'0\\');\\n                    func(s,j+1,k,ans,res,mask);\\n                    res.pop_back();\\n                    mask = mask & ~(1<<k);\\n                }\\n            }\\n        }\\n    }\\n    \\n    string smallestNumber(string s) {\\n        string finalAns=\"999999999999\";\\n        for(int i=1;i<=9;i++){\\n            string ans=\"9999999999\",res;\\n            res.push_back(i+\\'0\\');\\n            func(s,0,i,ans,res,1<<i);\\n            finalAns=min(finalAns,ans);\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void func(string &s,int i,int prevVal,string &ans,string &res,int mask){\\n        if(res.size()==s.length()+1){\\n            ans=min(ans,res);\\n            return ;\\n        }\\n        if(i==s.length()){\\n            return ;\\n        }\\n        for(int j=i;j<s.length();j++){\\n            if(s[j]==\\'I\\'){\\n                for(int k=prevVal+1;k<=9;k++){\\n                    if(mask & (1<<k)) continue;\\n                    mask = mask | (1<<k);\\n                    res.push_back(k+\\'0\\');\\n                    func(s,j+1,k,ans,res,mask);\\n                    res.pop_back();\\n                    mask = mask & ~(1<<k);\\n                }\\n            }\\n            else{\\n                for(int k=prevVal-1;k>=1;k--){\\n                    if(mask & (1<<k)) continue;\\n                    mask = mask | (1<<k);\\n                    res.push_back(k+\\'0\\');\\n                    func(s,j+1,k,ans,res,mask);\\n                    res.pop_back();\\n                    mask = mask & ~(1<<k);\\n                }\\n            }\\n        }\\n    }\\n    \\n    string smallestNumber(string s) {\\n        string finalAns=\"999999999999\";\\n        for(int i=1;i<=9;i++){\\n            string ans=\"9999999999\",res;\\n            res.push_back(i+\\'0\\');\\n            func(s,0,i,ans,res,1<<i);\\n            finalAns=min(finalAns,ans);\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652099,
                "title": "very-easy-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider example \"IIIDDD\" o/p of this will be \"1237654\".\\nSince size of pattern is 6 so length of o/p will be 7, range [1-7].\\nWe are starting from ch = \\'1\\' to ch=\\'7\\'. we will get characters(num) in increasing order 1,2,3,4,5,6,7.\\n\\nif \\'I\\' is the char we are processing that means all values present in stack is definately less than current number.\\nIf pattern[i]==\\'I\\' remove all elements from stack and append to ans.\\n![IMG_8A1A48A3B2C4-1.jpeg](https://assets.leetcode.com/users/images/132a9faa-7020-429a-b3d7-d6c2f0d49f48_1687085872.00057.jpeg)\\nDRY RUN:\\n    stack already has \\'1\\'.\\n    at i = 0\\n        \\'I\\' -> remove elements from stack. and when stack is empty push next number.\\n        ans = \"1\"\\n    at i = 1\\n        \\'I\\' -> remove elements from stack. when stack is empty push next number.\\n        ans = \"12\"\\n    at i = 2\\n        \\'I\\' -> remove elements from stack. when stack is empty push next  number.\\n        ans = \"123\"\\n    at i = 3\\n        \\'D\\' -> push \\'5\\' into stack. \\n        ans = \"123\"\\n    at i = 4\\n        \\'D\\' -> push \\'6\\' into stack. \\n        ans = \"123\"\\n    at i = 5\\n        \\'D\\' -> push \\'7\\' into stack. \\n        ans = \"123\"\\n\\nat last empty stack ans append char to ans.\\n\"1237654\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pat) {\\n        string ans=\"\";\\n        int n = pat.size();\\n        stack<char> st;\\n        int i=0;\\n        char ch = \\'1\\';\\n        st.push(ch);\\n        while(!st.empty() && i<n){\\n            ch++;\\n            if(pat[i]==\\'I\\'){\\n                while(!st.empty()){\\n                    ans+=st.top();\\n                    st.pop();\\n                }\\n                st.push(ch);\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n            i++;\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pat) {\\n        string ans=\"\";\\n        int n = pat.size();\\n        stack<char> st;\\n        int i=0;\\n        char ch = \\'1\\';\\n        st.push(ch);\\n        while(!st.empty() && i<n){\\n            ch++;\\n            if(pat[i]==\\'I\\'){\\n                while(!st.empty()){\\n                    ans+=st.top();\\n                    st.pop();\\n                }\\n                st.push(ch);\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n            i++;\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631228,
                "title": "100-beats-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string str) {\\n        vector<int> s = {1};\\n        int k = 0,y=1;\\n        for(int i = 0; i < str.length(); ){\\n            cout<<endl;\\n            if(str[i]==\\'D\\'){\\n                k = 0;\\n            while(i<str.length()&&str[i]==\\'D\\'){s[s.size()-1] = s.back()+1;i++;k++;y=s.back();}\\n            while(k--)s.push_back(s.back()-1);\\n            }else{\\n                i++;\\n                s.push_back(y+1);\\n                y = s.back();\\n            }\\n        }\\n        string ans = \"\",tmp = \"\";\\n        for(auto &i: s){\\n            tmp = (i+\\'0\\');\\n            ans = ans+tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string str) {\\n        vector<int> s = {1};\\n        int k = 0,y=1;\\n        for(int i = 0; i < str.length(); ){\\n            cout<<endl;\\n            if(str[i]==\\'D\\'){\\n                k = 0;\\n            while(i<str.length()&&str[i]==\\'D\\'){s[s.size()-1] = s.back()+1;i++;k++;y=s.back();}\\n            while(k--)s.push_back(s.back()-1);\\n            }else{\\n                i++;\\n                s.push_back(y+1);\\n                y = s.back();\\n            }\\n        }\\n        string ans = \"\",tmp = \"\";\\n        for(auto &i: s){\\n            tmp = (i+\\'0\\');\\n            ans = ans+tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3049890,
                "title": "permutations-c",
                "content": "```\\nclass Solution {\\n    bool good(string &s, string &p) {\\n        int n = p.size();\\n        for(int i=0; i<n; i++) {\\n            if(p[i] == \\'I\\' && s[i] > s[i + 1]) return false;\\n            else if(p[i] == \\'D\\' && s[i] < s[i + 1]) return false;\\n        }\\n        return true;\\n    }\\n\\n    void dfs(int i, string &s, string &pattern, string &ans) {\\n        if(i == s.size() - 1) {\\n            if(good(s, pattern)) ans = min(ans, s);\\n            return;\\n        }\\n        for(int j=i; j<s.size(); j++) {\\n            swap(s[i], s[j]);\\n            dfs(i + 1, s, pattern, ans);\\n            swap(s[i], s[j]);\\n        }\\n    }\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        string s, ans = \"99999999\";\\n        for(int i=1; i<=n+1; i++) s += to_string(i);\\n\\n        dfs(0, s, pattern, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    bool good(string &s, string &p) {\\n        int n = p.size();\\n        for(int i=0; i<n; i++) {\\n            if(p[i] == \\'I\\' && s[i] > s[i + 1]) return false;\\n            else if(p[i] == \\'D\\' && s[i] < s[i + 1]) return false;\\n        }\\n        return true;\\n    }\\n\\n    void dfs(int i, string &s, string &pattern, string &ans) {\\n        if(i == s.size() - 1) {\\n            if(good(s, pattern)) ans = min(ans, s);\\n            return;\\n        }\\n        for(int j=i; j<s.size(); j++) {\\n            swap(s[i], s[j]);\\n            dfs(i + 1, s, pattern, ans);\\n            swap(s[i], s[j]);\\n        }\\n    }\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        string s, ans = \"99999999\";\\n        for(int i=1; i<=n+1; i++) s += to_string(i);\\n\\n        dfs(0, s, pattern, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518280,
                "title": "java-easy-swapping-in-array",
                "content": "```\\nclass Solution {\\n    public String smallestNumber(String str) {\\n\\n        int n = str.length();\\n        char[] ans = new char[n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            ans[i] = ((i + 1) + \"\").charAt(0);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int j = i;\\n            while (j >= 0 && str.charAt(j) == \\'D\\') {\\n                swap(ans, j, j + 1);\\n                j--;\\n            }\\n        }\\n        return String.valueOf(ans);\\n    }\\n    \\n    private static void swap(char[] arr, int i, int j) {\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String str) {\\n\\n        int n = str.length();\\n        char[] ans = new char[n + 1];\\n        for (int i = 0; i <= n; i++) {\\n            ans[i] = ((i + 1) + \"\").charAt(0);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int j = i;\\n            while (j >= 0 && str.charAt(j) == \\'D\\') {\\n                swap(ans, j, j + 1);\\n                j--;\\n            }\\n        }\\n        return String.valueOf(ans);\\n    }\\n    \\n    private static void swap(char[] arr, int i, int j) {\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425588,
                "title": "javascript-stack-reverse-tc-o-nr-sc-o-n",
                "content": "```\\n/**\\n * @param {string} pattern\\n * @return {string}\\n */\\nvar smallestNumber = function(pattern) {\\n    const ans = [];\\n    let stack = [];\\n    \\n    for (let i = 0; i <= pattern.length; i++) {\\n        stack.push(i + 1);\\n        if (pattern[i] === \\'I\\' || i === pattern.length) {\\n            ans.push(...stack.reverse());\\n            stack = [];\\n        }\\n    }\\n    \\n    return ans.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} pattern\\n * @return {string}\\n */\\nvar smallestNumber = function(pattern) {\\n    const ans = [];\\n    let stack = [];\\n    \\n    for (let i = 0; i <= pattern.length; i++) {\\n        stack.push(i + 1);\\n        if (pattern[i] === \\'I\\' || i === pattern.length) {\\n            ans.push(...stack.reverse());\\n            stack = [];\\n        }\\n    }\\n    \\n    return ans.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423134,
                "title": "easy-to-understand-c-code",
                "content": "* ***Backtracking***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string res = \"999999999\";\\n    \\n    // s will keep track of included digit\\n    \\n    unordered_set<int> s;\\n    \\n    // backtracking function\\n    \\n    void dfs(string &pattern, int i, int n, string curr)\\n    {\\n        // base case, if we reached the end of the pattern\\n        \\n        if(i == n)\\n        {\\n            // update the res\\n            \\n            res = min(res, curr);\\n            \\n            return;\\n        }\\n        \\n        // case 1, if pattern[i] == \\'I\\'\\n    \\n        if(pattern[i] == \\'I\\')\\n        {\\n            // try out all possible digit\\n            \\n            for(int d = 1; d <= 9; d++)\\n            {\\n                // curr digit should not be included and greater than prev digit\\n                \\n                if(s.count(d) == 0 && d > curr.back() - \\'0\\')\\n                {\\n                    // mark the curr digit included\\n                    \\n                    s.insert(d);\\n                    \\n                    // add the curr digit in curr\\n                    \\n                    curr += to_string(d);\\n                    \\n                    dfs(pattern, i + 1, n, curr);\\n                    \\n                    // backtrack part\\n                    \\n                    curr.pop_back();\\n                    \\n                    s.erase(d);\\n                }\\n            }\\n        }\\n        \\n        // case 2, if pattern[i] == \\'D\\'\\n        \\n        else if(pattern[i] == \\'D\\')\\n        {\\n            for(int d = 1; d <= 9; d++)\\n            {\\n                // curr digit should not be included and less than prev digit\\n                \\n                if(s.count(d) == 0 && d < curr.back() - \\'0\\')\\n                {\\n                    // mark the curr digit included\\n                    \\n                    s.insert(d);\\n                    \\n                    // add the curr digit in curr\\n                    \\n                    curr += to_string(d);\\n                    \\n                    dfs(pattern, i + 1, n, curr);\\n                    \\n                    // backtrack part\\n                    \\n                    curr.pop_back();\\n                    \\n                    s.erase(d);\\n                }\\n            }\\n        }\\n    }\\n    \\n    string smallestNumber(string pattern) {\\n        \\n        int n = pattern.size();\\n        \\n        // try out by taking all the digits from (1 to 9) as starting digit\\n        \\n        for(int d = 1; d <= 9; d++)\\n        {\\n            s.clear();\\n            \\n            // mark the current digit as included\\n            \\n            s.insert(d);\\n            \\n            dfs(pattern, 0, n, to_string(d));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string res = \"999999999\";\\n    \\n    // s will keep track of included digit\\n    \\n    unordered_set<int> s;\\n    \\n    // backtracking function\\n    \\n    void dfs(string &pattern, int i, int n, string curr)\\n    {\\n        // base case, if we reached the end of the pattern\\n        \\n        if(i == n)\\n        {\\n            // update the res\\n            \\n            res = min(res, curr);\\n            \\n            return;\\n        }\\n        \\n        // case 1, if pattern[i] == \\'I\\'\\n    \\n        if(pattern[i] == \\'I\\')\\n        {\\n            // try out all possible digit\\n            \\n            for(int d = 1; d <= 9; d++)\\n            {\\n                // curr digit should not be included and greater than prev digit\\n                \\n                if(s.count(d) == 0 && d > curr.back() - \\'0\\')\\n                {\\n                    // mark the curr digit included\\n                    \\n                    s.insert(d);\\n                    \\n                    // add the curr digit in curr\\n                    \\n                    curr += to_string(d);\\n                    \\n                    dfs(pattern, i + 1, n, curr);\\n                    \\n                    // backtrack part\\n                    \\n                    curr.pop_back();\\n                    \\n                    s.erase(d);\\n                }\\n            }\\n        }\\n        \\n        // case 2, if pattern[i] == \\'D\\'\\n        \\n        else if(pattern[i] == \\'D\\')\\n        {\\n            for(int d = 1; d <= 9; d++)\\n            {\\n                // curr digit should not be included and less than prev digit\\n                \\n                if(s.count(d) == 0 && d < curr.back() - \\'0\\')\\n                {\\n                    // mark the curr digit included\\n                    \\n                    s.insert(d);\\n                    \\n                    // add the curr digit in curr\\n                    \\n                    curr += to_string(d);\\n                    \\n                    dfs(pattern, i + 1, n, curr);\\n                    \\n                    // backtrack part\\n                    \\n                    curr.pop_back();\\n                    \\n                    s.erase(d);\\n                }\\n            }\\n        }\\n    }\\n    \\n    string smallestNumber(string pattern) {\\n        \\n        int n = pattern.size();\\n        \\n        // try out by taking all the digits from (1 to 9) as starting digit\\n        \\n        for(int d = 1; d <= 9; d++)\\n        {\\n            s.clear();\\n            \\n            // mark the current digit as included\\n            \\n            s.insert(d);\\n            \\n            dfs(pattern, 0, n, to_string(d));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422851,
                "title": "java-clean-simple-recursion-beat-100",
                "content": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder str = new StringBuilder();\\n        helper(0, 1, pattern.toCharArray(), str);\\n        return str.reverse().toString();\\n    }\\n\\n    int helper(int index, int count, char[] arr, StringBuilder str) {\\n        if (index != arr.length) {\\n            if (arr[index] == \\'I\\')\\n                helper(index + 1, index + 2, arr, str);\\n            else\\n                count = helper(index + 1, count, arr, str);\\n        }\\n\\n        str.append(count);\\n        return count + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder str = new StringBuilder();\\n        helper(0, 1, pattern.toCharArray(), str);\\n        return str.reverse().toString();\\n    }\\n\\n    int helper(int index, int count, char[] arr, StringBuilder str) {\\n        if (index != arr.length) {\\n            if (arr[index] == \\'I\\')\\n                helper(index + 1, index + 2, arr, str);\\n            else\\n                count = helper(index + 1, count, arr, str);\\n        }\\n\\n        str.append(count);\\n        return count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422356,
                "title": "backtracking-simple-solution-with-explaination",
                "content": "```\\nclass Solution {\\n    string result = \"\";\\npublic:\\n    void Create_pattern(string pattern, string create, int index){\\n        if(index == pattern.size()){\\n            //check if you get the string first time\\n            if(result.size() == 0){\\n                result = create;\\n            }else{\\n                //Used set to sort the string by inserting resultant string and currently created string it \\n                // it will be sorted by set \\n                set<string> to_sort;\\n                to_sort.insert(result);\\n                to_sort.insert(create);\\n                for(auto it : to_sort){\\n                    result = it;\\n                    break;\\n                }\\n            }\\n            return ;\\n        }\\n\\n        int n = create.size();\\n        \\n        if(pattern[index] == \\'D\\'){\\n            if(create[n-1]!=\\'1\\'){\\n                // we check for all possible character which is less than current character\\n                for(char digit = create[n-1] -1; digit >= \\'1\\'; digit--){\\n                    \\n                    if(create.find(digit) == std::string::npos){\\n                        Create_pattern(pattern, create+digit, index+1);\\n                    }\\n                }\\n            }else{\\n                return ;\\n            }\\n        }else{\\n\\n            // we check for all possible character which are greater than current character\\n            if(create[n-1]!=\\'9\\'){\\n                for(char digit = create[n-1] + 1; digit <= \\'9\\'; digit++){\\n                 if(create.find(digit) == std::string::npos)\\n                    Create_pattern(pattern, create+digit, index+1);\\n                }\\n            }else{\\n                return ;\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        \\n        for(int i=1; i <10; i++)\\n            Create_pattern(pattern, to_string(i), 0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    string result = \"\";\\npublic:\\n    void Create_pattern(string pattern, string create, int index){\\n        if(index == pattern.size()){\\n            //check if you get the string first time\\n            if(result.size() == 0){\\n                result = create;\\n            }else{\\n                //Used set to sort the string by inserting resultant string and currently created string it \\n                // it will be sorted by set \\n                set<string> to_sort;\\n                to_sort.insert(result);\\n                to_sort.insert(create);\\n                for(auto it : to_sort){\\n                    result = it;\\n                    break;\\n                }\\n            }\\n            return ;\\n        }\\n\\n        int n = create.size();\\n        \\n        if(pattern[index] == \\'D\\'){\\n            if(create[n-1]!=\\'1\\'){\\n                // we check for all possible character which is less than current character\\n                for(char digit = create[n-1] -1; digit >= \\'1\\'; digit--){\\n                    \\n                    if(create.find(digit) == std::string::npos){\\n                        Create_pattern(pattern, create+digit, index+1);\\n                    }\\n                }\\n            }else{\\n                return ;\\n            }\\n        }else{\\n\\n            // we check for all possible character which are greater than current character\\n            if(create[n-1]!=\\'9\\'){\\n                for(char digit = create[n-1] + 1; digit <= \\'9\\'; digit++){\\n                 if(create.find(digit) == std::string::npos)\\n                    Create_pattern(pattern, create+digit, index+1);\\n                }\\n            }else{\\n                return ;\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        \\n        for(int i=1; i <10; i++)\\n            Create_pattern(pattern, to_string(i), 0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422188,
                "title": "java-backtracking-recursion-explained",
                "content": "**3 options\\nfirst index include any number\\nif character \\'I\\' number should be greater than previous\\nif character \\'D\\' number should be lower than previous**\\n\\n\\n```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    String ans=\"\";\\n    public void solve(String pattern, int idx, boolean visited[],String asf, int prev){\\n        if(idx==pattern.length()){\\n            int val=Integer.parseInt(asf);\\n            System.out.println(asf);\\n            if(val<min){\\n                min=val;\\n                ans=asf;\\n            }\\n            \\n            return;\\n        }\\n        for(int i=1;i<=pattern.length()+1;i++){\\n            \\n            if(idx==-1){\\n                visited[i+1]=true;\\n                solve(pattern,idx+1,visited,asf+i,i);\\n                visited[i+1]=false;\\n            }\\n            else{\\n                  char ch=pattern.charAt(idx);\\n                if(ch==\\'I\\'){\\n                    if(visited[i+1]==false && i>prev){\\n                        visited[i+1]=true;\\n                        solve(pattern,idx+1,visited,asf+i,i);\\n                        visited[i+1]=false;\\n                    }\\n                }\\n                else{\\n                    if(visited[i+1]==false && i<prev){\\n                        visited[i+1]=true;\\n                        solve(pattern,idx+1,visited,asf+i,i);\\n                        visited[i+1]=false;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String smallestNumber(String pattern) {\\n        boolean visited[] = new boolean[pattern.length()+3];\\n        solve(pattern,-1,visited,\"\",-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int min=Integer.MAX_VALUE;\\n    String ans=\"\";\\n    public void solve(String pattern, int idx, boolean visited[],String asf, int prev){\\n        if(idx==pattern.length()){\\n            int val=Integer.parseInt(asf);\\n            System.out.println(asf);\\n            if(val<min){\\n                min=val;\\n                ans=asf;\\n            }\\n            \\n            return;\\n        }\\n        for(int i=1;i<=pattern.length()+1;i++){\\n            \\n            if(idx==-1){\\n                visited[i+1]=true;\\n                solve(pattern,idx+1,visited,asf+i,i);\\n                visited[i+1]=false;\\n            }\\n            else{\\n                  char ch=pattern.charAt(idx);\\n                if(ch==\\'I\\'){\\n                    if(visited[i+1]==false && i>prev){\\n                        visited[i+1]=true;\\n                        solve(pattern,idx+1,visited,asf+i,i);\\n                        visited[i+1]=false;\\n                    }\\n                }\\n                else{\\n                    if(visited[i+1]==false && i<prev){\\n                        visited[i+1]=true;\\n                        solve(pattern,idx+1,visited,asf+i,i);\\n                        visited[i+1]=false;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String smallestNumber(String pattern) {\\n        boolean visited[] = new boolean[pattern.length()+3];\\n        solve(pattern,-1,visited,\"\",-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422123,
                "title": "easy-reversing-a-string-2-pointer-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void rev(string &s,int i,int j){\\n        for(int k=0;k<=(j-i)/2;k++){\\n            swap(s[i+k],s[j-k]);\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n\\n        string s=\"\";\\n        \\n        for(int i=0;i<=pattern.length();i++){\\n            s+= \\'1\\'+i;\\n        }\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            if(pattern[i]==\\'D\\'){\\n                int j=i;\\n                while(j<pattern.length() and pattern[j]==\\'D\\'){\\n                    j++;\\n                    \\n                }\\n                rev(s,i,j);\\n                i=j;\\n            }\\n            \\n        }\\n        \\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    void rev(string &s,int i,int j){\\n        for(int k=0;k<=(j-i)/2;k++){\\n            swap(s[i+k],s[j-k]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2422117,
                "title": "java-backtracking",
                "content": "```\\n//  greedily pick the smallest possible value at each index\\nclass Solution {\\n    boolean[] used = new boolean[10];\\n    int[] answer;\\n    boolean found = false;\\n    public String smallestNumber(String pattern) {\\n        char[] a = pattern.toCharArray();\\n        answer = new int[a.length + 1];\\n        for (int i = 1; i <= 9; i++) {\\n            answer[0] = i;\\n            used[i] = true;\\n            helper(a, 1);\\n            used[i] = false;\\n            //  we dont have to make further calls if the answer is built or will get TLE\\n            if (found) break;\\n        }\\n        String result = \"\";\\n        for (int v : answer) {\\n            result += v;\\n        }\\n        return result;\\n    }\\n    \\n    public void helper(char[] a, int idx) {\\n        if (idx == a.length + 1) {\\n            found = true;\\n            return;\\n        }\\n        int prev = answer[idx - 1];\\n        int todo = a[idx - 1] == \\'I\\' ? 1 : -1;\\n        //  greedily choosing the smallest value possible\\n        for (int option = prev + todo; option > 0  && option < 10; option += todo) {\\n            //  if already used skip this option\\n            if (used[option]) continue;\\n            answer[idx] = option;\\n            \\n            used[option] = true;\\n            helper(a, idx + 1);\\n            used[option] = false;\\n            \\n            //  we dont have to make further calls if the answer is built or will get TLE\\n            if (found) break;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    boolean[] used = new boolean[10];\\n    int[] answer;\\n    boolean found = false;\\n    public String smallestNumber(String pattern) {\\n        char[] a = pattern.toCharArray();\\n        answer = new int[a.length + 1];\\n        for (int i = 1; i <= 9; i++) {\\n            answer[0] = i;\\n            used[i] = true;\\n            helper(a, 1);\\n            used[i] = false;\\n            //  we dont have to make further calls if the answer is built or will get TLE\\n            if (found) break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2422089,
                "title": "backtracking-solution-easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    int max=Integer.MAX_VALUE;\\n    boolean values[]=new boolean[10];\\n    public String smallestNumber(String pattern) {\\n        int n=pattern.length();\\n        char arr[]=pattern.toCharArray();\\n        \\n        int cur=0;\\n        boolean solved=false;\\n        \\n        if(arr[0]==\\'I\\'){\\n            //at 0\\n            for(int i=1;i<=8;i++){\\n                values[i]=true;\\n                cur=cur*10+i;\\n                solve(arr,cur,0,n);\\n                cur=cur/10;\\n                values[i]=false;\\n            }\\n        }else{\\n            for(int i=2;i<=9;i++){\\n                values[i]=true;\\n                cur=cur*10+i;\\n                solve(arr,cur,0,n);\\n                values[i]=false;\\n                cur/=10;\\n            }\\n        }\\n        return String.valueOf(max);\\n        \\n    }\\n    void solve(char arr[],int cur,int id,int n){\\n        if(id==n){\\n            // System.out.println(cur);\\n            max=Math.min(max,cur);\\n            return;\\n        }\\n        if(arr[id]==\\'I\\'){\\n            for(int i=cur%10 +1 ;i<=9;i++){\\n                if(values[i])  continue;\\n                \\n                values[i]=true;\\n                cur=cur*10+i;\\n                solve(arr,cur,id+1,n);\\n                values[i]=false;\\n                cur/=10;\\n            }\\n        }else{\\n            for(int i=cur%10 -1;i>=1;i--){\\n                if(values[i])  continue;\\n                \\n                values[i]=true;\\n                cur=cur*10+i;\\n                solve(arr,cur,id+1,n);\\n                values[i]=false;\\n                cur/=10;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int max=Integer.MAX_VALUE;\\n    boolean values[]=new boolean[10];\\n    public String smallestNumber(String pattern) {\\n        int n=pattern.length();\\n        char arr[]=pattern.toCharArray();\\n        \\n        int cur=0;\\n        boolean solved=false;\\n        \\n        if(arr[0]==\\'I\\'){\\n            //at 0\\n            for(int i=1;i<=8;i++){\\n                values[i]=true;\\n                cur=cur*10+i;\\n                solve(arr,cur,0,n);\\n                cur=cur/10;\\n                values[i]=false;\\n            }\\n        }else{\\n            for(int i=2;i<=9;i++){\\n                values[i]=true;\\n                cur=cur*10+i;\\n                solve(arr,cur,0,n);\\n                values[i]=false;\\n                cur/=10;\\n            }\\n        }\\n        return String.valueOf(max);\\n        \\n    }\\n    void solve(char arr[],int cur,int id,int n){\\n        if(id==n){\\n            // System.out.println(cur);\\n            max=Math.min(max,cur);\\n            return;\\n        }\\n        if(arr[id]==\\'I\\'){\\n            for(int i=cur%10 +1 ;i<=9;i++){\\n                if(values[i])  continue;\\n                \\n                values[i]=true;\\n                cur=cur*10+i;\\n                solve(arr,cur,id+1,n);\\n                values[i]=false;\\n                cur/=10;\\n            }\\n        }else{\\n            for(int i=cur%10 -1;i>=1;i--){\\n                if(values[i])  continue;\\n                \\n                values[i]=true;\\n                cur=cur*10+i;\\n                solve(arr,cur,id+1,n);\\n                values[i]=false;\\n                cur/=10;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616432,
                "title": "clean-code-c-using-stack-explained-time-o-n-space-o-n",
                "content": "\\n# Approach\\n\\nIterate over the pattern string:\\n\\n- If the current character is \\'D\\', it means we need to create a decreasing sequence. In this case, push the current value of k onto the stack \\'st\\' and increment k.\\n- If the current character is \\'I\\' and the stack \\'st\\' is not empty, it means we need to create an increasing sequence. In this case, append the current value of k to the string x and then pop all the elements from the stack \\'st\\' and append them to x. Finally, increment k.\\n- If the current character is neither \\'D\\' nor \\'I\\', it means we have an invalid character in the pattern. We can ignore it or handle it as desired. In this code, it simply increments k without appending it to x.\\n\\n\\nAfter the loop ends, we have processed all the characters in the pattern. Now, we need to append the remaining elements in the stack \\'st\\' to the string x. This is done using a separate loop that pops elements from the stack, appends them to x, and increments k.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)      // to iterate over pattern string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  O(n)      //for maintaining the stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<int>st;\\n        string x;\\n        int i=0;\\n        char k=\\'1\\';\\n      \\n        while(i<pattern.size())\\n        {\\n            if(pattern[i]==\\'D\\')\\n            {\\n                st.push(k);\\n                k++;\\n            }\\n            else if(pattern[i]==\\'I\\' && st.size()>0)\\n            {\\n                x.push_back(k);\\n                while(!st.empty())\\n                {\\n                    int temp=satyaa.top();\\n                    satyaa.pop();\\n                    x.push_back(temp);\\n                }\\n                k++;\\n            }\\n            else\\n            {\\n                x.push_back(k);\\n                k++;\\n            }\\n            i++;\\n\\n        }\\n\\n    **//stack will not be empty in those testcases in which string ends with charcter \\'D\\'**\\n     \\n        int z=pattern.size();\\n        st.push(z+1+\\'0\\');\\n        while(!st.empty())\\n        {\\n            int t=st.top();\\n            st.pop();\\n            x.push_back(t);\\n            k++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<int>st;\\n        string x;\\n        int i=0;\\n        char k=\\'1\\';\\n      \\n        while(i<pattern.size())\\n        {\\n            if(pattern[i]==\\'D\\')\\n            {\\n                st.push(k);\\n                k++;\\n            }\\n            else if(pattern[i]==\\'I\\' && st.size()>0)\\n            {\\n                x.push_back(k);\\n                while(!st.empty())\\n                {\\n                    int temp=satyaa.top();\\n                    satyaa.pop();\\n                    x.push_back(temp);\\n                }\\n                k++;\\n            }\\n            else\\n            {\\n                x.push_back(k);\\n                k++;\\n            }\\n            i++;\\n\\n        }\\n\\n    **//stack will not be empty in those testcases in which string ends with charcter \\'D\\'**\\n     \\n        int z=pattern.size();\\n        st.push(z+1+\\'0\\');\\n        while(!st.empty())\\n        {\\n            int t=st.top();\\n            st.pop();\\n            x.push_back(t);\\n            k++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209231,
                "title": "proof-of-the-algorithm",
                "content": "# Algorithm\\nPlace digits in order $12345...$ then reverse all substrings corresponding to $D^+I$ patterns.\\n# Proof\\nWe\\'ll use 1-based index here. Let\\'s call $i$ \"reversed\" if $i$ is in an interval corresponding to a $D^+I$ pattern (i.e. $pattern[i] = D$ or $pattern[i - 1] = D$). Then the above algorithm can be expressed as:\\n- If $i$ is reversed, $s[i] := l + r - i + 1$, where \\n    - $l$ is the index of the closest $I$ on the left if it exists, or $-1$ otherwise\\n    - $r$ is the index of the closest $I$ on the right if it exists, or $N$ otherwise.\\n- Otherwise, $s[i] := i$.\\n\\n**Lemma 1**: If $i$ is not reversed, $s[1 \\\\dots i-1]$ is a permutation of $[1, i-1]$. \\nThis can be proved by induction.\\n\\nNow suppose there is a better solution $s\\'$, and $i$ is the first index where $s\\'[i] \\\\neq s[i]$, then by our assumption $s\\'[i] < s[i]$:\\n- If $i$ is not reversed, this is impossible, because, by Lemma 1, $s\\'[1 \\\\dots i-1] = s[1 \\\\dots i -1]$ already contains all numbers less than $i$, so we must have $s\\'[i] \\\\geq i = s[i]$.\\n- If $i$ is reversed, then again by Lemma 1, $s\\'[1 \\\\dots l] = s[1 \\\\dots l]$ contains all numbers in $[1 \\\\dots l]$. Thus, $s\\'[i]$ is greater than all distinct numbers in both $s\\'[1 \\\\cdots l]$ and $s\\'[i + 1 \\\\dots r]$. There are $l + r - i$ of them, therefore $s\\'[i] \\\\geq l + r - i + 1 = s[i]$.\\n\\nWe arrived at contradictions in both cases, therefore there cannot be better solutions.",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "# Algorithm\\nPlace digits in order $12345...$ then reverse all substrings corresponding to $D^+I$ patterns.\\n# Proof\\nWe\\'ll use 1-based index here. Let\\'s call $i$ \"reversed\" if $i$ is in an interval corresponding to a $D^+I$ pattern (i.e. $pattern[i] = D$ or $pattern[i - 1] = D$). Then the above algorithm can be expressed as:\\n- If $i$ is reversed, $s[i] := l + r - i + 1$, where \\n    - $l$ is the index of the closest $I$ on the left if it exists, or $-1$ otherwise\\n    - $r$ is the index of the closest $I$ on the right if it exists, or $N$ otherwise.\\n- Otherwise, $s[i] := i$.\\n\\n**Lemma 1**: If $i$ is not reversed, $s[1 \\\\dots i-1]$ is a permutation of $[1, i-1]$. \\nThis can be proved by induction.\\n\\nNow suppose there is a better solution $s\\'$, and $i$ is the first index where $s\\'[i] \\\\neq s[i]$, then by our assumption $s\\'[i] < s[i]$:\\n- If $i$ is not reversed, this is impossible, because, by Lemma 1, $s\\'[1 \\\\dots i-1] = s[1 \\\\dots i -1]$ already contains all numbers less than $i$, so we must have $s\\'[i] \\\\geq i = s[i]$.\\n- If $i$ is reversed, then again by Lemma 1, $s\\'[1 \\\\dots l] = s[1 \\\\dots l]$ contains all numbers in $[1 \\\\dots l]$. Thus, $s\\'[i]$ is greater than all distinct numbers in both $s\\'[1 \\\\cdots l]$ and $s\\'[i + 1 \\\\dots r]$. There are $l + r - i$ of them, therefore $s\\'[i] \\\\geq l + r - i + 1 = s[i]$.\\n\\nWe arrived at contradictions in both cases, therefore there cannot be better solutions.",
                "codeTag": "Unknown"
            },
            {
                "id": 2800278,
                "title": "100-faster-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<int> s;\\n        string str = \"\";\\n        for(int i = 0; i <= pattern.length(); i++){\\n            s.push(i+1);\\n            if(i==pattern.length() || pattern[i] == \\'I\\'){\\n                 while(!s.empty()){\\n                     str = str + to_string(s.top());\\n                     s.pop();\\n                 }\\n             }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<int> s;\\n        string str = \"\";\\n        for(int i = 0; i <= pattern.length(); i++){\\n            s.push(i+1);\\n            if(i==pattern.length() || pattern[i] == \\'I\\'){\\n                 while(!s.empty()){\\n                     str = str + to_string(s.top());\\n                     s.pop();\\n                 }\\n             }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617573,
                "title": "c-easy-reverse-solution",
                "content": "class Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        \\n        string s=\"\";\\n        for(int i=0;i<=p.size();i++){\\n            s+=(i+1)+\\'0\\';\\n        }\\n        \\n        \\n        for(int i=0;i<s.size();){\\n            \\n            if(p[i]==\\'D\\'){\\n                int j=i;\\n                \\n                while(p[j]==\\'D\\'){\\n                    j++;\\n                }\\n                reverse(s.begin()+i,s.begin()+j+1);\\n                i=j+1;\\n            }else {\\n                i++;\\n            }\\n        }\\n        \\n        \\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        \\n        string s=\"\";\\n        for(int i=0;i<=p.size();i++){\\n            s+=(i+1)+\\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2480419,
                "title": "construct-smallest-number-from-di-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int sz=pattern.size();\\n        string num=\"\";\\n        for(int i=0;i<=sz;i++){\\n            num+=to_string(i+1);\\n        }\\n        for(int i=0;i<sz;i++){\\n            for(int j=0;j<sz;j++){\\n                if(pattern[j]==\\'I\\'){\\n                    if(num[j]-\\'0\\'>num[j+1]-\\'0\\'){\\n                        swap(num[j],num[j+1]);\\n                    }\\n                }\\n                else if(pattern[j]==\\'D\\'){\\n                    if(num[j]-\\'0\\'<num[j+1]-\\'0\\'){\\n                        swap(num[j],num[j+1]);\\n                    }\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int sz=pattern.size();\\n        string num=\"\";\\n        for(int i=0;i<=sz;i++){\\n            num+=to_string(i+1);\\n        }\\n        for(int i=0;i<sz;i++){\\n            for(int j=0;j<sz;j++){\\n                if(pattern[j]==\\'I\\'){\\n                    if(num[j]-\\'0\\'>num[j+1]-\\'0\\'){\\n                        swap(num[j],num[j+1]);\\n                    }\\n                }\\n                else if(pattern[j]==\\'D\\'){\\n                    if(num[j]-\\'0\\'<num[j+1]-\\'0\\'){\\n                        swap(num[j],num[j+1]);\\n                    }\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468870,
                "title": "simple-greedy-solution-beats-100",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string ans = \"\";\\n        char ch = \\'1\\';\\n        int n = pattern.size();\\n        for(int i = 0 ;i<=n;i++){\\n            ans.push_back(ch++);\\n        }\\n\\n        for(int i = 0 ;i<n;i++){\\n            if(pattern[i] == \\'D\\'){\\n                int j = i;\\n                while(i<n and pattern[i] == \\'D\\'){\\n                    i++;\\n                }\\n                reverse(ans.begin()+j,ans.begin()+i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\nP.S \\nPlease ask queries if any.\\nUpvote if you liked it . And thanks in advance.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string ans = \"\";\\n        char ch = \\'1\\';\\n        int n = pattern.size();\\n        for(int i = 0 ;i<=n;i++){\\n            ans.push_back(ch++);\\n        }\\n\\n        for(int i = 0 ;i<n;i++){\\n            if(pattern[i] == \\'D\\'){\\n                int j = i;\\n                while(i<n and pattern[i] == \\'D\\'){\\n                    i++;\\n                }\\n                reverse(ans.begin()+j,ans.begin()+i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437716,
                "title": "easy-implementation-cakewalk",
                "content": "I was thinking greedy, recursion(due to small input), and what not. \\nCouldn\\'t go any ahead, tired with all this I started making dummy input cases and was trying to find some kind of relation, and I was struck with recurring pattern between a strictly increasing string \"IIIII...\" and it\\'s variations \"IDDDI..\" of the same size. \\n\\nThis question was to check our pattern checking abilities, if pattern = \"IIII\" then the minimum number which can be formed in correspondence to this pattern would be : 12345,\\nif the pattern would have been : IIDI, then : 12435, if the pattern would have been, IDID\\n13254.\\nSo the idea was to uitilize all the elements that would have been in an strictly increasing string of the same size.\\n\\n IIIIIIII -> 123456789, \\n IIIDIDDD -> 123549876\\n IIIDIDID -> 123547698 \\n IIDDDDID -> 127654398 \\n DDDIDDID -> 432176598\\n \\nAnd every time we find a segment like this : \"DDD..I\" we have to revese this segment in our strictly increasing string. Why are we doing what we are doing? \\nIf I say, think of the smallest string, that can be made with a pattern size n  : 1234567..(n+1), suppose the string is of size 5, then the smallest number that can be made will be 123456, simple. Now for any variation in pattern we have to utilize these digits only. Suppose we have a  segment in  which we have \"I**DDI**I\", here for the segment **DDI**,\\nfirst digit -> 1\\nsecond, third, fourth(before) 2,3,4 for pattern **\"III\"**, if I want to **\"DDI\"**, then I can simply start with 4 and decrease it twice, 3, 2, and then digit  will simply add up. \\nfifth digit -> 5\\nsixth digit -> 6\\n\\nso the final sequence will be, **143256**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        \\n\\t\\t//create a string for the strictly increasing pattern, this string \\n\\t\\t// will be altered further : \\n\\t\\t\\n        string ans = \"\";\\n        for(int i=0; i<n+1; i++) {\\n            ans += to_string(i+1);\\n        }\\n\\t\\t\\n        //traverse through the pattern string and find \\'D\\'\\n        for(int idx = 0; idx < n; idx++) {\\n\\t\\t//if find \\'D\\' now you have to find the next \\'I\\', so as to \\n\\t\\t//find a proper segment. \\n            if(pattern[idx] == \\'D\\') {\\n                int idxI = findI(pattern, idx);\\n                reverseSeg(ans, idx, idxI);\\n                idx = idxI; //jump on to the next segment, because this \\n\\t\\t\\t\\t//has already been reversed.\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n    \\nprivate: \\n    //find \\'I\\', and if not found it means the sequence is like : \\n    // something..DDDD, now you need to reverse it till the end.\\n    int findI(string &pattern, int idxOfD) {\\n        int n = pattern.size();\\n        for(int idx = idxOfD; idx < n; idx++) {\\n            if(pattern[idx] == \\'I\\') return idx;\\n        }\\n        \\n        return n;\\n    }\\n    \\n    //reverse the given segment.\\n    void reverseSeg(string &ans,  int i, int j) {\\n        while(i < j) {\\n            swap(ans[i], ans[j]);\\n            i++, j--;\\n        }\\n    }\\n};\\n```\\n\\n\\nI hope you enjoyed this solution, *viva la vida*",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        \\n\\t\\t//create a string for the strictly increasing pattern, this string \\n\\t\\t// will be altered further : \\n\\t\\t\\n        string ans = \"\";\\n        for(int i=0; i<n+1; i++) {\\n            ans += to_string(i+1);\\n        }\\n\\t\\t\\n        //traverse through the pattern string and find \\'D\\'\\n        for(int idx = 0; idx < n; idx++) {\\n\\t\\t//if find \\'D\\' now you have to find the next \\'I\\', so as to \\n\\t\\t//find a proper segment. \\n            if(pattern[idx] == \\'D\\') {\\n                int idxI = findI(pattern, idx);\\n                reverseSeg(ans, idx, idxI);\\n                idx = idxI; //jump on to the next segment, because this \\n\\t\\t\\t\\t//has already been reversed.\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n    \\nprivate: \\n    //find \\'I\\', and if not found it means the sequence is like : \\n    // something..DDDD, now you need to reverse it till the end.\\n    int findI(string &pattern, int idxOfD) {\\n        int n = pattern.size();\\n        for(int idx = idxOfD; idx < n; idx++) {\\n            if(pattern[idx] == \\'I\\') return idx;\\n        }\\n        \\n        return n;\\n    }\\n    \\n    //reverse the given segment.\\n    void reverseSeg(string &ans,  int i, int j) {\\n        while(i < j) {\\n            swap(ans[i], ans[j]);\\n            i++, j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432288,
                "title": "java-o-n-pre-processing-by-counting-number-of-consecutive-d-s",
                "content": "The idea is to count the number of consecutive D\\'s after each character in the pattern to know how much we have to increment for each nums[i] \\n\\n I    I    I   D   I   D   D  D   --- Pattern\\n0   0   1   0   3   2   1   0    ---  Pre-processed Array containing count of consecutive Ds \\n\\n\\nFunction to count Consecutive D\\'s\\n```\\n int[] dArray = fill(pattern, n);\\n public static int[] fill(char[] pattern, int n){\\n        int[] arr = new int[n];\\n        arr[n-1] = 0;\\n\\n        for(int i=n-2; i>=0; i--){\\n            if(pattern[i+1] == \\'D\\'){\\n                arr[i] = 1 + arr[i+1];\\n            }\\n            else arr[i] = 0;\\n        }\\n        return arr;\\n    }\\n```\\n\\nInitialise start with 1 (We can take numbers from 1-9 and smallest poosible number needs to be returned)\\n\\nNow, the array named dArray contains the pre-processed array depicting number of consecutive D\\'s (decrements required) after each character. \\n\\nWhenever we encounter an \\'I\\' generally we should do` start++`, but now we will do - \\n```\\nstart = start + 1 + dArray[i]\\n```\\n\\nOn the other hand, while encountering any \\'D\\' we can simply decrement the last value appended in the result by 1. \\n\\nFor the first character of result - \\n```\\n   int start = 1;\\n\\n        if(pattern[0] == \\'D\\'){\\n            start = start + 1 + dArray[0];\\n        }\\n        sb.append(start);\\n```\\n\\nIf its an \\'I\\' we can simply start with 1, but for a D, we should increment the start by the number of consectuive D\\'s present. \\n\\n\\n```\\npublic String smallestNumber(String s) {\\n        \\n        char[] pattern = s.toCharArray();\\n        int n = pattern.length;\\n        StringBuilder sb = new StringBuilder();\\n\\n        int[] dArray = fill(pattern, n);\\n\\n        int start = 1;\\n\\n        if(pattern[0] == \\'D\\'){\\n            start = start + 1 + dArray[0];\\n        }\\n        sb.append(start);\\n\\n        for(int i=0; i<n; i++){\\n            if(pattern[i] == \\'I\\'){\\n                start = start + 1 + dArray[i];\\n                sb.append(start);\\n            }\\n            else{\\n                int num = sb.toString().charAt(sb.toString().length()-1) - \\'0\\';\\n                sb.append(num-1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n\\nUpvote, if you like! :) \\n\\n\\t\\t  \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n int[] dArray = fill(pattern, n);\\n public static int[] fill(char[] pattern, int n){\\n        int[] arr = new int[n];\\n        arr[n-1] = 0;\\n\\n        for(int i=n-2; i>=0; i--){\\n            if(pattern[i+1] == \\'D\\'){\\n                arr[i] = 1 + arr[i+1];\\n            }\\n            else arr[i] = 0;\\n        }\\n        return arr;\\n    }\\n```\n```\\nstart = start + 1 + dArray[i]\\n```\n```\\n   int start = 1;\\n\\n        if(pattern[0] == \\'D\\'){\\n            start = start + 1 + dArray[0];\\n        }\\n        sb.append(start);\\n```\n```\\npublic String smallestNumber(String s) {\\n        \\n        char[] pattern = s.toCharArray();\\n        int n = pattern.length;\\n        StringBuilder sb = new StringBuilder();\\n\\n        int[] dArray = fill(pattern, n);\\n\\n        int start = 1;\\n\\n        if(pattern[0] == \\'D\\'){\\n            start = start + 1 + dArray[0];\\n        }\\n        sb.append(start);\\n\\n        for(int i=0; i<n; i++){\\n            if(pattern[i] == \\'I\\'){\\n                start = start + 1 + dArray[i];\\n                sb.append(start);\\n            }\\n            else{\\n                int num = sb.toString().charAt(sb.toString().length()-1) - \\'0\\';\\n                sb.append(num-1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431418,
                "title": "c-clean-o-n-stack",
                "content": "```cpp\\nclass Solution {\\n public:\\n  string smallestNumber(string pattern) {\\n    string ans;\\n    stack<char> stack{{\\'1\\'}};\\n\\n    for (const char c : pattern) {\\n      char maxSorFar = stack.top();\\n      if (c == \\'I\\')\\n        while (!stack.empty()) {\\n          maxSorFar = max(maxSorFar, stack.top());\\n          ans += stack.top(), stack.pop();\\n        }\\n      stack.push(maxSorFar + 1);\\n    }\\n\\n    while (!stack.empty())\\n      ans += stack.top(), stack.pop();\\n\\n    return ans;\\n  }\\n};\\n```\\n\\nTime: O(n)\\nSpace: O(n)",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\n public:\\n  string smallestNumber(string pattern) {\\n    string ans;\\n    stack<char> stack{{\\'1\\'}};\\n\\n    for (const char c : pattern) {\\n      char maxSorFar = stack.top();\\n      if (c == \\'I\\')\\n        while (!stack.empty()) {\\n          maxSorFar = max(maxSorFar, stack.top());\\n          ans += stack.top(), stack.pop();\\n        }\\n      stack.push(maxSorFar + 1);\\n    }\\n\\n    while (!stack.empty())\\n      ans += stack.top(), stack.pop();\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425793,
                "title": "worst-solution-using-backtracking",
                "content": "Check every possible string and then check if it is valid according to the conditions given in the question\\n\\n```\\nclass Solution {\\npublic:\\n    bool found = false;\\n    void rec(int dig,int i,string& ptrn,vector<int>& ans,map<int,int>& mp){\\n        if(i == ptrn.size()) {\\n            found = true;\\n            return;\\n        }\\n        if(ptrn[i] == \\'I\\'){\\n            for(int j=dig+1;j<=9;j++){\\n                if(mp[j] == 0) {\\n                    ans.push_back(j);\\n                    mp[j]++;\\n                    rec(j,i+1,ptrn,ans,mp);\\n                    if(found) return;\\n                    mp[j]--;\\n                    ans.pop_back();\\n                }\\n            }\\n        }\\n        else{\\n            for(int j=dig-1;j>=1;j--){\\n                if(mp[j] == 0) {\\n                    ans.push_back(j);\\n                    mp[j]++;\\n                    rec(j,i+1,ptrn,ans,mp);\\n                    if(found) return;\\n                    mp[j]--;\\n                    ans.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i=1;i<=9;i++){\\n            ans.push_back(i);\\n            mp[i]++;\\n            rec(i,0,pattern,ans,mp);\\n            if(found) break;\\n            mp[i]--;\\n            ans.pop_back();\\n        }\\n        \\n        string ss;\\n        // cout<<ans.size()<<endl;\\n        for(int i=0;i<=pattern.size();i++){\\n            ss.push_back(char(48 + ans[i]));\\n        }\\n        \\n        return ss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool found = false;\\n    void rec(int dig,int i,string& ptrn,vector<int>& ans,map<int,int>& mp){\\n        if(i == ptrn.size()) {\\n            found = true;\\n            return;\\n        }\\n        if(ptrn[i] == \\'I\\'){\\n            for(int j=dig+1;j<=9;j++){\\n                if(mp[j] == 0) {\\n                    ans.push_back(j);\\n                    mp[j]++;\\n                    rec(j,i+1,ptrn,ans,mp);\\n                    if(found) return;\\n                    mp[j]--;\\n                    ans.pop_back();\\n                }\\n            }\\n        }\\n        else{\\n            for(int j=dig-1;j>=1;j--){\\n                if(mp[j] == 0) {\\n                    ans.push_back(j);\\n                    mp[j]++;\\n                    rec(j,i+1,ptrn,ans,mp);\\n                    if(found) return;\\n                    mp[j]--;\\n                    ans.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i=1;i<=9;i++){\\n            ans.push_back(i);\\n            mp[i]++;\\n            rec(i,0,pattern,ans,mp);\\n            if(found) break;\\n            mp[i]--;\\n            ans.pop_back();\\n        }\\n        \\n        string ss;\\n        // cout<<ans.size()<<endl;\\n        for(int i=0;i<=pattern.size();i++){\\n            ss.push_back(char(48 + ans[i]));\\n        }\\n        \\n        return ss;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2425496,
                "title": "c-iterative-o-1-space-0ms",
                "content": "```\\nstring smallestNumber(string pattern) {\\n        string ans = \"\";\\n        int n = pattern.size();\\n        for(int i=0; i<=pattern.size(); i++){            \\n            while(pattern[i] == \\'I\\'){\\n                ans += (char) ((i+1) + \\'0\\');\\n                i++;\\n            }\\n\\n            int c = 0;\\n            while(pattern[i] == \\'D\\'){\\n                i++;\\n                c++;\\n            }\\n            \\n            int x = i+1;\\n            c++;\\n            while(c--){\\n                ans += (char)(x + \\'0\\');\\n                x--;\\n            }            \\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring smallestNumber(string pattern) {\\n        string ans = \"\";\\n        int n = pattern.size();\\n        for(int i=0; i<=pattern.size(); i++){            \\n            while(pattern[i] == \\'I\\'){\\n                ans += (char) ((i+1) + \\'0\\');\\n                i++;\\n            }\\n\\n            int c = 0;\\n            while(pattern[i] == \\'D\\'){\\n                i++;\\n                c++;\\n            }\\n            \\n            int x = i+1;\\n            c++;\\n            while(c--){\\n                ans += (char)(x + \\'0\\');\\n                x--;\\n            }            \\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2424837,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        \\n        def backtrack(i, curr):\\n            if i == len(pattern):\\n                return True\\n            \\n            if pattern[i] == \\'I\\':\\n                start, end, step = curr[-1] + 1, 10, 1\\n            else:\\n                start, end, step = curr[-1] - 1, 0, -1\\n                \\n            for j in range(start, end, step):\\n                if j not in curr:\\n                    curr.append(j)\\n                    if backtrack(i + 1, curr):\\n                        return True\\n                    curr.pop()\\n            \\n            return False\\n        \\n        for s in range(1, 10):\\n            curr = [s]\\n            if backtrack(0, curr):\\n                return \"\".join(map(str, curr))\\n        \\n        return \"\"\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        \\n        def backtrack(i, curr):\\n            if i == len(pattern):\\n                return True\\n            \\n            if pattern[i] == \\'I\\':\\n                start, end, step = curr[-1] + 1, 10, 1\\n            else:\\n                start, end, step = curr[-1] - 1, 0, -1\\n                \\n            for j in range(start, end, step):\\n                if j not in curr:\\n                    curr.append(j)\\n                    if backtrack(i + 1, curr):\\n                        return True\\n                    curr.pop()\\n            \\n            return False\\n        \\n        for s in range(1, 10):\\n            curr = [s]\\n            if backtrack(0, curr):\\n                return \"\".join(map(str, curr))\\n        \\n        return \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424360,
                "title": "c-easy-reverse-solution",
                "content": "**please do upvote if you find this helpful**\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n=pattern.size();\\n        string ans;\\n        int cnt=0;\\n        while(cnt<n+1){ // Pushing pattern.size()+1 digits in the ans string\\n            ans.push_back(char(\\'1\\'+cnt));\\n            cnt++;\\n        }\\n        for(int i=0;i<n;i++){\\n            int strt=i; // Calculating the starting and ending position of \\'D\\'\\n            while(i<n && pattern[i]==\\'D\\'){\\n                i++;\\n            }\\n            int k=i; //Reverse from start index of \\'D\\' to (i) where \\'D\\' ends.\\n            while(strt<k){\\n                swap(ans[strt],ans[k]);\\n                strt++;\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n=pattern.size();\\n        string ans;\\n        int cnt=0;\\n        while(cnt<n+1){ // Pushing pattern.size()+1 digits in the ans string\\n            ans.push_back(char(\\'1\\'+cnt));\\n            cnt++;\\n        }\\n        for(int i=0;i<n;i++){\\n            int strt=i; // Calculating the starting and ending position of \\'D\\'\\n            while(i<n && pattern[i]==\\'D\\'){\\n                i++;\\n            }\\n            int k=i; //Reverse from start index of \\'D\\' to (i) where \\'D\\' ends.\\n            while(strt<k){\\n                swap(ans[strt],ans[k]);\\n                strt++;\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423300,
                "title": "c-java-using-stack-and-next-permutation-easy-solution",
                "content": "**Approach 1: (Brute-Force(Next permutation) \\u2705**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size()+1;\\n        vector<int> v;\\n        \\n        for(int i = 0;i<n;i++){\\n            v.push_back(i+1);\\n        }\\n        while(1)\\n        {\\n            bool flag = false;\\n            for(int i=1;i<n;i++)\\n            {\\n                if((pattern[i-1] == \\'I\\' && v[i] > v[i-1]) || (pattern[i-1] == \\'D\\' && v[i] < v[i-1]))\\n                {\\n                    continue;\\n                }\\n                flag = true;\\n                break;\\n            }\\n            if(!flag)\\n            {\\n                string s;\\n                for(int i=0;i<n;i++){\\n                    s+=(v[i]+\\'0\\');\\n                }\\n                return s;\\n            }\\n            next_permutation(v.begin(),v.end());\\n        }\\n        return \"\";\\n    }\\n};\\n```\\n\\n**Approach 2: (Using Stack (Reversing) \\u2705AC**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string result;\\n        stack<int> s;\\n        for(int i=0;i<= pattern.length();i++)\\n        {\\n            s.push(i+1);\\n            if(i == pattern.length() || pattern[i] == \\'I\\')\\n            {\\n                while(!s.empty())\\n                {\\n                    result += to_string(s.top());\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\ntring smallestNumber(string pattern) {\\n        string result;\\n        stack<int> s;\\n        for (int i = 0; i <= pattern.length(); i++)\\n        {\\n            s.push(i + 1);\\n            if (i == pattern.length() || pattern[i] == \\'I\\')\\n            {\\n                while (!s.empty())\\n                {\\n                    result += to_string(s.top());\\n                    s.pop();\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\n**Do not forget to upvote if you like the solution**",
                "solutionTags": [
                    "Java",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size()+1;\\n        vector<int> v;\\n        \\n        for(int i = 0;i<n;i++){\\n            v.push_back(i+1);\\n        }\\n        while(1)\\n        {\\n            bool flag = false;\\n            for(int i=1;i<n;i++)\\n            {\\n                if((pattern[i-1] == \\'I\\' && v[i] > v[i-1]) || (pattern[i-1] == \\'D\\' && v[i] < v[i-1]))\\n                {\\n                    continue;\\n                }\\n                flag = true;\\n                break;\\n            }\\n            if(!flag)\\n            {\\n                string s;\\n                for(int i=0;i<n;i++){\\n                    s+=(v[i]+\\'0\\');\\n                }\\n                return s;\\n            }\\n            next_permutation(v.begin(),v.end());\\n        }\\n        return \"\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string result;\\n        stack<int> s;\\n        for(int i=0;i<= pattern.length();i++)\\n        {\\n            s.push(i+1);\\n            if(i == pattern.length() || pattern[i] == \\'I\\')\\n            {\\n                while(!s.empty())\\n                {\\n                    result += to_string(s.top());\\n                    s.pop();\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\ntring smallestNumber(string pattern) {\\n        string result;\\n        stack<int> s;\\n        for (int i = 0; i <= pattern.length(); i++)\\n        {\\n            s.push(i + 1);\\n            if (i == pattern.length() || pattern[i] == \\'I\\')\\n            {\\n                while (!s.empty())\\n                {\\n                    result += to_string(s.top());\\n                    s.pop();\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422854,
                "title": "c-using-next-permutation-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string s=\"\";// creating string of size pattern.size()+1\\n         for(int i=0;i<=pattern.size();i++)\\n         {\\n             s+=\"#\";\\n         }\\n        int j=1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            s[i]=j+\\'0\\';  //storing the digits\\n            j++;\\n        }\\n       int x=s.size();\\n        do\\n        {\\n            int c=0; // keeping a counter variable for  checking if satisfying all conditions in accordance to string pattern\\n            for(int i=0;i<pattern.size();i++)\\n            {\\n                \\n                if(pattern[i]==\\'I\\')\\n                {\\n                    if(s[i]-\\'0\\'>s[i+1]-\\'0\\')  // checking if not satisying incresing condition then break\\n                        break;\\n                }\\n                else if(pattern[i]==\\'D\\')\\n                {\\n                    if(s[i]-\\'0\\'<s[i+1]-\\'0\\') // checking if not satisfying decreasing condition then break\\n                        break;\\n                }\\n                c++;\\n            }\\n             if(c==pattern.size())\\n                break;\\n        }while(next_permutation(s.begin(),s.end()));\\n        return s;\\n    }\\n};\\n```\\n**Please Upvote if you like it**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string s=\"\";// creating string of size pattern.size()+1\\n         for(int i=0;i<=pattern.size();i++)\\n         {\\n             s+=\"#\";\\n         }\\n        int j=1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            s[i]=j+\\'0\\';  //storing the digits\\n            j++;\\n        }\\n       int x=s.size();\\n        do\\n        {\\n            int c=0; // keeping a counter variable for  checking if satisfying all conditions in accordance to string pattern\\n            for(int i=0;i<pattern.size();i++)\\n            {\\n                \\n                if(pattern[i]==\\'I\\')\\n                {\\n                    if(s[i]-\\'0\\'>s[i+1]-\\'0\\')  // checking if not satisying incresing condition then break\\n                        break;\\n                }\\n                else if(pattern[i]==\\'D\\')\\n                {\\n                    if(s[i]-\\'0\\'<s[i+1]-\\'0\\') // checking if not satisfying decreasing condition then break\\n                        break;\\n                }\\n                c++;\\n            }\\n             if(c==pattern.size())\\n                break;\\n        }while(next_permutation(s.begin(),s.end()));\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422813,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans=\"\";\\n    bool isValid(string &a, string &patt){\\n        for(int i = 0; i < patt.size(); i++){\\n            if(patt[i] == \\'I\\'){\\n                if(a[i]>=a[i + 1]){\\n                    return false;\\n                }\\n            }else{\\n                if(a[i]<=a[i + 1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\nvoid permute(string &a, int l, int r, string &patt) { \\n    if (l == r){\\n        if(isValid(a, patt)){\\n\\n             if(ans.size()==0){\\n                ans = a;\\n            }else{\\n                 ans = min(ans, a);\\n             }\\n        }\\n        return;\\n    }else{ \\n        for (int i = l; i <= r; i++){ \\n  \\n            swap(a[l], a[i]); \\n  \\n            permute(a, l+1, r, patt); \\n  \\n            swap(a[l], a[i]); \\n        } \\n    } \\n} \\n    string smallestNumber(string patt) {\\n        string p = \"\";\\n        int n = patt.size();\\n        for(int i = 1; i <= n + 1; i++){\\n            p.push_back(i + \\'0\\');\\n        }\\n        permute(p, 0, n, patt);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string ans=\"\";\\n    bool isValid(string &a, string &patt){\\n        for(int i = 0; i < patt.size(); i++){\\n            if(patt[i] == \\'I\\'){\\n                if(a[i]>=a[i + 1]){\\n                    return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2422585,
                "title": "javascript-brute-force-swap-at-d",
                "content": "1. the base answer is `123...n` in ascending order if all \"I\" in the pattern. eg: `III...I`\\n2. only if meet \"D\", swap with `i & i+1`\\n3. for previous validation, swap`i` and check at [...i-2, i-1] until it\\'s valid\\n\\n```\\nvar smallestNumber = function(pattern) {\\n    // Input: pattern = \"IIIDIDDD\"\\n    // Output: \"1 2 3 5 4 8 7 6 9\"\\n    const n = pattern.length + 1;\\n    const res = new Array(n).fill(0).map((el, index)=>index+1);\\n    for(let i = 0 ; i< n-1; i++)\\n    {\\n        if(pattern[i] == \\'I\\'){\\n            continue;\\n        }\\n        else if(pattern[i] === \\'D\\') {\\n            // swap i & i+1\\n            [res[i], res[i+1]] = [res[i+1], res[i]];\\n            for(let j = i-1; j>=0; j--) {\\n                if( (pattern[j] === \\'I\\' && res[j] < res[j+1]) || (pattern[j] === \\'D\\' && res[j] > res[j+1]) ) {\\n                    // valid at j\\n                    break;\\n                }\\n                else {\\n                        // swap j & j+1\\n                        [res[j], res[j+1]] = [res[j+1], res[j]];\\n                }\\n            }\\n        }\\n    }\\n    return res.join(\\'\\'); \\n};\\n```\\n\\n**Improved \"Reverse\" solution:**\\n```\\nvar smallestNumber = function(pattern) {\\n    // Input: pattern = \"IIIDIDDD\"\\n    // reverse when continous \"D\"\\n    const n = pattern.length + 1;\\n    const res = new Array(n).fill(0).map((el, index)=>index+1);\\n    for(let i = 0 ; i< n-1; i++)\\n    {\\n        if(pattern[i] == \\'I\\'){\\n            continue;\\n        }\\n        else {\\n            let j = i;\\n            while(j <n-1 && pattern[j] === \\'D\\'){\\n                j++;                \\n            }\\n            // reverse from i to j in res array\\n            reverse(res, i, j);  \\n            i = j-1;\\n        }\\n    }\\n    return res.join(\\'\\'); \\n};\\nfunction reverse(arr, i, j) {\\n    while(i<j){\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n        i++;\\n        j--;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallestNumber = function(pattern) {\\n    // Input: pattern = \"IIIDIDDD\"\\n    // Output: \"1 2 3 5 4 8 7 6 9\"\\n    const n = pattern.length + 1;\\n    const res = new Array(n).fill(0).map((el, index)=>index+1);\\n    for(let i = 0 ; i< n-1; i++)\\n    {\\n        if(pattern[i] == \\'I\\'){\\n            continue;\\n        }\\n        else if(pattern[i] === \\'D\\') {\\n            // swap i & i+1\\n            [res[i], res[i+1]] = [res[i+1], res[i]];\\n            for(let j = i-1; j>=0; j--) {\\n                if( (pattern[j] === \\'I\\' && res[j] < res[j+1]) || (pattern[j] === \\'D\\' && res[j] > res[j+1]) ) {\\n                    // valid at j\\n                    break;\\n                }\\n                else {\\n                        // swap j & j+1\\n                        [res[j], res[j+1]] = [res[j+1], res[j]];\\n                }\\n            }\\n        }\\n    }\\n    return res.join(\\'\\'); \\n};\\n```\n```\\nvar smallestNumber = function(pattern) {\\n    // Input: pattern = \"IIIDIDDD\"\\n    // reverse when continous \"D\"\\n    const n = pattern.length + 1;\\n    const res = new Array(n).fill(0).map((el, index)=>index+1);\\n    for(let i = 0 ; i< n-1; i++)\\n    {\\n        if(pattern[i] == \\'I\\'){\\n            continue;\\n        }\\n        else {\\n            let j = i;\\n            while(j <n-1 && pattern[j] === \\'D\\'){\\n                j++;                \\n            }\\n            // reverse from i to j in res array\\n            reverse(res, i, j);  \\n            i = j-1;\\n        }\\n    }\\n    return res.join(\\'\\'); \\n};\\nfunction reverse(arr, i, j) {\\n    while(i<j){\\n        [arr[i], arr[j]] = [arr[j], arr[i]];\\n        i++;\\n        j--;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422553,
                "title": "easy-c-code",
                "content": "![image](https://assets.leetcode.com/users/images/318d10be-e444-4088-a57f-226d5b31a6d0_1660451700.1888492.jpeg)\\n\\nclass Solution {\\npublic:\\n\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        vector<int> v(pattern.size() + 1);\\n        int x = 1, cnt = 0;\\n        for(int i = 0; i < pattern.size(); i++) {\\n            if(pattern[i] == \\'I\\') {\\n                v[i] = x++;\\n                if(cnt != 0) {\\n                    for(int j = i - 1; j >= 0 and cnt > 0; j--) {\\n                        if(v[j] == 0) {\\n                            v[j] = x++;\\n                            cnt--;\\n                        }\\n                    }\\n                }\\n            }\\n            else cnt++;\\n        }  \\n        cnt++;\\n        if(cnt != 0) {\\n            for(int i = n; i >= 0 and cnt > 0; i--) {\\n                if(v[i] == 0) {\\n                    v[i] = x++;\\n                    cnt--;\\n                }\\n            }\\n        }\\n        string str;\\n        for(auto &it: v){\\n            str.append(to_string(it));\\n        }\\n        return str;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        vector<int> v(pattern.size() + 1);\\n        int x = 1, cnt = 0;\\n        for(int i = 0; i < pattern.size(); i++) {\\n            if(pattern[i] == \\'I\\') {\\n                v[i] = x++;\\n                if(cnt != 0) {\\n                    for(int j = i - 1; j >= 0 and cnt > 0; j--) {\\n                        if(v[j] == 0) {\\n                            v[j] = x++;\\n                            cnt--;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2422533,
                "title": "javascript-stack-easy-to-understand",
                "content": "```\\nvar smallestNumber = function (pattern) {\\n    let result = \"\"\\n    let stack = []\\n    for (let i = 0; i < pattern.length + 1; i++) {\\n        stack.push(i + 1)\\n        if (i === pattern.length || pattern[i] == \"I\") {\\n            while (stack.length) {\\n                result += stack[stack.length - 1]\\n                stack.pop()\\n            }\\n        }\\n    }\\n    return result\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar smallestNumber = function (pattern) {\\n    let result = \"\"\\n    let stack = []\\n    for (let i = 0; i < pattern.length + 1; i++) {\\n        stack.push(i + 1)\\n        if (i === pattern.length || pattern[i] == \"I\") {\\n            while (stack.length) {\\n                result += stack[stack.length - 1]\\n                stack.pop()\\n            }\\n        }\\n    }\\n    return result\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422440,
                "title": "javascript-dfs-backtracking-2867ms",
                "content": "Main idea: backtracking build string element is \\'1\\' ~ \\'9\\', and find the valid answer\\n```\\nlet p, res, n;\\nconst smallestNumber = (pattern) => {\\n    p = pattern;\\n    n = p.length;\\n    res = \\'\\';\\n    dfs([]);\\n    return res;\\n};\\n\\nconst dfs = (cur) => {\\n    if (cur.length > n + 1) return;\\n    if (cur.length == n + 1) { // valid answer\\n        let t = cur.join(\"\")\\n        if (res.length == 0) {\\n            res = t;\\n        } else {\\n            if (t < res) res = t; // get lexicographically smallest\\n        }\\n    }\\n    for (let i = \\'1\\'; i <= \\'9\\'; i++) { // build\\n        cur.push(i);\\n        if (ok(cur)) dfs(cur);\\n        cur.pop();\\n    }\\n};\\n\\nconst ok = (a) => { // check if current built string is valid\\n    let u = new Set(a);\\n    if (u.size != a.length) return false; // each digit can be used once, no duplicate\\n    for (let i = 1; i < a.length; i++) {\\n        let mark = a[i] > a[i - 1] ? \\'I\\' : \\'D\\';\\n        if (mark != p[i - 1]) return false; // should meet pattern condition\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet p, res, n;\\nconst smallestNumber = (pattern) => {\\n    p = pattern;\\n    n = p.length;\\n    res = \\'\\';\\n    dfs([]);\\n    return res;\\n};\\n\\nconst dfs = (cur) => {\\n    if (cur.length > n + 1) return;\\n    if (cur.length == n + 1) { // valid answer\\n        let t = cur.join(\"\")\\n        if (res.length == 0) {\\n            res = t;\\n        } else {\\n            if (t < res) res = t; // get lexicographically smallest\\n        }\\n    }\\n    for (let i = \\'1\\'; i <= \\'9\\'; i++) { // build\\n        cur.push(i);\\n        if (ok(cur)) dfs(cur);\\n        cur.pop();\\n    }\\n};\\n\\nconst ok = (a) => { // check if current built string is valid\\n    let u = new Set(a);\\n    if (u.size != a.length) return false; // each digit can be used once, no duplicate\\n    for (let i = 1; i < a.length; i++) {\\n        let mark = a[i] > a[i - 1] ? \\'I\\' : \\'D\\';\\n        if (mark != p[i - 1]) return false; // should meet pattern condition\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422366,
                "title": "just-reverse-the-decreasing-parts-c",
                "content": "My intuition here was to form the smallest unique number for the given string length and just reverse the parts that follow the decreasing pattern.\\n\\nFor Example:\\nFor the pattern:\\n```\\nIIIDIDDD\\n```\\nThe smallest uniqe number would be 123456789. So ignoring the increasing parts (containing \\'I\\'), we check for decreasing ones (containing \\'D\\').\\nAnd search continuously for the decreasing pattern and reverse it.\\n```\\n  I   I   I   D   I   D   D   D\\n1   2   3   4   5   6   7   8   9\\n\\t\\t\\t|___|   |___________|\\n```\\nUpon reversing the above parts we get:\\n```\\n1 2 3 5 4 9 8 7 6\\n```\\nIt satisfies our pattern condition while also being the smallest uniqe number.\\n\\n```\\nstring smallestNumber(string p) {\\n        int n = p.length();\\n        string ans = \"\";\\n        for(int i = 1; i <= n + 1; ++i)\\n            ans += (char)(i + \\'0\\');\\n        for(int i = 0; i < n; ++i){\\n            if(p[i] == \\'D\\'){\\n                int j = i;\\n                while(i < n && p[i] == \\'D\\') i++;\\n                reverse(ans.begin() + j, ans.begin() + i + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nIIIDIDDD\\n```\n```\\n  I   I   I   D   I   D   D   D\\n1   2   3   4   5   6   7   8   9\\n\\t\\t\\t|___|   |___________|\\n```\n```\\n1 2 3 5 4 9 8 7 6\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422244,
                "title": "simplest-approach-c-pattern-based-approach-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string str = \"\";\\n        int n = pattern.length();\\n        int highest = n+1;\\n        int maxtemp = 0;\\n        int cnt = 0;\\n        for(int i = 0; i<n; i++){\\n            \\n            int k = i;\\n            if(i>0 && (pattern[i] == \\'I\\' && pattern[i-1] == \\'D\\')){\\n                char c = (char)(maxtemp+1+48);\\n                str.push_back(c);\\n                maxtemp = i+1;\\n            }\\n            else if(pattern[i] == \\'I\\'){\\n                maxtemp = i+1;\\n                char c = (char)(maxtemp+48);\\n                str.push_back(c);\\n            }\\n            else if(pattern[i] == \\'D\\'){\\n                while(pattern[k] == \\'D\\'){\\n                    k++;\\n                    cnt++;\\n                }\\n                \\n                char c = (char)(maxtemp + cnt + 1 + 48);\\n                str.push_back(c);\\n                cnt = 0;\\n            }\\n            \\n           \\n        }\\n        if(pattern[n-1] == \\'I\\'){\\n                maxtemp = n+1;\\n                char c = (char)(maxtemp+48);\\n                str.push_back(c);\\n            }\\n            else if(pattern[n-1] == \\'D\\'){\\n                char c = (char)(maxtemp + cnt + 1 + 48);\\n                str.push_back(c);\\n                \\n            }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string str = \"\";\\n        int n = pattern.length();\\n        int highest = n+1;\\n        int maxtemp = 0;\\n        int cnt = 0;\\n        for(int i = 0; i<n; i++){\\n            \\n            int k = i;\\n            if(i>0 && (pattern[i] == \\'I\\' && pattern[i-1] == \\'D\\')){\\n                char c = (char)(maxtemp+1+48);\\n                str.push_back(c);\\n                maxtemp = i+1;\\n            }\\n            else if(pattern[i] == \\'I\\'){\\n                maxtemp = i+1;\\n                char c = (char)(maxtemp+48);\\n                str.push_back(c);\\n            }\\n            else if(pattern[i] == \\'D\\'){\\n                while(pattern[k] == \\'D\\'){\\n                    k++;\\n                    cnt++;\\n                }\\n                \\n                char c = (char)(maxtemp + cnt + 1 + 48);\\n                str.push_back(c);\\n                cnt = 0;\\n            }\\n            \\n           \\n        }\\n        if(pattern[n-1] == \\'I\\'){\\n                maxtemp = n+1;\\n                char c = (char)(maxtemp+48);\\n                str.push_back(c);\\n            }\\n            else if(pattern[n-1] == \\'D\\'){\\n                char c = (char)(maxtemp + cnt + 1 + 48);\\n                str.push_back(c);\\n                \\n            }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422235,
                "title": "python3-permutations-3-lines",
                "content": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        n=len(pattern)\\n        d=[]\\n        for ch in pattern:\\n            if ch==\\'I\\': d.append(1)\\n            elif ch==\\'D\\': d.append(-1)\\n        for a in itertools.permutations([1,2,3,4,5,6,7,8,9], n+1):\\n            if all(a[i]<a[i+1] and d[i]==1 or a[i]>a[i+1] and d[i]==-1 for i in range(n)):\\n                return \\'\\'.join(str(x) for x in a)\\n```\\n\\nOR shorter version:\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        for a in itertools.permutations([1,2,3,4,5,6,7,8,9], len(pattern)+1):\\n            if all(a[i]<a[i+1] and pattern[i]==\\'I\\' or a[i]>a[i+1] and pattern[i]==\\'D\\' for i in range(len(pattern))):\\n                return \\'\\'.join(str(x) for x in a)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        n=len(pattern)\\n        d=[]\\n        for ch in pattern:\\n            if ch==\\'I\\': d.append(1)\\n            elif ch==\\'D\\': d.append(-1)\\n        for a in itertools.permutations([1,2,3,4,5,6,7,8,9], n+1):\\n            if all(a[i]<a[i+1] and d[i]==1 or a[i]>a[i+1] and d[i]==-1 for i in range(n)):\\n                return \\'\\'.join(str(x) for x in a)\\n```\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        for a in itertools.permutations([1,2,3,4,5,6,7,8,9], len(pattern)+1):\\n            if all(a[i]<a[i+1] and pattern[i]==\\'I\\' or a[i]>a[i+1] and pattern[i]==\\'D\\' for i in range(len(pattern))):\\n                return \\'\\'.join(str(x) for x in a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422222,
                "title": "java-tle-why-my-backtracking-got-tle",
                "content": "**I can obtain the correct result by clicking \"Run\",  but I got TLE when I click \"Submit\"**\\n```\\n    public String smallestNumber(String pattern) {\\n        int d = 0, i = 0;\\n        char[] ch = pattern.toCharArray();\\n        for (char c : ch) {\\n            if (c == \\'I\\') {\\n                i++;\\n            } else {\\n                d++;\\n            }\\n        }\\n        int len = pattern.length();\\n        int num = len + 1;\\n        int[] n = new int[num];\\n        int min = 1 + d;\\n        int max = 9 - i;\\n        int idx = 0;\\n        int start = Math.max(len + 1, min);\\n        for (int ii = start; ii > start - len - 1; ii--) {\\n            n[idx] = ii;\\n            idx++;\\n        }\\n        Arrays.sort(n);\\n        List<String> res = permute(n, pattern);\\n       \\n        return res.get(0);\\n        \\n    }\\n    \\n    public List<String> permute(int[] nums, String p) {\\n       List<String> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums, p);\\n       return list;\\n    }\\n\\n    private void backtrack(List<String> list, List<Integer> tempList, int [] nums, String p){\\n       if (tempList.size() == nums.length){\\n           StringBuilder sb = new StringBuilder();\\n           for (int a : tempList) {\\n               sb.append(a);\\n           }\\n           String r = sb.toString();\\n           if (isValid(r, p)) {\\n               list.add(r);\\n               return;\\n           }\\n\\n       }else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums, p);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n    \\n    boolean isValid(String s, String p) {\\n        char[] ss = s.toCharArray();\\n        char[] pp = p.toCharArray();\\n        for (int i = 1; i < ss.length; i++) {\\n            if (pp[i - 1] == \\'D\\' && ss[i] - \\'0\\' >= ss[i - 1] - \\'0\\') {\\n                return false;\\n            }\\n            if (pp[i - 1] == \\'I\\' && ss[i] - \\'0\\' <= ss[i - 1] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String smallestNumber(String pattern) {\\n        int d = 0, i = 0;\\n        char[] ch = pattern.toCharArray();\\n        for (char c : ch) {\\n            if (c == \\'I\\') {\\n                i++;\\n            } else {\\n                d++;\\n            }\\n        }\\n        int len = pattern.length();\\n        int num = len + 1;\\n        int[] n = new int[num];\\n        int min = 1 + d;\\n        int max = 9 - i;\\n        int idx = 0;\\n        int start = Math.max(len + 1, min);\\n        for (int ii = start; ii > start - len - 1; ii--) {\\n            n[idx] = ii;\\n            idx++;\\n        }\\n        Arrays.sort(n);\\n        List<String> res = permute(n, pattern);\\n       \\n        return res.get(0);\\n        \\n    }\\n    \\n    public List<String> permute(int[] nums, String p) {\\n       List<String> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums, p);\\n       return list;\\n    }\\n\\n    private void backtrack(List<String> list, List<Integer> tempList, int [] nums, String p){\\n       if (tempList.size() == nums.length){\\n           StringBuilder sb = new StringBuilder();\\n           for (int a : tempList) {\\n               sb.append(a);\\n           }\\n           String r = sb.toString();\\n           if (isValid(r, p)) {\\n               list.add(r);\\n               return;\\n           }\\n\\n       }else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums, p);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n    \\n    boolean isValid(String s, String p) {\\n        char[] ss = s.toCharArray();\\n        char[] pp = p.toCharArray();\\n        for (int i = 1; i < ss.length; i++) {\\n            if (pp[i - 1] == \\'D\\' && ss[i] - \\'0\\' >= ss[i - 1] - \\'0\\') {\\n                return false;\\n            }\\n            if (pp[i - 1] == \\'I\\' && ss[i] - \\'0\\' <= ss[i - 1] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422212,
                "title": "python-solution-no-use-of-backtracking",
                "content": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        \\n\\t\\t# there will be n+1 numbers in the final string\\n\\t\\t# and naturally we pick the smallest n+1 numbers between 1 - 9\\n\\t\\t# put the numbers in our result arr first in increasing order\\n        n = len(pattern) + 1\\n        result = list(range(1,n+1))\\n\\n        for i in range(len(pattern)):\\n\\t\\t\\t# when you have a D, you are forced to swap the current number\\n\\t\\t\\t# with the next number to have a decreasing segment\\n\\t\\t\\t# if we have consecutive Ds, we need to swap with the number after\\n\\t\\t\\t# the last D\\n            if pattern[i] == \"D\":\\n                j = i\\n                while j < len(pattern) and pattern[j] == \"D\":\\n                    j += 1\\n                    result[j], result[i] = result[i], result[j] \\n                \\n        \\n        return \"\".join([str(x) for x in result])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        \\n\\t\\t# there will be n+1 numbers in the final string\\n\\t\\t# and naturally we pick the smallest n+1 numbers between 1 - 9\\n\\t\\t# put the numbers in our result arr first in increasing order\\n        n = len(pattern) + 1\\n        result = list(range(1,n+1))\\n\\n        for i in range(len(pattern)):\\n\\t\\t\\t# when you have a D, you are forced to swap the current number\\n\\t\\t\\t# with the next number to have a decreasing segment\\n\\t\\t\\t# if we have consecutive Ds, we need to swap with the number after\\n\\t\\t\\t# the last D\\n            if pattern[i] == \"D\":\\n                j = i\\n                while j < len(pattern) and pattern[j] == \"D\":\\n                    j += 1\\n                    result[j], result[i] = result[i], result[j] \\n                \\n        \\n        return \"\".join([str(x) for x in result])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422202,
                "title": "c-o-n-reverse",
                "content": "```\\n    public string SmallestNumber(string pattern) \\n    {\\n        int n = pattern.Length + 1;\\n        char[] result = new char[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            result[i] = (char)(\\'1\\' + i);\\n        }\\n\\n        int lastI = 0;\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            if (pattern[i] == \\'I\\')\\n            {\\n                Array.Reverse(result, lastI, i + 1 - lastI);\\n                lastI = i + 1;\\n            }\\n        }\\n\\n        if (pattern.Last() == \\'D\\')\\n            Array.Reverse(result, lastI, n - lastI);\\n        return new string(result);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string SmallestNumber(string pattern) \\n    {\\n        int n = pattern.Length + 1;\\n        char[] result = new char[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            result[i] = (char)(\\'1\\' + i);\\n        }\\n\\n        int lastI = 0;\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            if (pattern[i] == \\'I\\')\\n            {\\n                Array.Reverse(result, lastI, i + 1 - lastI);\\n                lastI = i + 1;\\n            }\\n        }\\n\\n        if (pattern.Last() == \\'D\\')\\n            Array.Reverse(result, lastI, n - lastI);\\n        return new string(result);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422142,
                "title": "cpp-solution-brute-force-accepted-no-backtracking",
                "content": "```\\n//Simply we will keep record of all \\'D\\' because we have to choose a such number that will not going to be 0 so we will store Number of \\'D\\' that has occured in given String \\n\\nclass Solution {\\npublic:\\n    string smallestNumber(string str) {\\n         int n= str.size();\\n    vector<int> v(n, 0);                   //To store number of occurance of D \\n    for(int i=0; i<n; i++){\\n        \\n        int cnt=0;\\n        int j=i;\\n        if(str[i] == \\'D\\')\\n        {\\n            \\n            cnt++;\\n            while(str[j] == str[j+1]){\\n                cnt++;                //Here we will store occurance of \\'D\\' at first index of \\'D\\' where \\'D\\' is occuring\\n                j++;\\n            }\\n         }\\n        v[i] = cnt;\\n        i=j;\\n    }\\n    // for(auto &a:v)cout<<a<<\" \";\\n    char a=\\'1\\';\\n    string res=\"\";\\n    if(str[0] == \\'I\\')res.push_back(\\'1\\');   //if string is start with \\'I\\' we will start with \\'1\\' else according \\n    else res.push_back(v[0]+1 + \\'0\\');     //to number of \\'D\\' that we have stored in vector v;\\n    // cout<<res<<endl;\\n    for(int i=0; i<n; ){\\n        if(v[i]){\\n            int ak = v[i];                   //if v[i] != 0 means we have to decrease the value now \\n            \\n            char last = res[res.size()-1];       //find out last character in result \\n            char temp = last;\\n            a= max(a, last);\\n            // cout<<temp<<endl;\\n            while(ak--){                    //push value untill all \\'D\\' is not over\\n                temp--;\\n                res.push_back(temp);\\n                // cout<<temp<<\" \";;\\n            }\\n            i += v[i];\\n        }\\n        else{                           //if v[i] == 0 means there is \\'I\\' so we will simply increase the last character\\n            char la=a;\\n            a++;\\n            if(i<n-1)a+=v[i+1];\\n            res.push_back(a);\\n            i++;\\n        }\\n        \\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Simply we will keep record of all \\'D\\' because we have to choose a such number that will not going to be 0 so we will store Number of \\'D\\' that has occured in given String \\n\\nclass Solution {\\npublic:\\n    string smallestNumber(string str) {\\n         int n= str.size();\\n    vector<int> v(n, 0);                   //To store number of occurance of D \\n    for(int i=0; i<n; i++){\\n        \\n        int cnt=0;\\n        int j=i;\\n        if(str[i] == \\'D\\')\\n        {\\n            \\n            cnt++;\\n            while(str[j] == str[j+1]){\\n                cnt++;                //Here we will store occurance of \\'D\\' at first index of \\'D\\' where \\'D\\' is occuring\\n                j++;\\n            }\\n         }\\n        v[i] = cnt;\\n        i=j;\\n    }\\n    // for(auto &a:v)cout<<a<<\" \";\\n    char a=\\'1\\';\\n    string res=\"\";\\n    if(str[0] == \\'I\\')res.push_back(\\'1\\');   //if string is start with \\'I\\' we will start with \\'1\\' else according \\n    else res.push_back(v[0]+1 + \\'0\\');     //to number of \\'D\\' that we have stored in vector v;\\n    // cout<<res<<endl;\\n    for(int i=0; i<n; ){\\n        if(v[i]){\\n            int ak = v[i];                   //if v[i] != 0 means we have to decrease the value now \\n            \\n            char last = res[res.size()-1];       //find out last character in result \\n            char temp = last;\\n            a= max(a, last);\\n            // cout<<temp<<endl;\\n            while(ak--){                    //push value untill all \\'D\\' is not over\\n                temp--;\\n                res.push_back(temp);\\n                // cout<<temp<<\" \";;\\n            }\\n            i += v[i];\\n        }\\n        else{                           //if v[i] == 0 means there is \\'I\\' so we will simply increase the last character\\n            char la=a;\\n            a++;\\n            if(i<n-1)a+=v[i+1];\\n            res.push_back(a);\\n            i++;\\n        }\\n        \\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2422097,
                "title": "stack-simple",
                "content": "\\n    public String smallestNumber(String str) {\\n        Stack < Integer > st = new Stack < > ();\\n        int c = 0;\\n       StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < str.length(); i++) {\\n            char ch = str.charAt(i);\\n\\n\\n            if (ch == \\'D\\') {\\n                c++;\\n                st.push(c);\\n            } else if (ch == \\'I\\') {\\n                c++;\\n                st.push(c);\\n\\n                \\n                while (st.size() > 0) {\\n                    \\n                    sb.append(st.pop());\\n                }\\n            }\\n        }\\n\\n        c++;\\n        st.push(c);\\n\\n        \\n        while (st.size() > 0) {\\n                    \\n                    sb.append(st.pop());\\n                }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "\\n    public String smallestNumber(String str) {\\n        Stack < Integer > st = new Stack < > ();\\n        int c = 0;\\n       StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < str.length(); i++) {\\n            char ch = str.charAt(i);\\n\\n\\n            if (ch == \\'D\\') {\\n                c++;\\n                st.push(c);\\n            } else if (ch == \\'I\\') {\\n                c++;\\n                st.push(c);\\n\\n                \\n                while (st.size() > 0) {\\n                    \\n                    sb.append(st.pop());\\n                }\\n            }\\n        }\\n\\n        c++;\\n        st.push(c);\\n\\n        \\n        while (st.size() > 0) {\\n                    \\n                    sb.append(st.pop());\\n                }\\n        return sb.toString();\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3980052,
                "title": "simple-solution-with-using-stack-ds",
                "content": "# Intuition\\nNote that problem can be solved by using `greedy`, `backtrack` or `stack` algorithm.\\nFor this solution let me explain step-by-step `stack` - solution.\\n\\n\\n---\\n\\nIf you haven\\'t already familiar with [Stack DS](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)), than I **highly** recommend to know a little more! \\n\\n---\\n\\nThe problem explanation is quite simple as \\n```\\n# 0. the goal is to generate the smallest lexicographically \\n# string with n-length, where 2 <= n <= 9 \\n\\n# 1. the initial string represents as \\n# a sequence of \\'I\\'-s and \\'D\\'-s like \\'IIDD\\'\\n\\n# 2. the schema of placing number is \\n# for I == num[i] > num[i - 1]\\n# for D == num[i] < num[i + 1]\\n\\n```\\nAt each step we need to **somehow** store the `i` **optimally** according to the schema above.\\n\\n```\\n# Pseudocode\\ns = \\'IIDD\\'\\nstack = []\\n\\nfor i in range lengthof(s):\\n    add to stack s[index]\\n\\n    if char == \\'I\\' or index == lengthof(s):\\n        while stack:\\n            pop from stack and add it to the output\\n```\\n\\n\\n# Approach\\n1. initialize an empty `stack` and `ans` for storing numbers\\n2. iterate over all chars in `pattern` - string\\n3. add the current index `char + 1` to stack\\n4. any time we\\'re out of a string or the `pattern[i] == \\'I\\'`, pop all the chars from the `stack`\\n5. return the `ans` variable\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating over all chars in `pattern`\\n\\n- Space complexity: **O(n)**, because of storing elements in `stack` and inside `ans`.\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        stack = []\\n        ans = []\\n\\n        for i in range(len(pattern) + 1):\\n            stack.append(i + 1)\\n\\n            if i == len(pattern) or pattern[i] == \\'I\\':\\n                while stack:\\n                    ans.append(str(stack.pop()))\\n\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n# 0. the goal is to generate the smallest lexicographically \\n# string with n-length, where 2 <= n <= 9 \\n\\n# 1. the initial string represents as \\n# a sequence of \\'I\\'-s and \\'D\\'-s like \\'IIDD\\'\\n\\n# 2. the schema of placing number is \\n# for I == num[i] > num[i - 1]\\n# for D == num[i] < num[i + 1]\\n\\n```\n```\\n# Pseudocode\\ns = \\'IIDD\\'\\nstack = []\\n\\nfor i in range lengthof(s):\\n    add to stack s[index]\\n\\n    if char == \\'I\\' or index == lengthof(s):\\n        while stack:\\n            pop from stack and add it to the output\\n```\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        stack = []\\n        ans = []\\n\\n        for i in range(len(pattern) + 1):\\n            stack.append(i + 1)\\n\\n            if i == len(pattern) or pattern[i] == \\'I\\':\\n                while stack:\\n                    ans.append(str(stack.pop()))\\n\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856633,
                "title": "python-greedy-solution-with-an-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of treating a single character of the pattern consider the group of the same character.\\n\\nIf we have consecutive **k** *\"D\"* characters, pick the digit from the stack ( **pop(k)** ) that is at position k, and append it to the answer. decrease the k by one and repeat the process till k >= 1.\\n\\nIf we have consecutive **k** *\"I\"* characters, pick the digit from the beginning of the stack ( **pop(0)** ), and append it to the answer. decrease the k by one and repeat the process till k >= 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet\\'s consider the example \"IIIDDID\".\\nIf the size of the pattern is n, then the stack has a 1 to n+1 digit.\\n\\ninitially,\\nn = 7, pattern = \"IIIDDID\"\\nStack = [1,2,3,4,5,6,7,8]\\nanswer = \"\"\\n\\nsince the first three characters are I, so we have to append the first three\\ndigits from the stack to the answer.\\nanswer = \"123\" \\nstack = [4,5,6,7,8], pattern = \"DDID\"\\n\\n\\nNow first two element is D, so we append stack[2], and stack[1] in \\nthe same order to the answer.\\nanswer = \"12365\"\\nstack = [4,7,8], pattern = \"ID\"\\n\\n\\nNow we have 1 character of I so, we simply append the first digit\\nfrom the stack to the answer.\\nanswer = \"123654\"\\nstack = [7,8], pattern = \"D\"\\n\\n\\nNow we have only D characters in the pattern, so we append all\\nthe digits of the stack from the last in answer.\\nanswer = \"12365487\"\\nstack = [], pattern = \"\"\\n\\n\\nif we have only I character in the pattern, in that case, \\nwe will append all the digits of the stack from the beginning in the answer.\\nWe can keep count of I and D characters in a pattern.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n\\n        def helper(i, d_count, i_count, ansf):\\n            if i == n:\\n                return ansf\\n\\n            # Only D is left in pattern\\n            if i_count == 0:\\n                for x in digits[::-1]:\\n                    ansf += str(x)\\n                return ansf\\n\\n            # Only I is left in pattern\\n            if d_count == 0:\\n                for x in digits:\\n                    ansf += str(x)\\n                return ansf\\n\\n            if pattern[i] == \"I\":\\n                count = 0\\n\\n                # check for consecutive \"I\"\\n                while i < n and pattern[i] == \"I\":\\n                    i += 1\\n                    count += 1\\n                temp = count\\n\\n                while temp:\\n                    ansf += str(digits.pop(0))\\n                    temp -= 1\\n                return helper(i, d_count, i_count - count, ansf)\\n\\n            count = 0\\n\\n            # check for consecutive \"D\"\\n            while i < n and pattern[i] == \"D\":\\n                i += 1\\n                count += 1\\n            temp = count\\n\\n            while temp:\\n                ansf += str(digits.pop(temp))\\n                temp -= 1\\n            return helper(i, d_count - count, i_count, ansf )\\n\\n        n = len(pattern)\\n        d_count = pattern.count(\"D\")\\n        i_count = n - d_count\\n        digits = [i for i in range(1, n+2)]\\n\\n        return helper(0, d_count, i_count, \"\")      \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n\\n        def helper(i, d_count, i_count, ansf):\\n            if i == n:\\n                return ansf\\n\\n            # Only D is left in pattern\\n            if i_count == 0:\\n                for x in digits[::-1]:\\n                    ansf += str(x)\\n                return ansf\\n\\n            # Only I is left in pattern\\n            if d_count == 0:\\n                for x in digits:\\n                    ansf += str(x)\\n                return ansf\\n\\n            if pattern[i] == \"I\":\\n                count = 0\\n\\n                # check for consecutive \"I\"\\n                while i < n and pattern[i] == \"I\":\\n                    i += 1\\n                    count += 1\\n                temp = count\\n\\n                while temp:\\n                    ansf += str(digits.pop(0))\\n                    temp -= 1\\n                return helper(i, d_count, i_count - count, ansf)\\n\\n            count = 0\\n\\n            # check for consecutive \"D\"\\n            while i < n and pattern[i] == \"D\":\\n                i += 1\\n                count += 1\\n            temp = count\\n\\n            while temp:\\n                ansf += str(digits.pop(temp))\\n                temp -= 1\\n            return helper(i, d_count - count, i_count, ansf )\\n\\n        n = len(pattern)\\n        d_count = pattern.count(\"D\")\\n        i_count = n - d_count\\n        digits = [i for i in range(1, n+2)]\\n\\n        return helper(0, d_count, i_count, \"\")      \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543096,
                "title": "java-1-ms-intuitive-approach",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso first i assumed the string as completely increasing say suppose given a string s = IIIDIDDD first i took a string which consists of only i\\'s so my number will be 123456789 then after when ever i found d till the end of the d i swapped the numbers which yeilds me output as 12354876\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. the code has a linear time and space complexity in terms of the length of the pattern\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n        sb.replace(i + 1, j, new StringBuilder(sb.substring(i + 1, j)).reverse().toString());\\n    }\\n    public String smallestNumber(String pattern) {\\n        int n = pattern.length();\\n        StringBuilder result = new StringBuilder();\\n        int currentNum = 1;\\n        for (int i = 0; i <= n; i++) {\\n            result.append(currentNum);\\n            currentNum++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (pattern.charAt(i) == \\'D\\') {\\n                int j = i;\\n                while (j < n && pattern.charAt(j) == \\'D\\') {\\n                    j++;\\n                }\\n                swap(result, i, j);\\n                i = j;\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n        sb.replace(i + 1, j, new StringBuilder(sb.substring(i + 1, j)).reverse().toString());\\n    }\\n    public String smallestNumber(String pattern) {\\n        int n = pattern.length();\\n        StringBuilder result = new StringBuilder();\\n        int currentNum = 1;\\n        for (int i = 0; i <= n; i++) {\\n            result.append(currentNum);\\n            currentNum++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (pattern.charAt(i) == \\'D\\') {\\n                int j = i;\\n                while (j < n && pattern.charAt(j) == \\'D\\') {\\n                    j++;\\n                }\\n                swap(result, i, j);\\n                i = j;\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287561,
                "title": "java-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        String res = smallestNumber1(pattern);\\n        return res;\\n    }\\n    public String smallestNumber1(String str){\\n        //we will create a stack and create a num which will be initialized to 1\\n\\t\\tint num = 1;\\n\\t\\tString res = \"\";\\n\\t\\t//till we get d in string str we will push num into the stack and increment num\\n\\t\\t//when ever we get i push num into stack and increment just like previous but\\n\\t\\t//also print all the elements from stack by popping out\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tfor(int i = 0; i < str.length(); i++){\\n\\t\\t\\tchar ch = str.charAt(i);\\n\\t\\t\\tif(ch == \\'D\\'){\\n\\t\\t\\t\\t//push the num and increment num\\n\\t\\t\\t\\tstack.push(num);\\n\\t\\t\\t\\tnum++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t//push the num and increment num\\n\\t\\t\\t\\t//also pop all the elements from the stack and add it to string res\\n\\t\\t\\t\\tstack.push(num);\\n\\t\\t\\t\\tnum++;\\n\\t\\t\\t\\twhile(!stack.isEmpty()){\\n\\t\\t\\t\\t\\tres += stack.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tstack.push(num);\\n\\t\\twhile(!stack.isEmpty()){\\n\\t\\t\\tres += stack.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        String res = smallestNumber1(pattern);\\n        return res;\\n    }\\n    public String smallestNumber1(String str){\\n        //we will create a stack and create a num which will be initialized to 1\\n\\t\\tint num = 1;\\n\\t\\tString res = \"\";\\n\\t\\t//till we get d in string str we will push num into the stack and increment num\\n\\t\\t//when ever we get i push num into stack and increment just like previous but\\n\\t\\t//also print all the elements from stack by popping out\\n\\t\\tStack<Integer> stack = new Stack<>();\\n\\t\\tfor(int i = 0; i < str.length(); i++){\\n\\t\\t\\tchar ch = str.charAt(i);\\n\\t\\t\\tif(ch == \\'D\\'){\\n\\t\\t\\t\\t//push the num and increment num\\n\\t\\t\\t\\tstack.push(num);\\n\\t\\t\\t\\tnum++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t//push the num and increment num\\n\\t\\t\\t\\t//also pop all the elements from the stack and add it to string res\\n\\t\\t\\t\\tstack.push(num);\\n\\t\\t\\t\\tnum++;\\n\\t\\t\\t\\twhile(!stack.isEmpty()){\\n\\t\\t\\t\\t\\tres += stack.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tstack.push(num);\\n\\t\\twhile(!stack.isEmpty()){\\n\\t\\t\\tres += stack.pop();\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237382,
                "title": "0ms-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(9)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder res = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        char ch = \\'1\\';\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char cur = pattern.charAt(i);\\n            temp.append(ch++);\\n            if (cur == \\'I\\') {\\n                res.append(temp.reverse());\\n                temp = new StringBuilder();\\n            }\\n        }\\n        temp.append(ch++);\\n        res.append(temp.reverse());\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder res = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n        char ch = \\'1\\';\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char cur = pattern.charAt(i);\\n            temp.append(ch++);\\n            if (cur == \\'I\\') {\\n                res.append(temp.reverse());\\n                temp = new StringBuilder();\\n            }\\n        }\\n        temp.append(ch++);\\n        res.append(temp.reverse());\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200346,
                "title": "c-0-ms-o-n-solution-reverse-easy-and-clean-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        int n = p.size()+1;\\n        vector<int> v(n,1);\\n        for(int i=0;i<n;++i)v[i]+=i;\\n        for(int i=0;i<n-1;++i){\\n            if(p[i]==\\'D\\'){\\n                int l = i,r=i;\\n                while(r<n and p[r]==\\'D\\') ++r;\\n                reverse(v.begin()+l,v.begin()+r+1);\\n                i=r;\\n            }\\n        }\\n        string ans = \"\";\\n        for(auto it: v)ans+=to_string(it);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        int n = p.size()+1;\\n        vector<int> v(n,1);\\n        for(int i=0;i<n;++i)v[i]+=i;\\n        for(int i=0;i<n-1;++i){\\n            if(p[i]==\\'D\\'){\\n                int l = i,r=i;\\n                while(r<n and p[r]==\\'D\\') ++r;\\n                reverse(v.begin()+l,v.begin()+r+1);\\n                i=r;\\n            }\\n        }\\n        string ans = \"\";\\n        for(auto it: v)ans+=to_string(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997868,
                "title": "c-simple-solution-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    bool backtrack(string &pattern, int curr, vector<bool> &used, string &ans) {\\n        if(curr >= pattern.size()) return true;\\n\\n        for(char d=\\'1\\'; d<=\\'9\\'; ++d) {\\n            bool already_used = used[d-\\'0\\'];\\n            bool not_increasing = pattern[curr]==\\'I\\' && d<=ans.back();   // failing the increasing condition\\n            bool not_decreasing = pattern[curr]==\\'D\\' && d>=ans.back();   // failing the decreasing condition\\n            if(already_used || not_increasing || not_decreasing) continue;\\n\\n            ans.push_back(d);\\n            used[d-\\'0\\'] = 1;\\n            if(backtrack(pattern, curr+1, used, ans)) return true;\\n\\n            used[d-\\'0\\'] = 0;\\n            ans.pop_back();\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    string smallestNumber(string pattern) {\\n        for(char d=\\'1\\'; d<=\\'9\\'; ++d) {\\n            vector<bool> used(10, false);\\n            used[d-\\'0\\'] = 1;\\n            string ans;\\n            ans.push_back(d);\\n            if(backtrack(pattern, 0, used, ans)) return ans;\\n\\n            used[d-\\'0\\'] = 0;\\n            ans.pop_back();\\n        }\\n        return \"\";\\n    }\\n};\\n\\nP.S.: I believe there exist a more optimized solution. Suggestions are welcomed!!\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool backtrack(string &pattern, int curr, vector<bool> &used, string &ans) {\\n        if(curr >= pattern.size()) return true;\\n\\n        for(char d=\\'1\\'; d<=\\'9\\'; ++d) {\\n            bool already_used = used[d-\\'0\\'];\\n            bool not_increasing = pattern[curr]==\\'I\\' && d<=ans.back();   // failing the increasing condition\\n            bool not_decreasing = pattern[curr]==\\'D\\' && d>=ans.back();   // failing the decreasing condition\\n            if(already_used || not_increasing || not_decreasing) continue;\\n\\n            ans.push_back(d);\\n            used[d-\\'0\\'] = 1;\\n            if(backtrack(pattern, curr+1, used, ans)) return true;\\n\\n            used[d-\\'0\\'] = 0;\\n            ans.pop_back();\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    string smallestNumber(string pattern) {\\n        for(char d=\\'1\\'; d<=\\'9\\'; ++d) {\\n            vector<bool> used(10, false);\\n            used[d-\\'0\\'] = 1;\\n            string ans;\\n            ans.push_back(d);\\n            if(backtrack(pattern, 0, used, ans)) return ans;\\n\\n            used[d-\\'0\\'] = 0;\\n            ans.pop_back();\\n        }\\n        return \"\";\\n    }\\n};\\n\\nP.S.: I believe there exist a more optimized solution. Suggestions are welcomed!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955692,
                "title": "use-simple-backtracking-beats-73",
                "content": "Use simple backtracking\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        \"\"\"\\n        i can try to solve this problem using backtracking\\n        \"\"\"\\n        self.ans = None\\n        def fun(index, res_so_far):\\n            if self.ans:\\n                return\\n\\n            if index >= len(pattern):\\n                self.ans = \\'\\'.join(str(item) for item in res_so_far)\\n                return\\n\\n            last_digit = res_so_far[-1]\\n            for i in range(1, 10):\\n                appended = False\\n                if pattern[index] == \\'I\\' and i > last_digit and i not in res_so_far:\\n                    appended = True\\n                    res_so_far.append(i)\\n                    fun(index+1, res_so_far)\\n                elif pattern[index] == \\'D\\' and i < last_digit and i not in res_so_far:\\n                    appended = True\\n                    res_so_far.append(i)\\n                    fun(index+1, res_so_far)\\n\\n                if appended:\\n                    res_so_far.pop(-1)\\n\\n        for i in range(1,10):\\n            if not self.ans:\\n                fun(0, [i])\\n        return self.ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        \"\"\"\\n        i can try to solve this problem using backtracking\\n        \"\"\"\\n        self.ans = None\\n        def fun(index, res_so_far):\\n            if self.ans:\\n                return\\n\\n            if index >= len(pattern):\\n                self.ans = \\'\\'.join(str(item) for item in res_so_far)\\n                return\\n\\n            last_digit = res_so_far[-1]\\n            for i in range(1, 10):\\n                appended = False\\n                if pattern[index] == \\'I\\' and i > last_digit and i not in res_so_far:\\n                    appended = True\\n                    res_so_far.append(i)\\n                    fun(index+1, res_so_far)\\n                elif pattern[index] == \\'D\\' and i < last_digit and i not in res_so_far:\\n                    appended = True\\n                    res_so_far.append(i)\\n                    fun(index+1, res_so_far)\\n\\n                if appended:\\n                    res_so_far.pop(-1)\\n\\n        for i in range(1,10):\\n            if not self.ans:\\n                fun(0, [i])\\n        return self.ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876372,
                "title": "java-2ms-solution-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 9; i >= 1; i--) {\\n            stack.push(i);\\n        }\\n        Stack<Integer> stackTemp = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char c = pattern.charAt(i);\\n            if (c == \\'I\\') {\\n                sb.append(stack.pop());\\n                while (stackTemp.size() > 0) {\\n                    sb.append(stackTemp.pop());\\n                }\\n            } else {\\n                if (i - 1 > 0 && pattern.charAt(i - 1) != c) {\\n                    while (stackTemp.size() > 0) {\\n                        sb.append(stackTemp.pop());\\n                    }\\n                }\\n                stackTemp.push(stack.pop());\\n            }\\n        }\\n        stackTemp.push(stack.pop());\\n        while (stackTemp.size() > 0) {\\n            sb.append(stackTemp.pop());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (int i = 9; i >= 1; i--) {\\n            stack.push(i);\\n        }\\n        Stack<Integer> stackTemp = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < pattern.length(); i++) {\\n            char c = pattern.charAt(i);\\n            if (c == \\'I\\') {\\n                sb.append(stack.pop());\\n                while (stackTemp.size() > 0) {\\n                    sb.append(stackTemp.pop());\\n                }\\n            } else {\\n                if (i - 1 > 0 && pattern.charAt(i - 1) != c) {\\n                    while (stackTemp.size() > 0) {\\n                        sb.append(stackTemp.pop());\\n                    }\\n                }\\n                stackTemp.push(stack.pop());\\n            }\\n        }\\n        stackTemp.push(stack.pop());\\n        while (stackTemp.size() > 0) {\\n            sb.append(stackTemp.pop());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721161,
                "title": "c-backtracking-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    set<char>st;\\n    string smallestNumber(string pattern) \\n    {\\n        int idx=0;\\n\\n        char prvch=\\'*\\';\\n        int prvnum=-1;\\n\\n        ans=\"\";\\n\\n        fun(pattern,idx,\"\",prvch,prvnum);\\n\\n        return ans;\\n    }\\n    void fun(string &pattern,int idx,string str,char prvch,int prvnum)\\n    {\\n        if(str.length() == pattern.length()+1)\\n        {\\n            ans=str;\\n            return;\\n        }\\n        if(prvch==\\'*\\')\\n        {\\n            for(int i=1;i<=9;i++)\\n            {\\n                char ch = i + \\'0\\';\\n\\n                if(st.find(ch)==st.end() and ans.length()==0)   //not visited\\n                {\\n                   st.insert(ch);\\n                   fun(pattern,idx+1,str+ch,pattern[idx],i);\\n                   st.erase(ch);\\t      //backtracking\\n                }\\n            }\\n        }\\n        else if(prvch==\\'I\\')\\n        {\\n            for(int i=prvnum+1;i<=9;i++)\\n            {\\n                char ch = i + \\'0\\';\\n\\n                if(st.find(ch) == st.end() and ans.length()==0)\\n                {\\n                    st.insert(ch);\\n                    fun(pattern,idx+1,str+ch,pattern[idx],i);\\n                    st.erase(ch);\\n                }\\n            }\\n        }\\n        else if(prvch==\\'D\\')\\n        {\\n            for(int i=prvnum-1;i>=1;i--)\\n            {\\n                char ch = i + \\'0\\';\\n\\n                if(st.find(ch) == st.end() and ans.length()==0)\\n                {\\n                    st.insert(ch);\\n                    fun(pattern,idx+1,str+ch,pattern[idx],i);\\n                    st.erase(ch);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    set<char>st;\\n    string smallestNumber(string pattern) \\n    {\\n        int idx=0;\\n\\n        char prvch=\\'*\\';\\n        int prvnum=-1;\\n\\n        ans=\"\";\\n\\n        fun(pattern,idx,\"\",prvch,prvnum);\\n\\n        return ans;\\n    }\\n    void fun(string &pattern,int idx,string str,char prvch,int prvnum)\\n    {\\n        if(str.length() == pattern.length()+1)\\n        {\\n            ans=str;\\n            return;\\n        }\\n        if(prvch==\\'*\\')\\n        {\\n            for(int i=1;i<=9;i++)\\n            {\\n                char ch = i + \\'0\\';\\n\\n                if(st.find(ch)==st.end() and ans.length()==0)   //not visited\\n                {\\n                   st.insert(ch);\\n                   fun(pattern,idx+1,str+ch,pattern[idx],i);\\n                   st.erase(ch);\\t      //backtracking\\n                }\\n            }\\n        }\\n        else if(prvch==\\'I\\')\\n        {\\n            for(int i=prvnum+1;i<=9;i++)\\n            {\\n                char ch = i + \\'0\\';\\n\\n                if(st.find(ch) == st.end() and ans.length()==0)\\n                {\\n                    st.insert(ch);\\n                    fun(pattern,idx+1,str+ch,pattern[idx],i);\\n                    st.erase(ch);\\n                }\\n            }\\n        }\\n        else if(prvch==\\'D\\')\\n        {\\n            for(int i=prvnum-1;i>=1;i--)\\n            {\\n                char ch = i + \\'0\\';\\n\\n                if(st.find(ch) == st.end() and ans.length()==0)\\n                {\\n                    st.insert(ch);\\n                    fun(pattern,idx+1,str+ch,pattern[idx],i);\\n                    st.erase(ch);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583179,
                "title": "rust-reverse-sub-array",
                "content": "The key idea is to reverse the segment of \\'D\\'. Just check out the following code.\\n\\n```rust\\nimpl Solution {\\n\\tpub fn smallest_number(pattern: String) -> String {\\n\\t\\tlet mut a = \"123456789\".chars().collect::<Vec<char>>()[..pattern.len() + 1].to_vec();\\n\\t\\tlet mut s = vec![];\\n\\t\\tfor (i, c) in pattern.chars().enumerate() {\\n\\t\\t\\tif s.is_empty() || pattern.chars().nth(i - 1) != Some(c) { s.push(1); }\\n\\t\\t\\telse { *s.last_mut().unwrap() += 1; }\\n\\t\\t}\\n\\t\\tlet mut i = 0;\\n\\t\\tfor c in s {\\n\\t\\t\\tif pattern.chars().nth(i) == Some(\\'D\\') {\\n\\t\\t\\t\\tfor d in 0..(c + 1) / 2 { a.swap(i + d, i + c - d); }\\n\\t\\t\\t}\\n\\t\\t\\ti += c;\\n\\t\\t}\\n\\t\\ta.iter().collect()\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```rust\\nimpl Solution {\\n\\tpub fn smallest_number(pattern: String) -> String {\\n\\t\\tlet mut a = \"123456789\".chars().collect::<Vec<char>>()[..pattern.len() + 1].to_vec();\\n\\t\\tlet mut s = vec![];\\n\\t\\tfor (i, c) in pattern.chars().enumerate() {\\n\\t\\t\\tif s.is_empty() || pattern.chars().nth(i - 1) != Some(c) { s.push(1); }\\n\\t\\t\\telse { *s.last_mut().unwrap() += 1; }\\n\\t\\t}\\n\\t\\tlet mut i = 0;\\n\\t\\tfor c in s {\\n\\t\\t\\tif pattern.chars().nth(i) == Some(\\'D\\') {\\n\\t\\t\\t\\tfor d in 0..(c + 1) / 2 { a.swap(i + d, i + c - d); }\\n\\t\\t\\t}\\n\\t\\t\\ti += c;\\n\\t\\t}\\n\\t\\ta.iter().collect()\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2578572,
                "title": "easy-approach",
                "content": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        String ans =\"\";\\n        Stack<Integer> st = new Stack<>();\\n        int num =1;\\n        for(int i= 0 ;i< pattern.length() ;i++){\\n            char ch = pattern.charAt(i);\\n            if(ch == \\'D\\'){\\n                st.push(num);\\n                num++;\\n            }\\n            else{\\n                st.push(num);\\n                num++;\\n                while(st.size() > 0){\\n                    ans += (char)(st.pop() + \\'0\\');\\n                }\\n            }\\n        }\\n        st.push(num);\\n         while(st.size() > 0){\\n            ans += (char)(st.pop() + \\'0\\');\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        String ans =\"\";\\n        Stack<Integer> st = new Stack<>();\\n        int num =1;\\n        for(int i= 0 ;i< pattern.length() ;i++){\\n            char ch = pattern.charAt(i);\\n            if(ch == \\'D\\'){\\n                st.push(num);\\n                num++;\\n            }\\n            else{\\n                st.push(num);\\n                num++;\\n                while(st.size() > 0){\\n                    ans += (char)(st.pop() + \\'0\\');\\n                }\\n            }\\n        }\\n        st.push(num);\\n         while(st.size() > 0){\\n            ans += (char)(st.pop() + \\'0\\');\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564035,
                "title": "intuition",
                "content": "If we observe carefully, then from the test cases we can see that for the first occurence of \\'I\\' we want it to be set to 1. Consequence of this would determine the result for all the characters lying left to the index of \\'I\\'.\\nFor instance : we have a pattern as \"DDIDDID\".\\nThe answer for this is 32165487.\\nSo, the first \\'I\\' occurs at index 2, hence in the answer we have number at index 2 as \\'1\\'(minimum possible).\\nNow for the characters lying to the left of index 2, we have to set them as minimum possible going from 2 - 1 to 0.\\nhence index 1 is set to \\'2\\' and index \\'0\\' as \\'3\\'.\\nThe same approach can be applied to the next occurence of \\'I\\'. Only thing is we need not process the part of string which is already processed. Hence, we use an index beenSet to keep information about the indexes already set.\\n\\nEdge case: (DDD) If no \\'I\\' found, then we can start from the last index and process till we reach the last \\'I\\' which was processed possibly.(0 in this case).\\n\\nNote: Same approach can be used to solve Leetcode 942 :  https://leetcode.com/problems/di-string-match/\\n\\n\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int n = pattern.length();\\n        int min = 1;\\n        int beenSet = -1 ;\\n        \\n        // we need resultant string of length n + 1\\n        StringBuilder sb = new StringBuilder(pattern + \" \");\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            char ch = pattern.charAt(i);\\n            \\n            //encounter I set min possible at this index\\n            if(ch == \\'I\\'){\\n                //ascii of \\'0\\' is 48\\n                sb.setCharAt(i, (char)(min++ + 48));\\n                // set min possible at All \\'D\\' to the left of \\'I\\' and not been set so far\\n                for(int j = i - 1 ; j > beenSet ; j--){\\n                    sb.setCharAt(j, (char)(min++ + 48));\\n                }\\n                beenSet = i ;\\n            }  \\n        }\\n        //for characters not been set\\n        for(int i = n ; i > beenSet ; i--){\\n            sb.setCharAt(i, (char)(min++ + 48));\\n        }\\n        return sb.toString();     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int n = pattern.length();\\n        int min = 1;\\n        int beenSet = -1 ;\\n        \\n        // we need resultant string of length n + 1\\n        StringBuilder sb = new StringBuilder(pattern + \" \");\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            \\n            char ch = pattern.charAt(i);\\n            \\n            //encounter I set min possible at this index\\n            if(ch == \\'I\\'){\\n                //ascii of \\'0\\' is 48\\n                sb.setCharAt(i, (char)(min++ + 48));\\n                // set min possible at All \\'D\\' to the left of \\'I\\' and not been set so far\\n                for(int j = i - 1 ; j > beenSet ; j--){\\n                    sb.setCharAt(j, (char)(min++ + 48));\\n                }\\n                beenSet = i ;\\n            }  \\n        }\\n        //for characters not been set\\n        for(int i = n ; i > beenSet ; i--){\\n            sb.setCharAt(i, (char)(min++ + 48));\\n        }\\n        return sb.toString();     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508371,
                "title": "c-brute-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &ans,string &p){\\n        int n=p.size();\\n        for(int i=0;i<n;i++){\\n            if(p[i]==\\'I\\' && (ans[i])>=(ans[i+1]))return false;\\n            else if(p[i]==\\'D\\' && (ans[i])<=(ans[i+1]))return false;\\n        }\\n        return true;\\n    }\\n    string smallestNumber(string p) {\\n        int n=p.size();\\n        vector<int> ans;\\n        for(int i=1;i<=n+1;i++){\\n            ans.push_back(i);\\n        }\\n        do{\\n            if(check(ans,p))break;\\n        }while(next_permutation(ans.begin(),ans.end()));\\n        \\n        string temp;\\n        for(auto it:ans)temp.push_back(it+\\'0\\');\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &ans,string &p){\\n        int n=p.size();\\n        for(int i=0;i<n;i++){\\n            if(p[i]==\\'I\\' && (ans[i])>=(ans[i+1]))return false;\\n            else if(p[i]==\\'D\\' && (ans[i])<=(ans[i+1]))return false;\\n        }\\n        return true;\\n    }\\n    string smallestNumber(string p) {\\n        int n=p.size();\\n        vector<int> ans;\\n        for(int i=1;i<=n+1;i++){\\n            ans.push_back(i);\\n        }\\n        do{\\n            if(check(ans,p))break;\\n        }while(next_permutation(ans.begin(),ans.end()));\\n        \\n        string temp;\\n        for(auto it:ans)temp.push_back(it+\\'0\\');\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499812,
                "title": "runtime-0ms-easy-reverse-c-easy-to-understand-solution",
                "content": "\\tstring smallestNumber(string pat) {\\n        int n = pat.size();        \\n        int i=0;\\n        int j=1;\\n        string ans;\\n        while(i<n){\\n            if(pat[i]==\\'I\\'){\\n                string temp;\\n                while(i<n and pat[i]==\\'I\\'){\\n                    temp.push_back(j+\\'0\\');\\n                    i++;j++;\\n                }    \\n                i--;\\n                ans+=temp;\\n            }\\n            else{\\n                string temp;\\n                while(i<n and pat[i]==\\'D\\'){\\n                    temp.push_back(j+\\'0\\');\\n                    i++;j++;\\n                }\\n                temp.push_back(j+\\'0\\');\\n                j++;\\n                reverse(begin(temp),end(temp));\\n                ans+= temp;\\n            }\\n            i++;\\n        }\\n        if(ans.size()<n+1){\\n            ans.push_back(j+\\'0\\');\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "\\tstring smallestNumber(string pat) {\\n        int n = pat.size();        \\n        int i=0;\\n        int j=1;\\n        string ans;\\n        while(i<n){\\n            if(pat[i]==\\'I\\'){\\n                string temp;\\n                while(i<n and pat[i]==\\'I\\'){\\n                    temp.push_back(j+\\'0\\');\\n                    i++;j++;\\n                }    \\n                i--;\\n                ans+=temp;\\n            }\\n            else{\\n                string temp;\\n                while(i<n and pat[i]==\\'D\\'){\\n                    temp.push_back(j+\\'0\\');\\n                    i++;j++;\\n                }\\n                temp.push_back(j+\\'0\\');\\n                j++;\\n                reverse(begin(temp),end(temp));\\n                ans+= temp;\\n            }\\n            i++;\\n        }\\n        if(ans.size()<n+1){\\n            ans.push_back(j+\\'0\\');\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2472533,
                "title": "c-backtracking-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    string ans =\"\";\\n    \\n    void helper(int i,string pattern,int index,string s,vector<bool>& visited,int& flag)\\n    {\\n        if(index==pattern.size())\\n        {\\n            ans=s;\\n            //cout<<ans<<\" \";\\n            flag=1;\\n            return;\\n        }\\n        \\n\\n        if(pattern[index]==\\'I\\')\\n        {\\n            for(int j=i;j<=9;j++)\\n            {\\n                if(flag==1)\\n                    return;\\n                if(visited[j]==false)\\n                {\\n                    visited[j]=true;\\n                    helper(j+1,pattern,index+1,s+=to_string(j),visited,flag);\\n                    s.pop_back();\\n                    visited[j]=false;\\n                    \\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                if(flag==1)\\n                    return;\\n                if(visited[j]==false)\\n                {\\n                    visited[j]=true;\\n                    helper(j+1,pattern,index+1,s+=to_string(j),visited,flag);\\n                    s.pop_back();\\n                    visited[j]=false;\\n                }\\n                \\n            }\\n        }\\n    }\\n    \\n    \\n    string smallestNumber(string pattern) {\\n        \\n        pattern=\"I\"+pattern;\\n        vector<bool> visited;\\n        visited.resize(10,false);\\n        int flag=0;\\n        //visited[0]=true;\\n        //visited[1]=true;\\n        helper(1,pattern,0,\"\",visited,flag);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    string ans =\"\";\\n    \\n    void helper(int i,string pattern,int index,string s,vector<bool>& visited,int& flag)\\n    {\\n        if(index==pattern.size())\\n        {\\n            ans=s;\\n            //cout<<ans<<\" \";\\n            flag=1;\\n            return;\\n        }\\n        \\n\\n        if(pattern[index]==\\'I\\')\\n        {\\n            for(int j=i;j<=9;j++)\\n            {\\n                if(flag==1)\\n                    return;\\n                if(visited[j]==false)\\n                {\\n                    visited[j]=true;\\n                    helper(j+1,pattern,index+1,s+=to_string(j),visited,flag);\\n                    s.pop_back();\\n                    visited[j]=false;\\n                    \\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int j=1;j<i;j++)\\n            {\\n                if(flag==1)\\n                    return;\\n                if(visited[j]==false)\\n                {\\n                    visited[j]=true;\\n                    helper(j+1,pattern,index+1,s+=to_string(j),visited,flag);\\n                    s.pop_back();\\n                    visited[j]=false;\\n                }\\n                \\n            }\\n        }\\n    }\\n    \\n    \\n    string smallestNumber(string pattern) {\\n        \\n        pattern=\"I\"+pattern;\\n        vector<bool> visited;\\n        visited.resize(10,false);\\n        int flag=0;\\n        //visited[0]=true;\\n        //visited[1]=true;\\n        helper(1,pattern,0,\"\",visited,flag);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2444771,
                "title": "0ms-greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        int n=p.size();\\n        string s=\"\";\\n        for(int i=1;i<=n+1;i++){\\n            s+=to_string(i);\\n        }\\n        \\n        int i=0,j=0;\\n        \\n        while(i<n){\\n            if(p[i]==\\'I\\')i++;\\n            else {\\n                j=i;\\n                while(j<n and p[j]==\\'D\\') j++;\\n                reverse(s.begin()+i,s.begin()+j+1);\\n                i=j+1;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        int n=p.size();\\n        string s=\"\";\\n        for(int i=1;i<=n+1;i++){\\n            s+=to_string(i);\\n        }\\n        \\n        int i=0,j=0;\\n        \\n        while(i<n){\\n            if(p[i]==\\'I\\')i++;\\n            else {\\n                j=i;\\n                while(j<n and p[j]==\\'D\\') j++;\\n                reverse(s.begin()+i,s.begin()+j+1);\\n                i=j+1;\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444254,
                "title": "java-solution-greedy-without-backtracking-o-n-time",
                "content": "```java \\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int[] a = new int[pattern.length()+1];\\n        int c=1;\\n        for(int i=0;i<=pattern.length();i++)\\n        {\\n            if(i==pattern.length()||pattern.charAt(i)==\\'I\\')\\n            {\\n                int x=i;\\n                a[x--]=c++;\\n                while(x>=0&&a[x]==0)\\n                    a[x--]=c++;\\n            }\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        for(int x:a)\\n            sb.append(x);\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String smallestNumber(String pattern) {\\n        int[] a = new int[pattern.length()+1];\\n        int c=1;\\n        for(int i=0;i<=pattern.length();i++)\\n        {\\n            if(i==pattern.length()||pattern.charAt(i)==\\'I\\')\\n            {\\n                int x=i;\\n                a[x--]=c++;\\n                while(x>=0&&a[x]==0)\\n                    a[x--]=c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2436835,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        int n = pattern.size();\\n        \\n        // declare a stack\\n        \\n        stack<int> st;\\n        \\n        int NUM = 1;\\n       \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if pattern[i] == \\'I\\'\\n            \\n            if(pattern[i] == \\'I\\')\\n            {\\n                // include in res\\n                \\n                res += to_string(NUM);\\n                \\n                while(!st.empty())\\n                {\\n                    res += to_string(st.top());\\n                    \\n                    st.pop();\\n                }\\n                \\n                NUM++;\\n            }\\n            \\n            // if pattern[i] == \\'D\\'\\n            \\n            else\\n            {\\n                // push the NUM into the stack\\n                \\n               st.push(NUM);\\n                \\n                NUM++;\\n            }\\n        }\\n        \\n        st.push(NUM);\\n        \\n        // take out the all the elements from the stack\\n        \\n        while(!st.empty())\\n        {\\n            res += to_string(st.top());\\n            \\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        int n = pattern.size();\\n        \\n        // declare a stack\\n        \\n        stack<int> st;\\n        \\n        int NUM = 1;\\n       \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // if pattern[i] == \\'I\\'\\n            \\n            if(pattern[i] == \\'I\\')\\n            {\\n                // include in res\\n                \\n                res += to_string(NUM);\\n                \\n                while(!st.empty())\\n                {\\n                    res += to_string(st.top());\\n                    \\n                    st.pop();\\n                }\\n                \\n                NUM++;\\n            }\\n            \\n            // if pattern[i] == \\'D\\'\\n            \\n            else\\n            {\\n                // push the NUM into the stack\\n                \\n               st.push(NUM);\\n                \\n                NUM++;\\n            }\\n        }\\n        \\n        st.push(NUM);\\n        \\n        // take out the all the elements from the stack\\n        \\n        while(!st.empty())\\n        {\\n            res += to_string(st.top());\\n            \\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433085,
                "title": "c-recursion-backtracking-beginner-friendly",
                "content": "Whenever we see that we have to choose an answer out many possible ways first things that comes to the mind is recursion+backtracking\\n\\n```\\nclass Solution {\\npublic:\\n    int mn=INT_MAX;\\n    void dfs(int idx,string pattern,int sum,vector<int> &vis){\\n        //Base Condition:- We have to stop when the index/count becomes equal to the pattern size(because 0 based indexing)\\n        //and then we have to check for the char at previous index for deciding which number we can place\\n        if(idx==pattern.size()){\\n            for(int i=1;i<=9;i++){\\n                if(pattern[idx-1]==\\'I\\'){\\n                    if(i>sum%10 and vis[i]!=1){\\n                        int t=(sum*10)+i;\\n                        //This will store the minimum number which we would get\\n                        mn=min(t,mn);\\n                    }\\n                }\\n                if(pattern[idx-1]==\\'D\\'){\\n                    if(i<sum%10 and vis[i]!=1){\\n                        int t=(sum*10)+i;\\n                        //This will store the minimum number which we would get\\n                        mn=min(t,mn);\\n                    }\\n                }\\n            }\\n            return;\\n        }\\n        \\n        //Recursive Approach\\n        for(int i=1;i<=9;i++){\\n            //Initially we can place any number of out choice out of 1 to 9\\n            if(idx==0){\\n                vis[i]=1;\\n                dfs(idx+1,pattern,i,vis);\\n                vis[i]=0;\\n            }\\n            //Main Logic:- In this ques the next number will always be decided on the basis of the previous string char\\n            else if(pattern[idx-1]==\\'I\\'){\\n                if(i>sum%10 and vis[i]!=1){\\n                    vis[i]=1;\\n                    dfs(idx+1,pattern,(sum*10)+i,vis);\\n                    vis[i]=0;\\n                    \\n                }\\n            }\\n            else if(pattern[idx-1]==\\'D\\'){\\n                if(i<sum%10 and vis[i]!=1){\\n                    vis[i]=1;\\n                    dfs(idx+1,pattern,(sum*10)+i,vis);\\n                    vis[i]=0;\\n                }\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        vector<int> vis(10,0); //visited array is maintained because numbers can be repeated.\\n        int ans=0;\\n        dfs(0,pattern,ans,vis);\\n        return to_string(mn);\\n    }\\n};\\n```\\nHope you find this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mn=INT_MAX;\\n    void dfs(int idx,string pattern,int sum,vector<int> &vis){\\n        //Base Condition:- We have to stop when the index/count becomes equal to the pattern size(because 0 based indexing)\\n        //and then we have to check for the char at previous index for deciding which number we can place\\n        if(idx==pattern.size()){\\n            for(int i=1;i<=9;i++){\\n                if(pattern[idx-1]==\\'I\\'){\\n                    if(i>sum%10 and vis[i]!=1){\\n                        int t=(sum*10)+i;\\n                        //This will store the minimum number which we would get\\n                        mn=min(t,mn);\\n                    }\\n                }\\n                if(pattern[idx-1]==\\'D\\'){\\n                    if(i<sum%10 and vis[i]!=1){\\n                        int t=(sum*10)+i;\\n                        //This will store the minimum number which we would get\\n                        mn=min(t,mn);\\n                    }\\n                }\\n            }\\n            return;\\n        }\\n        \\n        //Recursive Approach\\n        for(int i=1;i<=9;i++){\\n            //Initially we can place any number of out choice out of 1 to 9\\n            if(idx==0){\\n                vis[i]=1;\\n                dfs(idx+1,pattern,i,vis);\\n                vis[i]=0;\\n            }\\n            //Main Logic:- In this ques the next number will always be decided on the basis of the previous string char\\n            else if(pattern[idx-1]==\\'I\\'){\\n                if(i>sum%10 and vis[i]!=1){\\n                    vis[i]=1;\\n                    dfs(idx+1,pattern,(sum*10)+i,vis);\\n                    vis[i]=0;\\n                    \\n                }\\n            }\\n            else if(pattern[idx-1]==\\'D\\'){\\n                if(i<sum%10 and vis[i]!=1){\\n                    vis[i]=1;\\n                    dfs(idx+1,pattern,(sum*10)+i,vis);\\n                    vis[i]=0;\\n                }\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        vector<int> vis(10,0); //visited array is maintained because numbers can be repeated.\\n        int ans=0;\\n        dfs(0,pattern,ans,vis);\\n        return to_string(mn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430817,
                "title": "easy-to-understand-using-stack-100-faster-solution",
                "content": "**simple made use of stack , if the char encountered is \\'I\\' then ,  add the position of that char from the top to the string, else just store the value to the stack..**\\n\\n\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        stack<char>st;\\n        string ans=\"\";\\n        for(int i=0;i<=pattern.size();i++)\\n        {\\n            \\n            st.push(i+1);\\n            if(pattern[i]==\\'I\\' || i==pattern.size())\\n            {\\n                while(!st.empty())\\n                {\\n                    ans+=to_string(st.top());\\n                    st.pop();\\n                }\\n            }\\n            \\n            \\n        }\\n    return ans;    \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        \\n        stack<char>st;\\n        string ans=\"\";\\n        for(int i=0;i<=pattern.size();i++)\\n        {\\n            \\n            st.push(i+1);\\n            if(pattern[i]==\\'I\\' || i==pattern.size())\\n            {\\n                while(!st.empty())\\n                {\\n                    ans+=to_string(st.top());\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2430621,
                "title": "java-two-stacks-solution-simple-and-easy-to-understand",
                "content": "The idea is that:\\nIf the character is \"D\", then add the current number to the end of the second stack. \\nIf the character is \"I\", then add the current number to the end of the first stack. Afterwards, poll everything from the back of the second stack to the back of the first stack. \\n\\nPlz do a dry run using this idea on one of the test cases, and you will see how it works. \\n   \\n   ```\\npublic String smallestNumber(String pattern) {\\n        char[] letters = pattern.toCharArray();\\n        StringBuilder res = new StringBuilder();\\n        ArrayDeque<Integer> stack = new ArrayDeque<>();\\n        ArrayDeque<Integer> s2 = new ArrayDeque<>();\\n        for(int i = 0; i<letters.length; i++){\\n            if(letters[i] == \\'I\\'){\\n                stack.addLast(i+1);\\n                while(!s2.isEmpty()){\\n                    stack.addLast(s2.pollLast());\\n                }\\n            }\\n            else if(letters[i] == \\'D\\'){\\n                s2.addLast(i+1);\\n            }\\n        }\\n        stack.addLast(letters.length+1);\\n        while(!s2.isEmpty()){\\n            stack.addLast(s2.pollLast());\\n        }\\n        for(int i : stack){\\n            res.append(i);\\n        }\\n        return res.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String smallestNumber(String pattern) {\\n        char[] letters = pattern.toCharArray();\\n        StringBuilder res = new StringBuilder();\\n        ArrayDeque<Integer> stack = new ArrayDeque<>();\\n        ArrayDeque<Integer> s2 = new ArrayDeque<>();\\n        for(int i = 0; i<letters.length; i++){\\n            if(letters[i] == \\'I\\'){\\n                stack.addLast(i+1);\\n                while(!s2.isEmpty()){\\n                    stack.addLast(s2.pollLast());\\n                }\\n            }\\n            else if(letters[i] == \\'D\\'){\\n                s2.addLast(i+1);\\n            }\\n        }\\n        stack.addLast(letters.length+1);\\n        while(!s2.isEmpty()){\\n            stack.addLast(s2.pollLast());\\n        }\\n        for(int i : stack){\\n            res.append(i);\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2430160,
                "title": "c-2-solutions-brute-force-o-10-5-optimal-o-1-using-stack",
                "content": "```\\n// Time Complexity -> O(n!) ~ 10^5\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        vector<int> arr;\\n        for(int i=1;i<=n+1;i++) {\\n            arr.push_back(i);\\n        }\\n        \\n        while(!isDIString(arr, pattern))\\n            next_permutation(arr.begin(),arr.end());\\n        \\n        string str;\\n        for(int i=0;i<=n;i++)   str.push_back(arr[i]+\\'0\\');\\n        return str;\\n    }\\n              \\n    bool isDIString(vector<int> &arr, string pattern) {\\n        for(int i=0;i<pattern.size();i++) {\\n            if(pattern[i] == \\'I\\') {\\n                if(arr[i] >= arr[i+1])\\n                    return false;\\n            }\\n            else {\\n                if(arr[i] <= arr[i+1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```\\n// Time Complexity -> constant space\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string ans=\"\";\\n        stack<int> st;\\n        for(int i=0;i<=pattern.size();i++) {\\n            st.push(i+1);\\n            if(i == pattern.size() || pattern[i] == \\'I\\') {\\n                while(!st.empty()) {\\n                    ans += to_string(st.top());\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n// Time Complexity -> O(n!) ~ 10^5\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        vector<int> arr;\\n        for(int i=1;i<=n+1;i++) {\\n            arr.push_back(i);\\n        }\\n        \\n        while(!isDIString(arr, pattern))\\n            next_permutation(arr.begin(),arr.end());\\n        \\n        string str;\\n        for(int i=0;i<=n;i++)   str.push_back(arr[i]+\\'0\\');\\n        return str;\\n    }\\n              \\n    bool isDIString(vector<int> &arr, string pattern) {\\n        for(int i=0;i<pattern.size();i++) {\\n            if(pattern[i] == \\'I\\') {\\n                if(arr[i] >= arr[i+1])\\n                    return false;\\n            }\\n            else {\\n                if(arr[i] <= arr[i+1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\n// Time Complexity -> constant space\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string ans=\"\";\\n        stack<int> st;\\n        for(int i=0;i<=pattern.size();i++) {\\n            st.push(i+1);\\n            if(i == pattern.size() || pattern[i] == \\'I\\') {\\n                while(!st.empty()) {\\n                    ans += to_string(st.top());\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429112,
                "title": "c-greedy-solution-no-stack-no-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pat) {\\n        string ans;\\n        for(int i = 0; i <= pat.length();i++){\\n            ans += to_string(i+1);\\n        }\\n        for(int i = 0; i < pat.length();){\\n            if(pat[i]==\\'D\\'){\\n                int temp = i;\\n                int count = 0;\\n                while(i < pat.length()&&pat[i]==pat[temp]){\\n                    i++;\\n                    count++;\\n                }\\n                int x = temp;\\n                int y = temp + count;\\n                while(x < y){\\n                    swap(ans[x++],ans[y--]);\\n                }\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pat) {\\n        string ans;\\n        for(int i = 0; i <= pat.length();i++){\\n            ans += to_string(i+1);\\n        }\\n        for(int i = 0; i < pat.length();){\\n            if(pat[i]==\\'D\\'){\\n                int temp = i;\\n                int count = 0;\\n                while(i < pat.length()&&pat[i]==pat[temp]){\\n                    i++;\\n                    count++;\\n                }\\n                int x = temp;\\n                int y = temp + count;\\n                while(x < y){\\n                    swap(ans[x++],ans[y--]);\\n                }\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428870,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string temp=\"123456789\";\\n        int n=pattern.size();\\n        // ans will be of size n+1\\n        do {\\n            // traverse over temp\\n            bool found=true;\\n            for(int i=0;i<n;i++) {\\n                if(pattern[i]==\\'D\\') {\\n                    if(temp[i+1]>temp[i]) {\\n                        found=false;\\n                        break;\\n                    }\\n                \\n                }\\n                else {\\n                    if(temp[i+1]<temp[i]) {\\n                        found=false;\\n                        break;\\n                    }\\n                }\\n               \\n            }\\n             if(found) {\\n                string ans=temp.substr(0,n+1);\\n                    return ans;\\n                }\\n        } while(next_permutation(temp.begin(),temp.end()));\\n        \\n                string ans=temp.substr(0,n+1);\\n                    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        string temp=\"123456789\";\\n        int n=pattern.size();\\n        // ans will be of size n+1\\n        do {\\n            // traverse over temp\\n            bool found=true;\\n            for(int i=0;i<n;i++) {\\n                if(pattern[i]==\\'D\\') {\\n                    if(temp[i+1]>temp[i]) {\\n                        found=false;\\n                        break;\\n                    }\\n                \\n                }\\n                else {\\n                    if(temp[i+1]<temp[i]) {\\n                        found=false;\\n                        break;\\n                    }\\n                }\\n               \\n            }\\n             if(found) {\\n                string ans=temp.substr(0,n+1);\\n                    return ans;\\n                }\\n        } while(next_permutation(temp.begin(),temp.end()));\\n        \\n                string ans=temp.substr(0,n+1);\\n                    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428648,
                "title": "9-is-small-enough-to-simply-brute-force",
                "content": "```\\n \\xA0 \\xA0def smallestNumber(self, pattern: str) -> str:\\n        for digits in permutations(range(1, len(pattern)+2)):\\n            for c, (d, e) in zip(pattern, pairwise(digits)):\\n                if (c == \\'I\\') != (d < e):\\n                    break \\n            else:\\n                return \\'\\'.join(map(str, digits))",
                "solutionTags": [],
                "code": "```\\n \\xA0 \\xA0def smallestNumber(self, pattern: str) -> str:\\n        for digits in permutations(range(1, len(pattern)+2)):\\n            for c, (d, e) in zip(pattern, pairwise(digits)):\\n                if (c == \\'I\\') != (d < e):\\n                    break \\n            else:\\n                return \\'\\'.join(map(str, digits))",
                "codeTag": "Python3"
            },
            {
                "id": 2428064,
                "title": "yet-another-rust-solution",
                "content": "![image](https://assets.leetcode.com/users/images/5e54e813-01cc-4657-8de4-dd07ee78cade_1660550719.5550337.png)\\n```rust\\nimpl Solution {\\n    pub fn smallest_number(mut pattern: String) -> String {\\n        pattern.push(\\'X\\');\\n        let length = pattern.len();\\n        let mut res: Vec<u8> = (1..=length as u8).collect();\\n        let partial_rev = |v: &mut Vec<u8>, mut i: usize, mut j: usize| {\\n            while i < j {\\n                v.swap(i, j);\\n                i += 1;\\n                j -= 1;\\n            }\\n        };\\n        let mut d_start: Option<usize> = None;\\n        pattern\\n            .bytes()\\n            .enumerate()\\n            .for_each(|(i, b)| match (d_start, b) {\\n                (None, b\\'D\\') => {\\n                    d_start = Some(i);\\n                }\\n                (Some(_start), b\\'D\\') => {}\\n                (Some(start), _) => {\\n                    partial_rev(&mut res, start, i);\\n                    d_start = None;\\n                }\\n                _ => {}\\n            });\\n        res.iter().map(|x| x.to_string()).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn smallest_number(mut pattern: String) -> String {\\n        pattern.push(\\'X\\');\\n        let length = pattern.len();\\n        let mut res: Vec<u8> = (1..=length as u8).collect();\\n        let partial_rev = |v: &mut Vec<u8>, mut i: usize, mut j: usize| {\\n            while i < j {\\n                v.swap(i, j);\\n                i += 1;\\n                j -= 1;\\n            }\\n        };\\n        let mut d_start: Option<usize> = None;\\n        pattern\\n            .bytes()\\n            .enumerate()\\n            .for_each(|(i, b)| match (d_start, b) {\\n                (None, b\\'D\\') => {\\n                    d_start = Some(i);\\n                }\\n                (Some(_start), b\\'D\\') => {}\\n                (Some(start), _) => {\\n                    partial_rev(&mut res, start, i);\\n                    d_start = None;\\n                }\\n                _ => {}\\n            });\\n        res.iter().map(|x| x.to_string()).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426821,
                "title": "c-backtracking-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(string pattern, string output, string& res, int index, unordered_set<int>&vis){\\n        \\n        if(index>=pattern.length()){\\n            if(res == \"-1\")\\n                res = output;\\n            return;\\n        }\\n        \\n        char temp = output.back();\\n        if(pattern[index] == \\'I\\'){\\n            for(int i=temp - \\'0\\';i<=9;i++){\\n                if(vis.find(i)==vis.end()){\\n                    output.push_back(i + \\'0\\');\\n                    vis.insert(i);\\n                    solve(pattern, output, res, index+1, vis);\\n                    vis.erase(i);\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=1;i<temp - \\'0\\';i++){\\n                if(vis.find(i)==vis.end()){\\n                    output.push_back(i + \\'0\\');\\n                    vis.insert(i);\\n                    solve(pattern, output, res, index+1, vis);\\n                    vis.erase(i);\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    string smallestNumber(string pattern) {\\n        string output = \"\", res = \"-1\";\\n        unordered_set<int>vis;\\n        \\n        for(int i=1;i<=9;i++){\\n            \\n            vis.insert(i);\\n            output.push_back(i + \\'0\\');\\n            solve(pattern, output, res, 0, vis);\\n            if(res!=\"-1\")\\n                return res;\\n            vis.erase(i);\\n            output.pop_back();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(string pattern, string output, string& res, int index, unordered_set<int>&vis){\\n        \\n        if(index>=pattern.length()){\\n            if(res == \"-1\")\\n                res = output;\\n            return;\\n        }\\n        \\n        char temp = output.back();\\n        if(pattern[index] == \\'I\\'){\\n            for(int i=temp - \\'0\\';i<=9;i++){\\n                if(vis.find(i)==vis.end()){\\n                    output.push_back(i + \\'0\\');\\n                    vis.insert(i);\\n                    solve(pattern, output, res, index+1, vis);\\n                    vis.erase(i);\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=1;i<temp - \\'0\\';i++){\\n                if(vis.find(i)==vis.end()){\\n                    output.push_back(i + \\'0\\');\\n                    vis.insert(i);\\n                    solve(pattern, output, res, index+1, vis);\\n                    vis.erase(i);\\n                    output.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    string smallestNumber(string pattern) {\\n        string output = \"\", res = \"-1\";\\n        unordered_set<int>vis;\\n        \\n        for(int i=1;i<=9;i++){\\n            \\n            vis.insert(i);\\n            output.push_back(i + \\'0\\');\\n            solve(pattern, output, res, 0, vis);\\n            if(res!=\"-1\")\\n                return res;\\n            vis.erase(i);\\n            output.pop_back();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426817,
                "title": "o-n-time-100-faster-js-easy-without-using-stack-only-loops-javascript",
                "content": "```\\n/**\\n * @param {string} pattern\\n * @return {string}\\n */\\nvar smallestNumber = function(pattern) {\\n   pattern+=\"I\";\\n  \\n    let num=Array(pattern.length).fill(\"\");\\n    let counter=1;\\n    let ans=\"\";\\n  \\n    for(let i=0;i<pattern.length;i++){\\n        if(pattern[i]==\"I\"){\\n             num[i]=counter++;\\n            let prev=i-1;\\n            while(prev>=0 && pattern[prev]==\"D\"){\\n                num[prev]=counter++;\\n                prev--;\\n            }\\n           \\n        }\\n        \\n    }\\n\\n    for(let i=0;i<pattern.length;i++){\\n        ans+=num[i];\\n    }\\n    \\n    return ans;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {string} pattern\\n * @return {string}\\n */\\nvar smallestNumber = function(pattern) {\\n   pattern+=\"I\";\\n  \\n    let num=Array(pattern.length).fill(\"\");\\n    let counter=1;\\n    let ans=\"\";\\n  \\n    for(let i=0;i<pattern.length;i++){\\n        if(pattern[i]==\"I\"){\\n             num[i]=counter++;\\n            let prev=i-1;\\n            while(prev>=0 && pattern[prev]==\"D\"){\\n                num[prev]=counter++;\\n                prev--;\\n            }\\n           \\n        }\\n        \\n    }\\n\\n    for(let i=0;i<pattern.length;i++){\\n        ans+=num[i];\\n    }\\n    \\n    return ans;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426637,
                "title": "python-intuitive-backtracking-with-comments",
                "content": "Greedy solution suggested by others could be tricky to come up with, specially in an interview setting. I went for a simple and intuitive Backtracking DFS approach. \\n\\n```\\n    def smallestNumber(self, pattern):\\n        \\n        def dfs(i, curr, res, mi=0, ma=10):\\n            # base case\\n            if i == len(pattern): \\n                return res\\n            \\n            # if \\'I\\', dfs for next unused bigger number between [curr,9]\\n            if pattern[i] == \"I\":\\n                for k in range(curr, ma):\\n                    if k not in res:\\n                        ret = dfs(i+1, k, res + [k])\\n                        if ret :\\n                            return ret\\n            # if \\'D\\', dfs for next unused smaller number between [curr,1]\\n            else :\\n                 for k in range(curr, mi, -1):\\n                    if k not in res:\\n                        ret = dfs(i+1, k, res + [k])\\n                        if ret :\\n                            return ret\\n            return None\\n        \\n        res = []\\n        # start dfs with all possible numbers [1,9]\\n        for k in range(1, 10):\\n                h = dfs(0, k, res + [k])\\n                if h : return \"\".join([str(i) for i in h])",
                "solutionTags": [
                    "Python",
                    "String",
                    "Depth-First Search"
                ],
                "code": "Greedy solution suggested by others could be tricky to come up with, specially in an interview setting. I went for a simple and intuitive Backtracking DFS approach. \\n\\n```\\n    def smallestNumber(self, pattern):\\n        \\n        def dfs(i, curr, res, mi=0, ma=10):\\n            # base case\\n            if i == len(pattern): \\n                return res\\n            \\n            # if \\'I\\', dfs for next unused bigger number between [curr,9]\\n            if pattern[i] == \"I\":\\n                for k in range(curr, ma):\\n                    if k not in res:\\n                        ret = dfs(i+1, k, res + [k])\\n                        if ret :\\n                            return ret\\n            # if \\'D\\', dfs for next unused smaller number between [curr,1]\\n            else :\\n                 for k in range(curr, mi, -1):\\n                    if k not in res:\\n                        ret = dfs(i+1, k, res + [k])\\n                        if ret :\\n                            return ret\\n            return None\\n        \\n        res = []\\n        # start dfs with all possible numbers [1,9]\\n        for k in range(1, 10):\\n                h = dfs(0, k, res + [k])\\n                if h : return \"\".join([str(i) for i in h])",
                "codeTag": "Python3"
            },
            {
                "id": 2425877,
                "title": "java-1-ms-faster-than-100-00-of-java-online-submission-using-reverse",
                "content": "Create an array with numbers from 1 to n+1 where n is length of a string.\\n\\nThen traverse through array, simultaneously check string if u find \\'D\\' in string once found  reverse the values of array once u find \\'I\\' in String or u reach end of a string.\\n\\nAt the end convert array in string.\\n\\n\\n\\n\\n\\'\\'\\'\\nclass Solution {\\n\\n    public String smallestNumber(String a) {\\n        int[]b=new int[a.length()+1];\\n        for(int i=0; i<b.length; i++) {\\n            b[i]=i+1;\\n        }\\n        for(int i=0; i<a.length(); i++) {\\n            if(a.charAt(i)==\\'D\\') {\\n                for(int j=i; j<a.length() && a.charAt(i)==\\'D\\'; j++) {\\n                    if((a.charAt(j)==\\'I\\') ) {\\n                        b=rev(b,i,j);\\n                        i=j+1;\\n                    } else if(j==(a.length()-1)) {\\n                        b=rev(b,i,j+1);\\n                        i=j+1;\\n                    }\\n                }\\n            }\\n        }\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0; i<b.length; ++i) {\\n            str.append(String.valueOf(b[i]));\\n        }\\n        return str.toString();\\n    }\\n    public static int[] rev(int[]c,int i,int j) {\\n\\n        for(int k=i; k<=(j+i)/2; k++) {\\n            int temp=c[k];\\n            c[k]=c[j-k+i];\\n            c[j-k+i]=temp;\\n        }\\n        return c;\\n    }\\n}      \\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String smallestNumber(String a) {\\n        int[]b=new int[a.length()+1];\\n        for(int i=0; i<b.length; i++) {\\n            b[i]=i+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2424366,
                "title": "c-o-1-space-without-reversing",
                "content": "*Please upvote if you find it helpful :)*\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int maxi = 1;\\n        string ans=\"\";\\n        ans+=to_string(maxi);\\n        for(int i=0;pattern[i];i++) {\\n            if(pattern[i]==\\'I\\') {\\n                ans+=to_string(maxi+1);\\n                maxi++;\\n            }\\n            else {\\n                int dcount = 0;\\n                while(pattern[i]==\\'D\\') {\\n                    dcount++;\\n                    i++;\\n                }\\n                int num = maxi+dcount;\\n                char c = ans[ans.length()-1];\\n                ans.pop_back();\\n                while(dcount--) {\\n                    ans+=to_string(num);\\n                    maxi = max(maxi, num);\\n                    num--;\\n                }\\n                ans+=c;\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int maxi = 1;\\n        string ans=\"\";\\n        ans+=to_string(maxi);\\n        for(int i=0;pattern[i];i++) {\\n            if(pattern[i]==\\'I\\') {\\n                ans+=to_string(maxi+1);\\n                maxi++;\\n            }\\n            else {\\n                int dcount = 0;\\n                while(pattern[i]==\\'D\\') {\\n                    dcount++;\\n                    i++;\\n                }\\n                int num = maxi+dcount;\\n                char c = ans[ans.length()-1];\\n                ans.pop_back();\\n                while(dcount--) {\\n                    ans+=to_string(num);\\n                    maxi = max(maxi, num);\\n                    num--;\\n                }\\n                ans+=c;\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423804,
                "title": "python-stack",
                "content": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        stack = []\\n        res = \\'\\'\\n \\n        for i in range(len(pattern) + 1):\\n            stack.append(i + 1)\\n            \\n            if (i == len(pattern) or pattern[i] == \\'I\\'):\\n                while len(stack) > 0:\\n                    res += str(stack.pop())\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        stack = []\\n        res = \\'\\'\\n \\n        for i in range(len(pattern) + 1):\\n            stack.append(i + 1)\\n            \\n            if (i == len(pattern) or pattern[i] == \\'I\\'):\\n                while len(stack) > 0:\\n                    res += str(stack.pop())\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423599,
                "title": "c-simple-reverse-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern){\\n        string num = \"123456789\";\\n        int n = pattern.size(), pos = 0;\\n        for(int i = 0; i < n; i++){\\n            if(pattern[i] == \\'D\\'){\\n                pos = i;\\n                while(pattern[i] == \\'D\\')    i++;\\n                reverse(num.begin()+pos, num.begin()+i+1);\\n            }\\n        }\\n        return num.substr(0, n+1);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string smallestNumber(string pattern){\\n        string num = \"123456789\";\\n        int n = pattern.size(), pos = 0;\\n        for(int i = 0; i < n; i++){\\n            if(pattern[i] == \\'D\\'){\\n                pos = i;\\n                while(pattern[i] == \\'D\\')    i++;\\n                reverse(num.begin()+pos, num.begin()+i+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2423589,
                "title": "simple-to-understand-solution-with-explanation-and-the-overall-idea",
                "content": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        \\n        \"\"\"\\n            Here is the idea:\\n                - Start with the lowest number i.e. 123456.. If the pattern length is 2, then the \\n                lowest number becomes 123. If it is 3, the lowest number becomes 1234\\n                - Check if the lowest number satisfies the contstraints\\n                - If it does, return\\n                - It it does not, return the next big permutation of this number. Next big \\n                permutation for 123 --> 132 --> 213 and so on\\n                - Keep trying until the permutation satisfies all the conditions\\n        \"\"\"\\n        \\n        def swap(inp, left,right):\\n            tmp = inp[left]\\n            inp[left] = inp[right]\\n            inp[right] = tmp\\n            \\n            \\n        def next_greater_permutation(inp):\\n            idx_one = -1\\n            for i in range(len(inp)-2,-1,-1):\\n                if inp[i] < inp[i+1]:\\n                    idx_one = i\\n                    break\\n                    \\n            idx_two = -1\\n            for i in range(len(inp)-1, idx_one, -1):\\n                if inp[i] > inp[idx_one]:\\n                    idx_two = i\\n                    break\\n                    \\n            \\n            swap(inp, idx_one, idx_two)\\n            left = idx_one +1\\n            right = len(inp)-1\\n            while left < right:\\n                swap(inp, left, right)\\n                left += 1\\n                right -= 1\\n        \\n                \\n        def is_valid(p):\\n            for i in range(len(pattern)):\\n                if pattern[i] == \"D\" and p[i+1] > p[i]:\\n                    return False\\n                if pattern[i] == \"I\" and p[i+1] < p[i]:\\n                    return False\\n            return True\\n        \\n        permutation = [i for i in range(1, len(pattern)+2)]\\n        if is_valid(permutation):\\n            return \"\".join([str(n) for n in permutation])\\n        \\n        found = False\\n        while not found:\\n            # loops until the element is found\\n            next_greater_permutation(permutation)\\n            # find the next greater permutation\\n            # this changes the permutation array in-place\\n            if is_valid(permutation):\\n                # returns when the valid permutation is found\\n                # this is guranteed to be the minimum since we started\\n                # with the min and always check for the next possible \\n                # permutation \\n                return \"\".join([str(n) for n in permutation])\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        \\n        \"\"\"\\n            Here is the idea:\\n                - Start with the lowest number i.e. 123456.. If the pattern length is 2, then the \\n                lowest number becomes 123. If it is 3, the lowest number becomes 1234\\n                - Check if the lowest number satisfies the contstraints\\n                - If it does, return\\n                - It it does not, return the next big permutation of this number. Next big \\n                permutation for 123 --> 132 --> 213 and so on\\n                - Keep trying until the permutation satisfies all the conditions\\n        \"\"\"\\n        \\n        def swap(inp, left,right):\\n            tmp = inp[left]\\n            inp[left] = inp[right]\\n            inp[right] = tmp\\n            \\n            \\n        def next_greater_permutation(inp):\\n            idx_one = -1\\n            for i in range(len(inp)-2,-1,-1):\\n                if inp[i] < inp[i+1]:\\n                    idx_one = i\\n                    break\\n                    \\n            idx_two = -1\\n            for i in range(len(inp)-1, idx_one, -1):\\n                if inp[i] > inp[idx_one]:\\n                    idx_two = i\\n                    break\\n                    \\n            \\n            swap(inp, idx_one, idx_two)\\n            left = idx_one +1\\n            right = len(inp)-1\\n            while left < right:\\n                swap(inp, left, right)\\n                left += 1\\n                right -= 1\\n        \\n                \\n        def is_valid(p):\\n            for i in range(len(pattern)):\\n                if pattern[i] == \"D\" and p[i+1] > p[i]:\\n                    return False\\n                if pattern[i] == \"I\" and p[i+1] < p[i]:\\n                    return False\\n            return True\\n        \\n        permutation = [i for i in range(1, len(pattern)+2)]\\n        if is_valid(permutation):\\n            return \"\".join([str(n) for n in permutation])\\n        \\n        found = False\\n        while not found:\\n            # loops until the element is found\\n            next_greater_permutation(permutation)\\n            # find the next greater permutation\\n            # this changes the permutation array in-place\\n            if is_valid(permutation):\\n                # returns when the valid permutation is found\\n                # this is guranteed to be the minimum since we started\\n                # with the min and always check for the next possible \\n                # permutation \\n                return \"\".join([str(n) for n in permutation])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423574,
                "title": "easy-java-backtracking",
                "content": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        HashSet<Integer> hset = new HashSet<>();\\n        List<String> res = new ArrayList<>();\\n        \\n        \\n        for (int i = 1; i <= 9; i++) {\\n\\n            hset.add(i);\\n            dfs(hset, \"\" + i, res, pattern, 0, i);\\n            hset.remove(i);\\n\\n        }\\n        \\n        int[] resarr = new int[res.size()];\\n        Arrays.fill(resarr, Integer.MAX_VALUE);\\n        int a = 0;\\n        for (String s: res) {\\n            resarr[a] = Integer.parseInt(s);\\n            a++;\\n        }\\n        \\n        Arrays.sort(resarr);\\n        return resarr[0] + \"\";\\n\\n    }\\n    \\n    \\n    private void dfs(HashSet<Integer> hset, String temp, List<String> res, String pattern, int index, int lastnum) {\\n        \\n        if (index >= pattern.length()) {\\n        \\n            if (temp.length() == pattern.length() + 1) {\\n                res.add(temp);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= 9; i++) {\\n            if (pattern.charAt(index) == \\'D\\') {\\n                if (i > lastnum || hset.contains(i)) {\\n                    continue;\\n                }\\n                hset.add(i);\\n                dfs(hset, temp + i, res, pattern, index + 1, i);\\n                hset.remove(i);\\n\\n            } else {\\n                // \\'I\\': increasing\\n                // hashset contains used integer\\n\\n                if (i < lastnum || hset.contains(i)) {\\n                    continue;\\n                }\\n                hset.add(i);\\n                dfs(hset, temp + i, res, pattern, index + 1, i);\\n                hset.remove(i);\\n\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        HashSet<Integer> hset = new HashSet<>();\\n        List<String> res = new ArrayList<>();\\n        \\n        \\n        for (int i = 1; i <= 9; i++) {\\n\\n            hset.add(i);\\n            dfs(hset, \"\" + i, res, pattern, 0, i);\\n            hset.remove(i);\\n\\n        }\\n        \\n        int[] resarr = new int[res.size()];\\n        Arrays.fill(resarr, Integer.MAX_VALUE);\\n        int a = 0;\\n        for (String s: res) {\\n            resarr[a] = Integer.parseInt(s);\\n            a++;\\n        }\\n        \\n        Arrays.sort(resarr);\\n        return resarr[0] + \"\";\\n\\n    }\\n    \\n    \\n    private void dfs(HashSet<Integer> hset, String temp, List<String> res, String pattern, int index, int lastnum) {\\n        \\n        if (index >= pattern.length()) {\\n        \\n            if (temp.length() == pattern.length() + 1) {\\n                res.add(temp);\\n            }\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= 9; i++) {\\n            if (pattern.charAt(index) == \\'D\\') {\\n                if (i > lastnum || hset.contains(i)) {\\n                    continue;\\n                }\\n                hset.add(i);\\n                dfs(hset, temp + i, res, pattern, index + 1, i);\\n                hset.remove(i);\\n\\n            } else {\\n                // \\'I\\': increasing\\n                // hashset contains used integer\\n\\n                if (i < lastnum || hset.contains(i)) {\\n                    continue;\\n                }\\n                hset.add(i);\\n                dfs(hset, temp + i, res, pattern, index + 1, i);\\n                hset.remove(i);\\n\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423215,
                "title": "c-solution-using-next-permutation-easy-solution",
                "content": "```\\nstring smallestNumber(string pattern) {\\n        string s = \"\";\\n        int n = pattern.size();\\n        for( int i=1; i<=n+1; i++){\\n            s+= to_string(i);\\n        }\\n        string s1 = s;\\n        next_permutation(s1.begin(), s1.end());\\n        while(s!= s1){\\n            bool flag  = true;\\n            for( int i=0; i<pattern.size(); i++){\\n                if(pattern[i]==\\'I\\' && s1[i]< s1[i+1]){\\n                    continue;\\n                }\\n                if( pattern[i]==\\'D\\'&& s1[i]>s1[i+1]){\\n                    continue;\\n                }\\n                else{\\n                    flag = false;\\n                    break;\\n                }\\n                \\n            }\\n            if(flag == true){\\n                break;\\n            }\\n            next_permutation(s1.begin(), s1.end());\\n        }\\n        return s1;\\n    }\\n```\\n\\n**please upvote if you find it insightful ;)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring smallestNumber(string pattern) {\\n        string s = \"\";\\n        int n = pattern.size();\\n        for( int i=1; i<=n+1; i++){\\n            s+= to_string(i);\\n        }\\n        string s1 = s;\\n        next_permutation(s1.begin(), s1.end());\\n        while(s!= s1){\\n            bool flag  = true;\\n            for( int i=0; i<pattern.size(); i++){\\n                if(pattern[i]==\\'I\\' && s1[i]< s1[i+1]){\\n                    continue;\\n                }\\n                if( pattern[i]==\\'D\\'&& s1[i]>s1[i+1]){\\n                    continue;\\n                }\\n                else{\\n                    flag = false;\\n                    break;\\n                }\\n                \\n            }\\n            if(flag == true){\\n                break;\\n            }\\n            next_permutation(s1.begin(), s1.end());\\n        }\\n        return s1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423206,
                "title": "very-simple-and-clean-code-based-on-stack",
                "content": "```\\n//  THIS IS THE EXACT QUESTION OF SMALLEST NUMBER FOLLOWING PATTERN OF STACK SERIES ON PEPCODING\\n// YOUTUBE CHANNEL SO YOU CAN REFER THAT VIDEO TO GET IDEA AND THIS IS THE SECOND QUESTION ENCOUNTERED AFTER\\nARRANGE HOUSE QUESTION OF LEETCODE SIMILAR TO ARRANGE BUILDING OF PEPCODING DP SERIES\\n\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int n = pattern.length();\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Integer> st = new Stack<>();\\n        int count = 1;\\n        \\n        for(int i=0; i<n; i++){\\n            char ch = pattern.charAt(i);\\n            \\n            if(ch == \\'D\\'){\\n                st.push(count);\\n                count++;\\n            }\\n            else {\\n                st.push(count);\\n                count++;\\n                \\n                while(!st.isEmpty()){\\n                    sb.append(st.pop());\\n                }\\n            }\\n        }\\n \\n                st.push(count);\\n                while(!st.isEmpty()){\\n                    sb.append(st.pop());\\n                }\\n        \\n        return sb.toString();\\n    }\\n}\\nPLEASE UPVOTE \\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n//  THIS IS THE EXACT QUESTION OF SMALLEST NUMBER FOLLOWING PATTERN OF STACK SERIES ON PEPCODING\\n// YOUTUBE CHANNEL SO YOU CAN REFER THAT VIDEO TO GET IDEA AND THIS IS THE SECOND QUESTION ENCOUNTERED AFTER\\nARRANGE HOUSE QUESTION OF LEETCODE SIMILAR TO ARRANGE BUILDING OF PEPCODING DP SERIES\\n\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int n = pattern.length();\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Integer> st = new Stack<>();\\n        int count = 1;\\n        \\n        for(int i=0; i<n; i++){\\n            char ch = pattern.charAt(i);\\n            \\n            if(ch == \\'D\\'){\\n                st.push(count);\\n                count++;\\n            }\\n            else {\\n                st.push(count);\\n                count++;\\n                \\n                while(!st.isEmpty()){\\n                    sb.append(st.pop());\\n                }\\n            }\\n        }\\n \\n                st.push(count);\\n                while(!st.isEmpty()){\\n                    sb.append(st.pop());\\n                }\\n        \\n        return sb.toString();\\n    }\\n}\\nPLEASE UPVOTE \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423056,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size() + 1;\\n        vector<int> ind(n, 0);\\n        vector<vector<int>> graph(n);\\n        for (int i = 0; i < n - 1; i++) {\\n            if (pattern[i] == \\'I\\') {\\n                ind[i + 1] += 1;\\n                graph[i].push_back(i + 1);\\n            }\\n            else {\\n                ind[i] += 1;\\n                graph[i + 1].push_back(i);\\n            }\\n        }\\n        string s(n, \\'1\\');\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        vector<bool> digitVisit(100, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (ind[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        vector<bool> vis(n, 0);\\n        while (!q.empty()) {\\n            int i = q.top();\\n            q.pop();\\n            vis[i] = 1;\\n            for (char c = s[i]; c <= \\'9\\'; c++) {\\n                if (!digitVisit[c - \\'1\\']) {\\n                    s[i] = c;\\n                    digitVisit[c - \\'1\\'] = 1;\\n                    break;\\n                }\\n            }\\n            for (int j : graph[i]) {\\n                s[j] = max(s[j], char(s[i] + 1));\\n                --ind[j];\\n                if (ind[j] == 0)\\n                {\\n                    q.push(j);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size() + 1;\\n        vector<int> ind(n, 0);\\n        vector<vector<int>> graph(n);\\n        for (int i = 0; i < n - 1; i++) {\\n            if (pattern[i] == \\'I\\') {\\n                ind[i + 1] += 1;\\n                graph[i].push_back(i + 1);\\n            }\\n            else {\\n                ind[i] += 1;\\n                graph[i + 1].push_back(i);\\n            }\\n        }\\n        string s(n, \\'1\\');\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        vector<bool> digitVisit(100, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (ind[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        vector<bool> vis(n, 0);\\n        while (!q.empty()) {\\n            int i = q.top();\\n            q.pop();\\n            vis[i] = 1;\\n            for (char c = s[i]; c <= \\'9\\'; c++) {\\n                if (!digitVisit[c - \\'1\\']) {\\n                    s[i] = c;\\n                    digitVisit[c - \\'1\\'] = 1;\\n                    break;\\n                }\\n            }\\n            for (int j : graph[i]) {\\n                s[j] = max(s[j], char(s[i] + 1));\\n                --ind[j];\\n                if (ind[j] == 0)\\n                {\\n                    q.push(j);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423007,
                "title": "c-easy-soution",
                "content": "class Solution {\\n# public:\\n    string smallestNumber(string pattern) {\\n        char c=\\'1\\';\\n        string s=\"\";\\n        for(int i=0;i<pattern.size();i++){\\n            s+=c;\\n            c++;\\n        }\\n          s+=c;\\n         for(int i=pattern.size()-1;i>=0;i--){\\n             if(pattern[i]==\\'D\\'){\\n                 int j=i;\\n                 while(j<pattern.size()&& pattern[j]==\\'D\\'){\\n                     swap(s[j],s[j+1]);\\n                     j++;\\n                 }\\n                 \\n             }\\n         }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n# public:\\n    string smallestNumber(string pattern) {\\n        char c=\\'1\\';\\n        string s=\"\";\\n        for(int i=0;i<pattern.size();i++){\\n            s+=c;\\n            c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2423000,
                "title": "c-why-you-should-use-stack-here",
                "content": "why should we use stack in this problem ? \\n&rarr; Because stack gives us the behavior in reverse order.\\n&rarr; If you ever encounter \\'I\\' you are simply going to add in stack and remove add it to result and when you getting \\'D\\' store it inside the stack.\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n\\n    string result;\\n\\n\\n    stack<int> st;\\n\\n    for(int i = 0; i<=pattern.size();i++){\\n\\n\\n        st.push(i + 1);\\n\\n\\n        \\n            while((i == pattern.length() || pattern[i]==\\'I\\') and st.empty() == false){\\n                result += to_string(st.top());\\n            st.pop();\\n            }\\n        \\n    }\\n\\n    return result;\\n\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n\\n    string result;\\n\\n\\n    stack<int> st;\\n\\n    for(int i = 0; i<=pattern.size();i++){\\n\\n\\n        st.push(i + 1);\\n\\n\\n        \\n            while((i == pattern.length() || pattern[i]==\\'I\\') and st.empty() == false){\\n                result += to_string(st.top());\\n            st.pop();\\n            }\\n        \\n    }\\n\\n    return result;\\n\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422960,
                "title": "reverse-string-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n  void reverse(string &s, int i, int j)\\n  {\\n    while (i <= j)\\n    {\\n      char ch = s[i];\\n      s[i] = s[j];\\n      s[j] = ch;\\n      i++;\\n      j--;\\n    }\\n  }\\n  string smallestNumber(string pattern)\\n  {\\n    string ans = \"\";\\n    for (int i = 1; i <= pattern.size() + 1; i++)\\n      ans += to_string(i);\\n\\n    for (int i = 0; i < pattern.size();)\\n    {\\n      if (pattern[i] == \\'D\\')\\n      {\\n        int start = i;\\n        int end = i;\\n        while (end < pattern.size() && pattern[end] == \\'D\\')\\n        {\\n          end++;\\n        }\\n        reverse(ans, start, end);\\n\\n        i = end;\\n      }\\n      else\\n      {\\n        i++;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  void reverse(string &s, int i, int j)\\n  {\\n    while (i <= j)\\n    {\\n      char ch = s[i];\\n      s[i] = s[j];\\n      s[j] = ch;\\n      i++;\\n      j--;\\n    }\\n  }\\n  string smallestNumber(string pattern)\\n  {\\n    string ans = \"\";\\n    for (int i = 1; i <= pattern.size() + 1; i++)\\n      ans += to_string(i);\\n\\n    for (int i = 0; i < pattern.size();)\\n    {\\n      if (pattern[i] == \\'D\\')\\n      {\\n        int start = i;\\n        int end = i;\\n        while (end < pattern.size() && pattern[end] == \\'D\\')\\n        {\\n          end++;\\n        }\\n        reverse(ans, start, end);\\n\\n        i = end;\\n      }\\n      else\\n      {\\n        i++;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422818,
                "title": "first-ever-backtracking-done-on-own",
                "content": "\\t\\tn = len(pattern)\\n        res = []\\n        def dfs(a): \\n            if not a or len(a) >= n+1: \\n                if a: res.append(a.copy())\\n            if len(a)<=n and pattern[len(a)-1] == \\'I\\': \\n                for k in range(a[-1]+1,10):\\n                    if k not in a: \\n                        a.append(k)  \\n                        dfs(a) \\n            if len(a)<=n and pattern[len(a)-1] == \\'D\\': \\n                for k in range(a[-1]-1,0,-1):\\n                    if k not in a: \\n                        a.append(k) \\n                        dfs(a) \\n            a.pop()\\n        \\n        for i in range(1,10): \\n            a = [i]\\n            dfs(a) \\n            if res: return \\'\\'.join(map(str, res[0]))\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "\\t\\tn = len(pattern)\\n        res = []\\n        def dfs(a): \\n            if not a or len(a) >= n+1: \\n                if a: res.append(a.copy())\\n            if len(a)<=n and pattern[len(a)-1] == \\'I\\': \\n                for k in range(a[-1]+1,10):\\n                    if k not in a: \\n                        a.append(k)  \\n                        dfs(a) \\n            if len(a)<=n and pattern[len(a)-1] == \\'D\\': \\n                for k in range(a[-1]-1,0,-1):\\n                    if k not in a: \\n                        a.append(k) \\n                        dfs(a) \\n            a.pop()\\n        \\n        for i in range(1,10): \\n            a = [i]\\n            dfs(a) \\n            if res: return \\'\\'.join(map(str, res[0]))\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2422757,
                "title": "c-dfs-time-less-than-o-9-space-o-n",
                "content": "DFS solution\\n\\n```\\n// time: less than O(9!) in worst case with pruning\\n// space: O(n) for recursive call stack\\n\\nclass Solution {\\npublic:\\n  string smallestNumber(string& pattern) {\\n    return to_string(solve(pattern, 0, 0, 0));\\n  }\\n  \\nprivate:\\n  int solve(string& pattern, int result, int i, int16_t usedMask) {\\n    if (i > pattern.length())\\n      return result;\\n    \\n    int num = INT_MAX, prev_d = result % 10;\\n    for (int cur_d = 1; cur_d <= 9; cur_d++) {\\n      if (usedMask & (1 << cur_d))\\n        continue;\\n      if (i == 0 or\\n          (pattern[i-1] == \\'I\\' and prev_d < cur_d) or\\n          (pattern[i-1] == \\'D\\' and prev_d > cur_d)) {\\n        num = min(num, solve(pattern, result * 10 + cur_d, i + 1, usedMask | (1 << cur_d)));\\n      }\\n    }\\n    \\n    return num;\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\n// time: less than O(9!) in worst case with pruning\\n// space: O(n) for recursive call stack\\n\\nclass Solution {\\npublic:\\n  string smallestNumber(string& pattern) {\\n    return to_string(solve(pattern, 0, 0, 0));\\n  }\\n  \\nprivate:\\n  int solve(string& pattern, int result, int i, int16_t usedMask) {\\n    if (i > pattern.length())\\n      return result;\\n    \\n    int num = INT_MAX, prev_d = result % 10;\\n    for (int cur_d = 1; cur_d <= 9; cur_d++) {\\n      if (usedMask & (1 << cur_d))\\n        continue;\\n      if (i == 0 or\\n          (pattern[i-1] == \\'I\\' and prev_d < cur_d) or\\n          (pattern[i-1] == \\'D\\' and prev_d > cur_d)) {\\n        num = min(num, solve(pattern, result * 10 + cur_d, i + 1, usedMask | (1 << cur_d)));\\n      }\\n    }\\n    \\n    return num;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422660,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public string SmallestNumber(string pattern)\\n    {\\n       Stack<int> stack = new Stack<int>();\\n        int num = 1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < pattern.Length; i++)\\n        {\\n            if (pattern[i] == \\'D\\')\\n            {\\n                stack.Push(num);\\n                num++;\\n            }\\n            else\\n            {\\n                sb.Append(num.ToString()); \\n\\t\\t\\t\\tnum++;\\n                while (stack.Count > 0)\\n                {\\n                    sb.Append(stack.Pop());\\n                }\\n            }\\n        }\\n        stack.Push(num);\\n        while(stack.Count > 0)\\n        {\\n            sb.Append(stack.Pop());\\n        }\\n        return sb.ToString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public string SmallestNumber(string pattern)\\n    {\\n       Stack<int> stack = new Stack<int>();\\n        int num = 1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < pattern.Length; i++)\\n        {\\n            if (pattern[i] == \\'D\\')\\n            {\\n                stack.Push(num);\\n                num++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2422617,
                "title": "java-clean-simple-0ms",
                "content": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        char[] charArr = pattern.toCharArray();\\n        int[] arr = new int[pattern.length() + 1];\\n        int cur = 1;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = cur;\\n\\n            int prevIndex = i - 1;\\n            while (prevIndex >= 0 && charArr[prevIndex] == \\'D\\') {\\n                arr[prevIndex]++;\\n                prevIndex--;\\n            }\\n            if (i < charArr.length && charArr[i] == \\'I\\')\\n                cur = arr[prevIndex + 1] + 1;\\n        }\\n\\n        StringBuilder str = new StringBuilder();\\n        for (var item : arr)\\n            str.append(item);\\n\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        char[] charArr = pattern.toCharArray();\\n        int[] arr = new int[pattern.length() + 1];\\n        int cur = 1;\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = cur;\\n\\n            int prevIndex = i - 1;\\n            while (prevIndex >= 0 && charArr[prevIndex] == \\'D\\') {\\n                arr[prevIndex]++;\\n                prevIndex--;\\n            }\\n            if (i < charArr.length && charArr[i] == \\'I\\')\\n                cur = arr[prevIndex + 1] + 1;\\n        }\\n\\n        StringBuilder str = new StringBuilder();\\n        for (var item : arr)\\n            str.append(item);\\n\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422583,
                "title": "c-o-n-solution-using-stack-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        string res(n+1, \\'*\\');\\n        vector<int> diff(n+1, 0);\\n        stack<int> st;\\n\\n        for (int i=0; i<n; i++) {\\n            if (pattern[i] == \\'I\\') {\\n                while (st.size() > 0) {\\n                    diff[st.top()+1] += i-st.top();\\n                    st.pop();\\n                }\\n                st.push(i);\\n            }\\n        }\\n        if (st.size()) {\\n            diff[st.top()+1] += n-st.top();\\n        }\\n        \\n        int maxi = 0;\\n        for (int i=0; i<n; i++) {\\n            if (pattern[i] == \\'D\\') {\\n                diff[i+1] = diff[i]-1;\\n            } else {\\n                diff[i+1] += maxi;\\n                maxi = max(maxi, diff[i+1]);\\n            }\\n        }\\n        \\n        // for (int i: diff) cout<<i<<\" \";\\n        // cout<<endl;\\n        \\n        int a = 1-*min_element(diff.begin(), diff.end());\\n        for (int i=0; i<=n; i++) {\\n            res[i] = \\'0\\' + (a+diff[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        string res(n+1, \\'*\\');\\n        vector<int> diff(n+1, 0);\\n        stack<int> st;\\n\\n        for (int i=0; i<n; i++) {\\n            if (pattern[i] == \\'I\\') {\\n                while (st.size() > 0) {\\n                    diff[st.top()+1] += i-st.top();\\n                    st.pop();\\n                }\\n                st.push(i);\\n            }\\n        }\\n        if (st.size()) {\\n            diff[st.top()+1] += n-st.top();\\n        }\\n        \\n        int maxi = 0;\\n        for (int i=0; i<n; i++) {\\n            if (pattern[i] == \\'D\\') {\\n                diff[i+1] = diff[i]-1;\\n            } else {\\n                diff[i+1] += maxi;\\n                maxi = max(maxi, diff[i+1]);\\n            }\\n        }\\n        \\n        // for (int i: diff) cout<<i<<\" \";\\n        // cout<<endl;\\n        \\n        int a = 1-*min_element(diff.begin(), diff.end());\\n        for (int i=0; i<=n; i++) {\\n            res[i] = \\'0\\' + (a+diff[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2422532,
                "title": "java-beats-100-0ms-tc-o-n-sc-o-1-except-the-string-required-to-build-the-result",
                "content": "*Note: Constraint is n<=8 *\\n\\nTake few examples as below.\\nThe idea is for every \\'I\\' we will just increase the number \\n(We will keep a **num** to get what number we need to add to the resultant string). **So always start with 1**.\\n\\nWith every D we need to skip the next number but it gets tricky when we have consecutive D. Think why by going through below examples and that will form a pattern. \\n\\nSo when we encounter D in our string we see how many consecutive are there & we need to skip/jump by that many number from the current number. With than we subtract everytime by 1 (for \\'I\\' we add by 1 & in D we minus one from the **num**)\\n\\n\\nOutside loop, we need to handle when the string ends with I as the resultant string is n+1.\\n\\n\\n```\\n\\n/**\\nIII\\n1234\\n\\nIIID\\n12354\\n\\nIIIDI\\n123546\\n\\nIIIDII\\n123 5467\\n\\nIII DD\\n123 654\\n\\nIII DDI\\n123 6547\\n\\nIIIDIDDD\\n123 549876\\n\\nIII DIDIDD\\n123 5476\\n\\n\\nDDDDDDDD\\n987654321\\n\\n\\n*/\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int num=1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<pattern.length();i++) {\\n            if(pattern.charAt(i)==\\'I\\')\\n                sb.append(num++);\\n            else {\\n                int j=i+1;\\n                while(j<pattern.length() && pattern.charAt(j)==\\'D\\') {\\n                    j++;\\n                }\\n                int count = j-i;\\n                int max=num+count;\\n\\t\\t\\t\\t\\n                while(count>=0) {\\n                    sb.append(num+count--);\\n                }\\n                i=j;\\n                num=max+1;\\n            }\\n        }\\n        if(pattern.charAt(pattern.length()-1)==\\'I\\')\\n            sb.append(num++);\\n        return sb.toString();\\n    }\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n/**\\nIII\\n1234\\n\\nIIID\\n12354\\n\\nIIIDI\\n123546\\n\\nIIIDII\\n123 5467\\n\\nIII DD\\n123 654\\n\\nIII DDI\\n123 6547\\n\\nIIIDIDDD\\n123 549876\\n\\nIII DIDIDD\\n123 5476\\n\\n\\nDDDDDDDD\\n987654321\\n\\n\\n*/\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int num=1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<pattern.length();i++) {\\n            if(pattern.charAt(i)==\\'I\\')\\n                sb.append(num++);\\n            else {\\n                int j=i+1;\\n                while(j<pattern.length() && pattern.charAt(j)==\\'D\\') {\\n                    j++;\\n                }\\n                int count = j-i;\\n                int max=num+count;\\n\\t\\t\\t\\t\\n                while(count>=0) {\\n                    sb.append(num+count--);\\n                }\\n                i=j;\\n                num=max+1;\\n            }\\n        }\\n        if(pattern.charAt(pattern.length()-1)==\\'I\\')\\n            sb.append(num++);\\n        return sb.toString();\\n    }\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422527,
                "title": "backtracing-c-check-conditions",
                "content": "The problem is to find smallest (lexicographically) \\'answer\\' string that satisfies : \\n\\nIf pattern[i]=\\'I\\' then answer[i]<answer[i+1]\\nIf pattern[i]=\\'D\\' then answer[i]>answer[i+1]\\n\\nWe can just check all possible permutations of 1 to n+1 (n=length of pattern)\\nbut this will be very time costly.\\n\\nInstead we can just put a few conditions to check if current state is a valid or not.\\nIf current itself is not valid then no need to further check.\\n\\nThe conditions used in code are as asked in question.Code is little bit messy and little bit repeated but can be improved :P\\n\\nConditions Explained : \\n1) Just check for 1 to 9.If any number is already visited then we can\\'t take that number.\\n\\n2) If current position in pattern is \\'I\\' and the number which we want to take is greater than previous number taken then it is a valid condition.Take that number and move on.\\n\\n3) Similarly if current position in pattenr is \\'D\\' and the number which we want to take is smaller than previous number taken then it is a valid condition.Take that number and move on \\n \\nIf we have finished whole pattern and reached ind==p.size()+1\\nstore that answer and mark found = true and return.\\n \\n```\\n\\tstring finalans;\\n    bool found=false;\\n    void backtrack(int ind,string &p,string ans,vector<int>&visited)\\n    {\\n        cout<<ans<<endl;\\n        if(found)\\n            return;\\n        if(ind==p.size()+1)\\n        {\\n            found=true;\\n            finalans = ans;\\n            return;\\n        }\\n        for(int i=1;i<=9;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(ind==0)\\n                {\\n                    visited[i]=1;\\n                    ans.push_back(i+\\'0\\');\\n                    backtrack(ind+1,p,ans,visited);\\n                    ans.pop_back();\\n                    visited[i]=0;\\n                }\\n                else\\n                {\\n                    if(p[ind-1]==\\'I\\')\\n                    {\\n                        if((i+\\'0\\')>(ans.back()))\\n                        {\\n                            visited[i]=1;\\n                            ans.push_back(i+\\'0\\');\\n                            backtrack(ind+1,p,ans,visited);\\n                            ans.pop_back();\\n                            visited[i]=0;\\n                        }\\n                    }\\n                    else if(p[ind-1]==\\'D\\')\\n                    {\\n                        if((i+\\'0\\')<(ans.back()))\\n                        {\\n                            visited[i]=1;\\n                            ans.push_back(i+\\'0\\');\\n                            backtrack(ind+1,p,ans,visited);\\n                            ans.pop_back();\\n                            visited[i]=0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    string smallestNumber(string p) {\\n        int n = p.length()+1;\\n        vector<int>visited(10,0);\\n        string ans=\"\";\\n        backtrack(0,p,ans,visited);\\n        \\n        return finalans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tstring finalans;\\n    bool found=false;\\n    void backtrack(int ind,string &p,string ans,vector<int>&visited)\\n    {\\n        cout<<ans<<endl;\\n        if(found)\\n            return;\\n        if(ind==p.size()+1)\\n        {\\n            found=true;\\n            finalans = ans;\\n            return;\\n        }\\n        for(int i=1;i<=9;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                if(ind==0)\\n                {\\n                    visited[i]=1;\\n                    ans.push_back(i+\\'0\\');\\n                    backtrack(ind+1,p,ans,visited);\\n                    ans.pop_back();\\n                    visited[i]=0;\\n                }\\n                else\\n                {\\n                    if(p[ind-1]==\\'I\\')\\n                    {\\n                        if((i+\\'0\\')>(ans.back()))\\n                        {\\n                            visited[i]=1;\\n                            ans.push_back(i+\\'0\\');\\n                            backtrack(ind+1,p,ans,visited);\\n                            ans.pop_back();\\n                            visited[i]=0;\\n                        }\\n                    }\\n                    else if(p[ind-1]==\\'D\\')\\n                    {\\n                        if((i+\\'0\\')<(ans.back()))\\n                        {\\n                            visited[i]=1;\\n                            ans.push_back(i+\\'0\\');\\n                            backtrack(ind+1,p,ans,visited);\\n                            ans.pop_back();\\n                            visited[i]=0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    string smallestNumber(string p) {\\n        int n = p.length()+1;\\n        vector<int>visited(10,0);\\n        string ans=\"\";\\n        backtrack(0,p,ans,visited);\\n        \\n        return finalans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2422515,
                "title": "easy-java-backtracking",
                "content": "```\\nclass Solution {\\n    String res = \"\";\\n    Set<Integer> used = new HashSet();\\n\\n    public String smallestNumber(String pattern) {\\n        recurse(pattern.toCharArray(), -1, -1, new StringBuilder());\\n        return res;\\n    }\\n\\n    private boolean recurse(char[] c, int index, int prevNum, StringBuilder sb) {\\n        if (index == c.length) return true;\\n        for (int i = 1; i <= 9; i++) {\\n            if (used.contains(i)) continue;\\n            if (index == -1) {\\n                sb.append(i);\\n                used.add(i);\\n                boolean found = recurse(c, index + 1, i, sb);\\n                if (found && res == \"\") res = sb.toString();\\n                if (found) return true;\\n                used.remove(i);\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else if (c[index] == \\'I\\') {\\n                if (prevNum < i) {\\n                    sb.append(i);\\n                    used.add(i);\\n                    boolean found = recurse(c, index + 1, i, sb);\\n                    if (found && res == \"\") res = sb.toString();\\n                    if (found) return true;\\n                    used.remove(i);\\n                    sb.deleteCharAt(sb.length() - 1);\\n                }\\n            } else {\\n                if (prevNum > i) {\\n                    sb.append(i);\\n                    used.add(i);\\n                    boolean found = recurse(c, index + 1, i, sb);\\n                    if (found && res == \"\") res = sb.toString();\\n                    if (found) return true;\\n                    used.remove(i);\\n                    sb.deleteCharAt(sb.length() - 1);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    String res = \"\";\\n    Set<Integer> used = new HashSet();\\n\\n    public String smallestNumber(String pattern) {\\n        recurse(pattern.toCharArray(), -1, -1, new StringBuilder());\\n        return res;\\n    }\\n\\n    private boolean recurse(char[] c, int index, int prevNum, StringBuilder sb) {\\n        if (index == c.length) return true;\\n        for (int i = 1; i <= 9; i++) {\\n            if (used.contains(i)) continue;\\n            if (index == -1) {\\n                sb.append(i);\\n                used.add(i);\\n                boolean found = recurse(c, index + 1, i, sb);\\n                if (found && res == \"\") res = sb.toString();\\n                if (found) return true;\\n                used.remove(i);\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else if (c[index] == \\'I\\') {\\n                if (prevNum < i) {\\n                    sb.append(i);\\n                    used.add(i);\\n                    boolean found = recurse(c, index + 1, i, sb);\\n                    if (found && res == \"\") res = sb.toString();\\n                    if (found) return true;\\n                    used.remove(i);\\n                    sb.deleteCharAt(sb.length() - 1);\\n                }\\n            } else {\\n                if (prevNum > i) {\\n                    sb.append(i);\\n                    used.add(i);\\n                    boolean found = recurse(c, index + 1, i, sb);\\n                    if (found && res == \"\") res = sb.toString();\\n                    if (found) return true;\\n                    used.remove(i);\\n                    sb.deleteCharAt(sb.length() - 1);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422514,
                "title": "2-stack-java",
                "content": "**Hint**: \\nMake 2 stacks, use first one to add increasing elements and if decreasing found, add that in another stack2 and then push all the elements from stack2 to stack1.\\n\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        Stack<Integer> stack1=new Stack<>();\\n        Stack<Integer> stack2=new Stack<>();\\n        for(int i=9;i>=1;i--){\\n            stack1.push(i);\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<pattern.length();i++){\\n            char curr=pattern.charAt(i);\\n            if(curr==\\'I\\'){\\n                sb.append(stack1.pop());\\n            }else{\\n                int count=0;\\n                int temp=i;\\n                while(temp<pattern.length() && pattern.charAt(temp)!=\\'I\\'){\\n                    stack2.push(stack1.pop());\\n                    temp+=1;\\n                }\\n                sb.append(stack1.pop());\\n                while(!stack2.isEmpty()){\\n                    sb.append(stack2.pop());\\n                    i+=1;\\n                }\\n            }\\n        }\\n        if(pattern.charAt(pattern.length()-1)==\\'I\\'){\\n            sb.append(stack1.pop());\\n        }\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        Stack<Integer> stack1=new Stack<>();\\n        Stack<Integer> stack2=new Stack<>();\\n        for(int i=9;i>=1;i--){\\n            stack1.push(i);\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<pattern.length();i++){\\n            char curr=pattern.charAt(i);\\n            if(curr==\\'I\\'){\\n                sb.append(stack1.pop());\\n            }else{\\n                int count=0;\\n                int temp=i;\\n                while(temp<pattern.length() && pattern.charAt(temp)!=\\'I\\'){\\n                    stack2.push(stack1.pop());\\n                    temp+=1;\\n                }\\n                sb.append(stack1.pop());\\n                while(!stack2.isEmpty()){\\n                    sb.append(stack2.pop());\\n                    i+=1;\\n                }\\n            }\\n        }\\n        if(pattern.charAt(pattern.length()-1)==\\'I\\'){\\n            sb.append(stack1.pop());\\n        }\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422485,
                "title": "c-backtracking-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string help;\\n    \\n    void f(int idx, int& n, string& ans, vector<bool>& visited, string& pattern){\\n        \\n        if(idx == n+1){\\n\\n            if(help.size() == 0){\\n                help = ans;\\n                return;\\n            }\\n            \\n            return;\\n        }\\n        \\n        if(idx == 0){\\n            \\n            for(char ch=\\'1\\';ch<=\\'9\\';ch++){\\n                if(visited[ch-\\'0\\'] || help.size() != 0) continue;\\n                ans.push_back(ch);\\n                visited[ch-\\'0\\'] = true;\\n                f(idx+1, n, ans, visited, pattern);\\n                ans.pop_back();\\n                visited[ch-\\'0\\'] = false;\\n            }\\n            \\n        }\\n        else{\\n            \\n            char last = ans[ans.size()-1];\\n            \\n            if(pattern[idx-1] == \\'I\\'){\\n                for(char ch=last+1;ch<=\\'9\\';ch++){\\n                    if(visited[ch-\\'0\\'] || help.size() != 0) continue;\\n                    ans.push_back(ch);\\n                    visited[ch-\\'0\\'] = true;\\n                    f(idx+1, n, ans, visited, pattern);\\n                    ans.pop_back();\\n                    visited[ch-\\'0\\'] = false;\\n                }\\n            }\\n            else{\\n                for(char ch=last-1;ch>=\\'1\\';ch--){\\n                    if(visited[ch-\\'0\\'] || help.size() != 0) continue;\\n                    ans.push_back(ch);\\n                    visited[ch-\\'0\\'] = true;\\n                    f(idx+1, n, ans, visited, pattern);\\n                    ans.pop_back();\\n                    visited[ch-\\'0\\'] = false;\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    string smallestNumber(string pattern) {\\n        int n = pattern.size();\\n        string ans;\\n        vector<bool> visited(10, false);\\n        f(0, n, ans, visited, pattern);\\n        return help;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    string help;\\n    \\n    void f(int idx, int& n, string& ans, vector<bool>& visited, string& pattern){\\n        \\n        if(idx == n+1){\\n\\n            if(help.size() == 0){\\n                help = ans;\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2422471,
                "title": "java-simple-backtracking-soln",
                "content": "Its a simple backtracking soln, folks with a little experience in that can easily understand that. The main thing is that if someone is not getting it, that I didn\\'t use any condition to check lexicographicality of the strings my code is producuing. Well there\\'s a simple trick for that, always try those cases first that fulfills your requirement. Our requirement was to find lexicographically smallest string, so for that I have used loops from 1 to 9 (or applicable limit), so that will automatically give you the lexicographically smallest string on the first possible answer. That **ct** variable is keeping that in check, that we have to store answer for the first time only.\\n\\nNote: Yu may have got the hang of it by now, nut let me tell another case to those who need it, If you were to find lexicographically largest string than you have to append larger values first i.e start the loop from 9 to 1 or in any applicable limit.\\n\\nRest of the things are easy ig\\n\\n\\n**EDIT** : That ct variable can also be used for pruning, just apply the base check for every call, and tada I got 1 ms soln.\\n\\n\\n```\\nclass Solution {                \\n    String real=\"999999999\";\\n    int ct=0;\\n    public String smallestNumber(String pattern) {\\n        StringBuilder ans=new StringBuilder();\\n        fun(pattern,ans,0,new HashSet<Integer>());\\n        return real;\\n    }\\n    void fun(String pat, StringBuilder ans, int i, HashSet<Integer> h){\\n\\tif(ct>0)return;\\n        if(pat.length()<i){\\n            real=ans.toString();\\n            ct++;\\n            return;\\n        }\\n        if(i==0){\\n            for(int j=1;j<=9;j++){\\n                ans.append(j);\\n                h.add(j);\\n                fun(pat,ans,i+1,h);\\n                h.remove(j);\\n                ans.deleteCharAt(ans.length()-1);\\n            }\\n        }\\n        else{\\n            char ch=pat.charAt(i-1);\\n            int ansch=ans.charAt(i-1)-\\'0\\';\\n            if(ch==\\'I\\'){\\n                for(int j=ansch+1;j<=9;j++){\\n                    if(h.contains(j))continue;\\n                    h.add(j);\\n                    ans.append(j);\\n                    fun(pat,ans,i+1,h);\\n                    h.remove(j);\\n                    ans.deleteCharAt(ans.length()-1);\\n                }\\n            }\\n            else{\\n                for(int j=1;j<ansch;j++){\\n                    if(h.contains(j))continue;\\n                    ans.append(j);\\n                    h.add(j);\\n                    fun(pat,ans,i+1,h);\\n                    h.remove(j);\\n                    ans.deleteCharAt(ans.length()-1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {                \\n    String real=\"999999999\";\\n    int ct=0;\\n    public String smallestNumber(String pattern) {\\n        StringBuilder ans=new StringBuilder();\\n        fun(pattern,ans,0,new HashSet<Integer>());\\n        return real;\\n    }\\n    void fun(String pat, StringBuilder ans, int i, HashSet<Integer> h){\\n\\tif(ct>0)return;\\n        if(pat.length()<i){\\n            real=ans.toString();\\n            ct++;\\n            return;\\n        }\\n        if(i==0){\\n            for(int j=1;j<=9;j++){\\n                ans.append(j);\\n                h.add(j);\\n                fun(pat,ans,i+1,h);\\n                h.remove(j);\\n                ans.deleteCharAt(ans.length()-1);\\n            }\\n        }\\n        else{\\n            char ch=pat.charAt(i-1);\\n            int ansch=ans.charAt(i-1)-\\'0\\';\\n            if(ch==\\'I\\'){\\n                for(int j=ansch+1;j<=9;j++){\\n                    if(h.contains(j))continue;\\n                    h.add(j);\\n                    ans.append(j);\\n                    fun(pat,ans,i+1,h);\\n                    h.remove(j);\\n                    ans.deleteCharAt(ans.length()-1);\\n                }\\n            }\\n            else{\\n                for(int j=1;j<ansch;j++){\\n                    if(h.contains(j))continue;\\n                    ans.append(j);\\n                    h.add(j);\\n                    fun(pat,ans,i+1,h);\\n                    h.remove(j);\\n                    ans.deleteCharAt(ans.length()-1);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422413,
                "title": "python-backtracking-dfs",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0x3f3f3f3f\\n    def smallestNumber(self, pattern: str) -> str:\\n        def dfs(cur, pattern, choice):\\n            if pattern == \"\":\\n                self.ans = min(self.ans, cur)\\n                return\\n            for i, nxt in enumerate(choice):\\n                if pattern[0] == \\'I\\' and nxt > cur % 10:\\n                    dfs(cur * 10 + nxt, pattern[1:], choice[:i] + choice[i + 1:])\\n                if pattern[0] == \\'D\\' and nxt < cur % 10:\\n                    dfs(cur * 10 + nxt, pattern[1:], choice[:i] + choice[i + 1:])\\n        nums = [i for i in range(1, 10)]\\n        for i in range(1, 10):\\n            dfs(i, pattern, nums[:i - 1] + nums[i:])\\n        return str(self.ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0x3f3f3f3f\\n    def smallestNumber(self, pattern: str) -> str:\\n        def dfs(cur, pattern, choice):\\n            if pattern == \"\":\\n                self.ans = min(self.ans, cur)\\n                return\\n            for i, nxt in enumerate(choice):\\n                if pattern[0] == \\'I\\' and nxt > cur % 10:\\n                    dfs(cur * 10 + nxt, pattern[1:], choice[:i] + choice[i + 1:])\\n                if pattern[0] == \\'D\\' and nxt < cur % 10:\\n                    dfs(cur * 10 + nxt, pattern[1:], choice[:i] + choice[i + 1:])\\n        nums = [i for i in range(1, 10)]\\n        for i in range(1, 10):\\n            dfs(i, pattern, nums[:i - 1] + nums[i:])\\n        return str(self.ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422408,
                "title": "python-3-stack-solution",
                "content": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        stack = []\\n        num = 1\\n        ans = \"\"\\n        for i in range(len(pattern)):\\n            if(pattern[i]==\"D\"):\\n                stack.append(num)\\n                num+=1\\n            else:\\n                stack.append(num)\\n                num+=1\\n                while(stack):\\n                    k = stack.pop()\\n                    ans+= str(k)\\n        stack.append(num)\\n        while(stack):\\n            k = stack.pop()\\n            ans+= str(k)\\n            \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        stack = []\\n        num = 1\\n        ans = \"\"\\n        for i in range(len(pattern)):\\n            if(pattern[i]==\"D\"):\\n                stack.append(num)\\n                num+=1\\n            else:\\n                stack.append(num)\\n                num+=1\\n                while(stack):\\n                    k = stack.pop()\\n                    ans+= str(k)\\n        stack.append(num)\\n        while(stack):\\n            k = stack.pop()\\n            ans+= str(k)\\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2422399,
                "title": "c-using-stack",
                "content": "```\\n  int n=p.size();\\n        stack<int>st;\\n        string res=\"\";\\n        for(int i=0;i<=n;i++){\\n            st.push(i+1);\\n            \\n            if(p[i]==\\'I\\' or i==n){\\n                while(st.empty()==false){\\n                    res+=to_string(st.top());\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "```\\n  int n=p.size();\\n        stack<int>st;\\n        string res=\"\";\\n        for(int i=0;i<=n;i++){\\n            st.push(i+1);\\n            \\n            if(p[i]==\\'I\\' or i==n){\\n                while(st.empty()==false){\\n                    res+=to_string(st.top());\\n                    st.pop();\\n                }\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 2422392,
                "title": "java-dfs-straight-forward",
                "content": "```\\nclass Solution {\\n    String s;\\n    public String smallestNumber(String pattern) {\\n        dfs(pattern.toCharArray(), 0, 0, new ArrayList<>());\\n        return s;\\n    }\\n    public boolean dfs(char[] arr, int index, int num, ArrayList<Integer> list){\\n        if(list.size() == arr.length + 1){\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0; i < list.size(); i++){\\n                sb.append(list.get(i));\\n            }\\n            s = sb.toString();\\n            return true;\\n        }\\n        if(index > 0){\\n            char prev = arr[index-1];\\n            if(prev == \\'I\\'){\\n                for(int i = num+1; i <= 9; i++){\\n                    if(list.contains(i)){\\n                        continue;\\n                    }\\n                    list.add(i);\\n                    if(dfs(arr, index+1, i, list)){\\n                        return true;\\n                    }\\n                    list.remove(list.size()-1);\\n                }\\n            }else{\\n                for(int i = 1; i < num; i++){\\n                    if(list.contains(i)){\\n                        continue;\\n                    }\\n                    list.add(i);\\n                    if(dfs(arr, index+1, i, list)){\\n                        return true;\\n                    }\\n                    list.remove(list.size()-1);\\n                }\\n            }\\n        }else{ //first element \\n            for(int i = 1; i <= 9; i++){\\n                if(list.contains(i)){\\n                    continue;\\n                }\\n                list.add(i);\\n                if(dfs(arr, index+1, i, list)){\\n                    return true;\\n                }\\n                list.remove(list.size()-1);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    String s;\\n    public String smallestNumber(String pattern) {\\n        dfs(pattern.toCharArray(), 0, 0, new ArrayList<>());\\n        return s;\\n    }\\n    public boolean dfs(char[] arr, int index, int num, ArrayList<Integer> list){\\n        if(list.size() == arr.length + 1){\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0; i < list.size(); i++){\\n                sb.append(list.get(i));\\n            }\\n            s = sb.toString();\\n            return true;\\n        }\\n        if(index > 0){\\n            char prev = arr[index-1];\\n            if(prev == \\'I\\'){\\n                for(int i = num+1; i <= 9; i++){\\n                    if(list.contains(i)){\\n                        continue;\\n                    }\\n                    list.add(i);\\n                    if(dfs(arr, index+1, i, list)){\\n                        return true;\\n                    }\\n                    list.remove(list.size()-1);\\n                }\\n            }else{\\n                for(int i = 1; i < num; i++){\\n                    if(list.contains(i)){\\n                        continue;\\n                    }\\n                    list.add(i);\\n                    if(dfs(arr, index+1, i, list)){\\n                        return true;\\n                    }\\n                    list.remove(list.size()-1);\\n                }\\n            }\\n        }else{ //first element \\n            for(int i = 1; i <= 9; i++){\\n                if(list.contains(i)){\\n                    continue;\\n                }\\n                list.add(i);\\n                if(dfs(arr, index+1, i, list)){\\n                    return true;\\n                }\\n                list.remove(list.size()-1);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422388,
                "title": "clean-solution-no-stack-o-n-2-0ms-beats-100",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring smallestNumber(string s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tfor(char c=\\'1\\'; c<=n+1+\\'0\\'; c++)\\n\\t\\t\\t\\tans+=c;\\n\\n\\t\\t\\tvector<int> temp(n,0);\\n\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\twhile(i+cnt<n && s[i+cnt]==\\'D\\')\\n\\t\\t\\t\\t\\tcnt++;\\n\\n\\t\\t\\t\\ttemp[i]=cnt;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=n-1; i>0; i--)\\n\\t\\t\\t\\tif(temp[i]<temp[i-1])\\n\\t\\t\\t\\t\\ttemp[i]=0;\\n\\n\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// reverse the string\\n\\t\\t\\t\\tint l=i,r=i+temp[i];\\n\\t\\t\\t\\twhile(l<r)\\n\\t\\t\\t\\t\\tswap(ans[l],ans[r]),l++,r--;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring smallestNumber(string s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tfor(char c=\\'1\\'; c<=n+1+\\'0\\'; c++)\\n\\t\\t\\t\\tans+=c;\\n\\n\\t\\t\\tvector<int> temp(n,0);\\n\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\tint cnt=0;\\n\\t\\t\\t\\twhile(i+cnt<n && s[i+cnt]==\\'D\\')\\n\\t\\t\\t\\t\\tcnt++;\\n\\n\\t\\t\\t\\ttemp[i]=cnt;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2422364,
                "title": "c-easy-simple-permutation-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isObey(string t,string p,int n)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(p[i]==\\'I\\')\\n            {\\n                if(t[i]>=t[i+1])\\n                    return false;\\n            }\\n            else\\n            {\\n                if(t[i]<=t[i+1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string smallestNumber(string pattern) \\n    {\\n        int n=pattern.size();\\n        string res;\\n        char c=\\'1\\';\\n        string s;\\n        for(int i=0;i<=n;i++)\\n        {\\n            s+=c;\\n            c++;\\n        }\\n        string ans;\\n        string perm=s;\\n        do\\n        {\\n            if(isObey(perm,pattern,n))\\n            {\\n              return perm;\\n            }\\n            next_permutation(perm.begin(),perm.end());\\n            \\n            \\n        }while(perm!=s);\\n\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t``",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool isObey(string t,string p,int n)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(p[i]==\\'I\\')\\n            {\\n                if(t[i]>=t[i+1])\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2422276,
                "title": "c-bruteforce",
                "content": "Here I present to you the brute force approach which searches through all the possible permutations, it will take `O((N+1)! * N)` time and `O(N)` space where `N` is the length of the pattern.\\n```\\nstring smallestNumber(string pattern) {\\n\\tint n = pattern.size();\\n\\tvector<int> v;\\n\\tfor(int i = 1 ; i <= n + 1 ; i++) v.push_back(i);\\n\\tdo{\\n\\t\\tstring cur;\\n\\t\\tfor(int i = 1 ; i <= n ; i++){\\n\\t\\t\\tif(v[i] > v[i - 1]) cur += \\'I\\';\\n\\t\\t\\telse cur += \\'D\\';\\n\\t\\t}\\n\\t\\tif(cur == pattern){\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i = 0 ; i <= n ; i++){\\n\\t\\t\\t\\tans += (char)(\\'0\\' + v[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}while(next_permutation(v.begin(), v.end()));\\n\\treturn \"\";\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring smallestNumber(string pattern) {\\n\\tint n = pattern.size();\\n\\tvector<int> v;\\n\\tfor(int i = 1 ; i <= n + 1 ; i++) v.push_back(i);\\n\\tdo{\\n\\t\\tstring cur;\\n\\t\\tfor(int i = 1 ; i <= n ; i++){\\n\\t\\t\\tif(v[i] > v[i - 1]) cur += \\'I\\';\\n\\t\\t\\telse cur += \\'D\\';\\n\\t\\t}\\n\\t\\tif(cur == pattern){\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i = 0 ; i <= n ; i++){\\n\\t\\t\\t\\tans += (char)(\\'0\\' + v[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}while(next_permutation(v.begin(), v.end()));\\n\\treturn \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422275,
                "title": "stack-python",
                "content": "The idea is simple. When we read I, we add from 1, next read I again, we add 2.\\nWhen we read D, we add its index to stack.\\nnow we have IIID. (1 2 3) stack = [3]\\nWe add next the last I for IIIDI, we have (1 2 3 _ 4)\\n\\tthen keep popping stack. Fill index  3 with 5 -> (1 2 3 5 4) until    empty the stack\\n\\nRead \\'DDD\\', after we have \\'IIDI\\', \\n->Stack = [5, 6, 7]\\nkeep pop stack and add one more than the last added value\\n-> 12354987\\n\\nWe are missing one, simply let pattern = pattern + pattern[-1] at the begining\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        pattern += pattern[-1]\\n        output = [0] * (len(pattern))\\n        start = 1\\n        stack = []\\n        for i, p in enumerate(pattern):\\n            if p == \\'I\\':\\n                output[i] = start\\n                start += 1\\n                while stack:\\n                    popped_idx = stack.pop()\\n                    output[popped_idx] = start\\n                    start += 1\\n            else:\\n                stack.append(i)\\n        while stack:\\n            popped_idx = stack.pop()\\n            output[popped_idx] = start\\n            start += 1\\n        return \\'\\'.join([str(i) for i in output])\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        pattern += pattern[-1]\\n        output = [0] * (len(pattern))\\n        start = 1\\n        stack = []\\n        for i, p in enumerate(pattern):\\n            if p == \\'I\\':\\n                output[i] = start\\n                start += 1\\n                while stack:\\n                    popped_idx = stack.pop()\\n                    output[popped_idx] = start\\n                    start += 1\\n            else:\\n                stack.append(i)\\n        while stack:\\n            popped_idx = stack.pop()\\n            output[popped_idx] = start\\n            start += 1\\n        return \\'\\'.join([str(i) for i in output])\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422252,
                "title": "construct-smallest-number-from-di-string-stack",
                "content": "```\\n string smallestNumber(string s) {\\n        string ss=\"\";\\n        stack<string> st;\\n        int j=1;\\n        for(int i=0;i<s.size();i++){\\n           if(s[i] ==\\'D\\'){\\n               st.push(to_string(j));\\n               j++;\\n           }\\n           else{\\n               st.push(to_string(j));\\n               j++;\\n               while(!st.empty()){\\n                   ss+=st.top();\\n                   st.pop();\\n               }\\n           }\\n       }\\n       st.push(to_string(j));\\n       while(!st.empty()){\\n           ss+=st.top();\\n           st.pop();\\n       }\\n         return ss;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n string smallestNumber(string s) {\\n        string ss=\"\";\\n        stack<string> st;\\n        int j=1;\\n        for(int i=0;i<s.size();i++){\\n           if(s[i] ==\\'D\\'){\\n               st.push(to_string(j));\\n               j++;\\n           }\\n           else{\\n               st.push(to_string(j));\\n               j++;\\n               while(!st.empty()){\\n                   ss+=st.top();\\n                   st.pop();\\n               }\\n           }\\n       }\\n       st.push(to_string(j));\\n       while(!st.empty()){\\n           ss+=st.top();\\n           st.pop();\\n       }\\n         return ss;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422204,
                "title": "simple-logic-100-faster-no-backtracking-no-stack-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        vector<int> c(p.size()+1,0);\\n        int x=0;\\n        for(int i=0;i<p.size();i++){\\n            if(p[i]==\\'I\\')\\n                break;\\n            else\\n                x++;\\n        }\\n        c[0]=x;\\n        // int j=1;\\n        for(int i=1;i<=p.size();i++){\\n            if(p[i-1]==\\'D\\'){\\n                continue;\\n            }\\n            \\n            int x=0;\\n        for(int j=i;j<p.size();j++){\\n            if(p[j]==\\'I\\')\\n                break;\\n            else\\n                x++;\\n        }\\n            c[i]=x;\\n        }\\n        x=1+c[0];\\n        string ans=\"\";\\n        \\n        ans+=\\'0\\'+x;\\n        for(int j=1;j<=c[0];j++){\\n                ans+=\\'0\\'+x-j;\\n            }\\n        x++;\\n        for(int i=1;i<c.size();i++){\\n            if(p[i-1]==\\'D\\'){\\n                continue;\\n            }\\n            if(c[i]==0){\\n                ans+=\\'0\\'+x;\\n                x++;\\n                continue;\\n            }\\n            x+=c[i];\\n            ans+=\\'0\\'+x;\\n            for(int j=1;j<=c[i];j++){\\n                ans+=\\'0\\'+x-j;\\n            }\\n                x++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string p) {\\n        vector<int> c(p.size()+1,0);\\n        int x=0;\\n        for(int i=0;i<p.size();i++){\\n            if(p[i]==\\'I\\')\\n                break;\\n            else\\n                x++;\\n        }\\n        c[0]=x;\\n        // int j=1;\\n        for(int i=1;i<=p.size();i++){\\n            if(p[i-1]==\\'D\\'){\\n                continue;\\n            }\\n            \\n            int x=0;\\n        for(int j=i;j<p.size();j++){\\n            if(p[j]==\\'I\\')\\n                break;\\n            else\\n                x++;\\n        }\\n            c[i]=x;\\n        }\\n        x=1+c[0];\\n        string ans=\"\";\\n        \\n        ans+=\\'0\\'+x;\\n        for(int j=1;j<=c[0];j++){\\n                ans+=\\'0\\'+x-j;\\n            }\\n        x++;\\n        for(int i=1;i<c.size();i++){\\n            if(p[i-1]==\\'D\\'){\\n                continue;\\n            }\\n            if(c[i]==0){\\n                ans+=\\'0\\'+x;\\n                x++;\\n                continue;\\n            }\\n            x+=c[i];\\n            ans+=\\'0\\'+x;\\n            for(int j=1;j<=c[i];j++){\\n                ans+=\\'0\\'+x-j;\\n            }\\n                x++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422199,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        pattern += \"I\";\\n        char[] res = new char[pattern.length()];\\n        char num = \\'1\\';\\n        for(int i=0; i<pattern.length(); i++) {\\n            if(pattern.charAt(i) == \\'I\\') {\\n                res[i] = num++;\\n            } else {\\n                int start = i;\\n                while(i<pattern.length() && pattern.charAt(i) == \\'D\\') i++;\\n                for(int j=i; j>=start; j--) {\\n                    res[j] = num++;\\n                }\\n            }\\n        }\\n        \\n        return new String(res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        pattern += \"I\";\\n        char[] res = new char[pattern.length()];\\n        char num = \\'1\\';\\n        for(int i=0; i<pattern.length(); i++) {\\n            if(pattern.charAt(i) == \\'I\\') {\\n                res[i] = num++;\\n            } else {\\n                int start = i;\\n                while(i<pattern.length() && pattern.charAt(i) == \\'D\\') i++;\\n                for(int j=i; j>=start; j--) {\\n                    res[j] = num++;\\n                }\\n            }\\n        }\\n        \\n        return new String(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422198,
                "title": "c-simple-backtracking-easy",
                "content": "\\tbool fun(int ind,map<int,int> mp,string temp,string &ans,string &pattern)\\n    {\\n        if(ind==pattern.size())                                      // when index reaches size of pattern then temp will\\n        {                                                            // contain the answer and we will return true\\n            ans = temp;\\n            return true;\\n        }\\n        \\n        for(int i=1;i<=9;i++)\\n        {\\n                int last = temp[temp.size()-1]-\\'0\\';                                            // finding last element which is added in temp string\\n                char c = i+\\'0\\';\\n                string t = temp+c;                                                             //adding current integer in t string \\n                    \\n                if(pattern[ind]==\\'I\\' && last<i &&(mp.find(i)==mp.end() || mp[i]==0))           // when element found is \\'I\\'\\n                {\\n                    mp[i]++;                                                                  // updating the map so that this integer will not be used anymore\\n                    \\n                    if( fun(ind+1,mp,t,ans,pattern) )\\n                        return true;\\n                    \\n                    mp[i]--;                                                                  // again decrementing the count to zero so that it can be used later \\n                }\\n                else if(pattern[ind]==\\'D\\' && last>i && (mp.find(i)==mp.end() || mp[i]==0) )    // when element found is \\'D\\'\\n                {\\n                    mp[i]++;\\n                    \\n                    if( fun(ind+1,mp,t,ans,pattern) )\\n                        return true;\\n                    \\n                    mp[i]--;\\n                }   \\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    string smallestNumber(string pattern) {\\n        \\n        string ans;\\n        map<int,int> mp;                                            // map is used for checking if given integer is available to use or already used\\n        \\n        for(int i=1;i<=9;i++)\\n        {\\n            string temp;\\n            temp += (i+\\'0\\');                                        // we are adding element one by one and passing it to fun \\n            mp[i]++;                             \\n            \\n            if(fun(0,mp,temp,ans,pattern)                           // answer string size is n+1 so we are passing index = 0\\n                return ans;                   \\n          \\n            mp[i]--;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "\\tbool fun(int ind,map<int,int> mp,string temp,string &ans,string &pattern)\\n    {\\n        if(ind==pattern.size())                                      // when index reaches size of pattern then temp will\\n        {                                                            // contain the answer and we will return true\\n            ans = temp;\\n            return true;\\n        }\\n        \\n        for(int i=1;i<=9;i++)\\n        {\\n                int last = temp[temp.size()-1]-\\'0\\';                                            // finding last element which is added in temp string\\n                char c = i+\\'0\\';\\n                string t = temp+c;                                                             //adding current integer in t string \\n                    \\n                if(pattern[ind]==\\'I\\' && last<i &&(mp.find(i)==mp.end() || mp[i]==0))           // when element found is \\'I\\'\\n                {\\n                    mp[i]++;                                                                  // updating the map so that this integer will not be used anymore\\n                    \\n                    if( fun(ind+1,mp,t,ans,pattern) )\\n                        return true;\\n                    \\n                    mp[i]--;                                                                  // again decrementing the count to zero so that it can be used later \\n                }\\n                else if(pattern[ind]==\\'D\\' && last>i && (mp.find(i)==mp.end() || mp[i]==0) )    // when element found is \\'D\\'\\n                {\\n                    mp[i]++;\\n                    \\n                    if( fun(ind+1,mp,t,ans,pattern) )\\n                        return true;\\n                    \\n                    mp[i]--;\\n                }   \\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    string smallestNumber(string pattern) {\\n        \\n        string ans;\\n        map<int,int> mp;                                            // map is used for checking if given integer is available to use or already used\\n        \\n        for(int i=1;i<=9;i++)\\n        {\\n            string temp;\\n            temp += (i+\\'0\\');                                        // we are adding element one by one and passing it to fun \\n            mp[i]++;                             \\n            \\n            if(fun(0,mp,temp,ans,pattern)                           // answer string size is n+1 so we are passing index = 0\\n                return ans;                   \\n          \\n            mp[i]--;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2422175,
                "title": "python-backtracking-with-bitmasks",
                "content": "```python\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        n = len(pattern)\\n        masks = {i : 1 << i for i in range(9)}\\n        \\n        def backtrack(available: int = (1 << 9) - 1, j: int = 0) -> bool:\\n            if j == n + 1:\\n                return True\\n            \\n            if j == 0:\\n                for i in range(1, 10):\\n                    mask = masks[i - 1]\\n                    if available & mask:\\n                        answer.append(str(i))\\n                        if backtrack(available ^ mask, j + 1):\\n                            return True\\n                        answer.pop()\\n            else:\\n                for i in range(1, 10):\\n                    mask = masks[i - 1]\\n                    if available & mask:\\n                        if (pattern[j - 1] == \"I\" and str(i) > answer[-1]) or (pattern[j - 1] == \"D\" and str(i) < answer[-1]):\\n                            answer.append(str(i))\\n                            if backtrack(available ^ mask, j + 1):\\n                                return True\\n                            answer.pop()\\n        \\n        answer = []\\n        backtrack()\\n        return \"\".join(answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        n = len(pattern)\\n        masks = {i : 1 << i for i in range(9)}\\n        \\n        def backtrack(available: int = (1 << 9) - 1, j: int = 0) -> bool:\\n            if j == n + 1:\\n                return True\\n            \\n            if j == 0:\\n                for i in range(1, 10):\\n                    mask = masks[i - 1]\\n                    if available & mask:\\n                        answer.append(str(i))\\n                        if backtrack(available ^ mask, j + 1):\\n                            return True\\n                        answer.pop()\\n            else:\\n                for i in range(1, 10):\\n                    mask = masks[i - 1]\\n                    if available & mask:\\n                        if (pattern[j - 1] == \"I\" and str(i) > answer[-1]) or (pattern[j - 1] == \"D\" and str(i) < answer[-1]):\\n                            answer.append(str(i))\\n                            if backtrack(available ^ mask, j + 1):\\n                                return True\\n                            answer.pop()\\n        \\n        answer = []\\n        backtrack()\\n        return \"\".join(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422114,
                "title": "easy-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    bool visited[256];\\n    void solve(string local, string pattern, int idx){\\n        int length = pattern.length();\\n        if(local.length() == length+1 and ans ==\"\"){\\n            ans = local;\\n            return;\\n        }\\n        if(pattern[idx] == \\'I\\'){\\n            for(char c = local.back(); c<=\\'9\\'; c++){\\n                if(visited[c]) continue;\\n                visited[c] = true;\\n                solve(local + c, pattern, idx+1);\\n                visited[c] = false;\\n            }\\n        }\\n        else{\\n           for(char c = local.back(); c>=\\'1\\'; c--){\\n                if(visited[c]) continue;\\n                visited[c] = true;\\n                solve(local + c, pattern, idx+1);\\n                visited[c] = false;\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        int length = pattern.length();\\n        memset(visited, false, sizeof(visited));\\n        string local;\\n        for(char c = \\'1\\' ; c<= \\'9\\'; c++){\\n            local += c;\\n            visited[c] = true;\\n            solve(local, pattern, 0);\\n            visited[c] = false;\\n            local.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    bool visited[256];\\n    void solve(string local, string pattern, int idx){\\n        int length = pattern.length();\\n        if(local.length() == length+1 and ans ==\"\"){\\n            ans = local;\\n            return;\\n        }\\n        if(pattern[idx] == \\'I\\'){\\n            for(char c = local.back(); c<=\\'9\\'; c++){\\n                if(visited[c]) continue;\\n                visited[c] = true;\\n                solve(local + c, pattern, idx+1);\\n                visited[c] = false;\\n            }\\n        }\\n        else{\\n           for(char c = local.back(); c>=\\'1\\'; c--){\\n                if(visited[c]) continue;\\n                visited[c] = true;\\n                solve(local + c, pattern, idx+1);\\n                visited[c] = false;\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        int length = pattern.length();\\n        memset(visited, false, sizeof(visited));\\n        string local;\\n        for(char c = \\'1\\' ; c<= \\'9\\'; c++){\\n            local += c;\\n            visited[c] = true;\\n            solve(local, pattern, 0);\\n            visited[c] = false;\\n            local.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094778,
                "title": "python-counting-o-n-time-o-1-space",
                "content": "# Intuition\\nIt is optimal to choose the smallest numbers first, ideally starting from 1.\\n\\n# Approach\\nIf we see `I` just bump the current min number available `cur`. If we see `D` count them as `d` until we see next `I` or the end of string, then we fill the previous `d` positions with `cur + d, cur + d - 1, ... cur + 1`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        res = [None] * (len(pattern) + 1)\\n        # lo, cnt = 1\\n        # for i, c in enumerate(res):\\n        #     if c == pattern[i - cnt]:\\n        #         cnt += 1\\n        #     else:\\n        #         if pattern[i - cnt] == \"D\":\\n        #             hi = lo = lo + cnt\\n        #             while hi - cnt < lo:\\n        #                 res[i - cnt] = hi - cnt\\n        #                 cnt -= 1\\n        #         else:\\n        #             lo += cnt\\n        #             while bla:\\n        #                 res[i + cnt] = lo + cnt\\n        #         cnt = 1\\n        # else:\\n        #     pass\\n        # res = \"\".join(res)\\n        cur, d = 1, 0\\n        for i, c in enumerate(pattern):\\n            if c == \"I\":\\n                nxt = cur + d + 1\\n                while d:\\n                    res[i - d] = cur + d\\n                    d -= 1\\n                res[i], cur = cur, nxt\\n            else:\\n                d += 1\\n        i += 1\\n        while d >= 0:\\n            res[i - d] = cur + d\\n            d -= 1\\n        res = \"\".join(str(i) for i in res)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        res = [None] * (len(pattern) + 1)\\n        # lo, cnt = 1\\n        # for i, c in enumerate(res):\\n        #     if c == pattern[i - cnt]:\\n        #         cnt += 1\\n        #     else:\\n        #         if pattern[i - cnt] == \"D\":\\n        #             hi = lo = lo + cnt\\n        #             while hi - cnt < lo:\\n        #                 res[i - cnt] = hi - cnt\\n        #                 cnt -= 1\\n        #         else:\\n        #             lo += cnt\\n        #             while bla:\\n        #                 res[i + cnt] = lo + cnt\\n        #         cnt = 1\\n        # else:\\n        #     pass\\n        # res = \"\".join(res)\\n        cur, d = 1, 0\\n        for i, c in enumerate(pattern):\\n            if c == \"I\":\\n                nxt = cur + d + 1\\n                while d:\\n                    res[i - d] = cur + d\\n                    d -= 1\\n                res[i], cur = cur, nxt\\n            else:\\n                d += 1\\n        i += 1\\n        while d >= 0:\\n            res[i - d] = cur + d\\n            d -= 1\\n        res = \"\".join(str(i) for i in res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041574,
                "title": "java-concise-stack-solution-with-proper-and-detailed-intuition",
                "content": "# Intuition\\n  Consider this example ---> \"III\"\\n  In the above example simply we want our answer to be in the increasing order right?\\n  Now Consider this example ---> \"DDD\"\\n  In the above example simply we want our answer to be in the descending order right?\\n  So, by concluding the above two examples can I see some reversal type of pattern?\\n  It means i will keep pushing the numbers in the stack an as soon as I encounter \\'I\\' then i will keep poping the numbers from the stack until the stack is not empty because this is what we need.\\n  \\nConsider this example ---> \"IIIDIDDD\"\\nch=\\'I\\'  i=1    stack=1(pop)   ans=\"1\"\\nch=\\'I\\'  i=2    stack=2(pop)   ans=\"12\"\\nch=\\'I\\'  i=3    stack=3(pop)   ans=\"123\"\\nch=\\'D\\'  i=4    stack=4        ans=\"123\"\\nch=\\'I\\'  i=5    stack=5,4(pop) ans=\"12354\"\\nch=\\'D\\'  i=6    stack=6        ans=\"12354\"\\nch=\\'D\\'  i=7    stack=7,6      ans=\"12354\"\\nch=\\'D\\'  i=8    stack=8,7,6    ans=\"12354\"  \\n-      i=9     stack=9,8,7,6  ans=\"123549876\\n\\nIn the end we will return ans.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        Stack<Integer>stack = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0;i<=pattern.length();i++){\\n            stack.push(i+1);\\n            if(i==pattern.length() || pattern.charAt(i)==\\'I\\'){\\n                while(!stack.isEmpty()) ans.append(String.valueOf(stack.pop()));\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        Stack<Integer>stack = new Stack<>();\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=0;i<=pattern.length();i++){\\n            stack.push(i+1);\\n            if(i==pattern.length() || pattern.charAt(i)==\\'I\\'){\\n                while(!stack.isEmpty()) ans.append(String.valueOf(stack.pop()));\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028698,
                "title": "linear-solution-using-stack",
                "content": "Video Solution ->(Hindi)\\n\\n https://youtu.be/GOCbsY7Arw4?si=QzIFjjxXwbpNSMJE\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string s) {\\n        string ans;\\n        stack<int> st;\\n        int n=1;\\n        for(auto it:s){\\n            if(it==\\'D\\'){\\n                st.push(n);\\n                n++;\\n            }\\n            else{\\n                st.push(n);\\n                n++;\\n                while(st.size()>0){\\n                    ans+=to_string(st.top());\\n                    st.pop();\\n                }\\n            }\\n        }\\n        st.push(n);\\n        while(st.size()>0){\\n                ans+=to_string(st.top());\\n                st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string s) {\\n        string ans;\\n        stack<int> st;\\n        int n=1;\\n        for(auto it:s){\\n            if(it==\\'D\\'){\\n                st.push(n);\\n                n++;\\n            }\\n            else{\\n                st.push(n);\\n                n++;\\n                while(st.size()>0){\\n                    ans+=to_string(st.top());\\n                    st.pop();\\n                }\\n            }\\n        }\\n        st.push(n);\\n        while(st.size()>0){\\n                ans+=to_string(st.top());\\n                st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024946,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int min = 1;\\n        int pos_I = 0;\\n        List<Integer> list = new ArrayList<>();\\n        if(pattern.charAt(0) == \\'I\\'){\\n            list.add(1);\\n            list.add(2);\\n            min = 3;\\n            pos_I = 1;\\n        }else{\\n            list.add(2);\\n            list.add(1);\\n            min = 3;\\n            pos_I = 0;\\n        }       \\n        for(int i=1; i<pattern.length(); i++){\\n            if(pattern.charAt(i) == \\'I\\'){\\n                list.add(min);\\n                min++;\\n                pos_I = i+1;\\n            }else{\\n                list.add(list.get(i));\\n                for(int j=pos_I; j<=i; j++){\\n                    list.set(j,list.get(j)+1);\\n                }\\n                min++;\\n            }\\n        } \\n        String res = \"\";\\n        for(int i=0; i<list.size(); i++){\\n            res += list.get(i);\\n        }\\n        return res;  \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        int min = 1;\\n        int pos_I = 0;\\n        List<Integer> list = new ArrayList<>();\\n        if(pattern.charAt(0) == \\'I\\'){\\n            list.add(1);\\n            list.add(2);\\n            min = 3;\\n            pos_I = 1;\\n        }else{\\n            list.add(2);\\n            list.add(1);\\n            min = 3;\\n            pos_I = 0;\\n        }       \\n        for(int i=1; i<pattern.length(); i++){\\n            if(pattern.charAt(i) == \\'I\\'){\\n                list.add(min);\\n                min++;\\n                pos_I = i+1;\\n            }else{\\n                list.add(list.get(i));\\n                for(int j=pos_I; j<=i; j++){\\n                    list.set(j,list.get(j)+1);\\n                }\\n                min++;\\n            }\\n        } \\n        String res = \"\";\\n        for(int i=0; i<list.size(); i++){\\n            res += list.get(i);\\n        }\\n        return res;  \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021719,
                "title": "simple-backtrack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string ans=\"999999999\";\\n    unordered_set<int>st;\\n    void find(string pattern,int i,string temp)\\n    {\\n        if(i==pattern.size())\\n        {\\n            if(temp.size()==pattern.size() && stoi(temp)<stoi(ans))\\n            {\\n                ans=temp;\\n            }\\n        \\n        return;\\n        }\\n\\n        for(char x=\\'1\\';x<=\\'9\\';x++)\\n        {\\n            if(i==0)\\n            {   st.insert(x);\\n                find(pattern,i+1,temp+x);\\n                st.erase(x);\\n            }\\n            else\\n            {\\n                if( st.find(x)!=st.end() || pattern[i-1]==\\'D\\' && (temp[i-1]==\\'1\\' || x>=temp[i-1]) || pattern[i-1]==\\'I\\' && (temp[i-1]==\\'9\\' || x<=temp[i-1]) )\\n                continue;\\n\\n                else\\n                { st.insert(x);\\n                find(pattern,i+1,temp+x);\\n                st.erase(x);\\n                }\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        string temp=\"\";\\n        find(pattern+\\'D\\',0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans=\"999999999\";\\n    unordered_set<int>st;\\n    void find(string pattern,int i,string temp)\\n    {\\n        if(i==pattern.size())\\n        {\\n            if(temp.size()==pattern.size() && stoi(temp)<stoi(ans))\\n            {\\n                ans=temp;\\n            }\\n        \\n        return;\\n        }\\n\\n        for(char x=\\'1\\';x<=\\'9\\';x++)\\n        {\\n            if(i==0)\\n            {   st.insert(x);\\n                find(pattern,i+1,temp+x);\\n                st.erase(x);\\n            }\\n            else\\n            {\\n                if( st.find(x)!=st.end() || pattern[i-1]==\\'D\\' && (temp[i-1]==\\'1\\' || x>=temp[i-1]) || pattern[i-1]==\\'I\\' && (temp[i-1]==\\'9\\' || x<=temp[i-1]) )\\n                continue;\\n\\n                else\\n                { st.insert(x);\\n                find(pattern,i+1,temp+x);\\n                st.erase(x);\\n                }\\n            }\\n        }\\n    }\\n    string smallestNumber(string pattern) {\\n        string temp=\"\";\\n        find(pattern+\\'D\\',0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007292,
                "title": "simple-java-iterative-solution",
                "content": "# Intuition\\nsetup an array with values from 1 to n, where n is size of the pattern string.\\ncount the number of continuous \\'D\\' char and then reverse the array segment from last \\'D\\' index (in contunious \\'D\\') with last encontered index of I \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n            // Initialize default minimum ans\\n\\t        int []ans = new int[pattern.length()+1];\\n\\t        for(int i=1;i<=ans.length;i++)\\n\\t            ans[i-1] = i;\\n\\n\\t        char[] pat = pattern.toCharArray();\\n\\t        int j=0; boolean dCame=false;\\n\\t        int i=0;\\n\\n            //Iterate over pattern string\\n\\t        while(i<pattern.length()){\\n\\t            char ch = pat[i];\\n\\t            j=i;\\n                //checking for continuous \\'D\\' char\\n\\t            while(ch==\\'D\\' && j<pattern.length()){\\n\\t                dCame = true;\\n\\t                j++;\\n\\t                if(j<pattern.length())\\n\\t                \\tch = pat[j];\\n\\t            }\\n\\t            if(dCame){\\n\\t                dCame = false;\\n\\t                reverse(i,j,ans);\\n\\t                i=j;\\n\\t            }else{\\n\\t                i++;\\n\\t            }\\n\\n\\t        }\\n\\t        StringBuilder sb = new StringBuilder();\\n\\t        for(int n: ans)\\n\\t            sb.append(n);\\n\\t        return sb.toString();       \\n\\t    }\\n\\n    public void reverse(int i, int j, int[]ans){\\n        while(i<j){\\n            int temp = ans[i];\\n            ans[i]=ans[j];\\n            ans[j]=temp;\\n            i++;j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n            // Initialize default minimum ans\\n\\t        int []ans = new int[pattern.length()+1];\\n\\t        for(int i=1;i<=ans.length;i++)\\n\\t            ans[i-1] = i;\\n\\n\\t        char[] pat = pattern.toCharArray();\\n\\t        int j=0; boolean dCame=false;\\n\\t        int i=0;\\n\\n            //Iterate over pattern string\\n\\t        while(i<pattern.length()){\\n\\t            char ch = pat[i];\\n\\t            j=i;\\n                //checking for continuous \\'D\\' char\\n\\t            while(ch==\\'D\\' && j<pattern.length()){\\n\\t                dCame = true;\\n\\t                j++;\\n\\t                if(j<pattern.length())\\n\\t                \\tch = pat[j];\\n\\t            }\\n\\t            if(dCame){\\n\\t                dCame = false;\\n\\t                reverse(i,j,ans);\\n\\t                i=j;\\n\\t            }else{\\n\\t                i++;\\n\\t            }\\n\\n\\t        }\\n\\t        StringBuilder sb = new StringBuilder();\\n\\t        for(int n: ans)\\n\\t            sb.append(n);\\n\\t        return sb.toString();       \\n\\t    }\\n\\n    public void reverse(int i, int j, int[]ans){\\n        while(i<j){\\n            int temp = ans[i];\\n            ans[i]=ans[j];\\n            ans[j]=temp;\\n            i++;j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003942,
                "title": "c-easy-solution-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string uttar;\\n    bool solve(string &pattern,string &ans,int index,vector<int>&visited){\\n         if(index>=pattern.length()){\\n             if(ans.length()==pattern.length()+1){\\n                 return true;\\n             }\\n             return false;\\n         }\\n         if(pattern[index]==\\'I\\'){\\n             int value=ans[index]-\\'0\\';\\n             for(int i=value+1;i<=9;i++){\\n                 if(!visited[i]){\\n                      visited[i]=1;\\n                      ans+=to_string(i);\\n                      if(solve(pattern,ans,index+1,visited)){\\n                          return true;\\n                      }\\n                      visited[i]=0;\\n                      ans.pop_back();\\n                 }\\n             }\\n         }\\n         else if(pattern[index]==\\'D\\'){\\n            int value=ans[index]-\\'0\\';\\n            for(int i=1;i<=value-1;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans+=to_string(i);\\n                    if(solve(pattern,ans,index+1,visited)){\\n                        return true;\\n                    }\\n                    visited[i]=0;\\n                    ans.pop_back();\\n                }\\n            }\\n         }\\n         return false;\\n    }\\n    string smallestNumber(string pattern) {\\n        vector<int>visited(10,0);\\n        string ans=\"\";\\n        for(int i=1;i<=9;i++){\\n            ans+=to_string(i);\\n            visited[i]=1;\\n            if(solve(pattern,ans,0,visited)){\\n                return ans;\\n            }\\n            ans.pop_back();\\n            visited[i]=0;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string uttar;\\n    bool solve(string &pattern,string &ans,int index,vector<int>&visited){\\n         if(index>=pattern.length()){\\n             if(ans.length()==pattern.length()+1){\\n                 return true;\\n             }\\n             return false;\\n         }\\n         if(pattern[index]==\\'I\\'){\\n             int value=ans[index]-\\'0\\';\\n             for(int i=value+1;i<=9;i++){\\n                 if(!visited[i]){\\n                      visited[i]=1;\\n                      ans+=to_string(i);\\n                      if(solve(pattern,ans,index+1,visited)){\\n                          return true;\\n                      }\\n                      visited[i]=0;\\n                      ans.pop_back();\\n                 }\\n             }\\n         }\\n         else if(pattern[index]==\\'D\\'){\\n            int value=ans[index]-\\'0\\';\\n            for(int i=1;i<=value-1;i++){\\n                if(!visited[i]){\\n                    visited[i]=1;\\n                    ans+=to_string(i);\\n                    if(solve(pattern,ans,index+1,visited)){\\n                        return true;\\n                    }\\n                    visited[i]=0;\\n                    ans.pop_back();\\n                }\\n            }\\n         }\\n         return false;\\n    }\\n    string smallestNumber(string pattern) {\\n        vector<int>visited(10,0);\\n        string ans=\"\";\\n        for(int i=1;i<=9;i++){\\n            ans+=to_string(i);\\n            visited[i]=1;\\n            if(solve(pattern,ans,0,visited)){\\n                return ans;\\n            }\\n            ans.pop_back();\\n            visited[i]=0;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995272,
                "title": "java-0ms-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n\\n        int n = pattern.length();  // 1 <= pattern.length <= 8\\n        int[] numCounts = new int[58];  // char frequency counter; ASCII chars \\'1\\'--\\'9\\' are 49--57\\n        char[] num = new char[n + 1];  // what we\\'ll return (as a String)\\n        num[0] = 49;  // \\'1\\'\\n        ++numCounts[num[0]];\\n\\n        int idxIntoNum = 1;\\n\\n        for (char c : pattern.toCharArray()) {\\n            if (c == \\'D\\') {\\n                // repeat immediately previous number in `num`, then increment any duplicate numbers leftward incrementally\\n                num[idxIntoNum] = num[idxIntoNum - 1];\\n                ++numCounts[num[idxIntoNum]];\\n                for (int idx = idxIntoNum - 1; idx >= 0; --idx) {\\n                    if (numCounts[num[idx]] > 1) {\\n                        --numCounts[num[idx]];\\n                        ++num[idx];\\n                        ++numCounts[num[idx]];\\n                    }\\n                }\\n            } else {  // c == \\'I\\'\\n                // plug in lowest currently available number\\n                int digit = 49;\\n                for ( ; digit <= 57; ++digit) {\\n                    if (numCounts[digit] == 0) {\\n                        break;\\n                    }\\n                }\\n                num[idxIntoNum] = (char)digit;\\n                ++numCounts[digit];\\n            }\\n\\n            ++idxIntoNum;\\n        }\\n\\n        // convert `num` to a String\\n        return new String(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n\\n        int n = pattern.length();  // 1 <= pattern.length <= 8\\n        int[] numCounts = new int[58];  // char frequency counter; ASCII chars \\'1\\'--\\'9\\' are 49--57\\n        char[] num = new char[n + 1];  // what we\\'ll return (as a String)\\n        num[0] = 49;  // \\'1\\'\\n        ++numCounts[num[0]];\\n\\n        int idxIntoNum = 1;\\n\\n        for (char c : pattern.toCharArray()) {\\n            if (c == \\'D\\') {\\n                // repeat immediately previous number in `num`, then increment any duplicate numbers leftward incrementally\\n                num[idxIntoNum] = num[idxIntoNum - 1];\\n                ++numCounts[num[idxIntoNum]];\\n                for (int idx = idxIntoNum - 1; idx >= 0; --idx) {\\n                    if (numCounts[num[idx]] > 1) {\\n                        --numCounts[num[idx]];\\n                        ++num[idx];\\n                        ++numCounts[num[idx]];\\n                    }\\n                }\\n            } else {  // c == \\'I\\'\\n                // plug in lowest currently available number\\n                int digit = 49;\\n                for ( ; digit <= 57; ++digit) {\\n                    if (numCounts[digit] == 0) {\\n                        break;\\n                    }\\n                }\\n                num[idxIntoNum] = (char)digit;\\n                ++numCounts[digit];\\n            }\\n\\n            ++idxIntoNum;\\n        }\\n\\n        // convert `num` to a String\\n        return new String(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992706,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\tbool solve( int ind, string pat, string s, string &res, vector<bool> &vis ) {\\n        if( ind==pat.size() )\\n        {\\n            res = s ;\\n            return true ;\\n        }\\n        if( pat[ind]==\\'D\\' )\\n        {\\n            int val = s.back()-\\'0\\' ;\\n            for( int i=1 ; i<val ; i++ )\\n                if( !vis[i] )\\n                {\\n                    vis[i] = true ;\\n                    if( solve(ind+1,pat,s+to_string(i),res,vis) )\\n                        return true ;\\n                    vis[i] = false ;\\n                }\\n            return false ;\\n        }\\n        else\\n        {\\n            int val = s.back()-\\'0\\' ;\\n            for( int i=val+1 ; i<=9 ; i++ )\\n                if( !vis[i] )\\n                {\\n                    vis[i] = true ;\\n                    if( solve(ind+1,pat,s+to_string(i),res,vis) )\\n                        return true ;\\n                    vis[i] = false ;\\n                }\\n            return false ;\\n        }\\n    }\\n    string smallestNumber(string pat) {\\n        vector<bool> vis(10,0) ;\\n        for( int i=1 ; i<=9 ; i++ )\\n        {\\n            string res = \"\" ;\\n            vis[i] = true ;\\n            if( solve(0,pat,to_string(i),res,vis) )\\n                return res ;\\n            vis[i] = false ;\\n        }\\n        return \"\" ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\tbool solve( int ind, string pat, string s, string &res, vector<bool> &vis ) {\\n        if( ind==pat.size() )\\n        {\\n            res = s ;\\n            return true ;\\n        }\\n        if( pat[ind]==\\'D\\' )\\n        {\\n            int val = s.back()-\\'0\\' ;\\n            for( int i=1 ; i<val ; i++ )\\n                if( !vis[i] )\\n                {\\n                    vis[i] = true ;\\n                    if( solve(ind+1,pat,s+to_string(i),res,vis) )\\n                        return true ;\\n                    vis[i] = false ;\\n                }\\n            return false ;\\n        }\\n        else\\n        {\\n            int val = s.back()-\\'0\\' ;\\n            for( int i=val+1 ; i<=9 ; i++ )\\n                if( !vis[i] )\\n                {\\n                    vis[i] = true ;\\n                    if( solve(ind+1,pat,s+to_string(i),res,vis) )\\n                        return true ;\\n                    vis[i] = false ;\\n                }\\n            return false ;\\n        }\\n    }\\n    string smallestNumber(string pat) {\\n        vector<bool> vis(10,0) ;\\n        for( int i=1 ; i<=9 ; i++ )\\n        {\\n            string res = \"\" ;\\n            vis[i] = true ;\\n            if( solve(0,pat,to_string(i),res,vis) )\\n                return res ;\\n            vis[i] = false ;\\n        }\\n        return \"\" ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985419,
                "title": "java-easy-solution-beats-100",
                "content": "\\n# Approach\\nIn num array \\n 1. add 1 to n+1 number in sorting order\\n 2. if character is I than Ignore and goto next char because num is already sorted\\n 3. if character is D than count no of continuous D \\n 4. In order to satisfy num[i]>num[i+1]  reverse the num\\'s value from stating to end index of continuous D\\n \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    String ans=\"\";\\n    public String smallestNumber(String pattern) {\\n           int n=pattern.length();\\n      int num[]=new int [n+1];\\n      for(int i=0;i<num.length;i++)\\n      {\\n          num[i]=i+1;\\n      }\\n   \\n      for(int i=0;i<n;i++)\\n      {\\n          if(pattern.charAt(i)==\\'D\\')\\n          {\\n              int end=i;\\n              while(end<n && pattern.charAt(end)==\\'D\\')\\n              {\\n                  end++;\\n              }\\n              reverse(num,i,end);\\n              i=end;\\n          }\\n      }\\n     StringBuilder result = new StringBuilder();\\n        for (int x : num) {\\n            result.append(x);\\n        }\\n        \\n        return result.toString();\\n    }\\n    void reverse(int nums[],int l,int h)\\n    {\\n        while(l<h)\\n        {\\n            int tmp=nums[l];\\n            nums[l]=nums[h];\\n            nums[h]=tmp;\\n            h--;\\n            l++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String ans=\"\";\\n    public String smallestNumber(String pattern) {\\n           int n=pattern.length();\\n      int num[]=new int [n+1];\\n      for(int i=0;i<num.length;i++)\\n      {\\n          num[i]=i+1;\\n      }\\n   \\n      for(int i=0;i<n;i++)\\n      {\\n          if(pattern.charAt(i)==\\'D\\')\\n          {\\n              int end=i;\\n              while(end<n && pattern.charAt(end)==\\'D\\')\\n              {\\n                  end++;\\n              }\\n              reverse(num,i,end);\\n              i=end;\\n          }\\n      }\\n     StringBuilder result = new StringBuilder();\\n        for (int x : num) {\\n            result.append(x);\\n        }\\n        \\n        return result.toString();\\n    }\\n    void reverse(int nums[],int l,int h)\\n    {\\n        while(l<h)\\n        {\\n            int tmp=nums[l];\\n            nums[l]=nums[h];\\n            nums[h]=tmp;\\n            h--;\\n            l++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980141,
                "title": "reverse-the-substring-logic",
                "content": "# Intution\\n\\n    suppose if it is given like \\n    IIIIIIII\\n    then answer would be simple 123456789\\n\\n    but if we make a little change\\n    IIIDDIII\\n    then, we can reverse the substring => 123(654)789\\n\\n    so the trick is whatever the decreasing part is \\n    achieve it by reversing the substring of that part only \\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n    \\n        int n = pattern.length();\\n        int N = n+1;\\n\\n        string s = \"\";\\n        for(int i = 1; i <= N; i++){\\n            s += to_string(i);\\n        }\\n\\n        int i = 0; \\n\\n        while(i < n){            \\n            if(pattern[i] == \\'I\\'){\\n                i++;\\n            } else {\\n                \\n                int j = i;\\n                while(j < n && pattern[j] == \\'D\\'){\\n                    j++;\\n                }\\n                 \\n                reverse(s.begin() + i, s.begin() + j + 1);\\n                i = j;\\n\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n    \\n        int n = pattern.length();\\n        int N = n+1;\\n\\n        string s = \"\";\\n        for(int i = 1; i <= N; i++){\\n            s += to_string(i);\\n        }\\n\\n        int i = 0; \\n\\n        while(i < n){            \\n            if(pattern[i] == \\'I\\'){\\n                i++;\\n            } else {\\n                \\n                int j = i;\\n                while(j < n && pattern[j] == \\'D\\'){\\n                    j++;\\n                }\\n                 \\n                reverse(s.begin() + i, s.begin() + j + 1);\\n                i = j;\\n\\n            }\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977503,
                "title": "construct-smallest-number-from-di-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Iterate through the pattern, for each \"I\", increment and append the smallest available number; for \"D\", find the largest available number and append.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- BRUTE FORCE (Time Complexity: O(n^2), Space Complexity: O(n)):\\n\\nIterate through the pattern, for each \"I\", increment and append the smallest available number; for \"D\", find the largest available number and append. Repeat for each character.\\n\\n- OPTIMAL-:\\n\\nThe optimal approach for generating the smallest number from a given pattern employs a stack to efficiently manage the sequence. While iterating through the pattern, ascending numbers are pushed onto the stack. Whenever \"I\" or the end of the pattern is encountered, numbers are popped from the stack and appended to the result for the smallest possible sequence. This method eliminates the need for array reversal and ensures optimal number usage.  Time: O(n), Space: O(n).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\nstring smallestNumber(string pattern) {//easy to implement without using reverse or array.\\n    string result; // Initialize the string to store the result\\n    stack<int> s; // Initialize a stack to keep track of numbers\\n\\n    // Loop through each index (including an extra iteration for the end)\\n    for (int i = 0; i <= pattern.length(); i++) {\\n        s.push(i + 1); // Push the current number onto the stack\\n\\n        // If the end of the pattern is reached or \"I\" is encountered\\n        if (i == pattern.length() || pattern[i] == \\'I\\') {\\n            // Pop numbers from the stack and append to the result\\n            while (!s.empty()) {\\n                result += to_string(s.top()); // Convert the top of the stack to a string and add to result\\n                s.pop(); // Remove the element from the stack\\n            }\\n        }\\n    }\\n\\n    return result; // Return the final result string\\n}\\n};\\n\\n/*class Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size() + 1; // Calculate the length of the pattern plus 1\\n        vector<int> arr(n); // Create an array to store the numbers\\n\\n        // Step 1: Fill the array with initial values 1 to n\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = i + 1; // Initialize the array elements in increasing order\\n        }\\n\\n        // Step 2: Process the pattern and reverse portions of the array\\n        for (int i = 0; i < n; i++) {\\n            int temp = i; // Initialize a temporary index\\n\\n            // Find the end of a decreasing sequence in the pattern\\n            while (temp < n - 1 && pattern[temp] == \\'D\\') {\\n                temp++; // Move the temporary index forward\\n            }\\n\\n            // Reverse the portion of the array between indices i and temp\\n            reverse(arr.begin() + i, arr.begin() + temp + 1);\\n\\n            // Adjust the loop index if a decreasing sequence was encountered\\n            if (temp != i) {\\n                i = temp - 1; // Move the index back to the last element of the reversed sequence\\n            }\\n        }\\n\\n        // Step 3: Convert the array elements to strings and concatenate them\\n        string ans; // Initialize the resulting string\\n        for (int i = 0; i < n; i++) {\\n            ans += to_string(arr[i]); // Convert the array element to a string and append to ans\\n        }\\n\\n        // Step 4: Return the resulting string\\n        return ans; // Return the smallest number following the pattern\\n    }\\n};\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\nstring smallestNumber(string pattern) {//easy to implement without using reverse or array.\\n    string result; // Initialize the string to store the result\\n    stack<int> s; // Initialize a stack to keep track of numbers\\n\\n    // Loop through each index (including an extra iteration for the end)\\n    for (int i = 0; i <= pattern.length(); i++) {\\n        s.push(i + 1); // Push the current number onto the stack\\n\\n        // If the end of the pattern is reached or \"I\" is encountered\\n        if (i == pattern.length() || pattern[i] == \\'I\\') {\\n            // Pop numbers from the stack and append to the result\\n            while (!s.empty()) {\\n                result += to_string(s.top()); // Convert the top of the stack to a string and add to result\\n                s.pop(); // Remove the element from the stack\\n            }\\n        }\\n    }\\n\\n    return result; // Return the final result string\\n}\\n};\\n\\n/*class Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        int n = pattern.size() + 1; // Calculate the length of the pattern plus 1\\n        vector<int> arr(n); // Create an array to store the numbers\\n\\n        // Step 1: Fill the array with initial values 1 to n\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = i + 1; // Initialize the array elements in increasing order\\n        }\\n\\n        // Step 2: Process the pattern and reverse portions of the array\\n        for (int i = 0; i < n; i++) {\\n            int temp = i; // Initialize a temporary index\\n\\n            // Find the end of a decreasing sequence in the pattern\\n            while (temp < n - 1 && pattern[temp] == \\'D\\') {\\n                temp++; // Move the temporary index forward\\n            }\\n\\n            // Reverse the portion of the array between indices i and temp\\n            reverse(arr.begin() + i, arr.begin() + temp + 1);\\n\\n            // Adjust the loop index if a decreasing sequence was encountered\\n            if (temp != i) {\\n                i = temp - 1; // Move the index back to the last element of the reversed sequence\\n            }\\n        }\\n\\n        // Step 3: Convert the array elements to strings and concatenate them\\n        string ans; // Initialize the resulting string\\n        for (int i = 0; i < n; i++) {\\n            ans += to_string(arr[i]); // Convert the array element to a string and append to ans\\n        }\\n\\n        // Step 4: Return the resulting string\\n        return ans; // Return the smallest number following the pattern\\n    }\\n};\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971573,
                "title": "using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<char> s;\\n        int n = pattern.length();\\n        pattern += pattern[n-1];\\n        int k = \\'1\\';\\n        string ans = \"\";\\n        for (int i = 0; i < n; i++) {\\n            if (pattern[i] == \\'D\\') {\\n                s.push(k);\\n                k++;\\n            }\\n            else {\\n                ans.push_back(k);\\n                k++;\\n\\n                while (!s.empty()) {\\n                    ans.push_back(s.top());\\n                    s.pop();\\n                }\\n            }\\n        }\\n        \\n        while (!s.empty()) {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        stack<char> s;\\n        int n = pattern.length();\\n        pattern += pattern[n-1];\\n        int k = \\'1\\';\\n        string ans = \"\";\\n        for (int i = 0; i < n; i++) {\\n            if (pattern[i] == \\'D\\') {\\n                s.push(k);\\n                k++;\\n            }\\n            else {\\n                ans.push_back(k);\\n                k++;\\n\\n                while (!s.empty()) {\\n                    ans.push_back(s.top());\\n                    s.pop();\\n                }\\n            }\\n        }\\n        \\n        while (!s.empty()) {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963698,
                "title": "java-easy-solution-easy-approach-without-stack",
                "content": "# Intuition\\n Points to note \\n    1. III  -> 1234     if I means smallest number first\\n    2. DDD  -> 4321     if D means largest number first\\n    3. DID  -> 2143  [ _1__  ,21__ ,21_3 , 2143]\\n    So if we encounter first I  or if we reach end then fill counter then number it counter and increase counter value and previous values before encountering I or index > 0  fill by increasing the values from the previous index\\n\\n  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // Points to note \\n    //1. III  -> 1234     if I means smallest number first\\n    //2. DDD  -> 4321     if D means largest number first\\n    //3. DID  -> 2143  [ _1__  ,21__ ,21_3 , 2143]\\n    public String smallestNumber(String pattern) {\\n\\n        int len=pattern.length();\\n\\n        // make arr of size len + 1\\n        int arr[]=new int[len+1];\\n\\n\\n        int counter=1;\\n\\n        for(int i=0;i<=len;i++){\\n\\n//  if we reach end then loop in reverse and fill  \\n            if( i==len || pattern.charAt(i)==\\'I\\' ){  \\n                // make first I as 1 and loop in reverse dirn before I or 0 by filling by Increasing counter\\n                arr[i]=counter++;\\n                for(int j=i-1;j>=0 && pattern.charAt(j)!=\\'I\\';j--){\\n                         arr[j]=counter++;\\n\\n                }\\n\\n            }\\n\\n        } \\n\\n\\n// make answer from array\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<=len;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Points to note \\n    //1. III  -> 1234     if I means smallest number first\\n    //2. DDD  -> 4321     if D means largest number first\\n    //3. DID  -> 2143  [ _1__  ,21__ ,21_3 , 2143]\\n    public String smallestNumber(String pattern) {\\n\\n        int len=pattern.length();\\n\\n        // make arr of size len + 1\\n        int arr[]=new int[len+1];\\n\\n\\n        int counter=1;\\n\\n        for(int i=0;i<=len;i++){\\n\\n//  if we reach end then loop in reverse and fill  \\n            if( i==len || pattern.charAt(i)==\\'I\\' ){  \\n                // make first I as 1 and loop in reverse dirn before I or 0 by filling by Increasing counter\\n                arr[i]=counter++;\\n                for(int j=i-1;j>=0 && pattern.charAt(j)!=\\'I\\';j--){\\n                         arr[j]=counter++;\\n\\n                }\\n\\n            }\\n\\n        } \\n\\n\\n// make answer from array\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<=len;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963428,
                "title": "c-std-next-permutation-not-fun-though-but-good-to-know-about",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        std::string s;\\n        for(int i = 1; i <= pattern.length() + 1; i++)\\n        {\\n            s.push_back((char) i + \\'0\\');\\n        }\\n\\n        std::next_permutation(s.begin(), s.end());\\n        while(!isValid(s, pattern))\\n        {\\n            std::next_permutation(s.begin(), s.end());\\n        }\\n        \\n        return s;\\n    }\\nprivate:\\n    bool isValid(std::string& num, std::string& pattern)\\n    {\\n        for(int i = 0; i < pattern.length(); i++)\\n        {\\n            if(pattern[i] == \\'I\\') {\\n                if(num[i] >= num[i + 1])\\n                    return false;\\n            }\\n            else {\\n                if(num[i] <= num[i + 1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pattern) {\\n        std::string s;\\n        for(int i = 1; i <= pattern.length() + 1; i++)\\n        {\\n            s.push_back((char) i + \\'0\\');\\n        }\\n\\n        std::next_permutation(s.begin(), s.end());\\n        while(!isValid(s, pattern))\\n        {\\n            std::next_permutation(s.begin(), s.end());\\n        }\\n        \\n        return s;\\n    }\\nprivate:\\n    bool isValid(std::string& num, std::string& pattern)\\n    {\\n        for(int i = 0; i < pattern.length(); i++)\\n        {\\n            if(pattern[i] == \\'I\\') {\\n                if(num[i] >= num[i + 1])\\n                    return false;\\n            }\\n            else {\\n                if(num[i] <= num[i + 1])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962093,
                "title": "python-clean-and-simple-topological-solution",
                "content": "For greedy solution, checkout this [link](https://leetcode.com/problems/construct-smallest-number-from-di-string/solutions/2422380/java-c-python-easy-reverse/).\\n\\n```python\\nfrom collections import defaultdict\\nfrom itertools import count\\n\\nUNVISITED = -1\\n\\n\\nclass Solution:\\n    def smallestNumber(self, s: str) -> str:\\n        n = len(s)\\n\\n        g = self.create_graph(s)  # note that graph is DAG\\n\\n        seq_numbers = [UNVISITED] * (n + 1)\\n        next_seq_id = count(1).__next__\\n\\n        def dfs(u: int) -> int:\\n            for v in g[u]:\\n                if seq_numbers[v] == UNVISITED:\\n                    dfs(v)\\n\\n            seq_numbers[u] = next_seq_id()\\n\\n        for i in range(n + 1):\\n            if seq_numbers[i] == UNVISITED:\\n                dfs(i)\\n\\n        return \\'\\'.join(map(str, seq_numbers))\\n\\n    @staticmethod\\n    def create_graph(s: str) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for i, c in enumerate(s):\\n            if c == \\'D\\':\\n                g[i].append(i + 1)\\n            else:\\n                g[i + 1].append(i)\\n\\n        return g\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```python\\nfrom collections import defaultdict\\nfrom itertools import count\\n\\nUNVISITED = -1\\n\\n\\nclass Solution:\\n    def smallestNumber(self, s: str) -> str:\\n        n = len(s)\\n\\n        g = self.create_graph(s)  # note that graph is DAG\\n\\n        seq_numbers = [UNVISITED] * (n + 1)\\n        next_seq_id = count(1).__next__\\n\\n        def dfs(u: int) -> int:\\n            for v in g[u]:\\n                if seq_numbers[v] == UNVISITED:\\n                    dfs(v)\\n\\n            seq_numbers[u] = next_seq_id()\\n\\n        for i in range(n + 1):\\n            if seq_numbers[i] == UNVISITED:\\n                dfs(i)\\n\\n        return \\'\\'.join(map(str, seq_numbers))\\n\\n    @staticmethod\\n    def create_graph(s: str) -> defaultdict[int, list[int]]:\\n        g = defaultdict(list)\\n\\n        for i, c in enumerate(s):\\n            if c == \\'D\\':\\n                g[i].append(i + 1)\\n            else:\\n                g[i + 1].append(i)\\n\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946565,
                "title": "backtracking-solution",
                "content": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        arr=[]\\n        for i in range(1,10):\\n            visited=set()\\n            visited.add(i)\\n            self.backtracking(pattern,str(i),arr,0,visited)\\n        numbers = [int(num_string) for num_string in arr]\\n        return str(min(numbers))\\n\\n    def backtracking(self,pattern,number,arr,idx,visited):\\n        if idx>=len(pattern):\\n            if len(number)==len(pattern)+1: \\n                arr.append(number)\\n            return\\n        if pattern[idx]==\"I\":\\n            for i in range(int(number[-1])+1,10):\\n                if i not in visited:\\n                    visited.add(i)\\n                    self.backtracking(pattern,number+str(i),arr,idx+1,visited)\\n                    visited.remove(i)\\n        else:\\n            for i in range(int(number[-1])-1,0,-1):\\n                if i not in visited:\\n                    visited.add(i)\\n                    self.backtracking(pattern,number+str(i),arr,idx+1,visited)\\n                    visited.remove(i)\\n            \\n                \\n        \\n   ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        arr=[]\\n        for i in range(1,10):\\n            visited=set()\\n            visited.add(i)\\n            self.backtracking(pattern,str(i),arr,0,visited)\\n        numbers = [int(num_string) for num_string in arr]\\n        return str(min(numbers))\\n\\n    def backtracking(self,pattern,number,arr,idx,visited):\\n        if idx>=len(pattern):\\n            if len(number)==len(pattern)+1: \\n                arr.append(number)\\n            return\\n        if pattern[idx]==\"I\":\\n            for i in range(int(number[-1])+1,10):\\n                if i not in visited:\\n                    visited.add(i)\\n                    self.backtracking(pattern,number+str(i),arr,idx+1,visited)\\n                    visited.remove(i)\\n        else:\\n            for i in range(int(number[-1])-1,0,-1):\\n                if i not in visited:\\n                    visited.add(i)\\n                    self.backtracking(pattern,number+str(i),arr,idx+1,visited)\\n                    visited.remove(i)\\n            \\n                \\n        \\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3916592,
                "title": "beats-92-78-stack-heavily-explained-with-comments-python",
                "content": "# Intuition\\nThrough the problem we can conclude that we can use stack to solve for finding the pattern where intially we will start with \\'1\\' and inc or dec accordingly.\\n\\n# Approach\\nMaintain a stack and seen set and check if we have \\n\\n1. \\'I\\' as pattern -> we need to simply add the element which is greater than largest seen element. \\n`Why largest seen element?` Because we are told we cant repeat any digit so a new \\'I\\' will always be greatest digit\\n\\n2. \\'D\\' as pattern -> the new num must be smaller than last added element in stack. \\nBut suppose ur stack is -> 1 I, 2 I, 3 I, 4 I\\nso doing 3 D will result in repeatition of number. Thus, u need to  keep removing all the stack elements and store them in seperate array (to add them back ) untill u find a I and increase that I by +1.\\nAdd back the modified value and separate array elements back by incrementing with \\'+1\\'.\\n`NOTE -> YOU WILL RUN REVERSE LOOP AS IN STACK WE POPPED ELEMENT IN REVERSE ORDER`\\nAdd the current element with stack top element -1 value.\\n\\nThere are smaller and cleaner solutions available but I didnt find any detailed solution like this. You can refer other posts for the same.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        stack = []\\n        stack.append((1, \\'I\\'))\\n        seen = set()\\n        seen.add(1)\\n        for p in pattern:\\n            if p == \\'I\\': # keep adding  if \\'I\\'\\n                num = stack[-1][0] + 1\\n                while num in seen:\\n                    num += 1\\n                stack.append((num, \\'I\\'))\\n                seen.add(num)\\n            else:\\n                arr = []\\n\\n                # if \\'D\\' if found remove untill \\'I\\' is found\\n\\n                while stack and stack[-1][1] != \\'I\\': \\n                    num, sign = stack.pop()\\n                    arr.append(num)\\n                    seen.remove(num)\\n                \\n                # remove the top \\'I\\' and increase it by +1 untill new value\\n\\n                num, sign = stack.pop()\\n                seen.remove(num)\\n                n = num + 1\\n                while n in seen:\\n                    n += 1\\n                \\n                # add back the inc value\\n\\n                seen.add(n)\\n                stack.append((n, \\'I\\'))\\n\\n                #reverse the arr to append back the digits by +1 inc\\n\\n                for j in range(len(arr)-1, -1, -1):\\n                    num = arr[j] + 1\\n                    while num in seen: # adding this check improves run time\\n                        num += 1\\n                    stack.append((num, \\'D\\')) #append back the increased one\\n                    seen.add(num)\\n                seen.add(stack[-1][0] - 1) # append the curr pattern\\n                stack.append((stack[-1][0] - 1, \\'D\\'))\\n        \\n        ans = \\'\\'\\n        for num, sign in stack:\\n            ans += str(num)\\n        return ans\\n        \\n                \\n                \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def smallestNumber(self, pattern: str) -> str:\\n        stack = []\\n        stack.append((1, \\'I\\'))\\n        seen = set()\\n        seen.add(1)\\n        for p in pattern:\\n            if p == \\'I\\': # keep adding  if \\'I\\'\\n                num = stack[-1][0] + 1\\n                while num in seen:\\n                    num += 1\\n                stack.append((num, \\'I\\'))\\n                seen.add(num)\\n            else:\\n                arr = []\\n\\n                # if \\'D\\' if found remove untill \\'I\\' is found\\n\\n                while stack and stack[-1][1] != \\'I\\': \\n                    num, sign = stack.pop()\\n                    arr.append(num)\\n                    seen.remove(num)\\n                \\n                # remove the top \\'I\\' and increase it by +1 untill new value\\n\\n                num, sign = stack.pop()\\n                seen.remove(num)\\n                n = num + 1\\n                while n in seen:\\n                    n += 1\\n                \\n                # add back the inc value\\n\\n                seen.add(n)\\n                stack.append((n, \\'I\\'))\\n\\n                #reverse the arr to append back the digits by +1 inc\\n\\n                for j in range(len(arr)-1, -1, -1):\\n                    num = arr[j] + 1\\n                    while num in seen: # adding this check improves run time\\n                        num += 1\\n                    stack.append((num, \\'D\\')) #append back the increased one\\n                    seen.add(num)\\n                seen.add(stack[-1][0] - 1) # append the curr pattern\\n                stack.append((stack[-1][0] - 1, \\'D\\'))\\n        \\n        ans = \\'\\'\\n        for num, sign in stack:\\n            ans += str(num)\\n        return ans\\n        \\n                \\n                \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905876,
                "title": "using-stack-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pat) {\\n        string ans=\"\";\\n        int n = pat.size();\\n        stack<char> st;\\n        int i=0;\\n        char ch = \\'1\\';\\n        st.push(ch);\\n        while(!st.empty() && i<n){\\n            ch++;\\n            if(pat[i]==\\'I\\'){\\n                while(!st.empty()){\\n                    ans+=st.top();\\n                    st.pop();\\n                }\\n                st.push(ch);\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n            i++;\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestNumber(string pat) {\\n        string ans=\"\";\\n        int n = pat.size();\\n        stack<char> st;\\n        int i=0;\\n        char ch = \\'1\\';\\n        st.push(ch);\\n        while(!st.empty() && i<n){\\n            ch++;\\n            if(pat[i]==\\'I\\'){\\n                while(!st.empty()){\\n                    ans+=st.top();\\n                    st.pop();\\n                }\\n                st.push(ch);\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n            i++;\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904503,
                "title": "construct-smallest-number-from-di-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEasy apporach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1ms\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Integer>s=new Stack<>();\\n        int current=1;\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            s.push(current);\\n            if(pattern.charAt(i)==\\'I\\'){\\n                while(!s.isEmpty()){\\n                    sb.append(s.pop());\\n                }\\n                \\n            }\\n            current++;\\n        }\\n        s.push(current);\\n        while(!s.isEmpty()){\\n            sb.append(s.pop());\\n        }\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestNumber(String pattern) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Integer>s=new Stack<>();\\n        int current=1;\\n        \\n        for(int i=0;i<pattern.length();i++){\\n            s.push(current);\\n            if(pattern.charAt(i)==\\'I\\'){\\n                while(!s.isEmpty()){\\n                    sb.append(s.pop());\\n                }\\n                \\n            }\\n            current++;\\n        }\\n        s.push(current);\\n        while(!s.isEmpty()){\\n            sb.append(s.pop());\\n        }\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877532,
                "title": "easy-stack-solution-beat-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse a stack and loop (start at 1) judge current character whether \"I\", if current character is I Pop all value from stack because \"I\" need increased.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public string SmallestNumber(string pattern) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<int> stack = new Stack<int>();\\n        for(int i = 1; i <= pattern.Length; i++){\\n            stack.Push(i);\\n            if(pattern[i - 1] == \\'I\\'){\\n                while(stack.Count > 0){\\n                    sb.Append(stack.Pop());\\n                }\\n            } \\n        } \\n        sb.Append(pattern.Length + 1);\\n        while(stack.Count > 0){\\n            sb.Append(stack.Pop());\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string SmallestNumber(string pattern) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<int> stack = new Stack<int>();\\n        for(int i = 1; i <= pattern.Length; i++){\\n            stack.Push(i);\\n            if(pattern[i - 1] == \\'I\\'){\\n                while(stack.Count > 0){\\n                    sb.Append(stack.Pop());\\n                }\\n            } \\n        } \\n        sb.Append(pattern.Length + 1);\\n        while(stack.Count > 0){\\n            sb.Append(stack.Pop());\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1977002,
                "content": [
                    {
                        "username": "ahmed_hadaka",
                        "content": "Same as this premium one: [find permutation](https://leetcode.com/problems/find-permutation/)"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "easy\\n"
                    },
                    {
                        "username": "Priya_Bandaru",
                        "content": "\"123546789\" I got the result which is less then \"123549876\" which is even correct..\\nBut TC is failing .\\n\\n"
                    },
                    {
                        "username": "ranavishal2015",
                        "content": "[@Priya](/Priya_Bandaru)\\nMake sure you use the digit at most once."
                    },
                    {
                        "username": "kbinu42",
                        "content": "no, condition fails for your result, If pattern[i] == \\'D\\', then num[i] > num[i + 1]."
                    },
                    {
                        "username": "Ashu2094",
                        "content": "no 123549876 is smallest for IIIDIDDD but for ur tc 123546789 the string must be IIIDIIII which is different\n"
                    }
                ]
            },
            {
                "id": 2025655,
                "content": [
                    {
                        "username": "ahmed_hadaka",
                        "content": "Same as this premium one: [find permutation](https://leetcode.com/problems/find-permutation/)"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "easy\\n"
                    },
                    {
                        "username": "Priya_Bandaru",
                        "content": "\"123546789\" I got the result which is less then \"123549876\" which is even correct..\\nBut TC is failing .\\n\\n"
                    },
                    {
                        "username": "ranavishal2015",
                        "content": "[@Priya](/Priya_Bandaru)\\nMake sure you use the digit at most once."
                    },
                    {
                        "username": "kbinu42",
                        "content": "no, condition fails for your result, If pattern[i] == \\'D\\', then num[i] > num[i + 1]."
                    },
                    {
                        "username": "Ashu2094",
                        "content": "no 123549876 is smallest for IIIDIDDD but for ur tc 123546789 the string must be IIIDIIII which is different\n"
                    }
                ]
            },
            {
                "id": 1826903,
                "content": [
                    {
                        "username": "ahmed_hadaka",
                        "content": "Same as this premium one: [find permutation](https://leetcode.com/problems/find-permutation/)"
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "easy\\n"
                    },
                    {
                        "username": "Priya_Bandaru",
                        "content": "\"123546789\" I got the result which is less then \"123549876\" which is even correct..\\nBut TC is failing .\\n\\n"
                    },
                    {
                        "username": "ranavishal2015",
                        "content": "[@Priya](/Priya_Bandaru)\\nMake sure you use the digit at most once."
                    },
                    {
                        "username": "kbinu42",
                        "content": "no, condition fails for your result, If pattern[i] == \\'D\\', then num[i] > num[i + 1]."
                    },
                    {
                        "username": "Ashu2094",
                        "content": "no 123549876 is smallest for IIIDIDDD but for ur tc 123546789 the string must be IIIDIIII which is different\n"
                    }
                ]
            }
        ]
    }
]