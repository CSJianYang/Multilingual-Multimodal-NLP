[
    {
        "title": "Binary Watch",
        "question_content": "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent&nbsp;the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n\tFor example, the below binary watch reads \"4:51\".\n\n\nGiven an integer turnedOn which represents the number of LEDs that are currently on (ignoring the PM), return all possible times the watch could represent. You may return the answer in any order.\nThe hour must not contain a leading zero.\n\n\tFor example, \"01:00\" is not valid. It should be \"1:00\".\n\nThe minute must&nbsp;consist of two digits and may contain a leading zero.\n\n\tFor example, \"10:2\" is not valid. It should be \"10:02\".\n\n&nbsp;\nExample 1:\nInput: turnedOn = 1\nOutput: [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\nExample 2:\nInput: turnedOn = 9\nOutput: []\n&nbsp;\nConstraints:\n\n\t0 <= turnedOn <= 10",
        "solutions": [
            {
                "id": 88458,
                "title": "simple-python-java",
                "content": "Just go through the possible times and collect those with the correct number of one-bits.\\n\\nPython:\\n\\n    def readBinaryWatch(self, num):\\n        return ['%d:%02d' % (h, m)\\n                for h in range(12) for m in range(60)\\n                if (bin(h) + bin(m)).count('1') == num]\\n\\nJava:\\n\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> times = new ArrayList<>();\\n        for (int h=0; h<12; h++)\\n            for (int m=0; m<60; m++)\\n                if (Integer.bitCount(h * 64 + m) == num)\\n                    times.add(String.format(\"%d:%02d\", h, m));\\n        return times;        \\n    }",
                "solutionTags": [],
                "code": "Just go through the possible times and collect those with the correct number of one-bits.\\n\\nPython:\\n\\n    def readBinaryWatch(self, num):\\n        return ['%d:%02d' % (h, m)\\n                for h in range(12) for m in range(60)\\n                if (bin(h) + bin(m)).count('1') == num]\\n\\nJava:\\n\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> times = new ArrayList<>();\\n        for (int h=0; h<12; h++)\\n            for (int m=0; m<60; m++)\\n                if (Integer.bitCount(h * 64 + m) == num)\\n                    times.add(String.format(\"%d:%02d\", h, m));\\n        return times;        \\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 88465,
                "title": "straight-forward-6-line-c-solution-no-need-to-explain",
                "content": "```\\nvector<string> readBinaryWatch(int num) {\\n    vector<string> rs;\\n    for (int h = 0; h < 12; h++)\\n    for (int m = 0; m < 60; m++)\\n        if (bitset<10>(h << 6 | m).count() == num)\\n            rs.emplace_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\\n    return rs;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> readBinaryWatch(int num) {\\n    vector<string> rs;\\n    for (int h = 0; h < 12; h++)\\n    for (int m = 0; m < 60; m++)\\n        if (bitset<10>(h << 6 | m).count() == num)\\n            rs.emplace_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\\n    return rs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88456,
                "title": "3ms-java-solution-using-backtracking-and-idea-of-permutation-and-combination",
                "content": "```\\npublic class Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        int[] nums1 = new int[]{8, 4, 2, 1}, nums2 = new int[]{32, 16, 8, 4, 2, 1};\\n        for(int i = 0; i <= num; i++) {\\n            List<Integer> list1 = generateDigit(nums1, i);\\n            List<Integer> list2 = generateDigit(nums2, num - i);\\n            for(int num1: list1) {\\n                if(num1 >= 12) continue;\\n                for(int num2: list2) {\\n                    if(num2 >= 60) continue;\\n                    res.add(num1 + \":\" + (num2 < 10 ? \"0\" + num2 : num2));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private List<Integer> generateDigit(int[] nums, int count) {\\n        List<Integer> res = new ArrayList<>();\\n        generateDigitHelper(nums, count, 0, 0, res);\\n        return res;\\n    }\\n\\n    private void generateDigitHelper(int[] nums, int count, int pos, int sum, List<Integer> res) {\\n        if(count == 0) {\\n            res.add(sum);\\n            return;\\n        }\\n        \\n        for(int i = pos; i < nums.length; i++) {\\n            generateDigitHelper(nums, count - 1, i + 1, sum + nums[i], res);    \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        int[] nums1 = new int[]{8, 4, 2, 1}, nums2 = new int[]{32, 16, 8, 4, 2, 1};\\n        for(int i = 0; i <= num; i++) {\\n            List<Integer> list1 = generateDigit(nums1, i);\\n            List<Integer> list2 = generateDigit(nums2, num - i);\\n            for(int num1: list1) {\\n                if(num1 >= 12) continue;\\n                for(int num2: list2) {\\n                    if(num2 >= 60) continue;\\n                    res.add(num1 + \":\" + (num2 < 10 ? \"0\" + num2 : num2));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private List<Integer> generateDigit(int[] nums, int count) {\\n        List<Integer> res = new ArrayList<>();\\n        generateDigitHelper(nums, count, 0, 0, res);\\n        return res;\\n    }\\n\\n    private void generateDigitHelper(int[] nums, int count, int pos, int sum, List<Integer> res) {\\n        if(count == 0) {\\n            res.add(sum);\\n            return;\\n        }\\n        \\n        for(int i = pos; i < nums.length; i++) {\\n            generateDigitHelper(nums, count - 1, i + 1, sum + nums[i], res);    \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88475,
                "title": "sorry-i-cheat",
                "content": "Just for fun, here is my code:\\n\\n```\\ndef read_binary_watch(num)\\n    case num\\n    when 0\\n    \\t[\"0:00\"]\\n    when 1\\n    \\t[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\\n    when 2\\n    \\t[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n    when 3\\n    \\t[\"0:07\",\"0:11\",\"0:13\",\"0:14\",\"0:19\",\"0:21\",\"0:22\",\"0:25\",\"0:26\",\"0:28\",\"0:35\",\"0:37\",\"0:38\",\"0:41\",\"0:42\",\"0:44\",\"0:49\",\"0:50\",\"0:52\",\"0:56\",\"1:03\",\"1:05\",\"1:06\",\"1:09\",\"1:10\",\"1:12\",\"1:17\",\"1:18\",\"1:20\",\"1:24\",\"1:33\",\"1:34\",\"1:36\",\"1:40\",\"1:48\",\"2:03\",\"2:05\",\"2:06\",\"2:09\",\"2:10\",\"2:12\",\"2:17\",\"2:18\",\"2:20\",\"2:24\",\"2:33\",\"2:34\",\"2:36\",\"2:40\",\"2:48\",\"3:01\",\"3:02\",\"3:04\",\"3:08\",\"3:16\",\"3:32\",\"4:03\",\"4:05\",\"4:06\",\"4:09\",\"4:10\",\"4:12\",\"4:17\",\"4:18\",\"4:20\",\"4:24\",\"4:33\",\"4:34\",\"4:36\",\"4:40\",\"4:48\",\"5:01\",\"5:02\",\"5:04\",\"5:08\",\"5:16\",\"5:32\",\"6:01\",\"6:02\",\"6:04\",\"6:08\",\"6:16\",\"6:32\",\"7:00\",\"8:03\",\"8:05\",\"8:06\",\"8:09\",\"8:10\",\"8:12\",\"8:17\",\"8:18\",\"8:20\",\"8:24\",\"8:33\",\"8:34\",\"8:36\",\"8:40\",\"8:48\",\"9:01\",\"9:02\",\"9:04\",\"9:08\",\"9:16\",\"9:32\",\"10:01\",\"10:02\",\"10:04\",\"10:08\",\"10:16\",\"10:32\",\"11:00\"]\\n    when 4\\n    \\t[\"0:15\",\"0:23\",\"0:27\",\"0:29\",\"0:30\",\"0:39\",\"0:43\",\"0:45\",\"0:46\",\"0:51\",\"0:53\",\"0:54\",\"0:57\",\"0:58\",\"1:07\",\"1:11\",\"1:13\",\"1:14\",\"1:19\",\"1:21\",\"1:22\",\"1:25\",\"1:26\",\"1:28\",\"1:35\",\"1:37\",\"1:38\",\"1:41\",\"1:42\",\"1:44\",\"1:49\",\"1:50\",\"1:52\",\"1:56\",\"2:07\",\"2:11\",\"2:13\",\"2:14\",\"2:19\",\"2:21\",\"2:22\",\"2:25\",\"2:26\",\"2:28\",\"2:35\",\"2:37\",\"2:38\",\"2:41\",\"2:42\",\"2:44\",\"2:49\",\"2:50\",\"2:52\",\"2:56\",\"3:03\",\"3:05\",\"3:06\",\"3:09\",\"3:10\",\"3:12\",\"3:17\",\"3:18\",\"3:20\",\"3:24\",\"3:33\",\"3:34\",\"3:36\",\"3:40\",\"3:48\",\"4:07\",\"4:11\",\"4:13\",\"4:14\",\"4:19\",\"4:21\",\"4:22\",\"4:25\",\"4:26\",\"4:28\",\"4:35\",\"4:37\",\"4:38\",\"4:41\",\"4:42\",\"4:44\",\"4:49\",\"4:50\",\"4:52\",\"4:56\",\"5:03\",\"5:05\",\"5:06\",\"5:09\",\"5:10\",\"5:12\",\"5:17\",\"5:18\",\"5:20\",\"5:24\",\"5:33\",\"5:34\",\"5:36\",\"5:40\",\"5:48\",\"6:03\",\"6:05\",\"6:06\",\"6:09\",\"6:10\",\"6:12\",\"6:17\",\"6:18\",\"6:20\",\"6:24\",\"6:33\",\"6:34\",\"6:36\",\"6:40\",\"6:48\",\"7:01\",\"7:02\",\"7:04\",\"7:08\",\"7:16\",\"7:32\",\"8:07\",\"8:11\",\"8:13\",\"8:14\",\"8:19\",\"8:21\",\"8:22\",\"8:25\",\"8:26\",\"8:28\",\"8:35\",\"8:37\",\"8:38\",\"8:41\",\"8:42\",\"8:44\",\"8:49\",\"8:50\",\"8:52\",\"8:56\",\"9:03\",\"9:05\",\"9:06\",\"9:09\",\"9:10\",\"9:12\",\"9:17\",\"9:18\",\"9:20\",\"9:24\",\"9:33\",\"9:34\",\"9:36\",\"9:40\",\"9:48\",\"10:03\",\"10:05\",\"10:06\",\"10:09\",\"10:10\",\"10:12\",\"10:17\",\"10:18\",\"10:20\",\"10:24\",\"10:33\",\"10:34\",\"10:36\",\"10:40\",\"10:48\",\"11:01\",\"11:02\",\"11:04\",\"11:08\",\"11:16\",\"11:32\"]\\n    when 5\\n    \\t[\"0:31\",\"0:47\",\"0:55\",\"0:59\",\"1:15\",\"1:23\",\"1:27\",\"1:29\",\"1:30\",\"1:39\",\"1:43\",\"1:45\",\"1:46\",\"1:51\",\"1:53\",\"1:54\",\"1:57\",\"1:58\",\"2:15\",\"2:23\",\"2:27\",\"2:29\",\"2:30\",\"2:39\",\"2:43\",\"2:45\",\"2:46\",\"2:51\",\"2:53\",\"2:54\",\"2:57\",\"2:58\",\"3:07\",\"3:11\",\"3:13\",\"3:14\",\"3:19\",\"3:21\",\"3:22\",\"3:25\",\"3:26\",\"3:28\",\"3:35\",\"3:37\",\"3:38\",\"3:41\",\"3:42\",\"3:44\",\"3:49\",\"3:50\",\"3:52\",\"3:56\",\"4:15\",\"4:23\",\"4:27\",\"4:29\",\"4:30\",\"4:39\",\"4:43\",\"4:45\",\"4:46\",\"4:51\",\"4:53\",\"4:54\",\"4:57\",\"4:58\",\"5:07\",\"5:11\",\"5:13\",\"5:14\",\"5:19\",\"5:21\",\"5:22\",\"5:25\",\"5:26\",\"5:28\",\"5:35\",\"5:37\",\"5:38\",\"5:41\",\"5:42\",\"5:44\",\"5:49\",\"5:50\",\"5:52\",\"5:56\",\"6:07\",\"6:11\",\"6:13\",\"6:14\",\"6:19\",\"6:21\",\"6:22\",\"6:25\",\"6:26\",\"6:28\",\"6:35\",\"6:37\",\"6:38\",\"6:41\",\"6:42\",\"6:44\",\"6:49\",\"6:50\",\"6:52\",\"6:56\",\"7:03\",\"7:05\",\"7:06\",\"7:09\",\"7:10\",\"7:12\",\"7:17\",\"7:18\",\"7:20\",\"7:24\",\"7:33\",\"7:34\",\"7:36\",\"7:40\",\"7:48\",\"8:15\",\"8:23\",\"8:27\",\"8:29\",\"8:30\",\"8:39\",\"8:43\",\"8:45\",\"8:46\",\"8:51\",\"8:53\",\"8:54\",\"8:57\",\"8:58\",\"9:07\",\"9:11\",\"9:13\",\"9:14\",\"9:19\",\"9:21\",\"9:22\",\"9:25\",\"9:26\",\"9:28\",\"9:35\",\"9:37\",\"9:38\",\"9:41\",\"9:42\",\"9:44\",\"9:49\",\"9:50\",\"9:52\",\"9:56\",\"10:07\",\"10:11\",\"10:13\",\"10:14\",\"10:19\",\"10:21\",\"10:22\",\"10:25\",\"10:26\",\"10:28\",\"10:35\",\"10:37\",\"10:38\",\"10:41\",\"10:42\",\"10:44\",\"10:49\",\"10:50\",\"10:52\",\"10:56\",\"11:03\",\"11:05\",\"11:06\",\"11:09\",\"11:10\",\"11:12\",\"11:17\",\"11:18\",\"11:20\",\"11:24\",\"11:33\",\"11:34\",\"11:36\",\"11:40\",\"11:48\"]\\n    when 6\\n    \\t[\"1:31\",\"1:47\",\"1:55\",\"1:59\",\"2:31\",\"2:47\",\"2:55\",\"2:59\",\"3:15\",\"3:23\",\"3:27\",\"3:29\",\"3:30\",\"3:39\",\"3:43\",\"3:45\",\"3:46\",\"3:51\",\"3:53\",\"3:54\",\"3:57\",\"3:58\",\"4:31\",\"4:47\",\"4:55\",\"4:59\",\"5:15\",\"5:23\",\"5:27\",\"5:29\",\"5:30\",\"5:39\",\"5:43\",\"5:45\",\"5:46\",\"5:51\",\"5:53\",\"5:54\",\"5:57\",\"5:58\",\"6:15\",\"6:23\",\"6:27\",\"6:29\",\"6:30\",\"6:39\",\"6:43\",\"6:45\",\"6:46\",\"6:51\",\"6:53\",\"6:54\",\"6:57\",\"6:58\",\"7:07\",\"7:11\",\"7:13\",\"7:14\",\"7:19\",\"7:21\",\"7:22\",\"7:25\",\"7:26\",\"7:28\",\"7:35\",\"7:37\",\"7:38\",\"7:41\",\"7:42\",\"7:44\",\"7:49\",\"7:50\",\"7:52\",\"7:56\",\"8:31\",\"8:47\",\"8:55\",\"8:59\",\"9:15\",\"9:23\",\"9:27\",\"9:29\",\"9:30\",\"9:39\",\"9:43\",\"9:45\",\"9:46\",\"9:51\",\"9:53\",\"9:54\",\"9:57\",\"9:58\",\"10:15\",\"10:23\",\"10:27\",\"10:29\",\"10:30\",\"10:39\",\"10:43\",\"10:45\",\"10:46\",\"10:51\",\"10:53\",\"10:54\",\"10:57\",\"10:58\",\"11:07\",\"11:11\",\"11:13\",\"11:14\",\"11:19\",\"11:21\",\"11:22\",\"11:25\",\"11:26\",\"11:28\",\"11:35\",\"11:37\",\"11:38\",\"11:41\",\"11:42\",\"11:44\",\"11:49\",\"11:50\",\"11:52\",\"11:56\"]\\n    when 7\\n    \\t[\"3:31\",\"3:47\",\"3:55\",\"3:59\",\"5:31\",\"5:47\",\"5:55\",\"5:59\",\"6:31\",\"6:47\",\"6:55\",\"6:59\",\"7:15\",\"7:23\",\"7:27\",\"7:29\",\"7:30\",\"7:39\",\"7:43\",\"7:45\",\"7:46\",\"7:51\",\"7:53\",\"7:54\",\"7:57\",\"7:58\",\"9:31\",\"9:47\",\"9:55\",\"9:59\",\"10:31\",\"10:47\",\"10:55\",\"10:59\",\"11:15\",\"11:23\",\"11:27\",\"11:29\",\"11:30\",\"11:39\",\"11:43\",\"11:45\",\"11:46\",\"11:51\",\"11:53\",\"11:54\",\"11:57\",\"11:58\"]\\n    when 8\\n    \\t[\"7:31\",\"7:47\",\"7:55\",\"7:59\",\"11:31\",\"11:47\",\"11:55\",\"11:59\"]\\n    else\\n    \\t[]\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef read_binary_watch(num)\\n    case num\\n    when 0\\n    \\t[\"0:00\"]\\n    when 1\\n    \\t[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\\n    when 2\\n    \\t[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n    when 3\\n    \\t[\"0:07\",\"0:11\",\"0:13\",\"0:14\",\"0:19\",\"0:21\",\"0:22\",\"0:25\",\"0:26\",\"0:28\",\"0:35\",\"0:37\",\"0:38\",\"0:41\",\"0:42\",\"0:44\",\"0:49\",\"0:50\",\"0:52\",\"0:56\",\"1:03\",\"1:05\",\"1:06\",\"1:09\",\"1:10\",\"1:12\",\"1:17\",\"1:18\",\"1:20\",\"1:24\",\"1:33\",\"1:34\",\"1:36\",\"1:40\",\"1:48\",\"2:03\",\"2:05\",\"2:06\",\"2:09\",\"2:10\",\"2:12\",\"2:17\",\"2:18\",\"2:20\",\"2:24\",\"2:33\",\"2:34\",\"2:36\",\"2:40\",\"2:48\",\"3:01\",\"3:02\",\"3:04\",\"3:08\",\"3:16\",\"3:32\",\"4:03\",\"4:05\",\"4:06\",\"4:09\",\"4:10\",\"4:12\",\"4:17\",\"4:18\",\"4:20\",\"4:24\",\"4:33\",\"4:34\",\"4:36\",\"4:40\",\"4:48\",\"5:01\",\"5:02\",\"5:04\",\"5:08\",\"5:16\",\"5:32\",\"6:01\",\"6:02\",\"6:04\",\"6:08\",\"6:16\",\"6:32\",\"7:00\",\"8:03\",\"8:05\",\"8:06\",\"8:09\",\"8:10\",\"8:12\",\"8:17\",\"8:18\",\"8:20\",\"8:24\",\"8:33\",\"8:34\",\"8:36\",\"8:40\",\"8:48\",\"9:01\",\"9:02\",\"9:04\",\"9:08\",\"9:16\",\"9:32\",\"10:01\",\"10:02\",\"10:04\",\"10:08\",\"10:16\",\"10:32\",\"11:00\"]\\n    when 4\\n    \\t[\"0:15\",\"0:23\",\"0:27\",\"0:29\",\"0:30\",\"0:39\",\"0:43\",\"0:45\",\"0:46\",\"0:51\",\"0:53\",\"0:54\",\"0:57\",\"0:58\",\"1:07\",\"1:11\",\"1:13\",\"1:14\",\"1:19\",\"1:21\",\"1:22\",\"1:25\",\"1:26\",\"1:28\",\"1:35\",\"1:37\",\"1:38\",\"1:41\",\"1:42\",\"1:44\",\"1:49\",\"1:50\",\"1:52\",\"1:56\",\"2:07\",\"2:11\",\"2:13\",\"2:14\",\"2:19\",\"2:21\",\"2:22\",\"2:25\",\"2:26\",\"2:28\",\"2:35\",\"2:37\",\"2:38\",\"2:41\",\"2:42\",\"2:44\",\"2:49\",\"2:50\",\"2:52\",\"2:56\",\"3:03\",\"3:05\",\"3:06\",\"3:09\",\"3:10\",\"3:12\",\"3:17\",\"3:18\",\"3:20\",\"3:24\",\"3:33\",\"3:34\",\"3:36\",\"3:40\",\"3:48\",\"4:07\",\"4:11\",\"4:13\",\"4:14\",\"4:19\",\"4:21\",\"4:22\",\"4:25\",\"4:26\",\"4:28\",\"4:35\",\"4:37\",\"4:38\",\"4:41\",\"4:42\",\"4:44\",\"4:49\",\"4:50\",\"4:52\",\"4:56\",\"5:03\",\"5:05\",\"5:06\",\"5:09\",\"5:10\",\"5:12\",\"5:17\",\"5:18\",\"5:20\",\"5:24\",\"5:33\",\"5:34\",\"5:36\",\"5:40\",\"5:48\",\"6:03\",\"6:05\",\"6:06\",\"6:09\",\"6:10\",\"6:12\",\"6:17\",\"6:18\",\"6:20\",\"6:24\",\"6:33\",\"6:34\",\"6:36\",\"6:40\",\"6:48\",\"7:01\",\"7:02\",\"7:04\",\"7:08\",\"7:16\",\"7:32\",\"8:07\",\"8:11\",\"8:13\",\"8:14\",\"8:19\",\"8:21\",\"8:22\",\"8:25\",\"8:26\",\"8:28\",\"8:35\",\"8:37\",\"8:38\",\"8:41\",\"8:42\",\"8:44\",\"8:49\",\"8:50\",\"8:52\",\"8:56\",\"9:03\",\"9:05\",\"9:06\",\"9:09\",\"9:10\",\"9:12\",\"9:17\",\"9:18\",\"9:20\",\"9:24\",\"9:33\",\"9:34\",\"9:36\",\"9:40\",\"9:48\",\"10:03\",\"10:05\",\"10:06\",\"10:09\",\"10:10\",\"10:12\",\"10:17\",\"10:18\",\"10:20\",\"10:24\",\"10:33\",\"10:34\",\"10:36\",\"10:40\",\"10:48\",\"11:01\",\"11:02\",\"11:04\",\"11:08\",\"11:16\",\"11:32\"]\\n    when 5\\n    \\t[\"0:31\",\"0:47\",\"0:55\",\"0:59\",\"1:15\",\"1:23\",\"1:27\",\"1:29\",\"1:30\",\"1:39\",\"1:43\",\"1:45\",\"1:46\",\"1:51\",\"1:53\",\"1:54\",\"1:57\",\"1:58\",\"2:15\",\"2:23\",\"2:27\",\"2:29\",\"2:30\",\"2:39\",\"2:43\",\"2:45\",\"2:46\",\"2:51\",\"2:53\",\"2:54\",\"2:57\",\"2:58\",\"3:07\",\"3:11\",\"3:13\",\"3:14\",\"3:19\",\"3:21\",\"3:22\",\"3:25\",\"3:26\",\"3:28\",\"3:35\",\"3:37\",\"3:38\",\"3:41\",\"3:42\",\"3:44\",\"3:49\",\"3:50\",\"3:52\",\"3:56\",\"4:15\",\"4:23\",\"4:27\",\"4:29\",\"4:30\",\"4:39\",\"4:43\",\"4:45\",\"4:46\",\"4:51\",\"4:53\",\"4:54\",\"4:57\",\"4:58\",\"5:07\",\"5:11\",\"5:13\",\"5:14\",\"5:19\",\"5:21\",\"5:22\",\"5:25\",\"5:26\",\"5:28\",\"5:35\",\"5:37\",\"5:38\",\"5:41\",\"5:42\",\"5:44\",\"5:49\",\"5:50\",\"5:52\",\"5:56\",\"6:07\",\"6:11\",\"6:13\",\"6:14\",\"6:19\",\"6:21\",\"6:22\",\"6:25\",\"6:26\",\"6:28\",\"6:35\",\"6:37\",\"6:38\",\"6:41\",\"6:42\",\"6:44\",\"6:49\",\"6:50\",\"6:52\",\"6:56\",\"7:03\",\"7:05\",\"7:06\",\"7:09\",\"7:10\",\"7:12\",\"7:17\",\"7:18\",\"7:20\",\"7:24\",\"7:33\",\"7:34\",\"7:36\",\"7:40\",\"7:48\",\"8:15\",\"8:23\",\"8:27\",\"8:29\",\"8:30\",\"8:39\",\"8:43\",\"8:45\",\"8:46\",\"8:51\",\"8:53\",\"8:54\",\"8:57\",\"8:58\",\"9:07\",\"9:11\",\"9:13\",\"9:14\",\"9:19\",\"9:21\",\"9:22\",\"9:25\",\"9:26\",\"9:28\",\"9:35\",\"9:37\",\"9:38\",\"9:41\",\"9:42\",\"9:44\",\"9:49\",\"9:50\",\"9:52\",\"9:56\",\"10:07\",\"10:11\",\"10:13\",\"10:14\",\"10:19\",\"10:21\",\"10:22\",\"10:25\",\"10:26\",\"10:28\",\"10:35\",\"10:37\",\"10:38\",\"10:41\",\"10:42\",\"10:44\",\"10:49\",\"10:50\",\"10:52\",\"10:56\",\"11:03\",\"11:05\",\"11:06\",\"11:09\",\"11:10\",\"11:12\",\"11:17\",\"11:18\",\"11:20\",\"11:24\",\"11:33\",\"11:34\",\"11:36\",\"11:40\",\"11:48\"]\\n    when 6\\n    \\t[\"1:31\",\"1:47\",\"1:55\",\"1:59\",\"2:31\",\"2:47\",\"2:55\",\"2:59\",\"3:15\",\"3:23\",\"3:27\",\"3:29\",\"3:30\",\"3:39\",\"3:43\",\"3:45\",\"3:46\",\"3:51\",\"3:53\",\"3:54\",\"3:57\",\"3:58\",\"4:31\",\"4:47\",\"4:55\",\"4:59\",\"5:15\",\"5:23\",\"5:27\",\"5:29\",\"5:30\",\"5:39\",\"5:43\",\"5:45\",\"5:46\",\"5:51\",\"5:53\",\"5:54\",\"5:57\",\"5:58\",\"6:15\",\"6:23\",\"6:27\",\"6:29\",\"6:30\",\"6:39\",\"6:43\",\"6:45\",\"6:46\",\"6:51\",\"6:53\",\"6:54\",\"6:57\",\"6:58\",\"7:07\",\"7:11\",\"7:13\",\"7:14\",\"7:19\",\"7:21\",\"7:22\",\"7:25\",\"7:26\",\"7:28\",\"7:35\",\"7:37\",\"7:38\",\"7:41\",\"7:42\",\"7:44\",\"7:49\",\"7:50\",\"7:52\",\"7:56\",\"8:31\",\"8:47\",\"8:55\",\"8:59\",\"9:15\",\"9:23\",\"9:27\",\"9:29\",\"9:30\",\"9:39\",\"9:43\",\"9:45\",\"9:46\",\"9:51\",\"9:53\",\"9:54\",\"9:57\",\"9:58\",\"10:15\",\"10:23\",\"10:27\",\"10:29\",\"10:30\",\"10:39\",\"10:43\",\"10:45\",\"10:46\",\"10:51\",\"10:53\",\"10:54\",\"10:57\",\"10:58\",\"11:07\",\"11:11\",\"11:13\",\"11:14\",\"11:19\",\"11:21\",\"11:22\",\"11:25\",\"11:26\",\"11:28\",\"11:35\",\"11:37\",\"11:38\",\"11:41\",\"11:42\",\"11:44\",\"11:49\",\"11:50\",\"11:52\",\"11:56\"]\\n    when 7\\n    \\t[\"3:31\",\"3:47\",\"3:55\",\"3:59\",\"5:31\",\"5:47\",\"5:55\",\"5:59\",\"6:31\",\"6:47\",\"6:55\",\"6:59\",\"7:15\",\"7:23\",\"7:27\",\"7:29\",\"7:30\",\"7:39\",\"7:43\",\"7:45\",\"7:46\",\"7:51\",\"7:53\",\"7:54\",\"7:57\",\"7:58\",\"9:31\",\"9:47\",\"9:55\",\"9:59\",\"10:31\",\"10:47\",\"10:55\",\"10:59\",\"11:15\",\"11:23\",\"11:27\",\"11:29\",\"11:30\",\"11:39\",\"11:43\",\"11:45\",\"11:46\",\"11:51\",\"11:53\",\"11:54\",\"11:57\",\"11:58\"]\\n    when 8\\n    \\t[\"7:31\",\"7:47\",\"7:55\",\"7:59\",\"11:31\",\"11:47\",\"11:55\",\"11:59\"]\\n    else\\n    \\t[]\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 88471,
                "title": "just-for-fun-java-1ms-beats-100",
                "content": "```\\npublic class Solution {\\n    String[][] hour = {{\"0\"},\\n            {\"1\", \"2\", \"4\", \"8\"},\\n            {\"3\", \"5\", \"6\", \"9\", \"10\"},\\n            {\"7\", \"11\"}};\\n    String[][] minute = {{\"00\"},\\n            {\"01\", \"02\", \"04\", \"08\", \"16\", \"32\"},\\n            {\"03\", \"05\", \"06\", \"09\", \"10\", \"12\", \"17\", \"18\", \"20\", \"24\", \"33\", \"34\", \"36\", \"40\", \"48\"},\\n            {\"07\", \"11\", \"13\", \"14\", \"19\", \"21\", \"22\", \"25\", \"26\", \"28\", \"35\", \"37\", \"38\", \"41\", \"42\", \"44\", \"49\", \"50\", \"52\", \"56\"},\\n            {\"15\", \"23\", \"27\", \"29\", \"30\", \"39\", \"43\", \"45\", \"46\", \"51\", \"53\", \"54\", \"57\", \"58\"},\\n            {\"31\", \"47\", \"55\", \"59\"}};\\n\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> ret = new ArrayList();\\n        for (int i = 0; i <= 3 && i <= num; i++) {\\n            if (num - i <= 5) {\\n                for (String str1 : hour[i]) {\\n                    for (String str2 : minute[num - i]) {\\n                        ret.add(str1 + \":\" + str2);\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    String[][] hour = {{\"0\"},\\n            {\"1\", \"2\", \"4\", \"8\"},\\n            {\"3\", \"5\", \"6\", \"9\", \"10\"},\\n            {\"7\", \"11\"}};\\n    String[][] minute = {{\"00\"},\\n            {\"01\", \"02\", \"04\", \"08\", \"16\", \"32\"},\\n            {\"03\", \"05\", \"06\", \"09\", \"10\", \"12\", \"17\", \"18\", \"20\", \"24\", \"33\", \"34\", \"36\", \"40\", \"48\"},\\n            {\"07\", \"11\", \"13\", \"14\", \"19\", \"21\", \"22\", \"25\", \"26\", \"28\", \"35\", \"37\", \"38\", \"41\", \"42\", \"44\", \"49\", \"50\", \"52\", \"56\"},\\n            {\"15\", \"23\", \"27\", \"29\", \"30\", \"39\", \"43\", \"45\", \"46\", \"51\", \"53\", \"54\", \"57\", \"58\"},\\n            {\"31\", \"47\", \"55\", \"59\"}};\\n\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> ret = new ArrayList();\\n        for (int i = 0; i <= 3 && i <= num; i++) {\\n            if (num - i <= 5) {\\n                for (String str1 : hour[i]) {\\n                    for (String str2 : minute[num - i]) {\\n                        ret.add(str1 + \":\" + str2);\\n                    }\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88536,
                "title": "straightforward-java-answer",
                "content": "```\\n    public List<String> readBinaryWatch(int num) {\\n        ArrayList<String> result = new ArrayList<>();\\n        for (int i = 0; i < 12; i++) {\\n            for (int j = 0; j < 60; j++) {\\n                if (Integer.bitCount(i) + Integer.bitCount(j) == num) {\\n                    result.add(String.format(\"%d:%02d\", i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public List<String> readBinaryWatch(int num) {\\n        ArrayList<String> result = new ArrayList<>();\\n        for (int i = 0; i < 12; i++) {\\n            for (int j = 0; j < 60; j++) {\\n                if (Integer.bitCount(i) + Integer.bitCount(j) == num) {\\n                    result.add(String.format(\"%d:%02d\", i, j));\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 88451,
                "title": "0ms-c-back-tracking-solution-with-explanation",
                "content": "I guess this is a pretty readable back-tracking solution. Using `pair<int, int>` time to represent time, `time.first` is hour and `time.second` is minute.   \\n\\n Here is some corner cases you might need to think about:\\n1. Is \"01:00\" valid?\\n2. Is \"12:00\" valid?\\n3. Is \"3:60\" valid?\\n4. Is \"11:4\" valid?\\n    \\n   \\n**Code:**\\n```c++\\nclass Solution \\n{\\n    // date: 2016-09-18     location: Vista Del Lago III\\n    vector<int> hour = {1, 2, 4, 8}, minute = {1, 2, 4, 8, 16, 32};\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        helper(res, make_pair(0, 0), num, 0);\\n        return res;\\n    }\\n    \\n    void helper(vector<string>& res, pair<int, int> time, int num, int start_point) {\\n        if (num == 0) {\\n            res.push_back(to_string(time.first) +  (time.second < 10 ?  \":0\" : \":\") + to_string(time.second));\\n            return;\\n        }\\n        for (int i = start_point; i < hour.size() + minute.size(); i ++)\\n            if (i < hour.size()) {    \\n                time.first += hour[i];\\n                if (time.first < 12)     helper(res, time, num - 1, i + 1);     // \"hour\" should be less than 12.\\n                time.first -= hour[i];\\n            } else {     \\n                time.second += minute[i - hour.size()];\\n                if (time.second < 60)    helper(res, time, num - 1, i + 1);     // \"minute\" should be less than 60.\\n                time.second -= minute[i - hour.size()];\\n            }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution \\n{\\n    // date: 2016-09-18     location: Vista Del Lago III\\n    vector<int> hour = {1, 2, 4, 8}, minute = {1, 2, 4, 8, 16, 32};\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        helper(res, make_pair(0, 0), num, 0);\\n        return res;\\n    }\\n    \\n    void helper(vector<string>& res, pair<int, int> time, int num, int start_point) {\\n        if (num == 0) {\\n            res.push_back(to_string(time.first) +  (time.second < 10 ?  \":0\" : \":\") + to_string(time.second));\\n            return;\\n        }\\n        for (int i = start_point; i < hour.size() + minute.size(); i ++)\\n            if (i < hour.size()) {    \\n                time.first += hour[i];\\n                if (time.first < 12)     helper(res, time, num - 1, i + 1);     // \"hour\" should be less than 12.\\n                time.first -= hour[i];\\n            } else {     \\n                time.second += minute[i - hour.size()];\\n                if (time.second < 60)    helper(res, time, num - 1, i + 1);     // \"minute\" should be less than 60.\\n                time.second -= minute[i - hour.size()];\\n            }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88453,
                "title": "python-dfs-and-complexity-analysis",
                "content": "Similar to other solutions out there. \\n\\nThe code has `O(1)` time complexity, because all the possible watch combinations (valid or invalid) can't be more that 12 * 59.\\nRegarding space complexity, it's also `O(1)` cause the DFS will have depth of maximum `n`, which can't be more than `9` as per problem boundary.\\n\\n```\\nclass Solution(object):\\n    def readBinaryWatch(self, n):\\n        \\n        def dfs(n, hours, mins, idx):\\n            if hours >= 12 or mins > 59: return\\n            if not n:\\n                res.append(str(hours) + \":\" + \"0\" * (mins < 10) + str(mins))\\n                return\\n            for i in range(idx, 10):\\n                if i < 4: \\n                    dfs(n - 1, hours | (1 << i), mins, i + 1)\\n                else:\\n                    k = i - 4\\n                    dfs(n - 1, hours, mins | (1 << k), i + 1)\\n        \\n        res = []\\n        dfs(n, 0, 0, 0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def readBinaryWatch(self, n):\\n        \\n        def dfs(n, hours, mins, idx):\\n            if hours >= 12 or mins > 59: return\\n            if not n:\\n                res.append(str(hours) + \":\" + \"0\" * (mins < 10) + str(mins))\\n                return\\n            for i in range(idx, 10):\\n                if i < 4: \\n                    dfs(n - 1, hours | (1 << i), mins, i + 1)\\n                else:\\n                    k = i - 4\\n                    dfs(n - 1, hours, mins | (1 << k), i + 1)\\n        \\n        res = []\\n        dfs(n, 0, 0, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926686,
                "title": "easy-bit-count-solution-c",
                "content": "The ```__builtin_popcount()``` function is used to count the number of set bits in a interger.\\n```\\nclass Solution\\n{\\npublic:\\n    vector<string> readBinaryWatch(int num)\\n    {\\n        vector<string> result;\\n        \\n        for(int hours = 0; hours < 12; hours++)\\n        {\\n            for(int minute = 0; minute < 60; minute++)\\n            {\\n                string temp = \"\";\\n                if(__builtin_popcount(hours) + __builtin_popcount(minute) == num )\\n                {\\n                    temp += to_string(hours) + \":\";\\n                    \\n                    if(minute < 10)\\n                    {\\n                        temp += \"0\";\\n                    }\\n                    temp += to_string(minute);\\n                    result.push_back(temp);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```__builtin_popcount()```\n```\\nclass Solution\\n{\\npublic:\\n    vector<string> readBinaryWatch(int num)\\n    {\\n        vector<string> result;\\n        \\n        for(int hours = 0; hours < 12; hours++)\\n        {\\n            for(int minute = 0; minute < 60; minute++)\\n            {\\n                string temp = \"\";\\n                if(__builtin_popcount(hours) + __builtin_popcount(minute) == num )\\n                {\\n                    temp += to_string(hours) + \":\";\\n                    \\n                    if(minute < 10)\\n                    {\\n                        temp += \"0\";\\n                    }\\n                    temp += to_string(minute);\\n                    result.push_back(temp);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654948,
                "title": "java-simple-standard-backtracking-solution-5ms-86",
                "content": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> result = new ArrayList<>();\\n        \\n        //range 0-3 are hours and range 4-9 are minutes\\n        int[] arr = {1, 2, 4, 8, 1, 2, 4, 8, 16, 32};\\n        backtrack(arr, 0, 0, 0, num, result);\\n        return result;\\n    }\\n\\n    public void backtrack(int[] arr, int position, int hours, int minutes, int limit, List<String> result) {\\n        //when num(limit) reaches to the zero, store hours and minutes into result list\\n        if (limit == 0) {\\n            //during recursion we might get e.g 4 + 8 = 12 hours which we must skip because max hour value could be 11\\n            if(hours <= 11 && minutes <= 59) {\\n                StringBuilder builder = new StringBuilder();\\n                builder.append(hours).append(\":\").append(minutes <= 9 ? \"0\" + minutes : minutes);\\n                result.add(builder.toString());\\n            }\\n            return;\\n        }\\n\\n        //standard backtracking solution add new value do recursion and then remove it\\n        for (int i = position; i < arr.length; i++) {\\n            if (isHour(i)) hours += arr[i];\\n            else minutes += arr[i];\\n\\n            backtrack(arr, i + 1, hours, minutes, limit - 1, result);\\n\\n            if (isHour(i)) hours -= arr[i];\\n            else minutes -= arr[i];\\n        }\\n    }\\n\\n    //Simple check by range: hours or minutes\\n    public boolean isHour(int position) {\\n        return position >= 0 && position <= 3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> result = new ArrayList<>();\\n        \\n        //range 0-3 are hours and range 4-9 are minutes\\n        int[] arr = {1, 2, 4, 8, 1, 2, 4, 8, 16, 32};\\n        backtrack(arr, 0, 0, 0, num, result);\\n        return result;\\n    }\\n\\n    public void backtrack(int[] arr, int position, int hours, int minutes, int limit, List<String> result) {\\n        //when num(limit) reaches to the zero, store hours and minutes into result list\\n        if (limit == 0) {\\n            //during recursion we might get e.g 4 + 8 = 12 hours which we must skip because max hour value could be 11\\n            if(hours <= 11 && minutes <= 59) {\\n                StringBuilder builder = new StringBuilder();\\n                builder.append(hours).append(\":\").append(minutes <= 9 ? \"0\" + minutes : minutes);\\n                result.add(builder.toString());\\n            }\\n            return;\\n        }\\n\\n        //standard backtracking solution add new value do recursion and then remove it\\n        for (int i = position; i < arr.length; i++) {\\n            if (isHour(i)) hours += arr[i];\\n            else minutes += arr[i];\\n\\n            backtrack(arr, i + 1, hours, minutes, limit - 1, result);\\n\\n            if (isHour(i)) hours -= arr[i];\\n            else minutes -= arr[i];\\n        }\\n    }\\n\\n    //Simple check by range: hours or minutes\\n    public boolean isHour(int position) {\\n        return position >= 0 && position <= 3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88609,
                "title": "3m-java-recursion-solution-easy-to-understand",
                "content": "\\n```\\npublic class Solution {\\n    final int[] watch = {1,2,4,8,1,2,4,8,16,32};\\n\\t\\n    public List<String> readBinaryWatch(int num) {\\n            List<String> list = new ArrayList<String>();\\n            if(num>=0) read_recursion(num, 0, list, 0 ,0);\\n            return list;\\n    }\\n\\n    private void read_recursion(int num, int start, List<String> list, int hour, int minute){\\n    \\tif(num <= 0) {\\n    \\t    if(hour<12 && minute<60){\\n\\t    \\t        if(minute<10) list.add(hour+\":0\"+minute);\\n\\t    \\t        else list.add(hour+\":\"+minute);\\n    \\t    }\\n    \\t} else {\\n\\t            for(int i=start; i<watch.length; i++){\\n\\t    \\t\\tif(i<4) read_recursion(num-1, i+1, list, hour+watch[i], minute);\\n\\t    \\t\\telse read_recursion(num-1, i+1, list, hour, minute+watch[i]);\\n\\t            }\\n            }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    final int[] watch = {1,2,4,8,1,2,4,8,16,32};\\n\\t\\n    public List<String> readBinaryWatch(int num) {\\n            List<String> list = new ArrayList<String>();\\n            if(num>=0) read_recursion(num, 0, list, 0 ,0);\\n            return list;\\n    }\\n\\n    private void read_recursion(int num, int start, List<String> list, int hour, int minute){\\n    \\tif(num <= 0) {\\n    \\t    if(hour<12 && minute<60){\\n\\t    \\t        if(minute<10) list.add(hour+\":0\"+minute);\\n\\t    \\t        else list.add(hour+\":\"+minute);\\n    \\t    }\\n    \\t} else {\\n\\t            for(int i=start; i<watch.length; i++){\\n\\t    \\t\\tif(i<4) read_recursion(num-1, i+1, list, hour+watch[i], minute);\\n\\t    \\t\\telse read_recursion(num-1, i+1, list, hour, minute+watch[i]);\\n\\t            }\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315156,
                "title": "python-easy-to-understand-with-6-lines-of-code",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        times = []\\n        for h in range(12):\\n            for m in range(60):\\n                if (bin(h) + bin(m)).count(\\'1\\') == turnedOn:\\n                    times.append(f\\'{h}:{m:02d}\\')\\n        return times  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        times = []\\n        for h in range(12):\\n            for m in range(60):\\n                if (bin(h) + bin(m)).count(\\'1\\') == turnedOn:\\n                    times.append(f\\'{h}:{m:02d}\\')\\n        return times  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 335053,
                "title": "easy-java-solution-with-little-code",
                "content": "```\\nclass Solution {\\n    \\n    public List<String> readBinaryWatch(int num) {\\n        if (num < 0 || num > 10) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n      \\n        for (int hour = 0; hour <= 11; hour++) {\\n            for (int minute = 0; minute <= 59; minute++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If number of bits in hour + number of bits in minute equals num\\n\\t\\t\\t\\t// add to result or else do nothing.\\n                if (Integer.bitCount(hour) + Integer.bitCount(minute) == num) {\\n                    \\n                    result.add(String.format(\"%d:%02d\", hour, minute));\\n                    \\n                }\\n            }\\n        }      \\n        \\n        return result;\\n    }\\n}\\n\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> readBinaryWatch(int num) {\\n        if (num < 0 || num > 10) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n      \\n        for (int hour = 0; hour <= 11; hour++) {\\n            for (int minute = 0; minute <= 59; minute++) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// If number of bits in hour + number of bits in minute equals num\\n\\t\\t\\t\\t// add to result or else do nothing.\\n                if (Integer.bitCount(hour) + Integer.bitCount(minute) == num) {\\n                    \\n                    result.add(String.format(\"%d:%02d\", hour, minute));\\n                    \\n                }\\n            }\\n        }      \\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88522,
                "title": "python-combinations",
                "content": "Generate all possible combinations of `num` indexes in the range from 0 to 10. For example, one possible combination of 5 indexes is `{0, 1, 4, 7, 8}`, which is \"3:25\".\\n\\n```\\ndef readBinaryWatch(self, num):\\n    watch = [1,2,4,8,1,2,4,8,16,32]\\n    times = []\\n    for leds in itertools.combinations(range(len(watch)), num):\\n        h = sum(watch[i] for i in leds if i < 4)\\n        m = sum(watch[i] for i in leds if i >= 4)\\n        if h > 11 or m > 59: continue\\n        times.append(\"{}:{:02d}\".format(h, m))\\n    return times\\n```",
                "solutionTags": [],
                "code": "```\\ndef readBinaryWatch(self, num):\\n    watch = [1,2,4,8,1,2,4,8,16,32]\\n    times = []\\n    for leds in itertools.combinations(range(len(watch)), num):\\n        h = sum(watch[i] for i in leds if i < 4)\\n        m = sum(watch[i] for i in leds if i >= 4)\\n        if h > 11 or m > 59: continue\\n        times.append(\"{}:{:02d}\".format(h, m))\\n    return times\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 88564,
                "title": "simple-java-ac-solution-with-explanation",
                "content": "The logic is based on DFS, to generate nCk. Represent all the lights by an array of n = 10.\\n    Then generate all possible values of the array by setting all possible k bits.\\n    Convert these array positions into their corresponding times, making sure to handle any time that exceeds hours >= 12 and minutes > 59\\n\\nFor A[10] with indices 0 to 9\\n\\n0 1 2 3 represents the Hour lights\\n4 5 6 7 8 9 represents the Minute lights\\n\\n```\\npublic static List<String> readBinaryWatch(int num) {\\n        List<String> list = new ArrayList<>();\\n        dfs(new int[10], 0, 0, list, num);\\n        return list;\\n    }\\n\\n    private static void dfs(int[] a, int i, int k, List<String> list, int num) {\\n        if(k == num) {\\n            String res = getTime(a);\\n            if(res != null)\\n                list.add(res);\\n            return;\\n        }\\n        if(i == a.length) {\\n            return;\\n        }\\n        a[i] = 0;\\n        dfs(a, i+1, k, list, num);\\n\\n        a[i] = 1;\\n        dfs(a, i+1, k+1, list, num);\\n\\n        a[i] = 0;\\n    }\\n\\n    private static String getTime(int[] a) {\\n        int hours = 0;\\n        for(int i = 0; i < 4; i++) {\\n            if(a[i] == 1) {\\n                hours = hours + (int)Math.pow(2, i);\\n            }\\n        }\\n\\n        int minutes = 0;\\n        for(int i = 4; i < 10; i++) {\\n            if(a[i] == 1) {\\n                minutes = minutes + (int)Math.pow(2, i-4);\\n            }\\n        }\\n        String min = \"\" + minutes;\\n        if(minutes  <  10)\\n            min = \"0\" + min;\\n        String res = hours + \":\" + min;\\n        if(hours  >= 12  ||  minutes  >=  60)\\n            return null;\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic static List<String> readBinaryWatch(int num) {\\n        List<String> list = new ArrayList<>();\\n        dfs(new int[10], 0, 0, list, num);\\n        return list;\\n    }\\n\\n    private static void dfs(int[] a, int i, int k, List<String> list, int num) {\\n        if(k == num) {\\n            String res = getTime(a);\\n            if(res != null)\\n                list.add(res);\\n            return;\\n        }\\n        if(i == a.length) {\\n            return;\\n        }\\n        a[i] = 0;\\n        dfs(a, i+1, k, list, num);\\n\\n        a[i] = 1;\\n        dfs(a, i+1, k+1, list, num);\\n\\n        a[i] = 0;\\n    }\\n\\n    private static String getTime(int[] a) {\\n        int hours = 0;\\n        for(int i = 0; i < 4; i++) {\\n            if(a[i] == 1) {\\n                hours = hours + (int)Math.pow(2, i);\\n            }\\n        }\\n\\n        int minutes = 0;\\n        for(int i = 4; i < 10; i++) {\\n            if(a[i] == 1) {\\n                minutes = minutes + (int)Math.pow(2, i-4);\\n            }\\n        }\\n        String min = \"\" + minutes;\\n        if(minutes  <  10)\\n            min = \"0\" + min;\\n        String res = hours + \":\" + min;\\n        if(hours  >= 12  ||  minutes  >=  60)\\n            return null;\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032126,
                "title": "o-1-time-complexity-java-solution-with-algorithm-explained",
                "content": "**Algorithm**\\n* Initalise a ArrayList in which you will add all the permutations.\\n* Start a 2d loop. First loop will be for hours and second will be for minutes.\\n* Java as a function \"Integer.bitCount\". It returns the count of the number of one-bits in the two\\u2019s complement binary representation of an int value. This function is sometimes referred to as the population count. Simply add hour and minute bit count and check if it is equal to given num.\\n* If the miute is less than 10, then add \\'0\\' before minute place in list. \\n* Else add it directly. \\n\\nTime Complexity: O(1) \\n```\\npublic List<String> readBinaryWatch(int turnedOn) {\\n        ArrayList<String> result = new ArrayList();\\n        for(int hour=0; hour<12; hour++){\\n            for(int minute=0; minute<60; minute++){\\n                if(Integer.bitCount(hour) + Integer.bitCount(minute) == turnedOn){\\n                    if(minute<10) result.add(String.format(\"%d:0%d\",hour,minute));\\n                    else result.add(String.format(\"%d:%d\",hour,minute));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\\n**Please upvote if it helped you**\\n*Feel free to ask any quesstions/query if any*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> readBinaryWatch(int turnedOn) {\\n        ArrayList<String> result = new ArrayList();\\n        for(int hour=0; hour<12; hour++){\\n            for(int minute=0; minute<60; minute++){\\n                if(Integer.bitCount(hour) + Integer.bitCount(minute) == turnedOn){\\n                    if(minute<10) result.add(String.format(\"%d:0%d\",hour,minute));\\n                    else result.add(String.format(\"%d:%d\",hour,minute));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494251,
                "title": "javascript-brute-force",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {string[]}\\n */\\nvar readBinaryWatch = function(num) {\\n  const times = [];\\n  for (let h = 0; h < 12; h++) {\\n    for (let m = 0; m < 60; m++) {\\n      const hOnes = h ? h.toString(2).match(/1/g).length : 0;\\n      const mOnes = m ? m.toString(2).match(/1/g).length : 0;\\n      if (hOnes + mOnes === num) {\\n        times.push(`${h}:${m < 10 ? `0${m}` : m}`);\\n      }\\n    }\\n  }\\n  return times;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string[]}\\n */\\nvar readBinaryWatch = function(num) {\\n  const times = [];\\n  for (let h = 0; h < 12; h++) {\\n    for (let m = 0; m < 60; m++) {\\n      const hOnes = h ? h.toString(2).match(/1/g).length : 0;\\n      const mOnes = m ? m.toString(2).match(/1/g).length : 0;\\n      if (hOnes + mOnes === num) {\\n        times.push(`${h}:${m < 10 ? `0${m}` : m}`);\\n      }\\n    }\\n  }\\n  return times;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602245,
                "title": "100-faster-please-upvote-for-my-work-not-useful-but-really-take-a-time",
                "content": "please Upvote for hardwork\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int n) {\\n        vector<string>ans;\\n        if(n==1)\\n        {\\n            ans.push_back(\"0:01\");\\n            ans.push_back(\"0:02\");\\n            ans.push_back(\"0:04\");\\n            ans.push_back(\"0:08\");\\n            ans.push_back(\"0:16\");\\n            ans.push_back(\"0:32\");\\n            ans.push_back(\"1:00\");\\n            ans.push_back(\"2:00\");\\n            ans.push_back(\"4:00\");\\n            ans.push_back(\"8:00\");\\n            \\n        }\\n        else if(n==2)\\n        {\\n        ans.push_back(\"0:03\");\\n            ans.push_back(\"0:05\");\\n            ans.push_back(\"0:06\");\\n            ans.push_back(\"0:09\");\\n            ans.push_back(\"0:10\");\\n            ans.push_back(\"0:12\");\\n            ans.push_back(\"0:17\");\\n            ans.push_back(\"0:18\");\\n            ans.push_back(\"0:20\");\\n            ans.push_back(\"0:24\");\\n            ans.push_back(\"0:33\");\\n            ans.push_back(\"0:34\");\\n            ans.push_back(\"0:36\");\\n            ans.push_back(\"0:40\");\\n             ans.push_back(\"0:48\");\\n            ans.push_back(\"1:01\");\\n            ans.push_back(\"1:02\");\\n            ans.push_back(\"1:04\");\\n             ans.push_back(\"1:08\");\\n            ans.push_back(\"1:16\");\\n            ans.push_back(\"1:32\");\\n            ans.push_back(\"2:01\");\\n            ans.push_back(\"2:02\");\\n            ans.push_back(\"2:04\");\\n             ans.push_back(\"2:08\");\\n            ans.push_back(\"2:16\");\\n            ans.push_back(\"2:32\");\\n            ans.push_back(\"3:00\");\\n             ans.push_back(\"4:01\");\\n            ans.push_back(\"4:02\");\\n            ans.push_back(\"4:04\");\\n             ans.push_back(\"4:08\");\\n            ans.push_back(\"4:16\");\\n            ans.push_back(\"4:32\");\\n            ans.push_back(\"5:00\");\\n            ans.push_back(\"6:00\");\\n            ans.push_back(\"8:01\");\\n            ans.push_back(\"8:02\");\\n            ans.push_back(\"8:04\");\\n             ans.push_back(\"8:08\");\\n            ans.push_back(\"8:16\");\\n            ans.push_back(\"8:32\");\\n            ans.push_back(\"9:00\");\\n            ans.push_back(\"10:00\");\\n            \\n        }\\n        else if(n==3)\\n        {\\n            ans={\"0:07\",\"0:11\",\"0:13\",\"0:14\",\"0:19\",\"0:21\",\"0:22\",\"0:25\",\"0:26\",\"0:28\",\"0:35\",\"0:37\",\"0:38\",\"0:41\",\"0:42\",\"0:44\",\"0:49\",\"0:50\",\"0:52\",\"0:56\",\"1:03\",\"1:05\",\"1:06\",\"1:09\",\"1:10\",\"1:12\",\"1:17\",\"1:18\",\"1:20\",\"1:24\",\"1:33\",\"1:34\",\"1:36\",\"1:40\",\"1:48\",\"2:03\",\"2:05\",\"2:06\",\"2:09\",\"2:10\",\"2:12\",\"2:17\",\"2:18\",\"2:20\",\"2:24\",\"2:33\",\"2:34\",\"2:36\",\"2:40\",\"2:48\",\"3:01\",\"3:02\",\"3:04\",\"3:08\",\"3:16\",\"3:32\",\"4:03\",\"4:05\",\"4:06\",\"4:09\",\"4:10\",\"4:12\",\"4:17\",\"4:18\",\"4:20\",\"4:24\",\"4:33\",\"4:34\",\"4:36\",\"4:40\",\"4:48\",\"5:01\",\"5:02\",\"5:04\",\"5:08\",\"5:16\",\"5:32\",\"6:01\",\"6:02\",\"6:04\",\"6:08\",\"6:16\",\"6:32\",\"7:00\",\"8:03\",\"8:05\",\"8:06\",\"8:09\",\"8:10\",\"8:12\",\"8:17\",\"8:18\",\"8:20\",\"8:24\",\"8:33\",\"8:34\",\"8:36\",\"8:40\",\"8:48\",\"9:01\",\"9:02\",\"9:04\",\"9:08\",\"9:16\",\"9:32\",\"10:01\",\"10:02\",\"10:04\",\"10:08\",\"10:16\",\"10:32\",\"11:00\"};\\n        }\\n        else if(n==4)\\n        {\\n            ans={\"0:15\",\"0:23\",\"0:27\",\"0:29\",\"0:30\",\"0:39\",\"0:43\",\"0:45\",\"0:46\",\"0:51\",\"0:53\",\"0:54\",\"0:57\",\"0:58\",\"1:07\",\"1:11\",\"1:13\",\"1:14\",\"1:19\",\"1:21\",\"1:22\",\"1:25\",\"1:26\",\"1:28\",\"1:35\",\"1:37\",\"1:38\",\"1:41\",\"1:42\",\"1:44\",\"1:49\",\"1:50\",\"1:52\",\"1:56\",\"2:07\",\"2:11\",\"2:13\",\"2:14\",\"2:19\",\"2:21\",\"2:22\",\"2:25\",\"2:26\",\"2:28\",\"2:35\",\"2:37\",\"2:38\",\"2:41\",\"2:42\",\"2:44\",\"2:49\",\"2:50\",\"2:52\",\"2:56\",\"3:03\",\"3:05\",\"3:06\",\"3:09\",\"3:10\",\"3:12\",\"3:17\",\"3:18\",\"3:20\",\"3:24\",\"3:33\",\"3:34\",\"3:36\",\"3:40\",\"3:48\",\"4:07\",\"4:11\",\"4:13\",\"4:14\",\"4:19\",\"4:21\",\"4:22\",\"4:25\",\"4:26\",\"4:28\",\"4:35\",\"4:37\",\"4:38\",\"4:41\",\"4:42\",\"4:44\",\"4:49\",\"4:50\",\"4:52\",\"4:56\",\"5:03\",\"5:05\",\"5:06\",\"5:09\",\"5:10\",\"5:12\",\"5:17\",\"5:18\",\"5:20\",\"5:24\",\"5:33\",\"5:34\",\"5:36\",\"5:40\",\"5:48\",\"6:03\",\"6:05\",\"6:06\",\"6:09\",\"6:10\",\"6:12\",\"6:17\",\"6:18\",\"6:20\",\"6:24\",\"6:33\",\"6:34\",\"6:36\",\"6:40\",\"6:48\",\"7:01\",\"7:02\",\"7:04\",\"7:08\",\"7:16\",\"7:32\",\"8:07\",\"8:11\",\"8:13\",\"8:14\",\"8:19\",\"8:21\",\"8:22\",\"8:25\",\"8:26\",\"8:28\",\"8:35\",\"8:37\",\"8:38\",\"8:41\",\"8:42\",\"8:44\",\"8:49\",\"8:50\",\"8:52\",\"8:56\",\"9:03\",\"9:05\",\"9:06\",\"9:09\",\"9:10\",\"9:12\",\"9:17\",\"9:18\",\"9:20\",\"9:24\",\"9:33\",\"9:34\",\"9:36\",\"9:40\",\"9:48\",\"10:03\",\"10:05\",\"10:06\",\"10:09\",\"10:10\",\"10:12\",\"10:17\",\"10:18\",\"10:20\",\"10:24\",\"10:33\",\"10:34\",\"10:36\",\"10:40\",\"10:48\",\"11:01\",\"11:02\",\"11:04\",\"11:08\",\"11:16\",\"11:32\"};\\n        }\\n        else if(n==5)\\n        {\\n            ans={\"0:31\",\"0:47\",\"0:55\",\"0:59\",\"1:15\",\"1:23\",\"1:27\",\"1:29\",\"1:30\",\"1:39\",\"1:43\",\"1:45\",\"1:46\",\"1:51\",\"1:53\",\"1:54\",\"1:57\",\"1:58\",\"2:15\",\"2:23\",\"2:27\",\"2:29\",\"2:30\",\"2:39\",\"2:43\",\"2:45\",\"2:46\",\"2:51\",\"2:53\",\"2:54\",\"2:57\",\"2:58\",\"3:07\",\"3:11\",\"3:13\",\"3:14\",\"3:19\",\"3:21\",\"3:22\",\"3:25\",\"3:26\",\"3:28\",\"3:35\",\"3:37\",\"3:38\",\"3:41\",\"3:42\",\"3:44\",\"3:49\",\"3:50\",\"3:52\",\"3:56\",\"4:15\",\"4:23\",\"4:27\",\"4:29\",\"4:30\",\"4:39\",\"4:43\",\"4:45\",\"4:46\",\"4:51\",\"4:53\",\"4:54\",\"4:57\",\"4:58\",\"5:07\",\"5:11\",\"5:13\",\"5:14\",\"5:19\",\"5:21\",\"5:22\",\"5:25\",\"5:26\",\"5:28\",\"5:35\",\"5:37\",\"5:38\",\"5:41\",\"5:42\",\"5:44\",\"5:49\",\"5:50\",\"5:52\",\"5:56\",\"6:07\",\"6:11\",\"6:13\",\"6:14\",\"6:19\",\"6:21\",\"6:22\",\"6:25\",\"6:26\",\"6:28\",\"6:35\",\"6:37\",\"6:38\",\"6:41\",\"6:42\",\"6:44\",\"6:49\",\"6:50\",\"6:52\",\"6:56\",\"7:03\",\"7:05\",\"7:06\",\"7:09\",\"7:10\",\"7:12\",\"7:17\",\"7:18\",\"7:20\",\"7:24\",\"7:33\",\"7:34\",\"7:36\",\"7:40\",\"7:48\",\"8:15\",\"8:23\",\"8:27\",\"8:29\",\"8:30\",\"8:39\",\"8:43\",\"8:45\",\"8:46\",\"8:51\",\"8:53\",\"8:54\",\"8:57\",\"8:58\",\"9:07\",\"9:11\",\"9:13\",\"9:14\",\"9:19\",\"9:21\",\"9:22\",\"9:25\",\"9:26\",\"9:28\",\"9:35\",\"9:37\",\"9:38\",\"9:41\",\"9:42\",\"9:44\",\"9:49\",\"9:50\",\"9:52\",\"9:56\",\"10:07\",\"10:11\",\"10:13\",\"10:14\",\"10:19\",\"10:21\",\"10:22\",\"10:25\",\"10:26\",\"10:28\",\"10:35\",\"10:37\",\"10:38\",\"10:41\",\"10:42\",\"10:44\",\"10:49\",\"10:50\",\"10:52\",\"10:56\",\"11:03\",\"11:05\",\"11:06\",\"11:09\",\"11:10\",\"11:12\",\"11:17\",\"11:18\",\"11:20\",\"11:24\",\"11:33\",\"11:34\",\"11:36\",\"11:40\",\"11:48\"};\\n            \\n        }\\n        else if(n==6)\\n        {\\n            ans={\"1:31\",\"1:47\",\"1:55\",\"1:59\",\"2:31\",\"2:47\",\"2:55\",\"2:59\",\"3:15\",\"3:23\",\"3:27\",\"3:29\",\"3:30\",\"3:39\",\"3:43\",\"3:45\",\"3:46\",\"3:51\",\"3:53\",\"3:54\",\"3:57\",\"3:58\",\"4:31\",\"4:47\",\"4:55\",\"4:59\",\"5:15\",\"5:23\",\"5:27\",\"5:29\",\"5:30\",\"5:39\",\"5:43\",\"5:45\",\"5:46\",\"5:51\",\"5:53\",\"5:54\",\"5:57\",\"5:58\",\"6:15\",\"6:23\",\"6:27\",\"6:29\",\"6:30\",\"6:39\",\"6:43\",\"6:45\",\"6:46\",\"6:51\",\"6:53\",\"6:54\",\"6:57\",\"6:58\",\"7:07\",\"7:11\",\"7:13\",\"7:14\",\"7:19\",\"7:21\",\"7:22\",\"7:25\",\"7:26\",\"7:28\",\"7:35\",\"7:37\",\"7:38\",\"7:41\",\"7:42\",\"7:44\",\"7:49\",\"7:50\",\"7:52\",\"7:56\",\"8:31\",\"8:47\",\"8:55\",\"8:59\",\"9:15\",\"9:23\",\"9:27\",\"9:29\",\"9:30\",\"9:39\",\"9:43\",\"9:45\",\"9:46\",\"9:51\",\"9:53\",\"9:54\",\"9:57\",\"9:58\",\"10:15\",\"10:23\",\"10:27\",\"10:29\",\"10:30\",\"10:39\",\"10:43\",\"10:45\",\"10:46\",\"10:51\",\"10:53\",\"10:54\",\"10:57\",\"10:58\",\"11:07\",\"11:11\",\"11:13\",\"11:14\",\"11:19\",\"11:21\",\"11:22\",\"11:25\",\"11:26\",\"11:28\",\"11:35\",\"11:37\",\"11:38\",\"11:41\",\"11:42\",\"11:44\",\"11:49\",\"11:50\",\"11:52\",\"11:56\"};\\n            \\n        }\\n        else if(n==7)\\n        {\\n            ans={\"3:31\",\"3:47\",\"3:55\",\"3:59\",\"5:31\",\"5:47\",\"5:55\",\"5:59\",\"6:31\",\"6:47\",\"6:55\",\"6:59\",\"7:15\",\"7:23\",\"7:27\",\"7:29\",\"7:30\",\"7:39\",\"7:43\",\"7:45\",\"7:46\",\"7:51\",\"7:53\",\"7:54\",\"7:57\",\"7:58\",\"9:31\",\"9:47\",\"9:55\",\"9:59\",\"10:31\",\"10:47\",\"10:55\",\"10:59\",\"11:15\",\"11:23\",\"11:27\",\"11:29\",\"11:30\",\"11:39\",\"11:43\",\"11:45\",\"11:46\",\"11:51\",\"11:53\",\"11:54\",\"11:57\",\"11:58\"};\\n        }\\n        else if(n==8)\\n        {\\n            ans={\"7:31\",\"7:47\",\"7:55\",\"7:59\",\"11:31\",\"11:47\",\"11:55\",\"11:59\"};\\n        }\\n        else if(n==10||n==9)\\n        {\\n            ans={};\\n        }\\n        else if(n==0)\\n        {\\n            ans={\"0:00\"};\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int n) {\\n        vector<string>ans;\\n        if(n==1)\\n        {\\n            ans.push_back(\"0:01\");\\n            ans.push_back(\"0:02\");\\n            ans.push_back(\"0:04\");\\n            ans.push_back(\"0:08\");\\n            ans.push_back(\"0:16\");\\n            ans.push_back(\"0:32\");\\n            ans.push_back(\"1:00\");\\n            ans.push_back(\"2:00\");\\n            ans.push_back(\"4:00\");\\n            ans.push_back(\"8:00\");\\n            \\n        }\\n        else if(n==2)\\n        {\\n        ans.push_back(\"0:03\");\\n            ans.push_back(\"0:05\");\\n            ans.push_back(\"0:06\");\\n            ans.push_back(\"0:09\");\\n            ans.push_back(\"0:10\");\\n            ans.push_back(\"0:12\");\\n            ans.push_back(\"0:17\");\\n            ans.push_back(\"0:18\");\\n            ans.push_back(\"0:20\");\\n            ans.push_back(\"0:24\");\\n            ans.push_back(\"0:33\");\\n            ans.push_back(\"0:34\");\\n            ans.push_back(\"0:36\");\\n            ans.push_back(\"0:40\");\\n             ans.push_back(\"0:48\");\\n            ans.push_back(\"1:01\");\\n            ans.push_back(\"1:02\");\\n            ans.push_back(\"1:04\");\\n             ans.push_back(\"1:08\");\\n            ans.push_back(\"1:16\");\\n            ans.push_back(\"1:32\");\\n            ans.push_back(\"2:01\");\\n            ans.push_back(\"2:02\");\\n            ans.push_back(\"2:04\");\\n             ans.push_back(\"2:08\");\\n            ans.push_back(\"2:16\");\\n            ans.push_back(\"2:32\");\\n            ans.push_back(\"3:00\");\\n             ans.push_back(\"4:01\");\\n            ans.push_back(\"4:02\");\\n            ans.push_back(\"4:04\");\\n             ans.push_back(\"4:08\");\\n            ans.push_back(\"4:16\");\\n            ans.push_back(\"4:32\");\\n            ans.push_back(\"5:00\");\\n            ans.push_back(\"6:00\");\\n            ans.push_back(\"8:01\");\\n            ans.push_back(\"8:02\");\\n            ans.push_back(\"8:04\");\\n             ans.push_back(\"8:08\");\\n            ans.push_back(\"8:16\");\\n            ans.push_back(\"8:32\");\\n            ans.push_back(\"9:00\");\\n            ans.push_back(\"10:00\");\\n            \\n        }\\n        else if(n==3)\\n        {\\n            ans={\"0:07\",\"0:11\",\"0:13\",\"0:14\",\"0:19\",\"0:21\",\"0:22\",\"0:25\",\"0:26\",\"0:28\",\"0:35\",\"0:37\",\"0:38\",\"0:41\",\"0:42\",\"0:44\",\"0:49\",\"0:50\",\"0:52\",\"0:56\",\"1:03\",\"1:05\",\"1:06\",\"1:09\",\"1:10\",\"1:12\",\"1:17\",\"1:18\",\"1:20\",\"1:24\",\"1:33\",\"1:34\",\"1:36\",\"1:40\",\"1:48\",\"2:03\",\"2:05\",\"2:06\",\"2:09\",\"2:10\",\"2:12\",\"2:17\",\"2:18\",\"2:20\",\"2:24\",\"2:33\",\"2:34\",\"2:36\",\"2:40\",\"2:48\",\"3:01\",\"3:02\",\"3:04\",\"3:08\",\"3:16\",\"3:32\",\"4:03\",\"4:05\",\"4:06\",\"4:09\",\"4:10\",\"4:12\",\"4:17\",\"4:18\",\"4:20\",\"4:24\",\"4:33\",\"4:34\",\"4:36\",\"4:40\",\"4:48\",\"5:01\",\"5:02\",\"5:04\",\"5:08\",\"5:16\",\"5:32\",\"6:01\",\"6:02\",\"6:04\",\"6:08\",\"6:16\",\"6:32\",\"7:00\",\"8:03\",\"8:05\",\"8:06\",\"8:09\",\"8:10\",\"8:12\",\"8:17\",\"8:18\",\"8:20\",\"8:24\",\"8:33\",\"8:34\",\"8:36\",\"8:40\",\"8:48\",\"9:01\",\"9:02\",\"9:04\",\"9:08\",\"9:16\",\"9:32\",\"10:01\",\"10:02\",\"10:04\",\"10:08\",\"10:16\",\"10:32\",\"11:00\"};\\n        }\\n        else if(n==4)\\n        {\\n            ans={\"0:15\",\"0:23\",\"0:27\",\"0:29\",\"0:30\",\"0:39\",\"0:43\",\"0:45\",\"0:46\",\"0:51\",\"0:53\",\"0:54\",\"0:57\",\"0:58\",\"1:07\",\"1:11\",\"1:13\",\"1:14\",\"1:19\",\"1:21\",\"1:22\",\"1:25\",\"1:26\",\"1:28\",\"1:35\",\"1:37\",\"1:38\",\"1:41\",\"1:42\",\"1:44\",\"1:49\",\"1:50\",\"1:52\",\"1:56\",\"2:07\",\"2:11\",\"2:13\",\"2:14\",\"2:19\",\"2:21\",\"2:22\",\"2:25\",\"2:26\",\"2:28\",\"2:35\",\"2:37\",\"2:38\",\"2:41\",\"2:42\",\"2:44\",\"2:49\",\"2:50\",\"2:52\",\"2:56\",\"3:03\",\"3:05\",\"3:06\",\"3:09\",\"3:10\",\"3:12\",\"3:17\",\"3:18\",\"3:20\",\"3:24\",\"3:33\",\"3:34\",\"3:36\",\"3:40\",\"3:48\",\"4:07\",\"4:11\",\"4:13\",\"4:14\",\"4:19\",\"4:21\",\"4:22\",\"4:25\",\"4:26\",\"4:28\",\"4:35\",\"4:37\",\"4:38\",\"4:41\",\"4:42\",\"4:44\",\"4:49\",\"4:50\",\"4:52\",\"4:56\",\"5:03\",\"5:05\",\"5:06\",\"5:09\",\"5:10\",\"5:12\",\"5:17\",\"5:18\",\"5:20\",\"5:24\",\"5:33\",\"5:34\",\"5:36\",\"5:40\",\"5:48\",\"6:03\",\"6:05\",\"6:06\",\"6:09\",\"6:10\",\"6:12\",\"6:17\",\"6:18\",\"6:20\",\"6:24\",\"6:33\",\"6:34\",\"6:36\",\"6:40\",\"6:48\",\"7:01\",\"7:02\",\"7:04\",\"7:08\",\"7:16\",\"7:32\",\"8:07\",\"8:11\",\"8:13\",\"8:14\",\"8:19\",\"8:21\",\"8:22\",\"8:25\",\"8:26\",\"8:28\",\"8:35\",\"8:37\",\"8:38\",\"8:41\",\"8:42\",\"8:44\",\"8:49\",\"8:50\",\"8:52\",\"8:56\",\"9:03\",\"9:05\",\"9:06\",\"9:09\",\"9:10\",\"9:12\",\"9:17\",\"9:18\",\"9:20\",\"9:24\",\"9:33\",\"9:34\",\"9:36\",\"9:40\",\"9:48\",\"10:03\",\"10:05\",\"10:06\",\"10:09\",\"10:10\",\"10:12\",\"10:17\",\"10:18\",\"10:20\",\"10:24\",\"10:33\",\"10:34\",\"10:36\",\"10:40\",\"10:48\",\"11:01\",\"11:02\",\"11:04\",\"11:08\",\"11:16\",\"11:32\"};\\n        }\\n        else if(n==5)\\n        {\\n            ans={\"0:31\",\"0:47\",\"0:55\",\"0:59\",\"1:15\",\"1:23\",\"1:27\",\"1:29\",\"1:30\",\"1:39\",\"1:43\",\"1:45\",\"1:46\",\"1:51\",\"1:53\",\"1:54\",\"1:57\",\"1:58\",\"2:15\",\"2:23\",\"2:27\",\"2:29\",\"2:30\",\"2:39\",\"2:43\",\"2:45\",\"2:46\",\"2:51\",\"2:53\",\"2:54\",\"2:57\",\"2:58\",\"3:07\",\"3:11\",\"3:13\",\"3:14\",\"3:19\",\"3:21\",\"3:22\",\"3:25\",\"3:26\",\"3:28\",\"3:35\",\"3:37\",\"3:38\",\"3:41\",\"3:42\",\"3:44\",\"3:49\",\"3:50\",\"3:52\",\"3:56\",\"4:15\",\"4:23\",\"4:27\",\"4:29\",\"4:30\",\"4:39\",\"4:43\",\"4:45\",\"4:46\",\"4:51\",\"4:53\",\"4:54\",\"4:57\",\"4:58\",\"5:07\",\"5:11\",\"5:13\",\"5:14\",\"5:19\",\"5:21\",\"5:22\",\"5:25\",\"5:26\",\"5:28\",\"5:35\",\"5:37\",\"5:38\",\"5:41\",\"5:42\",\"5:44\",\"5:49\",\"5:50\",\"5:52\",\"5:56\",\"6:07\",\"6:11\",\"6:13\",\"6:14\",\"6:19\",\"6:21\",\"6:22\",\"6:25\",\"6:26\",\"6:28\",\"6:35\",\"6:37\",\"6:38\",\"6:41\",\"6:42\",\"6:44\",\"6:49\",\"6:50\",\"6:52\",\"6:56\",\"7:03\",\"7:05\",\"7:06\",\"7:09\",\"7:10\",\"7:12\",\"7:17\",\"7:18\",\"7:20\",\"7:24\",\"7:33\",\"7:34\",\"7:36\",\"7:40\",\"7:48\",\"8:15\",\"8:23\",\"8:27\",\"8:29\",\"8:30\",\"8:39\",\"8:43\",\"8:45\",\"8:46\",\"8:51\",\"8:53\",\"8:54\",\"8:57\",\"8:58\",\"9:07\",\"9:11\",\"9:13\",\"9:14\",\"9:19\",\"9:21\",\"9:22\",\"9:25\",\"9:26\",\"9:28\",\"9:35\",\"9:37\",\"9:38\",\"9:41\",\"9:42\",\"9:44\",\"9:49\",\"9:50\",\"9:52\",\"9:56\",\"10:07\",\"10:11\",\"10:13\",\"10:14\",\"10:19\",\"10:21\",\"10:22\",\"10:25\",\"10:26\",\"10:28\",\"10:35\",\"10:37\",\"10:38\",\"10:41\",\"10:42\",\"10:44\",\"10:49\",\"10:50\",\"10:52\",\"10:56\",\"11:03\",\"11:05\",\"11:06\",\"11:09\",\"11:10\",\"11:12\",\"11:17\",\"11:18\",\"11:20\",\"11:24\",\"11:33\",\"11:34\",\"11:36\",\"11:40\",\"11:48\"};\\n            \\n        }\\n        else if(n==6)\\n        {\\n            ans={\"1:31\",\"1:47\",\"1:55\",\"1:59\",\"2:31\",\"2:47\",\"2:55\",\"2:59\",\"3:15\",\"3:23\",\"3:27\",\"3:29\",\"3:30\",\"3:39\",\"3:43\",\"3:45\",\"3:46\",\"3:51\",\"3:53\",\"3:54\",\"3:57\",\"3:58\",\"4:31\",\"4:47\",\"4:55\",\"4:59\",\"5:15\",\"5:23\",\"5:27\",\"5:29\",\"5:30\",\"5:39\",\"5:43\",\"5:45\",\"5:46\",\"5:51\",\"5:53\",\"5:54\",\"5:57\",\"5:58\",\"6:15\",\"6:23\",\"6:27\",\"6:29\",\"6:30\",\"6:39\",\"6:43\",\"6:45\",\"6:46\",\"6:51\",\"6:53\",\"6:54\",\"6:57\",\"6:58\",\"7:07\",\"7:11\",\"7:13\",\"7:14\",\"7:19\",\"7:21\",\"7:22\",\"7:25\",\"7:26\",\"7:28\",\"7:35\",\"7:37\",\"7:38\",\"7:41\",\"7:42\",\"7:44\",\"7:49\",\"7:50\",\"7:52\",\"7:56\",\"8:31\",\"8:47\",\"8:55\",\"8:59\",\"9:15\",\"9:23\",\"9:27\",\"9:29\",\"9:30\",\"9:39\",\"9:43\",\"9:45\",\"9:46\",\"9:51\",\"9:53\",\"9:54\",\"9:57\",\"9:58\",\"10:15\",\"10:23\",\"10:27\",\"10:29\",\"10:30\",\"10:39\",\"10:43\",\"10:45\",\"10:46\",\"10:51\",\"10:53\",\"10:54\",\"10:57\",\"10:58\",\"11:07\",\"11:11\",\"11:13\",\"11:14\",\"11:19\",\"11:21\",\"11:22\",\"11:25\",\"11:26\",\"11:28\",\"11:35\",\"11:37\",\"11:38\",\"11:41\",\"11:42\",\"11:44\",\"11:49\",\"11:50\",\"11:52\",\"11:56\"};\\n            \\n        }\\n        else if(n==7)\\n        {\\n            ans={\"3:31\",\"3:47\",\"3:55\",\"3:59\",\"5:31\",\"5:47\",\"5:55\",\"5:59\",\"6:31\",\"6:47\",\"6:55\",\"6:59\",\"7:15\",\"7:23\",\"7:27\",\"7:29\",\"7:30\",\"7:39\",\"7:43\",\"7:45\",\"7:46\",\"7:51\",\"7:53\",\"7:54\",\"7:57\",\"7:58\",\"9:31\",\"9:47\",\"9:55\",\"9:59\",\"10:31\",\"10:47\",\"10:55\",\"10:59\",\"11:15\",\"11:23\",\"11:27\",\"11:29\",\"11:30\",\"11:39\",\"11:43\",\"11:45\",\"11:46\",\"11:51\",\"11:53\",\"11:54\",\"11:57\",\"11:58\"};\\n        }\\n        else if(n==8)\\n        {\\n            ans={\"7:31\",\"7:47\",\"7:55\",\"7:59\",\"11:31\",\"11:47\",\"11:55\",\"11:59\"};\\n        }\\n        else if(n==10||n==9)\\n        {\\n            ans={};\\n        }\\n        else if(n==0)\\n        {\\n            ans={\"0:00\"};\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771554,
                "title": "backtracking-with-dfs-no-bitmasking",
                "content": "```\\nclass Solution(object):    \\n    def readBinaryWatch(self, num):\\n        def dfs(LEDS, idx, hrs, mins, n):\\n            # base cases\\n            if hrs >= 12 or mins >= 60:\\n                return\\n            if n == 0:\\n                time = str(hrs) + \":\" + \"0\"*(mins<10) + str(mins)\\n                result.append(time)\\n                return\\n\\n            if idx < len(LEDS):\\n                if idx <= 3:  # handle hours\\n                    dfs(LEDS, idx+1, hrs + LEDS[idx], mins, n-1)\\n                else:  # handle minutes\\n                    dfs(LEDS, idx+1, hrs, mins + LEDS[idx], n-1)\\n                dfs(LEDS, idx+1, hrs, mins, n)\\n        result = []\\n        LEDS = [\\n            8, 4, 2, 1,  # top row of watch\\n            32, 16, 8, 4, 2, 1 # bottom row of watch\\n        ]\\n        dfs(LEDS, 0, 0, 0, num)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):    \\n    def readBinaryWatch(self, num):\\n        def dfs(LEDS, idx, hrs, mins, n):\\n            # base cases\\n            if hrs >= 12 or mins >= 60:\\n                return\\n            if n == 0:\\n                time = str(hrs) + \":\" + \"0\"*(mins<10) + str(mins)\\n                result.append(time)\\n                return\\n\\n            if idx < len(LEDS):\\n                if idx <= 3:  # handle hours\\n                    dfs(LEDS, idx+1, hrs + LEDS[idx], mins, n-1)\\n                else:  # handle minutes\\n                    dfs(LEDS, idx+1, hrs, mins + LEDS[idx], n-1)\\n                dfs(LEDS, idx+1, hrs, mins, n)\\n        result = []\\n        LEDS = [\\n            8, 4, 2, 1,  # top row of watch\\n            32, 16, 8, 4, 2, 1 # bottom row of watch\\n        ]\\n        dfs(LEDS, 0, 0, 0, num)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258559,
                "title": "401-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize an empty list to store the output.\\n2. Loop through all possible combinations of hours and minutes from 0 to 11 and 0 to 59 respectively.\\n3. For each combination, count the number of set bits in the binary representation of hours and minutes by using the count() method of the string representation of the binary number.\\n4. Check if the total number of set bits equals the input parameter turnedOn.\\n5. If it does, format the hours and minutes into a string with the required format of \"HH:MM\" and append it to the output list.\\n6. Return the output list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        output = []\\n        # Loop through all possible combinations of hours and minutes and count the number of set bits\\n        for h in range(12):\\n            for m in range(60):\\n                if bin(h).count(\\'1\\') + bin(m).count(\\'1\\') == turnedOn:  # Check if the number of set bits in hours and minutes equals the target number\\n                    output.append(f\"{h}:{m:02d}\")  # Add the valid combination of hours and minutes to the output list\\n        return output\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        output = []\\n        # Loop through all possible combinations of hours and minutes and count the number of set bits\\n        for h in range(12):\\n            for m in range(60):\\n                if bin(h).count(\\'1\\') + bin(m).count(\\'1\\') == turnedOn:  # Check if the number of set bits in hours and minutes equals the target number\\n                    output.append(f\"{h}:{m:02d}\")  # Add the valid combination of hours and minutes to the output list\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667784,
                "title": "java-3-liner-simple",
                "content": "**Idea:** Generate all possible times and filter in those that satisfy the set bit-count using [Integer.bitCount](https://cr.openjdk.java.net/~iris/se/17/latestSpec/api/java.base/java/lang/Integer.html) method.\\n>**T/S:** O(1)/O(1) (ignoring space for output)\\n```\\npublic List<String> readBinaryWatch(int turnedOn) {\\n\\tvar times = new ArrayList<String>();\\n\\n\\tfor (var hour = 0; hour < 12; hour++)\\n\\t\\tfor (var minute = 0; minute < 60; minute++)\\n\\t\\t\\tif (Integer.bitCount(hour) + Integer.bitCount(minute) == turnedOn)\\n\\t\\t\\t\\ttimes.add(String.format(\"%d:%02d\", hour, minute));\\n\\t\\t\\t\\t\\n\\treturn times;\\n}\\n```\\n**Same approach using streams**\\n```\\npublic List<String> readBinaryWatch2(int turnedOn) {\\n\\tvar times = new ArrayList<String>();\\n\\n\\tIntStream.range(0, 12).forEach(hour ->\\n\\t\\tIntStream.range(0, 60).forEach(minute -> {\\n\\t\\t\\tif (Integer.bitCount(hour) + Integer.bitCount(minute) == turnedOn)\\n\\t\\t\\t\\ttimes.add(String.format(\"%d:%02d\", hour, minute));\\n\\t}));\\n\\n\\treturn times;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> readBinaryWatch(int turnedOn) {\\n\\tvar times = new ArrayList<String>();\\n\\n\\tfor (var hour = 0; hour < 12; hour++)\\n\\t\\tfor (var minute = 0; minute < 60; minute++)\\n\\t\\t\\tif (Integer.bitCount(hour) + Integer.bitCount(minute) == turnedOn)\\n\\t\\t\\t\\ttimes.add(String.format(\"%d:%02d\", hour, minute));\\n\\t\\t\\t\\t\\n\\treturn times;\\n}\\n```\n```\\npublic List<String> readBinaryWatch2(int turnedOn) {\\n\\tvar times = new ArrayList<String>();\\n\\n\\tIntStream.range(0, 12).forEach(hour ->\\n\\t\\tIntStream.range(0, 60).forEach(minute -> {\\n\\t\\t\\tif (Integer.bitCount(hour) + Integer.bitCount(minute) == turnedOn)\\n\\t\\t\\t\\ttimes.add(String.format(\"%d:%02d\", hour, minute));\\n\\t}));\\n\\n\\treturn times;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 775450,
                "title": "python-easy-to-understand",
                "content": "```\\n    def readBinaryWatch(self, num):\\n        ans =[]\\n        for h in range(0,12):\\n            for m in range(0,60):                \\n                if self.bitcount(h)+ self.bitcount(m) ==num:\\n                    time = str(h) + \":\"\\n                    if m<10:\\n                        time += \"0\" + str(m) \\n                    else:\\n                        time += str(m) \\n                    ans.append(time)\\n        return ans\\n\\n     # count how many bit will represent the number i.e. 15 is 1011 count will be 4\\n    def bitcount(self,n):\\n        count = 0\\n        while n > 0:\\n            if (n & 1 == 1): \\n                count += 1\\n            n >>= 1\\n        return count",
                "solutionTags": [],
                "code": "```\\n    def readBinaryWatch(self, num):\\n        ans =[]\\n        for h in range(0,12):\\n            for m in range(0,60):                \\n                if self.bitcount(h)+ self.bitcount(m) ==num:\\n                    time = str(h) + \":\"\\n                    if m<10:\\n                        time += \"0\" + str(m) \\n                    else:\\n                        time += str(m) \\n                    ans.append(time)\\n        return ans\\n\\n     # count how many bit will represent the number i.e. 15 is 1011 count will be 4\\n    def bitcount(self,n):\\n        count = 0\\n        while n > 0:\\n            if (n & 1 == 1): \\n                count += 1\\n            n >>= 1\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 371775,
                "title": "solution-in-python-3-beats-98-one-line",
                "content": "_Check All Possible Times:_\\n```\\nclass Solution:\\n    def readBinaryWatch(self, n: int) -> List[str]:\\n    \\treturn [str(h)+\\':\\'+\\'0\\'*(m<10)+str(m) for h in range(12) for m in range(60) if (bin(m)+bin(h)).count(\\'1\\') == n]\\n\\n\\n\\n```\\n_Check All Possible Combinations of LEDs:_\\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def readBinaryWatch(self, n: int) -> List[str]:\\n    \\tT, m = [], [480,240,120,60,32,16,8,4,2,1]\\n    \\tfor i in combinations(m,n):\\n    \\t\\tif 32 in i and 16 in i and 8 in i and 4 in i: continue\\n    \\t\\th, m = divmod(sum(i),60)\\n    \\t\\tif h > 11: continue\\n    \\t\\tT.append(str(h)+\\':\\'+\\'0\\'*(m < 10)+str(m))\\n    \\treturn T\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, n: int) -> List[str]:\\n    \\treturn [str(h)+\\':\\'+\\'0\\'*(m<10)+str(m) for h in range(12) for m in range(60) if (bin(m)+bin(h)).count(\\'1\\') == n]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309431,
                "title": "c-backtracking-solution-0ms-beats-100",
                "content": "Using the classic backtracking template + adding clock checks.\\nhours and minutes can be combined and treated as single string.\\nThis makes thinking the backtracking solution much easier.\\n\\n```\\nclass Solution {\\npublic:\\n    void backtrack(string& s, int start, int num, vector<string>& res){\\n        \\n        // clock specific checks\\n        int hours = std::bitset<4>(s.substr(6, 4)).to_ulong();\\n        if(hours > 11){\\n            return;\\n        }\\n        int minutes = std::bitset<6>(s.substr(0, 6)).to_ulong();\\n        if(minutes > 59){\\n            return;\\n        }\\n        \\n        // if num no of bulbs are now lit\\n        if(num==0){\\n            res.push_back(to_string(hours) + \":\" + (minutes < 10 ? \"0\" : \"\") + to_string(minutes));\\n            return;\\n        }\\n        \\n        // if reached string end\\n        if(start == s.length()){\\n            return;\\n        }\\n        \\n        for(int i=start; i<s.length(); ++i){\\n            // num-1 because we just lit one bulb\\n            // i+1 because, next bulb will be lit after index i\\n            // it can lit before i, but that\\'ll just be a duplicate case,\\n            // already handled in previous backtracks\\n            s[i] = \\'1\\';\\n            backtrack(s, i+1, num-1, res);\\n            s[i] = \\'0\\';\\n        }\\n    }\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        string s = \"0000000000\";\\n        backtrack(s, 0, num, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(string& s, int start, int num, vector<string>& res){\\n        \\n        // clock specific checks\\n        int hours = std::bitset<4>(s.substr(6, 4)).to_ulong();\\n        if(hours > 11){\\n            return;\\n        }\\n        int minutes = std::bitset<6>(s.substr(0, 6)).to_ulong();\\n        if(minutes > 59){\\n            return;\\n        }\\n        \\n        // if num no of bulbs are now lit\\n        if(num==0){\\n            res.push_back(to_string(hours) + \":\" + (minutes < 10 ? \"0\" : \"\") + to_string(minutes));\\n            return;\\n        }\\n        \\n        // if reached string end\\n        if(start == s.length()){\\n            return;\\n        }\\n        \\n        for(int i=start; i<s.length(); ++i){\\n            // num-1 because we just lit one bulb\\n            // i+1 because, next bulb will be lit after index i\\n            // it can lit before i, but that\\'ll just be a duplicate case,\\n            // already handled in previous backtracks\\n            s[i] = \\'1\\';\\n            backtrack(s, i+1, num-1, res);\\n            s[i] = \\'0\\';\\n        }\\n    }\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        string s = \"0000000000\";\\n        backtrack(s, 0, num, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266704,
                "title": "c-solution",
                "content": "\\n    public IList<string> ReadBinaryWatch(int num) {\\n        List<String> times = new List<string>();\\n        for (int h=0; h<12; h++)\\n        for (int m=0; m<60; m++)\\n            if (Bitcount(h) + Bitcount(m) == num)\\n                times.Add(String.Format(\"{0}:{1:D2}\", h, m));\\n        return times;    \\n    }\\n\\n    public int Bitcount(int n){\\n        int count = 0;\\n        while (n != 0) {\\n            count++;\\n            n &= (n - 1);\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\n    public IList<string> ReadBinaryWatch(int num) {\\n        List<String> times = new List<string>();\\n        for (int h=0; h<12; h++)\\n        for (int m=0; m<60; m++)\\n            if (Bitcount(h) + Bitcount(m) == num)\\n                times.Add(String.Format(\"{0}:{1:D2}\", h, m));\\n        return times;    \\n    }\\n\\n    public int Bitcount(int n){\\n        int count = 0;\\n        while (n != 0) {\\n            count++;\\n            n &= (n - 1);\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 88550,
                "title": "easy-simple-and-naive-python-solution",
                "content": "No need to explain.\\n\\n```python\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        output = []\\n        for h in range(12):\\n          for m in range(60):\\n            if bin(h * 64 + m).count('1') == num:\\n              output.append('%d:%02d' % (h, m))\\n        return output\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        output = []\\n        for h in range(12):\\n          for m in range(60):\\n            if bin(h * 64 + m).count('1') == num:\\n              output.append('%d:%02d' % (h, m))\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214774,
                "title": "decode-the-binary-watch-find-all-possible-times-with-a-given-number-of-leds-on",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne way to solve this problem is to generate all possible times that can be represented by a binary watch and check how many LEDs are turned on. If the number of turned-on LEDs matches the given input \"turnedOn\", we add the time to the result list. Since there are only 10 LEDs on the watch, we can iterate through all possible combinations using bit manipulation.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo implement the above intuition, we can start by iterating through all possible values of the hours (0-11) and minutes (0-59) and check how many LEDs are turned on in the binary representation of the hours and minutes. We can do this using the `bin()` function, which converts an integer to its binary representation as a string. Then, we can count the number of 1s in the binary string using the `count()` method of the `str` object. If the sum of the number of turned-on LEDs in the hours and minutes is equal to the given input \"turnedOn\", we can add the corresponding time to our output list.\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(1) since we are iterating through a constant number of possible values of the hours (0-11) and minutes (0-59), which is 12 and 60, respectively. Counting the number of set bits in a binary string takes O(log n) time, which is negligible compared to the overall time complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this approach is O(1) since we are not using any extra space to store intermediate results. The output list has a maximum size of 1024, which is the total number of possible combinations of turned-on LEDs.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        res = []\\n        for h in range(12):\\n            for m in range(60):\\n                if bin(h).count(\\'1\\') + bin(m).count(\\'1\\') == turnedOn:\\n                    res.append(f\"{h}:{m:02d}\")\\n        return res\\n```\\n\\nIn the code above, we use the `bin()` function to convert the integer hours and minutes to their binary representation. We use the `count()` method of the `str` object to count the number of set bits in the binary representation of the hours and minutes. We also use the f-string notation to format the output string with leading zero if necessary.",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        res = []\\n        for h in range(12):\\n            for m in range(60):\\n                if bin(h).count(\\'1\\') + bin(m).count(\\'1\\') == turnedOn:\\n                    res.append(f\"{h}:{m:02d}\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428153,
                "title": "simple-python-solution-98-faster",
                "content": "here is what I did:\\n\\n```python\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        ans = []\\n        num2bits = [bin(i).count(\"1\") for i in range(60)]\\n        for h in range(12):\\n            hb = num2bits[h]\\n            for m in range(60):\\n                mb = num2bits[m]\\n                if hb + mb == turnedOn:\\n                    ans.append(f\"{h}:{m:02d}\")\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        ans = []\\n        num2bits = [bin(i).count(\"1\") for i in range(60)]\\n        for h in range(12):\\n            hb = num2bits[h]\\n            for m in range(60):\\n                mb = num2bits[m]\\n                if hb + mb == turnedOn:\\n                    ans.append(f\"{h}:{m:02d}\")\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1101120,
                "title": "simple-c-solution-using-bit-manipulation-with-explanation-beats-100",
                "content": "\\nWe iterate through all the binary numbers from 0 to 2e10 and check when the number of set bits is equal to num.\\nThen we right shift the current number by 6 bits to get the hours and then use it to get the minutes.\\n\\n```\\nvector<string> readBinaryWatch(int num) {   // let num be 6\\n    int mask = 1 << 10;                     // mask = \"10000000000\\n    vector<string>ans;\\n    for (int i = 0; i < mask; i++)\\n    {\\n        if (__builtin_popcount(i) == num)   // counts number of set bits\\n        {                                   // let i = \"101001111\"\\n            int hr = i >> 6;                // hours = \"101\" = 5\\n            int mn = (hr << 6)^i;           // hr<<6 =\"101000000\"  \\n                                            // xor of i and hr<<6 will give us minutes \\n\\t\\t\\tif (hr < 12 && mn < 60)\\n            {\\n                ans.push_back(to_string(hr) + ((mn < 10) ? \":0\" : \":\") + to_string(mn));\\n            }\\n        }\\n    }\\n    return ans;\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<string> readBinaryWatch(int num) {   // let num be 6\\n    int mask = 1 << 10;                     // mask = \"10000000000\\n    vector<string>ans;\\n    for (int i = 0; i < mask; i++)\\n    {\\n        if (__builtin_popcount(i) == num)   // counts number of set bits\\n        {                                   // let i = \"101001111\"\\n            int hr = i >> 6;                // hours = \"101\" = 5\\n            int mn = (hr << 6)^i;           // hr<<6 =\"101000000\"  \\n                                            // xor of i and hr<<6 will give us minutes \\n\\t\\t\\tif (hr < 12 && mn < 60)\\n            {\\n                ans.push_back(to_string(hr) + ((mn < 10) ? \":0\" : \":\") + to_string(mn));\\n            }\\n        }\\n    }\\n    return ans;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88595,
                "title": "2-c-solutions",
                "content": "straight forward\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string>res;\\n        for(int h=0;h<12;++h)\\n            for(int m=0;m<60;++m)\\n                if(bitset<10>((h<<6)+m).count()==num)\\n                {\\n                    string str=to_string(h)+\":\";\\n                    str+=(m<10)?(\"0\"+to_string(m)):to_string(m);\\n                    res.push_back(str);\\n                }\\n        return res;\\n    }\\n};\\n```\\ncombination\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<vector<int>>hour(5),min(7);\\n        for(int i=0;i<12;++i)\\n        {\\n            int n=bitset<4>(i).count();\\n            hour[n].push_back(i);\\n        }\\n        for(int i=0;i<60;++i)\\n        {\\n            int n=bitset<6>(i).count();\\n            min[n].push_back(i);\\n        }\\n        vector<string>res;\\n        for(int i=0;i<=num&&i<=4;++i)\\n            for(int j=0;j<hour[i].size();++j)\\n                for(int k=0;num-i<=6&&k<min[num-i].size();++k)\\n                {\\n                    string str=to_string(hour[i][j])+\":\";\\n                    if(min[num-i][k]<10)\\n                        str+=\"0\";\\n                    str+=to_string(min[num-i][k]);\\n                    res.push_back(str);\\n                }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string>res;\\n        for(int h=0;h<12;++h)\\n            for(int m=0;m<60;++m)\\n                if(bitset<10>((h<<6)+m).count()==num)\\n                {\\n                    string str=to_string(h)+\":\";\\n                    str+=(m<10)?(\"0\"+to_string(m)):to_string(m);\\n                    res.push_back(str);\\n                }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239157,
                "title": "hindi-version-c-easy-approach",
                "content": "This post is written in HINDI as there are very less post explaining approaches in HINDI.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasic Backtracking ka use karenge. Code ko read karo comments de rakhe hai ache se samajha aayega and saath hi mein ek example par dry run karke dekho clarity mil jaayegi.\\n\\n# Complexity\\n- Time complexity: O((m+n)^turnedOn) = O(10^numberOfLEDs)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(10^numberOfLEDs)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // 4 LEDS for hours\\n    vector<int>hours = {1,2,4,8};\\n    // 6 LEDS for minutes\\n    vector<int>mins = {1,2,4,8,16,32};\\n    // helper function : Ye 4 parameters lega :\\n    // a) result vector of strings\\n    // b) ek pair of hours and minutes jahan par time.first hour ko represent karega and time.second minutes ko\\n    // c) No_Of_LEDs : iska use hum kitne LEDs on karne reh gaye hai iske liye use karenge\\n    // d) idx : current position of pointer in vectors (hours and mins)\\n    void helper(vector<string>&res,pair<int,int>time,int No_Of_LEDs,int idx)\\n    {\\n        // agar number of LEDs zero hojaate hai iska matlab mujhe ek possible time milgaya jisse mein apne result vector mein add karlunga\\n        if(No_Of_LEDs==0)\\n        {\\n            // agar number of minutes less than 10 hai toh \":0\" ko add karenge like this : \"12:05\"\\n            if(time.second<10)\\n            {\\n                res.push_back(to_string(time.first)+\":0\"+to_string(time.second));\\n            }\\n            // agar number of minutes greater than 10 hai toh \":\" ko add karenge like this : \"12:15\"\\n            else\\n            {\\n                res.push_back(to_string(time.first)+\":\"+to_string(time.second));\\n            }\\n            return;\\n        }\\n        int n = hours.size();\\n        int m = mins.size();\\n        for(int i=idx;i<(m+n);i++)\\n        {\\n            // agar saare 6 LEDs hours waale check nahi kare abhi toh pehle unhe check karo\\n            if(i<n)\\n            {\\n                // current hour waale LED ko lelo\\n                time.first += hours[i];\\n                // agar hours less than 12 hai toh aage bado\\n                if(time.first<12)\\n                {\\n                    helper(res,time,No_Of_LEDs-1,i+1);\\n                }\\n                // backtracking step current hour jo liya tha usse remove karo taaki kisi aur hour waale LED ko use kar saken\\n                time.first -= hours[i];\\n            }\\n            // agar saare 6 LEDs hours waale check karliye toh ab minutes waale LEDs ko check karo\\n            else\\n            {\\n                // current minutes waale LED ko lelo\\n                time.second += mins[i-n];\\n                // agar minutes less than 60 hai toh aage bado\\n                if(time.second<60)\\n                {\\n                    helper(res,time,No_Of_LEDs-1,i+1);\\n                }\\n                // backtracking step current minutes jo liya tha usse remove karo taaki kisi aur minutes waale LED ko use kar saken\\n                time.second -= mins[i-n];\\n            }\\n        }\\n    }\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        // ek vector of string le lenge return karne ke liye\\n        vector<string>res;\\n        // helper function ko call karenge\\n        helper(res,{0,0},turnedOn,0);\\n        return res;\\n    }\\n};\\n```\\n\\n**Agar Post se help mili ho toh please upvote karna!!!**",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // 4 LEDS for hours\\n    vector<int>hours = {1,2,4,8};\\n    // 6 LEDS for minutes\\n    vector<int>mins = {1,2,4,8,16,32};\\n    // helper function : Ye 4 parameters lega :\\n    // a) result vector of strings\\n    // b) ek pair of hours and minutes jahan par time.first hour ko represent karega and time.second minutes ko\\n    // c) No_Of_LEDs : iska use hum kitne LEDs on karne reh gaye hai iske liye use karenge\\n    // d) idx : current position of pointer in vectors (hours and mins)\\n    void helper(vector<string>&res,pair<int,int>time,int No_Of_LEDs,int idx)\\n    {\\n        // agar number of LEDs zero hojaate hai iska matlab mujhe ek possible time milgaya jisse mein apne result vector mein add karlunga\\n        if(No_Of_LEDs==0)\\n        {\\n            // agar number of minutes less than 10 hai toh \":0\" ko add karenge like this : \"12:05\"\\n            if(time.second<10)\\n            {\\n                res.push_back(to_string(time.first)+\":0\"+to_string(time.second));\\n            }\\n            // agar number of minutes greater than 10 hai toh \":\" ko add karenge like this : \"12:15\"\\n            else\\n            {\\n                res.push_back(to_string(time.first)+\":\"+to_string(time.second));\\n            }\\n            return;\\n        }\\n        int n = hours.size();\\n        int m = mins.size();\\n        for(int i=idx;i<(m+n);i++)\\n        {\\n            // agar saare 6 LEDs hours waale check nahi kare abhi toh pehle unhe check karo\\n            if(i<n)\\n            {\\n                // current hour waale LED ko lelo\\n                time.first += hours[i];\\n                // agar hours less than 12 hai toh aage bado\\n                if(time.first<12)\\n                {\\n                    helper(res,time,No_Of_LEDs-1,i+1);\\n                }\\n                // backtracking step current hour jo liya tha usse remove karo taaki kisi aur hour waale LED ko use kar saken\\n                time.first -= hours[i];\\n            }\\n            // agar saare 6 LEDs hours waale check karliye toh ab minutes waale LEDs ko check karo\\n            else\\n            {\\n                // current minutes waale LED ko lelo\\n                time.second += mins[i-n];\\n                // agar minutes less than 60 hai toh aage bado\\n                if(time.second<60)\\n                {\\n                    helper(res,time,No_Of_LEDs-1,i+1);\\n                }\\n                // backtracking step current minutes jo liya tha usse remove karo taaki kisi aur minutes waale LED ko use kar saken\\n                time.second -= mins[i-n];\\n            }\\n        }\\n    }\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        // ek vector of string le lenge return karne ke liye\\n        vector<string>res;\\n        // helper function ko call karenge\\n        helper(res,{0,0},turnedOn,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814562,
                "title": "java-0ms-explanation",
                "content": "**Intuition:**\\n\\nSimply we can check all the combinations of hour and minute. If bit count of any combination is same as number of LEDs that are currently turned on, means these combinations\\ncan give us a valid time in the watch.\\n\\nIf the minute is less than 10 we add a prefix zero to comply with the condition where it says minute must be consists of two digits.\\n\\n\\n**Algorithm:**\\n\\n1. Create a list to store the result\\n2. To create all the combinations of hour and minute, have a for loop from 0 t0 11 to represent hour and another for loop inside the first one from 0 to 59 to represent minutes\\n    - Sum up bit count of hour and mintue, if sum is equal to number of LEDs turned on, add the hour and minute combination to result list(format minute with prefix zero if it is less than 10)\\n3. Return the list of all possible times\\n\\n**Code : Java**\\n\\n```\\nclass Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        List<String> allPossibleTimes = new ArrayList();\\n        \\n        for(int hour=0;hour<12;hour++){\\n            for(int minute=0;minute<60;minute++){\\n                if(Integer.bitCount(hour)+Integer.bitCount(minute) == turnedOn){\\n                    StringBuilder time = new StringBuilder();\\n                    time.append(hour).append(\":\");\\n                    if(minute<10){\\n                        time.append(\"0\");\\n                    }\\n                    time.append(minute);\\n                    allPossibleTimes.add(time.toString());\\n                }\\n            }\\n        }\\n        return allPossibleTimes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        List<String> allPossibleTimes = new ArrayList();\\n        \\n        for(int hour=0;hour<12;hour++){\\n            for(int minute=0;minute<60;minute++){\\n                if(Integer.bitCount(hour)+Integer.bitCount(minute) == turnedOn){\\n                    StringBuilder time = new StringBuilder();\\n                    time.append(hour).append(\":\");\\n                    if(minute<10){\\n                        time.append(\"0\");\\n                    }\\n                    time.append(minute);\\n                    allPossibleTimes.add(time.toString());\\n                }\\n            }\\n        }\\n        return allPossibleTimes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220540,
                "title": "easy-java-recursive-solution-with-comments-91-faster",
                "content": "**We will use the include / not include calls**\\n\\n```\\n\\nclass Solution {\\n   public static List<String> readBinaryWatch(int turnedOn) {\\n\\n\\t\\tint[] arr = { 1, 2, 4, 8, 1, 2, 4, 8, 16, 32 };\\n\\t\\tList<String> list = new ArrayList<>();\\n\\t\\thelper(turnedOn, arr, 0, 0, 0, list);\\n\\n\\t\\treturn list;\\n\\t}\\n\\n\\tpublic static void helper(int turnedOn, int[] arr, int vidx, int hr, int min, List<String> list) {\\n\\n\\t\\tif (hr > 11 || min > 59) \\n\\t\\t\\treturn;\\n\\t\\t\\n\\t\\tif (turnedOn == 0) {\\n\\t\\t\\t//System.out.println(hr + \":\" + min);\\n\\t\\t\\tString str = \"\";\\n\\n\\t\\t\\tif (min <= 9)\\n\\t\\t\\t\\tstr = hr + \":0\" + min;\\n\\t\\t\\telse\\n\\t\\t\\t\\tstr = hr + \":\" + min;\\n\\n\\t\\t\\tlist.add(str);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (vidx == arr.length)\\n\\t\\t\\treturn;\\n\\n\\t\\t// ON\\n\\n\\t\\t\\tif (vidx <= 3)\\n\\t\\t\\t\\thelper(turnedOn - 1, arr, vidx + 1, hr + arr[vidx], min , list);\\n\\t\\t\\telse\\n\\t\\t\\t\\thelper(turnedOn - 1, arr, vidx + 1, hr, min + arr[vidx] , list);\\n\\n\\t\\t// OFF\\n\\t\\thelper(turnedOn, arr, vidx + 1, hr, min , list);\\n\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n   public static List<String> readBinaryWatch(int turnedOn) {\\n\\n\\t\\tint[] arr = { 1, 2, 4, 8, 1, 2, 4, 8, 16, 32 }",
                "codeTag": "Java"
            },
            {
                "id": 967386,
                "title": "java-bit-count-with-hamming-distance",
                "content": "The main difference with this solution is just the method `hDist` for counting the `1` in the current number used by the `h:mm`. I  believe this approach looks much better in an interview.\\n\\nCounting bits (`1`) will do the trick, for getting all the numbers that match the target `num` for the binary clock.\\n\\n```java\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> result = new ArrayList<String>();\\n        \\n        for (int i = 0; i < 12; i++) {\\n            for (int j = 0; j < 60; j++) {\\n                if (hDist(i) + hDist(j) == num) {\\n                    result.add(String.format(\"%d:%02d\", i, j));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n\\t// Count bits with Hamming Distance\\n    public int hDist(int num) {\\n        int ans = 0;\\n        \\n        while (num != 0) {\\n            ans++;\\n            num = num & (num - 1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> result = new ArrayList<String>();\\n        \\n        for (int i = 0; i < 12; i++) {\\n            for (int j = 0; j < 60; j++) {\\n                if (hDist(i) + hDist(j) == num) {\\n                    result.add(String.format(\"%d:%02d\", i, j));\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n\\t// Count bits with Hamming Distance\\n    public int hDist(int num) {\\n        int ans = 0;\\n        \\n        while (num != 0) {\\n            ans++;\\n            num = num & (num - 1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941090,
                "title": "python-backtracking-solution",
                "content": "```Python\\n# Runtime: 36 ms, faster than 26.41% of Python3 online submissions for Binary Watch.\\n\\n# Memory Usage: 14 MB, less than 75.87% of Python3 online submissions for Binary Watch.\\n\\n\\nclass Solution:\\n    _LED_NUM = 10\\n    _HOUR_LED_NUM = 4\\n\\n    # Backtracking\\n    def __init__(self):\\n        self._times = []\\n\\n    def readBinaryWatch(self, num: int):\\n        self._backtrack(num, 0, 0, 0)\\n        return self._times\\n    \\n    def _backtrack(self, num: int, pos: int, hour: int, minute: int):\\n        if hour > 11 or minute > 59:\\n            return\\n        elif num == 0:\\n            self._times.append(\"{:d}:{:02d}\".format(hour, minute))\\n            return\\n\\n        for i in range(pos, Solution._LED_NUM):\\n            if i < Solution._HOUR_LED_NUM:\\n                self._backtrack(num - 1, i + 1,\\n                    hour + 2**i, minute)\\n            else:\\n                self._backtrack(num - 1, i + 1,\\n                    hour, minute + 2**(i - Solution._HOUR_LED_NUM))\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```Python\\n# Runtime: 36 ms, faster than 26.41% of Python3 online submissions for Binary Watch.\\n\\n# Memory Usage: 14 MB, less than 75.87% of Python3 online submissions for Binary Watch.\\n\\n\\nclass Solution:\\n    _LED_NUM = 10\\n    _HOUR_LED_NUM = 4\\n\\n    # Backtracking\\n    def __init__(self):\\n        self._times = []\\n\\n    def readBinaryWatch(self, num: int):\\n        self._backtrack(num, 0, 0, 0)\\n        return self._times\\n    \\n    def _backtrack(self, num: int, pos: int, hour: int, minute: int):\\n        if hour > 11 or minute > 59:\\n            return\\n        elif num == 0:\\n            self._times.append(\"{:d}:{:02d}\".format(hour, minute))\\n            return\\n\\n        for i in range(pos, Solution._LED_NUM):\\n            if i < Solution._HOUR_LED_NUM:\\n                self._backtrack(num - 1, i + 1,\\n                    hour + 2**i, minute)\\n            else:\\n                self._backtrack(num - 1, i + 1,\\n                    hour, minute + 2**(i - Solution._HOUR_LED_NUM))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841627,
                "title": "java-runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> possibleTimes = new ArrayList<>();\\n        \\n        for(int hour = 0; hour < 12; hour++){\\n            for(int min = 0; min < 60; min++){\\n                if(Integer.bitCount(hour) + Integer.bitCount(min) == num){\\n                    StringBuilder sb = new StringBuilder();\\n                    if(min < 10){\\n                        possibleTimes.add(sb.append(hour).append(\":\").append(\"0\").append(min).toString());\\n                    }else{\\n                        possibleTimes.add(sb.append(hour).append(\":\").append(min).toString());\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return possibleTimes;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> possibleTimes = new ArrayList<>();\\n        \\n        for(int hour = 0; hour < 12; hour++){\\n            for(int min = 0; min < 60; min++){\\n                if(Integer.bitCount(hour) + Integer.bitCount(min) == num){\\n                    StringBuilder sb = new StringBuilder();\\n                    if(min < 10){\\n                        possibleTimes.add(sb.append(hour).append(\":\").append(\"0\").append(min).toString());\\n                    }else{\\n                        possibleTimes.add(sb.append(hour).append(\":\").append(min).toString());\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return possibleTimes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 768896,
                "title": "c-solution-in-o-1-time-and-o-1-space-100-better",
                "content": "```\\nclass Solution {\\npublic:\\n    int set(int n){\\n        int result = 0;\\n        while(n){\\n            result++;\\n            n &= (n - 1);\\n        }\\n        return result;\\n    }\\n    \\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> result;\\n        for(int i = 0;i<12;i++){\\n            for(int j = 0;j<60;j++){\\n                int a = set(i);\\n                int b = set(j);\\n                if(a + b == num){\\n                    string hour = to_string(i);\\n                    string minute = (j <  10) ? (\"0\" + to_string(j)) : to_string(j);\\n                    result.push_back(hour + \":\" + minute);\\n                }\\n            }\\n        }\\n    return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int set(int n){\\n        int result = 0;\\n        while(n){\\n            result++;\\n            n &= (n - 1);\\n        }\\n        return result;\\n    }\\n    \\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> result;\\n        for(int i = 0;i<12;i++){\\n            for(int j = 0;j<60;j++){\\n                int a = set(i);\\n                int b = set(j);\\n                if(a + b == num){\\n                    string hour = to_string(i);\\n                    string minute = (j <  10) ? (\"0\" + to_string(j)) : to_string(j);\\n                    result.push_back(hour + \":\" + minute);\\n                }\\n            }\\n        }\\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88498,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar readBinaryWatch = function(num) {\\n    const output = [];\\n    \\n    // find the number of ones in bit expression of time and match with num\\n    for (let h = 0; h < 12; h++) {\\n        for (let m = 0; m < 60; m++) {\\n            const ones = Number(h * 64 + m).toString(2).split('').filter(d => d === '1').length;\\n            if (ones === num) output.push(m < 10 ? `${h}:0${m}` : `${h}:${m}`);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar readBinaryWatch = function(num) {\\n    const output = [];\\n    \\n    // find the number of ones in bit expression of time and match with num\\n    for (let h = 0; h < 12; h++) {\\n        for (let m = 0; m < 60; m++) {\\n            const ones = Number(h * 64 + m).toString(2).split('').filter(d => d === '1').length;\\n            if (ones === num) output.push(m < 10 ? `${h}:0${m}` : `${h}:${m}`);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1670739,
                "title": "python-solution-faster-than-97",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        result =[]\\n        for i in range(12):\\n            for j in range(60):\\n                if((bin(i)+bin(j)).count(\\'1\\')==turnedOn):\\n                   \\n                   result.append((str(i)+\":\"+str(j).zfill(2)))\\n                    \\n        return result    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        result =[]\\n        for i in range(12):\\n            for j in range(60):\\n                if((bin(i)+bin(j)).count(\\'1\\')==turnedOn):\\n                   \\n                   result.append((str(i)+\":\"+str(j).zfill(2)))\\n                    \\n        return result    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312659,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        int[] hours = new int[] {8,4,2,1};\\n        int[] mins = new int[] {32,16,8,4,2,1};\\n        \\n        Set<String> res = new HashSet<>();\\n        \\n        for(int i=0;i<=turnedOn;i++)\\n        {\\n            List<Integer> list1 = generateTime(hours,i);\\n            List<Integer> list2 = generateTime(mins,turnedOn-i);\\n            for(int h : list1)\\n            {\\n                if(h >= 12)\\n                    continue;\\n                for(int min : list2)\\n                {\\n                    if(min >= 60)\\n                        continue;\\n                    res.add(h+\":\"+(min<10 ? \"0\"+min : min));\\n                }\\n            }\\n        }\\n        return new ArrayList(res);\\n    }\\n    List<Integer> generateTime(int[] nums,int count)\\n    {\\n        List<Integer> res = new ArrayList<>();\\n        recursion(nums,count,0,0,res);\\n        return res;\\n    }\\n    void recursion(int[] nums,int count ,int sum,int pos,List<Integer> res)\\n    {\\n        if(count == 0)\\n        {\\n            res.add(sum);\\n            return ;\\n        }\\n        for(int i=pos;i<nums.length;i++)\\n        {\\n            recursion(nums,count-1,sum+nums[i],i+1,res);\\n        }\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        int[] hours = new int[] {8,4,2,1};\\n        int[] mins = new int[] {32,16,8,4,2,1};\\n        \\n        Set<String> res = new HashSet<>();\\n        \\n        for(int i=0;i<=turnedOn;i++)\\n        {\\n            List<Integer> list1 = generateTime(hours,i);\\n            List<Integer> list2 = generateTime(mins,turnedOn-i);\\n            for(int h : list1)\\n            {\\n                if(h >= 12)\\n                    continue;\\n                for(int min : list2)\\n                {\\n                    if(min >= 60)\\n                        continue;\\n                    res.add(h+\":\"+(min<10 ? \"0\"+min : min));\\n                }\\n            }\\n        }\\n        return new ArrayList(res);\\n    }\\n    List<Integer> generateTime(int[] nums,int count)\\n    {\\n        List<Integer> res = new ArrayList<>();\\n        recursion(nums,count,0,0,res);\\n        return res;\\n    }\\n    void recursion(int[] nums,int count ,int sum,int pos,List<Integer> res)\\n    {\\n        if(count == 0)\\n        {\\n            res.add(sum);\\n            return ;\\n        }\\n        for(int i=pos;i<nums.length;i++)\\n        {\\n            recursion(nums,count-1,sum+nums[i],i+1,res);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228064,
                "title": "python3-simple-solution-one-liner",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn):\\n        return [\\'{}:{}\\'.format(i,str(j).zfill(2)) for i in range(12) for j in range(60) if bin(i)[2:].count(\\'1\\') + bin(j)[2:].count(\\'1\\') == turnedOn]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn):\\n        return [\\'{}:{}\\'.format(i,str(j).zfill(2)) for i in range(12) for j in range(60) if bin(i)[2:].count(\\'1\\') + bin(j)[2:].count(\\'1\\') == turnedOn]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302787,
                "title": "python-20ms",
                "content": "```\\n    def readBinaryWatch(self, num):\\n        mylist = []\\n        for i in range(12): \\n            for j in range(60):\\n                if bin(i).count(\\'1\\') + bin(j).count(\\'1\\') == num:\\n                    mylist.append(\\'%d:%02d\\' %(i,j))\\n        return mylist\\n```",
                "solutionTags": [],
                "code": "```\\n    def readBinaryWatch(self, num):\\n        mylist = []\\n        for i in range(12): \\n            for j in range(60):\\n                if bin(i).count(\\'1\\') + bin(j).count(\\'1\\') == num:\\n                    mylist.append(\\'%d:%02d\\' %(i,j))\\n        return mylist\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 135064,
                "title": "simple-dfs-solution-using-o-1-space-bit-manipulation",
                "content": "Same idea as permulations. I start with an Integer (0) that has 32 bits. After setting \"n\" bits in the Integer, Use the right 6 bits as minutes, and the 4 bits before that as Hour. \\n\\nComments are welcome...\\n\\n```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        solve(num, 0,0, res);\\n        return res;\\n    }\\n    \\n    void solve(int num, int mask,int start, List<String> res) {\\n        if (num == 0) {\\n            int min = mask & ((1 << 6) - 1);\\n            int hour = mask >> 6;\\n            if (hour > 11 || min > 59) return;\\n            res.add(String.format(\"%d:%02d\", hour, min));\\n            return;\\n        }\\n        \\n        for (int i = start; i < 10; i++) {\\n            solve(num - 1, mask | (1 << i),i + 1, res);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        solve(num, 0,0, res);\\n        return res;\\n    }\\n    \\n    void solve(int num, int mask,int start, List<String> res) {\\n        if (num == 0) {\\n            int min = mask & ((1 << 6) - 1);\\n            int hour = mask >> 6;\\n            if (hour > 11 || min > 59) return;\\n            res.add(String.format(\"%d:%02d\", hour, min));\\n            return;\\n        }\\n        \\n        for (int i = start; i < 10; i++) {\\n            solve(num - 1, mask | (1 << i),i + 1, res);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88513,
                "title": "easy-backtracking-solution-with-comments",
                "content": "\\n\\n\\n    public class Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res=new ArrayList();\\n        if(num>8){  //impossible if num>8 because the max time is 11:59\\n            return res;\\n        }\\n        if(num==0){\\n            String ans=\"0:00\";    //return the basic situation of num=0\\n            res.add(ans);\\n            return res;\\n        }\\n        int temp[]={8,4,2,1,32,16,8,4,2,1};//hours and minutes in an array!\\n        boolean index[]=new boolean[10];//boolean array to check if used!\\n        helper(res,temp,index,num,0);\\n        return res;\\n    }\\n    void helper(List<String> res,int[] temp,boolean[] index,int num,int start){\\n        if(num==0){//num=0,it is time to return answers!\\n            int hour=0;\\n           int minute=0;\\n            for(int k=0;k<10;k++){\\n                if(index[k]==true&&k<=3){\\n                    hour+=temp[k];\\n                }\\n                if(index[k]==true&&k>3){\\n                    minute+=temp[k];\\n                }\\n            }\\n            if(hour>=12||minute>=60){//impossible cases!\\n                return;\\n            }\\n            else{//Two situations of minutes to add to the string!!\\n                if(minute<10){\\n                    String answer=\"\"+hour+\":\"+\"0\"+minute;\\n                    res.add(answer);\\n                    return;\\n                }\\n                else{\\n                    String answer=\"\"+hour+\":\"+minute;\\n                    res.add(answer);\\n                    return;\\n                }\\n                    \\n                }\\n            }\\n        for(int i=start;i<temp.length;i++){//Backtracking Loop from here!\\n            index[i]=true;\\n            helper(res,temp,index,num-1,i+1);\\n            index[i]=false;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res=new ArrayList();\\n        if(num>8){  //impossible if num>8 because the max time is 11:59\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3266347,
                "title": "java-backtracking-0ms-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking & Bit Manipulation\\n\\n# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    List<String> res;\\n    int[] clock;\\n    public List<String> readBinaryWatch(int turnedOn) {\\n         res = new ArrayList<>();\\n         clock = new int[2];\\n         backtrack(turnedOn, 0);\\n         return res;\\n    }\\n\\n    private void backtrack(int on, int p){\\n        //the stop condition for backtracking\\n        if(on == 0){\\n            String time = getString(clock);\\n            res.add(time);\\n            return;\\n        }\\n        for(int i = p; i < 10; i++){\\n            int num = 1 << (i % 6);\\n            if(i < 6){\\n                clock[1] += num;\\n                if(isValid()){\\n                    backtrack(on - 1, i + 1);\\n                }\\n                clock[1] -= num;\\n            }else{\\n                clock[0] += num;\\n                if(isValid()){\\n                    backtrack(on - 1, i + 1);\\n                }\\n                clock[0] -= num;\\n            }\\n        }\\n    }\\n\\n    //check if the clock has a valid time\\n    private boolean isValid(){\\n        if(clock[1] < 60 && clock[0] < 12){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private String getString(int[] mark){\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(mark[0]);\\n        sb.append(\":\");\\n        if(mark[1] < 10){\\n            sb.append(0);\\n        }\\n        sb.append(mark[1]);\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> res;\\n    int[] clock;\\n    public List<String> readBinaryWatch(int turnedOn) {\\n         res = new ArrayList<>();\\n         clock = new int[2];\\n         backtrack(turnedOn, 0);\\n         return res;\\n    }\\n\\n    private void backtrack(int on, int p){\\n        //the stop condition for backtracking\\n        if(on == 0){\\n            String time = getString(clock);\\n            res.add(time);\\n            return;\\n        }\\n        for(int i = p; i < 10; i++){\\n            int num = 1 << (i % 6);\\n            if(i < 6){\\n                clock[1] += num;\\n                if(isValid()){\\n                    backtrack(on - 1, i + 1);\\n                }\\n                clock[1] -= num;\\n            }else{\\n                clock[0] += num;\\n                if(isValid()){\\n                    backtrack(on - 1, i + 1);\\n                }\\n                clock[0] -= num;\\n            }\\n        }\\n    }\\n\\n    //check if the clock has a valid time\\n    private boolean isValid(){\\n        if(clock[1] < 60 && clock[0] < 12){\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private String getString(int[] mark){\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(mark[0]);\\n        sb.append(\":\");\\n        if(mark[1] < 10){\\n            sb.append(0);\\n        }\\n        sb.append(mark[1]);\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671589,
                "title": "golang-simple-solution",
                "content": "```\\nfunc readBinaryWatch(turnedOn int) []string {\\n    var times []string\\n    for h := 0; h < 12; h++ {\\n        i := bits.OnesCount(uint(h))\\n        for m := 0; m < 60; m++ {\\n            j := bits.OnesCount(uint(m))\\n            if turnedOn == i + j {\\n               times = append(times, fmt.Sprintf(\"%d:%02d\", h, m))\\n            }\\n        }\\n    }\\n    return times\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc readBinaryWatch(turnedOn int) []string {\\n    var times []string\\n    for h := 0; h < 12; h++ {\\n        i := bits.OnesCount(uint(h))\\n        for m := 0; m < 60; m++ {\\n            j := bits.OnesCount(uint(m))\\n            if turnedOn == i + j {\\n               times = append(times, fmt.Sprintf(\"%d:%02d\", h, m))\\n            }\\n        }\\n    }\\n    return times\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658568,
                "title": "java-python-90-faster-easy-solution-bitcount",
                "content": "**JAVA Solution**\\n```\\nclass Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        ArrayList<String> results = new ArrayList<String>();\\n        \\n        for (int hour=0; hour < 12; hour++) {\\n            for (int min=0; min < 60; min++) {\\n                if (Integer.bitCount(hour) + Integer.bitCount(min) == turnedOn){\\n                    if (min < 10) {\\n                        results.add(String.format(\"%d:0%d\", hour, min));\\n                    }\\n                    else{\\n                        results.add(String.format(\"%d:%d\", hour, min));\\n                    }\\n                }\\n            }\\n        }\\n        return results;\\n    }\\n}\\n```\\n\\n**Python Solution**\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        res = []\\n        time = \\'\\'\\n        for hour in range(0, 12):\\n            for minute in range(0, 60):\\n                if bin(hour).count(\\'1\\') + bin(minute).count(\\'1\\') == turnedOn:\\n                    if minute < 10:\\n                        time = f\\'{hour}:0{minute}\\'\\n                    else:\\n                        time = f\\'{hour}:{minute}\\'\\n                    res.append(time)\\n        return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        ArrayList<String> results = new ArrayList<String>();\\n        \\n        for (int hour=0; hour < 12; hour++) {\\n            for (int min=0; min < 60; min++) {\\n                if (Integer.bitCount(hour) + Integer.bitCount(min) == turnedOn){\\n                    if (min < 10) {\\n                        results.add(String.format(\"%d:0%d\", hour, min));\\n                    }\\n                    else{\\n                        results.add(String.format(\"%d:%d\", hour, min));\\n                    }\\n                }\\n            }\\n        }\\n        return results;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        res = []\\n        time = \\'\\'\\n        for hour in range(0, 12):\\n            for minute in range(0, 60):\\n                if bin(hour).count(\\'1\\') + bin(minute).count(\\'1\\') == turnedOn:\\n                    if minute < 10:\\n                        time = f\\'{hour}:0{minute}\\'\\n                    else:\\n                        time = f\\'{hour}:{minute}\\'\\n                    res.append(time)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455557,
                "title": "o-n-2-using-bitcount-built-in-function-easy-to-understand",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n        List<String> ans = new ArrayList<>();\\n\\n        for (int h = 0; h < 12; h++) {\\n            for (int m = 0; m < 60; m++) {\\n                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn){\\n                    ans.add(\"\" + h + \":\" + (m < 10 ? \"0\" : \"\") + m);\\n                }\\n            }\\n        }\\n\\n        return ans;",
                "solutionTags": [],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1617192,
                "title": "c-easy-to-understand-using-bit-manipulation",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n      vector<string> ans;\\n      for(int hour=0;hour<12;hour++)\\n      {\\n          for(int minutes=0;minutes<60;minutes++)\\n          {\\n              bitset<4> b1(hour);\\n              bitset<6> b2(minutes);\\n              if(b1.count()+b2.count()==turnedOn)\\n              {\\n                  string res=\"\";\\n                  res+=to_string(hour);\\n                  res+=\\':\\';\\n                  if(minutes<10)\\n                  {\\n                      res+=\\'0\\';\\n                      res+=to_string(minutes);\\n                  }\\n                  else\\n                  {\\n                      res+=to_string(minutes);\\n                  }\\n                  ans.push_back(res);\\n              }\\n          }\\n      }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n      vector<string> ans;\\n      for(int hour=0;hour<12;hour++)\\n      {\\n          for(int minutes=0;minutes<60;minutes++)\\n          {\\n              bitset<4> b1(hour);\\n              bitset<6> b2(minutes);\\n              if(b1.count()+b2.count()==turnedOn)\\n              {\\n                  string res=\"\";\\n                  res+=to_string(hour);\\n                  res+=\\':\\';\\n                  if(minutes<10)\\n                  {\\n                      res+=\\'0\\';\\n                      res+=to_string(minutes);\\n                  }\\n                  else\\n                  {\\n                      res+=to_string(minutes);\\n                  }\\n                  ans.push_back(res);\\n              }\\n          }\\n      }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968930,
                "title": "python-easy-solution",
                "content": "```\\ndef readBinaryWatch(self, num: int) -> List[str]:\\n        ans=[]\\n        for i in range(12):\\n            hr_ones=bin(i)[2:].count(\\'1\\')\\n            for j in range(60):\\n                min_ones=bin(j)[2:].count(\\'1\\')\\n                if hr_ones+min_ones==num:\\n                    ans.append(\"{}:{:02d}\".format(i,j))\\n        return ans",
                "solutionTags": [],
                "code": "```\\ndef readBinaryWatch(self, num: int) -> List[str]:\\n        ans=[]\\n        for i in range(12):\\n            hr_ones=bin(i)[2:].count(\\'1\\')\\n            for j in range(60):\\n                min_ones=bin(j)[2:].count(\\'1\\')\\n                if hr_ones+min_ones==num:\\n                    ans.append(\"{}:{:02d}\".format(i,j))\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 871282,
                "title": "python-simple-iteration-over-hours-and-minutes",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        result = []\\n        for hours in range(12):\\n            for minutes in range(60):\\n                if bin(hours).count(\\'1\\') + bin(minutes).count(\\'1\\') == num:\\n                    result.append(str(hours) + \":\" + str(minutes).zfill(2))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        result = []\\n        for hours in range(12):\\n            for minutes in range(60):\\n                if bin(hours).count(\\'1\\') + bin(minutes).count(\\'1\\') == num:\\n                    result.append(str(hours) + \":\" + str(minutes).zfill(2))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677413,
                "title": "java-backtrack-solution",
                "content": "This is a really good backTrack problem. I don\\'t like bit operation, that is why I use backTrack.\\nFirst, build two array. One is for hours, another is for minutes.\\nThen if we use i to generate hours and num-i to generate minitues.\\nThen combine them all.\\n\\n```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        int[] hour ={8,4,2,1};\\n        int[] minite={32,16,8,4,2,1};\\n        \\n        for(int i=0;i<=num;i++){\\n\\t//use i to generate hour\\n            List<Integer> hours = generate(hour,i);\\n\\t//use num-i to generate minutes\\n            List<Integer> minutes = generate(minite,num-i);\\n            \\n\\t//combine all the hours and minutes\\n            for(Integer h:hours){\\n                if(h>11) continue;\\n                for(Integer m:minutes){\\n                    if(m>59) continue;\\n                    res.add(h+\":\"+(m<10?\"0\":\"\")+m);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n//generate numbers\\n    List<Integer> generate(int[] nums,int count){\\n        List<Integer> res = new ArrayList<>();\\n        backTrack(res,0,nums,count,0);\\n        return res;\\n    }\\n//back track\\n    void backTrack(List<Integer> res,int idx,int[] nums,int count,int time){\\n        \\n        if(count==0){\\n            res.add(time);\\n            return;\\n        }\\n        for(int i=idx;i<nums.length;i++){\\n            backTrack(res, i+1, nums, count-1, time+nums[i]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        int[] hour ={8,4,2,1};\\n        int[] minite={32,16,8,4,2,1};\\n        \\n        for(int i=0;i<=num;i++){\\n\\t//use i to generate hour\\n            List<Integer> hours = generate(hour,i);\\n\\t//use num-i to generate minutes\\n            List<Integer> minutes = generate(minite,num-i);\\n            \\n\\t//combine all the hours and minutes\\n            for(Integer h:hours){\\n                if(h>11) continue;\\n                for(Integer m:minutes){\\n                    if(m>59) continue;\\n                    res.add(h+\":\"+(m<10?\"0\":\"\")+m);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n//generate numbers\\n    List<Integer> generate(int[] nums,int count){\\n        List<Integer> res = new ArrayList<>();\\n        backTrack(res,0,nums,count,0);\\n        return res;\\n    }\\n//back track\\n    void backTrack(List<Integer> res,int idx,int[] nums,int count,int time){\\n        \\n        if(count==0){\\n            res.add(time);\\n            return;\\n        }\\n        for(int i=idx;i<nums.length;i++){\\n            backTrack(res, i+1, nums, count-1, time+nums[i]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557055,
                "title": "python-3-backtracking-solution-beats-94-86",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        res = []\\n        self.dfs(num, 0, res)\\n        return res\\n    \\n    def dfs(self, num, hours, res):\\n        if hours > num : \\n            return\\n        for hour in combinations([1, 2, 4, 8], hours):\\n            hs = sum(hour)\\n            if hs >= 12 : \\n                continue\\n            for minu in combinations([1, 2, 4, 8, 16, 32], num - hours):\\n                mins = sum(minu)\\n                if mins >= 60 : \\n                    continue\\n                res.append(\"%d:%02d\" % (hs, mins))\\n        self.dfs(num, hours + 1, res)\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        res = []\\n        self.dfs(num, 0, res)\\n        return res\\n    \\n    def dfs(self, num, hours, res):\\n        if hours > num : \\n            return\\n        for hour in combinations([1, 2, 4, 8], hours):\\n            hs = sum(hour)\\n            if hs >= 12 : \\n                continue\\n            for minu in combinations([1, 2, 4, 8, 16, 32], num - hours):\\n                mins = sum(minu)\\n                if mins >= 60 : \\n                    continue\\n                res.append(\"%d:%02d\" % (hs, mins))\\n        self.dfs(num, hours + 1, res)\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442732,
                "title": "clean-c-with-100-space-and-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        std::vector<std::string> result;\\n        for (int hour = 0; hour < 12; ++hour) {\\n            for (int minute = 0; minute < 60; ++minute) {\\n                if (CountBits(hour) + CountBits(minute) == num) {\\n                    result.push_back(TimeToString(hour, minute));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    inline std::string TimeToString(int hour, int minute) {\\n        return std::to_string(hour) +\\n               \":\" +\\n               (minute < 10 ? \"0\" : \"\") +\\n               std::to_string(minute);\\n    }\\n    \\n    inline int CountBits(int n) {\\n        int count = 0;\\n        while (n > 0) {\\n            n &= n - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        std::vector<std::string> result;\\n        for (int hour = 0; hour < 12; ++hour) {\\n            for (int minute = 0; minute < 60; ++minute) {\\n                if (CountBits(hour) + CountBits(minute) == num) {\\n                    result.push_back(TimeToString(hour, minute));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    inline std::string TimeToString(int hour, int minute) {\\n        return std::to_string(hour) +\\n               \":\" +\\n               (minute < 10 ? \"0\" : \"\") +\\n               std::to_string(minute);\\n    }\\n    \\n    inline int CountBits(int n) {\\n        int count = 0;\\n        while (n > 0) {\\n            n &= n - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88472,
                "title": "swift-solution-with-illustration",
                "content": "```\\nfunc readBinaryWatch(_ num: Int) -> [String] {\\n        var res = [String]()\\n\\n        func findLEDs(_ h: Int, _ m: Int) -> Int {\\n            let hc = Array(String(h, radix: 2).characters).filter { $0 == \"1\" }.count\\n            let mc = Array(String(m, radix: 2).characters).filter { $0 == \"1\" }.count\\n            return hc + mc\\n        }\\n\\n        for h in 0...11 {\\n            for m in 0...59 {\\n                if findLEDs(h, m) == num {\\n                    res.append(String(format: \"%d:%02d\", h, m))\\n                }\\n            }\\n        }\\n\\n        return res\\n    }\\n```\\n![](https://windsuzu.github.io/leetcode-401/binary_watch.gif)",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc readBinaryWatch(_ num: Int) -> [String] {\\n        var res = [String]()\\n\\n        func findLEDs(_ h: Int, _ m: Int) -> Int {\\n            let hc = Array(String(h, radix: 2).characters).filter { $0 == \"1\" }.count\\n            let mc = Array(String(m, radix: 2).characters).filter { $0 == \"1\" }.count\\n            return hc + mc\\n        }\\n\\n        for h in 0...11 {\\n            for m in 0...59 {\\n                if findLEDs(h, m) == num {\\n                    res.append(String(format: \"%d:%02d\", h, m))\\n                }\\n            }\\n        }\\n\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88470,
                "title": "my-fancy-c-solution",
                "content": "Well, I hate *bi*nary wa*tch*!\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<vector<int>> hours{{0},{1,2,4,8},{3,5,9,6,10},{7,11}};\\n        vector<vector<int>> minutes{{0},{1,2,4,8,16,32},{3,5,9,17,33,6,10,18,34,12,20,36,24,40,48},{7,11,19,35,13,21,37,25,41,49,14,22,38,26,42,50,28,44,52,56},{15,23,39,27,43,51,29,45,53,57,30,46,54,58},{31,47,55,59}};\\n        vector<string> res;\\n        for (int k = 0; k <= num; ++k) {\\n            int t = num - k;\\n            if (k > 3 || t > 5) continue;\\n            for (int i = 0; i < hours[k].size(); ++i) {\\n                for (int j = 0; j < minutes[t].size(); ++j) {\\n                    string str = minutes[t][j] < 10 ? \"0\" + to_string(minutes[t][j]) : to_string(minutes[t][j]);\\n                    res.push_back(to_string(hours[k][i]) + \":\" + str);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<vector<int>> hours{{0}",
                "codeTag": "Java"
            },
            {
                "id": 2830233,
                "title": "c-solution",
                "content": "```\\nchar ** readBinaryWatch(int turnedOn, int* returnSize){\\n     char** final_arr = (char**)malloc(190*sizeof(char*));\\n    int count =0;\\n    for (int k=0;k<720;k++){ // 720 hours a day\\n        unsigned char h = k/60; // unsigned char from 0 to 255\\n        unsigned char m = k%60;\\n        int count_bit = 0;\\n        while(h>0){\\n            if (h%2==1){\\n                count_bit++;\\n            }\\n            h>>=1;\\n        }\\n        while (m>0){\\n            if (m%2==1){\\n                count_bit++;\\n            }\\n            m>>=1;\\n        }\\n        if (count_bit==turnedOn){\\n            final_arr[count]= (char*)malloc(8*sizeof(char));\\n            snprintf(final_arr[count],8,\"%d:%02d\",k/60,k%60);\\n            count++;\\n        }  \\n    }\\n    *returnSize = count;\\n return final_arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar ** readBinaryWatch(int turnedOn, int* returnSize){\\n     char** final_arr = (char**)malloc(190*sizeof(char*));\\n    int count =0;\\n    for (int k=0;k<720;k++){ // 720 hours a day\\n        unsigned char h = k/60; // unsigned char from 0 to 255\\n        unsigned char m = k%60;\\n        int count_bit = 0;\\n        while(h>0){\\n            if (h%2==1){\\n                count_bit++;\\n            }\\n            h>>=1;\\n        }\\n        while (m>0){\\n            if (m%2==1){\\n                count_bit++;\\n            }\\n            m>>=1;\\n        }\\n        if (count_bit==turnedOn){\\n            final_arr[count]= (char*)malloc(8*sizeof(char));\\n            snprintf(final_arr[count],8,\"%d:%02d\",k/60,k%60);\\n            count++;\\n        }  \\n    }\\n    *returnSize = count;\\n return final_arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2466389,
                "title": "c-efficient-sol-100-faster-0ms-runtime",
                "content": "**UPVOTE IF YOU LIKE** \\uD83D\\uDE0A\\u2705\\n```\\nclass Solution {\\npublic:\\n    int count_set_bits(int n){\\n        int ct=0;\\n        while(n){\\n            n=n&(n-1);\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string>times;\\n        string h;\\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<60;j++){\\n                h=\"\";\\n                if(count_set_bits(i)+count_set_bits(j)==turnedOn){\\n                    string hours=to_string(i);\\n                    string mins=(j>9)?to_string(j):\"0\"+to_string(j);\\n                    h=hours+\":\"+mins;\\n                    times.push_back(h);\\n                }\\n            }\\n        }\\n        return times;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count_set_bits(int n){\\n        int ct=0;\\n        while(n){\\n            n=n&(n-1);\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string>times;\\n        string h;\\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<60;j++){\\n                h=\"\";\\n                if(count_set_bits(i)+count_set_bits(j)==turnedOn){\\n                    string hours=to_string(i);\\n                    string mins=(j>9)?to_string(j):\"0\"+to_string(j);\\n                    h=hours+\":\"+mins;\\n                    times.push_back(h);\\n                }\\n            }\\n        }\\n        return times;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273210,
                "title": "binary-watch-c",
                "content": "```\\nclass Solution\\n{\\n    int bit_count(int num)\\n    {\\n        int count = 0;\\n        while (num)\\n        {\\n            count++;\\n            num &= (num - 1);\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn)\\n    {\\n        vector<string> result;\\n        for (int h = 0; h < 12; h++)\\n        {\\n            for (int m = 0; m < 60; m++)\\n            {\\n                if (bit_count(h) + bit_count(m) == turnedOn)\\n                {\\n                    result.push_back(to_string(h) + \":\" + (m < 10 ? (\"0\" + to_string(m)) : to_string(m)));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    int bit_count(int num)\\n    {\\n        int count = 0;\\n        while (num)\\n        {\\n            count++;\\n            num &= (num - 1);\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn)\\n    {\\n        vector<string> result;\\n        for (int h = 0; h < 12; h++)\\n        {\\n            for (int m = 0; m < 60; m++)\\n            {\\n                if (bit_count(h) + bit_count(m) == turnedOn)\\n                {\\n                    result.push_back(to_string(h) + \":\" + (m < 10 ? (\"0\" + to_string(m)) : to_string(m)));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218606,
                "title": "0ms-100-very-intuitive-solution-bit-manipulation-without-backtracking",
                "content": "just calculated all the permitted hours and minutes  by `vector<int> helperhr(int bit)  `      and\\n`vector<int> helpermm(int bit) ` function respectively by  checking the number of set bits in the numbers via `__builtin_popcount(i)` method and then map all the possible configurations\\nby checking condition `  if (__builtin_popcount(hr[i]) + __builtin_popcount(mm[j]) == turnedOn)`\\n```\\nvector<string> readBinaryWatch(int turnedOn)\\n{\\n    vector<int> hr = helperhr(turnedOn);\\n    vector<int> mm = helpermm(turnedOn);\\n    vector<string> hhmm;\\n    for (int i = 0; i < hr.size(); i++)\\n    {\\n        for (int j = 0; j < mm.size(); j++)\\n        {\\n            if (__builtin_popcount(hr[i]) + __builtin_popcount(mm[j]) == turnedOn)\\n            {\\n                string mins;\\n                if (mm[j] < 10)\\n                {\\n                    mins = \"0\" + to_string(mm[j]);\\n                }\\n                else\\n                {\\n                    mins = to_string(mm[j]);\\n                }\\n                // string hrs=\"\"+hr[i];\\n                hhmm.push_back(to_string(hr[i]) + \":\" + mins);\\n            }\\n        }\\n    }\\n    return hhmm;\\n}\\nvector<int> helperhr(int bit)\\n{\\n    vector<int> ans;\\n    for (int i = 0; i < 12; i++)\\n    {\\n        if (__builtin_popcount(i) <= bit)\\n        {\\n            // cout<<i<<\" \";\\n            ans.push_back(i);\\n        }\\n    }\\n    return ans;\\n}\\nvector<int> helpermm(int bit)\\n{\\n    vector<int> ans;\\n    for (int i = 0; i < 60; i++)\\n    {\\n        if (__builtin_popcount(i) <= bit)\\n        {\\n            // cout<<i<<\" \";\\n            ans.push_back(i);\\n        }\\n    }\\n    return ans;\\n}\\n\\n```\\n##### If you like this solution, do **UPVOTE**.\\n##### Feel free to ask any **doubts** in the comment section.\\n##### Happy Coding :)",
                "solutionTags": [],
                "code": "```\\nvector<string> readBinaryWatch(int turnedOn)\\n{\\n    vector<int> hr = helperhr(turnedOn);\\n    vector<int> mm = helpermm(turnedOn);\\n    vector<string> hhmm;\\n    for (int i = 0; i < hr.size(); i++)\\n    {\\n        for (int j = 0; j < mm.size(); j++)\\n        {\\n            if (__builtin_popcount(hr[i]) + __builtin_popcount(mm[j]) == turnedOn)\\n            {\\n                string mins;\\n                if (mm[j] < 10)\\n                {\\n                    mins = \"0\" + to_string(mm[j]);\\n                }\\n                else\\n                {\\n                    mins = to_string(mm[j]);\\n                }\\n                // string hrs=\"\"+hr[i];\\n                hhmm.push_back(to_string(hr[i]) + \":\" + mins);\\n            }\\n        }\\n    }\\n    return hhmm;\\n}\\nvector<int> helperhr(int bit)\\n{\\n    vector<int> ans;\\n    for (int i = 0; i < 12; i++)\\n    {\\n        if (__builtin_popcount(i) <= bit)\\n        {\\n            // cout<<i<<\" \";\\n            ans.push_back(i);\\n        }\\n    }\\n    return ans;\\n}\\nvector<int> helpermm(int bit)\\n{\\n    vector<int> ans;\\n    for (int i = 0; i < 60; i++)\\n    {\\n        if (__builtin_popcount(i) <= bit)\\n        {\\n            // cout<<i<<\" \";\\n            ans.push_back(i);\\n        }\\n    }\\n    return ans;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2173628,
                "title": "100-faster-and-easy-c-solution-with-explanation",
                "content": "Dear All,\\n\\nPlease find below 100% faster and easy C++ solution with explanation:\\n```\\n// Main goal is to sum bits for hours and minutes.\\n// When sum equal to turnedOn - time should be added to result vector\\n// Example: turnedOn = 1\\n// Step 1: h = 0; m = 0; binary number is 0000 for h and m; 0 + 0 != 1 => don\\'t add\\n// Step 2: h = 0; m = 1; binary number is 0000 for h and 0001 for m; 0 + 1 == 1 => add to result \"0:01\"(\"h:m\")\\n// Step 3: h = 0; m = 2; binary number is 0000 for h and 0010 for m; 0 + 1 == 1 => add to result \"0:02\"(\"h:m\")\\n// Step 4: h = 0; m = 3; binary number is 0000 for h and 0011 for m; 0 + 2 != 1 => don\\'t add\\n// Step 5: h = 0; m = 4; binary number is 0000 for h and 0100 for m; 0 + 1 == 1 => add to result \"0:04\"(\"h:m\")\\n// Step 6: h = 0; m = 5; binary number is 0000 for h and 0101 for m; 0 + 2 != 1 => don\\'t add\\n// ... and so on ...\\n\\n// Now the question is how to convert int to binary and count 1 bits. \\n// There is standard function __builtin_popcount(x). But I prefer to use my own for several reasons: \\n// first - you know and undestand how to do this, second - you show your knowlange to interviewer and this will be appreciated.\\n// For example we want to convert 5 to binary: onesBitsCount = 0\\n// Step 1: 5 remainder of the division on 2 = 1, 5 / 2 = 2; onesBitsCount = 0 + 1(remainder of the division on 2) => 1;\\n// Step 2: 2 remainder of the division on 2 = 0, 2 / 2 = 1; onesBitsCount = 1 + 0;\\n// Step 3: 1 remainder of the division on 2 = 1, 1 / 2 = 0 = stop. onesBitsCount = 1 + 1 = 2;\\n// Read binary from Step 3 to Step 1 => 101 => 0101 (because before 101 everything equal 0).\\n// To count how many 1\\'s bits we have to count remainder of the division on 2 on each step before changing int.\\n// Same approach works for any int.\\n\\nclass Solution {\\nprivate:\\n    int intToBinary(int n) {\\n        int res = 0;\\n        while(n > 0)\\n        {\\n            res += n%2;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> res;\\n        \\n        for(int h = 0; h < 12; ++h)\\n            for(int m = 0; m < 60; ++m)\\n            {\\n                if(intToBinary(h) + intToBinary(m) == turnedOn)\\n                {\\n                    string s = \"\";\\n                    s += to_string(h);\\n                    s.push_back(\\':\\');\\n                    if(m < 10) s.push_back(\\'0\\');\\n                    s += to_string(m);\\n                    res.push_back(s);\\n                }\\n            }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nHope you found this solution useful and clear.\\nIn case you have  questions please ask.\\n\\nThank you and have a good day.\\n\\nBest regards, Yevhen.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n// Main goal is to sum bits for hours and minutes.\\n// When sum equal to turnedOn - time should be added to result vector\\n// Example: turnedOn = 1\\n// Step 1: h = 0; m = 0; binary number is 0000 for h and m; 0 + 0 != 1 => don\\'t add\\n// Step 2: h = 0; m = 1; binary number is 0000 for h and 0001 for m; 0 + 1 == 1 => add to result \"0:01\"(\"h:m\")\\n// Step 3: h = 0; m = 2; binary number is 0000 for h and 0010 for m; 0 + 1 == 1 => add to result \"0:02\"(\"h:m\")\\n// Step 4: h = 0; m = 3; binary number is 0000 for h and 0011 for m; 0 + 2 != 1 => don\\'t add\\n// Step 5: h = 0; m = 4; binary number is 0000 for h and 0100 for m; 0 + 1 == 1 => add to result \"0:04\"(\"h:m\")\\n// Step 6: h = 0; m = 5; binary number is 0000 for h and 0101 for m; 0 + 2 != 1 => don\\'t add\\n// ... and so on ...\\n\\n// Now the question is how to convert int to binary and count 1 bits. \\n// There is standard function __builtin_popcount(x). But I prefer to use my own for several reasons: \\n// first - you know and undestand how to do this, second - you show your knowlange to interviewer and this will be appreciated.\\n// For example we want to convert 5 to binary: onesBitsCount = 0\\n// Step 1: 5 remainder of the division on 2 = 1, 5 / 2 = 2; onesBitsCount = 0 + 1(remainder of the division on 2) => 1;\\n// Step 2: 2 remainder of the division on 2 = 0, 2 / 2 = 1; onesBitsCount = 1 + 0;\\n// Step 3: 1 remainder of the division on 2 = 1, 1 / 2 = 0 = stop. onesBitsCount = 1 + 1 = 2;\\n// Read binary from Step 3 to Step 1 => 101 => 0101 (because before 101 everything equal 0).\\n// To count how many 1\\'s bits we have to count remainder of the division on 2 on each step before changing int.\\n// Same approach works for any int.\\n\\nclass Solution {\\nprivate:\\n    int intToBinary(int n) {\\n        int res = 0;\\n        while(n > 0)\\n        {\\n            res += n%2;\\n            n /= 2;\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> res;\\n        \\n        for(int h = 0; h < 12; ++h)\\n            for(int m = 0; m < 60; ++m)\\n            {\\n                if(intToBinary(h) + intToBinary(m) == turnedOn)\\n                {\\n                    string s = \"\";\\n                    s += to_string(h);\\n                    s.push_back(\\':\\');\\n                    if(m < 10) s.push_back(\\'0\\');\\n                    s += to_string(m);\\n                    res.push_back(s);\\n                }\\n            }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950999,
                "title": "rust-solution",
                "content": "1. Simple solution with cycles.\\n```\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        let nu = turned_on as u32;\\n        let mut result = Vec::new();\\n        for i in 0i32..12 {\\n            for j in 0i32..60 {\\n                if (i.count_ones() + j.count_ones()) == nu {\\n                    result.push(format!(\"{}:{:02}\", i, j));\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```\\n2. Functional one-liner.\\n```\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        (0i32..1023)\\n            .map(|n| (n.count_ones() as i32, n >> 6, n & 0b111111))\\n            .filter_map(|(count, h, m)| {\\n                if count == turned_on && h < 12 && m < 60 {\\n                    Some(format!(\"{}:{:02}\", h, m))\\n                } else {\\n                    None\\n                }\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        let nu = turned_on as u32;\\n        let mut result = Vec::new();\\n        for i in 0i32..12 {\\n            for j in 0i32..60 {\\n                if (i.count_ones() + j.count_ones()) == nu {\\n                    result.push(format!(\"{}:{:02}\", i, j));\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        (0i32..1023)\\n            .map(|n| (n.count_ones() as i32, n >> 6, n & 0b111111))\\n            .filter_map(|(count, h, m)| {\\n                if count == turned_on && h < 12 && m < 60 {\\n                    Some(format!(\"{}:{:02}\", h, m))\\n                } else {\\n                    None\\n                }\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1656686,
                "title": "python-solution-beats-92-based-on-hints",
                "content": "Hint one stated that we need to do the following : \"Simplify by seeking for solutions that involve comparing bit counts.\"\\nMy solution is based on a this itself. One can definitely just produce different switch cases, but I do not think leetcode wants that.\\nHere\\'s that.\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        ans =[]\\n        for h in range(0,12): #since there\\'s only 12 hours possible\\n            for m in range(0,60):   #since there\\'s only 59 mins possible, 60th min converts into the next hour             \\n                if (bin(h)+ bin(m)).count(\\'1\\') == turnedOn:  #Using hint 1\\n                    time = str(h) + \":\"   #manually adjusting the string for 2 cases, one when minutes < 10 and other for all others\\n                    if m<10:\\n                        time += \"0\" + str(m) \\n                    else:\\n                        time += str(m) \\n                    ans.append(time)   #append first time, repeat this step \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        ans =[]\\n        for h in range(0,12): #since there\\'s only 12 hours possible\\n            for m in range(0,60):   #since there\\'s only 59 mins possible, 60th min converts into the next hour             \\n                if (bin(h)+ bin(m)).count(\\'1\\') == turnedOn:  #Using hint 1\\n                    time = str(h) + \":\"   #manually adjusting the string for 2 cases, one when minutes < 10 and other for all others\\n                    if m<10:\\n                        time += \"0\" + str(m) \\n                    else:\\n                        time += str(m) \\n                    ans.append(time)   #append first time, repeat this step \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589776,
                "title": "bitset-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> result;\\n        for(int hrs = 0; hrs < 12; hrs++)\\n        {\\n            for(int mins = 0; mins < 60; mins++ )\\n            {\\n                bitset<4> b_hrs = bitset<4>(hrs); //create 4 bits for hours (max 16, only need 11 at max)\\n                bitset<6> b_mins = bitset<6>(mins); // 6bits for mins(max 63, only need to 59 at max)\\n                if(b_hrs.count() + b_mins.count() == turnedOn) //if num matches the sum of total bits (1) count\\n                {                                               //then push result to vector\\n                    string temp = \"\";\\n                    temp += to_string(hrs) + \":\";\\n                    if(mins < 10)\\n                        temp += \"0\";\\n                    temp += to_string(mins);\\n                    result.push_back(temp);\\n                }\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> result;\\n        for(int hrs = 0; hrs < 12; hrs++)\\n        {\\n            for(int mins = 0; mins < 60; mins++ )\\n            {\\n                bitset<4> b_hrs = bitset<4>(hrs); //create 4 bits for hours (max 16, only need 11 at max)\\n                bitset<6> b_mins = bitset<6>(mins); // 6bits for mins(max 63, only need to 59 at max)\\n                if(b_hrs.count() + b_mins.count() == turnedOn) //if num matches the sum of total bits (1) count\\n                {                                               //then push result to vector\\n                    string temp = \"\";\\n                    temp += to_string(hrs) + \":\";\\n                    if(mins < 10)\\n                        temp += \"0\";\\n                    temp += to_string(mins);\\n                    result.push_back(temp);\\n                }\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308993,
                "title": "cpp-easy-solution-iterative-method",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> readBinaryWatch(int turnedon)\\n    {\\n        vector<string> time;\\n        for(int i=0;i<12;i++){\\n            bitset<4> hour(i);\\n            for(int j=0;j<60;j++){\\n                bitset<6> minutes(j);\\n                if(hour.count()+minutes.count()==turnedon){\\n                    string h=to_string(i);\\n                    string m=(j<10)?\":0\":\":\";\\n                    m+=to_string(j);\\n                    time.push_back(h+m);\\n                }\\n            }\\n        }\\n        return time;     \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> readBinaryWatch(int turnedon)\\n    {\\n        vector<string> time;\\n        for(int i=0;i<12;i++){\\n            bitset<4> hour(i);\\n            for(int j=0;j<60;j++){\\n                bitset<6> minutes(j);\\n                if(hour.count()+minutes.count()==turnedon){\\n                    string h=to_string(i);\\n                    string m=(j<10)?\":0\":\":\";\\n                    m+=to_string(j);\\n                    time.push_back(h+m);\\n                }\\n            }\\n        }\\n        return time;     \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245344,
                "title": "c-100-faster-runtime-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    string convertToTime(vector<bool>& bits) {\\n        string time = \"\";\\n        int hr=0, min =0;\\n        for(int i=3;i>=0;i--) {\\n            if(bits[i])  hr += pow(2, 3-i);\\n        } \\n       \\n        for(int i=9;i>=4;i--) {\\n            if(bits[i]) min += pow(2, 9-i);\\n        }\\n        if(hr<12 && min<60) {\\n            time+=to_string(hr)+ \":\";\\n            if(min<10) time += \"0\" + to_string(min);\\n            else time += to_string(min);\\n        }\\n        \\n        return time;\\n    }\\n    \\n    void getTime(vector<string> &ans, vector<bool>& bits, int turnedOn, int setBits, int index) {\\n        \\n        if(turnedOn == setBits) {\\n            string time = convertToTime(bits);\\n            if(time.size()>0) ans.push_back(time);\\n        }\\n        if(index==10) return;\\n        \\n        for(int i=index;i<10;i++) {\\n            bits[i] = true;\\n            getTime(ans, bits, turnedOn, setBits+1, i+1);\\n            bits[i] = false;\\n        }\\n       \\n    }\\n    \\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<bool> bits(10, false);\\n        vector<string> ans;\\n        int setBits = 0, index = 0;\\n        getTime(ans, bits, turnedOn, setBits, index);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string convertToTime(vector<bool>& bits) {\\n        string time = \"\";\\n        int hr=0, min =0;\\n        for(int i=3;i>=0;i--) {\\n            if(bits[i])  hr += pow(2, 3-i);\\n        } \\n       \\n        for(int i=9;i>=4;i--) {\\n            if(bits[i]) min += pow(2, 9-i);\\n        }\\n        if(hr<12 && min<60) {\\n            time+=to_string(hr)+ \":\";\\n            if(min<10) time += \"0\" + to_string(min);\\n            else time += to_string(min);\\n        }\\n        \\n        return time;\\n    }\\n    \\n    void getTime(vector<string> &ans, vector<bool>& bits, int turnedOn, int setBits, int index) {\\n        \\n        if(turnedOn == setBits) {\\n            string time = convertToTime(bits);\\n            if(time.size()>0) ans.push_back(time);\\n        }\\n        if(index==10) return;\\n        \\n        for(int i=index;i<10;i++) {\\n            bits[i] = true;\\n            getTime(ans, bits, turnedOn, setBits+1, i+1);\\n            bits[i] = false;\\n        }\\n       \\n    }\\n    \\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<bool> bits(10, false);\\n        vector<string> ans;\\n        int setBits = 0, index = 0;\\n        getTime(ans, bits, turnedOn, setBits, index);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202029,
                "title": "c-100-faster-binary-watch",
                "content": "```\\nclass Solution {\\npublic:\\n    string ToString(int hour, int minute){\\n        return to_string(hour) + \":\" + (minute < 10 ? \"0\" : \"\") + to_string(minute);\\n    }\\n    int bits(int n){\\n        int cnt=0;\\n        while(n){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    vector<string> readBinaryWatch(int n) {\\n        int hour,minute;\\n        vector<string> res;\\n        for(hour=0;hour<12;hour++){\\n            for(minute=0;minute<60;minute++){\\n                if(bits(hour)+bits(minute)==n) res.push_back(ToString(hour,minute));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string ToString(int hour, int minute){\\n        return to_string(hour) + \":\" + (minute < 10 ? \"0\" : \"\") + to_string(minute);\\n    }\\n    int bits(int n){\\n        int cnt=0;\\n        while(n){\\n            n=n&(n-1);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    vector<string> readBinaryWatch(int n) {\\n        int hour,minute;\\n        vector<string> res;\\n        for(hour=0;hour<12;hour++){\\n            for(minute=0;minute<60;minute++){\\n                if(bits(hour)+bits(minute)==n) res.push_back(ToString(hour,minute));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076038,
                "title": "strainght-forward-solution-using-basics-python",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        res=[]\\n        for hour in range(12):\\n            for minutes in range(60):\\n                if bin(hour)[2:].count(\\'1\\')+bin(minutes)[2:].count(\\'1\\') ==num:\\n                        y= \\'{}:{}\\'.format(hour,str(minutes).zfill(2))\\n                        res.append(y)\\n        return res\\n```\\nwhat we are doing here is sum(counting number of bits in hours,counting number of bits in minutes) if this is equal to given num we are appending it to res........don\\'t forget to use zfill and .format to get desirable output...",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        res=[]\\n        for hour in range(12):\\n            for minutes in range(60):\\n                if bin(hour)[2:].count(\\'1\\')+bin(minutes)[2:].count(\\'1\\') ==num:\\n                        y= \\'{}:{}\\'.format(hour,str(minutes).zfill(2))\\n                        res.append(y)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076006,
                "title": "easy-python",
                "content": "```python\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        def countBits(n):\\n            ans = 0\\n            while n:\\n                if (n & 1): ans += 1\\n                n >>= 1\\n            return ans\\n        \\n        res = []\\n        for i in range(12):\\n            for j in range(60):\\n                if(countBits(i) + countBits(j) == num):\\n                    one = str(i)\\n                    two = \"0\" + str(j)\\n                    if j >= 10:\\n                        two = str(j)\\n                    res.append(one + \":\" +two)\\n        return res\\n                    \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        def countBits(n):\\n            ans = 0\\n            while n:\\n                if (n & 1): ans += 1\\n                n >>= 1\\n            return ans\\n        \\n        res = []\\n        for i in range(12):\\n            for j in range(60):\\n                if(countBits(i) + countBits(j) == num):\\n                    one = str(i)\\n                    two = \"0\" + str(j)\\n                    if j >= 10:\\n                        two = str(j)\\n                    res.append(one + \":\" +two)\\n        return res\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 932423,
                "title": "java-backtrack",
                "content": "Backtrack every lights with index. We can choose either pick this light or not. Before actually recursively call the function, I checked whether the number of hours and minutes are still available **(hours: 0-11, minutes: 0-59 )**. The res list passed into the function is used for recording answers when returns.\\n```java\\nclass Solution {\\n    int[] map = {1,2,4,8,1,2,4,8,16,32};\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        backtrack(res, 0, 0, 0, num);\\n        return res;\\n    }\\n    public void backtrack(List<String> res, int curHour, int curMinute, int index, int left){\\n        if(index == 10 && left!=0) return;\\n        else if(left==0){\\n            res.add(translate(curHour, curMinute));\\n            return;\\n        }else{\\n            if(index<4&&curHour+map[index]<12) {\\n                backtrack(res, curHour+map[index], curMinute, index+1, left-1);\\n            }else if(index>=4 && curMinute+map[index]<60){\\n                backtrack(res, curHour, curMinute+map[index], index+1, left-1);\\n            }\\n            backtrack(res, curHour, curMinute, index+1, left);\\n        }\\n    }\\n    public String translate(int hour, int minute){\\n        if(minute<10) return String.valueOf(hour)+\":0\"+String.valueOf(minute);\\n        else return String.valueOf(hour)+\":\"+String.valueOf(minute);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    int[] map = {1,2,4,8,1,2,4,8,16,32};\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        backtrack(res, 0, 0, 0, num);\\n        return res;\\n    }\\n    public void backtrack(List<String> res, int curHour, int curMinute, int index, int left){\\n        if(index == 10 && left!=0) return;\\n        else if(left==0){\\n            res.add(translate(curHour, curMinute));\\n            return;\\n        }else{\\n            if(index<4&&curHour+map[index]<12) {\\n                backtrack(res, curHour+map[index], curMinute, index+1, left-1);\\n            }else if(index>=4 && curMinute+map[index]<60){\\n                backtrack(res, curHour, curMinute+map[index], index+1, left-1);\\n            }\\n            backtrack(res, curHour, curMinute, index+1, left);\\n        }\\n    }\\n    public String translate(int hour, int minute){\\n        if(minute<10) return String.valueOf(hour)+\":0\"+String.valueOf(minute);\\n        else return String.valueOf(hour)+\":\"+String.valueOf(minute);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719482,
                "title": "java-clean-code-easy-and-optimal-solution",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic List<String> readBinaryWatch (int num) {\\n\\t\\t\\n\\t\\tList<String> times = new LinkedList <>();\\n\\t\\t\\n\\t\\tfor (int hour = 0; hour < 12; ++hour) {\\n\\t\\t\\tfor (int minute = 0; minute < 60; ++minute) {\\n\\t\\t\\t\\tif (Integer.bitCount (hour) + Integer.bitCount (minute) == num) {\\n\\t\\t\\t\\t\\ttimes.add (hour + \":\" + (minute <= 9 ? \"0\" + minute : minute));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn times;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic List<String> readBinaryWatch (int num) {\\n\\t\\t\\n\\t\\tList<String> times = new LinkedList <>();\\n\\t\\t\\n\\t\\tfor (int hour = 0; hour < 12; ++hour) {\\n\\t\\t\\tfor (int minute = 0; minute < 60; ++minute) {\\n\\t\\t\\t\\tif (Integer.bitCount (hour) + Integer.bitCount (minute) == num) {\\n\\t\\t\\t\\t\\ttimes.add (hour + \":\" + (minute <= 9 ? \"0\" + minute : minute));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn times;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694258,
                "title": "python-3-table-driven",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int):\\n        \"\"\"\\n        Given a number of lit LEDs, this program returns all possible times\\n        with that many LEDs lit. It uses a table-driven approach.\\n\\n        :param num: number of lit LEDs\\n        :type num: int\\n        :return: all possible times with num LEDs lit\\n        :rtype: list[str]\\n        \"\"\"\\n        hours_map = \\\\\\n            {\\n                0: [\\'0:\\'],\\n                1: [\\'1:\\', \\'2:\\', \\'4:\\', \\'8:\\'],\\n                2: [\\'3:\\', \\'5:\\', \\'6:\\', \\'9:\\', \\'10:\\'],\\n                3: [\\'7:\\', \\'11:\\']\\n            }\\n        minutes_map = \\\\\\n            {\\n                0: [\\'00\\'],\\n                1: [\\'01\\', \\'02\\', \\'04\\', \\'08\\', \\'16\\', \\'32\\'],\\n                2: [\\'03\\', \\'05\\', \\'06\\', \\'09\\', \\'10\\', \\'12\\', \\'17\\', \\'18\\',\\n                    \\'20\\', \\'24\\', \\'33\\', \\'34\\', \\'36\\', \\'40\\', \\'48\\'],\\n                3: [\\'07\\', \\'11\\', \\'13\\', \\'14\\', \\'19\\', \\'21\\', \\'22\\', \\'25\\',\\n                    \\'26\\', \\'28\\', \\'35\\', \\'37\\', \\'38\\', \\'41\\', \\'42\\', \\'44\\',\\n                    \\'49\\', \\'50\\', \\'52\\', \\'56\\'],\\n                4: [\\'15\\', \\'23\\', \\'27\\', \\'29\\', \\'30\\', \\'39\\', \\'43\\', \\'45\\',\\n                    \\'46\\', \\'51\\', \\'53\\', \\'54\\', \\'57\\', \\'58\\'],\\n                5: [\\'31\\', \\'47\\', \\'55\\', \\'59\\']\\n            }\\n        nums_map = \\\\\\n            {\\n                0: [(0, 0)],\\n                1: [(0, 1), (1, 0)],\\n                2: [(0, 2), (1, 1), (2, 0)],\\n                3: [(0, 3), (1, 2), (2, 1), (3, 0)],\\n                4: [(0, 4), (1, 3), (2, 2), (3, 1)],\\n                5: [(0, 5), (1, 4), (2, 3), (3, 2)],\\n                6: [(1, 5), (2, 4), (3, 3)],\\n                7: [(2, 5), (3, 4)],\\n                8: [(3, 5)],\\n            }\\n        if num not in nums_map:\\n            return []\\n        times = []\\n        for hours, minutes in nums_map[num]:\\n            for hour in hours_map[hours]:\\n                for minute in minutes_map[minutes]:\\n                    times.append(\\'\\'.join([hour, minute]))\\n        return times\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int):\\n        \"\"\"\\n        Given a number of lit LEDs, this program returns all possible times\\n        with that many LEDs lit. It uses a table-driven approach.\\n\\n        :param num: number of lit LEDs\\n        :type num: int\\n        :return: all possible times with num LEDs lit\\n        :rtype: list[str]\\n        \"\"\"\\n        hours_map = \\\\\\n            {\\n                0: [\\'0:\\'],\\n                1: [\\'1:\\', \\'2:\\', \\'4:\\', \\'8:\\'],\\n                2: [\\'3:\\', \\'5:\\', \\'6:\\', \\'9:\\', \\'10:\\'],\\n                3: [\\'7:\\', \\'11:\\']\\n            }\\n        minutes_map = \\\\\\n            {\\n                0: [\\'00\\'],\\n                1: [\\'01\\', \\'02\\', \\'04\\', \\'08\\', \\'16\\', \\'32\\'],\\n                2: [\\'03\\', \\'05\\', \\'06\\', \\'09\\', \\'10\\', \\'12\\', \\'17\\', \\'18\\',\\n                    \\'20\\', \\'24\\', \\'33\\', \\'34\\', \\'36\\', \\'40\\', \\'48\\'],\\n                3: [\\'07\\', \\'11\\', \\'13\\', \\'14\\', \\'19\\', \\'21\\', \\'22\\', \\'25\\',\\n                    \\'26\\', \\'28\\', \\'35\\', \\'37\\', \\'38\\', \\'41\\', \\'42\\', \\'44\\',\\n                    \\'49\\', \\'50\\', \\'52\\', \\'56\\'],\\n                4: [\\'15\\', \\'23\\', \\'27\\', \\'29\\', \\'30\\', \\'39\\', \\'43\\', \\'45\\',\\n                    \\'46\\', \\'51\\', \\'53\\', \\'54\\', \\'57\\', \\'58\\'],\\n                5: [\\'31\\', \\'47\\', \\'55\\', \\'59\\']\\n            }\\n        nums_map = \\\\\\n            {\\n                0: [(0, 0)],\\n                1: [(0, 1), (1, 0)],\\n                2: [(0, 2), (1, 1), (2, 0)],\\n                3: [(0, 3), (1, 2), (2, 1), (3, 0)],\\n                4: [(0, 4), (1, 3), (2, 2), (3, 1)],\\n                5: [(0, 5), (1, 4), (2, 3), (3, 2)],\\n                6: [(1, 5), (2, 4), (3, 3)],\\n                7: [(2, 5), (3, 4)],\\n                8: [(3, 5)],\\n            }\\n        if num not in nums_map:\\n            return []\\n        times = []\\n        for hours, minutes in nums_map[num]:\\n            for hour in hours_map[hours]:\\n                for minute in minutes_map[minutes]:\\n                    times.append(\\'\\'.join([hour, minute]))\\n        return times\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625603,
                "title": "simple-c-backtracking-solution",
                "content": "```\\nint hours[4] = {1,2,4,8};\\nint minutes[6] = {1,2,4,8,16,32};\\n\\nvector<string> readBinaryWatch(int num) {\\n\\tvector<string> res;\\n\\tbacktrack(0, 0, num, 0, res);\\n\\treturn res;\\n}\\n\\nvoid backtrack(int h, int m, int num_on, int start, vector<string>& times) {\\n\\tif (num_on == 0) {\\n\\t\\ttimes.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i < 10; i++) {\\n\\t\\tif (i < 4) {\\n\\t\\t\\th += hours[i];\\n\\t\\t\\tif (h < 12) \\n\\t\\t\\t\\tbacktrack(h, m, num_on-1, i+1, times);\\n\\t\\t\\th -= hours[i];\\n\\t\\t} else {\\n\\t\\t\\tm += minutes[i-4];\\n\\t\\t\\tif (m < 60) \\n\\t\\t\\t\\tbacktrack(h, m, num_on-1, i+1, times);\\n\\t\\t\\tm -= minutes[i-4];\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nTo use the **backtracking** paradigm in general, we try to solve problems by incrementally building up solutions, as shown in the following pseudocode approach: \\n- For every possible option:\\n\\t- Select a *valid* option or path to traverse down. (here, checking for *validity* may involve checking certain constraints)\\n\\t- Recursively try to solve the smaller problem having selected the option. (note that the problem space must be smaller in some way)\\n\\t- Undo the selection of the option. (due to recursion, this will *roll back* solutions as they fail) \\n\\nTo solve the binary watch problem specifically:\\n- We want to build a collection of all possible times.\\n- The possible options are which of the LEDs on the watch are on.\\n- Selecting an LED to be on should update the current time, and then *remove* the LED from consideration and thus shrink the problem space.\\n\\t- This is done in the algorithm by considering the LEDs in a set order (1 hour to 8 hours, and 1 minute to 32 minutes) and specifying a starting index `start`.\\n\\nThus our algorithm runs as follows:\\n- If there are no more LEDs to turn on, add the current time to the collection of times.\\n- For each represented LED after the starting index `start`:\\n\\t- Select the LED as being on and update the current time represented by `h` and `m` accordingly.\\n\\t- Recursively try to solve with the remaining possible LEDs having selected this LED.\\n\\t- Undo the selection of the LED by resetting the current time.\\n\\nComplexity:\\n- The time complexity is O(2^n) since each LED can be on or off. Note that n is also bounded by 10 since there are only 10 LEDs.\\n- The space complexity is bounded by the depth of the recursion tree, which is O(n).",
                "solutionTags": [],
                "code": "```\\nint hours[4] = {1,2,4,8};\\nint minutes[6] = {1,2,4,8,16,32};\\n\\nvector<string> readBinaryWatch(int num) {\\n\\tvector<string> res;\\n\\tbacktrack(0, 0, num, 0, res);\\n\\treturn res;\\n}\\n\\nvoid backtrack(int h, int m, int num_on, int start, vector<string>& times) {\\n\\tif (num_on == 0) {\\n\\t\\ttimes.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i < 10; i++) {\\n\\t\\tif (i < 4) {\\n\\t\\t\\th += hours[i];\\n\\t\\t\\tif (h < 12) \\n\\t\\t\\t\\tbacktrack(h, m, num_on-1, i+1, times);\\n\\t\\t\\th -= hours[i];\\n\\t\\t} else {\\n\\t\\t\\tm += minutes[i-4];\\n\\t\\t\\tif (m < 60) \\n\\t\\t\\t\\tbacktrack(h, m, num_on-1, i+1, times);\\n\\t\\t\\tm -= minutes[i-4];\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616224,
                "title": "java-solution-using-loops",
                "content": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        ArrayList<String> ans= new ArrayList();\\n        \\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<60;j++){\\n              if(Integer.bitCount(i) + Integer.bitCount(j) == num  ){\\n                  \\n                  String str = \"\" + i + \":\";\\n                  if(j<10) str+= \"0\";\\n                  str+= \"\"+j;\\n                  ans.add(str);\\n              }        \\n          }\\n        }\\n               return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        ArrayList<String> ans= new ArrayList();\\n        \\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<60;j++){\\n              if(Integer.bitCount(i) + Integer.bitCount(j) == num  ){\\n                  \\n                  String str = \"\" + i + \":\";\\n                  if(j<10) str+= \"0\";\\n                  str+= \"\"+j;\\n                  ans.add(str);\\n              }        \\n          }\\n        }\\n               return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611179,
                "title": "c-beats-100-00-runtime-and-100-00-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> ans;\\n        for (int h = 0; h < 12; h++) {\\n            for (int m = 0; m < 60; m++) {\\n                int count = bitset<10>((h << 6) + m).count();\\n                if (count == num) {\\n                    char buf[100];\\n                    sprintf(buf, \"%d:%02d\", h, m);\\n                    ans.push_back(buf);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> ans;\\n        for (int h = 0; h < 12; h++) {\\n            for (int m = 0; m < 60; m++) {\\n                int count = bitset<10>((h << 6) + m).count();\\n                if (count == num) {\\n                    char buf[100];\\n                    sprintf(buf, \"%d:%02d\", h, m);\\n                    ans.push_back(buf);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557900,
                "title": "python-hash-table-beats-92",
                "content": "Use a hashtable and store all the possible minutes and hours before you actually parse the input.\\n\\n```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        \\n        hours = collections.defaultdict(list)\\n        minutes = collections.defaultdict(list)\\n        \\n        for hr in range(0,12):\\n            ct = bin(hr)[2:].zfill(4).count(\"1\")\\n            hours[ct].append(hr)\\n            \\n        for Min in range(0,60):\\n            ct = bin(Min)[2:].zfill(4).count(\"1\")\\n            minutes[ct].append(Min)    \\n        \\n        maxHr = min(4,num)\\n        out = []\\n        for hrDots in range(maxHr+1):\\n            MinDots= num-hrDots\\n\\n            for hr in hours[hrDots]:\\n                for Min in minutes[MinDots]:\\n                    out.append(str(hr)+\":\"+str(Min).zfill(2))     \\n                    \\n        return out\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        \\n        hours = collections.defaultdict(list)\\n        minutes = collections.defaultdict(list)\\n        \\n        for hr in range(0,12):\\n            ct = bin(hr)[2:].zfill(4).count(\"1\")\\n            hours[ct].append(hr)\\n            \\n        for Min in range(0,60):\\n            ct = bin(Min)[2:].zfill(4).count(\"1\")\\n            minutes[ct].append(Min)    \\n        \\n        maxHr = min(4,num)\\n        out = []\\n        for hrDots in range(maxHr+1):\\n            MinDots= num-hrDots\\n\\n            for hr in hours[hrDots]:\\n                for Min in minutes[MinDots]:\\n                    out.append(str(hr)+\":\"+str(Min).zfill(2))     \\n                    \\n        return out\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 520604,
                "title": "python-solution",
                "content": "i represent hours, j represent mins. i << 6 means the first 4 bits, j means the last 6 bits. Count the combined number has how many \\'1\\' s, if \\'1\\'s eauals to n, then append it.\\n```\\nclass Solution(object):\\n    def readBinaryWatch(self, n):\\n        res = []\\n        for i in range(12):\\n            for j in range(60):\\n                number = bin(i << 6 | j)\\n                if number.count(\\'1\\') == n:\\n                    cur = str(i) + \\':\\' + str(j) if j > 9 else str(i) + \\':0\\' + str(j)\\n                    res.append(cur)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def readBinaryWatch(self, n):\\n        res = []\\n        for i in range(12):\\n            for j in range(60):\\n                number = bin(i << 6 | j)\\n                if number.count(\\'1\\') == n:\\n                    cur = str(i) + \\':\\' + str(j) if j > 9 else str(i) + \\':0\\' + str(j)\\n                    res.append(cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460635,
                "title": "python-3-o-1-solution",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        if num > 8: return []\\n        return {0: [\\'0:00\\'],\\n                1: [\\'0:01\\', \\'0:02\\', \\'0:04\\', \\'0:08\\', \\'0:16\\', \\'0:32\\', \\'1:00\\', \\'2:00\\', \\'4:00\\', \\'8:00\\'],\\n                2: [\\'0:03\\', \\'0:05\\', \\'0:06\\', \\'0:09\\', \\'0:10\\', \\'0:12\\', \\'0:17\\', \\'0:18\\', \\'0:20\\', \\'0:24\\', \\'0:33\\', \\'0:34\\', \\'0:36\\', \\'0:40\\', \\'0:48\\', \\'1:01\\', \\'1:02\\', \\'1:04\\', \\'1:08\\', \\'1:16\\', \\'1:32\\', \\'2:01\\', \\'2:02\\', \\'2:04\\', \\'2:08\\', \\'2:16\\', \\'2:32\\', \\'3:00\\', \\'4:01\\', \\'4:02\\', \\'4:04\\', \\'4:08\\', \\'4:16\\', \\'4:32\\', \\'5:00\\', \\'6:00\\', \\'8:01\\', \\'8:02\\', \\'8:04\\', \\'8:08\\', \\'8:16\\', \\'8:32\\', \\'9:00\\', \\'10:00\\'],\\n                3: [\\'0:07\\', \\'0:11\\', \\'0:13\\', \\'0:14\\', \\'0:19\\', \\'0:21\\', \\'0:22\\', \\'0:25\\', \\'0:26\\', \\'0:28\\', \\'0:35\\', \\'0:37\\', \\'0:38\\', \\'0:41\\', \\'0:42\\', \\'0:44\\', \\'0:49\\', \\'0:50\\', \\'0:52\\', \\'0:56\\', \\'1:03\\', \\'1:05\\', \\'1:06\\', \\'1:09\\', \\'1:10\\', \\'1:12\\', \\'1:17\\', \\'1:18\\', \\'1:20\\', \\'1:24\\', \\'1:33\\', \\'1:34\\', \\'1:36\\', \\'1:40\\', \\'1:48\\', \\'2:03\\', \\'2:05\\', \\'2:06\\', \\'2:09\\', \\'2:10\\', \\'2:12\\', \\'2:17\\', \\'2:18\\', \\'2:20\\', \\'2:24\\', \\'2:33\\', \\'2:34\\', \\'2:36\\', \\'2:40\\', \\'2:48\\', \\'3:01\\', \\'3:02\\', \\'3:04\\', \\'3:08\\', \\'3:16\\', \\'3:32\\', \\'4:03\\', \\'4:05\\', \\'4:06\\', \\'4:09\\', \\'4:10\\', \\'4:12\\', \\'4:17\\', \\'4:18\\', \\'4:20\\', \\'4:24\\', \\'4:33\\', \\'4:34\\', \\'4:36\\', \\'4:40\\', \\'4:48\\', \\'5:01\\', \\'5:02\\', \\'5:04\\', \\'5:08\\', \\'5:16\\', \\'5:32\\', \\'6:01\\', \\'6:02\\', \\'6:04\\', \\'6:08\\', \\'6:16\\', \\'6:32\\', \\'7:00\\', \\'8:03\\', \\'8:05\\', \\'8:06\\', \\'8:09\\', \\'8:10\\', \\'8:12\\', \\'8:17\\', \\'8:18\\', \\'8:20\\', \\'8:24\\', \\'8:33\\', \\'8:34\\', \\'8:36\\', \\'8:40\\', \\'8:48\\', \\'9:01\\', \\'9:02\\', \\'9:04\\', \\'9:08\\', \\'9:16\\', \\'9:32\\', \\'10:01\\', \\'10:02\\', \\'10:04\\', \\'10:08\\', \\'10:16\\', \\'10:32\\', \\'11:00\\'],\\n                4: [\\'0:15\\', \\'0:23\\', \\'0:27\\', \\'0:29\\', \\'0:30\\', \\'0:39\\', \\'0:43\\', \\'0:45\\', \\'0:46\\', \\'0:51\\', \\'0:53\\', \\'0:54\\', \\'0:57\\', \\'0:58\\', \\'1:07\\', \\'1:11\\', \\'1:13\\', \\'1:14\\', \\'1:19\\', \\'1:21\\', \\'1:22\\', \\'1:25\\', \\'1:26\\', \\'1:28\\', \\'1:35\\', \\'1:37\\', \\'1:38\\', \\'1:41\\', \\'1:42\\', \\'1:44\\', \\'1:49\\', \\'1:50\\', \\'1:52\\', \\'1:56\\', \\'2:07\\', \\'2:11\\', \\'2:13\\', \\'2:14\\', \\'2:19\\', \\'2:21\\', \\'2:22\\', \\'2:25\\', \\'2:26\\', \\'2:28\\', \\'2:35\\', \\'2:37\\', \\'2:38\\', \\'2:41\\', \\'2:42\\', \\'2:44\\', \\'2:49\\', \\'2:50\\', \\'2:52\\', \\'2:56\\', \\'3:03\\', \\'3:05\\', \\'3:06\\', \\'3:09\\', \\'3:10\\', \\'3:12\\', \\'3:17\\', \\'3:18\\', \\'3:20\\', \\'3:24\\', \\'3:33\\', \\'3:34\\', \\'3:36\\', \\'3:40\\', \\'3:48\\', \\'4:07\\', \\'4:11\\', \\'4:13\\', \\'4:14\\', \\'4:19\\', \\'4:21\\', \\'4:22\\', \\'4:25\\', \\'4:26\\', \\'4:28\\', \\'4:35\\', \\'4:37\\', \\'4:38\\', \\'4:41\\', \\'4:42\\', \\'4:44\\', \\'4:49\\', \\'4:50\\', \\'4:52\\', \\'4:56\\', \\'5:03\\', \\'5:05\\', \\'5:06\\', \\'5:09\\', \\'5:10\\', \\'5:12\\', \\'5:17\\', \\'5:18\\', \\'5:20\\', \\'5:24\\', \\'5:33\\', \\'5:34\\', \\'5:36\\', \\'5:40\\', \\'5:48\\', \\'6:03\\', \\'6:05\\', \\'6:06\\', \\'6:09\\', \\'6:10\\', \\'6:12\\', \\'6:17\\', \\'6:18\\', \\'6:20\\', \\'6:24\\', \\'6:33\\', \\'6:34\\', \\'6:36\\', \\'6:40\\', \\'6:48\\', \\'7:01\\', \\'7:02\\', \\'7:04\\', \\'7:08\\', \\'7:16\\', \\'7:32\\', \\'8:07\\', \\'8:11\\', \\'8:13\\', \\'8:14\\', \\'8:19\\', \\'8:21\\', \\'8:22\\', \\'8:25\\', \\'8:26\\', \\'8:28\\', \\'8:35\\', \\'8:37\\', \\'8:38\\', \\'8:41\\', \\'8:42\\', \\'8:44\\', \\'8:49\\', \\'8:50\\', \\'8:52\\', \\'8:56\\', \\'9:03\\', \\'9:05\\', \\'9:06\\', \\'9:09\\', \\'9:10\\', \\'9:12\\', \\'9:17\\', \\'9:18\\', \\'9:20\\', \\'9:24\\', \\'9:33\\', \\'9:34\\', \\'9:36\\', \\'9:40\\', \\'9:48\\', \\'10:03\\', \\'10:05\\', \\'10:06\\', \\'10:09\\', \\'10:10\\', \\'10:12\\', \\'10:17\\', \\'10:18\\', \\'10:20\\', \\'10:24\\', \\'10:33\\', \\'10:34\\', \\'10:36\\', \\'10:40\\', \\'10:48\\', \\'11:01\\', \\'11:02\\', \\'11:04\\', \\'11:08\\', \\'11:16\\', \\'11:32\\'],\\n                5: [\\'0:31\\', \\'0:47\\', \\'0:55\\', \\'0:59\\', \\'1:15\\', \\'1:23\\', \\'1:27\\', \\'1:29\\', \\'1:30\\', \\'1:39\\', \\'1:43\\', \\'1:45\\', \\'1:46\\', \\'1:51\\', \\'1:53\\', \\'1:54\\', \\'1:57\\', \\'1:58\\', \\'2:15\\', \\'2:23\\', \\'2:27\\', \\'2:29\\', \\'2:30\\', \\'2:39\\', \\'2:43\\', \\'2:45\\', \\'2:46\\', \\'2:51\\', \\'2:53\\', \\'2:54\\', \\'2:57\\', \\'2:58\\', \\'3:07\\', \\'3:11\\', \\'3:13\\', \\'3:14\\', \\'3:19\\', \\'3:21\\', \\'3:22\\', \\'3:25\\', \\'3:26\\', \\'3:28\\', \\'3:35\\', \\'3:37\\', \\'3:38\\', \\'3:41\\', \\'3:42\\', \\'3:44\\', \\'3:49\\', \\'3:50\\', \\'3:52\\', \\'3:56\\', \\'4:15\\', \\'4:23\\', \\'4:27\\', \\'4:29\\', \\'4:30\\', \\'4:39\\', \\'4:43\\', \\'4:45\\', \\'4:46\\', \\'4:51\\', \\'4:53\\', \\'4:54\\', \\'4:57\\', \\'4:58\\', \\'5:07\\', \\'5:11\\', \\'5:13\\', \\'5:14\\', \\'5:19\\', \\'5:21\\', \\'5:22\\', \\'5:25\\', \\'5:26\\', \\'5:28\\', \\'5:35\\', \\'5:37\\', \\'5:38\\', \\'5:41\\', \\'5:42\\', \\'5:44\\', \\'5:49\\', \\'5:50\\', \\'5:52\\', \\'5:56\\', \\'6:07\\', \\'6:11\\', \\'6:13\\', \\'6:14\\', \\'6:19\\', \\'6:21\\', \\'6:22\\', \\'6:25\\', \\'6:26\\', \\'6:28\\', \\'6:35\\', \\'6:37\\', \\'6:38\\', \\'6:41\\', \\'6:42\\', \\'6:44\\', \\'6:49\\', \\'6:50\\', \\'6:52\\', \\'6:56\\', \\'7:03\\', \\'7:05\\', \\'7:06\\', \\'7:09\\', \\'7:10\\', \\'7:12\\', \\'7:17\\', \\'7:18\\', \\'7:20\\', \\'7:24\\', \\'7:33\\', \\'7:34\\', \\'7:36\\', \\'7:40\\', \\'7:48\\', \\'8:15\\', \\'8:23\\', \\'8:27\\', \\'8:29\\', \\'8:30\\', \\'8:39\\', \\'8:43\\', \\'8:45\\', \\'8:46\\', \\'8:51\\', \\'8:53\\', \\'8:54\\', \\'8:57\\', \\'8:58\\', \\'9:07\\', \\'9:11\\', \\'9:13\\', \\'9:14\\', \\'9:19\\', \\'9:21\\', \\'9:22\\', \\'9:25\\', \\'9:26\\', \\'9:28\\', \\'9:35\\', \\'9:37\\', \\'9:38\\', \\'9:41\\', \\'9:42\\', \\'9:44\\', \\'9:49\\', \\'9:50\\', \\'9:52\\', \\'9:56\\', \\'10:07\\', \\'10:11\\', \\'10:13\\', \\'10:14\\', \\'10:19\\', \\'10:21\\', \\'10:22\\', \\'10:25\\', \\'10:26\\', \\'10:28\\', \\'10:35\\', \\'10:37\\', \\'10:38\\', \\'10:41\\', \\'10:42\\', \\'10:44\\', \\'10:49\\', \\'10:50\\', \\'10:52\\', \\'10:56\\', \\'11:03\\', \\'11:05\\', \\'11:06\\', \\'11:09\\', \\'11:10\\', \\'11:12\\', \\'11:17\\', \\'11:18\\', \\'11:20\\', \\'11:24\\', \\'11:33\\', \\'11:34\\', \\'11:36\\', \\'11:40\\', \\'11:48\\'],\\n                6: [\\'1:31\\', \\'1:47\\', \\'1:55\\', \\'1:59\\', \\'2:31\\', \\'2:47\\', \\'2:55\\', \\'2:59\\', \\'3:15\\', \\'3:23\\', \\'3:27\\', \\'3:29\\', \\'3:30\\', \\'3:39\\', \\'3:43\\', \\'3:45\\', \\'3:46\\', \\'3:51\\', \\'3:53\\', \\'3:54\\', \\'3:57\\', \\'3:58\\', \\'4:31\\', \\'4:47\\', \\'4:55\\', \\'4:59\\', \\'5:15\\', \\'5:23\\', \\'5:27\\', \\'5:29\\', \\'5:30\\', \\'5:39\\', \\'5:43\\', \\'5:45\\', \\'5:46\\', \\'5:51\\', \\'5:53\\', \\'5:54\\', \\'5:57\\', \\'5:58\\', \\'6:15\\', \\'6:23\\', \\'6:27\\', \\'6:29\\', \\'6:30\\', \\'6:39\\', \\'6:43\\', \\'6:45\\', \\'6:46\\', \\'6:51\\', \\'6:53\\', \\'6:54\\', \\'6:57\\', \\'6:58\\', \\'7:07\\', \\'7:11\\', \\'7:13\\', \\'7:14\\', \\'7:19\\', \\'7:21\\', \\'7:22\\', \\'7:25\\', \\'7:26\\', \\'7:28\\', \\'7:35\\', \\'7:37\\', \\'7:38\\', \\'7:41\\', \\'7:42\\', \\'7:44\\', \\'7:49\\', \\'7:50\\', \\'7:52\\', \\'7:56\\', \\'8:31\\', \\'8:47\\', \\'8:55\\', \\'8:59\\', \\'9:15\\', \\'9:23\\', \\'9:27\\', \\'9:29\\', \\'9:30\\', \\'9:39\\', \\'9:43\\', \\'9:45\\', \\'9:46\\', \\'9:51\\', \\'9:53\\', \\'9:54\\', \\'9:57\\', \\'9:58\\', \\'10:15\\', \\'10:23\\', \\'10:27\\', \\'10:29\\', \\'10:30\\', \\'10:39\\', \\'10:43\\', \\'10:45\\', \\'10:46\\', \\'10:51\\', \\'10:53\\', \\'10:54\\', \\'10:57\\', \\'10:58\\', \\'11:07\\', \\'11:11\\', \\'11:13\\', \\'11:14\\', \\'11:19\\', \\'11:21\\', \\'11:22\\', \\'11:25\\', \\'11:26\\', \\'11:28\\', \\'11:35\\', \\'11:37\\', \\'11:38\\', \\'11:41\\', \\'11:42\\', \\'11:44\\', \\'11:49\\', \\'11:50\\', \\'11:52\\', \\'11:56\\'],\\n                7: [\\'3:31\\', \\'3:47\\', \\'3:55\\', \\'3:59\\', \\'5:31\\', \\'5:47\\', \\'5:55\\', \\'5:59\\', \\'6:31\\', \\'6:47\\', \\'6:55\\', \\'6:59\\', \\'7:15\\', \\'7:23\\', \\'7:27\\', \\'7:29\\', \\'7:30\\', \\'7:39\\', \\'7:43\\', \\'7:45\\', \\'7:46\\', \\'7:51\\', \\'7:53\\', \\'7:54\\', \\'7:57\\', \\'7:58\\', \\'9:31\\', \\'9:47\\', \\'9:55\\', \\'9:59\\', \\'10:31\\', \\'10:47\\', \\'10:55\\', \\'10:59\\', \\'11:15\\', \\'11:23\\', \\'11:27\\', \\'11:29\\', \\'11:30\\', \\'11:39\\', \\'11:43\\', \\'11:45\\', \\'11:46\\', \\'11:51\\', \\'11:53\\', \\'11:54\\', \\'11:57\\', \\'11:58\\'],\\n                8: [\\'7:31\\', \\'7:47\\', \\'7:55\\', \\'7:59\\', \\'11:31\\', \\'11:47\\', \\'11:55\\', \\'11:59\\']}[num]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        if num > 8: return []\\n        return {0: [\\'0:00\\'],\\n                1: [\\'0:01\\', \\'0:02\\', \\'0:04\\', \\'0:08\\', \\'0:16\\', \\'0:32\\', \\'1:00\\', \\'2:00\\', \\'4:00\\', \\'8:00\\'],\\n                2: [\\'0:03\\', \\'0:05\\', \\'0:06\\', \\'0:09\\', \\'0:10\\', \\'0:12\\', \\'0:17\\', \\'0:18\\', \\'0:20\\', \\'0:24\\', \\'0:33\\', \\'0:34\\', \\'0:36\\', \\'0:40\\', \\'0:48\\', \\'1:01\\', \\'1:02\\', \\'1:04\\', \\'1:08\\', \\'1:16\\', \\'1:32\\', \\'2:01\\', \\'2:02\\', \\'2:04\\', \\'2:08\\', \\'2:16\\', \\'2:32\\', \\'3:00\\', \\'4:01\\', \\'4:02\\', \\'4:04\\', \\'4:08\\', \\'4:16\\', \\'4:32\\', \\'5:00\\', \\'6:00\\', \\'8:01\\', \\'8:02\\', \\'8:04\\', \\'8:08\\', \\'8:16\\', \\'8:32\\', \\'9:00\\', \\'10:00\\'],\\n                3: [\\'0:07\\', \\'0:11\\', \\'0:13\\', \\'0:14\\', \\'0:19\\', \\'0:21\\', \\'0:22\\', \\'0:25\\', \\'0:26\\', \\'0:28\\', \\'0:35\\', \\'0:37\\', \\'0:38\\', \\'0:41\\', \\'0:42\\', \\'0:44\\', \\'0:49\\', \\'0:50\\', \\'0:52\\', \\'0:56\\', \\'1:03\\', \\'1:05\\', \\'1:06\\', \\'1:09\\', \\'1:10\\', \\'1:12\\', \\'1:17\\', \\'1:18\\', \\'1:20\\', \\'1:24\\', \\'1:33\\', \\'1:34\\', \\'1:36\\', \\'1:40\\', \\'1:48\\', \\'2:03\\', \\'2:05\\', \\'2:06\\', \\'2:09\\', \\'2:10\\', \\'2:12\\', \\'2:17\\', \\'2:18\\', \\'2:20\\', \\'2:24\\', \\'2:33\\', \\'2:34\\', \\'2:36\\', \\'2:40\\', \\'2:48\\', \\'3:01\\', \\'3:02\\', \\'3:04\\', \\'3:08\\', \\'3:16\\', \\'3:32\\', \\'4:03\\', \\'4:05\\', \\'4:06\\', \\'4:09\\', \\'4:10\\', \\'4:12\\', \\'4:17\\', \\'4:18\\', \\'4:20\\', \\'4:24\\', \\'4:33\\', \\'4:34\\', \\'4:36\\', \\'4:40\\', \\'4:48\\', \\'5:01\\', \\'5:02\\', \\'5:04\\', \\'5:08\\', \\'5:16\\', \\'5:32\\', \\'6:01\\', \\'6:02\\', \\'6:04\\', \\'6:08\\', \\'6:16\\', \\'6:32\\', \\'7:00\\', \\'8:03\\', \\'8:05\\', \\'8:06\\', \\'8:09\\', \\'8:10\\', \\'8:12\\', \\'8:17\\', \\'8:18\\', \\'8:20\\', \\'8:24\\', \\'8:33\\', \\'8:34\\', \\'8:36\\', \\'8:40\\', \\'8:48\\', \\'9:01\\', \\'9:02\\', \\'9:04\\', \\'9:08\\', \\'9:16\\', \\'9:32\\', \\'10:01\\', \\'10:02\\', \\'10:04\\', \\'10:08\\', \\'10:16\\', \\'10:32\\', \\'11:00\\'],\\n                4: [\\'0:15\\', \\'0:23\\', \\'0:27\\', \\'0:29\\', \\'0:30\\', \\'0:39\\', \\'0:43\\', \\'0:45\\', \\'0:46\\', \\'0:51\\', \\'0:53\\', \\'0:54\\', \\'0:57\\', \\'0:58\\', \\'1:07\\', \\'1:11\\', \\'1:13\\', \\'1:14\\', \\'1:19\\', \\'1:21\\', \\'1:22\\', \\'1:25\\', \\'1:26\\', \\'1:28\\', \\'1:35\\', \\'1:37\\', \\'1:38\\', \\'1:41\\', \\'1:42\\', \\'1:44\\', \\'1:49\\', \\'1:50\\', \\'1:52\\', \\'1:56\\', \\'2:07\\', \\'2:11\\', \\'2:13\\', \\'2:14\\', \\'2:19\\', \\'2:21\\', \\'2:22\\', \\'2:25\\', \\'2:26\\', \\'2:28\\', \\'2:35\\', \\'2:37\\', \\'2:38\\', \\'2:41\\', \\'2:42\\', \\'2:44\\', \\'2:49\\', \\'2:50\\', \\'2:52\\', \\'2:56\\', \\'3:03\\', \\'3:05\\', \\'3:06\\', \\'3:09\\', \\'3:10\\', \\'3:12\\', \\'3:17\\', \\'3:18\\', \\'3:20\\', \\'3:24\\', \\'3:33\\', \\'3:34\\', \\'3:36\\', \\'3:40\\', \\'3:48\\', \\'4:07\\', \\'4:11\\', \\'4:13\\', \\'4:14\\', \\'4:19\\', \\'4:21\\', \\'4:22\\', \\'4:25\\', \\'4:26\\', \\'4:28\\', \\'4:35\\', \\'4:37\\', \\'4:38\\', \\'4:41\\', \\'4:42\\', \\'4:44\\', \\'4:49\\', \\'4:50\\', \\'4:52\\', \\'4:56\\', \\'5:03\\', \\'5:05\\', \\'5:06\\', \\'5:09\\', \\'5:10\\', \\'5:12\\', \\'5:17\\', \\'5:18\\', \\'5:20\\', \\'5:24\\', \\'5:33\\', \\'5:34\\', \\'5:36\\', \\'5:40\\', \\'5:48\\', \\'6:03\\', \\'6:05\\', \\'6:06\\', \\'6:09\\', \\'6:10\\', \\'6:12\\', \\'6:17\\', \\'6:18\\', \\'6:20\\', \\'6:24\\', \\'6:33\\', \\'6:34\\', \\'6:36\\', \\'6:40\\', \\'6:48\\', \\'7:01\\', \\'7:02\\', \\'7:04\\', \\'7:08\\', \\'7:16\\', \\'7:32\\', \\'8:07\\', \\'8:11\\', \\'8:13\\', \\'8:14\\', \\'8:19\\', \\'8:21\\', \\'8:22\\', \\'8:25\\', \\'8:26\\', \\'8:28\\', \\'8:35\\', \\'8:37\\', \\'8:38\\', \\'8:41\\', \\'8:42\\', \\'8:44\\', \\'8:49\\', \\'8:50\\', \\'8:52\\', \\'8:56\\', \\'9:03\\', \\'9:05\\', \\'9:06\\', \\'9:09\\', \\'9:10\\', \\'9:12\\', \\'9:17\\', \\'9:18\\', \\'9:20\\', \\'9:24\\', \\'9:33\\', \\'9:34\\', \\'9:36\\', \\'9:40\\', \\'9:48\\', \\'10:03\\', \\'10:05\\', \\'10:06\\', \\'10:09\\', \\'10:10\\', \\'10:12\\', \\'10:17\\', \\'10:18\\', \\'10:20\\', \\'10:24\\', \\'10:33\\', \\'10:34\\', \\'10:36\\', \\'10:40\\', \\'10:48\\', \\'11:01\\', \\'11:02\\', \\'11:04\\', \\'11:08\\', \\'11:16\\', \\'11:32\\'],\\n                5: [\\'0:31\\', \\'0:47\\', \\'0:55\\', \\'0:59\\', \\'1:15\\', \\'1:23\\', \\'1:27\\', \\'1:29\\', \\'1:30\\', \\'1:39\\', \\'1:43\\', \\'1:45\\', \\'1:46\\', \\'1:51\\', \\'1:53\\', \\'1:54\\', \\'1:57\\', \\'1:58\\', \\'2:15\\', \\'2:23\\', \\'2:27\\', \\'2:29\\', \\'2:30\\', \\'2:39\\', \\'2:43\\', \\'2:45\\', \\'2:46\\', \\'2:51\\', \\'2:53\\', \\'2:54\\', \\'2:57\\', \\'2:58\\', \\'3:07\\', \\'3:11\\', \\'3:13\\', \\'3:14\\', \\'3:19\\', \\'3:21\\', \\'3:22\\', \\'3:25\\', \\'3:26\\', \\'3:28\\', \\'3:35\\', \\'3:37\\', \\'3:38\\', \\'3:41\\', \\'3:42\\', \\'3:44\\', \\'3:49\\', \\'3:50\\', \\'3:52\\', \\'3:56\\', \\'4:15\\', \\'4:23\\', \\'4:27\\', \\'4:29\\', \\'4:30\\', \\'4:39\\', \\'4:43\\', \\'4:45\\', \\'4:46\\', \\'4:51\\', \\'4:53\\', \\'4:54\\', \\'4:57\\', \\'4:58\\', \\'5:07\\', \\'5:11\\', \\'5:13\\', \\'5:14\\', \\'5:19\\', \\'5:21\\', \\'5:22\\', \\'5:25\\', \\'5:26\\', \\'5:28\\', \\'5:35\\', \\'5:37\\', \\'5:38\\', \\'5:41\\', \\'5:42\\', \\'5:44\\', \\'5:49\\', \\'5:50\\', \\'5:52\\', \\'5:56\\', \\'6:07\\', \\'6:11\\', \\'6:13\\', \\'6:14\\', \\'6:19\\', \\'6:21\\', \\'6:22\\', \\'6:25\\', \\'6:26\\', \\'6:28\\', \\'6:35\\', \\'6:37\\', \\'6:38\\', \\'6:41\\', \\'6:42\\', \\'6:44\\', \\'6:49\\', \\'6:50\\', \\'6:52\\', \\'6:56\\', \\'7:03\\', \\'7:05\\', \\'7:06\\', \\'7:09\\', \\'7:10\\', \\'7:12\\', \\'7:17\\', \\'7:18\\', \\'7:20\\', \\'7:24\\', \\'7:33\\', \\'7:34\\', \\'7:36\\', \\'7:40\\', \\'7:48\\', \\'8:15\\', \\'8:23\\', \\'8:27\\', \\'8:29\\', \\'8:30\\', \\'8:39\\', \\'8:43\\', \\'8:45\\', \\'8:46\\', \\'8:51\\', \\'8:53\\', \\'8:54\\', \\'8:57\\', \\'8:58\\', \\'9:07\\', \\'9:11\\', \\'9:13\\', \\'9:14\\', \\'9:19\\', \\'9:21\\', \\'9:22\\', \\'9:25\\', \\'9:26\\', \\'9:28\\', \\'9:35\\', \\'9:37\\', \\'9:38\\', \\'9:41\\', \\'9:42\\', \\'9:44\\', \\'9:49\\', \\'9:50\\', \\'9:52\\', \\'9:56\\', \\'10:07\\', \\'10:11\\', \\'10:13\\', \\'10:14\\', \\'10:19\\', \\'10:21\\', \\'10:22\\', \\'10:25\\', \\'10:26\\', \\'10:28\\', \\'10:35\\', \\'10:37\\', \\'10:38\\', \\'10:41\\', \\'10:42\\', \\'10:44\\', \\'10:49\\', \\'10:50\\', \\'10:52\\', \\'10:56\\', \\'11:03\\', \\'11:05\\', \\'11:06\\', \\'11:09\\', \\'11:10\\', \\'11:12\\', \\'11:17\\', \\'11:18\\', \\'11:20\\', \\'11:24\\', \\'11:33\\', \\'11:34\\', \\'11:36\\', \\'11:40\\', \\'11:48\\'],\\n                6: [\\'1:31\\', \\'1:47\\', \\'1:55\\', \\'1:59\\', \\'2:31\\', \\'2:47\\', \\'2:55\\', \\'2:59\\', \\'3:15\\', \\'3:23\\', \\'3:27\\', \\'3:29\\', \\'3:30\\', \\'3:39\\', \\'3:43\\', \\'3:45\\', \\'3:46\\', \\'3:51\\', \\'3:53\\', \\'3:54\\', \\'3:57\\', \\'3:58\\', \\'4:31\\', \\'4:47\\', \\'4:55\\', \\'4:59\\', \\'5:15\\', \\'5:23\\', \\'5:27\\', \\'5:29\\', \\'5:30\\', \\'5:39\\', \\'5:43\\', \\'5:45\\', \\'5:46\\', \\'5:51\\', \\'5:53\\', \\'5:54\\', \\'5:57\\', \\'5:58\\', \\'6:15\\', \\'6:23\\', \\'6:27\\', \\'6:29\\', \\'6:30\\', \\'6:39\\', \\'6:43\\', \\'6:45\\', \\'6:46\\', \\'6:51\\', \\'6:53\\', \\'6:54\\', \\'6:57\\', \\'6:58\\', \\'7:07\\', \\'7:11\\', \\'7:13\\', \\'7:14\\', \\'7:19\\', \\'7:21\\', \\'7:22\\', \\'7:25\\', \\'7:26\\', \\'7:28\\', \\'7:35\\', \\'7:37\\', \\'7:38\\', \\'7:41\\', \\'7:42\\', \\'7:44\\', \\'7:49\\', \\'7:50\\', \\'7:52\\', \\'7:56\\', \\'8:31\\', \\'8:47\\', \\'8:55\\', \\'8:59\\', \\'9:15\\', \\'9:23\\', \\'9:27\\', \\'9:29\\', \\'9:30\\', \\'9:39\\', \\'9:43\\', \\'9:45\\', \\'9:46\\', \\'9:51\\', \\'9:53\\', \\'9:54\\', \\'9:57\\', \\'9:58\\', \\'10:15\\', \\'10:23\\', \\'10:27\\', \\'10:29\\', \\'10:30\\', \\'10:39\\', \\'10:43\\', \\'10:45\\', \\'10:46\\', \\'10:51\\', \\'10:53\\', \\'10:54\\', \\'10:57\\', \\'10:58\\', \\'11:07\\', \\'11:11\\', \\'11:13\\', \\'11:14\\', \\'11:19\\', \\'11:21\\', \\'11:22\\', \\'11:25\\', \\'11:26\\', \\'11:28\\', \\'11:35\\', \\'11:37\\', \\'11:38\\', \\'11:41\\', \\'11:42\\', \\'11:44\\', \\'11:49\\', \\'11:50\\', \\'11:52\\', \\'11:56\\'],\\n                7: [\\'3:31\\', \\'3:47\\', \\'3:55\\', \\'3:59\\', \\'5:31\\', \\'5:47\\', \\'5:55\\', \\'5:59\\', \\'6:31\\', \\'6:47\\', \\'6:55\\', \\'6:59\\', \\'7:15\\', \\'7:23\\', \\'7:27\\', \\'7:29\\', \\'7:30\\', \\'7:39\\', \\'7:43\\', \\'7:45\\', \\'7:46\\', \\'7:51\\', \\'7:53\\', \\'7:54\\', \\'7:57\\', \\'7:58\\', \\'9:31\\', \\'9:47\\', \\'9:55\\', \\'9:59\\', \\'10:31\\', \\'10:47\\', \\'10:55\\', \\'10:59\\', \\'11:15\\', \\'11:23\\', \\'11:27\\', \\'11:29\\', \\'11:30\\', \\'11:39\\', \\'11:43\\', \\'11:45\\', \\'11:46\\', \\'11:51\\', \\'11:53\\', \\'11:54\\', \\'11:57\\', \\'11:58\\'],\\n                8: [\\'7:31\\', \\'7:47\\', \\'7:55\\', \\'7:59\\', \\'11:31\\', \\'11:47\\', \\'11:55\\', \\'11:59\\']}[num]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407377,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {string[]}\\n */\\n\\nvar readBinaryWatch = function(num) {\\n    const results = [];\\n    let hours = Array(4).fill(false);\\n    let minutes = Array(6).fill(false);\\n    findTimes(hours, minutes, num, results);\\n    return results;\\n};\\n\\nfunction findTimes(hours, minutes, remaining, results) {\\n    if (remaining == 0) {\\n        const time = getFormattedTime(hours, minutes);\\n        if (results.indexOf(time) == -1) {\\n            results.push(time);\\n        }\\n        return;\\n    }\\n    \\n    for(let i = 0; i < hours.length; i++) {\\n        if (!hours[i]) {\\n            hours[i] = true;\\n            if(getTime(hours) < 12) {\\n                findTimes(hours, minutes, remaining - 1, results);\\n            }\\n            hours[i] = false;\\n        }\\n    }\\n    \\n    for(let i = 0; i < minutes.length; i++) {\\n        if (!minutes[i]) { \\n            minutes[i] = true;\\n            if(getTime(minutes) < 60) {                \\n                findTimes(hours, minutes, remaining - 1, results);                \\n            }\\n            minutes[i] = false;\\n        } \\n    }\\n}\\n\\nfunction getFormattedTime(hours, minutes) {\\n    const h = getTime(hours);\\n    let m = getTime(minutes);\\n    m = m > 9 ? m : \\'0\\' + m;\\n    return h + \\':\\' + m;\\n}\\n\\nfunction getTime(time) {\\n    let sum = 0;\\n    for(let i = 0; i < time.length; i++) {\\n        if (time[i]) {\\n            sum += Math.pow(2, i);\\n        }\\n    }\\n    \\n    return sum;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string[]}\\n */\\n\\nvar readBinaryWatch = function(num) {\\n    const results = [];\\n    let hours = Array(4).fill(false);\\n    let minutes = Array(6).fill(false);\\n    findTimes(hours, minutes, num, results);\\n    return results;\\n};\\n\\nfunction findTimes(hours, minutes, remaining, results) {\\n    if (remaining == 0) {\\n        const time = getFormattedTime(hours, minutes);\\n        if (results.indexOf(time) == -1) {\\n            results.push(time);\\n        }\\n        return;\\n    }\\n    \\n    for(let i = 0; i < hours.length; i++) {\\n        if (!hours[i]) {\\n            hours[i] = true;\\n            if(getTime(hours) < 12) {\\n                findTimes(hours, minutes, remaining - 1, results);\\n            }\\n            hours[i] = false;\\n        }\\n    }\\n    \\n    for(let i = 0; i < minutes.length; i++) {\\n        if (!minutes[i]) { \\n            minutes[i] = true;\\n            if(getTime(minutes) < 60) {                \\n                findTimes(hours, minutes, remaining - 1, results);                \\n            }\\n            minutes[i] = false;\\n        } \\n    }\\n}\\n\\nfunction getFormattedTime(hours, minutes) {\\n    const h = getTime(hours);\\n    let m = getTime(minutes);\\n    m = m > 9 ? m : \\'0\\' + m;\\n    return h + \\':\\' + m;\\n}\\n\\nfunction getTime(time) {\\n    let sum = 0;\\n    for(let i = 0; i < time.length; i++) {\\n        if (time[i]) {\\n            sum += Math.pow(2, i);\\n        }\\n    }\\n    \\n    return sum;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 313268,
                "title": "my-java-solution-to-401-using-integer-bitcount",
                "content": "The key to this solution is using Integer.bitCount() within two loops (one for the hour and the other for the minutes). The key is that the sum of the 1 bits must be equal to num. Therefore, we can go about this as follows:\\n\\n```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> times = new ArrayList<String>();\\n        for(int x = 0; x < 12; x++){\\n            for(int y = 0; y < 60; y++){\\n\\t\\t\\t\\t// x - hours, y - minutes\\n\\t\\t\\t\\tif(Integer.bitCount(x) + Integer.bitCount(y) == num){\\n\\t\\t\\t\\t\\t// - they must be equal to the number of LEDS given as an argument, so if this passes,\\n\\t\\t\\t\\t\\t//     proceed with making the string for this hour:minute combination.\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(Integer.toString(x));\\n                    sb.append(\":\");\\n                    sb.append( ((y < 10) ? \"0\" : \"\") + Integer.toString(y));\\n                    times.add(sb.toString());\\n                }                \\n            }\\n        }\\n        return times;\\n    }\\n}\\n```\\n\\nThis solution beats 92% of other solutions, with memory efficiency of 99% higher than others.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> times = new ArrayList<String>();\\n        for(int x = 0; x < 12; x++){\\n            for(int y = 0; y < 60; y++){\\n\\t\\t\\t\\t// x - hours, y - minutes\\n\\t\\t\\t\\tif(Integer.bitCount(x) + Integer.bitCount(y) == num){\\n\\t\\t\\t\\t\\t// - they must be equal to the number of LEDS given as an argument, so if this passes,\\n\\t\\t\\t\\t\\t//     proceed with making the string for this hour:minute combination.\\n                    StringBuilder sb = new StringBuilder();\\n                    sb.append(Integer.toString(x));\\n                    sb.append(\":\");\\n                    sb.append( ((y < 10) ? \"0\" : \"\") + Integer.toString(y));\\n                    times.add(sb.toString());\\n                }                \\n            }\\n        }\\n        return times;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263043,
                "title": "golang-backtrace-solution",
                "content": "```\\nfunc readBinaryWatch(num int) []string {\\n\\tvar res []string\\n\\tdoRead(&res, num, 0, 0, 1)\\n\\treturn res\\n}\\n\\nfunc doRead(res *[]string, num int, hour , minute int, pos uint){\\n\\n\\tif num == 0{\\n\\t\\t*res = append(*res, strconv.Itoa(hour) + \":\" + fmt.Sprintf(\"%02d\", minute))\\n\\t\\treturn\\n\\t}\\n\\n\\n\\tfor i:=pos;i<=10;i++{\\n\\t\\tif i >=5 {\\n\\t\\t\\tif minute + 1<<(i-5) >=60{\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\tdoRead(res, num-1, hour, minute+ 1<<(i-5), i + 1)\\n\\t\\t}else {\\n\\t\\t\\tif hour + 1<<(i-1) >= 12{\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tdoRead(res, num-1, hour + 1<<(i-1), minute, i + 1)\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc readBinaryWatch(num int) []string {\\n\\tvar res []string\\n\\tdoRead(&res, num, 0, 0, 1)\\n\\treturn res\\n}\\n\\nfunc doRead(res *[]string, num int, hour , minute int, pos uint){\\n\\n\\tif num == 0{\\n\\t\\t*res = append(*res, strconv.Itoa(hour) + \":\" + fmt.Sprintf(\"%02d\", minute))\\n\\t\\treturn\\n\\t}\\n\\n\\n\\tfor i:=pos;i<=10;i++{\\n\\t\\tif i >=5 {\\n\\t\\t\\tif minute + 1<<(i-5) >=60{\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t\\tdoRead(res, num-1, hour, minute+ 1<<(i-5), i + 1)\\n\\t\\t}else {\\n\\t\\t\\tif hour + 1<<(i-1) >= 12{\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tdoRead(res, num-1, hour + 1<<(i-1), minute, i + 1)\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215205,
                "title": "java-backtracking-solution",
                "content": "```\\n    List<String> res;\\n    \\n    public List<String> readBinaryWatch(int num) {\\n        res = new ArrayList<>();\\n        \\n        rec(0, num, 0, 0);\\n        \\n        return res;\\n    }\\n    \\n    public void rec(int index, int num, int hour, int min) {\\n        \\n        if (hour > 11 || min > 59) return;\\n        \\n        if (num == 0) {        \\n            res.add(getTime(hour, min));\\n            return;\\n        }\\n        \\n        for (int i=index; i<10; i++) {\\n            if (i < 4) {\\n                rec(i+1, num-1, hour + (int) Math.pow(2, i), min);\\n            } else {\\n                rec(i+1, num-1, hour, min + (int) Math.pow(2, i-4));\\n            }\\n        }\\n    }\\n    \\n    public String getTime(int hour, int min) {\\n        \\n        StringBuilder str = new StringBuilder();\\n        \\n        str.append(hour).append(\":\").append(min<10?\"0\":\"\").append(min);\\n            \\n        return str.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    List<String> res;\\n    \\n    public List<String> readBinaryWatch(int num) {\\n        res = new ArrayList<>();\\n        \\n        rec(0, num, 0, 0);\\n        \\n        return res;\\n    }\\n    \\n    public void rec(int index, int num, int hour, int min) {\\n        \\n        if (hour > 11 || min > 59) return;\\n        \\n        if (num == 0) {        \\n            res.add(getTime(hour, min));\\n            return;\\n        }\\n        \\n        for (int i=index; i<10; i++) {\\n            if (i < 4) {\\n                rec(i+1, num-1, hour + (int) Math.pow(2, i), min);\\n            } else {\\n                rec(i+1, num-1, hour, min + (int) Math.pow(2, i-4));\\n            }\\n        }\\n    }\\n    \\n    public String getTime(int hour, int min) {\\n        \\n        StringBuilder str = new StringBuilder();\\n        \\n        str.append(hour).append(\":\").append(min<10?\"0\":\"\").append(min);\\n            \\n        return str.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 177768,
                "title": "java-backtracking-solution",
                "content": "```\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> sol =new ArrayList<>();\\n        int[] vals = new int[]{1,2,4,8,16,32,1,2,4,8};\\n        boolean[] used = new boolean[vals.length];\\n        backtracking(num,0,0, used,vals,sol );\\n        return sol;\\n    }\\n\\n    public void backtracking(int max, int curr, int spot, boolean[] used, int[] vals, List<String> sol){\\n        if(curr >= max){\\n\\n            int hour = 0;\\n            int minutes = 0;\\n            for(int i = 0; i < vals.length;i++){\\n                if(i > 5 && used[i])\\n                    hour += vals[i];\\n                else if(used[i])\\n                    minutes += vals[i];           \\n            }\\n            if(hour >= 12 || minutes >= 60)\\n                return;\\n            String h = \"\" + hour;\\n            String m = \"\";\\n\\n            if(minutes < 10)\\n                m = \"0\" + minutes;\\n            else\\n                m = m + minutes;\\n\\n            String ans = h + \":\" + m;\\n            sol.add(ans);\\n            return;\\n        }\\n\\n        for(int i = spot; i < vals.length; i++){\\n            if(!used[i]){\\n                used[i] = true;\\n                backtracking(max,curr+1,i+1,used,vals,sol);\\n                used[i] = false;\\n\\n            }\\n\\n\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> sol =new ArrayList<>();\\n        int[] vals = new int[]{1,2,4,8,16,32,1,2,4,8};\\n        boolean[] used = new boolean[vals.length];\\n        backtracking(num,0,0, used,vals,sol );\\n        return sol;\\n    }\\n\\n    public void backtracking(int max, int curr, int spot, boolean[] used, int[] vals, List<String> sol){\\n        if(curr >= max){\\n\\n            int hour = 0;\\n            int minutes = 0;\\n            for(int i = 0; i < vals.length;i++){\\n                if(i > 5 && used[i])\\n                    hour += vals[i];\\n                else if(used[i])\\n                    minutes += vals[i];           \\n            }\\n            if(hour >= 12 || minutes >= 60)\\n                return;\\n            String h = \"\" + hour;\\n            String m = \"\";\\n\\n            if(minutes < 10)\\n                m = \"0\" + minutes;\\n            else\\n                m = m + minutes;\\n\\n            String ans = h + \":\" + m;\\n            sol.add(ans);\\n            return;\\n        }\\n\\n        for(int i = spot; i < vals.length; i++){\\n            if(!used[i]){\\n                used[i] = true;\\n                backtracking(max,curr+1,i+1,used,vals,sol);\\n                used[i] = false;\\n\\n            }\\n\\n\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 122298,
                "title": "my-ac-java-solution-7ms-using-backtracking",
                "content": "```\\nclass Solution {\\n\\tpublic List<String> readBinaryWatch(int num) {\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tString emptyTimeStr = \"0000000000\";\\n\\n\\t\\tthis.backTrack(result, emptyTimeStr.toCharArray(), num, 0);\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void backTrack(List<String> list, char[] chars, int k, int start) {\\n\\t\\tif (k == 0) {\\n\\t\\t\\tString timeSeq = String.valueOf(chars);\\n\\t\\t\\tString hour = Integer.valueOf(timeSeq.substring(0, 4), 2).toString();\\n\\n\\t\\t\\tInteger minTmp = Integer.valueOf(timeSeq.substring(4), 2);\\n\\t\\t\\tString min = minTmp < 10 ? \"0\" + minTmp.toString() : minTmp.toString();\\n\\n\\t\\t\\tlist.add(hour + \":\" + min);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = start; i < chars.length; i++) {\\n\\t\\t\\tchars[i] = \\'1\\';\\n\\n\\t\\t\\tString checkTime = String.valueOf(chars);\\n\\t\\t\\tInteger checkHour = Integer.valueOf(checkTime.substring(0, 4), 2);\\n\\t\\t\\tInteger checkMin = Integer.valueOf(checkTime.substring(4), 2);\\n\\t\\t\\tif (checkHour <= 11 && checkMin <= 59) {\\n\\t\\t\\t\\tthis.backTrack(list, chars, k - 1, i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tchars[i] = \\'0\\';\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic List<String> readBinaryWatch(int num) {\\n\\t\\tList<String> result = new ArrayList<String>();\\n\\t\\tString emptyTimeStr = \"0000000000\";\\n\\n\\t\\tthis.backTrack(result, emptyTimeStr.toCharArray(), num, 0);\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void backTrack(List<String> list, char[] chars, int k, int start) {\\n\\t\\tif (k == 0) {\\n\\t\\t\\tString timeSeq = String.valueOf(chars);\\n\\t\\t\\tString hour = Integer.valueOf(timeSeq.substring(0, 4), 2).toString();\\n\\n\\t\\t\\tInteger minTmp = Integer.valueOf(timeSeq.substring(4), 2);\\n\\t\\t\\tString min = minTmp < 10 ? \"0\" + minTmp.toString() : minTmp.toString();\\n\\n\\t\\t\\tlist.add(hour + \":\" + min);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = start; i < chars.length; i++) {\\n\\t\\t\\tchars[i] = \\'1\\';\\n\\n\\t\\t\\tString checkTime = String.valueOf(chars);\\n\\t\\t\\tInteger checkHour = Integer.valueOf(checkTime.substring(0, 4), 2);\\n\\t\\t\\tInteger checkMin = Integer.valueOf(checkTime.substring(4), 2);\\n\\t\\t\\tif (checkHour <= 11 && checkMin <= 59) {\\n\\t\\t\\t\\tthis.backTrack(list, chars, k - 1, i + 1);\\n\\t\\t\\t}\\n\\t\\t\\tchars[i] = \\'0\\';\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88491,
                "title": "use-c-template-metaprogramming-to-prepare-the-solutions-at-compile-time",
                "content": "Just for fun... actually the code would not get accepted as LeetCode puts some compile-time restrictions, e.g. \"template instantiation depth exceeds maximum of 128\". It should work on a local machine (with flag \"-std=c++11\" or above, and \"-ftemplate-depth=1000\" if compiled with clang).\\n\\n```\\n#include <cstddef>\\n#include <string>\\n#include <tuple>\\n#include <type_traits>\\n#include <utility>\\n#include <vector>\\n\\ntemplate <std::size_t value>\\nusing Value = std::integral_constant<std::size_t, value>;\\n\\n// Compile-time integer sequence.\\ntemplate <std::size_t ...s>\\nstruct Sequence {\\n  template <template <typename ...> class Host>\\n  using bind_to = Host<Value<s>...>;\\n};\\n\\n// Generate a compile-time integer sequence.\\ntemplate <std::size_t n, std::size_t ...s>\\nstruct MakeSequence : MakeSequence<n-1, n-1, s...> {};\\n\\ntemplate <std::size_t ...s>\\nstruct MakeSequence<0, s...> {\\n  using type = Sequence<s...>;\\n};\\n\\n// Forward declaration of TypeList.\\ntemplate <typename ...Ts> class TypeList;\\nusing EmptyList = TypeList<>;\\n\\n// Meta functions for TypeList.\\n// -----------------------------------------------------------------------------\\ntemplate <typename TL, typename PosTL, typename Enable = void>\\nstruct ElementAtImpl;\\n\\ntemplate <typename TL, typename PosTL>\\nstruct ElementAtImpl<TL, PosTL, typename std::enable_if<PosTL::length == 0>::type> {\\n  using type = TL;\\n};\\n\\ntemplate <typename TL, typename PosTL>\\nstruct ElementAtImpl<TL, PosTL, typename std::enable_if<PosTL::length != 0>::type>\\n    : ElementAtImpl<typename std::tuple_element<\\n                        PosTL::head::value,\\n                        typename TL::template bind_to<std::tuple>>::type,\\n                    typename PosTL::tail> {};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op,\\n          typename Enable = void>\\nstruct FilterImpl;\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FilterImpl<Out, Rest, Op, typename std::enable_if<Rest::length == 0>::type> {\\n  using type = Out;\\n};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FilterImpl<Out, Rest, Op,\\n                  typename std::enable_if<Op<typename Rest::head>::value>::type>\\n    : FilterImpl<typename Out::template push_back<typename Rest::head>,\\n                 typename Rest::tail, Op> {};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FilterImpl<Out, Rest, Op,\\n                  typename std::enable_if<!Op<typename Rest::head>::value>::type>\\n    : FilterImpl<Out, typename Rest::tail, Op> {};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op,\\n          typename Enable = void>\\nstruct FlatmapImpl;\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FlatmapImpl<Out, Rest, Op, typename std::enable_if<Rest::length == 0>::type> {\\n  using type = Out;\\n};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FlatmapImpl<Out, Rest, Op, typename std::enable_if<Rest::length != 0>::type>\\n    : FlatmapImpl<typename Out::template append<typename Op<typename Rest::head>::type>,\\n                  typename Rest::tail, Op> {};\\n\\ntemplate <typename LeftTL, typename RightTL>\\nstruct CartesianProductImpl {\\n  template <typename LeftT>\\n  struct LeftHelper {\\n    template <typename RightT>\\n    struct RightHelper {\\n      using type = TypeList<LeftT, RightT>;\\n    };\\n    using type = typename RightTL::template map<RightHelper>;\\n  };\\n  using type = typename LeftTL::template flatmap<LeftHelper>;\\n};\\n// -----------------------------------------------------------------------------\\n// End of meta functions.\\n\\n// A minimal TypeList to support all the compile-time operations.\\ntemplate <typename ...Ts>\\nclass TypeListBase {\\n private:\\n  template <typename ...Tail> struct AppendHelper {\\n    using type = TypeList<Ts..., Tail...>;\\n  };\\n\\n public:\\n  static constexpr std::size_t length = sizeof...(Ts);\\n\\n  using type = TypeList<Ts...>;\\n  using self = type;\\n\\n  template <template <typename ...> class Host>\\n  using bind_to = Host<Ts...>;\\n\\n  template <std::size_t ...pos>\\n  using at = typename ElementAtImpl<self, TypeList<Value<pos>...>>::type;\\n\\n  template <typename T>\\n  using push_front = TypeList<T, Ts...>;\\n\\n  template <typename T>\\n  using push_back = TypeList<Ts..., T>;\\n\\n  template <typename TL>\\n  using append = typename TL::template bind_to<AppendHelper>::type;\\n\\n  template <typename TL>\\n  using cartesian_product = typename CartesianProductImpl<self, TL>::type;\\n\\n  template <template <typename ...> class Op>\\n  using map = TypeList<typename Op<Ts>::type...>;\\n\\n  template <template <typename ...> class Op>\\n  using flatmap = typename FlatmapImpl<EmptyList, self, Op>::type;\\n\\n  template <template <typename ...> class Op>\\n  using filter = typename FilterImpl<EmptyList, self, Op>::type;\\n\\n public:\\n  template <typename Container, template <typename ...> class Op>\\n  static inline Container Instantiate() {\\n    return { Op<Ts>()()... };\\n  }\\n};\\n\\ntemplate <typename T, typename ...Ts>\\nclass TypeList<T, Ts...> : public TypeListBase<T, Ts...> {\\n public:\\n  using head = T;\\n  using tail = TypeList<Ts...>;\\n};\\n\\ntemplate <>\\nclass TypeList<> : public TypeListBase<> {};\\n\\n// List of hours and minutes.\\nusing Hours = MakeSequence<12>::type::bind_to<TypeList>;\\nusing Minutes = MakeSequence<60>::type::bind_to<TypeList>;\\n\\n// Count the number of 1-bits in an integer at compile-time.\\ntemplate <typename V>\\nstruct BitCounter {\\n  static constexpr std::size_t Count(const std::size_t n) {\\n    return n ? 1 + Count(n & (n-1)) : 0;\\n  }\\n  using type = TypeList<V, Value<Count(V::value)>>;\\n};\\n\\n// Combine one hour slot with one minute slot, calculate the # of LEDs that are on.\\ntemplate <typename HMPair>\\nstruct HourMinuteCombiner {\\n  using H = typename HMPair::template at<0>;\\n  using M = typename HMPair::template at<1>;\\n  using type = TypeList<\\n      Value<H::template at<1>::value + M::template at<1>::value>,\\n      typename H::head, typename M::head>;\\n};\\n\\n// Get all combinations of hour slot + minute slot.\\nusing HourMinuteCombinations =\\n    Hours::map<BitCounter>::cartesian_product<Minutes::map<BitCounter>>\\n                          ::map<HourMinuteCombiner>;\\n\\n// Select all the combinations where Count of LEDs are on.\\ntemplate <typename Count>\\nstruct HourMinuteSelector {\\n  template <typename E>\\n  struct Filter {\\n    static constexpr std::size_t value = (E::head::value == Count::value);\\n  };\\n  using type = HourMinuteCombinations::filter<Filter>;\\n};\\n\\n// Convert compile-time hour:minute results into string representation.\\n// These conversions are done at runtime, though.\\ntemplate <typename HMTuple>\\nstruct HourMinuteToString {\\n  static inline std::string ToMinuteString(const int value) {\\n    return value < 10 ? \"0\" + std::to_string(value) : std::to_string(value);\\n  }\\n  inline std::string operator()() const {\\n    return std::to_string(HMTuple::template at<1>::value) + ':' +\\n           ToMinuteString(HMTuple::template at<2>::value);\\n  }\\n};\\n\\ntemplate <typename HMList>\\nstruct HourMinuteListToStringVector {\\n  inline std::vector<std::string> operator()() const {\\n    return HMList::template Instantiate<std::vector<std::string>,\\n                                        HourMinuteToString>();\\n  }\\n};\\n\\n// The solution class.\\nclass Solution {\\n public:\\n  std::vector<std::string> readBinaryWatch(int num) {\\n    return num >= kTable.size() ? std::vector<std::string>() : kTable[num];\\n  }\\n\\n private:\\n  static const std::vector<std::vector<std::string>> kTable;\\n};\\n\\n// Instantiate the table.\\nconst std::vector<std::vector<std::string>> Solution::kTable =\\n    MakeSequence<9>::type\\n        ::bind_to<TypeList>\\n        ::map<HourMinuteSelector>\\n        ::Instantiate<std::vector<std::vector<std::string>>,\\n                      HourMinuteListToStringVector>();\\n```",
                "solutionTags": [],
                "code": "```\\n#include <cstddef>\\n#include <string>\\n#include <tuple>\\n#include <type_traits>\\n#include <utility>\\n#include <vector>\\n\\ntemplate <std::size_t value>\\nusing Value = std::integral_constant<std::size_t, value>;\\n\\n// Compile-time integer sequence.\\ntemplate <std::size_t ...s>\\nstruct Sequence {\\n  template <template <typename ...> class Host>\\n  using bind_to = Host<Value<s>...>;\\n};\\n\\n// Generate a compile-time integer sequence.\\ntemplate <std::size_t n, std::size_t ...s>\\nstruct MakeSequence : MakeSequence<n-1, n-1, s...> {};\\n\\ntemplate <std::size_t ...s>\\nstruct MakeSequence<0, s...> {\\n  using type = Sequence<s...>;\\n};\\n\\n// Forward declaration of TypeList.\\ntemplate <typename ...Ts> class TypeList;\\nusing EmptyList = TypeList<>;\\n\\n// Meta functions for TypeList.\\n// -----------------------------------------------------------------------------\\ntemplate <typename TL, typename PosTL, typename Enable = void>\\nstruct ElementAtImpl;\\n\\ntemplate <typename TL, typename PosTL>\\nstruct ElementAtImpl<TL, PosTL, typename std::enable_if<PosTL::length == 0>::type> {\\n  using type = TL;\\n};\\n\\ntemplate <typename TL, typename PosTL>\\nstruct ElementAtImpl<TL, PosTL, typename std::enable_if<PosTL::length != 0>::type>\\n    : ElementAtImpl<typename std::tuple_element<\\n                        PosTL::head::value,\\n                        typename TL::template bind_to<std::tuple>>::type,\\n                    typename PosTL::tail> {};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op,\\n          typename Enable = void>\\nstruct FilterImpl;\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FilterImpl<Out, Rest, Op, typename std::enable_if<Rest::length == 0>::type> {\\n  using type = Out;\\n};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FilterImpl<Out, Rest, Op,\\n                  typename std::enable_if<Op<typename Rest::head>::value>::type>\\n    : FilterImpl<typename Out::template push_back<typename Rest::head>,\\n                 typename Rest::tail, Op> {};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FilterImpl<Out, Rest, Op,\\n                  typename std::enable_if<!Op<typename Rest::head>::value>::type>\\n    : FilterImpl<Out, typename Rest::tail, Op> {};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op,\\n          typename Enable = void>\\nstruct FlatmapImpl;\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FlatmapImpl<Out, Rest, Op, typename std::enable_if<Rest::length == 0>::type> {\\n  using type = Out;\\n};\\n\\ntemplate <typename Out, typename Rest, template <typename ...> class Op>\\nstruct FlatmapImpl<Out, Rest, Op, typename std::enable_if<Rest::length != 0>::type>\\n    : FlatmapImpl<typename Out::template append<typename Op<typename Rest::head>::type>,\\n                  typename Rest::tail, Op> {};\\n\\ntemplate <typename LeftTL, typename RightTL>\\nstruct CartesianProductImpl {\\n  template <typename LeftT>\\n  struct LeftHelper {\\n    template <typename RightT>\\n    struct RightHelper {\\n      using type = TypeList<LeftT, RightT>;\\n    };\\n    using type = typename RightTL::template map<RightHelper>;\\n  };\\n  using type = typename LeftTL::template flatmap<LeftHelper>;\\n};\\n// -----------------------------------------------------------------------------\\n// End of meta functions.\\n\\n// A minimal TypeList to support all the compile-time operations.\\ntemplate <typename ...Ts>\\nclass TypeListBase {\\n private:\\n  template <typename ...Tail> struct AppendHelper {\\n    using type = TypeList<Ts..., Tail...>;\\n  };\\n\\n public:\\n  static constexpr std::size_t length = sizeof...(Ts);\\n\\n  using type = TypeList<Ts...>;\\n  using self = type;\\n\\n  template <template <typename ...> class Host>\\n  using bind_to = Host<Ts...>;\\n\\n  template <std::size_t ...pos>\\n  using at = typename ElementAtImpl<self, TypeList<Value<pos>...>>::type;\\n\\n  template <typename T>\\n  using push_front = TypeList<T, Ts...>;\\n\\n  template <typename T>\\n  using push_back = TypeList<Ts..., T>;\\n\\n  template <typename TL>\\n  using append = typename TL::template bind_to<AppendHelper>::type;\\n\\n  template <typename TL>\\n  using cartesian_product = typename CartesianProductImpl<self, TL>::type;\\n\\n  template <template <typename ...> class Op>\\n  using map = TypeList<typename Op<Ts>::type...>;\\n\\n  template <template <typename ...> class Op>\\n  using flatmap = typename FlatmapImpl<EmptyList, self, Op>::type;\\n\\n  template <template <typename ...> class Op>\\n  using filter = typename FilterImpl<EmptyList, self, Op>::type;\\n\\n public:\\n  template <typename Container, template <typename ...> class Op>\\n  static inline Container Instantiate() {\\n    return { Op<Ts>()()... };\\n  }\\n};\\n\\ntemplate <typename T, typename ...Ts>\\nclass TypeList<T, Ts...> : public TypeListBase<T, Ts...> {\\n public:\\n  using head = T;\\n  using tail = TypeList<Ts...>;\\n};\\n\\ntemplate <>\\nclass TypeList<> : public TypeListBase<> {};\\n\\n// List of hours and minutes.\\nusing Hours = MakeSequence<12>::type::bind_to<TypeList>;\\nusing Minutes = MakeSequence<60>::type::bind_to<TypeList>;\\n\\n// Count the number of 1-bits in an integer at compile-time.\\ntemplate <typename V>\\nstruct BitCounter {\\n  static constexpr std::size_t Count(const std::size_t n) {\\n    return n ? 1 + Count(n & (n-1)) : 0;\\n  }\\n  using type = TypeList<V, Value<Count(V::value)>>;\\n};\\n\\n// Combine one hour slot with one minute slot, calculate the # of LEDs that are on.\\ntemplate <typename HMPair>\\nstruct HourMinuteCombiner {\\n  using H = typename HMPair::template at<0>;\\n  using M = typename HMPair::template at<1>;\\n  using type = TypeList<\\n      Value<H::template at<1>::value + M::template at<1>::value>,\\n      typename H::head, typename M::head>;\\n};\\n\\n// Get all combinations of hour slot + minute slot.\\nusing HourMinuteCombinations =\\n    Hours::map<BitCounter>::cartesian_product<Minutes::map<BitCounter>>\\n                          ::map<HourMinuteCombiner>;\\n\\n// Select all the combinations where Count of LEDs are on.\\ntemplate <typename Count>\\nstruct HourMinuteSelector {\\n  template <typename E>\\n  struct Filter {\\n    static constexpr std::size_t value = (E::head::value == Count::value);\\n  };\\n  using type = HourMinuteCombinations::filter<Filter>;\\n};\\n\\n// Convert compile-time hour:minute results into string representation.\\n// These conversions are done at runtime, though.\\ntemplate <typename HMTuple>\\nstruct HourMinuteToString {\\n  static inline std::string ToMinuteString(const int value) {\\n    return value < 10 ? \"0\" + std::to_string(value) : std::to_string(value);\\n  }\\n  inline std::string operator()() const {\\n    return std::to_string(HMTuple::template at<1>::value) + ':' +\\n           ToMinuteString(HMTuple::template at<2>::value);\\n  }\\n};\\n\\ntemplate <typename HMList>\\nstruct HourMinuteListToStringVector {\\n  inline std::vector<std::string> operator()() const {\\n    return HMList::template Instantiate<std::vector<std::string>,\\n                                        HourMinuteToString>();\\n  }\\n};\\n\\n// The solution class.\\nclass Solution {\\n public:\\n  std::vector<std::string> readBinaryWatch(int num) {\\n    return num >= kTable.size() ? std::vector<std::string>() : kTable[num];\\n  }\\n\\n private:\\n  static const std::vector<std::vector<std::string>> kTable;\\n};\\n\\n// Instantiate the table.\\nconst std::vector<std::vector<std::string>> Solution::kTable =\\n    MakeSequence<9>::type\\n        ::bind_to<TypeList>\\n        ::map<HourMinuteSelector>\\n        ::Instantiate<std::vector<std::vector<std::string>>,\\n                      HourMinuteListToStringVector>();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 88525,
                "title": "3-elegant-java-solutions",
                "content": "Separated concerns, mimicking the problem description (`110ms`, would be faster with proper lazy `Stream` support):\\n```java\\npublic class Solution {\\n  static final int LEDS = 10;\\n  public List<String> readBinaryWatch(int num) {\\n    return permute(new ArrayList<>(), 0, LEDS, num).stream()\\n          .filter(this::isValid)\\n          .map(this::toString)\\n          .collect(Collectors.toList());\\n  }\\n\\n  List<Integer> permute(List<Integer> results, int clock, int index, int remaining) {\\n    if (remaining == 0) {\\n      results.add(clock);\\n    } else if (index >= 0) {\\n      permute(results, clock,                index - 1, remaining);\\n      permute(results, setBit(clock, index), index - 1, remaining - 1);\\n    }\\n    return results;\\n  }\\n\\n  int setBit(int clock, int index) { return clock | (1 << index); }\\n  boolean isValid(int clock)       { return (hours(clock) < 12) && (minutes(clock) < 60); }\\n  int hours(int clock)             { return clock >>> 6; }\\n  int minutes(int clock)           { return clock & (-1 >>> -6); }\\n  String toString(int clock)       { return String.format(\"%d:%02d\", hours(clock), minutes(clock)); }\\n}\\n```\\n---\\nor inlined concerns (`30ms`)\\n```java\\npublic class Solution {\\n  static final int LEDS = 10;\\n  public List<String> readBinaryWatch(int num) {\\n    return permute(new ArrayList<>(pow2(LEDS + 1)), 0, LEDS, num);\\n  }\\n  List<String> permute(List<String> results, int clock, int index, int remaining) {\\n    if (isValid(clock)) {\\n      if (remaining == 0) results.add(toString(clock));\\n      else if (index >= 0) {\\n        permute(results, clock,                index - 1, remaining);\\n        permute(results, setBit(clock, index), index - 1, remaining - 1);\\n      }\\n    }\\n    return results;\\n  }\\n  int pow2(int exponent)           { return 1 << exponent; }\\n  int setBit(int clock, int index) { return clock | pow2(index); }\\n  boolean isValid(int clock)       { return (hours(clock) < 12) && (minutes(clock) < 60); }\\n  int hours(int clock)             { return clock >>> 6; }\\n  int minutes(int clock)           { return clock & (-1 >>> -6); }\\n  String toString(int clock)       { return String.format(\"%d:%02d\", hours(clock), minutes(clock)); }\\n}\\n```\\n---\\nor optimized only for speed (`2ms`):\\n```java\\npublic class Solution {\\n  public List<String> readBinaryWatch(int num) {\\n    switch (num) {\\n      case 0: return Arrays.asList(\"0:00\");\\n      case 1: return Arrays.asList(\"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\", \"1:00\", \"2:00\", \"4:00\", \"8:00\");\\n      case 2: return Arrays.asList(\"0:03\", \"0:05\", \"0:06\", \"0:09\", \"0:10\", \"0:12\", \"0:17\", \"0:18\", \"0:20\", \"0:24\", \"0:33\", \"0:34\", \"0:36\", \"0:40\", \"0:48\", \"10:00\", \"1:01\", \"1:02\", \"1:04\", \"1:08\", \"1:16\", \"1:32\", \"2:01\", \"2:02\", \"2:04\", \"2:08\", \"2:16\", \"2:32\", \"3:00\", \"4:01\", \"4:02\", \"4:04\", \"4:08\", \"4:16\", \"4:32\", \"5:00\", \"6:00\", \"8:01\", \"8:02\", \"8:04\", \"8:08\", \"8:16\", \"8:32\", \"9:00\");\\n      case 3: return Arrays.asList(\"0:07\", \"0:11\", \"0:13\", \"0:14\", \"0:19\", \"0:21\", \"0:22\", \"0:25\", \"0:26\", \"0:28\", \"0:35\", \"0:37\", \"0:38\", \"0:41\", \"0:42\", \"0:44\", \"0:49\", \"0:50\", \"0:52\", \"0:56\", \"10:01\", \"10:02\", \"10:04\", \"10:08\", \"10:16\", \"10:32\", \"11:00\", \"1:03\", \"1:05\", \"1:06\", \"1:09\", \"1:10\", \"1:12\", \"1:17\", \"1:18\", \"1:20\", \"1:24\", \"1:33\", \"1:34\", \"1:36\", \"1:40\", \"1:48\", \"2:03\", \"2:05\", \"2:06\", \"2:09\", \"2:10\", \"2:12\", \"2:17\", \"2:18\", \"2:20\", \"2:24\", \"2:33\", \"2:34\", \"2:36\", \"2:40\", \"2:48\", \"3:01\", \"3:02\", \"3:04\", \"3:08\", \"3:16\", \"3:32\", \"4:03\", \"4:05\", \"4:06\", \"4:09\", \"4:10\", \"4:12\", \"4:17\", \"4:18\", \"4:20\", \"4:24\", \"4:33\", \"4:34\", \"4:36\", \"4:40\", \"4:48\", \"5:01\", \"5:02\", \"5:04\", \"5:08\", \"5:16\", \"5:32\", \"6:01\", \"6:02\", \"6:04\", \"6:08\", \"6:16\", \"6:32\", \"7:00\", \"8:03\", \"8:05\", \"8:06\", \"8:09\", \"8:10\", \"8:12\", \"8:17\", \"8:18\", \"8:20\", \"8:24\", \"8:33\", \"8:34\", \"8:36\", \"8:40\", \"8:48\", \"9:01\", \"9:02\", \"9:04\", \"9:08\", \"9:16\", \"9:32\");\\n      case 4: return Arrays.asList(\"0:15\", \"0:23\", \"0:27\", \"0:29\", \"0:30\", \"0:39\", \"0:43\", \"0:45\", \"0:46\", \"0:51\", \"0:53\", \"0:54\", \"0:57\", \"0:58\", \"10:03\", \"10:05\", \"10:06\", \"10:09\", \"10:10\", \"10:12\", \"10:17\", \"10:18\", \"10:20\", \"10:24\", \"10:33\", \"10:34\", \"10:36\", \"10:40\", \"10:48\", \"11:01\", \"11:02\", \"11:04\", \"11:08\", \"11:16\", \"11:32\", \"1:07\", \"1:11\", \"1:13\", \"1:14\", \"1:19\", \"1:21\", \"1:22\", \"1:25\", \"1:26\", \"1:28\", \"1:35\", \"1:37\", \"1:38\", \"1:41\", \"1:42\", \"1:44\", \"1:49\", \"1:50\", \"1:52\", \"1:56\", \"2:07\", \"2:11\", \"2:13\", \"2:14\", \"2:19\", \"2:21\", \"2:22\", \"2:25\", \"2:26\", \"2:28\", \"2:35\", \"2:37\", \"2:38\", \"2:41\", \"2:42\", \"2:44\", \"2:49\", \"2:50\", \"2:52\", \"2:56\", \"3:03\", \"3:05\", \"3:06\", \"3:09\", \"3:10\", \"3:12\", \"3:17\", \"3:18\", \"3:20\", \"3:24\", \"3:33\", \"3:34\", \"3:36\", \"3:40\", \"3:48\", \"4:07\", \"4:11\", \"4:13\", \"4:14\", \"4:19\", \"4:21\", \"4:22\", \"4:25\", \"4:26\", \"4:28\", \"4:35\", \"4:37\", \"4:38\", \"4:41\", \"4:42\", \"4:44\", \"4:49\", \"4:50\", \"4:52\", \"4:56\", \"5:03\", \"5:05\", \"5:06\", \"5:09\", \"5:10\", \"5:12\", \"5:17\", \"5:18\", \"5:20\", \"5:24\", \"5:33\", \"5:34\", \"5:36\", \"5:40\", \"5:48\", \"6:03\", \"6:05\", \"6:06\", \"6:09\", \"6:10\", \"6:12\", \"6:17\", \"6:18\", \"6:20\", \"6:24\", \"6:33\", \"6:34\", \"6:36\", \"6:40\", \"6:48\", \"7:01\", \"7:02\", \"7:04\", \"7:08\", \"7:16\", \"7:32\", \"8:07\", \"8:11\", \"8:13\", \"8:14\", \"8:19\", \"8:21\", \"8:22\", \"8:25\", \"8:26\", \"8:28\", \"8:35\", \"8:37\", \"8:38\", \"8:41\", \"8:42\", \"8:44\", \"8:49\", \"8:50\", \"8:52\", \"8:56\", \"9:03\", \"9:05\", \"9:06\", \"9:09\", \"9:10\", \"9:12\", \"9:17\", \"9:18\", \"9:20\", \"9:24\", \"9:33\", \"9:34\", \"9:36\", \"9:40\", \"9:48\");\\n      case 5: return Arrays.asList(\"0:31\", \"0:47\", \"0:55\", \"0:59\", \"10:07\", \"10:11\", \"10:13\", \"10:14\", \"10:19\", \"10:21\", \"10:22\", \"10:25\", \"10:26\", \"10:28\", \"10:35\", \"10:37\", \"10:38\", \"10:41\", \"10:42\", \"10:44\", \"10:49\", \"10:50\", \"10:52\", \"10:56\", \"11:03\", \"11:05\", \"11:06\", \"11:09\", \"11:10\", \"11:12\", \"11:17\", \"11:18\", \"11:20\", \"11:24\", \"11:33\", \"11:34\", \"11:36\", \"11:40\", \"11:48\", \"1:15\", \"1:23\", \"1:27\", \"1:29\", \"1:30\", \"1:39\", \"1:43\", \"1:45\", \"1:46\", \"1:51\", \"1:53\", \"1:54\", \"1:57\", \"1:58\", \"2:15\", \"2:23\", \"2:27\", \"2:29\", \"2:30\", \"2:39\", \"2:43\", \"2:45\", \"2:46\", \"2:51\", \"2:53\", \"2:54\", \"2:57\", \"2:58\", \"3:07\", \"3:11\", \"3:13\", \"3:14\", \"3:19\", \"3:21\", \"3:22\", \"3:25\", \"3:26\", \"3:28\", \"3:35\", \"3:37\", \"3:38\", \"3:41\", \"3:42\", \"3:44\", \"3:49\", \"3:50\", \"3:52\", \"3:56\", \"4:15\", \"4:23\", \"4:27\", \"4:29\", \"4:30\", \"4:39\", \"4:43\", \"4:45\", \"4:46\", \"4:51\", \"4:53\", \"4:54\", \"4:57\", \"4:58\", \"5:07\", \"5:11\", \"5:13\", \"5:14\", \"5:19\", \"5:21\", \"5:22\", \"5:25\", \"5:26\", \"5:28\", \"5:35\", \"5:37\", \"5:38\", \"5:41\", \"5:42\", \"5:44\", \"5:49\", \"5:50\", \"5:52\", \"5:56\", \"6:07\", \"6:11\", \"6:13\", \"6:14\", \"6:19\", \"6:21\", \"6:22\", \"6:25\", \"6:26\", \"6:28\", \"6:35\", \"6:37\", \"6:38\", \"6:41\", \"6:42\", \"6:44\", \"6:49\", \"6:50\", \"6:52\", \"6:56\", \"7:03\", \"7:05\", \"7:06\", \"7:09\", \"7:10\", \"7:12\", \"7:17\", \"7:18\", \"7:20\", \"7:24\", \"7:33\", \"7:34\", \"7:36\", \"7:40\", \"7:48\", \"8:15\", \"8:23\", \"8:27\", \"8:29\", \"8:30\", \"8:39\", \"8:43\", \"8:45\", \"8:46\", \"8:51\", \"8:53\", \"8:54\", \"8:57\", \"8:58\", \"9:07\", \"9:11\", \"9:13\", \"9:14\", \"9:19\", \"9:21\", \"9:22\", \"9:25\", \"9:26\", \"9:28\", \"9:35\", \"9:37\", \"9:38\", \"9:41\", \"9:42\", \"9:44\", \"9:49\", \"9:50\", \"9:52\", \"9:56\");\\n      case 6: return Arrays.asList(\"10:15\", \"10:23\", \"10:27\", \"10:29\", \"10:30\", \"10:39\", \"10:43\", \"10:45\", \"10:46\", \"10:51\", \"10:53\", \"10:54\", \"10:57\", \"10:58\", \"11:07\", \"11:11\", \"11:13\", \"11:14\", \"11:19\", \"11:21\", \"11:22\", \"11:25\", \"11:26\", \"11:28\", \"11:35\", \"11:37\", \"11:38\", \"11:41\", \"11:42\", \"11:44\", \"11:49\", \"11:50\", \"11:52\", \"11:56\", \"1:31\", \"1:47\", \"1:55\", \"1:59\", \"2:31\", \"2:47\", \"2:55\", \"2:59\", \"3:15\", \"3:23\", \"3:27\", \"3:29\", \"3:30\", \"3:39\", \"3:43\", \"3:45\", \"3:46\", \"3:51\", \"3:53\", \"3:54\", \"3:57\", \"3:58\", \"4:31\", \"4:47\", \"4:55\", \"4:59\", \"5:15\", \"5:23\", \"5:27\", \"5:29\", \"5:30\", \"5:39\", \"5:43\", \"5:45\", \"5:46\", \"5:51\", \"5:53\", \"5:54\", \"5:57\", \"5:58\", \"6:15\", \"6:23\", \"6:27\", \"6:29\", \"6:30\", \"6:39\", \"6:43\", \"6:45\", \"6:46\", \"6:51\", \"6:53\", \"6:54\", \"6:57\", \"6:58\", \"7:07\", \"7:11\", \"7:13\", \"7:14\", \"7:19\", \"7:21\", \"7:22\", \"7:25\", \"7:26\", \"7:28\", \"7:35\", \"7:37\", \"7:38\", \"7:41\", \"7:42\", \"7:44\", \"7:49\", \"7:50\", \"7:52\", \"7:56\", \"8:31\", \"8:47\", \"8:55\", \"8:59\", \"9:15\", \"9:23\", \"9:27\", \"9:29\", \"9:30\", \"9:39\", \"9:43\", \"9:45\", \"9:46\", \"9:51\", \"9:53\", \"9:54\", \"9:57\", \"9:58\");\\n      case 7: return Arrays.asList(\"10:31\", \"10:47\", \"10:55\", \"10:59\", \"11:15\", \"11:23\", \"11:27\", \"11:29\", \"11:30\", \"11:39\", \"11:43\", \"11:45\", \"11:46\", \"11:51\", \"11:53\", \"11:54\", \"11:57\", \"11:58\", \"3:31\", \"3:47\", \"3:55\", \"3:59\", \"5:31\", \"5:47\", \"5:55\", \"5:59\", \"6:31\", \"6:47\", \"6:55\", \"6:59\", \"7:15\", \"7:23\", \"7:27\", \"7:29\", \"7:30\", \"7:39\", \"7:43\", \"7:45\", \"7:46\", \"7:51\", \"7:53\", \"7:54\", \"7:57\", \"7:58\", \"9:31\", \"9:47\", \"9:55\", \"9:59\");\\n      case 8: return Arrays.asList(\"11:31\", \"11:47\", \"11:55\", \"11:59\", \"7:31\", \"7:47\", \"7:55\", \"7:59\");\\n      default: return Arrays.asList();\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n  static final int LEDS = 10;\\n  public List<String> readBinaryWatch(int num) {\\n    return permute(new ArrayList<>(), 0, LEDS, num).stream()\\n          .filter(this::isValid)\\n          .map(this::toString)\\n          .collect(Collectors.toList());\\n  }\\n\\n  List<Integer> permute(List<Integer> results, int clock, int index, int remaining) {\\n    if (remaining == 0) {\\n      results.add(clock);\\n    } else if (index >= 0) {\\n      permute(results, clock,                index - 1, remaining);\\n      permute(results, setBit(clock, index), index - 1, remaining - 1);\\n    }\\n    return results;\\n  }\\n\\n  int setBit(int clock, int index) { return clock | (1 << index); }\\n  boolean isValid(int clock)       { return (hours(clock) < 12) && (minutes(clock) < 60); }\\n  int hours(int clock)             { return clock >>> 6; }\\n  int minutes(int clock)           { return clock & (-1 >>> -6); }\\n  String toString(int clock)       { return String.format(\"%d:%02d\", hours(clock), minutes(clock)); }\\n}\\n```\n```java\\npublic class Solution {\\n  static final int LEDS = 10;\\n  public List<String> readBinaryWatch(int num) {\\n    return permute(new ArrayList<>(pow2(LEDS + 1)), 0, LEDS, num);\\n  }\\n  List<String> permute(List<String> results, int clock, int index, int remaining) {\\n    if (isValid(clock)) {\\n      if (remaining == 0) results.add(toString(clock));\\n      else if (index >= 0) {\\n        permute(results, clock,                index - 1, remaining);\\n        permute(results, setBit(clock, index), index - 1, remaining - 1);\\n      }\\n    }\\n    return results;\\n  }\\n  int pow2(int exponent)           { return 1 << exponent; }\\n  int setBit(int clock, int index) { return clock | pow2(index); }\\n  boolean isValid(int clock)       { return (hours(clock) < 12) && (minutes(clock) < 60); }\\n  int hours(int clock)             { return clock >>> 6; }\\n  int minutes(int clock)           { return clock & (-1 >>> -6); }\\n  String toString(int clock)       { return String.format(\"%d:%02d\", hours(clock), minutes(clock)); }\\n}\\n```\n```java\\npublic class Solution {\\n  public List<String> readBinaryWatch(int num) {\\n    switch (num) {\\n      case 0: return Arrays.asList(\"0:00\");\\n      case 1: return Arrays.asList(\"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\", \"1:00\", \"2:00\", \"4:00\", \"8:00\");\\n      case 2: return Arrays.asList(\"0:03\", \"0:05\", \"0:06\", \"0:09\", \"0:10\", \"0:12\", \"0:17\", \"0:18\", \"0:20\", \"0:24\", \"0:33\", \"0:34\", \"0:36\", \"0:40\", \"0:48\", \"10:00\", \"1:01\", \"1:02\", \"1:04\", \"1:08\", \"1:16\", \"1:32\", \"2:01\", \"2:02\", \"2:04\", \"2:08\", \"2:16\", \"2:32\", \"3:00\", \"4:01\", \"4:02\", \"4:04\", \"4:08\", \"4:16\", \"4:32\", \"5:00\", \"6:00\", \"8:01\", \"8:02\", \"8:04\", \"8:08\", \"8:16\", \"8:32\", \"9:00\");\\n      case 3: return Arrays.asList(\"0:07\", \"0:11\", \"0:13\", \"0:14\", \"0:19\", \"0:21\", \"0:22\", \"0:25\", \"0:26\", \"0:28\", \"0:35\", \"0:37\", \"0:38\", \"0:41\", \"0:42\", \"0:44\", \"0:49\", \"0:50\", \"0:52\", \"0:56\", \"10:01\", \"10:02\", \"10:04\", \"10:08\", \"10:16\", \"10:32\", \"11:00\", \"1:03\", \"1:05\", \"1:06\", \"1:09\", \"1:10\", \"1:12\", \"1:17\", \"1:18\", \"1:20\", \"1:24\", \"1:33\", \"1:34\", \"1:36\", \"1:40\", \"1:48\", \"2:03\", \"2:05\", \"2:06\", \"2:09\", \"2:10\", \"2:12\", \"2:17\", \"2:18\", \"2:20\", \"2:24\", \"2:33\", \"2:34\", \"2:36\", \"2:40\", \"2:48\", \"3:01\", \"3:02\", \"3:04\", \"3:08\", \"3:16\", \"3:32\", \"4:03\", \"4:05\", \"4:06\", \"4:09\", \"4:10\", \"4:12\", \"4:17\", \"4:18\", \"4:20\", \"4:24\", \"4:33\", \"4:34\", \"4:36\", \"4:40\", \"4:48\", \"5:01\", \"5:02\", \"5:04\", \"5:08\", \"5:16\", \"5:32\", \"6:01\", \"6:02\", \"6:04\", \"6:08\", \"6:16\", \"6:32\", \"7:00\", \"8:03\", \"8:05\", \"8:06\", \"8:09\", \"8:10\", \"8:12\", \"8:17\", \"8:18\", \"8:20\", \"8:24\", \"8:33\", \"8:34\", \"8:36\", \"8:40\", \"8:48\", \"9:01\", \"9:02\", \"9:04\", \"9:08\", \"9:16\", \"9:32\");\\n      case 4: return Arrays.asList(\"0:15\", \"0:23\", \"0:27\", \"0:29\", \"0:30\", \"0:39\", \"0:43\", \"0:45\", \"0:46\", \"0:51\", \"0:53\", \"0:54\", \"0:57\", \"0:58\", \"10:03\", \"10:05\", \"10:06\", \"10:09\", \"10:10\", \"10:12\", \"10:17\", \"10:18\", \"10:20\", \"10:24\", \"10:33\", \"10:34\", \"10:36\", \"10:40\", \"10:48\", \"11:01\", \"11:02\", \"11:04\", \"11:08\", \"11:16\", \"11:32\", \"1:07\", \"1:11\", \"1:13\", \"1:14\", \"1:19\", \"1:21\", \"1:22\", \"1:25\", \"1:26\", \"1:28\", \"1:35\", \"1:37\", \"1:38\", \"1:41\", \"1:42\", \"1:44\", \"1:49\", \"1:50\", \"1:52\", \"1:56\", \"2:07\", \"2:11\", \"2:13\", \"2:14\", \"2:19\", \"2:21\", \"2:22\", \"2:25\", \"2:26\", \"2:28\", \"2:35\", \"2:37\", \"2:38\", \"2:41\", \"2:42\", \"2:44\", \"2:49\", \"2:50\", \"2:52\", \"2:56\", \"3:03\", \"3:05\", \"3:06\", \"3:09\", \"3:10\", \"3:12\", \"3:17\", \"3:18\", \"3:20\", \"3:24\", \"3:33\", \"3:34\", \"3:36\", \"3:40\", \"3:48\", \"4:07\", \"4:11\", \"4:13\", \"4:14\", \"4:19\", \"4:21\", \"4:22\", \"4:25\", \"4:26\", \"4:28\", \"4:35\", \"4:37\", \"4:38\", \"4:41\", \"4:42\", \"4:44\", \"4:49\", \"4:50\", \"4:52\", \"4:56\", \"5:03\", \"5:05\", \"5:06\", \"5:09\", \"5:10\", \"5:12\", \"5:17\", \"5:18\", \"5:20\", \"5:24\", \"5:33\", \"5:34\", \"5:36\", \"5:40\", \"5:48\", \"6:03\", \"6:05\", \"6:06\", \"6:09\", \"6:10\", \"6:12\", \"6:17\", \"6:18\", \"6:20\", \"6:24\", \"6:33\", \"6:34\", \"6:36\", \"6:40\", \"6:48\", \"7:01\", \"7:02\", \"7:04\", \"7:08\", \"7:16\", \"7:32\", \"8:07\", \"8:11\", \"8:13\", \"8:14\", \"8:19\", \"8:21\", \"8:22\", \"8:25\", \"8:26\", \"8:28\", \"8:35\", \"8:37\", \"8:38\", \"8:41\", \"8:42\", \"8:44\", \"8:49\", \"8:50\", \"8:52\", \"8:56\", \"9:03\", \"9:05\", \"9:06\", \"9:09\", \"9:10\", \"9:12\", \"9:17\", \"9:18\", \"9:20\", \"9:24\", \"9:33\", \"9:34\", \"9:36\", \"9:40\", \"9:48\");\\n      case 5: return Arrays.asList(\"0:31\", \"0:47\", \"0:55\", \"0:59\", \"10:07\", \"10:11\", \"10:13\", \"10:14\", \"10:19\", \"10:21\", \"10:22\", \"10:25\", \"10:26\", \"10:28\", \"10:35\", \"10:37\", \"10:38\", \"10:41\", \"10:42\", \"10:44\", \"10:49\", \"10:50\", \"10:52\", \"10:56\", \"11:03\", \"11:05\", \"11:06\", \"11:09\", \"11:10\", \"11:12\", \"11:17\", \"11:18\", \"11:20\", \"11:24\", \"11:33\", \"11:34\", \"11:36\", \"11:40\", \"11:48\", \"1:15\", \"1:23\", \"1:27\", \"1:29\", \"1:30\", \"1:39\", \"1:43\", \"1:45\", \"1:46\", \"1:51\", \"1:53\", \"1:54\", \"1:57\", \"1:58\", \"2:15\", \"2:23\", \"2:27\", \"2:29\", \"2:30\", \"2:39\", \"2:43\", \"2:45\", \"2:46\", \"2:51\", \"2:53\", \"2:54\", \"2:57\", \"2:58\", \"3:07\", \"3:11\", \"3:13\", \"3:14\", \"3:19\", \"3:21\", \"3:22\", \"3:25\", \"3:26\", \"3:28\", \"3:35\", \"3:37\", \"3:38\", \"3:41\", \"3:42\", \"3:44\", \"3:49\", \"3:50\", \"3:52\", \"3:56\", \"4:15\", \"4:23\", \"4:27\", \"4:29\", \"4:30\", \"4:39\", \"4:43\", \"4:45\", \"4:46\", \"4:51\", \"4:53\", \"4:54\", \"4:57\", \"4:58\", \"5:07\", \"5:11\", \"5:13\", \"5:14\", \"5:19\", \"5:21\", \"5:22\", \"5:25\", \"5:26\", \"5:28\", \"5:35\", \"5:37\", \"5:38\", \"5:41\", \"5:42\", \"5:44\", \"5:49\", \"5:50\", \"5:52\", \"5:56\", \"6:07\", \"6:11\", \"6:13\", \"6:14\", \"6:19\", \"6:21\", \"6:22\", \"6:25\", \"6:26\", \"6:28\", \"6:35\", \"6:37\", \"6:38\", \"6:41\", \"6:42\", \"6:44\", \"6:49\", \"6:50\", \"6:52\", \"6:56\", \"7:03\", \"7:05\", \"7:06\", \"7:09\", \"7:10\", \"7:12\", \"7:17\", \"7:18\", \"7:20\", \"7:24\", \"7:33\", \"7:34\", \"7:36\", \"7:40\", \"7:48\", \"8:15\", \"8:23\", \"8:27\", \"8:29\", \"8:30\", \"8:39\", \"8:43\", \"8:45\", \"8:46\", \"8:51\", \"8:53\", \"8:54\", \"8:57\", \"8:58\", \"9:07\", \"9:11\", \"9:13\", \"9:14\", \"9:19\", \"9:21\", \"9:22\", \"9:25\", \"9:26\", \"9:28\", \"9:35\", \"9:37\", \"9:38\", \"9:41\", \"9:42\", \"9:44\", \"9:49\", \"9:50\", \"9:52\", \"9:56\");\\n      case 6: return Arrays.asList(\"10:15\", \"10:23\", \"10:27\", \"10:29\", \"10:30\", \"10:39\", \"10:43\", \"10:45\", \"10:46\", \"10:51\", \"10:53\", \"10:54\", \"10:57\", \"10:58\", \"11:07\", \"11:11\", \"11:13\", \"11:14\", \"11:19\", \"11:21\", \"11:22\", \"11:25\", \"11:26\", \"11:28\", \"11:35\", \"11:37\", \"11:38\", \"11:41\", \"11:42\", \"11:44\", \"11:49\", \"11:50\", \"11:52\", \"11:56\", \"1:31\", \"1:47\", \"1:55\", \"1:59\", \"2:31\", \"2:47\", \"2:55\", \"2:59\", \"3:15\", \"3:23\", \"3:27\", \"3:29\", \"3:30\", \"3:39\", \"3:43\", \"3:45\", \"3:46\", \"3:51\", \"3:53\", \"3:54\", \"3:57\", \"3:58\", \"4:31\", \"4:47\", \"4:55\", \"4:59\", \"5:15\", \"5:23\", \"5:27\", \"5:29\", \"5:30\", \"5:39\", \"5:43\", \"5:45\", \"5:46\", \"5:51\", \"5:53\", \"5:54\", \"5:57\", \"5:58\", \"6:15\", \"6:23\", \"6:27\", \"6:29\", \"6:30\", \"6:39\", \"6:43\", \"6:45\", \"6:46\", \"6:51\", \"6:53\", \"6:54\", \"6:57\", \"6:58\", \"7:07\", \"7:11\", \"7:13\", \"7:14\", \"7:19\", \"7:21\", \"7:22\", \"7:25\", \"7:26\", \"7:28\", \"7:35\", \"7:37\", \"7:38\", \"7:41\", \"7:42\", \"7:44\", \"7:49\", \"7:50\", \"7:52\", \"7:56\", \"8:31\", \"8:47\", \"8:55\", \"8:59\", \"9:15\", \"9:23\", \"9:27\", \"9:29\", \"9:30\", \"9:39\", \"9:43\", \"9:45\", \"9:46\", \"9:51\", \"9:53\", \"9:54\", \"9:57\", \"9:58\");\\n      case 7: return Arrays.asList(\"10:31\", \"10:47\", \"10:55\", \"10:59\", \"11:15\", \"11:23\", \"11:27\", \"11:29\", \"11:30\", \"11:39\", \"11:43\", \"11:45\", \"11:46\", \"11:51\", \"11:53\", \"11:54\", \"11:57\", \"11:58\", \"3:31\", \"3:47\", \"3:55\", \"3:59\", \"5:31\", \"5:47\", \"5:55\", \"5:59\", \"6:31\", \"6:47\", \"6:55\", \"6:59\", \"7:15\", \"7:23\", \"7:27\", \"7:29\", \"7:30\", \"7:39\", \"7:43\", \"7:45\", \"7:46\", \"7:51\", \"7:53\", \"7:54\", \"7:57\", \"7:58\", \"9:31\", \"9:47\", \"9:55\", \"9:59\");\\n      case 8: return Arrays.asList(\"11:31\", \"11:47\", \"11:55\", \"11:59\", \"7:31\", \"7:47\", \"7:55\", \"7:59\");\\n      default: return Arrays.asList();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88503,
                "title": "java-two-loops-using-bitcount-beat-90",
                "content": "```\\n    public List<String> readBinaryWatch(int num) {\\n        int bitCount = 0;\\n    \\tList<String> ls = new ArrayList<String>();\\n    \\t\\n    \\tfor(int i=0; i<12;i++){\\n    \\t\\tfor(int j=0; j<60;j++){\\n    \\t\\t\\tbitCount = Integer.bitCount(i)+Integer.bitCount(j);\\n    \\t\\t\\tif (bitCount==num){\\n    \\t\\t\\t\\tif(j<10){\\n    \\t\\t\\t\\t\\tls.add(i+\":0\"+j);\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\tls.add(i+\":\"+j);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ls;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public List<String> readBinaryWatch(int num) {\\n        int bitCount = 0;\\n    \\tList<String> ls = new ArrayList<String>();\\n    \\t\\n    \\tfor(int i=0; i<12;i++){\\n    \\t\\tfor(int j=0; j<60;j++){\\n    \\t\\t\\tbitCount = Integer.bitCount(i)+Integer.bitCount(j);\\n    \\t\\t\\tif (bitCount==num){\\n    \\t\\t\\t\\tif(j<10){\\n    \\t\\t\\t\\t\\tls.add(i+\":0\"+j);\\n    \\t\\t\\t\\t}else{\\n    \\t\\t\\t\\t\\tls.add(i+\":\"+j);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\treturn ls;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 88582,
                "title": "concise-backtracking",
                "content": "    public List<String> readBinaryWatch(int num) {\\n        List<String> result = new ArrayList<String>();\\n        run(result, 0, 0, 0, num);\\n        return result;\\n    }\\n    \\n    private void run(List<String> result, int time, int startBit, int count, int num) {\\n        if (startBit == 10 || count == num) {\\n            if (count == num && isValid(time)) {\\n                result.add(print(time));\\n            }\\n            return;\\n        }\\n        for (int i = startBit; i < 10; i++) {\\n            run(result, time | (1<<i), i+1, count+1, num);\\n        }\\n    }\\n    \\n    private boolean isValid(int time) {\\n        return (time & 0x3f) < 60 && ((time>>6)&0xf) < 12;\\n    }\\n    \\n    private String print(int time) {\\n        return String.format(\"%d:%02d\", (time>>6)&0xf, (time & 0x3f));\\n    }",
                "solutionTags": [],
                "code": "    public List<String> readBinaryWatch(int num) {\\n        List<String> result = new ArrayList<String>();\\n        run(result, 0, 0, 0, num);\\n        return result;\\n    }\\n    \\n    private void run(List<String> result, int time, int startBit, int count, int num) {\\n        if (startBit == 10 || count == num) {\\n            if (count == num && isValid(time)) {\\n                result.add(print(time));\\n            }\\n            return;\\n        }\\n        for (int i = startBit; i < 10; i++) {\\n            run(result, time | (1<<i), i+1, count+1, num);\\n        }\\n    }\\n    \\n    private boolean isValid(int time) {\\n        return (time & 0x3f) < 60 && ((time>>6)&0xf) < 12;\\n    }\\n    \\n    private String print(int time) {\\n        return String.format(\"%d:%02d\", (time>>6)&0xf, (time & 0x3f));\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 88598,
                "title": "c-0ms-bit-manipulation",
                "content": "There are total 10 bits to present a time. We can use high 4 bits as hour and low 6 bits as minutes. It is easy to figure out that the maximum value of ```num``` is 8, or the either hour or minute will overflow.\\nSo, iterate all numbers from 0 to 0x2FF (```1011 | 111111 ```), ```1011``` is ```11```.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        if (num < 0 || num > 8) return res;\\n        for (int i = 0; i < 0x2FF; i++) {\\n            if (bitset<16>(i).count() == num) add(i, res);\\n        }\\n        return res;\\n    }\\n    \\n    void add(int n, vector<string>& res) {\\n        string s;\\n        int mins = n & 0x3F;\\n        if (mins > 59) return;\\n        int hour = n >> 6 & 0xF;\\n        if (hour > 11) return;\\n        s += to_string(hour) + \":\";\\n        if (mins < 10) s += \"0\";\\n        s += to_string(mins);\\n        res.push_back(s);\\n    }\\n};\\n```\\n\\nInspired by [@StefanPochmann's idea](https://discuss.leetcode.com/topic/59374/simple-python-java). Below is the C++ version\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        if (num < 0 || num > 8) return res;\\n        for (int i = 0; i < 12; i++) {\\n            for (int j = 0; j < 60; j++) {\\n                if (bitset<16>((j << 4) + i).count() == num) {\\n                    string t = to_string(i) + \":\";\\n                    if (j < 10) t.push_back('0');\\n                    t += to_string(j);\\n                    res.push_back(t);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```num```\n```1011 | 111111 ```\n```1011```\n```11```\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        if (num < 0 || num > 8) return res;\\n        for (int i = 0; i < 0x2FF; i++) {\\n            if (bitset<16>(i).count() == num) add(i, res);\\n        }\\n        return res;\\n    }\\n    \\n    void add(int n, vector<string>& res) {\\n        string s;\\n        int mins = n & 0x3F;\\n        if (mins > 59) return;\\n        int hour = n >> 6 & 0xF;\\n        if (hour > 11) return;\\n        s += to_string(hour) + \":\";\\n        if (mins < 10) s += \"0\";\\n        s += to_string(mins);\\n        res.push_back(s);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        if (num < 0 || num > 8) return res;\\n        for (int i = 0; i < 12; i++) {\\n            for (int j = 0; j < 60; j++) {\\n                if (bitset<16>((j << 4) + i).count() == num) {\\n                    string t = to_string(i) + \":\";\\n                    if (j < 10) t.push_back('0');\\n                    t += to_string(j);\\n                    res.push_back(t);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491042,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public IList<string> ReadBinaryWatch(int turnedOn) \\n    {\\n        var res = new List<string>();\\n\\n        for (var minute = 0; minute < 60; minute++)\\n            for (var hour = 0; hour < 12; hour++)\\n                if (CountBits(minute) + CountBits(hour) == turnedOn)\\n                    res.Add($\"{hour}:{minute:D2}\");\\n\\n        return res;\\n\\n        int CountBits(int num)\\n        {\\n            var count = 0;\\n            while (num != 0)\\n            {\\n                num &= num - 1;\\n                count++;\\n            }\\n            return count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public IList<string> ReadBinaryWatch(int turnedOn) \\n    {\\n        var res = new List<string>();\\n\\n        for (var minute = 0; minute < 60; minute++)\\n            for (var hour = 0; hour < 12; hour++)\\n                if (CountBits(minute) + CountBits(hour) == turnedOn)\\n                    res.Add($\"{hour}:{minute:D2}\");\\n\\n        return res;\\n\\n        int CountBits(int num)\\n        {\\n            var count = 0;\\n            while (num != 0)\\n            {\\n                num &= num - 1;\\n                count++;\\n            }\\n            return count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797700,
                "title": "c-solution-backtracking-bit-manipulation-o-1",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code : Bit Manipulation\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string>ans;\\n        for(int hr = 0; hr < 12; hr++){\\n            for(int min = 0; min < 60;min++){\\n                if(__builtin_popcount(hr) + __builtin_popcount(min) == turnedOn){\\n                    if(min < 10){\\n                        ans.push_back(to_string(hr) + \":0\" + to_string(min));\\n                    }\\n                    else{\\n                        ans.push_back(to_string(hr) + \":\" + to_string(min));\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Code : Backtracking\\n```\\nclass Solution {\\npublic:\\n    vector<int> hour = {1,2,4,8};\\n    vector<int> minute = {1,2,4,8,16,32};\\n    vector<string> res;\\n\\n    void solve(int hr, int min, int i, int n){\\n\\n        // base case\\n        if(n == 0){\\n            string s = to_string(hr)  + (min < 10 ? \":0\" : \":\")  + to_string(min);\\n            res.push_back(s);\\n            return;\\n        }\\n\\n        // solution\\n        for(int j = i; j < hour.size() + minute.size();j++){\\n            if(j < hour.size()){\\n                hr += hour[j];\\n                if(hr < 12){\\n                    solve(hr,min,j+1,n-1);\\n                }\\n                hr -= hour[j];\\n            }\\n            else{\\n                min += minute[j-hour.size()];\\n                if(min < 60){\\n                    solve(hr,min,j+1,n-1);\\n                }\\n                min -= minute[j-hour.size()];\\n            }\\n        }\\n    }\\n\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        solve(0,0,0,turnedOn);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string>ans;\\n        for(int hr = 0; hr < 12; hr++){\\n            for(int min = 0; min < 60;min++){\\n                if(__builtin_popcount(hr) + __builtin_popcount(min) == turnedOn){\\n                    if(min < 10){\\n                        ans.push_back(to_string(hr) + \":0\" + to_string(min));\\n                    }\\n                    else{\\n                        ans.push_back(to_string(hr) + \":\" + to_string(min));\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> hour = {1,2,4,8};\\n    vector<int> minute = {1,2,4,8,16,32};\\n    vector<string> res;\\n\\n    void solve(int hr, int min, int i, int n){\\n\\n        // base case\\n        if(n == 0){\\n            string s = to_string(hr)  + (min < 10 ? \":0\" : \":\")  + to_string(min);\\n            res.push_back(s);\\n            return;\\n        }\\n\\n        // solution\\n        for(int j = i; j < hour.size() + minute.size();j++){\\n            if(j < hour.size()){\\n                hr += hour[j];\\n                if(hr < 12){\\n                    solve(hr,min,j+1,n-1);\\n                }\\n                hr -= hour[j];\\n            }\\n            else{\\n                min += minute[j-hour.size()];\\n                if(min < 60){\\n                    solve(hr,min,j+1,n-1);\\n                }\\n                min -= minute[j-hour.size()];\\n            }\\n        }\\n    }\\n\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        solve(0,0,0,turnedOn);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786333,
                "title": "c-solution-100-time-63-60-space-used-bit-set",
                "content": "```\\nconst int TOTAL_HOURS_AM_PM_MODE_PER_DAY = 12;\\nconst int TOTAL_MINUTES_PER_HOUR = 60;\\n\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn);\\n};\\n/************************************************************************/\\nvector<string> Solution::readBinaryWatch(int turnedOn) {\\n    vector<string> v;\\n    if (turnedOn > 10) {\\n        return v;\\n    }\\n    int h, min;\\n    bitset<4> bH;\\n    bitset<6> bMin;\\n    char hC[4], minC[3];\\n    string s;\\n    for (h = 0; h < TOTAL_HOURS_AM_PM_MODE_PER_DAY; ++h) {\\n        for (min = 0; min < TOTAL_MINUTES_PER_HOUR; ++min) {\\n            bH = h;\\n            bMin = min;\\n            if (bH.count() + bMin.count() == turnedOn) {\\n                sprintf(hC,\"%d:\",h);\\n                sprintf(minC,\"%02d\", min);\\n                s=\"\";\\n                s+=hC;\\n                s+=minC;\\n                v.emplace_back(s);\\n            }\\n        } \\n    }\\n    return v;\\n}\\n/************************************************************************/\\n```",
                "solutionTags": [],
                "code": "```\\nconst int TOTAL_HOURS_AM_PM_MODE_PER_DAY = 12;\\nconst int TOTAL_MINUTES_PER_HOUR = 60;\\n\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn);\\n};\\n/************************************************************************/\\nvector<string> Solution::readBinaryWatch(int turnedOn) {\\n    vector<string> v;\\n    if (turnedOn > 10) {\\n        return v;\\n    }\\n    int h, min;\\n    bitset<4> bH;\\n    bitset<6> bMin;\\n    char hC[4], minC[3];\\n    string s;\\n    for (h = 0; h < TOTAL_HOURS_AM_PM_MODE_PER_DAY; ++h) {\\n        for (min = 0; min < TOTAL_MINUTES_PER_HOUR; ++min) {\\n            bH = h;\\n            bMin = min;\\n            if (bH.count() + bMin.count() == turnedOn) {\\n                sprintf(hC,\"%d:\",h);\\n                sprintf(minC,\"%02d\", min);\\n                s=\"\";\\n                s+=hC;\\n                s+=minC;\\n                v.emplace_back(s);\\n            }\\n        } \\n    }\\n    return v;\\n}\\n/************************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510111,
                "title": "c-faster-than-100-explained",
                "content": "The key in this solution is this: \\nminute 0 = 0:00\\nminute 1 = 0:01\\nminute 2 = 0:02\\n...\\nminute 60 = 1:00\\n....\\nminute 125 = 2:05\\n....\\nminute 248 = 4:08\\nand so on until\\nminute 719 wich is 11:59\\nBased on that we just need to know if a particular minute `X` has `turnedOn` amount of 1s. So we convert `X`  into `HOURS`  + `MINUTES` , lets call `Y` the amount of 1s in the binary representation of `HOURS` and lets call `Z` to the amount of 1s in the binary representation of `MINUTES`. We can say `X` is a valid hour if `Y + Z = turnedOn` so we just need to check for all the 720 hours we can represent in our clock if they are valid or not and we add it to the solution.\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> sol;\\n        for(int i = 0; i <= 719; i++) // there is only 720 different hours we can represent\\n            if(isValidTime(i, turnedOn)) // if minute i is representable in hour clock and has the same amount of 1s as turnedOn we added\\n                sol.push_back(convertToStringHour(i));\\n        \\n        return sol;\\n    }\\n    \\n    bool isValidTime(int time, int target){\\n        int hours = time / 60; //number of hours in *time*\\n        int minu = time % 60; //number of minutes in *time* when we represent it has HH:MM\\n\\t\\t\\n\\t\\t/**\\n\\t\\t* Maybe this is the most complex part of the sulution, __builtin__popcount(X) is a function \\n\\t\\t* from C compiler that returns the amount of 1s in the binary representation of X(for example if X = 5, its\\n\\t\\t* binary representation is \"101\" so __builtin_popcount(5) == 2 since there is 2 numbers 1 in \"101\")\\n\\t\\t* so we can represent *time* in hour binary clock if __builtin_popcount(HOURS) + __builtin_popcount(MINUTS)  == turnedOn\\n\\t\\t* so the translation of that is that the numbers of 1s in HOURS plus the numbers of 1s in MINUTS is equal to *turnedOn*\\n\\t\\t* */\\n        if(__builtin_popcount(hours) + __builtin_popcount(minu) == target) return true;\\n        return false;\\n    }\\n\\n\\t// This function convert minutus X to String format \"HH:MM\"\\n    string convertToStringHour(int n){\\n        int hours = n / 60; // number of hours in N\\n        int minu = n % 60; // number of minuts in N\\n\\n        string sol = \"\";\\n        if(hours == 0)\\n            sol = \"0:\";\\n        else\\n            sol = to_string(hours) + \\':\\';\\n\\n        if(minu == 0)\\n            sol += \"00\";\\n        else if(minu < 10){\\n            sol += \"0\";\\n            sol += to_string(minu);\\n        }\\n        else\\n            sol += to_string(minu);\\n\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> sol;\\n        for(int i = 0; i <= 719; i++) // there is only 720 different hours we can represent\\n            if(isValidTime(i, turnedOn)) // if minute i is representable in hour clock and has the same amount of 1s as turnedOn we added\\n                sol.push_back(convertToStringHour(i));\\n        \\n        return sol;\\n    }\\n    \\n    bool isValidTime(int time, int target){\\n        int hours = time / 60; //number of hours in *time*\\n        int minu = time % 60; //number of minutes in *time* when we represent it has HH:MM\\n\\t\\t\\n\\t\\t/**\\n\\t\\t* Maybe this is the most complex part of the sulution, __builtin__popcount(X) is a function \\n\\t\\t* from C compiler that returns the amount of 1s in the binary representation of X(for example if X = 5, its\\n\\t\\t* binary representation is \"101\" so __builtin_popcount(5) == 2 since there is 2 numbers 1 in \"101\")\\n\\t\\t* so we can represent *time* in hour binary clock if __builtin_popcount(HOURS) + __builtin_popcount(MINUTS)  == turnedOn\\n\\t\\t* so the translation of that is that the numbers of 1s in HOURS plus the numbers of 1s in MINUTS is equal to *turnedOn*\\n\\t\\t* */\\n        if(__builtin_popcount(hours) + __builtin_popcount(minu) == target) return true;\\n        return false;\\n    }\\n\\n\\t// This function convert minutus X to String format \"HH:MM\"\\n    string convertToStringHour(int n){\\n        int hours = n / 60; // number of hours in N\\n        int minu = n % 60; // number of minuts in N\\n\\n        string sol = \"\";\\n        if(hours == 0)\\n            sol = \"0:\";\\n        else\\n            sol = to_string(hours) + \\':\\';\\n\\n        if(minu == 0)\\n            sol += \"00\";\\n        else if(minu < 10){\\n            sol += \"0\";\\n            sol += to_string(minu);\\n        }\\n        else\\n            sol += to_string(minu);\\n\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195723,
                "title": "python-backtracking-beats-96-07",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        possibleTimes = []\\n        time = \"0000000000\" #the first four 0s are hours and remaining six 0s are minutes\\n        def solve(LED,p,time):\\n            if LED == 0:\\n                totalMinutes = int(time[4:],2)\\n                totalHours = int(time[:4],2)\\n                if totalMinutes < 10 and totalHours < 12:\\n                    possibleTimes.append(str(totalHours) + \":0\" + str(totalMinutes))\\n                elif totalMinutes < 60 and totalHours < 12:\\n                    possibleTimes.append(str(totalHours) + \":\" + str(totalMinutes))\\n            else:\\n                for i in range(p,10):\\n                    if time[i] == \"0\":\\n                        time = time[:i] + \"1\" + time[i+1:] #change\\n                        solve(LED-1,i,time) #recur\\n                        time = time[:i] + \"0\" + time[i+1:] #backtrack\\n        if turnedOn > 8:\\n            return possibleTimes #no possible solution\\n        solve(turnedOn,0,time)\\n        return possibleTimes\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        possibleTimes = []\\n        time = \"0000000000\" #the first four 0s are hours and remaining six 0s are minutes\\n        def solve(LED,p,time):\\n            if LED == 0:\\n                totalMinutes = int(time[4:],2)\\n                totalHours = int(time[:4],2)\\n                if totalMinutes < 10 and totalHours < 12:\\n                    possibleTimes.append(str(totalHours) + \":0\" + str(totalMinutes))\\n                elif totalMinutes < 60 and totalHours < 12:\\n                    possibleTimes.append(str(totalHours) + \":\" + str(totalMinutes))\\n            else:\\n                for i in range(p,10):\\n                    if time[i] == \"0\":\\n                        time = time[:i] + \"1\" + time[i+1:] #change\\n                        solve(LED-1,i,time) #recur\\n                        time = time[:i] + \"0\" + time[i+1:] #backtrack\\n        if turnedOn > 8:\\n            return possibleTimes #no possible solution\\n        solve(turnedOn,0,time)\\n        return possibleTimes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115139,
                "title": "100-0ms-consice-code-meme",
                "content": "```\\nJust go through the possible times and collect those with the correct number of one-bits.\\n\\nPython:\\n\\ndef readBinaryWatch(self, num):\\n    return [\\'%d:%02d\\' % (h, m)\\n            for h in range(12) for m in range(60)\\n            if (bin(h) + bin(m)).count(\\'1\\') == num]\\nJava:\\n\\npublic List<String> readBinaryWatch(int num) {\\n    List<String> times = new ArrayList<>();\\n    for (int h=0; h<12; h++)\\n        for (int m=0; m<60; m++)\\n            if (Integer.bitCount(h * 64 + m) == num)\\n                times.add(String.format(\"%d:%02d\", h, m));\\n    return times;        \\n}\\n```\\n![image](https://assets.leetcode.com/users/images/11a37fdf-593e-40a5-b2ee-227e19ee9164_1654447511.3796976.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nJust go through the possible times and collect those with the correct number of one-bits.\\n\\nPython:\\n\\ndef readBinaryWatch(self, num):\\n    return [\\'%d:%02d\\' % (h, m)\\n            for h in range(12) for m in range(60)\\n            if (bin(h) + bin(m)).count(\\'1\\') == num]\\nJava:\\n\\npublic List<String> readBinaryWatch(int num) {\\n    List<String> times = new ArrayList<>();\\n    for (int h=0; h<12; h++)\\n        for (int m=0; m<60; m++)\\n            if (Integer.bitCount(h * 64 + m) == num)\\n                times.add(String.format(\"%d:%02d\", h, m));\\n    return times;        \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2021813,
                "title": "subset-enumeration-with-gosper-s-hack-no-recursion-no-backtracking-20-lines",
                "content": "# Problem\\nWe have 10 leds (4 for the hours and 6 for the minutes) on the watch and we know that k are on.\\nThe tasks consists in enumerating all the possible times that the watch is currently showing.\\n\\nRecall that our \"hour\" leds are `[8, 4, 2, 1]` and our minutes leds are `[32, 16, 8, 4, 2, 1]`\\n\\n# Subset enumeration\\nBasically, we want to enumerate all the subsets of leds size k. \\nWe can represent a given subset with the bits of an integer. For example the integer 0100 000001 in binary corresponds to the situation where the second hour led is on, and the last minute led is on (I added a space to clearly represent the distinction between hours bits and minute bits). Thus this integer represents the time 4:01\\n\\nNotice that not all subset are feasible. For example, the subset represented by 1111 000000 would correspond to time 15:00, which is invalid in 12h format. Similarly, the bits corresponding to the minutes could code a number higher than 60, which is impossible. This tells us that we will have to filter the valid subset when enumerating.\\n\\n## Bitwise operation refresher\\n\\nThere are two basic operations that are useful when manipulating bit representation:\\n**Check if kth bit is on**: if `set` is our integer coding the subset, the condition can be written as `if((set>>k)&1)` or equivalently `if((set & (1<<k)) != 0)`\\n**Set the ith bit to true**: This is a simple bitwise or: `set |= (1<<k);`\\n\\n## Gosper\\'s hack\\nIt turns out there is a very elegant solution to enumerate all subset of size k. We start with the lexicographically smallest set, namely `set = (1<<k) - 1` (This is the set where the last k bits are on).\\nThen Gosper\\'s hack allows to transition to the next valid subset of size k in O(1) time and memory. It does so by operating the following operation:\\n```\\n // Gosper\\'s hack:\\nint c = set & - set;\\nint r = set + c;\\nset = (((r ^ set) >> 2) / c) | r;\\n```\\nI won\\'t go in details about the details of this hack. You can refer to online resources such as https://read.seas.harvard.edu/~kohler/class/cs207-s12/lec12.html\\n\\n# Putting it together\\nWith these building blocks, the solution is quite easy to write and should be self-explanatory. The takeaway message is that next time you encounter some kind of subset enumeration, think of Gosper\\'s hack!\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int k) {\\n        if(k==0) return {\"0:00\"}; // special case\\n        vector<string> result;\\n        const int n = 10;         // Total number of bits\\n        int set = (1 << k) - 1;   // Initial set\\n        while(set < (1<<n)) {     // Check that we don\\'t use too many bits\\n            int hour = 0, minute = 0;\\n            for(int i = 0; i < n; ++i){        //Enumerate all the bits\\n                if((set>>i)&1){                //Check if the ith bit is set\\n                    if(i < 4) hour |= (1<<i);  //hour bits\\n                    else minute |= (1<<(i-4)); //minute bits\\n                }\\n            } \\n            if(hour < 12 && minute < 60){      // Filter impossible times and convert to string\\n                string min_str = to_string(minute);\\n                result.push_back(to_string(hour) + ((min_str.size() < 2) ? \":0\"s : \":\"s) + min_str);\\n            }\\n  \\n            int c = set & -set;// Gosper\\'s hack\\n            int r = set + c;\\n            set = (((r^set) >> 2) / c) | r;\\n        } \\n        return result;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n // Gosper\\'s hack:\\nint c = set & - set;\\nint r = set + c;\\nset = (((r ^ set) >> 2) / c) | r;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int k) {\\n        if(k==0) return {\"0:00\"}; // special case\\n        vector<string> result;\\n        const int n = 10;         // Total number of bits\\n        int set = (1 << k) - 1;   // Initial set\\n        while(set < (1<<n)) {     // Check that we don\\'t use too many bits\\n            int hour = 0, minute = 0;\\n            for(int i = 0; i < n; ++i){        //Enumerate all the bits\\n                if((set>>i)&1){                //Check if the ith bit is set\\n                    if(i < 4) hour |= (1<<i);  //hour bits\\n                    else minute |= (1<<(i-4)); //minute bits\\n                }\\n            } \\n            if(hour < 12 && minute < 60){      // Filter impossible times and convert to string\\n                string min_str = to_string(minute);\\n                result.push_back(to_string(hour) + ((min_str.size() < 2) ? \":0\"s : \":\"s) + min_str);\\n            }\\n  \\n            int c = set & -set;// Gosper\\'s hack\\n            int r = set + c;\\n            set = (((r^set) >> 2) / c) | r;\\n        } \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782486,
                "title": "binary-watch-solution-java",
                "content": "class Solution {\\n  public List<String> readBinaryWatch(int num) {\\n    List<String> ans = new ArrayList<>();\\n    dfs(num, 0, 0, 0, ans);\\n    return ans;\\n  }\\n\\n  private int[] hours = new int[] {1, 2, 4, 8};\\n  private int[] minutes = new int[] {1, 2, 4, 8, 16, 32};\\n\\n  private void dfs(int n, int s, int h, int m, List<String> ans) {\\n    if (n == 0) {\\n      final String time = String.valueOf(h) + \":\" + (m < 10 ? \"0\" : \"\") + String.valueOf(m);\\n      ans.add(time);\\n      return;\\n    }\\n\\n    for (int i = s; i < hours.length + minutes.length; ++i)\\n      if (i < 4 && h + hours[i] < 12)\\n        dfs(n - 1, i + 1, h + hours[i], m, ans);\\n      else if (i >= 4 && m + minutes[i - 4] < 60)\\n        dfs(n - 1, i + 1, h, m + minutes[i - 4], ans);\\n  }\\n}\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n  public List<String> readBinaryWatch(int num) {\\n    List<String> ans = new ArrayList<>();\\n    dfs(num, 0, 0, 0, ans);\\n    return ans;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1658045,
                "title": "straight-forward-c-solution-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int count(int n)\\n    {\\n        int c = 0;\\n        while(n)\\n        {\\n            c += (n&1);\\n            n = n >> 1;\\n        }\\n        return c;\\n    }\\n    \\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> res;\\n        for(int h=0;h<=11;h++)\\n        {\\n            for(int m=0;m<=59;m++)\\n            {\\n                int setbits_h = count(h);\\n                int setbits_m = count(m);\\n                if(setbits_h + setbits_m == turnedOn)\\n                {\\n                    string s = \"\";\\n                    if(m < 10)\\n                    {\\n                        s = s + to_string(h) + \":0\" + to_string(m);\\n                    }\\n                    else\\n                    {\\n                        s = s + to_string(h) + \":\" + to_string(m);\\n                    }\\n                    res.push_back(s);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count(int n)\\n    {\\n        int c = 0;\\n        while(n)\\n        {\\n            c += (n&1);\\n            n = n >> 1;\\n        }\\n        return c;\\n    }\\n    \\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> res;\\n        for(int h=0;h<=11;h++)\\n        {\\n            for(int m=0;m<=59;m++)\\n            {\\n                int setbits_h = count(h);\\n                int setbits_m = count(m);\\n                if(setbits_h + setbits_m == turnedOn)\\n                {\\n                    string s = \"\";\\n                    if(m < 10)\\n                    {\\n                        s = s + to_string(h) + \":0\" + to_string(m);\\n                    }\\n                    else\\n                    {\\n                        s = s + to_string(h) + \":\" + to_string(m);\\n                    }\\n                    res.push_back(s);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611607,
                "title": "python-faster-than-100-16ms-premapping-list-comprehension",
                "content": "This is the fastest solution, but probably not most instructive in terms of bit counting/manipulation.\\nDifferent submissions of the same code ranged from 16ms to 32ms, and 14.2 MB to 14.5 MB\\n\\n\\n```python\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n            \\n            hours = {\\n                0: (\"0\",),\\n                1: (\"1\", \"2\", \"4\", \"8\"),\\n                2: (\"3\", \"5\", \"6\", \"9\", \"10\"),\\n                3: (\"7\", \"11\")\\n            }\\n            \\n            minutes = {\\n                0: (\\'00\\', ),\\n                1: (\\'01\\', \\'02\\', \\'04\\', \\'08\\', \\'16\\', \\'32\\'),\\n                2: (\\'03\\', \\'05\\', \\'06\\', \\'09\\', \\'10\\', \\'12\\', \\'17\\', \\'18\\', \\'20\\', \\'24\\', \\'33\\', \\'34\\', \\'36\\', \\'40\\', \\'48\\'),\\n                3: (\\'07\\', \\'11\\', \\'13\\', \\'14\\', \\'19\\', \\'21\\', \\'22\\', \\'25\\', \\'26\\', \\'28\\', \\'35\\', \\'37\\', \\'38\\', \\'41\\', \\'42\\', \\'44\\', \\'49\\', \\'50\\', \\'52\\', \\'56\\'),\\n                4: (\\'15\\', \\'23\\', \\'27\\', \\'29\\', \\'30\\', \\'39\\', \\'43\\', \\'45\\', \\'46\\', \\'51\\', \\'53\\', \\'54\\', \\'57\\', \\'58\\'),\\n                5: (\\'31\\', \\'47\\', \\'55\\', \\'59\\')\\n            }\\n            \\n            times = []\\n            for h in hours:\\n                if h > turnedOn:\\n                    break\\n                p_hours = hours[h]\\n                for m in range(6):\\n                    if h + m == turnedOn:\\n                        p_minutes = minutes[m]\\n                        times.extend([\\':\\'.join((hh,mm)) for hh in p_hours for mm in p_minutes])\\n            \\n            return times\\n```\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/a78be796-5cd5-4f84-98a4-d2f9a7951991_1638647346.1693537.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n            \\n            hours = {\\n                0: (\"0\",),\\n                1: (\"1\", \"2\", \"4\", \"8\"),\\n                2: (\"3\", \"5\", \"6\", \"9\", \"10\"),\\n                3: (\"7\", \"11\")\\n            }\\n            \\n            minutes = {\\n                0: (\\'00\\', ),\\n                1: (\\'01\\', \\'02\\', \\'04\\', \\'08\\', \\'16\\', \\'32\\'),\\n                2: (\\'03\\', \\'05\\', \\'06\\', \\'09\\', \\'10\\', \\'12\\', \\'17\\', \\'18\\', \\'20\\', \\'24\\', \\'33\\', \\'34\\', \\'36\\', \\'40\\', \\'48\\'),\\n                3: (\\'07\\', \\'11\\', \\'13\\', \\'14\\', \\'19\\', \\'21\\', \\'22\\', \\'25\\', \\'26\\', \\'28\\', \\'35\\', \\'37\\', \\'38\\', \\'41\\', \\'42\\', \\'44\\', \\'49\\', \\'50\\', \\'52\\', \\'56\\'),\\n                4: (\\'15\\', \\'23\\', \\'27\\', \\'29\\', \\'30\\', \\'39\\', \\'43\\', \\'45\\', \\'46\\', \\'51\\', \\'53\\', \\'54\\', \\'57\\', \\'58\\'),\\n                5: (\\'31\\', \\'47\\', \\'55\\', \\'59\\')\\n            }\\n            \\n            times = []\\n            for h in hours:\\n                if h > turnedOn:\\n                    break\\n                p_hours = hours[h]\\n                for m in range(6):\\n                    if h + m == turnedOn:\\n                        p_minutes = minutes[m]\\n                        times.extend([\\':\\'.join((hh,mm)) for hh in p_hours for mm in p_minutes])\\n            \\n            return times\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593479,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        (0i32..768)\\n            .filter(|&t| t.count_ones() as i32 == turned_on)\\n            .map(|t| (t / 64, t % 64))\\n            .filter(|(_, m)| m < &60)\\n            .map(|(h, m)| format!(\"{}:{:02}\", h, m))\\n            .collect()\\n    }\\n}\\n```\\n\\nBonus point: memoization.\\n\\n```\\nlazy_static! {\\n    static ref A: Vec<Vec<&\\'static str>> = {\\n        vec![\\n            vec![\"0:00\"],\\n            vec![\\n                \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\", \"1:00\", \"2:00\", \"4:00\", \"8:00\",\\n            ],\\n            vec![\\n                \"0:03\", \"0:05\", \"0:06\", \"0:09\", \"0:10\", \"0:12\", \"0:17\", \"0:18\", \"0:20\", \"0:24\",\\n                \"0:33\", \"0:34\", \"0:36\", \"0:40\", \"0:48\", \"1:01\", \"1:02\", \"1:04\", \"1:08\", \"1:16\",\\n                \"1:32\", \"2:01\", \"2:02\", \"2:04\", \"2:08\", \"2:16\", \"2:32\", \"3:00\", \"4:01\", \"4:02\",\\n                \"4:04\", \"4:08\", \"4:16\", \"4:32\", \"5:00\", \"6:00\", \"8:01\", \"8:02\", \"8:04\", \"8:08\",\\n                \"8:16\", \"8:32\", \"9:00\", \"10:00\",\\n            ],\\n            vec![\\n                \"0:07\", \"0:11\", \"0:13\", \"0:14\", \"0:19\", \"0:21\", \"0:22\", \"0:25\", \"0:26\", \"0:28\",\\n                \"0:35\", \"0:37\", \"0:38\", \"0:41\", \"0:42\", \"0:44\", \"0:49\", \"0:50\", \"0:52\", \"0:56\",\\n                \"1:03\", \"1:05\", \"1:06\", \"1:09\", \"1:10\", \"1:12\", \"1:17\", \"1:18\", \"1:20\", \"1:24\",\\n                \"1:33\", \"1:34\", \"1:36\", \"1:40\", \"1:48\", \"2:03\", \"2:05\", \"2:06\", \"2:09\", \"2:10\",\\n                \"2:12\", \"2:17\", \"2:18\", \"2:20\", \"2:24\", \"2:33\", \"2:34\", \"2:36\", \"2:40\", \"2:48\",\\n                \"3:01\", \"3:02\", \"3:04\", \"3:08\", \"3:16\", \"3:32\", \"4:03\", \"4:05\", \"4:06\", \"4:09\",\\n                \"4:10\", \"4:12\", \"4:17\", \"4:18\", \"4:20\", \"4:24\", \"4:33\", \"4:34\", \"4:36\", \"4:40\",\\n                \"4:48\", \"5:01\", \"5:02\", \"5:04\", \"5:08\", \"5:16\", \"5:32\", \"6:01\", \"6:02\", \"6:04\",\\n                \"6:08\", \"6:16\", \"6:32\", \"7:00\", \"8:03\", \"8:05\", \"8:06\", \"8:09\", \"8:10\", \"8:12\",\\n                \"8:17\", \"8:18\", \"8:20\", \"8:24\", \"8:33\", \"8:34\", \"8:36\", \"8:40\", \"8:48\", \"9:01\",\\n                \"9:02\", \"9:04\", \"9:08\", \"9:16\", \"9:32\", \"10:01\", \"10:02\", \"10:04\", \"10:08\",\\n                \"10:16\", \"10:32\", \"11:00\",\\n            ],\\n            vec![\\n                \"0:15\", \"0:23\", \"0:27\", \"0:29\", \"0:30\", \"0:39\", \"0:43\", \"0:45\", \"0:46\", \"0:51\",\\n                \"0:53\", \"0:54\", \"0:57\", \"0:58\", \"1:07\", \"1:11\", \"1:13\", \"1:14\", \"1:19\", \"1:21\",\\n                \"1:22\", \"1:25\", \"1:26\", \"1:28\", \"1:35\", \"1:37\", \"1:38\", \"1:41\", \"1:42\", \"1:44\",\\n                \"1:49\", \"1:50\", \"1:52\", \"1:56\", \"2:07\", \"2:11\", \"2:13\", \"2:14\", \"2:19\", \"2:21\",\\n                \"2:22\", \"2:25\", \"2:26\", \"2:28\", \"2:35\", \"2:37\", \"2:38\", \"2:41\", \"2:42\", \"2:44\",\\n                \"2:49\", \"2:50\", \"2:52\", \"2:56\", \"3:03\", \"3:05\", \"3:06\", \"3:09\", \"3:10\", \"3:12\",\\n                \"3:17\", \"3:18\", \"3:20\", \"3:24\", \"3:33\", \"3:34\", \"3:36\", \"3:40\", \"3:48\", \"4:07\",\\n                \"4:11\", \"4:13\", \"4:14\", \"4:19\", \"4:21\", \"4:22\", \"4:25\", \"4:26\", \"4:28\", \"4:35\",\\n                \"4:37\", \"4:38\", \"4:41\", \"4:42\", \"4:44\", \"4:49\", \"4:50\", \"4:52\", \"4:56\", \"5:03\",\\n                \"5:05\", \"5:06\", \"5:09\", \"5:10\", \"5:12\", \"5:17\", \"5:18\", \"5:20\", \"5:24\", \"5:33\",\\n                \"5:34\", \"5:36\", \"5:40\", \"5:48\", \"6:03\", \"6:05\", \"6:06\", \"6:09\", \"6:10\", \"6:12\",\\n                \"6:17\", \"6:18\", \"6:20\", \"6:24\", \"6:33\", \"6:34\", \"6:36\", \"6:40\", \"6:48\", \"7:01\",\\n                \"7:02\", \"7:04\", \"7:08\", \"7:16\", \"7:32\", \"8:07\", \"8:11\", \"8:13\", \"8:14\", \"8:19\",\\n                \"8:21\", \"8:22\", \"8:25\", \"8:26\", \"8:28\", \"8:35\", \"8:37\", \"8:38\", \"8:41\", \"8:42\",\\n                \"8:44\", \"8:49\", \"8:50\", \"8:52\", \"8:56\", \"9:03\", \"9:05\", \"9:06\", \"9:09\", \"9:10\",\\n                \"9:12\", \"9:17\", \"9:18\", \"9:20\", \"9:24\", \"9:33\", \"9:34\", \"9:36\", \"9:40\", \"9:48\",\\n                \"10:03\", \"10:05\", \"10:06\", \"10:09\", \"10:10\", \"10:12\", \"10:17\", \"10:18\", \"10:20\",\\n                \"10:24\", \"10:33\", \"10:34\", \"10:36\", \"10:40\", \"10:48\", \"11:01\", \"11:02\", \"11:04\",\\n                \"11:08\", \"11:16\", \"11:32\",\\n            ],\\n            vec![\\n                \"0:31\", \"0:47\", \"0:55\", \"0:59\", \"1:15\", \"1:23\", \"1:27\", \"1:29\", \"1:30\", \"1:39\",\\n                \"1:43\", \"1:45\", \"1:46\", \"1:51\", \"1:53\", \"1:54\", \"1:57\", \"1:58\", \"2:15\", \"2:23\",\\n                \"2:27\", \"2:29\", \"2:30\", \"2:39\", \"2:43\", \"2:45\", \"2:46\", \"2:51\", \"2:53\", \"2:54\",\\n                \"2:57\", \"2:58\", \"3:07\", \"3:11\", \"3:13\", \"3:14\", \"3:19\", \"3:21\", \"3:22\", \"3:25\",\\n                \"3:26\", \"3:28\", \"3:35\", \"3:37\", \"3:38\", \"3:41\", \"3:42\", \"3:44\", \"3:49\", \"3:50\",\\n                \"3:52\", \"3:56\", \"4:15\", \"4:23\", \"4:27\", \"4:29\", \"4:30\", \"4:39\", \"4:43\", \"4:45\",\\n                \"4:46\", \"4:51\", \"4:53\", \"4:54\", \"4:57\", \"4:58\", \"5:07\", \"5:11\", \"5:13\", \"5:14\",\\n                \"5:19\", \"5:21\", \"5:22\", \"5:25\", \"5:26\", \"5:28\", \"5:35\", \"5:37\", \"5:38\", \"5:41\",\\n                \"5:42\", \"5:44\", \"5:49\", \"5:50\", \"5:52\", \"5:56\", \"6:07\", \"6:11\", \"6:13\", \"6:14\",\\n                \"6:19\", \"6:21\", \"6:22\", \"6:25\", \"6:26\", \"6:28\", \"6:35\", \"6:37\", \"6:38\", \"6:41\",\\n                \"6:42\", \"6:44\", \"6:49\", \"6:50\", \"6:52\", \"6:56\", \"7:03\", \"7:05\", \"7:06\", \"7:09\",\\n                \"7:10\", \"7:12\", \"7:17\", \"7:18\", \"7:20\", \"7:24\", \"7:33\", \"7:34\", \"7:36\", \"7:40\",\\n                \"7:48\", \"8:15\", \"8:23\", \"8:27\", \"8:29\", \"8:30\", \"8:39\", \"8:43\", \"8:45\", \"8:46\",\\n                \"8:51\", \"8:53\", \"8:54\", \"8:57\", \"8:58\", \"9:07\", \"9:11\", \"9:13\", \"9:14\", \"9:19\",\\n                \"9:21\", \"9:22\", \"9:25\", \"9:26\", \"9:28\", \"9:35\", \"9:37\", \"9:38\", \"9:41\", \"9:42\",\\n                \"9:44\", \"9:49\", \"9:50\", \"9:52\", \"9:56\", \"10:07\", \"10:11\", \"10:13\", \"10:14\",\\n                \"10:19\", \"10:21\", \"10:22\", \"10:25\", \"10:26\", \"10:28\", \"10:35\", \"10:37\", \"10:38\",\\n                \"10:41\", \"10:42\", \"10:44\", \"10:49\", \"10:50\", \"10:52\", \"10:56\", \"11:03\", \"11:05\",\\n                \"11:06\", \"11:09\", \"11:10\", \"11:12\", \"11:17\", \"11:18\", \"11:20\", \"11:24\", \"11:33\",\\n                \"11:34\", \"11:36\", \"11:40\", \"11:48\",\\n            ],\\n            vec![\\n                \"1:31\", \"1:47\", \"1:55\", \"1:59\", \"2:31\", \"2:47\", \"2:55\", \"2:59\", \"3:15\", \"3:23\",\\n                \"3:27\", \"3:29\", \"3:30\", \"3:39\", \"3:43\", \"3:45\", \"3:46\", \"3:51\", \"3:53\", \"3:54\",\\n                \"3:57\", \"3:58\", \"4:31\", \"4:47\", \"4:55\", \"4:59\", \"5:15\", \"5:23\", \"5:27\", \"5:29\",\\n                \"5:30\", \"5:39\", \"5:43\", \"5:45\", \"5:46\", \"5:51\", \"5:53\", \"5:54\", \"5:57\", \"5:58\",\\n                \"6:15\", \"6:23\", \"6:27\", \"6:29\", \"6:30\", \"6:39\", \"6:43\", \"6:45\", \"6:46\", \"6:51\",\\n                \"6:53\", \"6:54\", \"6:57\", \"6:58\", \"7:07\", \"7:11\", \"7:13\", \"7:14\", \"7:19\", \"7:21\",\\n                \"7:22\", \"7:25\", \"7:26\", \"7:28\", \"7:35\", \"7:37\", \"7:38\", \"7:41\", \"7:42\", \"7:44\",\\n                \"7:49\", \"7:50\", \"7:52\", \"7:56\", \"8:31\", \"8:47\", \"8:55\", \"8:59\", \"9:15\", \"9:23\",\\n                \"9:27\", \"9:29\", \"9:30\", \"9:39\", \"9:43\", \"9:45\", \"9:46\", \"9:51\", \"9:53\", \"9:54\",\\n                \"9:57\", \"9:58\", \"10:15\", \"10:23\", \"10:27\", \"10:29\", \"10:30\", \"10:39\", \"10:43\",\\n                \"10:45\", \"10:46\", \"10:51\", \"10:53\", \"10:54\", \"10:57\", \"10:58\", \"11:07\", \"11:11\",\\n                \"11:13\", \"11:14\", \"11:19\", \"11:21\", \"11:22\", \"11:25\", \"11:26\", \"11:28\", \"11:35\",\\n                \"11:37\", \"11:38\", \"11:41\", \"11:42\", \"11:44\", \"11:49\", \"11:50\", \"11:52\", \"11:56\",\\n            ],\\n            vec![\\n                \"3:31\", \"3:47\", \"3:55\", \"3:59\", \"5:31\", \"5:47\", \"5:55\", \"5:59\", \"6:31\", \"6:47\",\\n                \"6:55\", \"6:59\", \"7:15\", \"7:23\", \"7:27\", \"7:29\", \"7:30\", \"7:39\", \"7:43\", \"7:45\",\\n                \"7:46\", \"7:51\", \"7:53\", \"7:54\", \"7:57\", \"7:58\", \"9:31\", \"9:47\", \"9:55\", \"9:59\",\\n                \"10:31\", \"10:47\", \"10:55\", \"10:59\", \"11:15\", \"11:23\", \"11:27\", \"11:29\", \"11:30\",\\n                \"11:39\", \"11:43\", \"11:45\", \"11:46\", \"11:51\", \"11:53\", \"11:54\", \"11:57\", \"11:58\",\\n            ],\\n            vec![\\n                \"7:31\", \"7:47\", \"7:55\", \"7:59\", \"11:31\", \"11:47\", \"11:55\", \"11:59\",\\n            ],\\n            vec![],\\n            vec![],\\n        ]\\n    };\\n}\\n\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        A[turned_on as usize]\\n            .iter()\\n            .map(|&x| x.to_string())\\n            .collect()\\n    }\\n}\\n```\\n\\nIsn\\'t it beautiful?",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        (0i32..768)\\n            .filter(|&t| t.count_ones() as i32 == turned_on)\\n            .map(|t| (t / 64, t % 64))\\n            .filter(|(_, m)| m < &60)\\n            .map(|(h, m)| format!(\"{}:{:02}\", h, m))\\n            .collect()\\n    }\\n}\\n```\n```\\nlazy_static! {\\n    static ref A: Vec<Vec<&\\'static str>> = {\\n        vec![\\n            vec![\"0:00\"],\\n            vec![\\n                \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\", \"1:00\", \"2:00\", \"4:00\", \"8:00\",\\n            ],\\n            vec![\\n                \"0:03\", \"0:05\", \"0:06\", \"0:09\", \"0:10\", \"0:12\", \"0:17\", \"0:18\", \"0:20\", \"0:24\",\\n                \"0:33\", \"0:34\", \"0:36\", \"0:40\", \"0:48\", \"1:01\", \"1:02\", \"1:04\", \"1:08\", \"1:16\",\\n                \"1:32\", \"2:01\", \"2:02\", \"2:04\", \"2:08\", \"2:16\", \"2:32\", \"3:00\", \"4:01\", \"4:02\",\\n                \"4:04\", \"4:08\", \"4:16\", \"4:32\", \"5:00\", \"6:00\", \"8:01\", \"8:02\", \"8:04\", \"8:08\",\\n                \"8:16\", \"8:32\", \"9:00\", \"10:00\",\\n            ],\\n            vec![\\n                \"0:07\", \"0:11\", \"0:13\", \"0:14\", \"0:19\", \"0:21\", \"0:22\", \"0:25\", \"0:26\", \"0:28\",\\n                \"0:35\", \"0:37\", \"0:38\", \"0:41\", \"0:42\", \"0:44\", \"0:49\", \"0:50\", \"0:52\", \"0:56\",\\n                \"1:03\", \"1:05\", \"1:06\", \"1:09\", \"1:10\", \"1:12\", \"1:17\", \"1:18\", \"1:20\", \"1:24\",\\n                \"1:33\", \"1:34\", \"1:36\", \"1:40\", \"1:48\", \"2:03\", \"2:05\", \"2:06\", \"2:09\", \"2:10\",\\n                \"2:12\", \"2:17\", \"2:18\", \"2:20\", \"2:24\", \"2:33\", \"2:34\", \"2:36\", \"2:40\", \"2:48\",\\n                \"3:01\", \"3:02\", \"3:04\", \"3:08\", \"3:16\", \"3:32\", \"4:03\", \"4:05\", \"4:06\", \"4:09\",\\n                \"4:10\", \"4:12\", \"4:17\", \"4:18\", \"4:20\", \"4:24\", \"4:33\", \"4:34\", \"4:36\", \"4:40\",\\n                \"4:48\", \"5:01\", \"5:02\", \"5:04\", \"5:08\", \"5:16\", \"5:32\", \"6:01\", \"6:02\", \"6:04\",\\n                \"6:08\", \"6:16\", \"6:32\", \"7:00\", \"8:03\", \"8:05\", \"8:06\", \"8:09\", \"8:10\", \"8:12\",\\n                \"8:17\", \"8:18\", \"8:20\", \"8:24\", \"8:33\", \"8:34\", \"8:36\", \"8:40\", \"8:48\", \"9:01\",\\n                \"9:02\", \"9:04\", \"9:08\", \"9:16\", \"9:32\", \"10:01\", \"10:02\", \"10:04\", \"10:08\",\\n                \"10:16\", \"10:32\", \"11:00\",\\n            ],\\n            vec![\\n                \"0:15\", \"0:23\", \"0:27\", \"0:29\", \"0:30\", \"0:39\", \"0:43\", \"0:45\", \"0:46\", \"0:51\",\\n                \"0:53\", \"0:54\", \"0:57\", \"0:58\", \"1:07\", \"1:11\", \"1:13\", \"1:14\", \"1:19\", \"1:21\",\\n                \"1:22\", \"1:25\", \"1:26\", \"1:28\", \"1:35\", \"1:37\", \"1:38\", \"1:41\", \"1:42\", \"1:44\",\\n                \"1:49\", \"1:50\", \"1:52\", \"1:56\", \"2:07\", \"2:11\", \"2:13\", \"2:14\", \"2:19\", \"2:21\",\\n                \"2:22\", \"2:25\", \"2:26\", \"2:28\", \"2:35\", \"2:37\", \"2:38\", \"2:41\", \"2:42\", \"2:44\",\\n                \"2:49\", \"2:50\", \"2:52\", \"2:56\", \"3:03\", \"3:05\", \"3:06\", \"3:09\", \"3:10\", \"3:12\",\\n                \"3:17\", \"3:18\", \"3:20\", \"3:24\", \"3:33\", \"3:34\", \"3:36\", \"3:40\", \"3:48\", \"4:07\",\\n                \"4:11\", \"4:13\", \"4:14\", \"4:19\", \"4:21\", \"4:22\", \"4:25\", \"4:26\", \"4:28\", \"4:35\",\\n                \"4:37\", \"4:38\", \"4:41\", \"4:42\", \"4:44\", \"4:49\", \"4:50\", \"4:52\", \"4:56\", \"5:03\",\\n                \"5:05\", \"5:06\", \"5:09\", \"5:10\", \"5:12\", \"5:17\", \"5:18\", \"5:20\", \"5:24\", \"5:33\",\\n                \"5:34\", \"5:36\", \"5:40\", \"5:48\", \"6:03\", \"6:05\", \"6:06\", \"6:09\", \"6:10\", \"6:12\",\\n                \"6:17\", \"6:18\", \"6:20\", \"6:24\", \"6:33\", \"6:34\", \"6:36\", \"6:40\", \"6:48\", \"7:01\",\\n                \"7:02\", \"7:04\", \"7:08\", \"7:16\", \"7:32\", \"8:07\", \"8:11\", \"8:13\", \"8:14\", \"8:19\",\\n                \"8:21\", \"8:22\", \"8:25\", \"8:26\", \"8:28\", \"8:35\", \"8:37\", \"8:38\", \"8:41\", \"8:42\",\\n                \"8:44\", \"8:49\", \"8:50\", \"8:52\", \"8:56\", \"9:03\", \"9:05\", \"9:06\", \"9:09\", \"9:10\",\\n                \"9:12\", \"9:17\", \"9:18\", \"9:20\", \"9:24\", \"9:33\", \"9:34\", \"9:36\", \"9:40\", \"9:48\",\\n                \"10:03\", \"10:05\", \"10:06\", \"10:09\", \"10:10\", \"10:12\", \"10:17\", \"10:18\", \"10:20\",\\n                \"10:24\", \"10:33\", \"10:34\", \"10:36\", \"10:40\", \"10:48\", \"11:01\", \"11:02\", \"11:04\",\\n                \"11:08\", \"11:16\", \"11:32\",\\n            ],\\n            vec![\\n                \"0:31\", \"0:47\", \"0:55\", \"0:59\", \"1:15\", \"1:23\", \"1:27\", \"1:29\", \"1:30\", \"1:39\",\\n                \"1:43\", \"1:45\", \"1:46\", \"1:51\", \"1:53\", \"1:54\", \"1:57\", \"1:58\", \"2:15\", \"2:23\",\\n                \"2:27\", \"2:29\", \"2:30\", \"2:39\", \"2:43\", \"2:45\", \"2:46\", \"2:51\", \"2:53\", \"2:54\",\\n                \"2:57\", \"2:58\", \"3:07\", \"3:11\", \"3:13\", \"3:14\", \"3:19\", \"3:21\", \"3:22\", \"3:25\",\\n                \"3:26\", \"3:28\", \"3:35\", \"3:37\", \"3:38\", \"3:41\", \"3:42\", \"3:44\", \"3:49\", \"3:50\",\\n                \"3:52\", \"3:56\", \"4:15\", \"4:23\", \"4:27\", \"4:29\", \"4:30\", \"4:39\", \"4:43\", \"4:45\",\\n                \"4:46\", \"4:51\", \"4:53\", \"4:54\", \"4:57\", \"4:58\", \"5:07\", \"5:11\", \"5:13\", \"5:14\",\\n                \"5:19\", \"5:21\", \"5:22\", \"5:25\", \"5:26\", \"5:28\", \"5:35\", \"5:37\", \"5:38\", \"5:41\",\\n                \"5:42\", \"5:44\", \"5:49\", \"5:50\", \"5:52\", \"5:56\", \"6:07\", \"6:11\", \"6:13\", \"6:14\",\\n                \"6:19\", \"6:21\", \"6:22\", \"6:25\", \"6:26\", \"6:28\", \"6:35\", \"6:37\", \"6:38\", \"6:41\",\\n                \"6:42\", \"6:44\", \"6:49\", \"6:50\", \"6:52\", \"6:56\", \"7:03\", \"7:05\", \"7:06\", \"7:09\",\\n                \"7:10\", \"7:12\", \"7:17\", \"7:18\", \"7:20\", \"7:24\", \"7:33\", \"7:34\", \"7:36\", \"7:40\",\\n                \"7:48\", \"8:15\", \"8:23\", \"8:27\", \"8:29\", \"8:30\", \"8:39\", \"8:43\", \"8:45\", \"8:46\",\\n                \"8:51\", \"8:53\", \"8:54\", \"8:57\", \"8:58\", \"9:07\", \"9:11\", \"9:13\", \"9:14\", \"9:19\",\\n                \"9:21\", \"9:22\", \"9:25\", \"9:26\", \"9:28\", \"9:35\", \"9:37\", \"9:38\", \"9:41\", \"9:42\",\\n                \"9:44\", \"9:49\", \"9:50\", \"9:52\", \"9:56\", \"10:07\", \"10:11\", \"10:13\", \"10:14\",\\n                \"10:19\", \"10:21\", \"10:22\", \"10:25\", \"10:26\", \"10:28\", \"10:35\", \"10:37\", \"10:38\",\\n                \"10:41\", \"10:42\", \"10:44\", \"10:49\", \"10:50\", \"10:52\", \"10:56\", \"11:03\", \"11:05\",\\n                \"11:06\", \"11:09\", \"11:10\", \"11:12\", \"11:17\", \"11:18\", \"11:20\", \"11:24\", \"11:33\",\\n                \"11:34\", \"11:36\", \"11:40\", \"11:48\",\\n            ],\\n            vec![\\n                \"1:31\", \"1:47\", \"1:55\", \"1:59\", \"2:31\", \"2:47\", \"2:55\", \"2:59\", \"3:15\", \"3:23\",\\n                \"3:27\", \"3:29\", \"3:30\", \"3:39\", \"3:43\", \"3:45\", \"3:46\", \"3:51\", \"3:53\", \"3:54\",\\n                \"3:57\", \"3:58\", \"4:31\", \"4:47\", \"4:55\", \"4:59\", \"5:15\", \"5:23\", \"5:27\", \"5:29\",\\n                \"5:30\", \"5:39\", \"5:43\", \"5:45\", \"5:46\", \"5:51\", \"5:53\", \"5:54\", \"5:57\", \"5:58\",\\n                \"6:15\", \"6:23\", \"6:27\", \"6:29\", \"6:30\", \"6:39\", \"6:43\", \"6:45\", \"6:46\", \"6:51\",\\n                \"6:53\", \"6:54\", \"6:57\", \"6:58\", \"7:07\", \"7:11\", \"7:13\", \"7:14\", \"7:19\", \"7:21\",\\n                \"7:22\", \"7:25\", \"7:26\", \"7:28\", \"7:35\", \"7:37\", \"7:38\", \"7:41\", \"7:42\", \"7:44\",\\n                \"7:49\", \"7:50\", \"7:52\", \"7:56\", \"8:31\", \"8:47\", \"8:55\", \"8:59\", \"9:15\", \"9:23\",\\n                \"9:27\", \"9:29\", \"9:30\", \"9:39\", \"9:43\", \"9:45\", \"9:46\", \"9:51\", \"9:53\", \"9:54\",\\n                \"9:57\", \"9:58\", \"10:15\", \"10:23\", \"10:27\", \"10:29\", \"10:30\", \"10:39\", \"10:43\",\\n                \"10:45\", \"10:46\", \"10:51\", \"10:53\", \"10:54\", \"10:57\", \"10:58\", \"11:07\", \"11:11\",\\n                \"11:13\", \"11:14\", \"11:19\", \"11:21\", \"11:22\", \"11:25\", \"11:26\", \"11:28\", \"11:35\",\\n                \"11:37\", \"11:38\", \"11:41\", \"11:42\", \"11:44\", \"11:49\", \"11:50\", \"11:52\", \"11:56\",\\n            ],\\n            vec![\\n                \"3:31\", \"3:47\", \"3:55\", \"3:59\", \"5:31\", \"5:47\", \"5:55\", \"5:59\", \"6:31\", \"6:47\",\\n                \"6:55\", \"6:59\", \"7:15\", \"7:23\", \"7:27\", \"7:29\", \"7:30\", \"7:39\", \"7:43\", \"7:45\",\\n                \"7:46\", \"7:51\", \"7:53\", \"7:54\", \"7:57\", \"7:58\", \"9:31\", \"9:47\", \"9:55\", \"9:59\",\\n                \"10:31\", \"10:47\", \"10:55\", \"10:59\", \"11:15\", \"11:23\", \"11:27\", \"11:29\", \"11:30\",\\n                \"11:39\", \"11:43\", \"11:45\", \"11:46\", \"11:51\", \"11:53\", \"11:54\", \"11:57\", \"11:58\",\\n            ],\\n            vec![\\n                \"7:31\", \"7:47\", \"7:55\", \"7:59\", \"11:31\", \"11:47\", \"11:55\", \"11:59\",\\n            ],\\n            vec![],\\n            vec![],\\n        ]\\n    };\\n}\\n\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        A[turned_on as usize]\\n            .iter()\\n            .map(|&x| x.to_string())\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587215,
                "title": "c-solution",
                "content": "Since the watch is in binary, H can be represented with 4 bits, namely 0000 - 1011 to represent 0-11 and M can be represented with 6 bits, namely 000000 - 111011 to represent 0-59. We can use two for loops to loop through every possible combination of the binary combination from 00:00 to 11:59.  In order to count the bits in any combination of time, we can use bitset data structure to convert decimals to binary and the size of the bitset should be 10 (4 + 6). To efficiently store the bits, we can left shift (<<) 6 bits for H and binary OR (|) it with M to combine the 10 bits.\\n\\nThe time complexity of the O(12* 60) = O(1).\\n\\n```\\nvector<string> readBinaryWatch(int turnedOn) {\\n\\tvector<string> res;\\n\\tfor (int h = 0; h < 12; h++) {\\n\\t\\tfor (int m = 0; m < 60; m++) {\\n\\t\\t\\tbitset<10> b(h << 6 | m);\\n\\t\\t\\tif (b.count() == turnedOn) {\\n\\t\\t\\t\\tstring hour = to_string(h), min = m < 10 ? \"0\" + to_string(m) : to_string(m);\\n\\t\\t\\t\\tres.push_back(hour + \":\" + min);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> readBinaryWatch(int turnedOn) {\\n\\tvector<string> res;\\n\\tfor (int h = 0; h < 12; h++) {\\n\\t\\tfor (int m = 0; m < 60; m++) {\\n\\t\\t\\tbitset<10> b(h << 6 | m);\\n\\t\\t\\tif (b.count() == turnedOn) {\\n\\t\\t\\t\\tstring hour = to_string(h), min = m < 10 ? \"0\" + to_string(m) : to_string(m);\\n\\t\\t\\t\\tres.push_back(hour + \":\" + min);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1553898,
                "title": "pre-compute-mappings-from-bits-hours-minutes",
                "content": "If you follow the advice of the second hint, the solution is quite straightforward.\\n\\n```\\nconst bitsToHours = {\\n  0: [0],\\n  1: [1, 2, 4, 8],\\n  2: [3, 5, 6, 9, 10],\\n  3: [7, 11],\\n};\\n\\nconst bitsToMinutes = {\\n  0: [0],\\n  1: [1, 2, 4, 8, 16, 32],\\n  2: [3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 33, 34, 36, 40, 48],\\n  3: [\\n    7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 35, 37, 38, 41, 42, 44, 49, 50, 52,\\n    56,\\n  ],\\n  4: [15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58],\\n  5: [31, 47, 55, 59],\\n};\\n\\nfunction readBinaryWatch(turnedOn) {\\n  const solutions = [];\\n\\n  for (let i = 0; i <= turnedOn; i++) {\\n    const hours = bitsToHours[i] ?? [];\\n    const minutes = bitsToMinutes[turnedOn - i] ?? [];\\n\\n    for (const hour of hours) {\\n      for (const minute of minutes) {\\n        solutions.push(`${hour}:${String(minute).padStart(2, \\'0\\')}`);\\n      }\\n    }\\n  }\\n\\n  return solutions;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst bitsToHours = {\\n  0: [0],\\n  1: [1, 2, 4, 8],\\n  2: [3, 5, 6, 9, 10],\\n  3: [7, 11],\\n};\\n\\nconst bitsToMinutes = {\\n  0: [0],\\n  1: [1, 2, 4, 8, 16, 32],\\n  2: [3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 33, 34, 36, 40, 48],\\n  3: [\\n    7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 35, 37, 38, 41, 42, 44, 49, 50, 52,\\n    56,\\n  ],\\n  4: [15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58],\\n  5: [31, 47, 55, 59],\\n};\\n\\nfunction readBinaryWatch(turnedOn) {\\n  const solutions = [];\\n\\n  for (let i = 0; i <= turnedOn; i++) {\\n    const hours = bitsToHours[i] ?? [];\\n    const minutes = bitsToMinutes[turnedOn - i] ?? [];\\n\\n    for (const hour of hours) {\\n      for (const minute of minutes) {\\n        solutions.push(`${hour}:${String(minute).padStart(2, \\'0\\')}`);\\n      }\\n    }\\n  }\\n\\n  return solutions;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1236313,
                "title": "python-by-checking-the-number-of-bits-used-by-all-possible-hh-mm",
                "content": "spelling it out\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n      result = []\\n      for hour in range(12):\\n        for minute in range(60):\\n          hour_bits = bin(hour)[2:].count(\"1\")\\n          minute_bits = bin(minute)[2:].count(\"1\")\\n          if hour_bits + minute_bits == turnedOn:\\n            result.append(f\"{hour}:{minute:02}\")\\n      return result\\n```\\n or this could be a single expression\\n ```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n      return [f\"{hour}:{minute:02}\"\\n              for hour in range(12)\\n              for minute in range(60)\\n              if bin(hour)[2:].count(\"1\") + bin(minute)[2:].count(\"1\") == turnedOn]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n      result = []\\n      for hour in range(12):\\n        for minute in range(60):\\n          hour_bits = bin(hour)[2:].count(\"1\")\\n          minute_bits = bin(minute)[2:].count(\"1\")\\n          if hour_bits + minute_bits == turnedOn:\\n            result.append(f\"{hour}:{minute:02}\")\\n      return result\\n```\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n      return [f\"{hour}:{minute:02}\"\\n              for hour in range(12)\\n              for minute in range(60)\\n              if bin(hour)[2:].count(\"1\") + bin(minute)[2:].count(\"1\") == turnedOn]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146604,
                "title": "easy-python-solution-90-faster",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        arr = []\\n        for i in range(0,12):\\n            for j in range(0,60):\\n                a = bin(i).count(\"1\")\\n                b = bin(j).count(\"1\")\\n                summ = a+b\\n\\n                if summ == num:\\n                    arr.append(f\\'{i}:{j:02d}\\')\\n                    \\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        arr = []\\n        for i in range(0,12):\\n            for j in range(0,60):\\n                a = bin(i).count(\"1\")\\n                b = bin(j).count(\"1\")\\n                summ = a+b\\n\\n                if summ == num:\\n                    arr.append(f\\'{i}:{j:02d}\\')\\n                    \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035433,
                "title": "c-solution-beats-100",
                "content": "This solution iterates through all numbers that are 10 bits long and uses those with the specified number of 1 bits as a solution.\\nBit manipulation helps check the presence of 1 bits efficiently.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> times;\\n        for (int i = 0; i < pow(2, 10); i++) {\\n            uint32_t temp = i;\\n            int numOnes = 0;\\n            while (temp > 0) {\\n                if (temp & 1) {\\n                    numOnes++;\\n                }\\n                temp>>=1;\\n            }\\n            if (numOnes == num) \\n                bitsToTime(i, times);\\n        }\\n        return times;\\n    }\\n    \\n    void bitsToTime(int num, vector<string>& answer) {\\n        int hour = 0, minutes = 0;\\n        for (int i = 0; i < 4; i++) {\\n            if (num & 1)\\n                hour += pow(2, i);\\n            num >>=  1;\\n        }\\n        if (hour >= 12)\\n            return;\\n        for (int i = 0; i < 6; i++) {\\n            if (num & 1)\\n                minutes += pow(2, i);\\n            num >>=  1;\\n        }\\n        if (minutes >= 60)\\n            return;\\n        //make the string \\n        string time = to_string(hour) + \":\";\\n        time += minutes < 10 ? \"0\" + to_string(minutes) : to_string(minutes);\\n        answer.push_back(time);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> times;\\n        for (int i = 0; i < pow(2, 10); i++) {\\n            uint32_t temp = i;\\n            int numOnes = 0;\\n            while (temp > 0) {\\n                if (temp & 1) {\\n                    numOnes++;\\n                }\\n                temp>>=1;\\n            }\\n            if (numOnes == num) \\n                bitsToTime(i, times);\\n        }\\n        return times;\\n    }\\n    \\n    void bitsToTime(int num, vector<string>& answer) {\\n        int hour = 0, minutes = 0;\\n        for (int i = 0; i < 4; i++) {\\n            if (num & 1)\\n                hour += pow(2, i);\\n            num >>=  1;\\n        }\\n        if (hour >= 12)\\n            return;\\n        for (int i = 0; i < 6; i++) {\\n            if (num & 1)\\n                minutes += pow(2, i);\\n            num >>=  1;\\n        }\\n        if (minutes >= 60)\\n            return;\\n        //make the string \\n        string time = to_string(hour) + \":\";\\n        time += minutes < 10 ? \"0\" + to_string(minutes) : to_string(minutes);\\n        answer.push_back(time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016522,
                "title": "c-simple-and-straightforward",
                "content": "I\\'m surprised that most of the solutions here are quite long/complicated (with exceptions of some Pyhton few-liners), maybe I\\'m missing the point of the task. In any case, this solution here simply loops trough the whole range (0..1023) of nums which can be represented with 10 bits and checks which ones can be represented with a given number of bits..100% mem and time, if that means anything.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool hasNumBits(int num, int numBits)\\n    {\\n        int currNumBits = 0;\\n        for(int i = 0; i < 10; i++)\\n        {\\n            if(num & 1) currNumBits++;\\n            num >>= 1;\\n        }\\n         \\n        if(currNumBits == numBits) return true;\\n        else return false;\\n    }\\n    \\n    vector<string> readBinaryWatch(int num) \\n    {\\n        vector<string> res;\\n        \\n        for(int i = 0; i < 1024; i++)\\n        {\\n            if(!hasNumBits(i, num)) continue;\\n            \\n            int hours =   (i & 0b1111000000) >> 6;\\n            int minutes = (i & 0b0000111111);\\n            \\n            if(hours > 11 or minutes > 59) continue;\\n            \\n            string hoursS = to_string(hours);\\n            string minutesS = to_string(minutes);\\n            if(minutesS.length() == 1) minutesS = \"0\" + minutesS;\\n            \\n            res.push_back(hoursS + \":\" + minutesS);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool hasNumBits(int num, int numBits)\\n    {\\n        int currNumBits = 0;\\n        for(int i = 0; i < 10; i++)\\n        {\\n            if(num & 1) currNumBits++;\\n            num >>= 1;\\n        }\\n         \\n        if(currNumBits == numBits) return true;\\n        else return false;\\n    }\\n    \\n    vector<string> readBinaryWatch(int num) \\n    {\\n        vector<string> res;\\n        \\n        for(int i = 0; i < 1024; i++)\\n        {\\n            if(!hasNumBits(i, num)) continue;\\n            \\n            int hours =   (i & 0b1111000000) >> 6;\\n            int minutes = (i & 0b0000111111);\\n            \\n            if(hours > 11 or minutes > 59) continue;\\n            \\n            string hoursS = to_string(hours);\\n            string minutesS = to_string(minutes);\\n            if(minutesS.length() == 1) minutesS = \"0\" + minutesS;\\n            \\n            res.push_back(hoursS + \":\" + minutesS);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895112,
                "title": "python-simple",
                "content": "```\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \\n        res = []\\n        for i in range(0, 12):\\n            for j in range(0, 60):\\n                if  (bin(i)+bin(j)).count(\\'1\\') == num:\\n                    res.append(\\'%d:%02d\\'%(i,j))\\n        return res           \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \\n        res = []\\n        for i in range(0, 12):\\n            for j in range(0, 60):\\n                if  (bin(i)+bin(j)).count(\\'1\\') == num:\\n                    res.append(\\'%d:%02d\\'%(i,j))\\n        return res           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 839839,
                "title": "js-100",
                "content": "```\\nconst pop = n => n ? ( 1 & n ) + pop( n >> 1 ) : 0\\nconst hours = Array.from( { length: 4 }, _ => [] )\\nconst mins  = Array.from( { length: 6 }, _ => [] )\\n\\nfor ( let i = 0; i < 12; i++ ) hours[ pop( i ) ].push( i )\\nfor ( let i = 0; i < 60; i++ ) mins[ pop( i ) ].push( String( i ).padStart( 2, 0 ) )\\n\\nvar readBinaryWatch = function(num) {\\n    const times = []\\n\\n    for ( let i = 0; i <= num; i++ ) {\\n        let h = hours[ i ]\\n        let m = mins[ num - i ]\\n\\n        if ( h && m ) {\\n            h.forEach( hh => {\\n                m.forEach( mm => {\\n                    times.push( hh + \\':\\' + mm )\\n                })\\n            })\\n        }\\n    }\\n    \\n    return times\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst pop = n => n ? ( 1 & n ) + pop( n >> 1 ) : 0\\nconst hours = Array.from( { length: 4 }, _ => [] )\\nconst mins  = Array.from( { length: 6 }, _ => [] )\\n\\nfor ( let i = 0; i < 12; i++ ) hours[ pop( i ) ].push( i )\\nfor ( let i = 0; i < 60; i++ ) mins[ pop( i ) ].push( String( i ).padStart( 2, 0 ) )\\n\\nvar readBinaryWatch = function(num) {\\n    const times = []\\n\\n    for ( let i = 0; i <= num; i++ ) {\\n        let h = hours[ i ]\\n        let m = mins[ num - i ]\\n\\n        if ( h && m ) {\\n            h.forEach( hh => {\\n                m.forEach( mm => {\\n                    times.push( hh + \\':\\' + mm )\\n                })\\n            })\\n        }\\n    }\\n    \\n    return times\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747522,
                "title": "java-solution-backtracking-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> list = new ArrayList<>();\\n        int[] time = new int[]{1,2,4,8,1,2,4,8,16,32};\\n        readBinaryWatch(list, 0, 0, 0, num, time);\\n        return list;\\n    }\\n    private void readBinaryWatch(List<String> list,\\n                                 int start,\\n                                 int hour,\\n                                 int minute,\\n                                 int num,\\n                                 int[] time){\\n        if(num == 0){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(hour).append(\":\");\\n            if(minute < 10){\\n                sb.append(0);\\n            }\\n            sb.append(minute);\\n            list.add(sb.toString());\\n        }else{\\n            for(int i = start; i < time.length; i++){\\n                int nowHour = hour;\\n                int nowMinute = minute;\\n                if(isHour(i)){\\n                    nowHour += time[i];\\n                }else{\\n                    nowMinute += time[i];\\n                }\\n                if(nowHour <= 11 && nowMinute <= 59){\\n                    readBinaryWatch(list, i + 1, nowHour, nowMinute, num - 1, time);\\n                }\\n            }\\n        }\\n        \\n    }\\n    private boolean isHour(int position){\\n        return position < 4 ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> list = new ArrayList<>();\\n        int[] time = new int[]{1,2,4,8,1,2,4,8,16,32};\\n        readBinaryWatch(list, 0, 0, 0, num, time);\\n        return list;\\n    }\\n    private void readBinaryWatch(List<String> list,\\n                                 int start,\\n                                 int hour,\\n                                 int minute,\\n                                 int num,\\n                                 int[] time){\\n        if(num == 0){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(hour).append(\":\");\\n            if(minute < 10){\\n                sb.append(0);\\n            }\\n            sb.append(minute);\\n            list.add(sb.toString());\\n        }else{\\n            for(int i = start; i < time.length; i++){\\n                int nowHour = hour;\\n                int nowMinute = minute;\\n                if(isHour(i)){\\n                    nowHour += time[i];\\n                }else{\\n                    nowMinute += time[i];\\n                }\\n                if(nowHour <= 11 && nowMinute <= 59){\\n                    readBinaryWatch(list, i + 1, nowHour, nowMinute, num - 1, time);\\n                }\\n            }\\n        }\\n        \\n    }\\n    private boolean isHour(int position){\\n        return position < 4 ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738371,
                "title": "simple-c-solution-beats-100",
                "content": "```\\n// godfather_rana\\n\\nclass Solution {\\npublic:\\n    int bit_count(int n){\\n        int ans = 0; \\n        while(n){\\n            if(n&1)\\n                ans++;\\n            n = n >> 1; \\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> ans;\\n        \\n        int n = 1023;\\n        \\n        for(int i = 0 ; i <= n ; i++){\\n            int c = bit_count(i);\\n            if(c == num){\\n                int mi = i & 63;\\n                int hr = 15 << 6;\\n                hr = hr & i; \\n                hr = hr >> 6;\\n                if(hr < 12 && mi < 60)\\n                    ans.push_back(to_string(hr)+(mi < 10 ? \":0\" : \":\")+to_string(mi));\\n                cout << i << \" \";\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// godfather_rana\\n\\nclass Solution {\\npublic:\\n    int bit_count(int n){\\n        int ans = 0; \\n        while(n){\\n            if(n&1)\\n                ans++;\\n            n = n >> 1; \\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> ans;\\n        \\n        int n = 1023;\\n        \\n        for(int i = 0 ; i <= n ; i++){\\n            int c = bit_count(i);\\n            if(c == num){\\n                int mi = i & 63;\\n                int hr = 15 << 6;\\n                hr = hr & i; \\n                hr = hr >> 6;\\n                if(hr < 12 && mi < 60)\\n                    ans.push_back(to_string(hr)+(mi < 10 ? \":0\" : \":\")+to_string(mi));\\n                cout << i << \" \";\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 694020,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public List<String> readBinaryWatch(int num) {\\n        List<String> times = new ArrayList<>();\\n        for (int h=0; h<12; h++)\\n            for (int m=0; m<60; m++)\\n                if (Integer.bitCount(h * 64 + m) == num)\\n                    times.add(String.format(\"%d:%02d\", h, m));\\n        return times;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public List<String> readBinaryWatch(int num) {\\n        List<String> times = new ArrayList<>();\\n        for (int h=0; h<12; h++)\\n            for (int m=0; m<60; m++)\\n                if (Integer.bitCount(h * 64 + m) == num)\\n                    times.add(String.format(\"%d:%02d\", h, m));\\n        return times;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622577,
                "title": "cpp-bitset-inspired-100-faster-and-100-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> ans;\\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<60;j++){\\n                if(num==bitset<10>((i<<6)+j).count()){\\n                    char tmp[10];\\n                    sprintf(tmp,\"%d:%02d\",i,j);\\n                    ans.push_back(tmp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> ans;\\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<60;j++){\\n                if(num==bitset<10>((i<<6)+j).count()){\\n                    char tmp[10];\\n                    sprintf(tmp,\"%d:%02d\",i,j);\\n                    ans.push_back(tmp);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593075,
                "title": "c-short-100-sc-100-tc-using-bitset",
                "content": "Using @mzchen solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        for(int h = 0;h<12;h++) {\\n            for(int m = 0;m<60;m++) {\\n                if(bitset<10>(h<<6 | m).count() == num) { // rightmost 6 bits for minutes and left bits for hour.\\n                    res.push_back(to_string(h) + (m<10? \":0\":\":\") + to_string(m));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        for(int h = 0;h<12;h++) {\\n            for(int m = 0;m<60;m++) {\\n                if(bitset<10>(h<<6 | m).count() == num) { // rightmost 6 bits for minutes and left bits for hour.\\n                    res.push_back(to_string(h) + (m<10? \":0\":\":\") + to_string(m));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568232,
                "title": "java-simplest-easy-to-understand-naive-straightforward",
                "content": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        if(num < 0 || num > 8) return res;\\n\\n        for(int i = 0; i < 12; i++){\\n            String hour = Integer.toString(i);\\n            for(int j = 0; j < 60; j++){\\n                if(Integer.bitCount(i) + Integer.bitCount(j) == num){\\n                    String minute = j < 10 ? \"0\"+Integer.toString(j) : Integer.toString(j);\\n                    res.add(hour+\":\"+minute);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        if(num < 0 || num > 8) return res;\\n\\n        for(int i = 0; i < 12; i++){\\n            String hour = Integer.toString(i);\\n            for(int j = 0; j < 60; j++){\\n                if(Integer.bitCount(i) + Integer.bitCount(j) == num){\\n                    String minute = j < 10 ? \"0\"+Integer.toString(j) : Integer.toString(j);\\n                    res.add(hour+\":\"+minute);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482962,
                "title": "c-solution-with-explanation-bitwise-selection",
                "content": "There are 10 LEDs in total. (4 for hours and 6 for minutes). Let us represent this 10 LEDs using a 10bit binary number whereby the 4 most significant bits denote the hours and the remaining 6 bits denoting the minutes.\\n\\nFor eg\\n\\n0000 100001     denotes that hour = 0000 and minutes = 100001\\nThis binary number is 33 in decimal system.\\n\\nUsing this representation it is evident that the highest possible binary number of 10 bits is 1111111111 which is 1023 in decimal. \\n\\nHence we run a loop from 0 to 1023. In each iteration we use a helper function to count the number of set bits(bits with value = 1) in the value of loop counter. The set bit count of loop counter should be exactly equal to the input num since we want to consider only those possibilities whereby input num is the number of lighted LEDs. Eg if input num = 2, 0000 100001 and 1000 100000 are some possibilities with 2 set bits.\\n\\nThen we seperate the first 4 bits and last 6 bits of loop counter and convert them to string and add to the output array. Make sure to skip hours > 11 and minutes > 59 .\\n\\nNB: For a 10 bit number such as 1111 000000, i>>6 (Right shift by 6 units) will give 000000 1111 which is the number of hours. Similarly suppose number is 0000 110011, i&63 will give last 6 bits of the number as 63 in binary is (0000 111111) and the bitwise AND will make the bits for hours as zero.\\n\\n\\n\\n\\tint countSetBits(int n){\\n\\t\\tint ct = 0;\\n\\t\\twhile(n != 0){\\n\\t\\t\\tif(1&n)\\n\\t\\t\\t\\tct++;\\n\\t\\t\\tn = n>>1;\\n\\t\\t}\\n\\t\\treturn ct;\\n\\t}\\n\\n\\n\\tvector<string> readBinaryWatch(int num) {\\n\\t\\tif(num == 0) return {\"0:00\"};\\n\\n\\t\\tint hoursBinary,minutesBinary;\\n\\t\\tvector<string> res;\\n\\n\\t\\tfor(int i=0;i<1024;i++){\\n\\t\\t\\tif(countSetBits(i) != num)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\thoursBinary = i>>6;\\n\\t\\t\\tminutesBinary = (i&63);\\n\\n\\t\\t\\tif(hoursBinary > 11 || minutesBinary > 59)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t//Adding to result vector\\n\\t\\t\\tstring time;\\n\\n\\t\\t\\tif(minutesBinary > 9)\\n\\t\\t\\t\\ttime = \"\" + to_string(hoursBinary) + \":\" + to_string(minutesBinary);\\n\\t\\t\\telse\\n\\t\\t\\t\\ttime = \"\" + to_string(hoursBinary) + \":0\" + to_string(minutesBinary);\\n\\n\\t\\t\\tres.push_back(time);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\n\\t}\\n\\n\\n",
                "solutionTags": [],
                "code": "There are 10 LEDs in total. (4 for hours and 6 for minutes). Let us represent this 10 LEDs using a 10bit binary number whereby the 4 most significant bits denote the hours and the remaining 6 bits denoting the minutes.\\n\\nFor eg\\n\\n0000 100001     denotes that hour = 0000 and minutes = 100001\\nThis binary number is 33 in decimal system.\\n\\nUsing this representation it is evident that the highest possible binary number of 10 bits is 1111111111 which is 1023 in decimal. \\n\\nHence we run a loop from 0 to 1023. In each iteration we use a helper function to count the number of set bits(bits with value = 1) in the value of loop counter. The set bit count of loop counter should be exactly equal to the input num since we want to consider only those possibilities whereby input num is the number of lighted LEDs. Eg if input num = 2, 0000 100001 and 1000 100000 are some possibilities with 2 set bits.\\n\\nThen we seperate the first 4 bits and last 6 bits of loop counter and convert them to string and add to the output array. Make sure to skip hours > 11 and minutes > 59 .\\n\\nNB: For a 10 bit number such as 1111 000000, i>>6 (Right shift by 6 units) will give 000000 1111 which is the number of hours. Similarly suppose number is 0000 110011, i&63 will give last 6 bits of the number as 63 in binary is (0000 111111) and the bitwise AND will make the bits for hours as zero.\\n\\n\\n\\n\\tint countSetBits(int n){\\n\\t\\tint ct = 0;\\n\\t\\twhile(n != 0){\\n\\t\\t\\tif(1&n)\\n\\t\\t\\t\\tct++;\\n\\t\\t\\tn = n>>1;\\n\\t\\t}\\n\\t\\treturn ct;\\n\\t}\\n\\n\\n\\tvector<string> readBinaryWatch(int num) {\\n\\t\\tif(num == 0) return {\"0:00\"};\\n\\n\\t\\tint hoursBinary,minutesBinary;\\n\\t\\tvector<string> res;\\n\\n\\t\\tfor(int i=0;i<1024;i++){\\n\\t\\t\\tif(countSetBits(i) != num)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\thoursBinary = i>>6;\\n\\t\\t\\tminutesBinary = (i&63);\\n\\n\\t\\t\\tif(hoursBinary > 11 || minutesBinary > 59)\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t//Adding to result vector\\n\\t\\t\\tstring time;\\n\\n\\t\\t\\tif(minutesBinary > 9)\\n\\t\\t\\t\\ttime = \"\" + to_string(hoursBinary) + \":\" + to_string(minutesBinary);\\n\\t\\t\\telse\\n\\t\\t\\t\\ttime = \"\" + to_string(hoursBinary) + \":0\" + to_string(minutesBinary);\\n\\n\\t\\t\\tres.push_back(time);\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\n\\t}\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 433627,
                "title": "c-100-time-with-memoised-pre-computed-base-combos",
                "content": "There it is:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static std::unordered_map<int, std::vector<int>> bits;\\n    vector<string> readBinaryWatch(int n) {\\n        std::vector<string> res;\\n        for (int i = 0; i <= n; i++){\\n            for (auto h: bits[i]) {\\n                if (h > 11) continue;\\n                for (auto m: bits[n - i]) {\\n                    res.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nstd::unordered_map<int, std::vector<int>> Solution::bits = {{0, {0}}, {1, {1, 2, 4, 8, 16, 32}}, {2, {3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 33, 34, 36, 40, 48}}, {3, {7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 35, 37, 38, 41, 42, 44, 49, 50, 52, 56}}, {4, {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58}},{5, {31, 47, 55, 59}}};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    static std::unordered_map<int, std::vector<int>> bits;\\n    vector<string> readBinaryWatch(int n) {\\n        std::vector<string> res;\\n        for (int i = 0; i <= n; i++){\\n            for (auto h: bits[i]) {\\n                if (h > 11) continue;\\n                for (auto m: bits[n - i]) {\\n                    res.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nstd::unordered_map<int, std::vector<int>> Solution::bits = {{0, {0}}, {1, {1, 2, 4, 8, 16, 32}}, {2, {3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 33, 34, 36, 40, 48}}, {3, {7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 35, 37, 38, 41, 42, 44, 49, 50, 52, 56}}, {4, {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58}},{5, {31, 47, 55, 59}}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431320,
                "title": "readable-python-backtracking",
                "content": "Not meant to be the most concise code but the most readable. Not skipping any step.\\n```\\nclass Solution:\\n    def readBinaryWatch(self, num):\\n        minutes = [1, 2, 4, 8, 16, 32]\\n        hours = [1, 2, 4, 8]\\n        ans = []\\n        imin = ihour = 0\\n        minute = hour = 0\\n        self.backtracker(num, minutes, hours, ans, imin, ihour, minute, hour)\\n        return ans\\n    \\n    def backtracker(self, num, minutes, hours, ans, imin, ihour, minute, hour):\\n        if minute >= 60 or hour >= 12: return False\\n        if not num:\\n            ans.append(self.format_time(minute, hour))\\n            return True\\n        for m in range(imin, len(minutes)):\\n            self.backtracker(num - 1, minutes, hours, ans, m + 1, ihour, minute + minutes[m], hour)\\n        for h in range(ihour, len(hours)):\\n            self.backtracker(num - 1, minutes, hours, ans, len(minutes), h + 1, minute, hour + hours[h])\\n        \\n    def format_time(self, minute, hour):\\n        prefix = \"0\" if minute < 10 else \"\"\\n        return f\"{hour}:{prefix}{minute}\"\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num):\\n        minutes = [1, 2, 4, 8, 16, 32]\\n        hours = [1, 2, 4, 8]\\n        ans = []\\n        imin = ihour = 0\\n        minute = hour = 0\\n        self.backtracker(num, minutes, hours, ans, imin, ihour, minute, hour)\\n        return ans\\n    \\n    def backtracker(self, num, minutes, hours, ans, imin, ihour, minute, hour):\\n        if minute >= 60 or hour >= 12: return False\\n        if not num:\\n            ans.append(self.format_time(minute, hour))\\n            return True\\n        for m in range(imin, len(minutes)):\\n            self.backtracker(num - 1, minutes, hours, ans, m + 1, ihour, minute + minutes[m], hour)\\n        for h in range(ihour, len(hours)):\\n            self.backtracker(num - 1, minutes, hours, ans, len(minutes), h + 1, minute, hour + hours[h])\\n        \\n    def format_time(self, minute, hour):\\n        prefix = \"0\" if minute < 10 else \"\"\\n        return f\"{hour}:{prefix}{minute}\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 411524,
                "title": "python-backtracking-version-easy-understand",
                "content": "\\n```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        result = []\\n        for i in range(0, num+1):\\n            result_hour = self.hour(0, i)\\n            result_minutes = self.minutes(0, num-i)\\n            \\n            for hour in result_hour:\\n                for minutes in result_minutes:\\n                    hour_num = hour[0]*8 + hour[1]*4 + hour[2]*2 + hour[3]*1\\n                    minutes_num = minutes[0]*32 + minutes[1]*16 + minutes[2]*8 + minutes[3]*4 + minutes[4]*2 + minutes[5]*1\\n                    if hour_num <= 11 and minutes_num <= 59:\\n                        result.append(\\'{}:{:02d}\\'.format(hour_num, minutes_num))\\n        \\n        return result\\n        \\n    \\n    def hour(self, start, k):\\n        if k == 0:\\n            return [[0, 0, 0 ,0]]\\n        else:\\n            result = []\\n            for i in range(start, 4):\\n                result_hour = self.hour(i+1, k-1)\\n                for item in result_hour:\\n                    item[i] = 1\\n                    result.append(item)\\n            \\n            return result\\n                \\n    \\n    def minutes(self, start, k):\\n        if k == 0:\\n            return [[0, 0, 0 ,0, 0, 0]]\\n        else:\\n            result = []\\n            for i in range(start, 6):\\n                result_minutes = self.minutes(i+1, k-1)\\n                for item in result_minutes:\\n                    item[i] = 1\\n                    result.append(item)\\n            return result\\n        \\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        result = []\\n        for i in range(0, num+1):\\n            result_hour = self.hour(0, i)\\n            result_minutes = self.minutes(0, num-i)\\n            \\n            for hour in result_hour:\\n                for minutes in result_minutes:\\n                    hour_num = hour[0]*8 + hour[1]*4 + hour[2]*2 + hour[3]*1\\n                    minutes_num = minutes[0]*32 + minutes[1]*16 + minutes[2]*8 + minutes[3]*4 + minutes[4]*2 + minutes[5]*1\\n                    if hour_num <= 11 and minutes_num <= 59:\\n                        result.append(\\'{}:{:02d}\\'.format(hour_num, minutes_num))\\n        \\n        return result\\n        \\n    \\n    def hour(self, start, k):\\n        if k == 0:\\n            return [[0, 0, 0 ,0]]\\n        else:\\n            result = []\\n            for i in range(start, 4):\\n                result_hour = self.hour(i+1, k-1)\\n                for item in result_hour:\\n                    item[i] = 1\\n                    result.append(item)\\n            \\n            return result\\n                \\n    \\n    def minutes(self, start, k):\\n        if k == 0:\\n            return [[0, 0, 0 ,0, 0, 0]]\\n        else:\\n            result = []\\n            for i in range(start, 6):\\n                result_minutes = self.minutes(i+1, k-1)\\n                for item in result_minutes:\\n                    item[i] = 1\\n                    result.append(item)\\n            return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 401791,
                "title": "simple-python-java-and-c-solution-using-bit-counting",
                "content": "Just count bits of each hour and minute and see if the sum of the counts matches the given number.\\n\\nTime compexlity: O(1) -- The double loop is a fixed size (60*12).\\n\\nPython\\n```python\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        return [\\'{}:{:>02d}\\'.format(h,m) \\n                for h in range(12) for m in range(60) \\n                if bin(h).count(\\'1\\') + bin(m).count(\\'1\\') == num]\\n```\\n\\n***\\n\\nJava\\n```java\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        for (int h = 0; h < 12; h++) {\\n            for (int m = 0; m < 60; m++) {\\n                if (Integer.bitCount(h) + Integer.bitCount(m) == num) {\\n                    res.add(String.format(\"%d:%02d\", h, m));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n***\\n\\nC++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        for (int h = 0; h < 12; ++h) {\\n            for (int m = 0; m < 60; ++m) {\\n                if (bitset<10>(h).count() + bitset<10>(m).count() == num) {\\n                    res.emplace_back(to_string(h) + \\':\\' + ((m<10) ? (\"0\" + to_string(m)) : to_string(m)));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        return [\\'{}:{:>02d}\\'.format(h,m) \\n                for h in range(12) for m in range(60) \\n                if bin(h).count(\\'1\\') + bin(m).count(\\'1\\') == num]\\n```\n```java\\nclass Solution {\\n    public List<String> readBinaryWatch(int num) {\\n        List<String> res = new ArrayList<>();\\n        for (int h = 0; h < 12; h++) {\\n            for (int m = 0; m < 60; m++) {\\n                if (Integer.bitCount(h) + Integer.bitCount(m) == num) {\\n                    res.add(String.format(\"%d:%02d\", h, m));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int num) {\\n        vector<string> res;\\n        for (int h = 0; h < 12; ++h) {\\n            for (int m = 0; m < 60; ++m) {\\n                if (bitset<10>(h).count() + bitset<10>(m).count() == num) {\\n                    res.emplace_back(to_string(h) + \\':\\' + ((m<10) ? (\"0\" + to_string(m)) : to_string(m)));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335057,
                "title": "easy-python3-solution",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        if num < 0 or num > 10:\\n            return []\\n        \\n        result = []\\n        \\n        for hour in range(0, 12):\\n            for minute in range(0, 60):\\n                if bin(hour).count(\\'1\\') + bin(minute).count(\\'1\\') == num:\\n                    result.append(\\'{:d}:{:02d}\\'.format(hour, minute))\\n                    \\n        return result\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        if num < 0 or num > 10:\\n            return []\\n        \\n        result = []\\n        \\n        for hour in range(0, 12):\\n            for minute in range(0, 60):\\n                if bin(hour).count(\\'1\\') + bin(minute).count(\\'1\\') == num:\\n                    result.append(\\'{:d}:{:02d}\\'.format(hour, minute))\\n                    \\n        return result\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 333098,
                "title": "100-100-php-solution",
                "content": "I assume it\\'s 100% because nobody writes php ;)\\n\\n```\\n    function readBinaryWatch($num) {\\n        if ($num == 0) { return [\\'0:00\\']; }\\n        $lol = [];\\n        for ($i = 0; $i <= 11; $i++) {\\n          for ($j = 0; $j <= 59; $j++) {\\n            $lol[substr_count(decbin($i) . decbin($j), 1)][] = $i . \":\" . sprintf(\\'%02d\\', $j);\\n          }\\n        }\\n        $out = $lol[$num] ?: [];\\n        return $out;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    function readBinaryWatch($num) {\\n        if ($num == 0) { return [\\'0:00\\']; }\\n        $lol = [];\\n        for ($i = 0; $i <= 11; $i++) {\\n          for ($j = 0; $j <= 59; $j++) {\\n            $lol[substr_count(decbin($i) . decbin($j), 1)][] = $i . \":\" . sprintf(\\'%02d\\', $j);\\n          }\\n        }\\n        $out = $lol[$num] ?: [];\\n        return $out;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 188631,
                "title": "python-solution-using-itertools-combinations",
                "content": "```\n        ref = [1,2,4,8,16,32,64,128,256,512]\n        st = set()\n        for x in combinations(ref, num):\n            top = sum(i for i in x if i <= 8)\n            bottom = sum(i//16 for i in x if i >= 16)\n            if top < 12 and bottom < 60:\n                st.add((top, bottom))\n        \n        result = []\n        for hour, minute in st:\n            result.append(str(hour) + ':' + str(minute).rjust(2, '0'))\n        return sorted(result)\n```",
                "solutionTags": [],
                "code": "```\n        ref = [1,2,4,8,16,32,64,128,256,512]\n        st = set()\n        for x in combinations(ref, num):\n            top = sum(i for i in x if i <= 8)\n            bottom = sum(i//16 for i in x if i >= 16)\n            if top < 12 and bottom < 60:\n                st.add((top, bottom))\n        \n        result = []\n        for hour, minute in st:\n            result.append(str(hour) + ':' + str(minute).rjust(2, '0'))\n        return sorted(result)\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 185205,
                "title": "c-backtracking-and-bit-manipulation",
                "content": "Oct. 23, 2018\\nIt is an easy level back tracking algorithm. But I think that it is the best algorithm I found to train myself, learn from different ideas through discuss panel. I wrote this solution using C# based on the idea learned from the discuss. \\n\\nHere are highlights of things I learned through the coding. \\n1. There are 10 bits, 1024 options, base case is well defined. \\n```if (startBit == 10 || count == num)```\\n2. The code to set ith bit to 1 is very short and concise, ``` time | (1 << i)```\\n3. Bit manipulation to get lowest six bits for minutes is easy to follow, ```time & 0x3f```\\n4. Bit manipulation get get highest 4 bits for hour is easy to follow, ```(time >> 6) & 0xf```; In order to keep only 4 bits from 7 to 10th, and operation is taken, ```& 0xf```. \\n\\nI like to write a few words for bit manipulations: \\n\\n1. Use or ```|``` and left shift ```<<``` to set the ith bit to 1; ``` time | (1 << i)```\\n2. Use and ```&``` to get minutes, ```time & 0x3f```\\n3. Use right shift and ```&``` to get hour,  ```(time >> 6) & 0xf```\\n\\nI also like to learn from the player who has more than one thousand submissmion. It is most elegant code compared to all other ideas I wrote today. I chose five ideas to write today. \\n\\n```\\npublic class Solution {\\n   /// <summary>\\n        /// source code is based on the idea from \\n        /// https://leetcode.com/problems/binary-watch/discuss/88582/Concise-Backtracking\\n        /// </summary>\\n        /// <param name=\"num\"></param>\\n        /// <returns></returns>\\n        public IList<string> ReadBinaryWatch(int num)\\n        {\\n            var result = new List<string>();\\n\\n            goOverAllBits(result, 0, 0, 0, num);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        /// base case is well defined: \\n        /// 10 bits in binary number for hour and minutes.\\n        /// \\n        /// </summary>\\n        /// <param name=\"result\"></param>\\n        /// <param name=\"time\"></param>\\n        /// <param name=\"startBit\"></param>\\n        /// <param name=\"count\"></param>\\n        /// <param name=\"num\"></param>\\n        private static void goOverAllBits(List<String> result, int time, int startBit, int count, int num)\\n        {\\n            // base case\\n            if (startBit == 10 || count == num)\\n            {\\n                if (count == num && isValid(time))\\n                {\\n                    result.Add(print(time));\\n                }\\n\\n                return;\\n            }\\n\\n            for (int i = startBit; i < 10; i++)\\n            {   //                    turn on ith bit\\n                goOverAllBits(result, time | (1 << i), i + 1, count + 1, num);\\n            }\\n        }\\n\\n        private static bool isValid(int time)\\n        {\\n            //   lowest six bits           highest 4 bits\\n            return (time & 0x3f) < 60 && ((time >> 6) & 0xf) < 12;\\n        }\\n\\n        private static string print(int time)\\n        {\\n            var hour = (time >> 6) & 0xf;\\n            var minutes = time & 0x3f;\\n\\n            var timeFormatted = hour + \":\" + minutes;\\n            if (minutes < 10)\\n            {\\n                timeFormatted = hour + \":0\" + minutes;\\n            }\\n\\n            return timeFormatted;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```if (startBit == 10 || count == num)```\n``` time | (1 << i)```\n```time & 0x3f```\n```(time >> 6) & 0xf```\n```& 0xf```\n```|```\n```<<```\n``` time | (1 << i)```\n```&```\n```time & 0x3f```\n```&```\n```(time >> 6) & 0xf```\n```\\npublic class Solution {\\n   /// <summary>\\n        /// source code is based on the idea from \\n        /// https://leetcode.com/problems/binary-watch/discuss/88582/Concise-Backtracking\\n        /// </summary>\\n        /// <param name=\"num\"></param>\\n        /// <returns></returns>\\n        public IList<string> ReadBinaryWatch(int num)\\n        {\\n            var result = new List<string>();\\n\\n            goOverAllBits(result, 0, 0, 0, num);\\n            return result;\\n        }\\n\\n        /// <summary>\\n        /// base case is well defined: \\n        /// 10 bits in binary number for hour and minutes.\\n        /// \\n        /// </summary>\\n        /// <param name=\"result\"></param>\\n        /// <param name=\"time\"></param>\\n        /// <param name=\"startBit\"></param>\\n        /// <param name=\"count\"></param>\\n        /// <param name=\"num\"></param>\\n        private static void goOverAllBits(List<String> result, int time, int startBit, int count, int num)\\n        {\\n            // base case\\n            if (startBit == 10 || count == num)\\n            {\\n                if (count == num && isValid(time))\\n                {\\n                    result.Add(print(time));\\n                }\\n\\n                return;\\n            }\\n\\n            for (int i = startBit; i < 10; i++)\\n            {   //                    turn on ith bit\\n                goOverAllBits(result, time | (1 << i), i + 1, count + 1, num);\\n            }\\n        }\\n\\n        private static bool isValid(int time)\\n        {\\n            //   lowest six bits           highest 4 bits\\n            return (time & 0x3f) < 60 && ((time >> 6) & 0xf) < 12;\\n        }\\n\\n        private static string print(int time)\\n        {\\n            var hour = (time >> 6) & 0xf;\\n            var minutes = time & 0x3f;\\n\\n            var timeFormatted = hour + \":\" + minutes;\\n            if (minutes < 10)\\n            {\\n                timeFormatted = hour + \":0\" + minutes;\\n            }\\n\\n            return timeFormatted;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167289,
                "title": "why-12-00-is-not-valid-output",
                "content": "```\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n```\\n\\nExpected doesn\\'t contain 12:00, but when it can be obtained by 2 bits.",
                "solutionTags": [],
                "code": "```\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158235,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer} num\\n# @return {String[]}\\ndef read_binary_watch(num)\\n  res = []\\n  (0..11).each do |h|\\n    (0..59).each do |s|\\n      res.push \"#{h}:#{s.to_s.rjust(2, \"0\")}\" if (h.to_s(2)+s.to_s(2)).count(\\'1\\') == num\\n    end\\n  end\\n  res\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer} num\\n# @return {String[]}\\ndef read_binary_watch(num)\\n  res = []\\n  (0..11).each do |h|\\n    (0..59).each do |s|\\n      res.push \"#{h}:#{s.to_s.rjust(2, \"0\")}\" if (h.to_s(2)+s.to_s(2)).count(\\'1\\') == num\\n    end\\n  end\\n  res\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 141544,
                "title": "python-using-array-and-backtracking",
                "content": "```\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def backtrack(positions,remaining, outputs, start):\\n            if remaining == 0:\\n                outputs.append(positions[:])\\n            else:\\n                for i in range(start, len(positions)):\\n                    positions[i] = 1\\n                    backtrack(positions, remaining -1, outputs, i + 1)\\n                    positions[i] = 0\\n        \\n        outputs = []\\n        leds = [0]*10\\n        backtrack(leds, num, outputs, 0)\\n        outputs = map(\"\".join, [map(str, x) for x in outputs])\\n        ans = []\\n        for led in outputs:\\n            hr = int(led[0:4],2)\\n            minutes = int(led[4:10],2)\\n            if hr <= 11 and minutes  <= 59:\\n                ans.append(\"{}:{:02}\".format(hr,minutes))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        def backtrack(positions,remaining, outputs, start):\\n            if remaining == 0:\\n                outputs.append(positions[:])\\n            else:\\n                for i in range(start, len(positions)):\\n                    positions[i] = 1\\n                    backtrack(positions, remaining -1, outputs, i + 1)\\n                    positions[i] = 0\\n        \\n        outputs = []\\n        leds = [0]*10\\n        backtrack(leds, num, outputs, 0)\\n        outputs = map(\"\".join, [map(str, x) for x in outputs])\\n        ans = []\\n        for led in outputs:\\n            hr = int(led[0:4],2)\\n            minutes = int(led[4:10],2)\\n            if hr <= 11 and minutes  <= 59:\\n                ans.append(\"{}:{:02}\".format(hr,minutes))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88539,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} num\\n * @return {string[]}\\n */\\nvar readBinaryWatch = function(num) {\\n    var result = [];\\n    for (var i = 0; i <= 11; i++) {\\n        for (var j = 0; j <= 59; j++) {\\n            if ((countSetBit(i) + countSetBit(j)) === num) {\\n                result.push(i + (j < 10 ? ':0' : ':') + j);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\nfunction countSetBit(num) {\\n    var binary = num.toString(2);\\n    var count = 0;\\n    for (var i = 0; i < binary.length; i++) {\\n        if (binary[i] == 1) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} num\\n * @return {string[]}\\n */\\nvar readBinaryWatch = function(num) {\\n    var result = [];\\n    for (var i = 0; i <= 11; i++) {\\n        for (var j = 0; j <= 59; j++) {\\n            if ((countSetBit(i) + countSetBit(j)) === num) {\\n                result.push(i + (j < 10 ? ':0' : ':') + j);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\nfunction countSetBit(num) {\\n    var binary = num.toString(2);\\n    var count = 0;\\n    for (var i = 0; i < binary.length; i++) {\\n        if (binary[i] == 1) {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88541,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/73134/python-solution-with-detailed-explanation\\n\\n**Binary Watch** https://leetcode.com/problems/binary-watch/\\n\\n**Backtracking Solution**\\n* We use the standard backtracking recipe to traverse the backtracking tree. We use hrs_so_far, mins_so_far, hidx and midx. The last two indicate the index into hours LED array and minutes LED array.\\n* We always traverse hours array after the minutes array, so for hours array, we set midx to 6 so that minutes are not generated in the next recursion call. If this is not done, we will end up having duplicates while walking the recursion tree.\\n* This requires a bit of thought - check the recursion tree and see how hours sub-trees are pruned to prevent duplication.https://goo.gl/photos/vmvL7U4QACJeWwCm9\\n\\n```\\nclass Solution(object):\\n    def helper(self, N, hrs_so_far, mins_so_far, hidx, midx):\\n        if N == 0:\\n            self.results.append(\"%d:%02d\"%(hrs_so_far, mins_so_far))\\n        else:\\n            for i in range(midx, 6):\\n                if mins_so_far|(1<<i) <= 59:\\n                    self.helper(N-1, hrs_so_far, mins_so_far|1<<i, hidx, i+1)\\n            for i in range(hidx, 4):\\n                if hrs_so_far|(1<<i) <= 11:\\n                    self.helper(N-1, hrs_so_far|1<<i, mins_so_far, i+1, 6)\\n        return\\n    \\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.results = []\\n        hrs_so_far, mins_so_far, hidx, midx = 0, 0, 0, 0\\n        self.helper(num, hrs_so_far, mins_so_far, hidx, midx)\\n        return self.results\\n```\\n\\n**Counting Solution**\\n* Iterate all the possible times and filter the ones with the correct number of one-bits.\\n* Idea suggested in: https://discuss.leetcode.com/topic/59374/simple-python-java\\n```\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        return ['%d:%02d'%(i,j) for i in range(12) for j in range(60) if (bin(i)+bin(j)).count('1') == n\\n```\\n* Notice the use of bin method within Python - it gives the binary equivalent for any input.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, N, hrs_so_far, mins_so_far, hidx, midx):\\n        if N == 0:\\n            self.results.append(\"%d:%02d\"%(hrs_so_far, mins_so_far))\\n        else:\\n            for i in range(midx, 6):\\n                if mins_so_far|(1<<i) <= 59:\\n                    self.helper(N-1, hrs_so_far, mins_so_far|1<<i, hidx, i+1)\\n            for i in range(hidx, 4):\\n                if hrs_so_far|(1<<i) <= 11:\\n                    self.helper(N-1, hrs_so_far|1<<i, mins_so_far, i+1, 6)\\n        return\\n    \\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        self.results = []\\n        hrs_so_far, mins_so_far, hidx, midx = 0, 0, 0, 0\\n        self.helper(num, hrs_so_far, mins_so_far, hidx, midx)\\n        return self.results\\n```\n```\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        return ['%d:%02d'%(i,j) for i in range(12) for j in range(60) if (bin(i)+bin(j)).count('1') == n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88568,
                "title": "easy-javascript-solution-explained",
                "content": "If the number of bits in the hour is equal to the requested number of LEDs, then its a valid hour:\\n````\\nvar readBinaryWatch = function(num) {\\n    var hour,\\n        minutes,\\n        numBits,\\n        result = [],\\n        hourFormat = \"\";\\n    \\n    for(hour = 0; hour <= 11; hour++){\\n        for(minutes = 0; minutes <= 59; minutes++){\\n            // Count the number of 'one' bits in each number\\n            numBits = hour.toString(2).split(1).length - 1;\\n            numBits += minutes.toString(2).split(1).length - 1;\\n            \\n            // If the number of bits in the hour is the same as the requested number add it to the results\\n            if(numBits === num){\\n                // Format the output, if the minutes are less than 10 add a zero at the beggining of the string\\n            \\thourFormat = hour.toString() + \":\" + (minutes < 10? '0' + minutes.toString() : minutes.toString());\\n                result.push(hourFormat);\\n            }\\n            \\n        }\\n    }\\n    \\n    return result;\\n};",
                "solutionTags": [],
                "code": "If the number of bits in the hour is equal to the requested number of LEDs, then its a valid hour:\\n````\\nvar readBinaryWatch = function(num) {\\n    var hour,\\n        minutes,\\n        numBits,\\n        result = [],\\n        hourFormat = \"\";\\n    \\n    for(hour = 0; hour <= 11; hour++){\\n        for(minutes = 0; minutes <= 59; minutes++){\\n            // Count the number of 'one' bits in each number\\n            numBits = hour.toString(2).split(1).length - 1;\\n            numBits += minutes.toString(2).split(1).length - 1;\\n            \\n            // If the number of bits in the hour is the same as the requested number add it to the results\\n            if(numBits === num){\\n                // Format the output, if the minutes are less than 10 add a zero at the beggining of the string\\n            \\thourFormat = hour.toString() + \":\" + (minutes < 10? '0' + minutes.toString() : minutes.toString());\\n                result.push(hourFormat);\\n            }\\n            \\n        }\\n    }\\n    \\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 88454,
                "title": "easy-understand-python-solution-generate-results-at-the-same-time-beats-94",
                "content": "from collections import defaultdict\\n\\n\\nclass Solution(object):\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        minute = defaultdict(lambda: list())\\n        hour = defaultdict(lambda: list())\\n        res = list()\\n\\n        for i in range(0, 60):\\n            binary = \"{0:b}\".format(i)\\n            minute[binary.count('1')].append(i)\\n\\n        for i in range(0, 12):\\n            binary = \"{0:b}\".format(i)\\n            hour[binary.count('1')].append(i)\\n\\n        for i in range(0, num + 1):\\n            # print hour[i]\\n            # print minute[num-i]\\n\\n            for j in hour[i]:\\n                for k in minute[num - i]:\\n                    if len(str(k)) < 2:\\n                        res.append(str(j) + ':0' + str(k))\\n                    else:\\n                        res.append(str(j) + ':' + str(k))\\n\\n        return res",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        minute = defaultdict(lambda: list())\\n        hour = defaultdict(lambda: list())\\n        res = list()\\n\\n        for i in range(0, 60):\\n            binary = \"{0:b}",
                "codeTag": "Java"
            },
            {
                "id": 88592,
                "title": "simple-java-backtracking",
                "content": "```\\npublic class Solution {\\n    public List<String> readBinaryWatch(int n) {\\n        int[] time = new int[] {1, 2, 4, 8, 1, 2, 4, 8, 16, 32};\\n        List<String> res = new ArrayList();\\n        backtrack(res, time, 0, n, 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void backtrack(List<String> res, int[] time, int start, int n, int hour, int min, int count) {\\n        if (hour > 11 || min > 59) {\\n            return;\\n        }\\n        if (count == n) {\\n            String mm = min < 10 ? \"0\" + min : \"\" + min;\\n            String hh = \"\" + hour;\\n            res.add(new String(hh + \":\" + mm));\\n            return;\\n        }\\n        \\n        for (int i = start; i < time.length; i++) {\\n            int newHour = i < 4 ? hour + time[i] : hour;\\n            int newMin = i < 4 ? min : min + time[i];\\n            backtrack(res, time, i + 1, n, newHour, newMin, count + 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public List<String> readBinaryWatch(int n) {\\n        int[] time = new int[] {1, 2, 4, 8, 1, 2, 4, 8, 16, 32};\\n        List<String> res = new ArrayList();\\n        backtrack(res, time, 0, n, 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void backtrack(List<String> res, int[] time, int start, int n, int hour, int min, int count) {\\n        if (hour > 11 || min > 59) {\\n            return;\\n        }\\n        if (count == n) {\\n            String mm = min < 10 ? \"0\" + min : \"\" + min;\\n            String hh = \"\" + hour;\\n            res.add(new String(hh + \":\" + mm));\\n            return;\\n        }\\n        \\n        for (int i = start; i < time.length; i++) {\\n            int newHour = i < 4 ? hour + time[i] : hour;\\n            int newMin = i < 4 ? min : min + time[i];\\n            backtrack(res, time, i + 1, n, newHour, newMin, count + 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88616,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def backtrack(self, r, h, num, ind):\\n        if num == 0:\\n            hour, minute = 0, 0\\n            for i in xrange(4):\\n                hour = hour*2 + h[i]\\n            for i in xrange(4, 10):\\n                minute = minute*2 + h[i]\\n            if hour < 12 and minute < 60:\\n                r.append('%d:%02d' % (hour, minute))\\n        else:\\n            for i in xrange(ind, 11-num):\\n                h[i] = 1\\n                self.backtrack(r, h, num-1, i+1)\\n                h[i] = 0\\n    \\n    def readBinaryWatch(self, num):\\n        r = []\\n        self.backtrack(r, [0]*10, num, 0)\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def backtrack(self, r, h, num, ind):\\n        if num == 0:\\n            hour, minute = 0, 0\\n            for i in xrange(4):\\n                hour = hour*2 + h[i]\\n            for i in xrange(4, 10):\\n                minute = minute*2 + h[i]\\n            if hour < 12 and minute < 60:\\n                r.append('%d:%02d' % (hour, minute))\\n        else:\\n            for i in xrange(ind, 11-num):\\n                h[i] = 1\\n                self.backtrack(r, h, num-1, i+1)\\n                h[i] = 0\\n    \\n    def readBinaryWatch(self, num):\\n        r = []\\n        self.backtrack(r, [0]*10, num, 0)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88639,
                "title": "simple-easy-python-dfs-solution",
                "content": "    Use Helper arrays to help us to represent binary numbers.\\n    hours * 100 to distinguish that from minutes.\\n    then just easy and normal dfs to retrieve all combinations. \\n\\n\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        nums = [1,2,4,8,16,32,100,200,400,800]\\n        res = []\\n        self.dfs(nums, 0, 0, num, 0, res)\\n        return res\\n    \\n    def dfs(self, nums, level, idx, num, path, res):\\n        if level == num:\\n            hours = path/100\\n            minutes = path%100\\n            if hours > 11 or minutes > 59:\\n                return\\n            elif minutes < 10:\\n                res.append(str(hours)+\":\"+\"0\"+str(minutes))\\n                return\\n            else:\\n                res.append(str(hours)+\":\"+str(minutes))\\n                return\\n            \\n        for i in range(idx, len(nums)):\\n            self.dfs(nums, level+1, i+1, num, path+nums[i], res)",
                "solutionTags": [],
                "code": "    Use Helper arrays to help us to represent binary numbers.\\n    hours * 100 to distinguish that from minutes.\\n    then just easy and normal dfs to retrieve all combinations. \\n\\n\\n    def readBinaryWatch(self, num):\\n        \"\"\"\\n        :type num: int\\n        :rtype: List[str]\\n        \"\"\"\\n        nums = [1,2,4,8,16,32,100,200,400,800]\\n        res = []\\n        self.dfs(nums, 0, 0, num, 0, res)\\n        return res\\n    \\n    def dfs(self, nums, level, idx, num, path, res):\\n        if level == num:\\n            hours = path/100\\n            minutes = path%100\\n            if hours > 11 or minutes > 59:\\n                return\\n            elif minutes < 10:\\n                res.append(str(hours)+\":\"+\"0\"+str(minutes))\\n                return\\n            else:\\n                res.append(str(hours)+\":\"+str(minutes))\\n                return\\n            \\n        for i in range(idx, len(nums)):\\n            self.dfs(nums, level+1, i+1, num, path+nums[i], res)",
                "codeTag": "Python3"
            },
            {
                "id": 3642923,
                "title": "binary-watch-time-combinations-using-typescript-and-rust",
                "content": "# TypeScript\\n```\\nfunction readBinaryWatch(turnedOn: number): string[] {\\n    const times = []\\n\\n    const countOnes = (num: number) => num.toString(2).split(\\'1\\').length - 1\\n\\n    for (let h = 0; h < 12; h++) {\\n        for (let m = 0; m < 60; m++) {\\n            if (countOnes(h) + countOnes(m) === turnedOn) {\\n                times.push(`${h}:${String(m).padStart(2, \\'0\\')}`)\\n            }\\n        }\\n    }\\n\\n    return times\\n};\\n```\\n\\n# Rust\\n```\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        let num = turned_on as u32;\\n        let mut res = Vec::new();\\n\\n        for h in 0i32..12 {\\n            for m in 0i32..60 {\\n                if h.count_ones() + m.count_ones() == num {\\n                    res.push(format!(\"{h}:{m:0>2}\"));\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "TypeScript"
                ],
                "code": "```\\nfunction readBinaryWatch(turnedOn: number): string[] {\\n    const times = []\\n\\n    const countOnes = (num: number) => num.toString(2).split(\\'1\\').length - 1\\n\\n    for (let h = 0; h < 12; h++) {\\n        for (let m = 0; m < 60; m++) {\\n            if (countOnes(h) + countOnes(m) === turnedOn) {\\n                times.push(`${h}:${String(m).padStart(2, \\'0\\')}`)\\n            }\\n        }\\n    }\\n\\n    return times\\n};\\n```\n```\\nimpl Solution {\\n    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {\\n        let num = turned_on as u32;\\n        let mut res = Vec::new();\\n\\n        for h in 0i32..12 {\\n            for m in 0i32..60 {\\n                if h.count_ones() + m.count_ones() == num {\\n                    res.push(format!(\"{h}:{m:0>2}\"));\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3140829,
                "title": "counting-digits-c-100",
                "content": "# Approach\\nAs there are only $$12*60=720$$ combinations of hour and minute that can be displayed on the watch, we can simply iterate over all hour-minute combinations and count the digits$$~> 0$$ in the binary representation of hour and minute. To check whether a digit is $$1$$, we left-shift $$1$$ to the position to that digit and use the bit-wise `and` operator.\\n\\n# Complexity\\n- Time complexity:\\n$$O(h*m)$$, with $$h$$ and $$m$$ being the number of hours in a day and minutes in an hour, respectively.\\n\\n- Space complexity:\\n$$O(result.Length)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> ReadBinaryWatch(int turnedOn) {\\n        List<string> result = new List<string>();\\n        for(int h = 0; h < 12; h++)\\n        {\\n            for(int m = 0; m < 60; m++)\\n            {\\n                int d = 0;\\n                for(int a = 0; a < 6; a++)\\n                    d += (((h&(1<<a)) > 0)?1:0) + (((m&(1<<a)) > 0)?1:0);\\n                if(d == turnedOn)\\n                    result.Add(h.ToString() + \":\" + m.ToString().PadLeft(2,\\'0\\'));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> ReadBinaryWatch(int turnedOn) {\\n        List<string> result = new List<string>();\\n        for(int h = 0; h < 12; h++)\\n        {\\n            for(int m = 0; m < 60; m++)\\n            {\\n                int d = 0;\\n                for(int a = 0; a < 6; a++)\\n                    d += (((h&(1<<a)) > 0)?1:0) + (((m&(1<<a)) > 0)?1:0);\\n                if(d == turnedOn)\\n                    result.Add(h.ToString() + \":\" + m.ToString().PadLeft(2,\\'0\\'));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854853,
                "title": "simple-python-solution",
                "content": "Instead of using backtracking, since there are a constant number of times we can just iterate through each of them and check if the correct number of LEDs are turned on.\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        ret = []\\n        for h in range(12):\\n            for m in range(60):\\n                if bin(h).count(\\'1\\') + bin(m).count(\\'1\\') == turnedOn:\\n                    ret.append(f\\'{str(h)}:{str(m).zfill(2)}\\')\\n        return ret\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        ret = []\\n        for h in range(12):\\n            for m in range(60):\\n                if bin(h).count(\\'1\\') + bin(m).count(\\'1\\') == turnedOn:\\n                    ret.append(f\\'{str(h)}:{str(m).zfill(2)}\\')\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788865,
                "title": "calculate-all-set-bits-0-59",
                "content": "```\\nvector<string> readBinaryWatch(int turnedOn) {\\n        vector<int>dp(60,0);  // number of set bits in ith \\n        for(int i=1;i<60;i++)\\n            dp[i]=dp[i/2]+(i&1);\\n        \\n        vector<string>res;\\n        \\n        for(int hr=0;hr<12;hr++){\\n            for(int i=0;i<60;i++)\\n                if(dp[i]+dp[hr]==turnedOn) {\\n                    if(i<10) res.push_back(to_string(hr)+\":0\"+to_string(i));\\n                    else res.push_back(to_string(hr)+\":\"+to_string(i));\\n                }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<string> readBinaryWatch(int turnedOn) {\\n        vector<int>dp(60,0);  // number of set bits in ith \\n        for(int i=1;i<60;i++)\\n            dp[i]=dp[i/2]+(i&1);\\n        \\n        vector<string>res;\\n        \\n        for(int hr=0;hr<12;hr++){\\n            for(int i=0;i<60;i++)\\n                if(dp[i]+dp[hr]==turnedOn) {\\n                    if(i<10) res.push_back(to_string(hr)+\":0\"+to_string(i));\\n                    else res.push_back(to_string(hr)+\":\"+to_string(i));\\n                }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541698,
                "title": "very-simple-python-solution",
                "content": "```python\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        # for example:\\n        # 2 1 (3 min) - two leds on, bin: 11 \\n        # 2   (2 min) - one led on, bin: 10\\n        #   1 (1 min) - one led on, bin:  1\\n        \\n        def bit_counter(n):\\n            s = bin(n)[2:]\\n            temp = 0\\n            for i in s:\\n                if i == \\'1\\':\\n                    temp += 1\\n            return temp\\n        \\n        result = []\\n        \\n        for h in range(12):\\n            for m in range(60):\\n                if bit_counter(h) + bit_counter(m) == turnedOn:\\n                    result.append(f\\'{h}:{m:02}\\')\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        # for example:\\n        # 2 1 (3 min) - two leds on, bin: 11 \\n        # 2   (2 min) - one led on, bin: 10\\n        #   1 (1 min) - one led on, bin:  1\\n        \\n        def bit_counter(n):\\n            s = bin(n)[2:]\\n            temp = 0\\n            for i in s:\\n                if i == \\'1\\':\\n                    temp += 1\\n            return temp\\n        \\n        result = []\\n        \\n        for h in range(12):\\n            for m in range(60):\\n                if bit_counter(h) + bit_counter(m) == turnedOn:\\n                    result.append(f\\'{h}:{m:02}\\')\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418051,
                "title": "python3-hashmap-bit-count",
                "content": "For people who can understand hindi: https://www.youtube.com/watch?v=Pdpug1FIDqQ&t=8s\\n\\nConsider any time of the day\\nEg: 10:25, the numbers set of the watch would be:\\n\\n![image](https://assets.leetcode.com/users/images/1f6c6201-6048-47db-a9b2-3190ee8e4f4a_1660368068.8611372.png)\\n\\nTo find the number of bits turned on for this time in total, we can one-hot encode the hours and minutes. If a particular number is used, it is represented as 1 else as 0.\\nHence number of ones for 10:25 would be 5.\\n\\nAlso observe that, the binary version of 10 is 1010 and that of 25 is 011001.\\nThis coincides with the one hot encoded version.\\n\\nHence to calculate the total number of turnedOn bits, just calculate the number of ones in the binary version of the hours and minutes.\\n\\nSo what we do is generate all possible `hours:minutes` (hours has range 0-11 and mintes has range 0-59).\\nCount the number of set bits in each `hours:minutes` combination and store it in a hashmap with` key->number of turnedOn bits` and` value->list of hours:minutes strings`.\\n\\nIn python:\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\t\\t\\n        #hours: 0-11 range of possible values\\n        #minutes: 0-59 range of possible values\\n        \\n        setbits2time = {i:[] for i in range(10+1)} #time in str correspondng to number of set bits\\n        \\n        #generate each possible time and associate with number of set bits\\n        for hr in range(0,11+1):\\n            hour = f\\'{hr}\\'\\n            for mi in range(0,59+1):\\n                if mi<10:\\n                    minutes = f\\'0{mi}\\'\\n                else:\\n                    minutes = f\\'{mi}\\'\\n                    \\n                totalBitsSet = bin(hr).count(\"1\") + bin(mi).count(\"1\")\\n                setbits2time[totalBitsSet].append(hour+\":\"+minutes)\\n                \\n        return setbits2time[turnedOn]\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\t\\t\\n        #hours: 0-11 range of possible values\\n        #minutes: 0-59 range of possible values\\n        \\n        setbits2time = {i:[] for i in range(10+1)} #time in str correspondng to number of set bits\\n        \\n        #generate each possible time and associate with number of set bits\\n        for hr in range(0,11+1):\\n            hour = f\\'{hr}\\'\\n            for mi in range(0,59+1):\\n                if mi<10:\\n                    minutes = f\\'0{mi}\\'\\n                else:\\n                    minutes = f\\'{mi}\\'\\n                    \\n                totalBitsSet = bin(hr).count(\"1\") + bin(mi).count(\"1\")\\n                setbits2time[totalBitsSet].append(hour+\":\"+minutes)\\n                \\n        return setbits2time[turnedOn]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411603,
                "title": "binary-watch-simple-java-solution",
                "content": "class Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        \\n        List<String> ans = new ArrayList<>();\\n        StringBuilder str;\\n        for(int i=0;i<12;i++){\\n            \\n            for(int j =0;j<60;j++){\\n                \\n                if(Integer.bitCount(i)+Integer.bitCount(j)==turnedOn){\\n                    str = new StringBuilder(\"\");\\n                \\n                    str.append(i).append(\":\").append((j>9)?\"\":\"0\").append(j);\\n                    ans.add(str.toString());\\n                    \\n                    \\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n**Please Upvote if you like **",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> readBinaryWatch(int turnedOn) {\\n        \\n        List<String> ans = new ArrayList<>();\\n        StringBuilder str;\\n        for(int i=0;i<12;i++){\\n            \\n            for(int j =0;j<60;j++){\\n                \\n                if(Integer.bitCount(i)+Integer.bitCount(j)==turnedOn){\\n                    str = new StringBuilder(\"\");\\n                \\n                    str.append(i).append(\":\").append((j>9)?\"\":\"0\").append(j);\\n                    ans.add(str.toString());\\n                    \\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2389073,
                "title": "javascript",
                "content": "```\\nvar readBinaryWatch = function (turnedOn) {\\n  let res = [];\\n\\n  for (let hr = 0; hr < 12; hr++) {\\n    for (let min = 0; min < 60; min++) {\\n      if (bitCount(hr) + bitCount(min) === turnedOn) {\\n        if (min < 10) min = \"0\" + min;\\n        res.push(`${hr}:${min}`);\\n      }\\n    }\\n  }\\n  return res;\\n\\n  function bitCount(num) {\\n    return Number(num)\\n      .toString(2)\\n      .split(\"\")\\n      .filter((el) => el === \"1\").length;\\n  }\\n};",
                "solutionTags": [],
                "code": "```\\nvar readBinaryWatch = function (turnedOn) {\\n  let res = [];\\n\\n  for (let hr = 0; hr < 12; hr++) {\\n    for (let min = 0; min < 60; min++) {\\n      if (bitCount(hr) + bitCount(min) === turnedOn) {\\n        if (min < 10) min = \"0\" + min;\\n        res.push(`${hr}:${min}`);\\n      }\\n    }\\n  }\\n  return res;\\n\\n  function bitCount(num) {\\n    return Number(num)\\n      .toString(2)\\n      .split(\"\")\\n      .filter((el) => el === \"1\").length;\\n  }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2356543,
                "title": "perfect-code-java-90",
                "content": "```\\npublic List<String> readBinaryWatch(int turnedOn) {\\n        List<String> result = new ArrayList<>();\\n        for(int i=0; i<12; i++){\\n            for(int j=0; j<60; j++){\\n                StringBuffer sb = new StringBuffer();\\n                int hrBits = Integer.bitCount(i);\\n                int minBits = Integer.bitCount(j);\\n                if(hrBits+minBits == turnedOn){\\n                    sb.append(i);\\n                    sb.append(\":\");\\n                    if(j<10) sb.append(\"0\");\\n                    sb.append(j);\\n                    \\n                    result.add(sb.toString());\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic List<String> readBinaryWatch(int turnedOn) {\\n        List<String> result = new ArrayList<>();\\n        for(int i=0; i<12; i++){\\n            for(int j=0; j<60; j++){\\n                StringBuffer sb = new StringBuffer();\\n                int hrBits = Integer.bitCount(i);\\n                int minBits = Integer.bitCount(j);\\n                if(hrBits+minBits == turnedOn){\\n                    sb.append(i);\\n                    sb.append(\":\");\\n                    if(j<10) sb.append(\"0\");\\n                    sb.append(j);\\n                    \\n                    result.add(sb.toString());\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2220065,
                "title": "simple-and-easy-to-understand-backtracking-solution-in-python",
                "content": "Simple and easy to understand backtracking solution using a list.\\n* Represent the time as an list of zeros\\n* Backtrack using list index and the number of bits still turned on\\n* When no remainig bits need to be turned on we can store the candidate\\n* Translate the array of bits to a time\\n\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        \\n        time = [0]*10\\n        res = []\\n        \\n        def backtrack(time, index, on):\\n            \\n            if on == 0:\\n                \\n                # Convert binary strings to int\\n                hr = int(\\'\\'.join(map(str, time[0:4])), 2)\\n                mn = int(\\'\\'.join(map(str, time[4:])), 2)\\n                \\n                if hr < 12 and mn < 60:\\n                    # Stringify\\n                    str_hr, str_mn = str(hr), str(mn)\\n                    \\n                    # Pad out minute if necessary\\n                    if len(str_mn) == 1:\\n                        str_mn = \"0\" + str_mn\\n                        \\n                    res.append(str_hr + \":\" + str_mn)\\n            else:    \\n                \\n                for i in range(index, len(time)):\\n                    time[i] = 1\\n                    backtrack(time, i+1, on-1)\\n                    time[i] = 0\\n            \\n            \\n        backtrack(time, 0, turnedOn)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        \\n        time = [0]*10\\n        res = []\\n        \\n        def backtrack(time, index, on):\\n            \\n            if on == 0:\\n                \\n                # Convert binary strings to int\\n                hr = int(\\'\\'.join(map(str, time[0:4])), 2)\\n                mn = int(\\'\\'.join(map(str, time[4:])), 2)\\n                \\n                if hr < 12 and mn < 60:\\n                    # Stringify\\n                    str_hr, str_mn = str(hr), str(mn)\\n                    \\n                    # Pad out minute if necessary\\n                    if len(str_mn) == 1:\\n                        str_mn = \"0\" + str_mn\\n                        \\n                    res.append(str_hr + \":\" + str_mn)\\n            else:    \\n                \\n                for i in range(index, len(time)):\\n                    time[i] = 1\\n                    backtrack(time, i+1, on-1)\\n                    time[i] = 0\\n            \\n            \\n        backtrack(time, 0, turnedOn)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206948,
                "title": "while-loop-answer-c",
                "content": "```\\nclass Solution {\\n\\n    \\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n\\n        vector<string> res;\\n        if(turnedOn >= 9) return res;\\n        if(turnedOn == 0) { res.push_back(\"0:00\"); return res;}\\n        \\n        int cm = 0;\\n        int m = 0;\\n        int h = 0;\\n        std::stringstream buffer;\\n\\n        \\n        while(h < 12)\\n        {\\n            while(m < 60)\\n            {\\n                cm = __builtin_popcount(h) + __builtin_popcount(m);\\n                if(cm == turnedOn && ( h>0 || m > 0) )\\n                {\\n                    if (m < 10)\\n                        buffer << h << \":0\" << m ;\\n                    else\\n                        buffer << h << \":\" << m ;\\n                    res.push_back(buffer.str());\\n                }\\n                buffer.str(\"\");\\n                m += 1;\\n            }\\n            h += 1;\\n            m = 0;\\n        }\\n        \\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    \\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n\\n        vector<string> res;\\n        if(turnedOn >= 9) return res;\\n        if(turnedOn == 0) { res.push_back(\"0:00\"); return res;}\\n        \\n        int cm = 0;\\n        int m = 0;\\n        int h = 0;\\n        std::stringstream buffer;\\n\\n        \\n        while(h < 12)\\n        {\\n            while(m < 60)\\n            {\\n                cm = __builtin_popcount(h) + __builtin_popcount(m);\\n                if(cm == turnedOn && ( h>0 || m > 0) )\\n                {\\n                    if (m < 10)\\n                        buffer << h << \":0\" << m ;\\n                    else\\n                        buffer << h << \":\" << m ;\\n                    res.push_back(buffer.str());\\n                }\\n                buffer.str(\"\");\\n                m += 1;\\n            }\\n            h += 1;\\n            m = 0;\\n        }\\n        \\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183195,
                "title": "c-pure-backtracking-no-wasteful-combinations-beats-100",
                "content": "```\\nclass Solution {\\n    void genCombs(vector<string>& ans, int rem, int idx, int leds) {\\n        if ((leds >> 6) > 11) return; // hours\\n        if ((leds & 0x3F) > 59) return; // mins\\n        if (10 - idx < rem || rem < 0) return; // goal not reachable\\n        \\n        if (rem == 0) {\\n            ans.push_back(to_string(leds >> 6) + // hours\\n                          \\':\\' + \\n                          ((leds & 0x3F) < 10? \"0\" : \"\") + // leading zero\\n                          to_string(leds & 0x3F)); // mins\\n            return;\\n        }\\n        \\n        for (int i = idx; i < 10; ++i) {\\n            leds |= 1 << i; // flip\\n            genCombs(ans, rem - 1, i + 1, leds);\\n            leds ^= 1 << i; // flop\\n        }\\n    }\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> ans;\\n        genCombs(ans, turnedOn, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    void genCombs(vector<string>& ans, int rem, int idx, int leds) {\\n        if ((leds >> 6) > 11) return; // hours\\n        if ((leds & 0x3F) > 59) return; // mins\\n        if (10 - idx < rem || rem < 0) return; // goal not reachable\\n        \\n        if (rem == 0) {\\n            ans.push_back(to_string(leds >> 6) + // hours\\n                          \\':\\' + \\n                          ((leds & 0x3F) < 10? \"0\" : \"\") + // leading zero\\n                          to_string(leds & 0x3F)); // mins\\n            return;\\n        }\\n        \\n        for (int i = idx; i < 10; ++i) {\\n            leds |= 1 << i; // flip\\n            genCombs(ans, rem - 1, i + 1, leds);\\n            leds ^= 1 << i; // flop\\n        }\\n    }\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> ans;\\n        genCombs(ans, turnedOn, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123695,
                "title": "c-pre-computed-bit-ranges-solution-100-time-0ms-60-space-6-4mb",
                "content": "Trying to improve a bit upon [my previous one](https://leetcode.com/problems/binary-watch/discuss/433627/).\\n\\nThe main trick is still to precompute what valid numbers (ie: in the `0 - 60` range) we can get for each amount of bits; we might do so with a simple loop filling in the buckets for each number, but I preferred to just store it into an array of vectors, `bits`, since it is really trivial and not worth recomputing for each execution (and [a much better explanation of it already exists](https://leetcode.com/problems/binary-watch/discuss/497654/)).\\n\\nWe will also declare a support variable `res`, our usual accumulator for the result, and spare time, `return`ing it as it is (ie: empty) when `n > 8` (no valid times in those cases).\\n\\nFor the rest, we will loop with both `i` and `j`, respectively initialised to `0` and `n`, `n + 1` times (so to cover all the values in the `0 - n` range with `i`, the value we will use to assign bits to the hours); for each iteration we will:\\n* get every hours `h` out of `bits[i]` and for it:\\n\\t* `break`  if `h > 11`, since there is no point in considering it (given the time format required in the specs);\\n\\t* get each minute `m` out of `bits[j]` and:\\n\\t\\t* push into `res` a string made of `h` (stringified), `\":0\"` or `\":\"` (depending on whether or not `m < `10`) and `m` (stringified, again).\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nvector<int> bits[] = {{0}, {1, 2, 4, 8, 16, 32}, {3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 33, 34, 36, 40, 48}, {7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 35, 37, 38, 41, 42, 44, 49, 50, 52, 56}, {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58}, {31, 47, 55, 59}, {}, {}, {}, {}, {}};\\n\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int n) {\\n        // support variables\\n        vector<string> res;\\n        // edge case: too many bits\\n        if (n > 8) return res;\\n        // going through all the possible values of bits for the hours\\n        for (int i = 0, j = n; i <= n; i++, j--){\\n            for (auto h: bits[i]) {\\n                if (h > 11) break;\\n                // getting all the remaining bits for the minutes\\n                for (auto m: bits[j]) {\\n                    res.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nvector<int> bits[] = {{0}, {1, 2, 4, 8, 16, 32}, {3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 33, 34, 36, 40, 48}, {7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 35, 37, 38, 41, 42, 44, 49, 50, 52, 56}, {15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58}, {31, 47, 55, 59}, {}, {}, {}, {}, {}};\\n\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int n) {\\n        // support variables\\n        vector<string> res;\\n        // edge case: too many bits\\n        if (n > 8) return res;\\n        // going through all the possible values of bits for the hours\\n        for (int i = 0, j = n; i <= n; i++, j--){\\n            for (auto h: bits[i]) {\\n                if (h > 11) break;\\n                // getting all the remaining bits for the minutes\\n                for (auto m: bits[j]) {\\n                    res.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999166,
                "title": "solution-using-bit-count",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        result = []\\n        \\n        for hour in range(12):\\n            for minute in range(60):\\n                if (bin(hour).count(\"1\") + bin(minute).count(\"1\")) == turnedOn:\\n                    result.append(str(hour) + \":\" + str(minute).zfill(2))\\n        \\n        return result\\n```\\n\\nUsed bit().count() / Could be replaced with bit_count() in python 3.10. remember to zfill to match the format",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        result = []\\n        \\n        for hour in range(12):\\n            for minute in range(60):\\n                if (bin(hour).count(\"1\") + bin(minute).count(\"1\")) == turnedOn:\\n                    result.append(str(hour) + \":\" + str(minute).zfill(2))\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969790,
                "title": "5-lines-python-solution-85-faster-memory-less-than-75",
                "content": "```\\nclass Solution:\\n    def readBinaryWatch(self, n: int) -> List[str]:\\n        H=[1,2,4,8] ; M=[1,2,4,8,16,32] ; ans=[]\\n        for i in range(n+1):\\n            for x,y in product(combinations(H,i),combinations(M,n-i)):\\n                if sum(x)<12 and sum(y)<60: ans.append(str(sum(x))+\\':\\'+str(sum(y)).zfill(2))\\n        return ans\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, n: int) -> List[str]:\\n        H=[1,2,4,8] ; M=[1,2,4,8,16,32] ; ans=[]\\n        for i in range(n+1):\\n            for x,y in product(combinations(H,i),combinations(M,n-i)):\\n                if sum(x)<12 and sum(y)<60: ans.append(str(sum(x))+\\':\\'+str(sum(y)).zfill(2))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872844,
                "title": "python-backtracking",
                "content": "It\\'s a combination problem `C(10, k)`, find all possible combs for given turn ons LEDs, and export the result only if the time is less or eqal than `11:59`.\\n\\n```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        \\n        def get_repr(arr):\\n            \\n            hours = minutes = 0\\n            \\n            for bit in arr:\\n                \\n                if bit <= 5:\\n                    \\n                    minutes += 2 ** bit\\n                    \\n                else:\\n                    \\n                    hours += 2 ** (bit - 6)\\n                \\n                if minutes > 59 or hours > 11:\\n                    \\n                    return None\\n                \\n            return str(hours).lstrip() + \":\" + str(minutes).zfill(2)\\n        \\n        def backtrack(i, arr):\\n            \\n            if len(arr) == turnedOn:\\n                \\n                rep = get_repr(arr)\\n                    \\n                if rep:\\n                    \\n                    ans.append(rep)\\n                \\n            else:\\n                \\n                for j in range(i, 10):\\n                    \\n                    arr.append(j)\\n                    \\n                    backtrack(j + 1, arr)\\n                    \\n                    arr.pop()\\n                    \\n        # edge case\\n        if turnedOn > 8:\\n            return []\\n        \\n        ans = []\\n        \\n        backtrack(0, [])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\\n        \\n        def get_repr(arr):\\n            \\n            hours = minutes = 0\\n            \\n            for bit in arr:\\n                \\n                if bit <= 5:\\n                    \\n                    minutes += 2 ** bit\\n                    \\n                else:\\n                    \\n                    hours += 2 ** (bit - 6)\\n                \\n                if minutes > 59 or hours > 11:\\n                    \\n                    return None\\n                \\n            return str(hours).lstrip() + \":\" + str(minutes).zfill(2)\\n        \\n        def backtrack(i, arr):\\n            \\n            if len(arr) == turnedOn:\\n                \\n                rep = get_repr(arr)\\n                    \\n                if rep:\\n                    \\n                    ans.append(rep)\\n                \\n            else:\\n                \\n                for j in range(i, 10):\\n                    \\n                    arr.append(j)\\n                    \\n                    backtrack(j + 1, arr)\\n                    \\n                    arr.pop()\\n                    \\n        # edge case\\n        if turnedOn > 8:\\n            return []\\n        \\n        ans = []\\n        \\n        backtrack(0, [])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823037,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> ans ;\\n        if(turnedOn == 0) {\\n            ans.push_back(\"0:00\");\\n            return ans;\\n        }\\n        else if (turnedOn > 8) { return ans; }\\n       bitset<4> hh;\\n       bitset<6> min;\\n       for(int i = 0; i < 12; i++) { \\n           hh = i;       \\n           for(int j = 0; j < 60; j++) {\\n               min = j;\\n               if( hh.count() + min.count() == turnedOn) {\\n                   string s = to_string(i) + \":\" + (j < 10 ? \"0\" + to_string(j) : to_string(j));\\n                   ans.push_back(s);\\n               }       \\n           }\\n       }   \\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> readBinaryWatch(int turnedOn) {\\n        vector<string> ans ;\\n        if(turnedOn == 0) {\\n            ans.push_back(\"0:00\");\\n            return ans;\\n        }\\n        else if (turnedOn > 8) { return ans; }\\n       bitset<4> hh;\\n       bitset<6> min;\\n       for(int i = 0; i < 12; i++) { \\n           hh = i;       \\n           for(int j = 0; j < 60; j++) {\\n               min = j;\\n               if( hh.count() + min.count() == turnedOn) {\\n                   string s = to_string(i) + \":\" + (j < 10 ? \"0\" + to_string(j) : to_string(j));\\n                   ans.push_back(s);\\n               }       \\n           }\\n       }   \\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1571675,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1566789,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1736039,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1576252,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1575970,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1571678,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1575015,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1576022,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1573114,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1566508,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1571675,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1566789,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1736039,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1576252,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1575970,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1571678,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1575015,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1576022,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1573114,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1566508,
                "content": [
                    {
                        "username": "kai99",
                        "content": "First of all, IMO I don't think this problem should be easy, it should be medium, anyways.\\n\\nThis problem could be modeled to getting all unique permutations of a string. There's a more efficient solution for this problem than the regular backtracking algorithm using hashmap to count the frequencies of each occurrence of an element.\\n\\nFor example if n = 2, then we have the input as 0000000011, we run the string permutation algorithm that generate all the unique permutations of this string, then we get the time representation."
                    },
                    {
                        "username": "OHTHEMISERY",
                        "content": "[@bodhisatta1999](/bodhisatta1999) It is because the problem is intended to be solved with brute force, not backtracking"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "I was also thnking that this should be in Medium not easy"
                    },
                    {
                        "username": "ulyx",
                        "content": "My code cannot pass input 2, the output:\\n\\nInput: 2\\n\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"10:00\",\"12:00\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nThe only difference is my output has 12:00 but the expected has not. \\nSo the problem is: 2 leds on 4 and 8 can represent 12:00, why the answer does't have it?"
                    },
                    {
                        "username": "Rakibul_Nayeem",
                        "content": "It mentioned that hours will be between 0 and 11, (0-11), in the problem."
                    },
                    {
                        "username": "pete88pete",
                        "content": "What is with that watch example in the photo, makes no sense!"
                    },
                    {
                        "username": "Brajesh76",
                        "content": "Why this has more dislikes than like?"
                    },
                    {
                        "username": "user0184a",
                        "content": "[@gururaj88](/gururaj88) 5 minutes is the expectation of an easy problem? \\n"
                    },
                    {
                        "username": "gururaj88",
                        "content": "its a nice problem .. but the difficulty is mismatched.. this is clearly medium level..\\n\\nyou cant expect someone to solve this in 5min (expectation of an easy level)"
                    },
                    {
                        "username": "mr_ocean719",
                        "content": "I did solve this problem, but there\\'s a case that I do not understand. In the case of n = 2, one of the bit patterns that can be produced on the watch is 0b1100 00 0000. This works out to 12:00 pm. In the test case of n = 2, this value is not contained in the expected output. Why?"
                    },
                    {
                        "username": "user2049D",
                        "content": "12:00 PM is 00:00 AM\\n12:00 AM is 00:00 PM"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I spent a lot of time debugging why 12:00 is not valid for the \"2\" input. After reading some of the comments here, I realized that we are talking about a 12 hour clock, not a 24 hour clock."
                    },
                    {
                        "username": "adfel70",
                        "content": "In the case of 2 leds on, my code returns that time \\'12:00\\' but in the expected list that time is missing.\\n12 in conducted of led 4 and led 8, so why is it not correct to appear in the answer?\\n\\nSincerely\\n"
                    },
                    {
                        "username": "ssshra",
                        "content": "Take a look on the watch picture, there is PM indicator, it means that we have hour values - 0 till 11"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "because we need to represent hour from 0 to 11 "
                    },
                    {
                        "username": "dblokhin",
                        "content": "It\\'s a good problem actually. Why is it so downvoted?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "My guess is that the difficulty rating is not very fair. I would definitely consider it medium (at least the way I did it, which was just backtracking all permutations)"
                    },
                    {
                        "username": "felachu",
                        "content": "The difference between the output and the expected result below is \"12:00\", my output has \"12:00\" and the expected result don\\'t have it.\\nBut if you use the two bits for the first two bits of the hour part, you will get \"12:00\" like this\\n1100:000000 = 8 +4+0+0 : 00 = 12:00\\nis there something I missed?\\nInput:\\n2\\nOutput:\\n[\"12:00\",\"10:00\",\"9:00\",\"8:32\",\"8:16\",\"8:08\",\"8:04\",\"8:02\",\"8:01\",\"6:00\",\"5:00\",\"4:32\",\"4:16\",\"4:08\",\"4:04\",\"4:02\",\"4:01\",\"3:00\",\"2:32\",\"2:16\",\"2:08\",\"2:04\",\"2:02\",\"2:01\",\"1:32\",\"1:16\",\"1:08\",\"1:04\",\"1:02\",\"1:01\",\"0:48\",\"0:40\",\"0:36\",\"0:34\",\"0:33\",\"0:24\",\"0:20\",\"0:18\",\"0:17\",\"0:12\",\"0:10\",\"0:09\",\"0:06\",\"0:05\",\"0:03\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "sxmbaka",
                        "content": "You missed the constraints for the hour, it clearly says __\"hours (0-11)\"__."
                    },
                    {
                        "username": "thiepha",
                        "content": "The test case for n = 2 is incorrect.\\nMy output:[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"3:00\",\"5:00\",\"6:00\",\"9:00\",\"10:00\",\"12:00\"]\\n\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]\\n\\nAs you can see \"12:00\" should be included but it is missed from expected result, and it evaluated my result as incorrect one.\\nIt is a wrong test case."
                    },
                    {
                        "username": "BLOCKS",
                        "content": "0-11 hours was mentioned in the question"
                    }
                ]
            },
            {
                "id": 1576237,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 1969827,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 1574167,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 1571674,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 1571676,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 1571677,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 2075857,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 2040006,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 2018869,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            },
            {
                "id": 2016155,
                "content": [
                    {
                        "username": "jhackgpu",
                        "content": "Is this European or something? WTF"
                    },
                    {
                        "username": "Chino05",
                        "content": "I\\'m confused here at to why in the example input for 9 the output is an empty list"
                    },
                    {
                        "username": "user1889GX",
                        "content": "See there are 4 bits for hour and 6 bits for minutes and we have only 12 hours in this case only 11 as mentioned in problem as there is PM . and only 60 minutes .\\n\\nNow if we enable 9 bits or turned-on 9 lights in any combination.\\n\\ne.g all 4 form hours and rest 5 from minutes check how many hours or minutes it would be .\\nit would be more that 12 hours and more that 60 minutes in some case based on how many lights we turned on. \\n\\nthe max lights we can turned on is 7 to get valid hour and minutes. hence 9 is returning empty.\\n\\nThis is my understanding so far"
                    },
                    {
                        "username": "varab",
                        "content": "I love https://leetcode.com/problems/binary-watch/discuss/768896/C%2B%2B-solution-in-O(1)-time-and-O(1)-space-100-better\\nthis solution, which is O(1) space and time.\\nOthers have provided more like recursion solution, which is always a f(n) = 2^n.\\n\\nEither ways, I don\\'t see this as easier one. Or has the level changed these days ?"
                    },
                    {
                        "username": "cyan11",
                        "content": "Submission Result: Wrong Answer More Details \\n\\nInput:\\n2\\nOutput:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\",\"12:00\"]\\nExpected:\\n[\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:10\",\"0:12\",\"0:17\",\"0:18\",\"0:20\",\"0:24\",\"0:33\",\"0:34\",\"0:36\",\"0:40\",\"0:48\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"3:00\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"5:00\",\"6:00\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"9:00\",\"10:00\"]"
                    },
                    {
                        "username": "tc25898",
                        "content": "[0-1024) represents all possible binary cases(2 to the power of 10) for this question.\\nSee post below."
                    },
                    {
                        "username": "HelloKenLee",
                        "content": "I think the order of ouputs matters..."
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think problem should be at least in medium category.  To solve this problem you should know binary numbers, recursion, array, dynamic programming."
                    },
                    {
                        "username": "vvviktor",
                        "content": "Was really helpful backtracking adventure for me."
                    },
                    {
                        "username": "aniket_andhale",
                        "content": "turnedOn is not a good idea to name a variable"
                    },
                    {
                        "username": "dnox",
                        "content": "The most medium easy I\\'ve ever had"
                    },
                    {
                        "username": "dnox",
                        "content": "the hardest easy maybe?"
                    }
                ]
            }
        ]
    }
]