[
    {
        "title": "Find the String with LCP",
        "question_content": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\n\tlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an&nbsp;n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.\n&nbsp;\nExample 1:\n\nInput: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".\n\nExample 2:\n\nInput: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\". \n\nExample 3:\n\nInput: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists.\n\n&nbsp;\nConstraints:\n\n\t1 <= n ==&nbsp;lcp.length == lcp[i].length&nbsp;<= 1000\n\t0 <= lcp[i][j] <= n",
        "solutions": [
            {
                "id": 3203816,
                "title": "java-c-python-check-same-characters",
                "content": "# **Intuition**\\nIf `lcp[i][j] > 0`, then `A[i] = A[j]`\\nIf `lcp[i][j] == 0`, then `A[i] != A[j]`\\n<br>\\n\\n# **Explanation**\\nWe follow the intution above,\\nfind the same `A[i]` and assign them to the same character `c`.\\nthen construct the whole array `A`.\\nWe should use at most 26 different elements.\\n\\nThen we check if this `A` is valid for `lcp`.\\nIf `A[i] == A[j]`,\\nthen `lcp[i][j] = lcp[i+1][j+1] + 1`\\n\\nIf not valid, return empty string.\\nIf valid, then we transform `A` to string and return it.\\n<br>\\n\\n# **Complexity**\\nTime `O(n^2)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length, c = 0, A[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] > 0) continue;\\n            if (++c > 26) return \"\";\\n            for (int j = i; j < n; ++j)\\n                if (lcp[i][j] > 0)\\n                    A[j] = c;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int v = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;\\n                v = A[i] == A[j] ? v + 1 : 0;\\n                if (lcp[i][j] != v) return \"\";\\n            }\\n        }\\n        StringBuilder res = new StringBuilder();\\n        for (int a : A)\\n            res.append((char)(\\'a\\' + a - 1));\\n        return res.toString();\\n    }\\n```\\n**C++**\\n```cpp\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size(), c = 0;\\n        vector<int> A(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i]) continue;\\n            if (++c > 26) return \"\";\\n            for (int j = i; j < n; ++j)\\n                if (lcp[i][j] > 0)\\n                    A[j] = c;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int v = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;\\n                v = A[i] == A[j] ? v + 1 : 0;\\n                if (lcp[i][j] != v) return \"\";\\n            }\\n        }\\n        string res = \"\";\\n        for (int c : A)\\n            res += \\'a\\' + c - 1;\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        A = [0] * n\\n        c = 1\\n        for i in range(n):\\n            if A[i]: continue\\n            if c > 26: return \\'\\'\\n            for j in range(i, n):\\n                if lcp[i][j]:\\n                    A[j] = c\\n            c += 1\\n        for i in range(n):\\n            for j in range(n):\\n                v = lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 0\\n                v = v + 1 if A[i] == A[j] else 0\\n                if lcp[i][j] != v:\\n                    return \\'\\'\\n        return \\'\\'.join(chr(ord(\\'a\\') + i - 1) for i in A)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length, c = 0, A[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] > 0) continue;\\n            if (++c > 26) return \"\";\\n            for (int j = i; j < n; ++j)\\n                if (lcp[i][j] > 0)\\n                    A[j] = c;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int v = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;\\n                v = A[i] == A[j] ? v + 1 : 0;\\n                if (lcp[i][j] != v) return \"\";\\n            }\\n        }\\n        StringBuilder res = new StringBuilder();\\n        for (int a : A)\\n            res.append((char)(\\'a\\' + a - 1));\\n        return res.toString();\\n    }\\n```\n```cpp\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size(), c = 0;\\n        vector<int> A(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i]) continue;\\n            if (++c > 26) return \"\";\\n            for (int j = i; j < n; ++j)\\n                if (lcp[i][j] > 0)\\n                    A[j] = c;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int v = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;\\n                v = A[i] == A[j] ? v + 1 : 0;\\n                if (lcp[i][j] != v) return \"\";\\n            }\\n        }\\n        string res = \"\";\\n        for (int c : A)\\n            res += \\'a\\' + c - 1;\\n        return res;\\n    }\\n```\n```py\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        A = [0] * n\\n        c = 1\\n        for i in range(n):\\n            if A[i]: continue\\n            if c > 26: return \\'\\'\\n            for j in range(i, n):\\n                if lcp[i][j]:\\n                    A[j] = c\\n            c += 1\\n        for i in range(n):\\n            for j in range(n):\\n                v = lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 0\\n                v = v + 1 if A[i] == A[j] else 0\\n                if lcp[i][j] != v:\\n                    return \\'\\'\\n        return \\'\\'.join(chr(ord(\\'a\\') + i - 1) for i in A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3203795,
                "title": "c-fast-o-n-2-using-generative-algorithm-build-candidate-then-verify",
                "content": "Approach:\\n* Initially, we have `n` `a` as the initial candidate string\\n* we use each row of `lcp` matrix to determine if we should bump the character up\\n* if `lcp[r][c]` == `0`, and the char do not equal, then we must increase it to the next available char.\\n* If any char is beyond `z`, then we return impossible.\\n\\nThen, we calculate the would be `lcp` as the `would` matrix, using Dynamic Programming.\\nComparing that with the original `lcp`, and if they are inconsistent. return impossible.\\n\\nOtherwise, we return the built `cand` string.\\n\\n```c++\\nclass Solution {\\n public:\\n  string findTheString(vector<vector<int>> &lcp) {\\n    const int n = lcp.size();\\n    string cand = \"\";\\n    for (int i = 0; i < n; i++)\\n      cand += \"a\";\\n    // now we have cand as a string of length n with all a\\'s\\n\\n    for (int r = 0; r < n; r++) {\\n      for (int c = r; c < n; c++) {\\n        if (lcp[r][c] == 0 && cand[c] == cand[r])\\n          cand[c]++; // lcp is 0, and the chars equal, bump it up\\n      }\\n    }\\n\\n    // if the cand string is beyond `z`, then impossible.\\n    for (char ch : cand)\\n      if (ch > \\'z\\')\\n        return \"\";\\n\\n    // using DP to build the would lcp matrix\\n    int would[n + 1][n + 1];\\n    memset(would, 0, sizeof(would));\\n    for (int r = n - 1; r >= 0; r--) {\\n      for (int c = n - 1; c >= 0; c--) {\\n        if (cand[r] == cand[c]) {\\n          would[r][c] = 1 + would[r + 1][c + 1];\\n        }\\n      }\\n    }\\n\\n    // the `would` matrix we built, must equal to the original matrix given by the problem.\\n    for (int r = 0; r < n; r++)\\n      for (int c = 0; c < n; c++)\\n        if (would[r][c] != lcp[r][c])\\n          return \"\";\\n\\n    return cand;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nclass Solution {\\n public:\\n  string findTheString(vector<vector<int>> &lcp) {\\n    const int n = lcp.size();\\n    string cand = \"\";\\n    for (int i = 0; i < n; i++)\\n      cand += \"a\";\\n    // now we have cand as a string of length n with all a\\'s\\n\\n    for (int r = 0; r < n; r++) {\\n      for (int c = r; c < n; c++) {\\n        if (lcp[r][c] == 0 && cand[c] == cand[r])\\n          cand[c]++; // lcp is 0, and the chars equal, bump it up\\n      }\\n    }\\n\\n    // if the cand string is beyond `z`, then impossible.\\n    for (char ch : cand)\\n      if (ch > \\'z\\')\\n        return \"\";\\n\\n    // using DP to build the would lcp matrix\\n    int would[n + 1][n + 1];\\n    memset(would, 0, sizeof(would));\\n    for (int r = n - 1; r >= 0; r--) {\\n      for (int c = n - 1; c >= 0; c--) {\\n        if (cand[r] == cand[c]) {\\n          would[r][c] = 1 + would[r + 1][c + 1];\\n        }\\n      }\\n    }\\n\\n    // the `would` matrix we built, must equal to the original matrix given by the problem.\\n    for (int r = 0; r < n; r++)\\n      for (int c = 0; c < n; c++)\\n        if (would[r][c] != lcp[r][c])\\n          return \"\";\\n\\n    return cand;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203712,
                "title": "java-solution-with-explanation",
                "content": "First, construct a potential answer. The first character would always be \\u2018a\\u2019. Next we find the other characters by iterating from 1 to n - 1\\n\\nIn each iteration, we check values j from 0 to i - 1. If lcp[I][j] is greater than 0, it implies that i and j are same character so we can terminate the inner loop. If we don\\u2019t find any j such that lcp[I][j] is greater than 0, we can set the ith character to the next unvisited character as this satisfies the lexicographical minimum constraints. Obviously if this character is greater than \\u2018z\\u2019, then we would return an empty string since we would need more than 26 characters to form such lcp array.\\n\\nOnce we have gotten a potential string that could serve as the answer, the next step would be validating if the entire lcp is correct. We can do this by constructing our own lcp from the potential string.\\n\\nWe can construct this using dynamic programming iterating backwards. If ith and jth character are different, then dp[i][j] is 0. Otherwise dp[I][j] is 1 + dp[i + 1][j + 1].  \\n\\nTime and Space complexity is O(n^2)\\n\\n\\nPlease upvote if you like the solution :)\\n\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204109,
                "title": "easy-greedy-dp-video-solution-intuitive-approach",
                "content": "# Intuition\\nIn order to form the smallest lexicographic string we always would be starting the result with \\'a\\'. any index $j>0$ (0 base indexing and index 0 has already been set to \\'a\\'), would be having the value at index $i$ $(i<j)$ if $lcp[i][j]>0$, else assign it the minimum unutilized character. \\n\\n\\nVideo solution: https://youtu.be/BotxOAPrYnY\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. assign character \\'a\\' to the 0th index, let\\'s call the string as res \\n2. run loop for $i=1$ to size-1\\n3. check for the leftmost index j $(j<i)$ such that $lcp[i][j]>0$ if such an index exist then assign $res[i]=res[j]$\\n4. If such an index is not found then assign minimum unused character to $res[i]$\\n5. In order to verify if the string is valid, construct a longest similar suffix dp array.\\n6. If the dp array is exactly equal to the lcp then answer constructed is valid else return empty string (for invalid answer)\\n# Complexity\\n- Time complexity:\\n $$O(n^2)$$ \\n\\n- Space complexity:\\n $$O(n^2)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        string res(n,\\'a\\');\\n        res[0]=\\'a\\';     \\n        char mn=\\'b\\';\\n        for(int i=1;i<n;i++)\\n        {\\n            bool set=false;\\n            for(int j=0;j<i;j++){\\n                if(lcp[i][j]!=0){\\n                    set=true;\\n                    res[i]=res[j];\\n                    break;\\n                }\\n            }\\n            if(!set)    res[i]=mn++;\\n        }\\n        for(int i=0;i<n;i++)    if(res[i]>\\'z\\')  return \"\";\\n        vector<vector<int>> dp(n,vector<int>(n,0));     // suffix count\\n\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=n-1;j>=0;j--)\\n                if(res[i]==res[j])  dp[i][j]=1+((i<n-1 && j<n-1)?dp[i+1][j+1]:0);\\n        \\n        for(int i=0;i<n;i++)        // now my 2 arrays should be equal\\n            for(int j=0;j<n;j++)\\n                if(dp[i][j]!=lcp[i][j]) return \"\";\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        string res(n,\\'a\\');\\n        res[0]=\\'a\\';     \\n        char mn=\\'b\\';\\n        for(int i=1;i<n;i++)\\n        {\\n            bool set=false;\\n            for(int j=0;j<i;j++){\\n                if(lcp[i][j]!=0){\\n                    set=true;\\n                    res[i]=res[j];\\n                    break;\\n                }\\n            }\\n            if(!set)    res[i]=mn++;\\n        }\\n        for(int i=0;i<n;i++)    if(res[i]>\\'z\\')  return \"\";\\n        vector<vector<int>> dp(n,vector<int>(n,0));     // suffix count\\n\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=n-1;j>=0;j--)\\n                if(res[i]==res[j])  dp[i][j]=1+((i<n-1 && j<n-1)?dp[i+1][j+1]:0);\\n        \\n        for(int i=0;i<n;i++)        // now my 2 arrays should be equal\\n            for(int j=0;j<n;j++)\\n                if(dp[i][j]!=lcp[i][j]) return \"\";\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204597,
                "title": "python3-union-find-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnion find structure helps a lot with combining the same chars and then checking for contradictions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Use rules from lcp array to unify same symbols. Simultaneously checking for inconsistencies.\\nStep 2: Check all conditions fulfilled and self-consistent.\\nStep 3: Use union find structure to fill answer with chars.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        uf = [i for i in range(n)]\\n        \\n        def find(x):\\n            if uf[x] == x:\\n                return x\\n            uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        #  Step 1: Use rules from lcp array to unify same symbols. Simultaneously checking for inconsistencies.\\n        for i in range(n):\\n            # bc symbols are equal to themselves\\n            if lcp[i][i] + i != n:\\n                return \"\"\\n            for j in range(i + 1, n):\\n                # border and symmetry check\\n                if j + lcp[i][j] > n or lcp[i][j] != lcp[j][i]:\\n                    return \"\"\\n                \\n                if lcp[i][j]:\\n                    if j + 1 < n and lcp[i + 1][j + 1] + 1 != lcp[i][j]:\\n                        return \"\"\\n        \\n                    uf[i] = uf[j] = min(find(i), find(j))\\n                    \\n        #  Step 2: Check all conditions fulfilled and self-consistent.\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                # cases: need to be unequal, but in reality opposite\\n                if lcp[i][j] == 0 and find(i) == find(j):\\n                    return \"\"\\n                if lcp[i][j] > 0 and lcp[i][j] + j < n and find(i + lcp[i][j]) == find(j + lcp[i][j]):\\n                    return \"\"\\n                \\n        #  Step 3: Use union find structure to fill answer with chars.\\n        ret = [None] * n\\n        letter = 97  # ASCII code of \\'a\\' letter\\n        for i in range(len(ret)):\\n            val = find(i)\\n            if ret[val] is not None:\\n                ret[i] = ret[val]\\n            else:\\n                # if needed more letters, we can\\'t afford it, as \\'z\\' has 122 ASCII code\\n                if letter == 123:\\n                    return \"\"\\n                ret[i] = chr(letter)\\n                letter += 1\\n        return \\'\\'.join(ret)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        uf = [i for i in range(n)]\\n        \\n        def find(x):\\n            if uf[x] == x:\\n                return x\\n            uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        #  Step 1: Use rules from lcp array to unify same symbols. Simultaneously checking for inconsistencies.\\n        for i in range(n):\\n            # bc symbols are equal to themselves\\n            if lcp[i][i] + i != n:\\n                return \"\"\\n            for j in range(i + 1, n):\\n                # border and symmetry check\\n                if j + lcp[i][j] > n or lcp[i][j] != lcp[j][i]:\\n                    return \"\"\\n                \\n                if lcp[i][j]:\\n                    if j + 1 < n and lcp[i + 1][j + 1] + 1 != lcp[i][j]:\\n                        return \"\"\\n        \\n                    uf[i] = uf[j] = min(find(i), find(j))\\n                    \\n        #  Step 2: Check all conditions fulfilled and self-consistent.\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                # cases: need to be unequal, but in reality opposite\\n                if lcp[i][j] == 0 and find(i) == find(j):\\n                    return \"\"\\n                if lcp[i][j] > 0 and lcp[i][j] + j < n and find(i + lcp[i][j]) == find(j + lcp[i][j]):\\n                    return \"\"\\n                \\n        #  Step 3: Use union find structure to fill answer with chars.\\n        ret = [None] * n\\n        letter = 97  # ASCII code of \\'a\\' letter\\n        for i in range(len(ret)):\\n            val = find(i)\\n            if ret[val] is not None:\\n                ret[i] = ret[val]\\n            else:\\n                # if needed more letters, we can\\'t afford it, as \\'z\\' has 122 ASCII code\\n                if letter == 123:\\n                    return \"\"\\n                ret[i] = chr(letter)\\n                letter += 1\\n        return \\'\\'.join(ret)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215651,
                "title": "greedy-z-function",
                "content": "First, we greedily construct our candidate string. Then, we validate that string against the `lcp` matrix.\\n\\nFor each position `i`, we use `lcp` to check if it matches any previous character `j`. \\n\\nIf yes, we use the previous character. If not, we assign the next available character `ch`.\\n\\n> At this stage, we do not care about repetitions - we only check if `lcp[i][j] > 0`.\\n\\nFor the validation, we can build an LCP array from the constructed string, and compare it to the input.\\n\\nNote that the input `lcp` is actually a matrix of Z-functions for each starting position `i`.  Z-function can be computed in O(n).\\n\\nThere is, however, an easier way to check the matrix. For that, we reverse-engineer how that matrix was populated.\\n\\nIt was probably populated using DP, and it has a diagonal structure.\\n\\nIf `lcp[i][j] == k`, then `lcp[i + 1][j + 1] == k -1`, and so on till `lcp[i + k - 1][j + k - 1] == 1`.\\n\\nTherefore, if `s[i] == s[j]`, then `lcp[i][j] == 1 + lcp[i + 1][j + 1]`.\\n\\n## Diagonal\\n**C++**\\n```cpp\\nstring findTheString(vector<vector<int>>& lcp) {\\n    int n = lcp.size(), ch = \\'a\\';\\n    string res;\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j <= i && res.size() == i; ++j)\\n            if (lcp[i][j])\\n                res.push_back(j < i ? res[j] : ch++);\\n        if  (res.back() > \\'z\\')\\n            return \"\";\\n    }\\n    for (int i = 0; i < n; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int val = res[i] == res[j];\\n            if (val && i + 1 < n && j + 1 < n)\\n                val += lcp[i + 1][j + 1];\\n            if (lcp[i][j] != val)\\n                return \"\";\\n        }\\n    return res;\\n}\\n```\\n\\n## Z-function\\n\\n**C++**\\n```cpp\\nvector<int> z_function(string &s, int start) {\\n    int n = s.size() - start;\\n    vector<int> z(s.size()); \\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n        if (i <= r)\\n            z[i + start] = min(r - i + 1, z[i - l + start]);\\n        while (i + z[i + start] < n && s[z[i + start] + start] == s[i + z[ i+ start] + start])\\n            ++z[i + start];\\n        if (i + z[i+ start] - 1 > r)\\n            l = i, r = i + z[i+ start] - 1;\\n    }\\n    return z;\\n}\\nstring findTheString(vector<vector<int>>& lcp) {\\n    int n = lcp.size(), ch = \\'a\\';\\n    string res;\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j <= i && res.size() == i; ++j)\\n            if (lcp[i][j])\\n                res.push_back(j < i ? res[j] : ch++);\\n        if  (lcp[i][i] != n - i || res.back() > \\'z\\')\\n            return \"\";\\n    }\\n    for (int i = 0; i < n; ++i) {\\n        auto z = z_function(res, i);\\n        for (int j = i + 1; j < n; ++j)\\n            if (lcp[i][j] != lcp[j][i] || lcp[i][j] != z[j])\\n                return \"\";\\n    }  \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring findTheString(vector<vector<int>>& lcp) {\\n    int n = lcp.size(), ch = \\'a\\';\\n    string res;\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j <= i && res.size() == i; ++j)\\n            if (lcp[i][j])\\n                res.push_back(j < i ? res[j] : ch++);\\n        if  (res.back() > \\'z\\')\\n            return \"\";\\n    }\\n    for (int i = 0; i < n; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int val = res[i] == res[j];\\n            if (val && i + 1 < n && j + 1 < n)\\n                val += lcp[i + 1][j + 1];\\n            if (lcp[i][j] != val)\\n                return \"\";\\n        }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> z_function(string &s, int start) {\\n    int n = s.size() - start;\\n    vector<int> z(s.size()); \\n    for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n        if (i <= r)\\n            z[i + start] = min(r - i + 1, z[i - l + start]);\\n        while (i + z[i + start] < n && s[z[i + start] + start] == s[i + z[ i+ start] + start])\\n            ++z[i + start];\\n        if (i + z[i+ start] - 1 > r)\\n            l = i, r = i + z[i+ start] - 1;\\n    }\\n    return z;\\n}\\nstring findTheString(vector<vector<int>>& lcp) {\\n    int n = lcp.size(), ch = \\'a\\';\\n    string res;\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j <= i && res.size() == i; ++j)\\n            if (lcp[i][j])\\n                res.push_back(j < i ? res[j] : ch++);\\n        if  (lcp[i][i] != n - i || res.back() > \\'z\\')\\n            return \"\";\\n    }\\n    for (int i = 0; i < n; ++i) {\\n        auto z = z_function(res, i);\\n        for (int j = i + 1; j < n; ++j)\\n            if (lcp[i][j] != lcp[j][i] || lcp[i][j] != z[j])\\n                return \"\";\\n    }  \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3207846,
                "title": "support-an-omissive-test-case",
                "content": "Some code([example1](https://leetcode.com/submissions/detail/900802586/), [example2](https://leetcode.com/submissions/detail/901252948/)) only checks this two constraints:\\n\\n1. if lcp[i][j] == 0 then str[i] != str[j]\\n2. if lcp[i][j] < n - j then str[i + lcp[i][j]] != str[j + lcp[i][j]]\\n\\nbut also got Accepted! \\n\\nHere is a new case which can make it get Wrong Answer.\\n\\n```\\n[[5,0,2,0,0],[0,4,0,0,0],[2,0,3,0,0],[0,0,0,2,0],[0,0,0,0,1]]\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n[[5,0,2,0,0],[0,4,0,0,0],[2,0,3,0,0],[0,0,0,2,0],[0,0,0,0,1]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203810,
                "title": "python3-tabu-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/485c537c6fa9056ce656959ea352d2a68cef473f) for solutions of weekly 333. \\n\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        ans = []\\n        for i in range(n): \\n            tabu = set()\\n            for j in range(i): \\n                if lcp[i][j]: \\n                    ans.append(ans[j])\\n                    break\\n                else: tabu.add(ans[j])\\n            else: \\n                for ch in ascii_lowercase: \\n                    if ch not in tabu: \\n                        ans.append(ch)\\n                        break\\n                else: return \"\"\\n        dp = [[0]*n for _ in range(n)]\\n        for i in range(n-1, -1, -1): \\n            for j in range(n-1, -1, -1): \\n                if ans[i] == ans[j]: \\n                    if i == n-1 or j == n-1: dp[i][j] = 1\\n                    else: dp[i][j] = 1 + dp[i+1][j+1]\\n                if dp[i][j] != lcp[i][j]: return \"\"\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        ans = []\\n        for i in range(n): \\n            tabu = set()\\n            for j in range(i): \\n                if lcp[i][j]: \\n                    ans.append(ans[j])\\n                    break\\n                else: tabu.add(ans[j])\\n            else: \\n                for ch in ascii_lowercase: \\n                    if ch not in tabu: \\n                        ans.append(ch)\\n                        break\\n                else: return \"\"\\n        dp = [[0]*n for _ in range(n)]\\n        for i in range(n-1, -1, -1): \\n            for j in range(n-1, -1, -1): \\n                if ans[i] == ans[j]: \\n                    if i == n-1 or j == n-1: dp[i][j] = 1\\n                    else: dp[i][j] = 1 + dp[i+1][j+1]\\n                if dp[i][j] != lcp[i][j]: return \"\"\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203739,
                "title": "c-rust-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO( N * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n// Thanks https://leetcode.com/Rook_Lift/ for point out that \\n//verification was actually O(N * N * N), instead of O(N & N).\\n//It was improved to achieve O(N * N).\\n// Rust solution was also included. \\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        vector<char> ret(n, \\' \\');\\n        \\n        char c = \\'a\\';\\n        for (int i = 0; i < n; ++i) {\\n            if (ret[i] != \\' \\') continue;\\n                \\n            if (c > \\'z\\') return \"\";\\n            ret[i] = c;\\n            c += 1;\\n            \\n            for (int k = i + 1; k < n; ++k) {\\n                if (lcp[i][k] != 0) ret[k] = ret[i];\\n            }\\n        }\\n        \\n        for (int k = 0; k < n; ++k) {\\n            for (int i = n - 1 - k; i >= 0; --i) {\\n                int a = 0;\\n                if (ret[i] == ret[i + k]) {\\n                    a = 1;\\n                    if (i + k + 1 < n) a += lcp[i + 1][i + k + 1]; \\n                }\\n                if (lcp[i][i + k] != a or lcp[i + k][i] != a) return \"\";\\n            } \\n        }\\n        \\n        string s;\\n        for (auto &c: ret) s += c;\\n        return s;\\n    }\\n};\\n```\\n~~~\\n// Rust\\nimpl Solution {\\n    pub fn find_the_string(lcp: Vec<Vec<i32>>) -> String {\\n        let n = lcp.len();\\n        let mut data = vec![\\' \\'; n];\\n\\n        let mut c = \\'a\\';\\n        for i in 0 .. n {\\n            if data[i] != \\' \\' { continue }\\n            if c > \\'z\\' { return String::new() }\\n            \\n            data[i] = c;\\n            c = (c as u8 + 1) as char;\\n\\n            for k in i + 1 .. n {\\n                if lcp[i][k] != 0 { data[k] = data[i]; }\\n            } \\n        }\\n\\n        for k in 0 .. n {\\n            for i in (0 .. n - k).rev() {\\n                let mut a = 0;\\n                if data[i] == data[i + k] {\\n                    a = 1;\\n                    if i + k + 1 < n { a += lcp[i + 1][i + k + 1]; }\\n                }\\n                if lcp[i][i + k] != a || lcp[i + k][i] != a { return String::new() }\\n            }\\n        }\\n\\n        data.into_iter().collect()\\n    }\\n}\\n~~~\\n\\n",
                "solutionTags": [
                    "C++",
                    "Rust"
                ],
                "code": "```\\n// Thanks https://leetcode.com/Rook_Lift/ for point out that \\n//verification was actually O(N * N * N), instead of O(N & N).\\n//It was improved to achieve O(N * N).\\n// Rust solution was also included. \\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        vector<char> ret(n, \\' \\');\\n        \\n        char c = \\'a\\';\\n        for (int i = 0; i < n; ++i) {\\n            if (ret[i] != \\' \\') continue;\\n                \\n            if (c > \\'z\\') return \"\";\\n            ret[i] = c;\\n            c += 1;\\n            \\n            for (int k = i + 1; k < n; ++k) {\\n                if (lcp[i][k] != 0) ret[k] = ret[i];\\n            }\\n        }\\n        \\n        for (int k = 0; k < n; ++k) {\\n            for (int i = n - 1 - k; i >= 0; --i) {\\n                int a = 0;\\n                if (ret[i] == ret[i + k]) {\\n                    a = 1;\\n                    if (i + k + 1 < n) a += lcp[i + 1][i + k + 1]; \\n                }\\n                if (lcp[i][i + k] != a or lcp[i + k][i] != a) return \"\";\\n            } \\n        }\\n        \\n        string s;\\n        for (auto &c: ret) s += c;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224432,
                "title": "union-find-time-o-n-n-space-o-n-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int> &p){\\n        if(p[x]==x)return x;\\n        return find(p[x],p);\\n    }\\n    void unon(int x,int y,vector<int> &p,vector<int> &sz){\\n        int a = find(x,p);\\n        int b = find(y,p);\\n        if(a==b)return;\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n        p[b] = a;\\n        sz[a] += sz[b];\\n    }\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int i,j,n=lcp.size();\\n        vector<int> p(n),sz(n);\\n        for(i = 0; i < n; i++){\\n            sz[i] = 1;\\n            p[i] = i;\\n        }\\n        for(i = 0; i<n; i++){\\n            for(j = 0; j < n; j++){\\n                if(lcp[i][j]==0)continue;\\n                if(lcp[i][j])unon(i,j,p,sz);//ith and jth char is same if lcp>0 \\n                if(i==j&&lcp[i][j] !=n-i)return \"\";\\n            }\\n        }\\n        unordered_set<int> s;//find all possible disticnt char\\n        for(auto &i: p){\\n            s.insert(i);\\n        }\\n        if(s.size()>26)return \"\";//if no of possible chars > 26 return \"\";\\n        string str = \"\";\\n        unordered_map<int,char> mp;\\n        char c = \\'a\\';\\n        for(i = 0; i < n; i++){\\n            if(mp.count(p[i])==0){\\n                mp[p[i]] = c++;//assign easch parent to disticnt char\\n            }\\n            str += mp[p[i]];\\n        }\\n        vector<vector<int>> dp(n,vector<int> (n,0));//make a lcp by answer string\\n        for(i = n-1; i >= 0; i--){\\n            for(j = n-1; j>=0; j--){\\n                if(str[i] != str[j])dp[i][j] = 0;\\n                else{\\n                    if(i+1<n&&j+1<n){\\n                        dp[i][j] += dp[i+1][j+1]+1;\\n                    }else{\\n                        dp[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            for(j=  0; j < n; j++){\\n                if(dp[i][j]!=lcp[i][j])return \"\";//if not same return \"\";\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x,vector<int> &p){\\n        if(p[x]==x)return x;\\n        return find(p[x],p);\\n    }\\n    void unon(int x,int y,vector<int> &p,vector<int> &sz){\\n        int a = find(x,p);\\n        int b = find(y,p);\\n        if(a==b)return;\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n        p[b] = a;\\n        sz[a] += sz[b];\\n    }\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int i,j,n=lcp.size();\\n        vector<int> p(n),sz(n);\\n        for(i = 0; i < n; i++){\\n            sz[i] = 1;\\n            p[i] = i;\\n        }\\n        for(i = 0; i<n; i++){\\n            for(j = 0; j < n; j++){\\n                if(lcp[i][j]==0)continue;\\n                if(lcp[i][j])unon(i,j,p,sz);//ith and jth char is same if lcp>0 \\n                if(i==j&&lcp[i][j] !=n-i)return \"\";\\n            }\\n        }\\n        unordered_set<int> s;//find all possible disticnt char\\n        for(auto &i: p){\\n            s.insert(i);\\n        }\\n        if(s.size()>26)return \"\";//if no of possible chars > 26 return \"\";\\n        string str = \"\";\\n        unordered_map<int,char> mp;\\n        char c = \\'a\\';\\n        for(i = 0; i < n; i++){\\n            if(mp.count(p[i])==0){\\n                mp[p[i]] = c++;//assign easch parent to disticnt char\\n            }\\n            str += mp[p[i]];\\n        }\\n        vector<vector<int>> dp(n,vector<int> (n,0));//make a lcp by answer string\\n        for(i = n-1; i >= 0; i--){\\n            for(j = n-1; j>=0; j--){\\n                if(str[i] != str[j])dp[i][j] = 0;\\n                else{\\n                    if(i+1<n&&j+1<n){\\n                        dp[i][j] += dp[i+1][j+1]+1;\\n                    }else{\\n                        dp[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            for(j=  0; j < n; j++){\\n                if(dp[i][j]!=lcp[i][j])return \"\";//if not same return \"\";\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830053,
                "title": "python-o-n-2-solution",
                "content": "![image](https://assets.leetcode.com/users/images/51e8be83-3f98-438f-8488-38818711e0d9_1690658956.1728718.jpeg)\\n![image](https://assets.leetcode.com/users/images/edd4e98a-0a42-4dfc-8f89-6b6bda4c3342_1690658956.2422037.jpeg)\\n![image](https://assets.leetcode.com/users/images/09db80e9-d087-48e4-b26d-d681013fbf54_1690658956.2269988.jpeg)\\n![image](https://assets.leetcode.com/users/images/6e12ddda-59fc-4751-a4dc-15bcb949516d_1690658956.2199922.jpeg)\\n   ![image](https://assets.leetcode.com/users/images/ccb56869-56ab-4dc6-b1ee-10198a228572_1690658955.6743765.jpeg)\\n\\n```\\nclass Solution(object):\\n    def findTheString(self, lcp):\\n        \"\"\"\\n        :type lcp: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        n = len(lcp)\\n        \\n        \"\"\"\\n        airline pre-check\\n        rule 1: lcp[0][0]=dimesnion of matrix;\\n\\t\\t\\t# rule 1 is more specific of rule 2 (redundant)\\n        rule 2: i == j, lcp[i][j] == n - i\\n        rule 3: lcp[i][j]=lcp[j][i] \\n        rule 4: lcp[i+1][j+1]=lcp[i][j]-1 if lcp[i][j]>0\\n        rule 5: lcp[i][j]<=n- max(i,j)\\n        \"\"\"\\n\\t\\t\\n\\t\\t# O(N^2)\\n        # if lcp[0][0] != n:\\n           #  print(\"case 0 \")\\n            # return \"\"\\n        for i, row in enumerate(lcp):\\n            for j, item in enumerate(row):\\n\\t\\t\\t\\t# rule 2 \\n                if i == j and lcp[i][j] != n - i:\\n                    print(\"where messed up 1\")\\n                    return \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# rule 3 \\n                if lcp[i][j] != lcp[j][i]:\\n                    print(\"where messed up 2\")\\n                    return \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# rule 5\\n                if lcp[i][j] > n - max(i, j):\\n                    print(\"where messed up 4\")\\n                    \\n                    return \"\"\\n\\t\\t\\t\\t\\n                if i != len(row) - 1 and j != len(row) - 1:\\n                    if lcp[i][j] > 0:\\n                        if lcp[i + 1][j + 1] != lcp[i][j] - 1:\\n                            print(\"case 4.5\")\\n                            return \"\"\\n                    \\n        \\n        min_char = \\'a\\'\\n        return_list = [\\'#\\' for i in range(n)]\\n        \\n\\t\\t# O(N^2)\\n        for i, curr_char in enumerate(return_list):\\n            if curr_char != \\'#\\':\\n                continue\\n            if min_char > \\'z\\':\\n                print(\"where messed up 5\")\\n                return \"\"\\n            \\n            for j in range(i, n):\\n                if lcp[i][j] > 0:\\n                    return_list[j] = min_char\\n            min_char = chr(ord(min_char) + 1)\\n        \\n        \"\"\"\\n        Then, check if the LCP is aligned with actual resulting string.\\n\\t\\tO(N^2)\\n        \"\"\"\\n        for i, row in enumerate(return_list):\\n            # Checks for Rule 2 again\\n\\t\\t\\t# if i != len(return_list) - 1:\\n               #  if lcp[i][i] != len(return_list) - i:\\n                  #   print(\\'case 6\\')\\n                   #  return \"\"\\n\\t\\t\\t\\t   \\n\\t\\t\\t# Rule 4 \\n            for j, curr_char in enumerate(row):\\n                lcp_amount = lcp[i][j]\\n                if lcp_amount > 0:\\n                    if return_list[i: i + lcp_amount] != return_list[j: j + lcp_amount]:\\n                    \\n                        print(\"case 7\")\\n                        return \"\"\\n                    \\n            \\n        return \"\".join(return_list)\\n               \\n\\n                \\n                \\n        \\n\\n   ```\\n   \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findTheString(self, lcp):\\n        \"\"\"\\n        :type lcp: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        n = len(lcp)\\n        \\n        \"\"\"\\n        airline pre-check\\n        rule 1: lcp[0][0]=dimesnion of matrix;\\n\\t\\t\\t# rule 1 is more specific of rule 2 (redundant)\\n        rule 2: i == j, lcp[i][j] == n - i\\n        rule 3: lcp[i][j]=lcp[j][i] \\n        rule 4: lcp[i+1][j+1]=lcp[i][j]-1 if lcp[i][j]>0\\n        rule 5: lcp[i][j]<=n- max(i,j)\\n        \"\"\"\\n\\t\\t\\n\\t\\t# O(N^2)\\n        # if lcp[0][0] != n:\\n           #  print(\"case 0 \")\\n            # return \"\"\\n        for i, row in enumerate(lcp):\\n            for j, item in enumerate(row):\\n\\t\\t\\t\\t# rule 2 \\n                if i == j and lcp[i][j] != n - i:\\n                    print(\"where messed up 1\")\\n                    return \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# rule 3 \\n                if lcp[i][j] != lcp[j][i]:\\n                    print(\"where messed up 2\")\\n                    return \"\"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# rule 5\\n                if lcp[i][j] > n - max(i, j):\\n                    print(\"where messed up 4\")\\n                    \\n                    return \"\"\\n\\t\\t\\t\\t\\n                if i != len(row) - 1 and j != len(row) - 1:\\n                    if lcp[i][j] > 0:\\n                        if lcp[i + 1][j + 1] != lcp[i][j] - 1:\\n                            print(\"case 4.5\")\\n                            return \"\"\\n                    \\n        \\n        min_char = \\'a\\'\\n        return_list = [\\'#\\' for i in range(n)]\\n        \\n\\t\\t# O(N^2)\\n        for i, curr_char in enumerate(return_list):\\n            if curr_char != \\'#\\':\\n                continue\\n            if min_char > \\'z\\':\\n                print(\"where messed up 5\")\\n                return \"\"\\n            \\n            for j in range(i, n):\\n                if lcp[i][j] > 0:\\n                    return_list[j] = min_char\\n            min_char = chr(ord(min_char) + 1)\\n        \\n        \"\"\"\\n        Then, check if the LCP is aligned with actual resulting string.\\n\\t\\tO(N^2)\\n        \"\"\"\\n        for i, row in enumerate(return_list):\\n            # Checks for Rule 2 again\\n\\t\\t\\t# if i != len(return_list) - 1:\\n               #  if lcp[i][i] != len(return_list) - i:\\n                  #   print(\\'case 6\\')\\n                   #  return \"\"\\n\\t\\t\\t\\t   \\n\\t\\t\\t# Rule 4 \\n            for j, curr_char in enumerate(row):\\n                lcp_amount = lcp[i][j]\\n                if lcp_amount > 0:\\n                    if return_list[i: i + lcp_amount] != return_list[j: j + lcp_amount]:\\n                    \\n                        print(\"case 7\")\\n                        return \"\"\\n                    \\n            \\n        return \"\".join(return_list)\\n               \\n\\n                \\n                \\n        \\n\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3579569,
                "title": "2573-find-the-string-with-lcp",
                "content": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n       int n= lcp.size();\\n       string ans =\"\";\\n       if(lcp[0][0]!=n)\\n       return ans;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\\n               return ans;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n            return ans;\\n           }\\n       }\\n\\n       int t=0;\\n       for(int i=0;i<n;i++)\\n       ans +=\\'1\\';\\n\\n       for(int i=0;i<n;i++){\\n           bool flag = false;\\n           for(int j=i;j<n;j++){\\n               if(ans[j]==\\'1\\' && lcp[i][j]!=0){\\n                   if(t>=26)\\n                   return \"\";\\n                   ans[j] =\\'a\\'+t;\\n                   flag = true;\\n               }\\n           }\\n           if(flag ==true)\\n           t++;\\n       }\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n               return \"\";\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n       int n= lcp.size();\\n       string ans =\"\";\\n       if(lcp[0][0]!=n)\\n       return ans;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\\n               return ans;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n            return ans;\\n           }\\n       }\\n\\n       int t=0;\\n       for(int i=0;i<n;i++)\\n       ans +=\\'1\\';\\n\\n       for(int i=0;i<n;i++){\\n           bool flag = false;\\n           for(int j=i;j<n;j++){\\n               if(ans[j]==\\'1\\' && lcp[i][j]!=0){\\n                   if(t>=26)\\n                   return \"\";\\n                   ans[j] =\\'a\\'+t;\\n                   flag = true;\\n               }\\n           }\\n           if(flag ==true)\\n           t++;\\n       }\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n               return \"\";\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221230,
                "title": "python3-o-n-2-build-string-from-left-to-right-and-z-function-check-lcp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we build s from left to right. For position i, we will fill it with current smallest char if it is empty. Next we will check lcp with all other substrings starting with i+1, i+2, ..., n-1. If lcp[i][j] > 0, it means s[j] == s[i]. \\nRepeat this process we will always get a string. Then we use z-function to check the lcp matrix. The detail of z-function please refer to [https://cp-algorithms.com/string/z-function.html](https://cp-algorithms.com/string/z-function.html).\\n\\n**Notice:**\\n1. The lcp matrix is symmetric. The diagonal element is same as the substring length.\\n2. Make sure the chars we used are not exceed 26.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def z_function(self, s):\\n        n = len(s)\\n        z = [0] * n\\n        l, r = 0, 0\\n        for i in range(1, n):\\n            if i <= r and z[i - l] < r - i + 1:z[i] = z[i - l]\\n            else:\\n                z[i] = max(0, r - i + 1)\\n                while i + z[i] < n and s[z[i]] == s[i + z[i]]:z[i] += 1\\n            if i + z[i] - 1 > r:\\n                l = i\\n                r = i + z[i] - 1\\n        z[0] = len(s)\\n        return z\\n\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        s, idx = [\\'\\'] * n, 0\\n        for i in range(n):\\n            if i + lcp[i][i] != n: return \\'\\'\\n            if s[i] == \\'\\':\\n                if idx > 25: return \\'\\'\\n                s[i] = chr(ord(\\'a\\') + idx)\\n                idx += 1\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]: return \\'\\'\\n                if lcp[i][j]:\\n                    if s[j] != \\'\\' and s[j] != s[i]: return \\'\\'\\n                    s[j] = s[i]\\n        s = \\'\\'.join(s)\\n        return \\'\\' if any(self.z_function(s[i:]) != lcp[i][i:] for i in range(n)) else s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def z_function(self, s):\\n        n = len(s)\\n        z = [0] * n\\n        l, r = 0, 0\\n        for i in range(1, n):\\n            if i <= r and z[i - l] < r - i + 1:z[i] = z[i - l]\\n            else:\\n                z[i] = max(0, r - i + 1)\\n                while i + z[i] < n and s[z[i]] == s[i + z[i]]:z[i] += 1\\n            if i + z[i] - 1 > r:\\n                l = i\\n                r = i + z[i] - 1\\n        z[0] = len(s)\\n        return z\\n\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        s, idx = [\\'\\'] * n, 0\\n        for i in range(n):\\n            if i + lcp[i][i] != n: return \\'\\'\\n            if s[i] == \\'\\':\\n                if idx > 25: return \\'\\'\\n                s[i] = chr(ord(\\'a\\') + idx)\\n                idx += 1\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]: return \\'\\'\\n                if lcp[i][j]:\\n                    if s[j] != \\'\\' and s[j] != s[i]: return \\'\\'\\n                    s[j] = s[i]\\n        s = \\'\\'.join(s)\\n        return \\'\\' if any(self.z_function(s[i:]) != lcp[i][i:] for i in range(n)) else s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971133,
                "title": "easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            if(lcp[i][i]!=(n-i)) return \"\";\\n            for(int j=i,k=i;j>=0;j--,k--){\\n                if(lcp[i][j]!=lcp[j][i]) return \"\";\\n                if(lcp[i][j]>min(n-i,n-j)) return \"\";\\n            }\\n        }\\n        ans+=\\'a\\';\\n        int r=1;\\n        int z=1;\\n        int prev=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                int cnt=lcp[i][j];\\n                if(cnt==0) continue;\\n                if(i+1<n && j+1<n){\\n                    if(lcp[i+1][j+1]!=cnt-1) return \"\";\\n                }\\n                if(cnt+i>=r){\\n                    for(int x=j+r-i,y=r+1;y<=cnt+i;y++,x++){\\n                        ans+=ans[x];\\n                    }\\n                    r=ans.length();\\n                }else{\\n                    continue;\\n                }\\n            }\\n            if(ans.length()==prev && ans.length()<i+1){\\n                if(z<26){\\n                    ans+=(\\'a\\'+z);\\n                    z++;\\n                }else{\\n                    return \"\";\\n                }\\n            }\\n            r=ans.length();\\n            prev=r;\\n        }\\n        if(ans.length()!=n) return \"\";\\n        vector<vector<int>> lcp1(n,vector<int>(n,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(ans[i]==ans[j]){\\n                    lcp1[i][j]=1;\\n                    if(i+1<n && j+1<n){\\n                        lcp1[i][j]+=lcp1[i+1][j+1];\\n                    }\\n                }\\n                lcp1[j][i]=lcp1[i][j];\\n                if(lcp1[i][j]!=lcp[i][j]) return \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            if(lcp[i][i]!=(n-i)) return \"\";\\n            for(int j=i,k=i;j>=0;j--,k--){\\n                if(lcp[i][j]!=lcp[j][i]) return \"\";\\n                if(lcp[i][j]>min(n-i,n-j)) return \"\";\\n            }\\n        }\\n        ans+=\\'a\\';\\n        int r=1;\\n        int z=1;\\n        int prev=1;\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                int cnt=lcp[i][j];\\n                if(cnt==0) continue;\\n                if(i+1<n && j+1<n){\\n                    if(lcp[i+1][j+1]!=cnt-1) return \"\";\\n                }\\n                if(cnt+i>=r){\\n                    for(int x=j+r-i,y=r+1;y<=cnt+i;y++,x++){\\n                        ans+=ans[x];\\n                    }\\n                    r=ans.length();\\n                }else{\\n                    continue;\\n                }\\n            }\\n            if(ans.length()==prev && ans.length()<i+1){\\n                if(z<26){\\n                    ans+=(\\'a\\'+z);\\n                    z++;\\n                }else{\\n                    return \"\";\\n                }\\n            }\\n            r=ans.length();\\n            prev=r;\\n        }\\n        if(ans.length()!=n) return \"\";\\n        vector<vector<int>> lcp1(n,vector<int>(n,0));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(ans[i]==ans[j]){\\n                    lcp1[i][j]=1;\\n                    if(i+1<n && j+1<n){\\n                        lcp1[i][j]+=lcp1[i+1][j+1];\\n                    }\\n                }\\n                lcp1[j][i]=lcp1[i][j];\\n                if(lcp1[i][j]!=lcp[i][j]) return \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877728,
                "title": "2573-find-the-string-with-lcp",
                "content": "# Intuition\\nTo build a string, we will sequentially analyze arrays, while separately storing the next character and the next character in alphabetical order\\n\\n# Approach\\nTo check the correctness of arrays, we use the z-function\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n))$$\\n\\n- Space complexity:\\n$$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun findTheString(lcp: Array<IntArray>): String {\\n        if (lcp.size == 1 && lcp[0][0] == 0) return \"\"\\n\\n        val result = CharArray(lcp[0].size) { _: Int ->  \\'#\\' }\\n        result[0] = \\'a\\'\\n        var next = \\'a\\'\\n        var dNext = \\'a\\'\\n        for (ind in lcp.indices) {\\n            if (lcp[ind].last() > 1) return \"\"\\n\\n            val arrForBuild = lcp[ind].takeLast(lcp.size - ind).toIntArray()\\n            arrForBuild.forEachIndexed { index, arr ->\\n                if (index > 0 && result[index + ind] == \\'#\\' && arr > 0) result[index + ind] = next\\n            }\\n            if (result[ind] == \\'#\\') result[ind] = next\\n            next = if (1 < arrForBuild.size) {\\n                if (arrForBuild.all { it == 0 }) {\\n                    next\\n                } else {\\n                    if (result[ind + 1] != \\'#\\') result[ind + 1] else {\\n                        if (dNext == \\'z\\') \\'a\\' else {\\n                            dNext += 1\\n                            dNext\\n                        }\\n                    }\\n                }\\n            } else {\\n                next\\n            }\\n        }\\n        var s = String(result)\\n\\n        val length = s.length\\n        if (s.isEmpty()) return \"\"\\n        for (ind in lcp.indices) {\\n            val prefStr = if (ind == 0) s else s.takeLast(length - ind) + \"#\" + s\\n            val zArr = zFunction(prefStr)\\n            val zArrM = zArr.takeLast(length).toIntArray()\\n            zArrM[ind] = length - ind\\n            if (zArrM.joinToString() != lcp[ind].joinToString()) {\\n                s =  \"\"\\n                break\\n            }\\n        }\\n\\n        return s\\n    }\\n    \\n    fun zFunction(s : String): IntArray {\\n        val n = s.length\\n        val zf = IntArray(n)\\n        var left = 0\\n        var right = 0\\n        for (i in 1 until n) {\\n            val min = if(right - i < zf[i - left]) right - i else zf[i - left] \\n            zf[i] = if(0 > min) 0 else min\\n            while (i + zf[i] < n && s[zf[i]] == s[i + zf[i]]) {\\n                zf[i]++\\n            }\\n            if (i + zf[i] > right) {\\n                left = i\\n                right = i + zf[i]\\n            }\\n        }\\n        return zf\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    fun findTheString(lcp: Array<IntArray>): String {\\n        if (lcp.size == 1 && lcp[0][0] == 0) return \"\"\\n\\n        val result = CharArray(lcp[0].size) { _: Int ->  \\'#\\' }\\n        result[0] = \\'a\\'\\n        var next = \\'a\\'\\n        var dNext = \\'a\\'\\n        for (ind in lcp.indices) {\\n            if (lcp[ind].last() > 1) return \"\"\\n\\n            val arrForBuild = lcp[ind].takeLast(lcp.size - ind).toIntArray()\\n            arrForBuild.forEachIndexed { index, arr ->\\n                if (index > 0 && result[index + ind] == \\'#\\' && arr > 0) result[index + ind] = next\\n            }\\n            if (result[ind] == \\'#\\') result[ind] = next\\n            next = if (1 < arrForBuild.size) {\\n                if (arrForBuild.all { it == 0 }) {\\n                    next\\n                } else {\\n                    if (result[ind + 1] != \\'#\\') result[ind + 1] else {\\n                        if (dNext == \\'z\\') \\'a\\' else {\\n                            dNext += 1\\n                            dNext\\n                        }\\n                    }\\n                }\\n            } else {\\n                next\\n            }\\n        }\\n        var s = String(result)\\n\\n        val length = s.length\\n        if (s.isEmpty()) return \"\"\\n        for (ind in lcp.indices) {\\n            val prefStr = if (ind == 0) s else s.takeLast(length - ind) + \"#\" + s\\n            val zArr = zFunction(prefStr)\\n            val zArrM = zArr.takeLast(length).toIntArray()\\n            zArrM[ind] = length - ind\\n            if (zArrM.joinToString() != lcp[ind].joinToString()) {\\n                s =  \"\"\\n                break\\n            }\\n        }\\n\\n        return s\\n    }\\n    \\n    fun zFunction(s : String): IntArray {\\n        val n = s.length\\n        val zf = IntArray(n)\\n        var left = 0\\n        var right = 0\\n        for (i in 1 until n) {\\n            val min = if(right - i < zf[i - left]) right - i else zf[i - left] \\n            zf[i] = if(0 > min) 0 else min\\n            while (i + zf[i] < n && s[zf[i]] == s[i + zf[i]]) {\\n                zf[i]++\\n            }\\n            if (i + zf[i] > right) {\\n                left = i\\n                right = i + zf[i]\\n            }\\n        }\\n        return zf\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852370,
                "title": "python-3-build-pattern-validate-lcp-o-n-2",
                "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850831,
                "title": "python3-simple-and-commented-o-n-2",
                "content": "# Code\\n```\\nclass Solution:\\n\\n    def checkNewLCP(self, lcp: List[List[int]], output: List[str]) -> bool:\\n        n = len(output)\\n        for row_index in range(n):\\n            for col_index in range(n):\\n                prev_val = lcp[row_index+1][col_index+1] if (row_index+1 < n and col_index+1 < n) else 0\\n                expected_val = -1\\n                if output[col_index] == output[row_index]:\\n                    # If the two chars match, it means they must extend the prefix of lcp[row_index+1][col_index+1] by one because we have an additional matching char in both substrings\\n                    expected_val = prev_val + 1\\n                else:\\n                    # Since the additional char in the two substrings does not match, I expect the prefix to become zero\\n                    expected_val = 0\\n                if lcp[row_index][col_index] != expected_val:\\n                    return False\\n        return True\\n\\n    def checkOldLCP(self, lcp: List[List[int]]) -> bool:\\n        n = len(lcp)\\n        for row_index in range(n):\\n            for col_index in range(n):\\n                if row_index == col_index:\\n                    # Check if the value is the expected one\\n                    expected_value = n - row_index\\n                    if lcp[row_index][col_index] != expected_value:\\n                        return False\\n                if lcp[row_index][col_index] != lcp[col_index][row_index]:\\n                    return False\\n                # Check the length of the two string\\n                if lcp[row_index][col_index] > n - max(row_index, col_index):\\n                    return False\\n        return True\\n\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # Check if the matrix is symmetric and if in its principal diagonal we have the series [N, ..., 1]\\n        n = len(lcp)\\n        if not self.checkOldLCP(lcp):\\n            return \"\"\\n        \\n        output = [\\'$\\'] * n\\n        current_letter_index = 0\\n\\n        for row_index in range(n):\\n            for col_index in range(row_index, n):\\n                # If a letter has not been assigned to this position, assign it\\n                if output[row_index] == \\'$\\':\\n                    # If we ran out of letters, then we cannot build this string\\n                    if ord(\\'a\\') + current_letter_index > ord(\\'z\\'):\\n                        return \"\"\\n                    output[row_index] = chr(ord(\\'a\\') + current_letter_index)\\n                    current_letter_index += 1\\n\\n                assert output[row_index] != \\'$\\'\\n                if lcp[row_index][col_index] == 0:\\n                    # Rule: The two positions must not match\\n                    if output[row_index] == output[col_index]:\\n                        return \"\"\\n                else:\\n                    # Rule: The two positions must match\\n\\n                    # if there is already a character assigned to the \"col_index\" position, it must have been assigned by another rule, so there\\'s a mismatch between rules => return empty string\\n                    if output[col_index] != \\'$\\':\\n                        if output[col_index] != output[row_index]:\\n                            return \"\"\\n                        else:\\n                            # The two positions already match, so nothing to do\\n                            pass\\n                    else:\\n                        # Assign the character in row_index position to the col_index position as dictated by the rule\\n                        output[col_index] = output[row_index]\\n        \\n        if not self.checkNewLCP(lcp, output):\\n            return \"\"\\n        else:\\n            return \"\".join(output)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def checkNewLCP(self, lcp: List[List[int]], output: List[str]) -> bool:\\n        n = len(output)\\n        for row_index in range(n):\\n            for col_index in range(n):\\n                prev_val = lcp[row_index+1][col_index+1] if (row_index+1 < n and col_index+1 < n) else 0\\n                expected_val = -1\\n                if output[col_index] == output[row_index]:\\n                    # If the two chars match, it means they must extend the prefix of lcp[row_index+1][col_index+1] by one because we have an additional matching char in both substrings\\n                    expected_val = prev_val + 1\\n                else:\\n                    # Since the additional char in the two substrings does not match, I expect the prefix to become zero\\n                    expected_val = 0\\n                if lcp[row_index][col_index] != expected_val:\\n                    return False\\n        return True\\n\\n    def checkOldLCP(self, lcp: List[List[int]]) -> bool:\\n        n = len(lcp)\\n        for row_index in range(n):\\n            for col_index in range(n):\\n                if row_index == col_index:\\n                    # Check if the value is the expected one\\n                    expected_value = n - row_index\\n                    if lcp[row_index][col_index] != expected_value:\\n                        return False\\n                if lcp[row_index][col_index] != lcp[col_index][row_index]:\\n                    return False\\n                # Check the length of the two string\\n                if lcp[row_index][col_index] > n - max(row_index, col_index):\\n                    return False\\n        return True\\n\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # Check if the matrix is symmetric and if in its principal diagonal we have the series [N, ..., 1]\\n        n = len(lcp)\\n        if not self.checkOldLCP(lcp):\\n            return \"\"\\n        \\n        output = [\\'$\\'] * n\\n        current_letter_index = 0\\n\\n        for row_index in range(n):\\n            for col_index in range(row_index, n):\\n                # If a letter has not been assigned to this position, assign it\\n                if output[row_index] == \\'$\\':\\n                    # If we ran out of letters, then we cannot build this string\\n                    if ord(\\'a\\') + current_letter_index > ord(\\'z\\'):\\n                        return \"\"\\n                    output[row_index] = chr(ord(\\'a\\') + current_letter_index)\\n                    current_letter_index += 1\\n\\n                assert output[row_index] != \\'$\\'\\n                if lcp[row_index][col_index] == 0:\\n                    # Rule: The two positions must not match\\n                    if output[row_index] == output[col_index]:\\n                        return \"\"\\n                else:\\n                    # Rule: The two positions must match\\n\\n                    # if there is already a character assigned to the \"col_index\" position, it must have been assigned by another rule, so there\\'s a mismatch between rules => return empty string\\n                    if output[col_index] != \\'$\\':\\n                        if output[col_index] != output[row_index]:\\n                            return \"\"\\n                        else:\\n                            # The two positions already match, so nothing to do\\n                            pass\\n                    else:\\n                        # Assign the character in row_index position to the col_index position as dictated by the rule\\n                        output[col_index] = output[row_index]\\n        \\n        if not self.checkNewLCP(lcp, output):\\n            return \"\"\\n        else:\\n            return \"\".join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749972,
                "title": "very-very-easy-commented-and-readable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // First of all check lcp matrix is valid or not? If not return empty string\\n    bool isLcpValid(vector<vector<int>>&lcp)\\n    {\\n        /*\\n            observation-1: lcp[0][0]=dimesnion of matrix;\\n            observation-2: lcp[i][j]=lcp[j][i] as in both case two strings [i to n-1] and [j to n-1] are same.\\n            observation-3: lcp[i+1][j+1]=lcp[i][j]-1 if lcp[i][j]>0\\n            observation-4: lcp[i][j]<=n- max(i,j)\\n        */\\n        int n=lcp.size();\\n        if(lcp[0][0]!=n) return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               if(lcp[i][j]!=lcp[j][i]) return false;\\n               if(lcp[i][j]>n-max(i,j)) return false;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 &&  lcp[i+1][j+1]!=lcp[i][j]-1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string findTheString(vector<vector<int>>& lcp) \\n    {\\n        if(isLcpValid(lcp)==false)\\n        {\\n          // invalid LCP\\n            return \"\";\\n        } \\n        int n=lcp.size();\\n        char currChar=\\'a\\';\\n        vector<char>v(n,\\'#\\');\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]!=\\'#\\')continue;\\n            if(currChar>\\'z\\') \\n            {\\n               // Characters exceeded\\n                return \"\";\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                if(lcp[i][j]>0) v[j]=currChar; // if two substrings have lcp>0, means have some common prefix, so s[j]=s[i]\\n            }\\n             currChar++;\\n        }\\n        string ans=\"\";\\n        for(auto it:v)ans+=it;\\n        //check if my builded string is satisfying the given lcp or not.\\n        for (int i = 0; i < n; ++i) \\n        {\\n            for (int j = 0; j < n; ++j) \\n            {\\n                int v = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;\\n                v = ans[i] == ans[j] ? v + 1 : 0;\\n                if (lcp[i][j] != v) return \"\";\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // First of all check lcp matrix is valid or not? If not return empty string\\n    bool isLcpValid(vector<vector<int>>&lcp)\\n    {\\n        /*\\n            observation-1: lcp[0][0]=dimesnion of matrix;\\n            observation-2: lcp[i][j]=lcp[j][i] as in both case two strings [i to n-1] and [j to n-1] are same.\\n            observation-3: lcp[i+1][j+1]=lcp[i][j]-1 if lcp[i][j]>0\\n            observation-4: lcp[i][j]<=n- max(i,j)\\n        */\\n        int n=lcp.size();\\n        if(lcp[0][0]!=n) return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               if(lcp[i][j]!=lcp[j][i]) return false;\\n               if(lcp[i][j]>n-max(i,j)) return false;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 &&  lcp[i+1][j+1]!=lcp[i][j]-1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string findTheString(vector<vector<int>>& lcp) \\n    {\\n        if(isLcpValid(lcp)==false)\\n        {\\n          // invalid LCP\\n            return \"\";\\n        } \\n        int n=lcp.size();\\n        char currChar=\\'a\\';\\n        vector<char>v(n,\\'#\\');\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]!=\\'#\\')continue;\\n            if(currChar>\\'z\\') \\n            {\\n               // Characters exceeded\\n                return \"\";\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                if(lcp[i][j]>0) v[j]=currChar; // if two substrings have lcp>0, means have some common prefix, so s[j]=s[i]\\n            }\\n             currChar++;\\n        }\\n        string ans=\"\";\\n        for(auto it:v)ans+=it;\\n        //check if my builded string is satisfying the given lcp or not.\\n        for (int i = 0; i < n; ++i) \\n        {\\n            for (int j = 0; j < n; ++j) \\n            {\\n                int v = i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0;\\n                v = ans[i] == ans[j] ? v + 1 : 0;\\n                if (lcp[i][j] != v) return \"\";\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706167,
                "title": "clean-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        res = \\'\\'\\n        if not check_valid_lcp(lcp):\\n            return \\'\\'\\n\\n        for i in range(len(lcp)):                \\n            exact = set()\\n            diff = set()\\n            for j in range(i):\\n                if lcp[i][j] > 0:\\n                    exact.add(res[j])\\n                else:\\n                    diff.add(res[j])\\n            if len(exact) > 1:\\n                return \\'\\'\\n            if len(exact) == 1:\\n                res += (list(exact)[0])\\n                if res[i] in diff:\\n                    return \\'\\'\\n            if len(exact) == 0:\\n                c = choose_diff_char(diff)\\n                if c == \\'\\':\\n                    return \\'\\'\\n                res += c\\n\\n        return res\\n\\nalphabet = [chr(i+ ord(\\'a\\')) for i in range(26)]\\ndef choose_diff_char(diff):\\n    for c in alphabet:\\n        if c not in diff:\\n            return c\\n    return \\'\\'\\n\\ndef check_valid_lcp(lcp):\\n    for i in range(len(lcp)):\\n        if lcp[i][i] != len(lcp) - i:\\n            return False\\n        for j in range(i):\\n            if lcp[i][j] != lcp[j][i] or lcp[i][j] > len(lcp) - i:\\n                return False\\n            if i == len(lcp)-1:\\n                next_value = 0\\n            else:\\n                next_value = lcp[i+1][j+1]\\n\\n            if lcp[i][j] !=0 and lcp[i][j] != next_value+1:\\n                return False\\n    return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        res = \\'\\'\\n        if not check_valid_lcp(lcp):\\n            return \\'\\'\\n\\n        for i in range(len(lcp)):                \\n            exact = set()\\n            diff = set()\\n            for j in range(i):\\n                if lcp[i][j] > 0:\\n                    exact.add(res[j])\\n                else:\\n                    diff.add(res[j])\\n            if len(exact) > 1:\\n                return \\'\\'\\n            if len(exact) == 1:\\n                res += (list(exact)[0])\\n                if res[i] in diff:\\n                    return \\'\\'\\n            if len(exact) == 0:\\n                c = choose_diff_char(diff)\\n                if c == \\'\\':\\n                    return \\'\\'\\n                res += c\\n\\n        return res\\n\\nalphabet = [chr(i+ ord(\\'a\\')) for i in range(26)]\\ndef choose_diff_char(diff):\\n    for c in alphabet:\\n        if c not in diff:\\n            return c\\n    return \\'\\'\\n\\ndef check_valid_lcp(lcp):\\n    for i in range(len(lcp)):\\n        if lcp[i][i] != len(lcp) - i:\\n            return False\\n        for j in range(i):\\n            if lcp[i][j] != lcp[j][i] or lcp[i][j] > len(lcp) - i:\\n                return False\\n            if i == len(lcp)-1:\\n                next_value = 0\\n            else:\\n                next_value = lcp[i+1][j+1]\\n\\n            if lcp[i][j] !=0 and lcp[i][j] != next_value+1:\\n                return False\\n    return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691081,
                "title": "merge-equal-characters",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.size = [1] * n\\n        \\n    def find(self, a):\\n        if a == self.parent[a]:\\n            return a\\n        self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n        \\n    def union(self, a, b):\\n        parent_a = self.find(a)\\n        parent_b = self.find(b)\\n        if parent_a != parent_b:\\n            if self.size[parent_a] < self.size[parent_b]:\\n                parent_a, parent_b = parent_b, parent_a\\n            self.parent[parent_b] = parent_a\\n            self.size[parent_a] += self.size[parent_b]\\n\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        dsu = DSU(n)\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] > 0:\\n                    dsu.union(i, j)\\n        res = []\\n        x = 0\\n        mp = {}\\n        for i in range(n):\\n            if dsu.find(i) not in mp:\\n                if x >= 26:\\n                    return \"\"\\n                mp[dsu.find(i)] = chr(ord(\\'a\\') + x)\\n                x += 1\\n            res.append(mp[dsu.find(i)])\\n        res = \"\".join(res)\\n        for i in range(n):\\n            for j in range(n):\\n                curr = 1 + lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 1\\n                if res[i] != res[j]:\\n                    curr = 0\\n                if curr != lcp[i][j]:\\n                    return \"\"\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.size = [1] * n\\n        \\n    def find(self, a):\\n        if a == self.parent[a]:\\n            return a\\n        self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n        \\n    def union(self, a, b):\\n        parent_a = self.find(a)\\n        parent_b = self.find(b)\\n        if parent_a != parent_b:\\n            if self.size[parent_a] < self.size[parent_b]:\\n                parent_a, parent_b = parent_b, parent_a\\n            self.parent[parent_b] = parent_a\\n            self.size[parent_a] += self.size[parent_b]\\n\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        dsu = DSU(n)\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] > 0:\\n                    dsu.union(i, j)\\n        res = []\\n        x = 0\\n        mp = {}\\n        for i in range(n):\\n            if dsu.find(i) not in mp:\\n                if x >= 26:\\n                    return \"\"\\n                mp[dsu.find(i)] = chr(ord(\\'a\\') + x)\\n                x += 1\\n            res.append(mp[dsu.find(i)])\\n        res = \"\".join(res)\\n        for i in range(n):\\n            for j in range(n):\\n                curr = 1 + lcp[i + 1][j + 1] if i + 1 < n and j + 1 < n else 1\\n                if res[i] != res[j]:\\n                    curr = 0\\n                if curr != lcp[i][j]:\\n                    return \"\"\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678361,
                "title": "c-union-find-rolling-hash-string",
                "content": "\\n# Approach\\n1. if lcp[i][j] >= 1 indicates that thier first character equals atleast so, by union find method I will join them and I will do it for all i, j\\n2. Now I make the string by traversing from 0 to n - 1. how?\\n\\n3. Let say I gone to ith index and see its **grand ancestor** by simple find function that we made for the union find now I will see that will it used earlier or not if yes then assign our string that character else assign it new character i.e. we initially initialise with \\'a\\' and after that do increment. If character exceeds 26 then return null string.\\n\\n4. Now I have string need to know for every pair what is the longest common prefix and we check with the given. If any pair is wrong then return null string else return our generated string. \\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n * n * logn)\\n\\n---\\n\\n\\n# Code\\n```\\nclass hashing {\\nprivate:\\n  int n;\\n  long long p;\\n  long long mod;\\n  vector<long long> P;\\n  vector<long long> H;\\npublic:\\n  hashing(int prime, int md, int N) {\\n    n = N;\\n    mod = md;\\n    p = prime;\\n    P.resize(n + 1);\\n    H.resize(n + 1);\\n  }\\n  void init(string& s) {\\n    P[0] = 1;\\n    for(int i = 1; i <= n; i++) {\\n      P[i] = (P[i - 1] % mod * p % mod) % mod;\\n      H[i] = (H[i - 1] % mod + ((s[i - 1] - \\'a\\' + 1) * P[i]) % mod) % mod;\\n    }\\n  }\\n  long long value(int i, int length) {\\n    int L = i;\\n    int R = i + length - 1;\\n    long long res = (H[R] - H[L - 1] + mod) % mod;\\n    return res;\\n  }\\n  bool possible(int i, int j, int length) {\\n    long long left = (value(i, length) % mod * P[j - i] % mod) % mod;\\n    long long right = value(j, length) % mod;\\n    return (left == right);\\n  }\\n};\\nclass Solution {\\npublic:\\n  int parent[1000];\\n  int find(int a) {\\n    if(a == parent[a]) {\\n      return a;\\n    }\\n    return parent[a] = find(parent[a]);\\n  }\\n  void unite(int a, int b) {\\n    a = find(a);\\n    b = find(b);\\n    parent[a] = b;\\n  }\\n\\n  string findTheString(vector<vector<int>>& lcp) {\\n    int n = lcp.size();\\n    for(int i = 0; i < n; i++) {\\n      for(int j = 0; j < n; j++) {\\n        if(lcp[i][j] != lcp[j][i]) {\\n          return \"\";\\n        }\\n        if(min(n - i, n - j) < lcp[i][j]) {\\n          return \"\";\\n        }\\n      }\\n    }\\n    for(int i = 0; i < n; i++) {\\n      parent[i] = i;\\n    }\\n    for(int i = 0; i < n; i++) {\\n      for(int j = 0; j < n; j++) {\\n        if(lcp[i][j]) {\\n          unite(i, j);\\n        }\\n      }\\n    }\\n    int ch = 0;\\n    string s;\\n    unordered_map<int, int> assign;\\n    for(int i = 0; i < n; i++) {\\n      int gp = find(i);\\n      if(assign.find(gp) == assign.end()) {\\n        if(ch < 26) {\\n          assign[gp] = ch;\\n          ch++;\\n        }\\n        else {\\n          return \"\";\\n        }\\n      }\\n      s.push_back(assign[gp] + \\'a\\');\\n    }\\n    hashing h1(31, 1e9 + 7, n);\\n    hashing h2(37, 1e9 + 9, n);\\n    h1.init(s);\\n    h2.init(s);\\n    for(int i = 0; i < n; i++) {\\n      for(int j = i; j < n; j++) {\\n        int length = 0;\\n        int l = 1, h = n - j;\\n        while(l <= h) {\\n          int mid = (l + h) >> 1;\\n          if(h1.possible(i + 1, j + 1, mid) && h2.possible(i + 1, j + 1, mid)) {\\n            length = mid;\\n            l = mid + 1;\\n          }\\n          else {\\n            h = mid - 1;\\n          }\\n        }\\n        if(length != lcp[i][j]) {\\n          return \"\";\\n        }\\n      }\\n    }\\n    return s;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Union Find",
                    "Rolling Hash"
                ],
                "code": "```\\nclass hashing {\\nprivate:\\n  int n;\\n  long long p;\\n  long long mod;\\n  vector<long long> P;\\n  vector<long long> H;\\npublic:\\n  hashing(int prime, int md, int N) {\\n    n = N;\\n    mod = md;\\n    p = prime;\\n    P.resize(n + 1);\\n    H.resize(n + 1);\\n  }\\n  void init(string& s) {\\n    P[0] = 1;\\n    for(int i = 1; i <= n; i++) {\\n      P[i] = (P[i - 1] % mod * p % mod) % mod;\\n      H[i] = (H[i - 1] % mod + ((s[i - 1] - \\'a\\' + 1) * P[i]) % mod) % mod;\\n    }\\n  }\\n  long long value(int i, int length) {\\n    int L = i;\\n    int R = i + length - 1;\\n    long long res = (H[R] - H[L - 1] + mod) % mod;\\n    return res;\\n  }\\n  bool possible(int i, int j, int length) {\\n    long long left = (value(i, length) % mod * P[j - i] % mod) % mod;\\n    long long right = value(j, length) % mod;\\n    return (left == right);\\n  }\\n};\\nclass Solution {\\npublic:\\n  int parent[1000];\\n  int find(int a) {\\n    if(a == parent[a]) {\\n      return a;\\n    }\\n    return parent[a] = find(parent[a]);\\n  }\\n  void unite(int a, int b) {\\n    a = find(a);\\n    b = find(b);\\n    parent[a] = b;\\n  }\\n\\n  string findTheString(vector<vector<int>>& lcp) {\\n    int n = lcp.size();\\n    for(int i = 0; i < n; i++) {\\n      for(int j = 0; j < n; j++) {\\n        if(lcp[i][j] != lcp[j][i]) {\\n          return \"\";\\n        }\\n        if(min(n - i, n - j) < lcp[i][j]) {\\n          return \"\";\\n        }\\n      }\\n    }\\n    for(int i = 0; i < n; i++) {\\n      parent[i] = i;\\n    }\\n    for(int i = 0; i < n; i++) {\\n      for(int j = 0; j < n; j++) {\\n        if(lcp[i][j]) {\\n          unite(i, j);\\n        }\\n      }\\n    }\\n    int ch = 0;\\n    string s;\\n    unordered_map<int, int> assign;\\n    for(int i = 0; i < n; i++) {\\n      int gp = find(i);\\n      if(assign.find(gp) == assign.end()) {\\n        if(ch < 26) {\\n          assign[gp] = ch;\\n          ch++;\\n        }\\n        else {\\n          return \"\";\\n        }\\n      }\\n      s.push_back(assign[gp] + \\'a\\');\\n    }\\n    hashing h1(31, 1e9 + 7, n);\\n    hashing h2(37, 1e9 + 9, n);\\n    h1.init(s);\\n    h2.init(s);\\n    for(int i = 0; i < n; i++) {\\n      for(int j = i; j < n; j++) {\\n        int length = 0;\\n        int l = 1, h = n - j;\\n        while(l <= h) {\\n          int mid = (l + h) >> 1;\\n          if(h1.possible(i + 1, j + 1, mid) && h2.possible(i + 1, j + 1, mid)) {\\n            length = mid;\\n            l = mid + 1;\\n          }\\n          else {\\n            h = mid - 1;\\n          }\\n        }\\n        if(length != lcp[i][j]) {\\n          return \"\";\\n        }\\n      }\\n    }\\n    return s;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662919,
                "title": "c-simple-and-easy-explanation",
                "content": "\\n# Complexity\\n- Time complexity: O ( N^2 )\\n- Space complexity: O ( N^2 )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Class to implement union find operations.\\nclass UF{\\n    public:\\n    unordered_map<int, int> rank, parent;\\n    void make(int n){\\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    int find(int n){\\n        if(parent[n]!=n)\\n            return parent[n] = find(parent[n]);\\n        return n;\\n    }\\n    void merge(int x, int y)\\n    {\\n        int a = parent[x], b=parent[y];\\n        if(a==b)\\n            return;\\n        if(rank[a]>rank[b])\\n            parent[b] = a;\\n        else if(rank[a]<rank[b])\\n            parent[a] = b;\\n        else\\n        {\\n            parent[a] = b;\\n            rank[b]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& m) {\\n        int n = m.size();\\n\\n        UF u;\\n        u.make(n);\\n\\n        // if m[i][j] > 0, then it means that character i and j are same,\\n        // thus putting them in same group using union find class.\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                if(m[i][j])\\n                    u.merge(i, j);\\n            }\\n        }\\n        vector<int> v(n, -1);\\n        int al = 0;\\n\\n        // allocating same character to all the element of a group\\n        for(int i=0; i<n; i++)\\n        {\\n            int p = u.find(i);\\n            if(v[p]!=-1)\\n                v[i] = v[p];\\n            else\\n            {\\n                if(al>=26)\\n                    return \"\";\\n                v[i] = al;\\n                v[p] = al;\\n                al++;\\n            }\\n        }\\n\\n        // Check if our found answer can generate the same LCP\\n        vector<vector<int>> dp(n, vector<int> (n, 0));\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                if(v[i] == v[j])\\n                    dp[i][j] = 1;\\n                if(dp[i][j]>0 && i<n-1 && j<n-1)\\n                    dp[i][j] += dp[i+1][j+1];\\n                if(dp[i][j]!=m[i][j] || v[i]==-1 || v[j]==-1)\\n                    return \"\";\\n            }\\n        }\\n        string s;\\n        for(int i=0; i<n; i++)\\n            s+=(\\'a\\'+v[i]);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\n// Class to implement union find operations.\\nclass UF{\\n    public:\\n    unordered_map<int, int> rank, parent;\\n    void make(int n){\\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    int find(int n){\\n        if(parent[n]!=n)\\n            return parent[n] = find(parent[n]);\\n        return n;\\n    }\\n    void merge(int x, int y)\\n    {\\n        int a = parent[x], b=parent[y];\\n        if(a==b)\\n            return;\\n        if(rank[a]>rank[b])\\n            parent[b] = a;\\n        else if(rank[a]<rank[b])\\n            parent[a] = b;\\n        else\\n        {\\n            parent[a] = b;\\n            rank[b]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& m) {\\n        int n = m.size();\\n\\n        UF u;\\n        u.make(n);\\n\\n        // if m[i][j] > 0, then it means that character i and j are same,\\n        // thus putting them in same group using union find class.\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                if(m[i][j])\\n                    u.merge(i, j);\\n            }\\n        }\\n        vector<int> v(n, -1);\\n        int al = 0;\\n\\n        // allocating same character to all the element of a group\\n        for(int i=0; i<n; i++)\\n        {\\n            int p = u.find(i);\\n            if(v[p]!=-1)\\n                v[i] = v[p];\\n            else\\n            {\\n                if(al>=26)\\n                    return \"\";\\n                v[i] = al;\\n                v[p] = al;\\n                al++;\\n            }\\n        }\\n\\n        // Check if our found answer can generate the same LCP\\n        vector<vector<int>> dp(n, vector<int> (n, 0));\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            for(int j=n-1; j>=0; j--)\\n            {\\n                if(v[i] == v[j])\\n                    dp[i][j] = 1;\\n                if(dp[i][j]>0 && i<n-1 && j<n-1)\\n                    dp[i][j] += dp[i+1][j+1];\\n                if(dp[i][j]!=m[i][j] || v[i]==-1 || v[j]==-1)\\n                    return \"\";\\n            }\\n        }\\n        string s;\\n        for(int i=0; i<n; i++)\\n            s+=(\\'a\\'+v[i]);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659249,
                "title": "check-matrix-property-and-then-greedy-decode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck properties of lcp matrix and then greedy decode the string.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        // Check matrix structure\\n        // lcp[i][j] = lcp[j][i]\\n        // lcp[i][i] = n - i\\n        // lcp[i][j] > 0: lcp[i+1][j+1] =  lcp[i][j] - 1\\n        // lcp[i][j] < n - i, lcp[i][j] < n - j\\n        for (int i = 0; i < n; i++) {\\n            if (lcp[i][i] != n - i) return \"\";\\n            for (int j = 0; j < n; j++) {\\n                if (lcp[i][j] != lcp[j][i]) return \"\";\\n                if (lcp[i][j] > min(n - i, n - j)) return \"\"; \\n                if (i + 1 < n && j + 1 < n && lcp[i][j] > 0) {\\n                    if (lcp[i+1][j+1] + 1 != lcp[i][j]) return \"\";\\n                }\\n            }\\n        }\\n\\n        vector<int> result(n, -1);\\n        vector<vector<int>> isOK(n, vector<int>(26, 1));\\n        for (int i = 0; i < n; i++) {\\n            if (result[i] == -1) {\\n                for (int j = 0; j < 26; j++) {\\n                    if (isOK[i][j]) {\\n                        result[i] = j;\\n                        break;\\n                    }\\n                }\\n                if (result[i] == -1) return \"\";\\n            }\\n            // Check and populate\\n            for (int j = i+1; j < n; j++) {\\n                if (lcp[i][j] == 0) {\\n                    // conflict with existing letter\\n                    if (result[j] >= 0 && result[j] == result[i]) return \"\";\\n                    isOK[j][result[i]] = false;\\n                } else {\\n                    // conflict with existing letter\\n                    if (result[j] >= 0 && result[j] != result[i]) return \"\";\\n                    // conflict with can not fill\\n                    if (result[j] == -1 && !isOK[j][result[i]]) return \"\";\\n                    result[j] = result[i];\\n                }\\n            }\\n        }\\n        string s;\\n        for (int c: result) s += char(c+\\'a\\');\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        // Check matrix structure\\n        // lcp[i][j] = lcp[j][i]\\n        // lcp[i][i] = n - i\\n        // lcp[i][j] > 0: lcp[i+1][j+1] =  lcp[i][j] - 1\\n        // lcp[i][j] < n - i, lcp[i][j] < n - j\\n        for (int i = 0; i < n; i++) {\\n            if (lcp[i][i] != n - i) return \"\";\\n            for (int j = 0; j < n; j++) {\\n                if (lcp[i][j] != lcp[j][i]) return \"\";\\n                if (lcp[i][j] > min(n - i, n - j)) return \"\"; \\n                if (i + 1 < n && j + 1 < n && lcp[i][j] > 0) {\\n                    if (lcp[i+1][j+1] + 1 != lcp[i][j]) return \"\";\\n                }\\n            }\\n        }\\n\\n        vector<int> result(n, -1);\\n        vector<vector<int>> isOK(n, vector<int>(26, 1));\\n        for (int i = 0; i < n; i++) {\\n            if (result[i] == -1) {\\n                for (int j = 0; j < 26; j++) {\\n                    if (isOK[i][j]) {\\n                        result[i] = j;\\n                        break;\\n                    }\\n                }\\n                if (result[i] == -1) return \"\";\\n            }\\n            // Check and populate\\n            for (int j = i+1; j < n; j++) {\\n                if (lcp[i][j] == 0) {\\n                    // conflict with existing letter\\n                    if (result[j] >= 0 && result[j] == result[i]) return \"\";\\n                    isOK[j][result[i]] = false;\\n                } else {\\n                    // conflict with existing letter\\n                    if (result[j] >= 0 && result[j] != result[i]) return \"\";\\n                    // conflict with can not fill\\n                    if (result[j] == -1 && !isOK[j][result[i]]) return \"\";\\n                    result[j] = result[i];\\n                }\\n            }\\n        }\\n        string s;\\n        for (int c: result) s += char(c+\\'a\\');\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511535,
                "title": "for-loop-dp-solution-o-n-n-approach-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a dummy vector (v) of same size as of required string having all element \\'a\\'\\n\\n2. traverse a lcp array . if : \\nlcp[i][j] == 0   ( means v[i] != v[j] )\\nbut if in our array (v)  if(v[i] == v[j] ) \\nmeans originally we want v[i] != v[j] but they are equal . \\nso to make it unequal we increase v[j] .\\n\\nQues : Why we cannot increase v[j] ? \\nAns : we required lexographically smallest string that is only possible if we increase v[j]  ans ( j > i : check for loop 8-9 line from top . )\\n\\n3. now check if any index of v > \\'z\\' . means we will not able to assign any alphabet . \\nso return \"\" \\n\\n4. now try to create or try filling dp . from a answer in vector (v) .\\n    ( i , j ) from n-1 to 0 \\n    if(v[i] == v[j] ) dp[i][j] = 1 + dp[i+1][j+1] \\n\\n    and dp[i+1][j+1] is already calculated previously . \\n\\n4. finally check whether lcp and dp array are equal or not .  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO( N * N )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO( N * N )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size() ;\\n        int dp[n][n] ;\\n        memset(dp , 0 , sizeof(dp)) ;\\n        vector<char> v (n , \\'a\\') ;\\n        for(int i = 0 ; i< n ; ++i ){\\n            for(int j = i+1 ; j< n ; ++j ){\\n                if(lcp[i][j] == 0 && v[i] == v[j] ) {\\n                    v[j]++;\\n                }\\n                if(v[j] > \\'z\\' ) return \"\" ;\\n            }\\n        }\\n        for(int i = n-1 ; i>=0 ; --i ){\\n            for(int j = n-1 ; j>=0 ; --j ){\\n                if(v[i] == v[j] ){\\n                    dp[i][j] = 1 ;\\n                    if( i + 1 < n && j+1 < n )\\n                    dp[i][j] += dp[i+1][j+1] ;\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i< n ; ++i ){\\n            for(int j = 0 ; j< n ; ++j ){\\n                if(lcp[i][j] != dp[i][j] ){\\n                    return \"\" ;\\n                } \\n            }\\n        }\\n        string ans = \"\" ;\\n        for(auto it : v ) ans += it ;\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size() ;\\n        int dp[n][n] ;\\n        memset(dp , 0 , sizeof(dp)) ;\\n        vector<char> v (n , \\'a\\') ;\\n        for(int i = 0 ; i< n ; ++i ){\\n            for(int j = i+1 ; j< n ; ++j ){\\n                if(lcp[i][j] == 0 && v[i] == v[j] ) {\\n                    v[j]++;\\n                }\\n                if(v[j] > \\'z\\' ) return \"\" ;\\n            }\\n        }\\n        for(int i = n-1 ; i>=0 ; --i ){\\n            for(int j = n-1 ; j>=0 ; --j ){\\n                if(v[i] == v[j] ){\\n                    dp[i][j] = 1 ;\\n                    if( i + 1 < n && j+1 < n )\\n                    dp[i][j] += dp[i+1][j+1] ;\\n                }\\n            }\\n        }\\n        for(int i = 0 ; i< n ; ++i ){\\n            for(int j = 0 ; j< n ; ++j ){\\n                if(lcp[i][j] != dp[i][j] ){\\n                    return \"\" ;\\n                } \\n            }\\n        }\\n        string ans = \"\" ;\\n        for(auto it : v ) ans += it ;\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445316,
                "title": "o-n-2-solution-explained-python",
                "content": "# Intuition\\nOne way to solve this problem is to reverse-engineer the string from the given LCP matrix.\\n\\n# Approach\\n1. Check top-left to bottom-right diagonal. They should be in strictly decreasing order from n -> 1.\\n2. Reverse engineer the string. Att each position:\\n    - If the position has been filled, that means if there is any position after the current position that needs to be the same as the current position, it should be already filled too with the same character.\\n    - If the position has not been filled, We fill the position with the next available character `curr_l` and all the positions after that, that have to be the same as curr position.\\n3. This step would be kind of DP, but instead of filling in values, we check the values.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        letters = [None] * n\\n        curr_l = \\'a\\'\\n        \\n        for i in range(n):\\n            if lcp[i][i] != n-i: return \"\"\\n            lcp[i].append(0)\\n        \\n        for i in range(n):\\n            l = letters[i]\\n            if l is not None:\\n                for j in range(i+1, n):\\n                    if lcp[i][j] != lcp[j][i]: return \"\"\\n                    if lcp[i][j] and letters[j] != l: return \"\"\\n            else:\\n                if curr_l > \\'z\\': return \"\"\\n                for j in range(i, n):\\n                    if lcp[i][j] != lcp[j][i]: return \"\"\\n                    if lcp[i][j]:\\n                        if letters[j]:\\n                            if letters[j] != curr_l: return \"\"\\n                        else:\\n                            letters[j] = curr_l\\n                curr_l = chr(ord(curr_l) + 1)\\n                \\n            \\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if letters[i] == letters[j] and lcp[i][j]!=lcp[i+1][j+1]+1:\\n                    return \"\"\\n        \\n        \\n        return \\'\\'.join(letters)\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        letters = [None] * n\\n        curr_l = \\'a\\'\\n        \\n        for i in range(n):\\n            if lcp[i][i] != n-i: return \"\"\\n            lcp[i].append(0)\\n        \\n        for i in range(n):\\n            l = letters[i]\\n            if l is not None:\\n                for j in range(i+1, n):\\n                    if lcp[i][j] != lcp[j][i]: return \"\"\\n                    if lcp[i][j] and letters[j] != l: return \"\"\\n            else:\\n                if curr_l > \\'z\\': return \"\"\\n                for j in range(i, n):\\n                    if lcp[i][j] != lcp[j][i]: return \"\"\\n                    if lcp[i][j]:\\n                        if letters[j]:\\n                            if letters[j] != curr_l: return \"\"\\n                        else:\\n                            letters[j] = curr_l\\n                curr_l = chr(ord(curr_l) + 1)\\n                \\n            \\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if letters[i] == letters[j] and lcp[i][j]!=lcp[i+1][j+1]+1:\\n                    return \"\"\\n        \\n        \\n        return \\'\\'.join(letters)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432074,
                "title": "python-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp):\\n        n = len(lcp)\\n\\n        dict1 = defaultdict(int)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a,b = find(x),find(y)\\n\\n            if a > b:\\n                dict1[a] = b\\n            else:\\n                dict1[b] = a\\n\\n        for i in range(n):\\n            for j in range(i):\\n                if lcp[i][j]: union(i,j)\\n\\n        ans = [find(i) for i in range(n)]\\n\\n        for i in range(n):\\n            for j in range(n):\\n                val = lcp[i+1][j+1] if i+1 < n and j+1 < n else 0\\n                val = val + 1 if ans[i] == ans[j] else 0\\n                if val != lcp[i][j]:\\n                    return \"\"\\n\\n        group = set(ans)\\n        if len(group) > 26: return \"\"\\n        dict2 = {x:i for i,x in enumerate(sorted(group))}\\n\\n        res = []\\n\\n        for i,k in enumerate(ans):\\n            res.append(chr(97+dict2[k]))\\n\\n        return \"\".join(res)\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n            \\n\\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp):\\n        n = len(lcp)\\n\\n        dict1 = defaultdict(int)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a,b = find(x),find(y)\\n\\n            if a > b:\\n                dict1[a] = b\\n            else:\\n                dict1[b] = a\\n\\n        for i in range(n):\\n            for j in range(i):\\n                if lcp[i][j]: union(i,j)\\n\\n        ans = [find(i) for i in range(n)]\\n\\n        for i in range(n):\\n            for j in range(n):\\n                val = lcp[i+1][j+1] if i+1 < n and j+1 < n else 0\\n                val = val + 1 if ans[i] == ans[j] else 0\\n                if val != lcp[i][j]:\\n                    return \"\"\\n\\n        group = set(ans)\\n        if len(group) > 26: return \"\"\\n        dict2 = {x:i for i,x in enumerate(sorted(group))}\\n\\n        res = []\\n\\n        for i,k in enumerate(ans):\\n            res.append(chr(97+dict2[k]))\\n\\n        return \"\".join(res)\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n            \\n\\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393556,
                "title": "c-easy-to-understand-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n       int n= lcp.size();\\n       string ans =\"\";\\n       if(lcp[0][0]!=n)\\n       return ans;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\\n               return ans;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n            return ans;\\n           }\\n       }\\n\\n       int t=0;\\n       for(int i=0;i<n;i++)\\n       ans +=\\'1\\';\\n\\n       for(int i=0;i<n;i++){\\n           bool flag = false;\\n           for(int j=i;j<n;j++){\\n               if(ans[j]==\\'1\\' && lcp[i][j]!=0){\\n                   if(t>=26)\\n                   return \"\";\\n                   ans[j] =\\'a\\'+t;\\n                   flag = true;\\n               }\\n           }\\n           if(flag ==true)\\n           t++;\\n       }\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n               return \"\";\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n       int n= lcp.size();\\n       string ans =\"\";\\n       if(lcp[0][0]!=n)\\n       return ans;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\\n               return ans;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n            return ans;\\n           }\\n       }\\n\\n       int t=0;\\n       for(int i=0;i<n;i++)\\n       ans +=\\'1\\';\\n\\n       for(int i=0;i<n;i++){\\n           bool flag = false;\\n           for(int j=i;j<n;j++){\\n               if(ans[j]==\\'1\\' && lcp[i][j]!=0){\\n                   if(t>=26)\\n                   return \"\";\\n                   ans[j] =\\'a\\'+t;\\n                   flag = true;\\n               }\\n           }\\n           if(flag ==true)\\n           t++;\\n       }\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n               return \"\";\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299283,
                "title": "union-find-solution-c-simple-elaborative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are lot of conditions to be verified. \\n1. All the diagonals elements should be in decreasing order n,n-1,n-2,...,1\\n2. The trasition of (i,j) from (i+1,j+1) differs by 1 because adding 1 character can increase the same prefix by at most one.\\n3. Characters required must be in range [a-z]  \\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\n   public:\\n    vector<int> parent,size; \\n    DSU(int n)\\n    {\\n        parent.resize(n);\\n        size.resize(n,1);\\n        for(int i=0;i<n;i++)\\n            parent[i] = i;\\n    }\\n    int find(int n)\\n    {\\n        if(parent[n]!=n)\\n            return parent[n] = find(parent[n]);\\n        return n;\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = find(x);\\n        int v = find(y);\\n        if(u!=v)\\n        {\\n            if(size[u]>size[v])\\n            {\\n                parent[v] = u;\\n                size[u]+=size[v]; \\n            }\\n            else\\n            {\\n                parent[u] = v;\\n                size[v]+=size[u];\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        vector<int> dp(n,-1);\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(lcp[i][j]!=lcp[j][i] || lcp[i][j] > n - i || lcp[i][j] > n-j) return \"\";\\n                if(i==j && lcp[i][j]!= n-i) return \"\";\\n                if(i<n-1 && j<n-1 && lcp[i][j]!=0 && lcp[i][j]==lcp[i+1][j+1]) return \"\";\\n            }\\n        DSU d(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                if(lcp[i][j]==1)\\n                {\\n                    int l =i,r=j;\\n                    d.Union(l,r);\\n                    while(l>0 && r>0 && lcp[l-1][r-1] == lcp[l][r]+1)\\n                    {\\n                        l--;\\n                        r--;\\n                        d.Union(l,r);\\n                    }\\n                }\\n                if(i>0 && j>0 && lcp[i-1][j-1] > lcp[i][j]+1)\\n                        return \"\";\\n                if(lcp[i][j]==0)\\n                {\\n                    if(d.find(i) == d.find(j))\\n                        return \"\";\\n                }\\n            }\\n        }\\n        map<int,char> mapping;\\n        char c = \\'a\\';\\n        string ans(n,\\'#\\');\\n        for(int i=0;i<n;i++)\\n        {\\n            int p = d.find(i);\\n            if(mapping.find(p)==mapping.end())\\n                mapping[p] = c++;\\n            if(c == \\'z\\'+2)\\n                return \"\";\\n            ans[i] = mapping[p];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\n   public:\\n    vector<int> parent,size; \\n    DSU(int n)\\n    {\\n        parent.resize(n);\\n        size.resize(n,1);\\n        for(int i=0;i<n;i++)\\n            parent[i] = i;\\n    }\\n    int find(int n)\\n    {\\n        if(parent[n]!=n)\\n            return parent[n] = find(parent[n]);\\n        return n;\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = find(x);\\n        int v = find(y);\\n        if(u!=v)\\n        {\\n            if(size[u]>size[v])\\n            {\\n                parent[v] = u;\\n                size[u]+=size[v]; \\n            }\\n            else\\n            {\\n                parent[u] = v;\\n                size[v]+=size[u];\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        vector<int> dp(n,-1);\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(lcp[i][j]!=lcp[j][i] || lcp[i][j] > n - i || lcp[i][j] > n-j) return \"\";\\n                if(i==j && lcp[i][j]!= n-i) return \"\";\\n                if(i<n-1 && j<n-1 && lcp[i][j]!=0 && lcp[i][j]==lcp[i+1][j+1]) return \"\";\\n            }\\n        DSU d(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                if(lcp[i][j]==1)\\n                {\\n                    int l =i,r=j;\\n                    d.Union(l,r);\\n                    while(l>0 && r>0 && lcp[l-1][r-1] == lcp[l][r]+1)\\n                    {\\n                        l--;\\n                        r--;\\n                        d.Union(l,r);\\n                    }\\n                }\\n                if(i>0 && j>0 && lcp[i-1][j-1] > lcp[i][j]+1)\\n                        return \"\";\\n                if(lcp[i][j]==0)\\n                {\\n                    if(d.find(i) == d.find(j))\\n                        return \"\";\\n                }\\n            }\\n        }\\n        map<int,char> mapping;\\n        char c = \\'a\\';\\n        string ans(n,\\'#\\');\\n        for(int i=0;i<n;i++)\\n        {\\n            int p = d.find(i);\\n            if(mapping.find(p)==mapping.end())\\n                mapping[p] = c++;\\n            if(c == \\'z\\'+2)\\n                return \"\";\\n            ans[i] = mapping[p];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289021,
                "title": "java-dsu-graph-full-explanation",
                "content": "\\nSolution using DSU.\\n**Approach** - \\n1. Firt declare parent[], rank[] required for DSU. And fill the default values in them.\\n2. Then iterative in lcp[][] for upper j > i region only. Because for i == j, lcp[i][j] == i and lower trianglular values in lcp[][] are same to upper triangular value of lcp[][]. For every lcp[i][j] > 0. Connect position i and j using union() and rank().\\n3. Now, we have groups of position in result string str[] with same values.\\n4. Iterate from i = 0 to n. Find parent par for position i. If char[par] is 0 then assign it value ++c. Then fill str[i] = chars[par]. By doing that we are filling charater values in possible result string array str[].\\n5. Now, we have created str[] but we have not checked whether given lcp[][] is valid or not. So, we will create lcpNew[][] from str[] and match it with given lcp[][]. If lcp[i][j] is not equal to lcpNew[i][j] for any i and j, then return null string.\\n6. Create string answer from str[] and return it.\\n\\nT.C is O(N * N) and S.C is O(N * N)\\n\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        int[] parent = new int[n], rank = new int[n], chars = new int[n], str = new int[n];\\n        for(int i = 0; i < n; ++i){\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n        \\n        for(int i = 0; i < n; ++i){\\n            for(int j = i + 1; j < n; ++j){\\n                if(lcp[i][j] > 0){\\n                    union(parent, rank, i, j);\\n                }\\n            }\\n        }\\n        \\n        int c = 0, par;\\n        for(int i = 0; i < n; ++i){\\n            par = find(parent, i);\\n            if(chars[par] == 0){\\n                chars[par] = ++c;\\n            }\\n            if(c > 26) return \"\"; // this condition is difficult to think\\n            str[i] = chars[par];\\n        }\\n        // System.out.println(Arrays.toString(str));\\n        int val;\\n        int[][] lcpNew = new int[n][n];\\n        for(int i = n-1; i >= 0; --i){\\n            for(int j = n-1; j >= 0; --j){\\n                val = (i+1)<n && (j+1)<n ? lcpNew[i+1][j+1] : 0;\\n                val = str[i] == str[j] ? 1 + val : 0;\\n                lcpNew[i][j] = val;\\n                if(lcpNew[i][j] != lcp[i][j]) return \"\";\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int e : str){\\n            sb.append((char)(e + \\'a\\' - 1));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int[] parent, int x){\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent, parent[x]);\\n    }\\n    \\n    private void union(int[] parent, int[] rank, int u, int v){\\n        u = find(parent, u); v= find(parent, v);\\n        if(u == v) return;\\n        if(rank[u] >= rank[v]){\\n            parent[v] = u;\\n            rank[u] += rank[v];\\n        }\\n        else{\\n            parent[u] = v;\\n            rank[v] += rank[u];\\n        }\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        int[] parent = new int[n], rank = new int[n], chars = new int[n], str = new int[n];\\n        for(int i = 0; i < n; ++i){\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n        \\n        for(int i = 0; i < n; ++i){\\n            for(int j = i + 1; j < n; ++j){\\n                if(lcp[i][j] > 0){\\n                    union(parent, rank, i, j);\\n                }\\n            }\\n        }\\n        \\n        int c = 0, par;\\n        for(int i = 0; i < n; ++i){\\n            par = find(parent, i);\\n            if(chars[par] == 0){\\n                chars[par] = ++c;\\n            }\\n            if(c > 26) return \"\"; // this condition is difficult to think\\n            str[i] = chars[par];\\n        }\\n        // System.out.println(Arrays.toString(str));\\n        int val;\\n        int[][] lcpNew = new int[n][n];\\n        for(int i = n-1; i >= 0; --i){\\n            for(int j = n-1; j >= 0; --j){\\n                val = (i+1)<n && (j+1)<n ? lcpNew[i+1][j+1] : 0;\\n                val = str[i] == str[j] ? 1 + val : 0;\\n                lcpNew[i][j] = val;\\n                if(lcpNew[i][j] != lcp[i][j]) return \"\";\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int e : str){\\n            sb.append((char)(e + \\'a\\' - 1));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int[] parent, int x){\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent, parent[x]);\\n    }\\n    \\n    private void union(int[] parent, int[] rank, int u, int v){\\n        u = find(parent, u); v= find(parent, v);\\n        if(u == v) return;\\n        if(rank[u] >= rank[v]){\\n            parent[v] = u;\\n            rank[u] += rank[v];\\n        }\\n        else{\\n            parent[u] = v;\\n            rank[v] += rank[u];\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255732,
                "title": "c-solution-logic-building",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        string ans=\"\";\\n        if(lcp[0][0]!=n)\\n        return ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(lcp[i][j]!=lcp[j][i] || lcp[i][j]>n-max(i,j))\\n                return ans;\\n                if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n                return ans;\\n            }\\n        }\\n        int t=0;\\n        for(int i=0;i<n;i++)\\n        ans+=\\'1\\';\\n        for(int i=0;i<n;i++){\\n            bool flag=false;\\n            for(int j=i;j<n;j++){\\n                if(ans[j]==\\'1\\'&& lcp[i][j]!=0){\\n                    if(t>=26)\\n                    return \"\";\\n                    ans[j]=\\'a\\'+t;\\n                    flag=true;\\n                }\\n            }\\n            if(flag==true)\\n            t++;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n                return \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        string ans=\"\";\\n        if(lcp[0][0]!=n)\\n        return ans;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(lcp[i][j]!=lcp[j][i] || lcp[i][j]>n-max(i,j))\\n                return ans;\\n                if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n                return ans;\\n            }\\n        }\\n        int t=0;\\n        for(int i=0;i<n;i++)\\n        ans+=\\'1\\';\\n        for(int i=0;i<n;i++){\\n            bool flag=false;\\n            for(int j=i;j<n;j++){\\n                if(ans[j]==\\'1\\'&& lcp[i][j]!=0){\\n                    if(t>=26)\\n                    return \"\";\\n                    ans[j]=\\'a\\'+t;\\n                    flag=true;\\n                }\\n            }\\n            if(flag==true)\\n            t++;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n                return \"\";\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230656,
                "title": "collect-requirements-then-build-greedily-to-satisfy-it",
                "content": "# Intuition\\n/*\\nLCP Must be;\\n1) symmetric matrix\\n2) diagonal element is [n,n-1,n-2,...,1]\\n3) less then equal at least.\\n  {4, 3, 2, 1},\\n  {3, 3, 2, 1},\\n  {2, 2, 2, 1},\\n  {1, 1, 1, 1};\\n\\n*/\\n\\nWe just try to create `word` greedily,\\nthen verify the `word` is surely the proper answer.\\n\\n\\n# Approach\\n\\n/*\\nBrute force.\\n\\n- Assert requirements.\\n- Build matrix greedily.\\n- Reconstruct LCP from the word built and validate the given LCP is created.\\n*/\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n```\\nclass Solution {\\n  public String findTheString(int[][] lcp) {\\n    int n = lcp.length;\\n    if (!isDiag(lcp, n)) { // Assert matrix is diagonal\\n      return \"\";\\n    }\\n    if (!isLeq(lcp, n)) { // Assert value is less than possible max value at each cell.\\n      return \"\";\\n    }\\n\\n    var w = new char[n];\\n    { // Build matrix greedily to create the smallest word.\\n      // As matrix is symmetric, building lower triangular matrix is enough.\\n      w[0] = \\'a\\';\\n      for (int c = 0; c < n; c++) {\\n        for (int r = c; r < n; r++) {\\n          if (lcp[r][c] == 0) {\\n            if (w[r] == w[c] || w[r] == \\'\\\\0\\') {\\n              w[r] = (char) (w[c] + 1);\\n            }\\n          } else {\\n            w[r] = w[c];\\n          }\\n        }\\n      }\\n    }\\n    // Check only alphabetic char is used.\\n    for (int i = 0; i < w.length; i++) {\\n      if (!Character.isAlphabetic(w[i])) {\\n        return \"\";\\n      }\\n    }\\n\\n    var s = String.valueOf(w);\\n    // Reconstruct LCP from the word built and validate the given LCP is created.\\n    if (!Arrays.deepEquals(buildLcp(w, n), lcp)) { // validate\\n      return \"\";\\n    }\\n    return s;\\n  }\\n\\n  private int[][] buildLcp(char[] s, int n) {\\n    var res = new int[n][n];\\n    for (int r = n - 1; r >= 0; r--) {\\n      for (int c = n - 1; c >= 0; c--) {\\n        if (s[r] == s[c]) {\\n          res[r][c] = 1;\\n          if (r + 1 < n && c + 1 < n) {\\n            res[r][c] += res[r + 1][c + 1];\\n          }\\n        }\\n      }\\n    }\\n    return res;\\n  }\\n\\n  private boolean isLeq(int[][] lcp, int n) {\\n    for (int r = 0; r < n; r++) {\\n      int remRow = n - r;\\n      for (int c = 0; c < n; c++) {\\n        int remCol = n - c;\\n        var v = lcp[r][c];\\n        if (v > remRow || v > remCol) {\\n          return false;\\n        }\\n        if (r == c && v != remRow) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  private boolean isDiag(int[][] lcp, int n) {\\n    for (int r = 0; r < n; r++) {\\n      for (int c = r; c < n; c++) {\\n        if (lcp[r][c] != lcp[c][r]) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public String findTheString(int[][] lcp) {\\n    int n = lcp.length;\\n    if (!isDiag(lcp, n)) { // Assert matrix is diagonal\\n      return \"\";\\n    }\\n    if (!isLeq(lcp, n)) { // Assert value is less than possible max value at each cell.\\n      return \"\";\\n    }\\n\\n    var w = new char[n];\\n    { // Build matrix greedily to create the smallest word.\\n      // As matrix is symmetric, building lower triangular matrix is enough.\\n      w[0] = \\'a\\';\\n      for (int c = 0; c < n; c++) {\\n        for (int r = c; r < n; r++) {\\n          if (lcp[r][c] == 0) {\\n            if (w[r] == w[c] || w[r] == \\'\\\\0\\') {\\n              w[r] = (char) (w[c] + 1);\\n            }\\n          } else {\\n            w[r] = w[c];\\n          }\\n        }\\n      }\\n    }\\n    // Check only alphabetic char is used.\\n    for (int i = 0; i < w.length; i++) {\\n      if (!Character.isAlphabetic(w[i])) {\\n        return \"\";\\n      }\\n    }\\n\\n    var s = String.valueOf(w);\\n    // Reconstruct LCP from the word built and validate the given LCP is created.\\n    if (!Arrays.deepEquals(buildLcp(w, n), lcp)) { // validate\\n      return \"\";\\n    }\\n    return s;\\n  }\\n\\n  private int[][] buildLcp(char[] s, int n) {\\n    var res = new int[n][n];\\n    for (int r = n - 1; r >= 0; r--) {\\n      for (int c = n - 1; c >= 0; c--) {\\n        if (s[r] == s[c]) {\\n          res[r][c] = 1;\\n          if (r + 1 < n && c + 1 < n) {\\n            res[r][c] += res[r + 1][c + 1];\\n          }\\n        }\\n      }\\n    }\\n    return res;\\n  }\\n\\n  private boolean isLeq(int[][] lcp, int n) {\\n    for (int r = 0; r < n; r++) {\\n      int remRow = n - r;\\n      for (int c = 0; c < n; c++) {\\n        int remCol = n - c;\\n        var v = lcp[r][c];\\n        if (v > remRow || v > remCol) {\\n          return false;\\n        }\\n        if (r == c && v != remRow) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  private boolean isDiag(int[][] lcp, int n) {\\n    for (int r = 0; r < n; r++) {\\n      for (int c = r; c < n; c++) {\\n        if (lcp[r][c] != lcp[c][r]) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230597,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n  vector<int> idxToParent;\\n  vector<vector<bool>> eligible;\\n  vector<char> parentToChar;\\n  vector<unordered_set<int>> different;\\n\\n  int getParent(int idx) {\\n    if (idxToParent[idx] == -1) {\\n      idxToParent[idx] = idx;\\n    }\\n    if (idxToParent[idx] == idx) {\\n      return idx;\\n    }\\n    idxToParent[idx] = getParent(idxToParent[idx]);\\n    return idxToParent[idx];\\n  }\\n  \\n  bool combineParents(int idx1, int idx2) {\\n    int parentIdx1 = getParent(idx1);\\n    int parentIdx2 = getParent(idx2);\\n    for (int i = 0; i < 26; ++i) {\\n      if (eligible[parentIdx1][i] != eligible[parentIdx2][i]) {\\n        return false;\\n      }\\n    }\\n    if (different[parentIdx1].find(parentIdx2) != different[parentIdx1].end()) {\\n      return false;\\n    }\\n    if (different[parentIdx2].find(parentIdx1) != different[parentIdx2].end()) {\\n      return false;\\n    }\\n    for (auto it = different[parentIdx2].begin();\\n        it != different[parentIdx2].end();\\n        ++it) {\\n      different[parentIdx1].insert(*it);\\n    }\\n    idxToParent[parentIdx2] = parentIdx1;\\n    return true;\\n  }\\n  \\n  bool tryFilling(int idx, char c) {\\n    int cIdx = c - \\'a\\';\\n    int parentIdx = getParent(idx);\\n    if (!eligible[parentIdx][cIdx]) return false;\\n    for (auto it = different[parentIdx].begin();\\n         it != different[parentIdx].end();\\n         ++it) {\\n      eligible[getParent(*it)][cIdx] = false;\\n    }\\n    parentToChar[parentIdx] = c;\\n    return true;\\n  }\\n  \\n  string findTheString(vector<vector<int>>& lcp) {\\n    int n = lcp.size();\\n    idxToParent = vector<int>(n, -1);\\n    parentToChar = vector<char>(n, 0);\\n    eligible = vector<vector<bool>>(n, vector<bool>(26, true));\\n    different = vector<unordered_set<int>>(n);\\n    \\n    for (int i = 0; i < n; ++i) {\\n      if (lcp[i][i] != (n - i)) return \"\";\\n      for (int j = i; j < n; ++j) {\\n        if (i < n - 1 && j < n - 1) {\\n          if (lcp[i][j] != 0 && ((lcp[i][j] - lcp[i + 1][j + 1]) != 1)) {\\n            return \"\";\\n          }\\n        }\\n        if (lcp[i][j] != lcp[j][i]) return \"\";\\n        if (lcp[i][j] > (n - j)) return \"\";\\n        if (lcp[i][j] != 0) {\\n          if (!combineParents(i, j)) return \"\";\\n        } else {\\n          if (i == j) return \"\";\\n          different[getParent(i)].insert(getParent(j));\\n          different[getParent(j)].insert(getParent(i));\\n        }\\n      }\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {\\n      int parentIdx = getParent(i);\\n      if (parentToChar[parentIdx] != 0) continue;\\n      bool found = false;\\n      for (int j = 0; j < 26; ++j) {\\n        if (tryFilling(i, \\'a\\' + j)) {\\n          found = true;\\n          break;\\n        }\\n      }\\n      if (!found) {\\n        return \"\";\\n      }\\n    }\\n    string s = \"\";\\n    for (int i = 0; i < n; ++i) {\\n      s += parentToChar[getParent(i)];\\n    }\\n    return s;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> idxToParent;\\n  vector<vector<bool>> eligible;\\n  vector<char> parentToChar;\\n  vector<unordered_set<int>> different;\\n\\n  int getParent(int idx) {\\n    if (idxToParent[idx] == -1) {\\n      idxToParent[idx] = idx;\\n    }\\n    if (idxToParent[idx] == idx) {\\n      return idx;\\n    }\\n    idxToParent[idx] = getParent(idxToParent[idx]);\\n    return idxToParent[idx];\\n  }\\n  \\n  bool combineParents(int idx1, int idx2) {\\n    int parentIdx1 = getParent(idx1);\\n    int parentIdx2 = getParent(idx2);\\n    for (int i = 0; i < 26; ++i) {\\n      if (eligible[parentIdx1][i] != eligible[parentIdx2][i]) {\\n        return false;\\n      }\\n    }\\n    if (different[parentIdx1].find(parentIdx2) != different[parentIdx1].end()) {\\n      return false;\\n    }\\n    if (different[parentIdx2].find(parentIdx1) != different[parentIdx2].end()) {\\n      return false;\\n    }\\n    for (auto it = different[parentIdx2].begin();\\n        it != different[parentIdx2].end();\\n        ++it) {\\n      different[parentIdx1].insert(*it);\\n    }\\n    idxToParent[parentIdx2] = parentIdx1;\\n    return true;\\n  }\\n  \\n  bool tryFilling(int idx, char c) {\\n    int cIdx = c - \\'a\\';\\n    int parentIdx = getParent(idx);\\n    if (!eligible[parentIdx][cIdx]) return false;\\n    for (auto it = different[parentIdx].begin();\\n         it != different[parentIdx].end();\\n         ++it) {\\n      eligible[getParent(*it)][cIdx] = false;\\n    }\\n    parentToChar[parentIdx] = c;\\n    return true;\\n  }\\n  \\n  string findTheString(vector<vector<int>>& lcp) {\\n    int n = lcp.size();\\n    idxToParent = vector<int>(n, -1);\\n    parentToChar = vector<char>(n, 0);\\n    eligible = vector<vector<bool>>(n, vector<bool>(26, true));\\n    different = vector<unordered_set<int>>(n);\\n    \\n    for (int i = 0; i < n; ++i) {\\n      if (lcp[i][i] != (n - i)) return \"\";\\n      for (int j = i; j < n; ++j) {\\n        if (i < n - 1 && j < n - 1) {\\n          if (lcp[i][j] != 0 && ((lcp[i][j] - lcp[i + 1][j + 1]) != 1)) {\\n            return \"\";\\n          }\\n        }\\n        if (lcp[i][j] != lcp[j][i]) return \"\";\\n        if (lcp[i][j] > (n - j)) return \"\";\\n        if (lcp[i][j] != 0) {\\n          if (!combineParents(i, j)) return \"\";\\n        } else {\\n          if (i == j) return \"\";\\n          different[getParent(i)].insert(getParent(j));\\n          different[getParent(j)].insert(getParent(i));\\n        }\\n      }\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {\\n      int parentIdx = getParent(i);\\n      if (parentToChar[parentIdx] != 0) continue;\\n      bool found = false;\\n      for (int j = 0; j < 26; ++j) {\\n        if (tryFilling(i, \\'a\\' + j)) {\\n          found = true;\\n          break;\\n        }\\n      }\\n      if (!found) {\\n        return \"\";\\n      }\\n    }\\n    string s = \"\";\\n    for (int i = 0; i < n; ++i) {\\n      s += parentToChar[getParent(i)];\\n    }\\n    return s;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228351,
                "title": "c-o-n-2-easy-explanation",
                "content": "\\n\\t[[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\\n1. string is of length n, in this case 4 (\"####\")\\n2. for a particular index j in this string s we check all its previous characters( i : j-1 -> 0)\\n   to check for common prefix\\n    if(lcp[i][j] > 1) it means that they have a common prefix or we can say s[j] == s[i];\\n    if(lcp[i][j] == 0) it means that they have no common prefix so we can say that s[j] cannot be     s[i] for this we create an invalid array of char so that after traversing from i: j-1 -> 0 we       can find that lexicographically smallest char that we can insert is no char that we return \"\";\\n3. after creating the string s we check if the lcp matrix is valid from the generated string \\n```\\n  0,1,2,3\\n0[4,0,2,0],\\n1[0,3,0,1],\\n2[2,0,2,0],\\n3[0,1,0,1],\\n\\nj = 0, c(char to be inserted at j) = \\'$\\'(initially)\\n    i = -1 exit i loop \\n    since c == \\'$\\' first valid char that can be inserted \\'a\\' so c = \\'a\\'\\ns = \"a\"\\n\\nj = 1, c = \\'$\\'\\n    i = 0 \\n        lcp[i][j] == 0 no prefix or s[j] cannot be s[i] therefore invalid[s[i]] = 1;\\n    i = -1 exit i loop \\n    since c == \\'$\\' first valid char that can be inserted \\'b\\' so c = \\'b\\'\\ns = \"ab\"\\n\\nj = 2, c = \\'$\\'\\n    i = 1\\n        lcp[i][j] == 0 no prefix or s[j] cannot be s[i] therefore invalid[s[i]] = 1;\\n    i = 0 \\n        lcp[i][j] > 1 common prefix or s[j] = s[i] therefore c = s[i];\\n    i = -1 exit i loop \\n    since c != \\'$\\' we push c(a)\\ns = \"aba\"\\n\\nj = 3, c = \\'$\\'\\n    i = 2\\n        lcp[i][j] == 0 no prefix or s[j] cannot be s[i] therefore invalid[s[i]] = 1;\\n    i = 1\\n        lcp[i][j] > 1 common prefix or s[j] = s[i] therefore c = s[i];\\n    i = 0\\n        lcp[i][j] == 0 no prefix or s[j] cannot be s[i] therefore invalid[s[i]] = 1;\\n    i = -1 exit i loop \\n    since c != \\'$\\' we push c(b)\\ns = \"abab\"\\n```\\n4. for checking LCP matrix through generated string through bottom up dp\\n   s = \"abab\" ||  i : n-1 -> 0 || j : n-1 -> 0\\n   general idea: \\n       if(s[i] == s[j]) then longest common prefix will be lcp of (s[i+1]&s[j+1])+1\\n       lcp[i][j] must lcp[i+1][j+1]+1 if s[i] == s[j]\\n\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size(),v;\\n        string res = \"\"; vector<int> invalid;\\n        for(int j=0; j<n; ++j){\\n            invalid = vector<int>(26,0);\\n            char c = \\'$\\';\\n            for(int i=j-1; i>=0; --i){\\n                if(lcp[i][j] > 0){\\n                    if(c != \\'$\\' && c != res[i]) return \"\";\\n                    else c = res[i];\\n                }else{\\n                    invalid[res[i]-\\'a\\'] = 1;\\n                }\\n            }\\n            if(c == \\'$\\'){\\n                for(int k=0; k<26; ++k){\\n                    if(!invalid[k]){\\n                        c = \\'a\\'+k; break;\\n                    }\\n                }\\n                if(c == \\'$\\') return \"\";\\n            }\\n            res.push_back(c);\\n        }\\n        \\n        for(int i=n-1; i>=0; --i){\\n            for(int j=n-1; j>=0; --j){\\n                v = 0;\\n\\t\\t\\t\\t// (i+1 == n || j+1 == n)  check for out of bounds\\n                if(res[i] == res[j]) v = (i+1 == n || j+1 == n) ? 1 : lcp[i+1][j+1]+1;\\n                if(lcp[i][j] != v) return \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n  0,1,2,3\\n0[4,0,2,0],\\n1[0,3,0,1],\\n2[2,0,2,0],\\n3[0,1,0,1],\\n\\nj = 0, c(char to be inserted at j) = \\'$\\'(initially)\\n    i = -1 exit i loop \\n    since c == \\'$\\' first valid char that can be inserted \\'a\\' so c = \\'a\\'\\ns = \"a\"\\n\\nj = 1, c = \\'$\\'\\n    i = 0 \\n        lcp[i][j] == 0 no prefix or s[j] cannot be s[i] therefore invalid[s[i]] = 1;\\n    i = -1 exit i loop \\n    since c == \\'$\\' first valid char that can be inserted \\'b\\' so c = \\'b\\'\\ns = \"ab\"\\n\\nj = 2, c = \\'$\\'\\n    i = 1\\n        lcp[i][j] == 0 no prefix or s[j] cannot be s[i] therefore invalid[s[i]] = 1;\\n    i = 0 \\n        lcp[i][j] > 1 common prefix or s[j] = s[i] therefore c = s[i];\\n    i = -1 exit i loop \\n    since c != \\'$\\' we push c(a)\\ns = \"aba\"\\n\\nj = 3, c = \\'$\\'\\n    i = 2\\n        lcp[i][j] == 0 no prefix or s[j] cannot be s[i] therefore invalid[s[i]] = 1;\\n    i = 1\\n        lcp[i][j] > 1 common prefix or s[j] = s[i] therefore c = s[i];\\n    i = 0\\n        lcp[i][j] == 0 no prefix or s[j] cannot be s[i] therefore invalid[s[i]] = 1;\\n    i = -1 exit i loop \\n    since c != \\'$\\' we push c(b)\\ns = \"abab\"\\n```\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size(),v;\\n        string res = \"\"; vector<int> invalid;\\n        for(int j=0; j<n; ++j){\\n            invalid = vector<int>(26,0);\\n            char c = \\'$\\';\\n            for(int i=j-1; i>=0; --i){\\n                if(lcp[i][j] > 0){\\n                    if(c != \\'$\\' && c != res[i]) return \"\";\\n                    else c = res[i];\\n                }else{\\n                    invalid[res[i]-\\'a\\'] = 1;\\n                }\\n            }\\n            if(c == \\'$\\'){\\n                for(int k=0; k<26; ++k){\\n                    if(!invalid[k]){\\n                        c = \\'a\\'+k; break;\\n                    }\\n                }\\n                if(c == \\'$\\') return \"\";\\n            }\\n            res.push_back(c);\\n        }\\n        \\n        for(int i=n-1; i>=0; --i){\\n            for(int j=n-1; j>=0; --j){\\n                v = 0;\\n\\t\\t\\t\\t// (i+1 == n || j+1 == n)  check for out of bounds\\n                if(res[i] == res[j]) v = (i+1 == n || j+1 == n) ? 1 : lcp[i+1][j+1]+1;\\n                if(lcp[i][j] != v) return \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221738,
                "title": "c-solution-union-find",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>fa;\\n    int findFather(int x)\\n    {\\n        if(fa[x]==x)return x;\\n        return fa[x]=findFather(fa[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        x=fa[x];\\n        y=fa[y];\\n        fa[y]=x;\\n        return;\\n    }\\n    string findTheString(vector<vector<int>>& lcp)\\n    {\\n        int n=lcp.size();\\n        fa.resize(n);\\n        for(int i=0;i<n;i++)fa[i]=i;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(lcp[i][j]==0)continue;\\n                if(findFather(i)!=findFather(j))Union(i,j);\\n                if(i==j&&(lcp[i][j]!=n-i))return \"\";\\n            }\\n        set<int>Set;\\n        for(int i=0;i<n;i++)Set.insert(findFather(i));\\n        if(Set.size()>26)return \"\";\\n        map<int,char>Map;\\n        char c=\\'a\\';\\n        string res=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(Map.count(fa[i])==false)\\n            {\\n                Map[fa[i]]=c;\\n                c++;\\n            }\\n            res.push_back(Map[fa[i]]);\\n        }\\n        vector<vector<int>>f(n,vector<int>(n,0));\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(res[i]!=res[j])f[i][j]=0;\\n                else if(i+1<n&&j+1<n)f[i][j]=f[i+1][j+1]+1;\\n                else f[i][j]=1;\\n            }\\n        for(int i=0;i<n;i++)for(int j=0;j<n;j++)if(f[i][j]!=lcp[i][j])return \"\";\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>fa;\\n    int findFather(int x)\\n    {\\n        if(fa[x]==x)return x;\\n        return fa[x]=findFather(fa[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        x=fa[x];\\n        y=fa[y];\\n        fa[y]=x;\\n        return;\\n    }\\n    string findTheString(vector<vector<int>>& lcp)\\n    {\\n        int n=lcp.size();\\n        fa.resize(n);\\n        for(int i=0;i<n;i++)fa[i]=i;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(lcp[i][j]==0)continue;\\n                if(findFather(i)!=findFather(j))Union(i,j);\\n                if(i==j&&(lcp[i][j]!=n-i))return \"\";\\n            }\\n        set<int>Set;\\n        for(int i=0;i<n;i++)Set.insert(findFather(i));\\n        if(Set.size()>26)return \"\";\\n        map<int,char>Map;\\n        char c=\\'a\\';\\n        string res=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(Map.count(fa[i])==false)\\n            {\\n                Map[fa[i]]=c;\\n                c++;\\n            }\\n            res.push_back(Map[fa[i]]);\\n        }\\n        vector<vector<int>>f(n,vector<int>(n,0));\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(res[i]!=res[j])f[i][j]=0;\\n                else if(i+1<n&&j+1<n)f[i][j]=f[i+1][j+1]+1;\\n                else f[i][j]=1;\\n            }\\n        for(int i=0;i<n;i++)for(int j=0;j<n;j++)if(f[i][j]!=lcp[i][j])return \"\";\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221368,
                "title": "python3-greedy-o-n-2-solution-with-o-n-space-cost-with-some-exposition",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## Greedy\\nWe can construct a valid string, not necessarily the lexicographically smallest one, by starting to look at the `lcp[i][j]` values for large `i` and `j` and moving toward smaller values. For example, suppose the string we want to construct is `s` and `len(lcp) == n` then we can put an arbitrary letter at `s[n-1]`, say `s[n-1] = \\'z\\'`. `lcp[n-2][n-1]` is either `0` or `1`. If it is `1` that means `s[n-2] == s[n-1]` and we assign `s[n-2] = \\'z\\'`. If it is `0` then `s[n-2] != s[n-1]` and we assign a different letter to `s[n-2]`, say `s[n-2] = \\'y\\'`. Once the last two letters have been decided we can focus on `s[n-3]` and fix it by first comparing it with `s[n-1]` (i.e. by looking at `lcp[n-3][n-1]`), and then comparing it with `s[n-2]` (i.e. by looking at `lcp[n-3][n-2]`). This process can be continued until we have fixed the first letter `s[0]`.\\n\\nSicne we have to iterate over the 2d array `lcp`, the time complexity is going to be $$O(n^2)$$.\\n\\n## Lexicographically minimum\\nThe `lcp` matrix does not change if we change distinct letters in the string by distinct letters. So, once a valid string has been found it can be turned into the lexicographically smallest one by iterating once over the string. Before we start iterating, we consider all the letters in the alphabet to be avaialble. Then, wehenever we encounter a new letter in the string, we replace it with the smallest available letter, and mark that letter as unavailable. This takes $$O(n)$$ time, which is subleading to the $$O(n^2)$$ cost of iterating over `lcp`.\\n\\n## Some observations about a valid lcp matrix\\n1. It is symmetric, obviously, the lcp of `s[i:]` and `s[j:]` is the same as that of `s[j:]` and `s[i:]`.\\n2. `lcp[i][i] == n-i` because the lcp of `s[i]` and `s[i]` is `s[i]` itself. We use these to check if we have a valid `lcp` matrix as we iterate over it.\\n3. If `lcp[i][j] != 0`, then `lcp[i][j] == lcp[i+1][j+1]+1` because the lcp of `s[i]` and `s[j]` is simply the lcp of `s[i+1]` and `s[j+1]` preceded by s[i]\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: list[list[int]]) -> str:\\n        n = len(lcp)\\n        \\n        # start with the possibility that any letter can be placed anywhere\\n        s = [\\'abcdefghijklmnopqrstuvwxyz\\' for _ in range(n)] \\n        # storing this array takes O(26*n) = O(n) space.\\n        \\n        # arbitrarily assing the final letter in the string\\n        s[-1] = \\'z\\'\\n        \\n        for row in range(n-1,-1,-1):\\n            for col in range(n-1, row-1, -1):\\n                # lcp has to be symmetric\\n                if lcp[row][col] != lcp[col][row]: return(\\'\\')\\n\\n                if row == col:\\n                    # lcp[i][i] has to equal n-i\\n                    if lcp[row][col] != n-row: return(\\'\\')\\n\\n                    # once we have compared s[row] with s[row+1:] and eliminated all letters from the possible choices for s[row], we can freely assign one out of the remaining pool. If nothing remains in the pool, a valid string does not exist.\\n                    if len(s[row]): s[row] = s[row][-1]\\n                    else: return(\\'\\')\\n                    continue\\n                        \\n                c = s[col]\\n                \\n                # if lcp[row][col] is zero, we remove s[col] from the list of possible letters for s[row]\\n                if lcp[row][col] == 0:\\n                    if s[row][-1] == c: s[row] = s[row][:-1]\\n                    if not s[row]: return(\\'\\')\\n                    continue\\n                \\n                # if lcp[i][j] is nonzero then it must equal lcp[i+1][j+1] + 1 \\n                if lcp[row][col] > min(n-row, n-col): return(\\'\\')\\n                if col < n-1 and lcp[row+1][col+1] != lcp[row][col]-1: return(\\'\\')\\n                \\n                # once all these checks have been passed and lcp[row][col] is nonzero, we can safely assign s[row] to be equal to s[col]\\n                if c not in s[row]: return(\\'\\')\\n                else: s[row] = c\\n                    \\n        # from the existing string s (a list of characters at the momen), generate the lexicographically smallest one\\n        sub = 26*[None]\\n        newLetter = \\'a\\'\\n        for i, c in enumerate(s):\\n            if sub[ord(c)-ord(\\'a\\')] is None:\\n                sub[ord(c)-ord(\\'a\\')] = newLetter\\n                s[i] = newLetter\\n                newLetter = chr(ord(newLetter)+1)\\n            else:\\n                s[i] = sub[ord(s[i])-ord(\\'a\\')]\\n        \\n        return(\\'\\'.join(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp: list[list[int]]) -> str:\\n        n = len(lcp)\\n        \\n        # start with the possibility that any letter can be placed anywhere\\n        s = [\\'abcdefghijklmnopqrstuvwxyz\\' for _ in range(n)] \\n        # storing this array takes O(26*n) = O(n) space.\\n        \\n        # arbitrarily assing the final letter in the string\\n        s[-1] = \\'z\\'\\n        \\n        for row in range(n-1,-1,-1):\\n            for col in range(n-1, row-1, -1):\\n                # lcp has to be symmetric\\n                if lcp[row][col] != lcp[col][row]: return(\\'\\')\\n\\n                if row == col:\\n                    # lcp[i][i] has to equal n-i\\n                    if lcp[row][col] != n-row: return(\\'\\')\\n\\n                    # once we have compared s[row] with s[row+1:] and eliminated all letters from the possible choices for s[row], we can freely assign one out of the remaining pool. If nothing remains in the pool, a valid string does not exist.\\n                    if len(s[row]): s[row] = s[row][-1]\\n                    else: return(\\'\\')\\n                    continue\\n                        \\n                c = s[col]\\n                \\n                # if lcp[row][col] is zero, we remove s[col] from the list of possible letters for s[row]\\n                if lcp[row][col] == 0:\\n                    if s[row][-1] == c: s[row] = s[row][:-1]\\n                    if not s[row]: return(\\'\\')\\n                    continue\\n                \\n                # if lcp[i][j] is nonzero then it must equal lcp[i+1][j+1] + 1 \\n                if lcp[row][col] > min(n-row, n-col): return(\\'\\')\\n                if col < n-1 and lcp[row+1][col+1] != lcp[row][col]-1: return(\\'\\')\\n                \\n                # once all these checks have been passed and lcp[row][col] is nonzero, we can safely assign s[row] to be equal to s[col]\\n                if c not in s[row]: return(\\'\\')\\n                else: s[row] = c\\n                    \\n        # from the existing string s (a list of characters at the momen), generate the lexicographically smallest one\\n        sub = 26*[None]\\n        newLetter = \\'a\\'\\n        for i, c in enumerate(s):\\n            if sub[ord(c)-ord(\\'a\\')] is None:\\n                sub[ord(c)-ord(\\'a\\')] = newLetter\\n                s[i] = newLetter\\n                newLetter = chr(ord(newLetter)+1)\\n            else:\\n                s[i] = sub[ord(s[i])-ord(\\'a\\')]\\n        \\n        return(\\'\\'.join(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217216,
                "title": "javascript-dp-171ms",
                "content": "```\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(0));\\nconst char = (ascii) => String.fromCharCode(ascii);\\n\\nconst findTheString = (g) => {\\n    let n = g.length, res = Array(n).fill(-1), max = 1, dp = initialize2DArray(n, n);\\n    res[0] = 0;\\n    for (let i = 1; i < n; i++) {\\n        let match = false;\\n        for (let j = 0; j < i; j++) {\\n            if (g[i][j] > 0) {\\n                res[i] = res[j];\\n                match = true;\\n                break;\\n            }\\n        }\\n        if (!match) {\\n            res[i] = max;\\n            if (res[i] >= 26) return \\'\\';\\n            max++;\\n        }\\n    }\\n    dp[n - 1][n - 1] = 1;\\n    for (let i = n - 2; ~i; i--) {\\n        for (let j = i; j < n; j++) {\\n            if (res[i] != res[j]) {\\n                dp[i][j] = 0;\\n            } else {\\n                dp[i][j] = j + 1 < n ? dp[i + 1][j + 1] + 1 : 1;\\n            }\\n        }\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (dp[i][j] != g[i][j] || dp[i][j] != g[j][i]) return \\'\\';\\n        }\\n    }\\n    return res.map(x => char(x + 97)).join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(0));\\nconst char = (ascii) => String.fromCharCode(ascii);\\n\\nconst findTheString = (g) => {\\n    let n = g.length, res = Array(n).fill(-1), max = 1, dp = initialize2DArray(n, n);\\n    res[0] = 0;\\n    for (let i = 1; i < n; i++) {\\n        let match = false;\\n        for (let j = 0; j < i; j++) {\\n            if (g[i][j] > 0) {\\n                res[i] = res[j];\\n                match = true;\\n                break;\\n            }\\n        }\\n        if (!match) {\\n            res[i] = max;\\n            if (res[i] >= 26) return \\'\\';\\n            max++;\\n        }\\n    }\\n    dp[n - 1][n - 1] = 1;\\n    for (let i = n - 2; ~i; i--) {\\n        for (let j = i; j < n; j++) {\\n            if (res[i] != res[j]) {\\n                dp[i][j] = 0;\\n            } else {\\n                dp[i][j] = j + 1 < n ? dp[i + 1][j + 1] + 1 : 1;\\n            }\\n        }\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (dp[i][j] != g[i][j] || dp[i][j] != g[j][i]) return \\'\\';\\n        }\\n    }\\n    return res.map(x => char(x + 97)).join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3216904,
                "title": "dsu-z-function-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njust did what the question said with help of suitable ds and Z function\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass dsu():\\n\\tdef __init__(self,n):\\n\\t\\tself.parent=[0]*(n)\\n\\t\\tself.sz=[0]*(n)\\n\\n\\tdef make_set(self,v):\\n\\t\\tself.parent[v]=v\\n\\t\\tself.sz[v]=1\\n\\n\\tdef find_set(self,v):\\n\\t\\tif v==self.parent[v]:\\n\\t\\t\\treturn v\\n\\t\\tself.parent[v]=self.find_set(self.parent[v])\\n\\t\\treturn self.parent[v]\\n\\n\\tdef union(self,a,b):\\n\\t\\ta=self.find_set(a)\\n\\t\\tb=self.find_set(b)\\n\\t\\tif a==b:\\n\\t\\t\\treturn\\n\\t\\tif self.sz[a]<self.sz[b]:\\n\\t\\t\\ta,b=b,a\\n\\t\\tself.parent[b]=a\\n\\t\\tself.sz[a]+=self.sz[b]\\n\\n\\tdef getsize(self,v):\\n\\t\\treturn self.sz[self.find_set(v)]\\ndef Z(s):\\n\\tn=len(s)\\n\\tx=0;y=0\\n\\tz=[0]*(n)\\n\\tfor i in range(1,n):\\n\\t\\tz[i]=max(0,min(z[i-x],y-i+1))\\n\\t\\twhile i+z[i]<n and s[z[i]]==s[i+z[i]]:\\n\\t\\t\\tx=i\\n\\t\\t\\ty=i+z[i]\\n\\t\\t\\tz[i]+=1\\n\\treturn z\\nclass Solution:\\n    def findTheString(self, l: List[List[int]]) -> str:\\n        pairs=[]\\n        n=len(l)\\n        ds=dsu(n)\\n        for i in range(n):\\n            ds.make_set(i)\\n        for i in range(n):\\n            for j in range(n):\\n                if l[i][j]:\\n                    if ds.find_set(i)!=ds.find_set(j):\\n                        ds.union(i,j)\\n        st=defaultdict(list)\\n        for i in range(n):\\n            st[ds.find_set(i)].append(i)\\n        vis=[0]*n\\n        let=\"abcdefghijklmnopqrstuvwxyz\"\\n        print(len(let))\\n        base=0\\n        sr=[\"-1\"]*n\\n        for i in range(n):\\n        \\n            if vis[i]:\\n                continue\\n            for vl in st[ds.find_set(i)]:\\n                vis[vl]=1\\n                sr[vl]=let[base]\\n            base+=1\\n            if base>=26:\\n                base=0\\n                # return \"\"\\n        fl=False\\n        lc=[]\\n        sr=\"\".join(sr)\\n        for i in range(n):\\n            li=sr[i:]\\n            x=li+\"#\"+sr\\n            zr=Z(x)\\n            print(zr)\\n            lc.append(zr[len(li)+1:])\\n        if lc!=l:\\n            return \"\"\\n        return sr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass dsu():\\n\\tdef __init__(self,n):\\n\\t\\tself.parent=[0]*(n)\\n\\t\\tself.sz=[0]*(n)\\n\\n\\tdef make_set(self,v):\\n\\t\\tself.parent[v]=v\\n\\t\\tself.sz[v]=1\\n\\n\\tdef find_set(self,v):\\n\\t\\tif v==self.parent[v]:\\n\\t\\t\\treturn v\\n\\t\\tself.parent[v]=self.find_set(self.parent[v])\\n\\t\\treturn self.parent[v]\\n\\n\\tdef union(self,a,b):\\n\\t\\ta=self.find_set(a)\\n\\t\\tb=self.find_set(b)\\n\\t\\tif a==b:\\n\\t\\t\\treturn\\n\\t\\tif self.sz[a]<self.sz[b]:\\n\\t\\t\\ta,b=b,a\\n\\t\\tself.parent[b]=a\\n\\t\\tself.sz[a]+=self.sz[b]\\n\\n\\tdef getsize(self,v):\\n\\t\\treturn self.sz[self.find_set(v)]\\ndef Z(s):\\n\\tn=len(s)\\n\\tx=0;y=0\\n\\tz=[0]*(n)\\n\\tfor i in range(1,n):\\n\\t\\tz[i]=max(0,min(z[i-x],y-i+1))\\n\\t\\twhile i+z[i]<n and s[z[i]]==s[i+z[i]]:\\n\\t\\t\\tx=i\\n\\t\\t\\ty=i+z[i]\\n\\t\\t\\tz[i]+=1\\n\\treturn z\\nclass Solution:\\n    def findTheString(self, l: List[List[int]]) -> str:\\n        pairs=[]\\n        n=len(l)\\n        ds=dsu(n)\\n        for i in range(n):\\n            ds.make_set(i)\\n        for i in range(n):\\n            for j in range(n):\\n                if l[i][j]:\\n                    if ds.find_set(i)!=ds.find_set(j):\\n                        ds.union(i,j)\\n        st=defaultdict(list)\\n        for i in range(n):\\n            st[ds.find_set(i)].append(i)\\n        vis=[0]*n\\n        let=\"abcdefghijklmnopqrstuvwxyz\"\\n        print(len(let))\\n        base=0\\n        sr=[\"-1\"]*n\\n        for i in range(n):\\n        \\n            if vis[i]:\\n                continue\\n            for vl in st[ds.find_set(i)]:\\n                vis[vl]=1\\n                sr[vl]=let[base]\\n            base+=1\\n            if base>=26:\\n                base=0\\n                # return \"\"\\n        fl=False\\n        lc=[]\\n        sr=\"\".join(sr)\\n        for i in range(n):\\n            li=sr[i:]\\n            x=li+\"#\"+sr\\n            zr=Z(x)\\n            print(zr)\\n            lc.append(zr[len(li)+1:])\\n        if lc!=l:\\n            return \"\"\\n        return sr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215910,
                "title": "a-leetcode-noob-s-solution",
                "content": "Feel free to make optimizations. I just wanted to post this bc i felt proud of myself\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\" # alphabet\\n        alpha_map = {alpha[i]: i for i in range(26)} # needed to find the next letter index after a given letter \\n        i_to_letter = {i: \"a\" for i in range(n)} # we assume best case scenario (every letter is a) and change the index->letter map as we iterate n**2 over lcp\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                length_too_big = lcp[i][j] > n - j # impossible length\\n                pardox_letter =  i == j and not lcp[i][j] # letter at i==j means it has to be a prefix of 1 or more\\n                parodox_prefix = lcp[i][j] != lcp[j][i] # the inverse of i, j should be equal, longest prefix from i->n-1 and j->n-1 when i and j swap\\n                if length_too_big or pardox_letter or parodox_prefix:\\n                    return \"\"\\n                \\n                if i_to_letter[i] == i_to_letter[j]:\\n                    # if they belong to same letter \\n                    if lcp[i][j] == 0:\\n                        # we have unmatching characters and need to increase letter ord  of j (we pick j bc its going to create a smaller lexographical word)\\n                        nxt_idx = alpha_map[i_to_letter[i]] + 1\\n                        if nxt_idx >= 26: \\n                            # we cannot create a word that goes past letter z\\n                            return \"\" \\n                        i_to_letter[j] = alpha[nxt_idx]\\n                    else:\\n                        # we have matching characters, then we need to check if the current prefix it forms aligns with the next one\\n                        if i + 1 < n and j + 1 < n and lcp[i+1][j+1] != lcp[i][j] - 1: \\n                            # the next prefix at location lcp[i+1, j+1] should be one minus the length of the current prefix to make it a valid prefix\\n                            return \"\"\\n                else:\\n                    # i and j do not belong to same letter\\n                    if lcp[i][j]: \\n                        # if i and j do not belong to same letter, they cannot have any prefix other than 0\\n                        return \"\"\\n                    \\n        \\n        return \"\".join([i_to_letter[i] for i in range(n)])\\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        alpha = \"abcdefghijklmnopqrstuvwxyz\" # alphabet\\n        alpha_map = {alpha[i]: i for i in range(26)} # needed to find the next letter index after a given letter \\n        i_to_letter = {i: \"a\" for i in range(n)} # we assume best case scenario (every letter is a) and change the index->letter map as we iterate n**2 over lcp\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                length_too_big = lcp[i][j] > n - j # impossible length\\n                pardox_letter =  i == j and not lcp[i][j] # letter at i==j means it has to be a prefix of 1 or more\\n                parodox_prefix = lcp[i][j] != lcp[j][i] # the inverse of i, j should be equal, longest prefix from i->n-1 and j->n-1 when i and j swap\\n                if length_too_big or pardox_letter or parodox_prefix:\\n                    return \"\"\\n                \\n                if i_to_letter[i] == i_to_letter[j]:\\n                    # if they belong to same letter \\n                    if lcp[i][j] == 0:\\n                        # we have unmatching characters and need to increase letter ord  of j (we pick j bc its going to create a smaller lexographical word)\\n                        nxt_idx = alpha_map[i_to_letter[i]] + 1\\n                        if nxt_idx >= 26: \\n                            # we cannot create a word that goes past letter z\\n                            return \"\" \\n                        i_to_letter[j] = alpha[nxt_idx]\\n                    else:\\n                        # we have matching characters, then we need to check if the current prefix it forms aligns with the next one\\n                        if i + 1 < n and j + 1 < n and lcp[i+1][j+1] != lcp[i][j] - 1: \\n                            # the next prefix at location lcp[i+1, j+1] should be one minus the length of the current prefix to make it a valid prefix\\n                            return \"\"\\n                else:\\n                    # i and j do not belong to same letter\\n                    if lcp[i][j]: \\n                        # if i and j do not belong to same letter, they cannot have any prefix other than 0\\n                        return \"\"\\n                    \\n        \\n        return \"\".join([i_to_letter[i] for i in range(n)])\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215774,
                "title": "1sentence-build-the-sequence-by-looking-at-non-zero-elems-easy-and-verify-diagonally-from-the-end",
                "content": "\\n# Code\\n```\\ndef findTheString(self, lcp: List[List[int]]) -> str:\\n    n = len(lcp)\\n    seq = [0] * n\\n    letter = ord(\\'a\\')\\n    lcp.append([0] * (n+1))\\n    for i in range(0, n):\\n        if not seq[i]:\\n            for j in range(i, n):\\n                if lcp[i][j]:\\n                    seq[j] = letter\\n            letter += 1\\n    if letter > ord(\\'z\\') + 1:\\n        return \"\"\\n    for i in reversed(range(n)):\\n        for j in range(i+1):\\n            if not (lcp[i][j] == lcp[j][i] == (lcp[i+1][j+1] + 1 if seq[i] == seq[j] else 0)):\\n                return \"\"\\n    return \\'\\'.join([chr(i) for i in seq])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef findTheString(self, lcp: List[List[int]]) -> str:\\n    n = len(lcp)\\n    seq = [0] * n\\n    letter = ord(\\'a\\')\\n    lcp.append([0] * (n+1))\\n    for i in range(0, n):\\n        if not seq[i]:\\n            for j in range(i, n):\\n                if lcp[i][j]:\\n                    seq[j] = letter\\n            letter += 1\\n    if letter > ord(\\'z\\') + 1:\\n        return \"\"\\n    for i in reversed(range(n)):\\n        for j in range(i+1):\\n            if not (lcp[i][j] == lcp[j][i] == (lcp[i+1][j+1] + 1 if seq[i] == seq[j] else 0)):\\n                return \"\"\\n    return \\'\\'.join([chr(i) for i in seq])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3214324,
                "title": "c-intuitive-brute-accepted",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(i==j){\\n                    if(lcp[i][j] != n-i) return \"\";\\n                }\\n                else if(lcp[i][j] > n-j) return \"\";\\n                else if(lcp[i][j] != lcp[j][i]) return \"\";\\n            }\\n        }\\n        \\n        string s(n,\\'a\\');\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(lcp[i][j]==0 && s[i]==s[j]){\\n                    if(s[j]==\\'z\\') return \"\";\\n                    else s[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int f=i,y=j;\\n                bool fg=0;\\n                while(lcp[i][j]!=0){\\n                    if(s[f]!=s[y]) fg=1;\\n                    lcp[i][j]--,f++,y++;\\n                }\\n                if(f<n && y<n && s[f]==s[y]) return \"\";\\n                if(fg) return \"\";\\n                \\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(i==j){\\n                    if(lcp[i][j] != n-i) return \"\";\\n                }\\n                else if(lcp[i][j] > n-j) return \"\";\\n                else if(lcp[i][j] != lcp[j][i]) return \"\";\\n            }\\n        }\\n        \\n        string s(n,\\'a\\');\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(lcp[i][j]==0 && s[i]==s[j]){\\n                    if(s[j]==\\'z\\') return \"\";\\n                    else s[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int f=i,y=j;\\n                bool fg=0;\\n                while(lcp[i][j]!=0){\\n                    if(s[f]!=s[y]) fg=1;\\n                    lcp[i][j]--,f++,y++;\\n                }\\n                if(f<n && y<n && s[f]==s[y]) return \"\";\\n                if(fg) return \"\";\\n                \\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214214,
                "title": "simple-and-intuitive-java-solution-using-disjoint-set-union-union-find",
                "content": "# Intuition\\nif lcp[i][j] is > 0, then the substring (i, i+lcp[i][j]-1) equals (j, j+lcp[i][j]-1). This also means that character i+lcp[i][j] is not equal to j+lcp[i][j]. We can use disjoint set union to mark when 2 characters are equal.\\n\\n# Approach\\nWe actually don\\'t need to make sure that every substring that we know is the same is actually the same in dsu, only the first character. This is because if lcp[i][j] > 0 then lcp[i+1][j+1] = lcp[i][j]-1. This means when we go to position lcp[i+1][j+1] in the loop we are checking the second character in the same substring, so we don\\'t need to do it the first time. We only need to unite characters i and j if lcp[i][j] > 0 to signify that they are the same. After that we need to make sure that i+lcp[i][j] is not the same as j+lcp[i][j]. Then, if the number of connected components in disjoint set union (witch is the same as the number of distinct charaters) is > 26 it is impossible. So we can simply just go through each character, and assign the first connected components to the lowest possible characters to make the string lexographically the shortest (since this means we prioritize making the first characters smaller instead of the last characters).\\n\\nNote that we are using DSU for distinct characters. if a and b are in the same connected component, they are the same character. Otherwise they are different characters.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2 logN)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        DSU d = new DSU(n);\\n        for(int i = 0; i<n; i++) for(int j = 0; j<n; j++) if(lcp[i][j] != 0){\\n            d.unite(i, j);\\n            if(i != n-1 && j != n-1 && lcp[i+1][j+1] != lcp[i][j]-1) return \"\";\\n        }\\n        for(int i = 0; i<n; i++) for(int j = 0; j<n; j++){\\n            int a = i+lcp[i][j], b = j+lcp[i][j];\\n            if(a > n || b > n) return \"\";\\n            if(a != n && b != n && d.isSame(a, b)) return \"\";\\n        }\\n        if(d.getCC() > 26) return \"\";\\n        Map<Integer, Character> map = new HashMap<>();\\n        char last = \\'a\\';\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i<n; i++){\\n            Character get = map.get(d.get(i));\\n            if(get == null)\\n                map.put(d.get(i), get = last++);\\n            sb.append(get);\\n        }\\n        return sb.toString();\\n    }\\n\\tprivate static class DSU {\\n\\t\\tprivate int[] par, size;\\n\\t\\tprivate int cc;\\n\\n\\t\\tpublic DSU(int N) {\\n\\t\\t\\tpar = new int[N];\\n\\t\\t\\tsize = new int[N];\\n\\t\\t\\tcc = N;\\n\\t\\t\\tArrays.fill(par, -1);\\n\\t\\t\\tArrays.fill(size, 1);\\n\\t\\t}\\n\\n\\t\\tpublic int size(int num) {\\n\\t\\t\\treturn size[get(num)];\\n\\t\\t}\\n\\n\\t\\tpublic int get(int num) {\\n\\t\\t\\treturn par[num] == -1 ? num : (par[num] = get(par[num]));\\n\\t\\t}\\n\\n\\t\\tpublic boolean isSame(int x, int y) {\\n\\t\\t\\treturn get(x) == get(y);\\n\\t\\t}\\n\\n\\t\\tpublic boolean unite(int x, int y) {\\n\\t\\t\\tint p1 = get(x), p2 = get(y);\\n\\t\\t\\tif (p1 == p2)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (size[p1] < size[p2]) {\\n\\t\\t\\t\\tint s = p2;\\n\\t\\t\\t\\tp2 = p1;\\n\\t\\t\\t\\tp1 = s;\\n\\t\\t\\t}\\n\\t\\t\\tsize[p1] += size[p2];\\n\\t\\t\\tpar[p2] = p1;\\n\\t\\t\\tcc--;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic int getCC() {\\n\\t\\t\\treturn cc;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        DSU d = new DSU(n);\\n        for(int i = 0; i<n; i++) for(int j = 0; j<n; j++) if(lcp[i][j] != 0){\\n            d.unite(i, j);\\n            if(i != n-1 && j != n-1 && lcp[i+1][j+1] != lcp[i][j]-1) return \"\";\\n        }\\n        for(int i = 0; i<n; i++) for(int j = 0; j<n; j++){\\n            int a = i+lcp[i][j], b = j+lcp[i][j];\\n            if(a > n || b > n) return \"\";\\n            if(a != n && b != n && d.isSame(a, b)) return \"\";\\n        }\\n        if(d.getCC() > 26) return \"\";\\n        Map<Integer, Character> map = new HashMap<>();\\n        char last = \\'a\\';\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i<n; i++){\\n            Character get = map.get(d.get(i));\\n            if(get == null)\\n                map.put(d.get(i), get = last++);\\n            sb.append(get);\\n        }\\n        return sb.toString();\\n    }\\n\\tprivate static class DSU {\\n\\t\\tprivate int[] par, size;\\n\\t\\tprivate int cc;\\n\\n\\t\\tpublic DSU(int N) {\\n\\t\\t\\tpar = new int[N];\\n\\t\\t\\tsize = new int[N];\\n\\t\\t\\tcc = N;\\n\\t\\t\\tArrays.fill(par, -1);\\n\\t\\t\\tArrays.fill(size, 1);\\n\\t\\t}\\n\\n\\t\\tpublic int size(int num) {\\n\\t\\t\\treturn size[get(num)];\\n\\t\\t}\\n\\n\\t\\tpublic int get(int num) {\\n\\t\\t\\treturn par[num] == -1 ? num : (par[num] = get(par[num]));\\n\\t\\t}\\n\\n\\t\\tpublic boolean isSame(int x, int y) {\\n\\t\\t\\treturn get(x) == get(y);\\n\\t\\t}\\n\\n\\t\\tpublic boolean unite(int x, int y) {\\n\\t\\t\\tint p1 = get(x), p2 = get(y);\\n\\t\\t\\tif (p1 == p2)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (size[p1] < size[p2]) {\\n\\t\\t\\t\\tint s = p2;\\n\\t\\t\\t\\tp2 = p1;\\n\\t\\t\\t\\tp1 = s;\\n\\t\\t\\t}\\n\\t\\t\\tsize[p1] += size[p2];\\n\\t\\t\\tpar[p2] = p1;\\n\\t\\t\\tcc--;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic int getCC() {\\n\\t\\t\\treturn cc;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212068,
                "title": "python-solution-with-video-explanation",
                "content": "**Detailed Video explanation:**\\n\\nhttps://youtu.be/11VXS2Vbv3s\\n\\n# Intuition\\nBuild the string first then validate.\\n\\n# Approach\\n- build the string using lcp first by assing smallest lowercase char first \\n- validate the string using lcp matrix\\n- lcp[i][j] must equal lcp[i+1][j+1] + 1 if (i, j) shares common prefix\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n\\n        # build s\\n        s = [\\'\\' for _ in range(n)]\\n        c = \\'a\\' # \\'a\\' .... \\'z\\'\\n        for i in range(n):\\n            if s[i] != \\'\\':\\n                continue\\n            if c > \\'z\\': \\n                return \"\"\\n            s[i] = c\\n            for j in range(n):\\n                if lcp[i][j] > 0: # len(common_prefix(s[i:] , s[j:])) > 0\\n                    s[j] = s[i] \\n            c = chr(ord(c) + 1)\\n\\n        print(\"\".join(s))\\n\\n        # validate last column and last row\\n        for i in range(n):\\n            if lcp[i][n - 1] != (s[i] == s[n-1]):\\n                return \"\"\\n            if lcp[n-1][i] != (s[i] == s[n-1]):\\n                return \"\"\\n\\n        # validate rest of lcp: if s[i] == s[j] => lcp[i][j] = 1 + lcp[i+1][j+1]\\n        for i in range(n-1):\\n            for j in range(n-1):\\n                if s[i] == s[j]:\\n                    if lcp[i][j] != 1 + lcp[i+1][j+1]: \\n                        return \"\"\\n                else: # char at i and j are different => lcp[i][j] should be 0\\n                    if lcp[i][j] != 0:\\n                        return \"\"\\n\\n        return \"\".join(s)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n\\n        # build s\\n        s = [\\'\\' for _ in range(n)]\\n        c = \\'a\\' # \\'a\\' .... \\'z\\'\\n        for i in range(n):\\n            if s[i] != \\'\\':\\n                continue\\n            if c > \\'z\\': \\n                return \"\"\\n            s[i] = c\\n            for j in range(n):\\n                if lcp[i][j] > 0: # len(common_prefix(s[i:] , s[j:])) > 0\\n                    s[j] = s[i] \\n            c = chr(ord(c) + 1)\\n\\n        print(\"\".join(s))\\n\\n        # validate last column and last row\\n        for i in range(n):\\n            if lcp[i][n - 1] != (s[i] == s[n-1]):\\n                return \"\"\\n            if lcp[n-1][i] != (s[i] == s[n-1]):\\n                return \"\"\\n\\n        # validate rest of lcp: if s[i] == s[j] => lcp[i][j] = 1 + lcp[i+1][j+1]\\n        for i in range(n-1):\\n            for j in range(n-1):\\n                if s[i] == s[j]:\\n                    if lcp[i][j] != 1 + lcp[i+1][j+1]: \\n                        return \"\"\\n                else: # char at i and j are different => lcp[i][j] should be 0\\n                    if lcp[i][j] != 0:\\n                        return \"\"\\n\\n        return \"\".join(s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206881,
                "title": "greedily-construct-the-answer-and-then-check-against-lcp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose string $s$ is the answer and we already know $s[0:j]$ (exclude j, python notation) then using $lcp[0:j, j]$, we can determine the value of $s[j]$ by (1) setting $s[j] = s[i]$ if $lcp[i][j] > 1$ or (2) setting it to the next unused characters greedily (because the goal is to get the alphabetically smallest string). Eventually, we reconstruct lcp using DP, and compare it against the original lcp array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n(1) Some initial checks (diagonal elements, symmetry, numerical limitation)\\n(2) Build answer greedily (we can also make this algorithm faster by terminating early in this loop)\\n(3) Validate lcp array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        // check 1: diagonal\\n        for (int i = 0; i < n; i++) {\\n            if (lcp[i][i] != n - i) return \"\";\\n        }\\n        // check 2: limitation and symmetry\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (lcp[i][j] > n - j || lcp[i][j] != lcp[j][i]) return \"\";\\n            }\\n        }\\n        // construct answer\\n        string s = string(n, \\'#\\');\\n        s[0] = \\'a\\';\\n        char cur = \\'a\\';\\n        for (int j = 1; j < n; j++) {\\n            int i;\\n            for (i = 0; i < j; i++) {\\n                if (lcp[i][j] > 0) {\\n                    s[j] = s[i];\\n                    break;\\n                }\\n            }\\n            if (i == j) {\\n                if (cur == \\'z\\') return \"\";\\n                else s[j] = ++cur;\\n            }\\n        }\\n        // check 3: validate lcp\\n        int dp[n][n];\\n        memset(dp, 0, sizeof(dp));\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s[i] == s[n - 1]) dp[i][n - 1] = 1;\\n        }\\n        for (int j = n - 2; j >= 0; j--) {\\n            dp[j][j] = n - j;\\n            for (int i = j - 1; i >= 0; i--) {\\n                if (s[i] == s[j]) dp[i][j] = 1 + dp[i + 1][j + 1];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (lcp[i][j] != dp[i][j]) return \"\";\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        // check 1: diagonal\\n        for (int i = 0; i < n; i++) {\\n            if (lcp[i][i] != n - i) return \"\";\\n        }\\n        // check 2: limitation and symmetry\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (lcp[i][j] > n - j || lcp[i][j] != lcp[j][i]) return \"\";\\n            }\\n        }\\n        // construct answer\\n        string s = string(n, \\'#\\');\\n        s[0] = \\'a\\';\\n        char cur = \\'a\\';\\n        for (int j = 1; j < n; j++) {\\n            int i;\\n            for (i = 0; i < j; i++) {\\n                if (lcp[i][j] > 0) {\\n                    s[j] = s[i];\\n                    break;\\n                }\\n            }\\n            if (i == j) {\\n                if (cur == \\'z\\') return \"\";\\n                else s[j] = ++cur;\\n            }\\n        }\\n        // check 3: validate lcp\\n        int dp[n][n];\\n        memset(dp, 0, sizeof(dp));\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (s[i] == s[n - 1]) dp[i][n - 1] = 1;\\n        }\\n        for (int j = n - 2; j >= 0; j--) {\\n            dp[j][j] = n - j;\\n            for (int i = j - 1; i >= 0; i--) {\\n                if (s[i] == s[j]) dp[i][j] = 1 + dp[i + 1][j + 1];\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (lcp[i][j] != dp[i][j]) return \"\";\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206557,
                "title": "python-3-union-find",
                "content": "```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)       \\n        \\n        loc = list(range(n))\\n        \\n        def find(x):\\n            if loc[x] != x:\\n                loc[x] = find(loc[x])\\n            return loc[x]\\n        \\n        def union(x, y):\\n            a, b = find(x), find(y)\\n            if a < b:\\n                loc[b] = a\\n            else:\\n                loc[a] = b        \\n        \\n        \\n        for i in range(n):\\n            for j in range(i+1):\\n                # the tricky part is that the value of lcp doesn\\'t matter here, as long as > 0, just union the index, will check the value later on\\n                if lcp[i][j]: union(i, j) \\n        \\n        g = [find(i) for i in range(n)]\\n        \\n\\n        # check if the built union-find group is valid\\n        # based on @lee215\\'s solution\\n        # lcp[i][j] must equal lcp[i+1][j+1] + 1 if (i, j) shares common prefix\\n        for i in range(n):\\n            for j in range(n):\\n                v = lcp[i+1][j+1] if i < n - 1 and j < n - 1 else 0\\n                v = v + 1 if g[i] == g[j] else 0\\n                if v != lcp[i][j]:\\n                    return \"\"\\n        \\n        # collapse grop sequence number to most smallest character index \\n        # for example if group number is [0, 2] then collapse to [0, 1]\\n        grp = set(g)\\n        if len(grp) > 26: return \"\"\\n        grp = {x: i for i, x in enumerate(sorted(grp))}\\n        \\n        ans = []\\n        for i, k in enumerate(g):\\n            ans.append(chr(97+grp[k]))           \\n        \\n        \\n        return \"\".join(ans)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "class Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)       \\n        \\n        loc = list(range(n))\\n        \\n        def find(x):\\n            if loc[x] != x:\\n                loc[x] = find(loc[x])\\n            return loc[x]\\n        \\n        def union(x, y):\\n            a, b = find(x), find(y)\\n            if a < b:\\n                loc[b] = a\\n            else:\\n                loc[a] = b        \\n        \\n        \\n        for i in range(n):\\n            for j in range(i+1):\\n                # the tricky part is that the value of lcp doesn\\'t matter here, as long as > 0, just union the index, will check the value later on\\n                if lcp[i][j]: union(i, j) \\n        \\n        g = [find(i) for i in range(n)]\\n        \\n\\n        # check if the built union-find group is valid\\n        # based on @lee215\\'s solution\\n        # lcp[i][j] must equal lcp[i+1][j+1] + 1 if (i, j) shares common prefix\\n        for i in range(n):\\n            for j in range(n):\\n                v = lcp[i+1][j+1] if i < n - 1 and j < n - 1 else 0\\n                v = v + 1 if g[i] == g[j] else 0\\n                if v != lcp[i][j]:\\n                    return \"\"\\n        \\n        # collapse grop sequence number to most smallest character index \\n        # for example if group number is [0, 2] then collapse to [0, 1]\\n        grp = set(g)\\n        if len(grp) > 26: return \"\"\\n        grp = {x: i for i, x in enumerate(sorted(grp))}",
                "codeTag": "Java"
            },
            {
                "id": 3206514,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `lcp`\\n */\\nclass Solution {\\n public:\\n  string findTheString(const vector<vector<int>> &lcp) {\\n    constexpr char default_c = \\'\\\\0\\';\\n    constexpr char lower = \\'a\\';\\n    constexpr char upper = \\'z\\';\\n    const int n = static_cast<int>(lcp.size());\\n    char candidate = lower;\\n    string ret(n, default_c);\\n    for (int i = 0; i < n; ++i) {\\n      if (ret[i] != default_c) {\\n        continue;\\n      }\\n      if (candidate > upper) {\\n        return string{};\\n      }\\n      ret[i] = candidate++;\\n      for (int j = i + 1; j < n; ++j) {\\n        if (lcp[i][j] > 0) {\\n          ret[j] = ret[i];\\n        }\\n      }\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {\\n      for (int j = 0; j < n; ++j) {\\n        const int item = ret[i] == ret[j] ? (i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0) + 1 : 0;\\n        if (item != lcp[i][j]) {\\n          return string{};\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `lcp`\\n */\\nclass Solution {\\n public:\\n  string findTheString(const vector<vector<int>> &lcp) {\\n    constexpr char default_c = \\'\\\\0\\';\\n    constexpr char lower = \\'a\\';\\n    constexpr char upper = \\'z\\';\\n    const int n = static_cast<int>(lcp.size());\\n    char candidate = lower;\\n    string ret(n, default_c);\\n    for (int i = 0; i < n; ++i) {\\n      if (ret[i] != default_c) {\\n        continue;\\n      }\\n      if (candidate > upper) {\\n        return string{};\\n      }\\n      ret[i] = candidate++;\\n      for (int j = i + 1; j < n; ++j) {\\n        if (lcp[i][j] > 0) {\\n          ret[j] = ret[i];\\n        }\\n      }\\n    }\\n    \\n    for (int i = 0; i < n; ++i) {\\n      for (int j = 0; j < n; ++j) {\\n        const int item = ret[i] == ret[j] ? (i + 1 < n && j + 1 < n ? lcp[i + 1][j + 1] : 0) + 1 : 0;\\n        if (item != lcp[i][j]) {\\n          return string{};\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206371,
                "title": "easy-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205532,
                "title": "video-explanation-intuitive-solution",
                "content": "# Explanation\\n\\nhttps://youtu.be/yydoJ83WlHI\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> LongestCommonPrefixMatrix (string s) {\\n        int n = s.length();\\n        vector<vector<int>> result(n, vector<int>(n, 0));\\n        \\n        for (int j = 0; j < n; j ++) {\\n            result[n-1][j] = result[j][n-1] = (s[j] == s[n-1])? 1 : 0; \\n        }\\n        for (int i = n-2; i >= 0; i --) {\\n            for (int j = n-2; j >= 0; j --) {\\n                result[i][j] = (s[i] == s[j])? 1 + result[i+1][j+1] : 0;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        \\n        string result (n, \\'a\\');\\n        \\n        for (int i = 1; i < n; i ++) {\\n            vector<bool> not_equal(26, false);\\n            bool matched = false;\\n            \\n            for (int j = 0; j < i; j ++) {\\n                if (lcp[j][i] == 0) {\\n                    not_equal[result[j] - \\'a\\'] = true;\\n                    continue;\\n                }\\n                \\n                matched = true;\\n                result[i] = result[j];\\n                break;\\n            }\\n        \\n            if (matched) continue;\\n            for (int j = 0; j < 26; j ++) {\\n                if (not_equal[j]) continue;\\n                \\n                result[i] = (char)(\\'a\\' + j);\\n                break;\\n            }\\n        }\\n        \\n        if (LongestCommonPrefixMatrix(result) == lcp) return result;\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> LongestCommonPrefixMatrix (string s) {\\n        int n = s.length();\\n        vector<vector<int>> result(n, vector<int>(n, 0));\\n        \\n        for (int j = 0; j < n; j ++) {\\n            result[n-1][j] = result[j][n-1] = (s[j] == s[n-1])? 1 : 0; \\n        }\\n        for (int i = n-2; i >= 0; i --) {\\n            for (int j = n-2; j >= 0; j --) {\\n                result[i][j] = (s[i] == s[j])? 1 + result[i+1][j+1] : 0;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        \\n        string result (n, \\'a\\');\\n        \\n        for (int i = 1; i < n; i ++) {\\n            vector<bool> not_equal(26, false);\\n            bool matched = false;\\n            \\n            for (int j = 0; j < i; j ++) {\\n                if (lcp[j][i] == 0) {\\n                    not_equal[result[j] - \\'a\\'] = true;\\n                    continue;\\n                }\\n                \\n                matched = true;\\n                result[i] = result[j];\\n                break;\\n            }\\n        \\n            if (matched) continue;\\n            for (int j = 0; j < 26; j ++) {\\n                if (not_equal[j]) continue;\\n                \\n                result[i] = (char)(\\'a\\' + j);\\n                break;\\n            }\\n        }\\n        \\n        if (LongestCommonPrefixMatrix(result) == lcp) return result;\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205469,
                "title": "java-with-detail-explaination-o-n-2-o-n-2",
                "content": "# Intuition\\nThe solution is actually quite counter-intuitive because most algorithm generates a set of answers based on a few constraints and  do a `map-reduce` onto all the answers (e.g. problem 3 can be seen as generates all subsets and get the number of all subsets), but in this question the constraints are actually too much. Consider this matrix `m`, where `m[i][j] = 0` means `string[i] != string[j]`, vise versa. **We can guarantee that this matrix can instruct us to generate a string, because we know each character\\'s equality onto all other characters**, if we also enforce lexicographically smallest, then we have either one possible string or no valid string (which is actually very easy to construct, e.g. `m[i][i] = 0` will lead to a impossible string).\\nWith that in mind let\\'s look at the `lcp` matrix, apparently this matrix doesn\\'t yield more information than the matrix above (there\\'s simply no more information to yield anyway), but with the added information it\\'s more likely to lead us onto an impossible string. So the idea is really first convert `lcp` onto `m` matrix, construct the only valid string, and then convert back string to `actualLcp` to reverify the original `lcp` is valid or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2). It takes O(n^2) to check every index pair and put characters into string, and it takes the same time to get back the `actualLcp` and compare it.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        char[] resChar = new char[lcp.length];\\n\\n        // we start with \\'a\\' which is only valid smallest character to start with.\\n        // Now if you think about it, even if the question doesn\\'t ask you to get smallest string,\\n        // and the OA has a way to verify string result,\\n        // starting with \\'a\\' will still work anyway.\\n        for (int i = 0; i < lcp.length; i++) {\\n            resChar[i] = \\'a\\';\\n        }\\n        for (int i = 0; i < lcp.length; i++) {\\n            char c = resChar[i];\\n            if (c > \\'z\\') {\\n                return \"\";\\n            }\\n            c++;\\n            // if string[i] != string[j], make string[j] = string[i] + 1\\n            // +1 because we want smallest string\\n            for (int j = i; j < lcp.length; j++) {\\n                if (lcp[i][j] == 0 && resChar[i] == resChar[j]) {\\n                    resChar[j] = c;\\n                }\\n            }\\n        }\\n        // we use dynamic programming to get back the actual lcp.\\n        // by expanding definition of lcp to include 0 length prefix\\n        // we can use formula: lcp[i][j] = 0 if s[i] != s[j]\\n        // lcp[i][j] = 1 (expand by 1) + lcp[i + 1][j + 1] vise versa\\n        // (which is the lcp value once you remove one more character from\\n        // both prefix.)\\n        int[][] actualLcp = new int[lcp.length + 1][lcp.length + 1];\\n        for (int i = lcp.length - 1; i >= 0; i--) {\\n            for (int j = lcp.length - 1; j >= 0; j--) {\\n                if (resChar[i] == resChar[j]) {\\n                    actualLcp[i][j] = 1 + actualLcp[i + 1][j + 1];\\n                }\\n                if (actualLcp[i][j] != lcp[i][j]) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return new String(resChar);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        char[] resChar = new char[lcp.length];\\n\\n        // we start with \\'a\\' which is only valid smallest character to start with.\\n        // Now if you think about it, even if the question doesn\\'t ask you to get smallest string,\\n        // and the OA has a way to verify string result,\\n        // starting with \\'a\\' will still work anyway.\\n        for (int i = 0; i < lcp.length; i++) {\\n            resChar[i] = \\'a\\';\\n        }\\n        for (int i = 0; i < lcp.length; i++) {\\n            char c = resChar[i];\\n            if (c > \\'z\\') {\\n                return \"\";\\n            }\\n            c++;\\n            // if string[i] != string[j], make string[j] = string[i] + 1\\n            // +1 because we want smallest string\\n            for (int j = i; j < lcp.length; j++) {\\n                if (lcp[i][j] == 0 && resChar[i] == resChar[j]) {\\n                    resChar[j] = c;\\n                }\\n            }\\n        }\\n        // we use dynamic programming to get back the actual lcp.\\n        // by expanding definition of lcp to include 0 length prefix\\n        // we can use formula: lcp[i][j] = 0 if s[i] != s[j]\\n        // lcp[i][j] = 1 (expand by 1) + lcp[i + 1][j + 1] vise versa\\n        // (which is the lcp value once you remove one more character from\\n        // both prefix.)\\n        int[][] actualLcp = new int[lcp.length + 1][lcp.length + 1];\\n        for (int i = lcp.length - 1; i >= 0; i--) {\\n            for (int j = lcp.length - 1; j >= 0; j--) {\\n                if (resChar[i] == resChar[j]) {\\n                    actualLcp[i][j] = 1 + actualLcp[i + 1][j + 1];\\n                }\\n                if (actualLcp[i][j] != lcp[i][j]) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return new String(resChar);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205468,
                "title": "java-with-detail-explaination-o-n-2-o-n-2",
                "content": "# Intuition\\nThe solution is actually quite counter-intuitive because most algorithm generates a set of answers based on a few constraints and  do a `map-reduce` onto all the answers (e.g. problem 3 can be seen as generates all subsets and get the number of all subsets), but in this question the constraints are actually too much. Consider this matrix `m`, where `m[i][j] = 0` means `string[i] != string[j]`, vise versa. We can guarantee that this matrix can instruct us to generate a string, because we know each character\\'s equality onto all other characters, if we also enforce lexicographically smallest, then we have either one possible string or no valid string (which is actually very easy to construct, e.g. `m[i][i] = 0` will lead to a impossible string).\\nWith that in mind let\\'s look at the `lcp` matrix, apparently this matrix doesn\\'t yield more information than the matrix above (there\\'s simply no more information to yield anyway), but with the added information it\\'s more likely to lead us onto an impossible string. So the idea is really first convert `lcp` onto `m` matrix, construct the only valid string, and then convert back string to `actualLcp` to reverify the original `lcp` is valid or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2). It takes O(n^2) to check every index pair and put characters into string, and it takes the same time to get back the `actualLcp` and compare it.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        char[] resChar = new char[lcp.length];\\n\\n        // we start with \\'a\\' which is only valid smallest character to start with.\\n        // Now if you think about it, even if the question doesn\\'t ask you to get smallest string,\\n        // and the OA has a way to verify string result,\\n        // starting with \\'a\\' will still work anyway.\\n        for (int i = 0; i < lcp.length; i++) {\\n            resChar[i] = \\'a\\';\\n        }\\n        for (int i = 0; i < lcp.length; i++) {\\n            char c = resChar[i];\\n            if (c > \\'z\\') {\\n                return \"\";\\n            }\\n            c++;\\n            // if string[i] != string[j], make string[j] = string[i] + 1\\n            // +1 because we want smallest string\\n            for (int j = i; j < lcp.length; j++) {\\n                if (lcp[i][j] == 0 && resChar[i] == resChar[j]) {\\n                    resChar[j] = c;\\n                }\\n            }\\n        }\\n        // we use dynamic programming to get back the actual lcp.\\n        // by expanding definition of lcp to include 0 length prefix\\n        // we can use formula: lcp[i][j] = 0 if s[i] != s[j]\\n        // lcp[i][j] = 1 (expand by 1) + lcp[i + 1][j + 1] vise versa\\n        // (which is the lcp value once you remove one more character from\\n        // both prefix.)\\n        int[][] actualLcp = new int[lcp.length + 1][lcp.length + 1];\\n        for (int i = lcp.length - 1; i >= 0; i--) {\\n            for (int j = lcp.length - 1; j >= 0; j--) {\\n                if (resChar[i] == resChar[j]) {\\n                    actualLcp[i][j] = 1 + actualLcp[i + 1][j + 1];\\n                }\\n                if (actualLcp[i][j] != lcp[i][j]) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return new String(resChar);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        char[] resChar = new char[lcp.length];\\n\\n        // we start with \\'a\\' which is only valid smallest character to start with.\\n        // Now if you think about it, even if the question doesn\\'t ask you to get smallest string,\\n        // and the OA has a way to verify string result,\\n        // starting with \\'a\\' will still work anyway.\\n        for (int i = 0; i < lcp.length; i++) {\\n            resChar[i] = \\'a\\';\\n        }\\n        for (int i = 0; i < lcp.length; i++) {\\n            char c = resChar[i];\\n            if (c > \\'z\\') {\\n                return \"\";\\n            }\\n            c++;\\n            // if string[i] != string[j], make string[j] = string[i] + 1\\n            // +1 because we want smallest string\\n            for (int j = i; j < lcp.length; j++) {\\n                if (lcp[i][j] == 0 && resChar[i] == resChar[j]) {\\n                    resChar[j] = c;\\n                }\\n            }\\n        }\\n        // we use dynamic programming to get back the actual lcp.\\n        // by expanding definition of lcp to include 0 length prefix\\n        // we can use formula: lcp[i][j] = 0 if s[i] != s[j]\\n        // lcp[i][j] = 1 (expand by 1) + lcp[i + 1][j + 1] vise versa\\n        // (which is the lcp value once you remove one more character from\\n        // both prefix.)\\n        int[][] actualLcp = new int[lcp.length + 1][lcp.length + 1];\\n        for (int i = lcp.length - 1; i >= 0; i--) {\\n            for (int j = lcp.length - 1; j >= 0; j--) {\\n                if (resChar[i] == resChar[j]) {\\n                    actualLcp[i][j] = 1 + actualLcp[i + 1][j + 1];\\n                }\\n                if (actualLcp[i][j] != lcp[i][j]) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return new String(resChar);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205364,
                "title": "java-building-string-from-scratch-and-validate-the-lcp-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given 2D integer array. lcp[i][j] indicates length of longest common prefix. We need to find the lexicographically smaller string consist of a-z.\\n\\nWe can write a validation algorithem to check if such a stirng can be build. If not we can return empty string.\\n\\nAfter building the array, we are not violating the LCP property.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Validation\\n* lcp[i][j] should be same sa lcp[j][i]\\n* when i and j is same, that means when we are looking the same index, loc[i][i] should equal to length of remaining string. loc[i][i] = len-i\\n* When we build lexigrohpically small string, we should not cross a-z limit.\\n\\n# Complexity\\nn - length of string\\n- Time complexity: $$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        var len = lcp.length;\\n        var arr = new char[len];\\n        var val = \\'a\\';\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(lcp[i][i] != len-i ) return \"\";\\n            if(arr[i] == 0)\\n            {\\n                arr[i] = val;\\n                val++;\\n            }\\n            \\n            for(int j  = i+1; j < len; j++)\\n            {\\n                if(lcp[i][j] != lcp[j][i] ||  i + lcp[i][j] >= len  ) return \"\";\\n                if(lcp[i][j] == 0)\\n                {\\n                    if(arr[i] == 0)\\n                    {\\n                        arr[j] = val;\\n                        val++;\\n                    }\\n                }else{\\n                    for(int k = 0; k < lcp[i][j]; k++ )\\n                    {\\n                        if(arr[j+k] == 0 )\\n                        {\\n                           arr[j+k] = arr[i+k];\\n                        }else{\\n                            if(arr[j+k] - arr[i+k] != 0)  return \"\";\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //reverse validation\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(arr[i] - \\'a\\' >= 26) return \"\";\\n            for(int j = i+1; j < len; j++)\\n            {\\n                var k = lcp[i][j];\\n                if( j+ k < len &&  arr[i+k] == arr[j + k] ) return \"\";\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        var len = lcp.length;\\n        var arr = new char[len];\\n        var val = \\'a\\';\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(lcp[i][i] != len-i ) return \"\";\\n            if(arr[i] == 0)\\n            {\\n                arr[i] = val;\\n                val++;\\n            }\\n            \\n            for(int j  = i+1; j < len; j++)\\n            {\\n                if(lcp[i][j] != lcp[j][i] ||  i + lcp[i][j] >= len  ) return \"\";\\n                if(lcp[i][j] == 0)\\n                {\\n                    if(arr[i] == 0)\\n                    {\\n                        arr[j] = val;\\n                        val++;\\n                    }\\n                }else{\\n                    for(int k = 0; k < lcp[i][j]; k++ )\\n                    {\\n                        if(arr[j+k] == 0 )\\n                        {\\n                           arr[j+k] = arr[i+k];\\n                        }else{\\n                            if(arr[j+k] - arr[i+k] != 0)  return \"\";\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //reverse validation\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(arr[i] - \\'a\\' >= 26) return \"\";\\n            for(int j = i+1; j < len; j++)\\n            {\\n                var k = lcp[i][j];\\n                if( j+ k < len &&  arr[i+k] == arr[j + k] ) return \"\";\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205283,
                "title": "dfs-connected-components-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define pii pair<int,int>\\n\\n    string ans;\\n    vector<bool> visited;\\n\\n    void dfs(vector<vector<int>>& adj, int i=0, int val=0)\\n    {\\n        visited[i]=true;\\n        ans[i]= \\'a\\'+ val;\\n        for(auto it: adj[i])\\n        {\\n            if(!visited[it]) dfs(adj, it, val);\\n        }\\n    }\\n    string findTheString(vector<vector<int>>& lcp) {\\n        \\n        // i want to know the equalities\\n        int n= lcp.size();\\n        vector<vector<int>> v(n);\\n        set<pii> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            int dist;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(lcp[i][i] != n-i) return \"\";\\n                if(lcp[i][j] != lcp[j][i]) return \"\";\\n                if(i-1 >=0 && j-1 >=0 && lcp[i-1][j-1] > 0 && lcp[i][j] + 1 != lcp[i-1][j-1]) return \"\";\\n                dist= min(n-i, n-j);\\n               \\n                if(lcp[i][j] > dist) return \"\";\\n\\n                if(st.find({i, j})== st.end() && st.find({j,i})== st.end() && lcp[i][j] !=0) \\n                {\\n                    v[i].push_back(j);\\n                    v[j].push_back(i);\\n                }\\n                st.insert({i,j});\\n            \\n            }\\n        }\\n        ans.resize(n);\\n        visited.resize(n, false);\\n        int val=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i]) {if(val>25) return \"\"; dfs(v, i, val); val++;}\\n        \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pii pair<int,int>\\n\\n    string ans;\\n    vector<bool> visited;\\n\\n    void dfs(vector<vector<int>>& adj, int i=0, int val=0)\\n    {\\n        visited[i]=true;\\n        ans[i]= \\'a\\'+ val;\\n        for(auto it: adj[i])\\n        {\\n            if(!visited[it]) dfs(adj, it, val);\\n        }\\n    }\\n    string findTheString(vector<vector<int>>& lcp) {\\n        \\n        // i want to know the equalities\\n        int n= lcp.size();\\n        vector<vector<int>> v(n);\\n        set<pii> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            int dist;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(lcp[i][i] != n-i) return \"\";\\n                if(lcp[i][j] != lcp[j][i]) return \"\";\\n                if(i-1 >=0 && j-1 >=0 && lcp[i-1][j-1] > 0 && lcp[i][j] + 1 != lcp[i-1][j-1]) return \"\";\\n                dist= min(n-i, n-j);\\n               \\n                if(lcp[i][j] > dist) return \"\";\\n\\n                if(st.find({i, j})== st.end() && st.find({j,i})== st.end() && lcp[i][j] !=0) \\n                {\\n                    v[i].push_back(j);\\n                    v[j].push_back(i);\\n                }\\n                st.insert({i,j});\\n            \\n            }\\n        }\\n        ans.resize(n);\\n        visited.resize(n, false);\\n        int val=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i]) {if(val>25) return \"\"; dfs(v, i, val); val++;}\\n        \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205263,
                "title": "python-construct-and-check-through-every-case-i-failed",
                "content": "# Intuition\\n\\nif lcp[i][j] > 0, it means words[i:i+lcp[i][j]] == words[j:j+lcp[i][j]]\\nthus, we can know that words[i] = words[j] if lcp[i][j] > 0\\n\\nsince we want alphabetically smallest string, we can iterate i from `0 to n-1` and assign from `a to z` one by one **if lcp[i][j] > 0**\\n\\nif we already assigned character before, we skip it because it\\'s already possible alphabetically smallest character\\n\\nafter we construct possible solution to alphabetically smallest string, we still need to check if lcp matrix is valid or not.\\n\\nthe conditions are the same as we construct string:\\n\\n1. if `i+lcp[i][j] > n` or `j+lcp[i][j]`, it\\'s **invalid**. (see example 3)\\n2. if **words[i] == words[j]**:\\n    - lcp[i][j] should be greater than 0\\n    - lcp[i][j] should equals lcp[i+1][j+1]+1\\n3. if **words[i] != words[j]**:\\n    - it\\'s opposite from second condition\\n    - lcp[i][j] should be 0\\n    - lcp[i][j] should **NOT** equal lcp[i+1][j+1]+1\\n4. length of final words we constructed should equal `n`\\n\\n    ```py\\n    ans = \"\".join(words)\\n    if len(ans) != n: return \"\"\\n    ```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # lcp[i][j]: length of common prefix word[i:] and word[j]\\n        n = len(lcp)\\n        words = [\"\"]*n\\n        shift = 0\\n        for i in range(n):\\n            if words[i]: continue\\n            for j in range(n):\\n                if words[j]: continue\\n                # words[i:i+lcp[i][j]] == words[j:j+lcp[i][j]]\\n                # -> words[i] == words[j]\\n                if lcp[i][j] > 0:\\n                    words[i] = chr(ord(\\'a\\')+shift) if shift < 26 else \"\"\\n                    words[j] = words[i]\\n            shift += 1\\n\\n        for i in range(n):\\n            for j in range(n):\\n                # example 3\\n                if i+lcp[i][j] > n or j+lcp[i][j] > n: return \"\"\\n                \\n                if words[i] == words[j]:\\n                    # case: [[2,1],[0,1]]\\n                    if lcp[i][j] == 0: return \"\"\\n                    # case: [[4,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]\\n                    if i<n-1 and j<n-1 and lcp[i][j] != lcp[i+1][j+1]+1:\\n                        return \"\"\\n                else:\\n                    if lcp[i][j] != 0: return \"\"\\n                    if i<n-1 and j<n-1 and lcp[i][j] == lcp[i+1][j+1]+1:\\n                        return \"\"\\n        \\n        # final case\\n        ans = \"\".join(words)\\n        if len(ans) != n: return \"\"\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\n    ans = \"\".join(words)\\n    if len(ans) != n: return \"\"\\n    ```\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # lcp[i][j]: length of common prefix word[i:] and word[j]\\n        n = len(lcp)\\n        words = [\"\"]*n\\n        shift = 0\\n        for i in range(n):\\n            if words[i]: continue\\n            for j in range(n):\\n                if words[j]: continue\\n                # words[i:i+lcp[i][j]] == words[j:j+lcp[i][j]]\\n                # -> words[i] == words[j]\\n                if lcp[i][j] > 0:\\n                    words[i] = chr(ord(\\'a\\')+shift) if shift < 26 else \"\"\\n                    words[j] = words[i]\\n            shift += 1\\n\\n        for i in range(n):\\n            for j in range(n):\\n                # example 3\\n                if i+lcp[i][j] > n or j+lcp[i][j] > n: return \"\"\\n                \\n                if words[i] == words[j]:\\n                    # case: [[2,1],[0,1]]\\n                    if lcp[i][j] == 0: return \"\"\\n                    # case: [[4,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]\\n                    if i<n-1 and j<n-1 and lcp[i][j] != lcp[i+1][j+1]+1:\\n                        return \"\"\\n                else:\\n                    if lcp[i][j] != 0: return \"\"\\n                    if i<n-1 and j<n-1 and lcp[i][j] == lcp[i+1][j+1]+1:\\n                        return \"\"\\n        \\n        # final case\\n        ans = \"\".join(words)\\n        if len(ans) != n: return \"\"\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204604,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_the_string(lcp: Vec<Vec<i32>>) -> String {\\n        let n = lcp.len();\\n        let mut arr = vec![0; n];\\n        let mut c = 0;\\n        for i in 0..n {\\n            if arr[i] != 0 {\\n                continue;\\n            }\\n            c += 1;\\n            if c > 26 {\\n                return \"\".to_string();\\n            }\\n            for (j, arr_j) in arr.iter_mut().enumerate().skip(i).take(n) {\\n                if lcp[i][j] > 0 {\\n                    *arr_j = c;\\n                }\\n            }\\n        }\\n        for i in 0..n {\\n            for j in 0..n {\\n                let v = if i + 1 < n && j + 1 < n { lcp[i + 1][j + 1] } else { 0 };\\n                let v = if arr[i] == arr[j] { v + 1 } else { 0 };\\n                if lcp[i][j] != v {\\n                    return \"\".to_string();\\n                }\\n            }\\n        }\\n        let mut res = String::new();\\n        for c in arr {\\n            res.push((b\\'a\\' + c - 1) as char);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_the_string(lcp: Vec<Vec<i32>>) -> String {\\n        let n = lcp.len();\\n        let mut arr = vec![0; n];\\n        let mut c = 0;\\n        for i in 0..n {\\n            if arr[i] != 0 {\\n                continue;\\n            }\\n            c += 1;\\n            if c > 26 {\\n                return \"\".to_string();\\n            }\\n            for (j, arr_j) in arr.iter_mut().enumerate().skip(i).take(n) {\\n                if lcp[i][j] > 0 {\\n                    *arr_j = c;\\n                }\\n            }\\n        }\\n        for i in 0..n {\\n            for j in 0..n {\\n                let v = if i + 1 < n && j + 1 < n { lcp[i + 1][j + 1] } else { 0 };\\n                let v = if arr[i] == arr[j] { v + 1 } else { 0 };\\n                if lcp[i][j] != v {\\n                    return \"\".to_string();\\n                }\\n            }\\n        }\\n        let mut res = String::new();\\n        for c in arr {\\n            res.push((b\\'a\\' + c - 1) as char);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3204547,
                "title": "dsu-o-n-2",
                "content": "```\\nstruct unionfind\\n{\\n    int n;\\n    // vector<int> rank;\\n    vector<int> parent;\\n    unionfind(int n)\\n    {\\n        \\n        // fill(rank.begin(), rank.end(), 0);\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n    }\\n    int find(int node)\\n    {\\n        if (node == parent[node])\\n        {\\n            return node;\\n        }\\n        else\\n        {\\n            return parent[node] = find(parent[node]);\\n        }\\n    }\\n    bool Union(int u, int v)\\n    {\\n        u = find(u);\\n        v = find(v);\\n        if (u == v)\\n        {\\n            return false;\\n        }\\n        \\n        parent[v] = u;\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& v) {\\n        int n=v.size();\\n        unionfind u = unionfind(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i][j]){\\n                    u.Union(i,j);\\n                }\\n            }\\n        }\\n        int dp[n][n];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(u.find(i)==u.find(j)){\\n                    dp[i][j]=1;\\n                    if(i+1<n && j+1<n){\\n                        dp[i][j] = dp[i+1][j+1]+1;\\n                    }\\n                }\\n                if(dp[i][j]!=v[i][j]){\\n                    return \"\";\\n                }\\n            }\\n        }\\n        // cout<<1;\\n        char x = \\'a\\'-1;\\n        string s=\"\";\\n        map<char,int>m;\\n        for(int i=0;i<n;i++){\\n            if(m.find(u.find(i))!=m.end()){\\n                s+=m[u.find(i)];\\n            }\\n            else{\\n                x++;\\n                m[u.find(i)]=x;\\n                s+=x;\\n            }\\n        }\\n        if(x>\\'z\\'){\\n            return \"\";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nstruct unionfind\\n{\\n    int n;\\n    // vector<int> rank;\\n    vector<int> parent;\\n    unionfind(int n)\\n    {\\n        \\n        // fill(rank.begin(), rank.end(), 0);\\n        parent.resize(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n    }\\n    int find(int node)\\n    {\\n        if (node == parent[node])\\n        {\\n            return node;\\n        }\\n        else\\n        {\\n            return parent[node] = find(parent[node]);\\n        }\\n    }\\n    bool Union(int u, int v)\\n    {\\n        u = find(u);\\n        v = find(v);\\n        if (u == v)\\n        {\\n            return false;\\n        }\\n        \\n        parent[v] = u;\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& v) {\\n        int n=v.size();\\n        unionfind u = unionfind(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i][j]){\\n                    u.Union(i,j);\\n                }\\n            }\\n        }\\n        int dp[n][n];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(u.find(i)==u.find(j)){\\n                    dp[i][j]=1;\\n                    if(i+1<n && j+1<n){\\n                        dp[i][j] = dp[i+1][j+1]+1;\\n                    }\\n                }\\n                if(dp[i][j]!=v[i][j]){\\n                    return \"\";\\n                }\\n            }\\n        }\\n        // cout<<1;\\n        char x = \\'a\\'-1;\\n        string s=\"\";\\n        map<char,int>m;\\n        for(int i=0;i<n;i++){\\n            if(m.find(u.find(i))!=m.end()){\\n                s+=m[u.find(i)];\\n            }\\n            else{\\n                x++;\\n                m[u.find(i)]=x;\\n                s+=x;\\n            }\\n        }\\n        if(x>\\'z\\'){\\n            return \"\";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3204372,
                "title": "antarnab-java-100-faster-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204261,
                "title": "swift-solution-with-brief-explanation",
                "content": "# Approach\\n1. Create a 2D array of size n x n\\n2. Initialize the array with 0\\n3. Iterate over the array and fill the array with the LCP values\\n4. Create a new array of size n\\n5. Initialize the array with \"a\"\\n6. Iterate over the array and fill the array with the values from the LCP array\\n7. If the value is 0, then increment the value of the previous element by 1\\n8. If the value is greater than 26, then return an empty string\\n9. Create a new 2D array of size n x n\\n10. Initialize the array with 0\\n11. Iterate over the array and fill the array with the LCP values\\n12. Iterate over the array and check if the LCP values are same as the values in the new array\\n13. If the values are not same, then return an empty string\\n14. Return the array joined with \"\"\\n\\n\\n# Complexity\\n- Time complexity: O(n<sup>2</sup>)\\n\\n- Space complexity: O(n<sup>2</sup>)\\n\\n# Code\\n```\\nclass Solution {\\n    func findTheString(_ lcp: [[Int]]) -> String {\\n        let n = lcp.count\\n        var arr = Array(repeating: \"a\", count: n)\\n        var test = \"a\"\\n        var found = false\\n        for i in 1..<n {\\n            test = \"a\"\\n            found = false\\n            for j in 0..<i {\\n                test = max(test, arr[j])\\n                if lcp[i][j] != 0 {\\n                    found = true\\n                    arr[i] = arr[j]\\n                    break\\n                }    \\n            }\\n            if found {\\n                continue\\n            }\\n            test = String(Character(UnicodeScalar(test.unicodeScalars.first!.value + 1)!))\\n            arr[i] = test\\n            if test > \"z\" {\\n                return \"\"\\n            }\\n        }\\n        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: n + 1)\\n        var val = 0\\n        for i in (0..<n).reversed() {\\n            for j in (0..<n).reversed() {\\n                if arr[i] != arr[j] {\\n                    val = 0\\n                } else {\\n                    val = 1 + dp[i + 1][j + 1]\\n                }\\n                \\n                dp[i][j] = val\\n            }\\n        }\\n        for i in (0..<n).reversed() {\\n            for j in (0..<n).reversed() {\\n                if dp[i][j] != lcp[i][j] {\\n                    return \"\"\\n                }\\n            }\\n        }\\n        return arr.joined()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findTheString(_ lcp: [[Int]]) -> String {\\n        let n = lcp.count\\n        var arr = Array(repeating: \"a\", count: n)\\n        var test = \"a\"\\n        var found = false\\n        for i in 1..<n {\\n            test = \"a\"\\n            found = false\\n            for j in 0..<i {\\n                test = max(test, arr[j])\\n                if lcp[i][j] != 0 {\\n                    found = true\\n                    arr[i] = arr[j]\\n                    break\\n                }    \\n            }\\n            if found {\\n                continue\\n            }\\n            test = String(Character(UnicodeScalar(test.unicodeScalars.first!.value + 1)!))\\n            arr[i] = test\\n            if test > \"z\" {\\n                return \"\"\\n            }\\n        }\\n        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: n + 1)\\n        var val = 0\\n        for i in (0..<n).reversed() {\\n            for j in (0..<n).reversed() {\\n                if arr[i] != arr[j] {\\n                    val = 0\\n                } else {\\n                    val = 1 + dp[i + 1][j + 1]\\n                }\\n                \\n                dp[i][j] = val\\n            }\\n        }\\n        for i in (0..<n).reversed() {\\n            for j in (0..<n).reversed() {\\n                if dp[i][j] != lcp[i][j] {\\n                    return \"\"\\n                }\\n            }\\n        }\\n        return arr.joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204090,
                "title": "c-check-if-possible-then-construct-string-greedily",
                "content": "# Intuition\\nThere are 4 conditions which must hold true in order for it to be possible.\\n\\n1. `lcp[0][0]` must be n.\\n2. `lcp[i][j]` must be same as `lcp[j][i]`.\\n3. if `lcp[i][j]` is more than 0, then `lcp[i + 1][j + 1]` must be `lcp[i][j] - 1`.\\n4. `lcp[i][j]` must be less than or equal to `n - max(i, j)`.\\n\\nIf it meets all these 4 conditions, we start building the string greedily.\\n\\nAn obsrvation we can make is that if `lcp[i][j]` is more thatn zero, that means that character `i` and `j` should be the same.\\n\\nfirst we know for sure that the first character should be \"a\". Then we go through all lcp\\'s of the first row, if `lcp[0][j]` is more than zero, that means that there is an \"a\" at index `j`.\\n\\nThen we go to the second character in the string. If it is still empty we put in the next minimum available character, which is \"b\", and we go through all lcp\\'s of the second row and fill in every index `j`, where `lcp[1][j]` is more than zero, with \"b\".\\n\\nWe continue doing this for every index, checking if it is empty, and if it is empty filling in all index `j`, where `lcp[i][j]` is more than 0, with the next character. If the next character is more than \\'z\\' we know it\\'s impossible.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        if (lcp[0][0] < n) return \"\";\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (lcp[i][j] != lcp[j][i]) return \"\";\\n                if (max(j, i) + lcp[i][j] > n)\\n                    return \"\";\\n                if (i && j && lcp[i - 1][j - 1] && lcp[i][j] != lcp[i - 1][j - 1] - 1)\\n                    return \"\";\\n            }\\n        }\\n        string res(n, \\' \\');\\n        char nxt = \\'a\\';\\n        for (int i = 0; i < n; i++) {\\n            if (res[i] != \\' \\') continue;\\n            if (nxt > \\'z\\') return \"\";\\n            for (int j = 0; j < n; j++)\\n                if (lcp[i][j]) res[j] = nxt;\\n            nxt++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n = lcp.size();\\n        if (lcp[0][0] < n) return \"\";\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (lcp[i][j] != lcp[j][i]) return \"\";\\n                if (max(j, i) + lcp[i][j] > n)\\n                    return \"\";\\n                if (i && j && lcp[i - 1][j - 1] && lcp[i][j] != lcp[i - 1][j - 1] - 1)\\n                    return \"\";\\n            }\\n        }\\n        string res(n, \\' \\');\\n        char nxt = \\'a\\';\\n        for (int i = 0; i < n; i++) {\\n            if (res[i] != \\' \\') continue;\\n            if (nxt > \\'z\\') return \"\";\\n            for (int j = 0; j < n; j++)\\n                if (lcp[i][j]) res[j] = nxt;\\n            nxt++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203961,
                "title": "greedy-use-character-and-test-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        int index = 0;\\n        Character[] str = new Character[n];\\n        for(int i = 0;i<n;i++){\\n\\n            if(lcp[i][i]!=n-i)\\n                return \"\";\\n\\n            if(str[i]==null){\\n                if(index>25)\\n                    return \"\";\\n                str[i] = (char)(\\'a\\'+index++);\\n            }\\n            \\n            for(int j = 0;j<n;j++){\\n                if(lcp[i][j]>n-i||lcp[i][j]>n-j)\\n                    return \"\";\\n                if(lcp[i][j]>0){\\n                    if(str[j]!=null&&str[j]!=str[i])\\n                        return \"\";\\n                    str[j] = str[i];\\n                }else if(lcp[i][j]==0&&str[i]==str[j]){\\n                    return \"\";\\n                }\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0;i<str.length;i++){\\n            sb.append(str[i]);\\n        }\\n        \\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(lcp[i][j]==0)\\n                    continue;\\n                int count = 0;\\n                int k = 0;\\n                while(i+k<n&&j+k<n&&sb.charAt(i+k)==sb.charAt(j+k)){\\n                    count++;\\n                    k++;\\n                }\\n                if(count!=lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        int index = 0;\\n        Character[] str = new Character[n];\\n        for(int i = 0;i<n;i++){\\n\\n            if(lcp[i][i]!=n-i)\\n                return \"\";\\n\\n            if(str[i]==null){\\n                if(index>25)\\n                    return \"\";\\n                str[i] = (char)(\\'a\\'+index++);\\n            }\\n            \\n            for(int j = 0;j<n;j++){\\n                if(lcp[i][j]>n-i||lcp[i][j]>n-j)\\n                    return \"\";\\n                if(lcp[i][j]>0){\\n                    if(str[j]!=null&&str[j]!=str[i])\\n                        return \"\";\\n                    str[j] = str[i];\\n                }else if(lcp[i][j]==0&&str[i]==str[j]){\\n                    return \"\";\\n                }\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0;i<str.length;i++){\\n            sb.append(str[i]);\\n        }\\n        \\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(lcp[i][j]==0)\\n                    continue;\\n                int count = 0;\\n                int k = 0;\\n                while(i+k<n&&j+k<n&&sb.charAt(i+k)==sb.charAt(j+k)){\\n                    count++;\\n                    k++;\\n                }\\n                if(count!=lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203827,
                "title": "java-try-build-the-string-in-greedy-approach-then-test",
                "content": "# Intuitive\\nSay the String is `char[] A`.\\nWhenever `lcp[i][j] > 0`, then `A[i] == A[j]`.\\nWe can use this rule to try insert letters from left, the letter insert should start from `a` and increments each we need a new letter.\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        char c = \\'a\\';\\n        int n = lcp.length;\\n        for (int i = 0; i < n; i++) {\\n            if (lcp[i][i] != n - i) return \"\";\\n            for (int j = 1; j < n; j++) if (lcp[i][j] != lcp[j][i]) return \"\";\\n        }\\n        char[] output = new char[n];\\n        Arrays.fill(output, \\'*\\');\\n        for (int i = 0; i < n; i++) \\n            if (output[i] == \\'*\\') {\\n                if (c > \\'z\\') return \"\";\\n                for (int j = i; j < n; j++) if (lcp[i][j] > 0) {\\n                    if (output[j] != \\'*\\') return \"\";\\n                    output[j] = c;\\n                }\\n                c++;\\n            }\\n            else for (int j = i + 1; j < n; j++) if (lcp[i][j] > 0 && output[i] != output[j]) return \"\";\\n        for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) if (lcp[i][j] > 0) {\\n            int k = 0;\\n            while (i + k < n && j + k < n && output[i + k] == output[j + k]) k++;\\n            if (lcp[i][j] != k) return \"\";\\n        }\\n        return new String(output);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        char c = \\'a\\';\\n        int n = lcp.length;\\n        for (int i = 0; i < n; i++) {\\n            if (lcp[i][i] != n - i) return \"\";\\n            for (int j = 1; j < n; j++) if (lcp[i][j] != lcp[j][i]) return \"\";\\n        }\\n        char[] output = new char[n];\\n        Arrays.fill(output, \\'*\\');\\n        for (int i = 0; i < n; i++) \\n            if (output[i] == \\'*\\') {\\n                if (c > \\'z\\') return \"\";\\n                for (int j = i; j < n; j++) if (lcp[i][j] > 0) {\\n                    if (output[j] != \\'*\\') return \"\";\\n                    output[j] = c;\\n                }\\n                c++;\\n            }\\n            else for (int j = i + 1; j < n; j++) if (lcp[i][j] > 0 && output[i] != output[j]) return \"\";\\n        for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) if (lcp[i][j] > 0) {\\n            int k = 0;\\n            while (i + k < n && j + k < n && output[i + k] == output[j + k]) k++;\\n            if (lcp[i][j] != k) return \"\";\\n        }\\n        return new String(output);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203802,
                "title": "greedy-construction",
                "content": "# Intuition\\nFor every position in the string, what is the minimum character which can be used to fill that position without violating any previous conditions.\\n\\n\\n# Approach\\n\\nConstruct a directed graph where an edge between i and j denotes that S[i] != S[j]. For each lcp element, the first smallest index where the two substrings are unequal contribute to the edges of this graph. From this graph, for each position, find the min c such no conditions are violated.\\n\\nFinally reconstruct the lcp array using dynamic programming and ensure it is equal to the given lcp. If so return the greedily constructed string.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> E[1111];\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if (lcp[i][j]!=lcp[j][i]) return \"\";\\n                int l2=n-j;\\n                if (j+lcp[i][j]<n) {\\n                    E[j+lcp[i][j]].push_back(i+lcp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        \\n        string S(n,\\'#\\');\\n        for(int i=0;i<n;i++) {\\n            int mask=0;\\n            for(int j : E[i]) {\\n                mask|=(1<<(S[j]-\\'a\\'));\\n            }\\n            for(int c=0;c<26;c++) {\\n                if (!((mask>>c)&1)) {\\n                    S[i]=c+\\'a\\';\\n                    break;\\n                }\\n            }\\n            if (S[i]==\\'#\\') return \"\";\\n        }\\n        \\n        vector<vector<int>> estimated_lcp(n,vector<int>(n));\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            for(int j=n-1;j>=0;j--) {\\n                if (S[i]!=S[j]) {\\n                    estimated_lcp[i][j]=0;\\n                } else {\\n                    estimated_lcp[i][j]=1;\\n                    if (i+1<n && j+1<n) estimated_lcp[i][j]+=estimated_lcp[i+1][j+1];\\n                }\\n            }\\n        }\\n        if (lcp != estimated_lcp) return \"\";\\n        return S;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> E[1111];\\n    string findTheString(vector<vector<int>>& lcp) {\\n        int n=lcp.size();\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                if (lcp[i][j]!=lcp[j][i]) return \"\";\\n                int l2=n-j;\\n                if (j+lcp[i][j]<n) {\\n                    E[j+lcp[i][j]].push_back(i+lcp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        \\n        string S(n,\\'#\\');\\n        for(int i=0;i<n;i++) {\\n            int mask=0;\\n            for(int j : E[i]) {\\n                mask|=(1<<(S[j]-\\'a\\'));\\n            }\\n            for(int c=0;c<26;c++) {\\n                if (!((mask>>c)&1)) {\\n                    S[i]=c+\\'a\\';\\n                    break;\\n                }\\n            }\\n            if (S[i]==\\'#\\') return \"\";\\n        }\\n        \\n        vector<vector<int>> estimated_lcp(n,vector<int>(n));\\n        \\n        for(int i=n-1;i>=0;i--) {\\n            for(int j=n-1;j>=0;j--) {\\n                if (S[i]!=S[j]) {\\n                    estimated_lcp[i][j]=0;\\n                } else {\\n                    estimated_lcp[i][j]=1;\\n                    if (i+1<n && j+1<n) estimated_lcp[i][j]+=estimated_lcp[i+1][j+1];\\n                }\\n            }\\n        }\\n        if (lcp != estimated_lcp) return \"\";\\n        return S;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1806493,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "Can anyone explain the problem? I can\\'t even fully understand it ..."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "one point i got is it\\'s hard question from label\\nbut other hard  part is  i start reading question  and i can\\'t finish \\uD83D\\uDE23\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "This is actually the reverse problem of LCS (Longest Commion Substring) problem with one string. Solving the problem requires two parts:\n1) Constructing the solution if it exists.  \n2) Verifying the input table if it's an actual an LCS length table.\n\nA potential solution could be easily built with a double loop. Once we have a potential solution, we can easily build a two dimensional LCS length table from the potential solution string  and verify if it's the same as the input matrix."
                    },
                    {
                        "username": "KumarRaunak",
                        "content": "Easy Way  to implement \\n\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}"
                    },
                    {
                        "username": "dawravaibhav",
                        "content": "One possibility I am thinking to implement is, consider a full graph of n nodes, where edge (i,j) represents s[i]=s[j]. Each entry in lcp[x][y] tells what is first index in x----n-1 and y---n-1 that differs and that edges can be removed. After all iterations, if number of connected components >26, its not possible. then we will assign a character to each component , smallest character going to component which has smallest index present.\\nAfter construction of string, we build lcp and check if its same.\\nI have not implemented it but think its ok. If anyone thinks any problem, feel free to comment\\n"
                    }
                ]
            },
            {
                "id": 1816447,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "Can anyone explain the problem? I can\\'t even fully understand it ..."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "one point i got is it\\'s hard question from label\\nbut other hard  part is  i start reading question  and i can\\'t finish \\uD83D\\uDE23\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "This is actually the reverse problem of LCS (Longest Commion Substring) problem with one string. Solving the problem requires two parts:\n1) Constructing the solution if it exists.  \n2) Verifying the input table if it's an actual an LCS length table.\n\nA potential solution could be easily built with a double loop. Once we have a potential solution, we can easily build a two dimensional LCS length table from the potential solution string  and verify if it's the same as the input matrix."
                    },
                    {
                        "username": "KumarRaunak",
                        "content": "Easy Way  to implement \\n\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}"
                    },
                    {
                        "username": "dawravaibhav",
                        "content": "One possibility I am thinking to implement is, consider a full graph of n nodes, where edge (i,j) represents s[i]=s[j]. Each entry in lcp[x][y] tells what is first index in x----n-1 and y---n-1 that differs and that edges can be removed. After all iterations, if number of connected components >26, its not possible. then we will assign a character to each component , smallest character going to component which has smallest index present.\\nAfter construction of string, we build lcp and check if its same.\\nI have not implemented it but think its ok. If anyone thinks any problem, feel free to comment\\n"
                    }
                ]
            },
            {
                "id": 1807237,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "Can anyone explain the problem? I can\\'t even fully understand it ..."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "one point i got is it\\'s hard question from label\\nbut other hard  part is  i start reading question  and i can\\'t finish \\uD83D\\uDE23\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "This is actually the reverse problem of LCS (Longest Commion Substring) problem with one string. Solving the problem requires two parts:\n1) Constructing the solution if it exists.  \n2) Verifying the input table if it's an actual an LCS length table.\n\nA potential solution could be easily built with a double loop. Once we have a potential solution, we can easily build a two dimensional LCS length table from the potential solution string  and verify if it's the same as the input matrix."
                    },
                    {
                        "username": "KumarRaunak",
                        "content": "Easy Way  to implement \\n\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}"
                    },
                    {
                        "username": "dawravaibhav",
                        "content": "One possibility I am thinking to implement is, consider a full graph of n nodes, where edge (i,j) represents s[i]=s[j]. Each entry in lcp[x][y] tells what is first index in x----n-1 and y---n-1 that differs and that edges can be removed. After all iterations, if number of connected components >26, its not possible. then we will assign a character to each component , smallest character going to component which has smallest index present.\\nAfter construction of string, we build lcp and check if its same.\\nI have not implemented it but think its ok. If anyone thinks any problem, feel free to comment\\n"
                    }
                ]
            },
            {
                "id": 2005501,
                "content": [
                    {
                        "username": "sugarteddy",
                        "content": "Can anyone explain the problem? I can\\'t even fully understand it ..."
                    },
                    {
                        "username": "PrashantUnity",
                        "content": "one point i got is it\\'s hard question from label\\nbut other hard  part is  i start reading question  and i can\\'t finish \\uD83D\\uDE23\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "xiaoping3418",
                        "content": "This is actually the reverse problem of LCS (Longest Commion Substring) problem with one string. Solving the problem requires two parts:\n1) Constructing the solution if it exists.  \n2) Verifying the input table if it's an actual an LCS length table.\n\nA potential solution could be easily built with a double loop. Once we have a potential solution, we can easily build a two dimensional LCS length table from the potential solution string  and verify if it's the same as the input matrix."
                    },
                    {
                        "username": "KumarRaunak",
                        "content": "Easy Way  to implement \\n\\nclass Solution {\\n    public String findTheString(int[][] lcp) {\\n        int n = lcp.length;\\n        \\n        // potential answer\\n        char [] arr = new char [n];\\n        arr[0] = \\'a\\';\\n        \\n        char test;\\n        boolean found;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            test = \\'a\\';\\n            found = false;\\n            \\n            for (int j = 0; j < i; ++j){\\n                test = (char)Math.max(test, arr[j]);\\n                \\n                if (lcp[i][j] != 0){\\n                    found = true;\\n                    arr[i] = arr[j];  \\n                    break;\\n                }    \\n            }\\n            \\n            if (found)\\n                continue;\\n            \\n            ++test;\\n            arr[i] = test;\\n            \\n            \\n            // More than 26 characters needed. \\n            if (test > \\'z\\')\\n                return \"\";\\n        }\\n        \\n        // lcp from potential string\\n        int [][] dp = new int [n + 1][n + 1];\\n        \\n        int val;\\n        \\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (arr[i] != arr[j])\\n                    val = 0;\\n                else\\n                    val = 1 + dp[i + 1][j + 1];\\n                \\n                dp[i][j] = val;\\n            }\\n        }\\n        \\n        // compare dp and lcp as both should be same\\n        for (int i = n - 1; i >= 0; --i){\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (dp[i][j] != lcp[i][j])\\n                    return \"\";\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n}"
                    },
                    {
                        "username": "dawravaibhav",
                        "content": "One possibility I am thinking to implement is, consider a full graph of n nodes, where edge (i,j) represents s[i]=s[j]. Each entry in lcp[x][y] tells what is first index in x----n-1 and y---n-1 that differs and that edges can be removed. After all iterations, if number of connected components >26, its not possible. then we will assign a character to each component , smallest character going to component which has smallest index present.\\nAfter construction of string, we build lcp and check if its same.\\nI have not implemented it but think its ok. If anyone thinks any problem, feel free to comment\\n"
                    }
                ]
            }
        ]
    }
]