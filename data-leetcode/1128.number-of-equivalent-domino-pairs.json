[
    {
        "title": "Number of Equivalent Domino Pairs",
        "question_content": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.\nReturn the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\n&nbsp;\nExample 1:\n\nInput: dominoes = [[1,2],[2,1],[3,4],[5,6]]\nOutput: 1\n\nExample 2:\n\nInput: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= dominoes.length <= 4 * 104\n\tdominoes[i].length == 2\n\t1 <= dominoes[i][j] <= 9",
        "solutions": [
            {
                "id": 340022,
                "title": "java-c-python-easy-and-concise",
                "content": "# **Intuition**\\nJust count the number of different dominoes.\\n<br>\\n\\n# **Explanation**\\nYou need to distinguish the different dominoes and count the same.\\n\\nI did it in this way:\\n`f(domino) = min(d[0], d[1]) * 10 + max(d[0], d[1])`\\nFor each domino `d`, calculate `min(d[0], d[1]) * 10 + max(d[0], d[1])`\\nThis will put the smaller number on the left and bigger one on the right (in decimal).\\nSo same number same domino, different number different domino.\\n\\nTake the example from the problem:\\n`dominoes = [[1,2],[2,1],[3,4],[5,6]]`\\nnow we transform it into `[12,12,34,56]`.\\n\\n@sendAsync also suggest other intersting ways to do that:\\n1. Use the product of primes\\n`primes = [2,3,5,7,11,13,17,19,23,29]`\\n`f(domino) = primes[d[0]] * primes[d[1]]`\\n(though primes[0] is not used)\\n\\n2. Use the bit manipulation.\\n`primes = [2,3,5,7,11,13,17,19,23,29]`\\n`f(domino) = 1 << d[0]| 1 << d[1];`\\n\\nPersonaly I like the second more.\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n# Solution 1\\n\\nWe sum up the pair in the end after the loop,\\nusing the guass formula `sum = v * (v + 1) / 2`,\\nwhere `v` is the number of count.\\n\\n**Java:**\\n```java\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int res = 0;\\n        for (int[] d : dominoes) {\\n            int k = Math.min(d[0], d[1]) * 10 + Math.max(d[0], d[1]);\\n            count.put(k, count.getOrDefault(k, 0) + 1);\\n        }\\n        for (int v : count.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numEquivDominoPairs(self, A):\\n        return sum(v * (v - 1) / 2 for v in collections.Counter(tuple(sorted(x)) for x in A).values())\\n```\\n<br>\\n\\n# Solution 2\\n\\nWe sum up the pairs right away during the loop.\\n`count[domino]` is the number of same dominoes that we have seen.\\n\\n**C++:**\\n```cpp\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> count;\\n        int res = 0;\\n        for (auto& d : dominoes) {\\n            res += count[min(d[0], d[1]) * 10 + max(d[0], d[1])]++;\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int res = 0;\\n        for (int[] d : dominoes) {\\n            int k = Math.min(d[0], d[1]) * 10 + Math.max(d[0], d[1]);\\n            count.put(k, count.getOrDefault(k, 0) + 1);\\n        }\\n        for (int v : count.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def numEquivDominoPairs(self, A):\\n        return sum(v * (v - 1) / 2 for v in collections.Counter(tuple(sorted(x)) for x in A).values())\\n```\n```cpp\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> count;\\n        int res = 0;\\n        for (auto& d : dominoes) {\\n            res += count[min(d[0], d[1]) * 10 + max(d[0], d[1])]++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 339969,
                "title": "java-python-3-o-n-code-with-brief-explanation-and-analysis",
                "content": "**Explanation of `cnt += pairs`** credit to **@wunanpty**\\nI want to explain why here we accumulate count like: cnt += pairs;\\nfor example our map is\\n\\nmap: <23, 1> <24, 1>\\ncurrent key = 23, so pair = 1, count += 1 -> count = 1 (which means we have 2 dominoes has same key, 2 dominoes is 1 pair)\\nmap become: <23, 2><24, 1>\\n\\ncurrent key = 23, so pair = 2, count += 2 -> count = 3 (which means we have 3 dominoes has same key, 3 dominoes is 3 pair -> (a, b)(a,c)(b,c))\\nmap become :<23, 3><24, 1>\\n\\ncurrent key = 23, so pair = 3, count += 3 -> count = 6 (4 dominoes has same key, 4 dominoes is 6 pair ->(a,b)(a,c)(a,d)(b,c)(b,d)(c,d))\\nmap become :<23, 4><24, 1>\\n\\n**End**\\n\\n**Q & A:**\\n**Q:** \\n1. Why do we use this for min * 10 + max, encoding?  how to decide on encoding?  \\n2. what if the maximum is infinite?\\n\\n**A:**\\n1. We do NOT have to use `10`, as long as the number `m` > `max(dominoes)`, there will be no collision; In addition, the corresponding decoding is `encoded / m`, `encoded % m`;\\n2. .If the size of the number is limited, we can convert it to a String. \\n\\n**End of Q & A**\\n\\n----\\n1. Encode each domino as min * 10 + max, where min and max are the smaller and bigger values of each domino, respectively;\\n2. Use a HashMap to store the number of dominoes with same encoding, and for each encoding (key), count the newly found pairs;\\n\\n**Java:**\\n```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int cnt = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] a : dominoes) {\\n            int max = Math.max(a[0], a[1]), min = Math.min(a[0], a[1]);\\n            int key = min * 10 + max;\\n            int pairs = map.getOrDefault(key, 0); // the number of dominoes already in the map is the number of the newly found pairs.\\n            cnt += pairs;\\n            map.put(key, 1 + pairs);\\n                               \\n        }\\n        return cnt;\\n    }\\n```\\n\\n----\\n**Python 3:**\\n\\n```\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = {}\\n        cnt = 0\\n        for a, b in dominoes:\\n            key = min(a, b) * 10 + max(a, b) \\n            if key in d:\\n                cnt += d[key] # the number of dominoes already in the map is the number of the newly found pairs.\\n                d[key] += 1\\n            else:\\n                d[key] = 1   \\n        return cnt\\n```\\nor \\n```python\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d, ans = defaultdict(int), 0\\n        for a, b in dominoes:\\n            key = min(a, b), max(a, b)\\n            ans += d[key]\\n            d[key] += 1\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nSince `1 <= dominoes[i][j] <= 9`, there are at most `9 * (9 + 1) / 2 = 45` encodings.\\nTime: O(n), space: O(45), where n = dominoes.length.",
                "solutionTags": [],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int cnt = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] a : dominoes) {\\n            int max = Math.max(a[0], a[1]), min = Math.min(a[0], a[1]);\\n            int key = min * 10 + max;\\n            int pairs = map.getOrDefault(key, 0); // the number of dominoes already in the map is the number of the newly found pairs.\\n            cnt += pairs;\\n            map.put(key, 1 + pairs);\\n                               \\n        }\\n        return cnt;\\n    }\\n```\n```\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = {}\\n        cnt = 0\\n        for a, b in dominoes:\\n            key = min(a, b) * 10 + max(a, b) \\n            if key in d:\\n                cnt += d[key] # the number of dominoes already in the map is the number of the newly found pairs.\\n                d[key] += 1\\n            else:\\n                d[key] = 1   \\n        return cnt\\n```\n```python\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d, ans = defaultdict(int), 0\\n        for a, b in dominoes:\\n            key = min(a, b), max(a, b)\\n            ans += d[key]\\n            d[key] += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 549709,
                "title": "easy-without-hashmap-java-solution-runtime-0ms",
                "content": "__Idea__ \\n```\\nThe main idea is to store each domino pair as a number for example..\\n[1,2] it will be stored as 12 and for domino [2,1] it is same as the above domino \\naccording to the question so this will also be stored as number 12. \\n\\nMaximum range for each number is 9 so the array which will store the frequency of each number will be of size100.\\nAt the end, In the freq array we will have freq of each type of domino and now we need to do nCr of those values.\\nSee the example to support this above line..,\\n[[1,2], [2,1], [1,2], [5,6], [6,5], [1,2]] \\nHere [1,2] this type of domino are 4 and [5,6] this type of domino are 2. \\nThe ans will be 4C2 + 2C2. so 4! \\xF7 (2! * 2!) + 2! \\xF7 (2! * 1!). \\n```\\n\\n\\nTo shorten the Formula see the below picture...,!\\n![image](https://assets.leetcode.com/users/frankenstein32/image_1585029327.png)\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] freq = new int[100];\\n        for(int[] d : dominoes){\\n            int x = Math.min(d[0],d[1]);\\n            int y = Math.max(d[1],d[0]);\\n            freq[x*10 + y]++;\\n        }\\n        int res = 0;\\n        for(int i = 0;i < 100;i++){\\n            if(freq[i] > 0){\\n                res += ((freq[i] * (freq[i] - 1)) / 2);\\n            }       \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThe main idea is to store each domino pair as a number for example..\\n[1,2] it will be stored as 12 and for domino [2,1] it is same as the above domino \\naccording to the question so this will also be stored as number 12. \\n\\nMaximum range for each number is 9 so the array which will store the frequency of each number will be of size100.\\nAt the end, In the freq array we will have freq of each type of domino and now we need to do nCr of those values.\\nSee the example to support this above line..,\\n[[1,2], [2,1], [1,2], [5,6], [6,5], [1,2]] \\nHere [1,2] this type of domino are 4 and [5,6] this type of domino are 2. \\nThe ans will be 4C2 + 2C2. so 4! \\xF7 (2! * 2!) + 2! \\xF7 (2! * 1!). \\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] freq = new int[100];\\n        for(int[] d : dominoes){\\n            int x = Math.min(d[0],d[1]);\\n            int y = Math.max(d[1],d[0]);\\n            freq[x*10 + y]++;\\n        }\\n        int res = 0;\\n        for(int i = 0;i < 100;i++){\\n            if(freq[i] > 0){\\n                res += ((freq[i] * (freq[i] - 1)) / 2);\\n            }       \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348400,
                "title": "python3-dictionary-count",
                "content": "* Use a dictionary to count how many times an intrinsic domino appeared. Here we define intrinsic domino as a sorted domino. By sort the list, we can easily identify the intrinsic domino.  Use the intrinsic domino as key, the intrinsic domino frequency as value, store the information we need in a dictionary.\\n```\\nExample:\\nindex     0     1      2     3\\ninput = [[1,2],[2,1],[1,2],[1,2]]\\nd = { [1,2] : 4}\\nThe number of equivalent domino pairs of the input will be 4 * 3 / 2 = 6\\n          index               index\\npair  1 :   0    [1,2]   and     1        [2,1]\\npair  2 :   0    [1,2]   and     2        [1,2]\\npair  3 :   0    [1,2]   and     3        [1,2]\\npair  4 :   1    [2,1]   and     0        [1,2]\\npair  5 :   1    [2,1]   and     2        [1,2]\\npair  6 :   1    [2,1]   and     3        [1,2]\\npair  7 :   2    [1,2]   and     0        [1,2]\\npair  8 :   2    [1,2]   and     1        [1,2]\\npair  9 :   2    [1,2]   and     3        [1,2]\\npair 10 :   3    [1,2]   and     0        [1,2]\\npair 11 :   3    [1,2]   and     1        [1,2]\\npair 12 :   3    [1,2]   and     2        [1,2]\\n\\napparently, \\npair 1 (index 0, 1) and pair 4  (index 1,0)  are considered the same pair. \\npair 2 (index 0, 2) and pair 7  (index 2,0)  are considered the same pair. \\npair 3 (index 0, 3) and pair 10 (index 3,0)  are considered the same pair. \\npair 5 (index 1, 2) and pair 8 (index 2,1)  are considered the same pair. \\npair 6 (index 1, 3) and pair 11 (index 3,1)  are considered the same pair. \\npair 9 (index 2, 3) and pair 12 (index 3,2)  are considered the same pair. \\n\\n\\n                    \\n```\\n* Calculate how many pairs of Equivalent domino:\\nFor each domino, the number of pairs = n*(n-1)//2, \\nwhere n is the domino frequency.\\nExplanation:\\n\\tFor the first domino in the pair, we have n options, \\n\\tFor the second domino in the pair, we have (n - 1) options. \\n\\tSince the order of domino in the pair doesn\\'t matter, which means\\n```\\nPair 1 : [1,2],[2,1]\\nPair 2 : [2,1],[1,2]\\nare considered the same pair.\\n```\\nWe need to divide by 2 to eliminate the duplicate.\\n```\\nimport collections\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # step 1: count the dominoes\\n        d = {}\\n        for domi in dominoes:\\n            p = tuple(sorted(domi))\\n            if p in d:\\n                d[p] += 1\\n            else:\\n                d[p] = 1\\n        # step 2: caculate the pairs. for each pair, number of pairs = n*(n-1)//2\\n        c = 0\\n        for n in d.values():\\n            s = n*(n-1)//2\\n            c += s\\n        return c\\n```\\n**Complexity Analysis**\\n* Time complexity: O(n)\\nDictionary takes O(1) to store. \\nTo generate the dictionary takes n*O(1) and calculate pairs takes O(n), the total time complexity is O(n), where n is the length of the input list.\\n* Space complexity: O(n)\\nAt worst case (every item in the input list appeared once), the algorithm needs a dictionary which it\\'s size equals the length of the list, where n is the length of the input list.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nExample:\\nindex     0     1      2     3\\ninput = [[1,2],[2,1],[1,2],[1,2]]\\nd = { [1,2] : 4}\\nThe number of equivalent domino pairs of the input will be 4 * 3 / 2 = 6\\n          index               index\\npair  1 :   0    [1,2]   and     1        [2,1]\\npair  2 :   0    [1,2]   and     2        [1,2]\\npair  3 :   0    [1,2]   and     3        [1,2]\\npair  4 :   1    [2,1]   and     0        [1,2]\\npair  5 :   1    [2,1]   and     2        [1,2]\\npair  6 :   1    [2,1]   and     3        [1,2]\\npair  7 :   2    [1,2]   and     0        [1,2]\\npair  8 :   2    [1,2]   and     1        [1,2]\\npair  9 :   2    [1,2]   and     3        [1,2]\\npair 10 :   3    [1,2]   and     0        [1,2]\\npair 11 :   3    [1,2]   and     1        [1,2]\\npair 12 :   3    [1,2]   and     2        [1,2]\\n\\napparently, \\npair 1 (index 0, 1) and pair 4  (index 1,0)  are considered the same pair. \\npair 2 (index 0, 2) and pair 7  (index 2,0)  are considered the same pair. \\npair 3 (index 0, 3) and pair 10 (index 3,0)  are considered the same pair. \\npair 5 (index 1, 2) and pair 8 (index 2,1)  are considered the same pair. \\npair 6 (index 1, 3) and pair 11 (index 3,1)  are considered the same pair. \\npair 9 (index 2, 3) and pair 12 (index 3,2)  are considered the same pair. \\n\\n\\n                    \\n```\n```\\nPair 1 : [1,2],[2,1]\\nPair 2 : [2,1],[1,2]\\nare considered the same pair.\\n```\n```\\nimport collections\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # step 1: count the dominoes\\n        d = {}\\n        for domi in dominoes:\\n            p = tuple(sorted(domi))\\n            if p in d:\\n                d[p] += 1\\n            else:\\n                d[p] = 1\\n        # step 2: caculate the pairs. for each pair, number of pairs = n*(n-1)//2\\n        c = 0\\n        for n in d.values():\\n            s = n*(n-1)//2\\n            c += s\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340458,
                "title": "java-one-pass-o-1-space-beats-100",
                "content": "We can save number of times we\\'ve seen each domino pair in the array of 9x9 < 100 elements. We are looping over the dominoes array and check every pair. Increment element [i,j] of our array. To take into account cases 1,2 and 2,1 we flip the pair so the upper number is always smaller. \\nThe catch is - for every next same pair we check array, if it\\'s > 1 we increment the result, but each time increment will be the number saved in array. So for case like this:\\n1,2 1,2 3,4 1,2 correct answer is 3 - index 0 matches 1 and 3, index 1 matches 3, there are no matches for index 2 and 3.\\n\\narray of results at [1,2] and num will be:\\n1. res[1,2] = 0 - initial\\n2. res[1,2] = 1, num=0 when index = 0\\n3. res[1,2] = 2, num = 1 when index = 1\\n4. res[3,4] = 1, num = 1 when index = 2\\n5. res[1,2] = 3, num = 3 when index = 3\\n\\nWe can use flat array, just compute the index by doing up*10 + down. This is 99 index max, means 100 elements.\\n\\nThis is O(n) time complexity - one scan of the inout array, O(1) space - we\\'ll need count array of the same size independently of number of dominoes.\\n\\nUPD: Make code compact by refactoring some part, thanks to @ysboss\\n\\n```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        //we need to acceess indexes from 0 to 99. max number of dominoes is 9\\n        int[] counts = new int[100];\\n        int res = 0;\\n        //check every pair of dominoes\\n        for (int[] d : dominoes) {\\n            //get upper and down number, make upper always smaller\\n            int up = d[0] < d[1] ? d[0] : d[1]; \\n\\t\\t\\tint down = d[0] < d[1] ? d[1] : d[0];\\n            //increment number of times we\\'ve seen exactly this pair\\n            //if more than once increment result, every next same pair will contribute on 1 more than a previous one\\n            res+=counts[up * 10 + down]++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        //we need to acceess indexes from 0 to 99. max number of dominoes is 9\\n        int[] counts = new int[100];\\n        int res = 0;\\n        //check every pair of dominoes\\n        for (int[] d : dominoes) {\\n            //get upper and down number, make upper always smaller\\n            int up = d[0] < d[1] ? d[0] : d[1]; \\n\\t\\t\\tint down = d[0] < d[1] ? d[1] : d[0];\\n            //increment number of times we\\'ve seen exactly this pair\\n            //if more than once increment result, every next same pair will contribute on 1 more than a previous one\\n            res+=counts[up * 10 + down]++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767338,
                "title": "c-2-approaches-easy-to-understand",
                "content": "# TIME LIMIT EXCEEDED\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int result = 0;\\n        for(int i = 0; i<d.size();i++){\\n            for(int j = i+1;j<d.size();j++){\\n                if((d[i][0] == d[j][0] && d[i][1] == d[j][1]) || (d[i][0] == d[j][1] && d[i][1] == d[j][0])){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Runtime: 104 ms, faster than 80.73% of C++ online submissions for Number of Equivalent Domino Pairs.\\nMemory Usage: 22 MB, less than 96.88% of C++ online submissions for Number of Equivalent Domino Pairs.***\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            seen[make_pair(v[0],v[1])]++;\\n        }\\n        for(auto& [key, value] : seen){\\n            result += value*(value-1)/2;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Runtime: 100 ms, faster than 88.74% of C++ online submissions for Number of Equivalent Domino Pairs.\\nMemory Usage: 22.1 MB, less than 90.63% of C++ online submissions for Number of Equivalent Domino Pairs.***\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            result += seen[make_pair(v[0],v[1])]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int result = 0;\\n        for(int i = 0; i<d.size();i++){\\n            for(int j = i+1;j<d.size();j++){\\n                if((d[i][0] == d[j][0] && d[i][1] == d[j][1]) || (d[i][0] == d[j][1] && d[i][1] == d[j][0])){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            seen[make_pair(v[0],v[1])]++;\\n        }\\n        for(auto& [key, value] : seen){\\n            result += value*(value-1)/2;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            result += seen[make_pair(v[0],v[1])]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506930,
                "title": "c-o-n-domino-id-and-map",
                "content": "##### Algorithm:\\nFor each domino I create an identifying number:\\n* if `d` is current domino, than identifier is: (d[1] << 4) + d[0]\\n* And reverse identifier, if we flip domino: (d[0] << 4) + d[1]\\n\\nCause **one side** of domino has **max value** of `9` (`1001` in binary), it can only take 4 bits. Total lenght of an identifier is `8` bits.\\n\\nFor `d=[9,5]` identifiers gonna look like:\\n![image](https://assets.leetcode.com/users/andnik/image_1582091923.png)\\n\\n##### Code:\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> dict;\\n        int count = 0;\\n        for (vector<int> d: dominoes) {\\n            int a = (d[0] << 4) | d[1], b = (d[1] << 4) | d[0];\\n            count += (a == b ? 0 : dict[b]) + dict[a]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> dict;\\n        int count = 0;\\n        for (vector<int> d: dominoes) {\\n            int a = (d[0] << 4) | d[1], b = (d[1] << 4) | d[0];\\n            count += (a == b ? 0 : dict[b]) + dict[a]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359439,
                "title": "java-simple-solution-8ms-beats-80-runtime-and-100-memory",
                "content": "Represents each domino as 2-digit number, when the first number is always the smallest.\\nFor example [2,3] or [3,2] domino will be represented as 23 number:\\n\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            \\n            int num = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\\n            int currCount = counts.getOrDefault(num, 0);\\n            res += currCount;\\n            counts.put(num, currCount + 1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            \\n            int num = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\\n            int currCount = counts.getOrDefault(num, 0);\\n            res += currCount;\\n            counts.put(num, currCount + 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342042,
                "title": "javascript-o-n-simple-solution-using-map",
                "content": "Permutation:\\na -> 0\\naa -> 1 (0 + 1) pairs\\naaa -> 3 (1 + 2) paris\\naaaa -> 6 (3 + 3) pairs\\naaaaa -> 10 (6 + 4) pairs\\n.....\\n\\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = new Map();\\n    let count = 0;\\n    for (let [a , b] of dominoes) {\\n        let key = a < b ? `${a}${b}` : `${b}${a}`;\\n\\n        if (map.has(key)) {\\n            let currentIndex = map.get(key) + 1;\\n            map.set(key, currentIndex);\\n            count += currentIndex;\\n        } else {\\n            map.set(key, 0);\\n        }\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = new Map();\\n    let count = 0;\\n    for (let [a , b] of dominoes) {\\n        let key = a < b ? `${a}${b}` : `${b}${a}`;\\n\\n        if (map.has(key)) {\\n            let currentIndex = map.get(key) + 1;\\n            map.set(key, currentIndex);\\n            count += currentIndex;\\n        } else {\\n            map.set(key, 0);\\n        }\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817564,
                "title": "java-clean-and-beats-99-o-n-time-o-1-space-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] dominoMap = new int[100];\\n        int matches = 0;\\n        for (int[] domino : dominoes) {\\n            int n1 = domino[0], n2 = domino[1];\\n            int hash = Math.max(n1,n2) * 10 + Math.min(n1,n2);\\n            matches += dominoMap[hash]++;\\n        }\\n        return matches;\\n    }\\n}\\n```\\n\\nThe basic strategy is to keep track of matching dominos in the map using a key that will be the same if the numbers are the same, no matter the order. Since the return needs to be the number of pairs, you can derive that using a summation. Therefore, when a match is found the total matches for that domino is added each time.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] dominoMap = new int[100];\\n        int matches = 0;\\n        for (int[] domino : dominoes) {\\n            int n1 = domino[0], n2 = domino[1];\\n            int hash = Math.max(n1,n2) * 10 + Math.min(n1,n2);\\n            matches += dominoMap[hash]++;\\n        }\\n        return matches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553484,
                "title": "python-99-48-one-liner-explained",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum( [ (v-1)*v//2 for v in collections.Counter([ 10*min(i)+max(i) for i in dominoes ]).values() ]) \\n```\\n\\nThis is how it works step by step. \\n\\nFirst we need to find a a way to assign a unique id to a domino regardless if it\\'s [x:y] or [y:x]. Since domino value is `1<x<9`, we can simply convert it into a 2 digit number like this `[ 10*min(i)+max(i) for i in dominoes ]` . Another approach would to use tuples like `[ tuple(sorted(i)) for i in dominoes ]`. \\n\\nOnce we converted the original list of dominoes into a list of dominoes disregarding orientation, the next step is to calculate counts using `collection.Counter()`. It will produce a dictionary with values like `\\'domino1\\':count1, \\'domino2\\':count2, ...`\\n\\nSince we just need the number of pairs, we can ignore the exact keys and just look at the values (the counts). Calculating pairs is a bit tricky, it\\'s basically n*(n-1)//2 for each domino.\\n\\nFinally we calculate the total count by using `sum()`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum( [ (v-1)*v//2 for v in collections.Counter([ 10*min(i)+max(i) for i in dominoes ]).values() ]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871033,
                "title": "python-dictionary-solution-with-explanation-252ms",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        #Keep track of the dominoes with a dictionary\\n\\t\\t#counter[ DOMINO ] = COUNT\\n        counter = defaultdict( int );\\n        \\n        #Total will be the total number of pairs\\n        total = 0;\\n        \\n        #Go through all of the dominoes\\n        for i in range( len ( dominoes ) ):\\n            #Check the pair at the index\\n            pair = dominoes[ i ];\\n            \\n            #Pull the two values\\n            first = pair[ 0 ];\\n            second = pair[ 1 ];\\n            \\n            #Sort them by value\\n\\t\\t\\t#This way, the reversed matches will go into the same count\\n            smaller = min ( first, second );\\n            bigger = max( first, second );\\n            \\n            #Reassemble into tuple\\n\\t\\t\\t#This will act as our key for each domino\\n            pair_sorted = ( smaller, bigger );\\n            \\n            #If the current domino is already in our counter\\n            #Add to the total the previous matches\\n            \\n            #That is\\n            #If we have already added matching dominoes\\n            #Our current one will match with all the previous\\n            if pair_sorted in counter:\\n                total += counter[ pair_sorted ];\\n            \\n            #Lastly, we increment the count of the current\\n            counter [ pair_sorted ] += 1;\\n            \\n            \\n        return total;\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        #Keep track of the dominoes with a dictionary\\n\\t\\t#counter[ DOMINO ] = COUNT\\n        counter = defaultdict( int );\\n        \\n        #Total will be the total number of pairs\\n        total = 0;\\n        \\n        #Go through all of the dominoes\\n        for i in range( len ( dominoes ) ):\\n            #Check the pair at the index\\n            pair = dominoes[ i ];\\n            \\n            #Pull the two values\\n            first = pair[ 0 ];\\n            second = pair[ 1 ];\\n            \\n            #Sort them by value\\n\\t\\t\\t#This way, the reversed matches will go into the same count\\n            smaller = min ( first, second );\\n            bigger = max( first, second );\\n            \\n            #Reassemble into tuple\\n\\t\\t\\t#This will act as our key for each domino\\n            pair_sorted = ( smaller, bigger );\\n            \\n            #If the current domino is already in our counter\\n            #Add to the total the previous matches\\n            \\n            #That is\\n            #If we have already added matching dominoes\\n            #Our current one will match with all the previous\\n            if pair_sorted in counter:\\n                total += counter[ pair_sorted ];\\n            \\n            #Lastly, we increment the count of the current\\n            counter [ pair_sorted ] += 1;\\n            \\n            \\n        return total;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405437,
                "title": "python3-concise-and-efficient",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        m = collections.defaultdict(int)\\n        ans = 0\\n        for a, b in dominoes:\\n            if a > b: a, b = b, a\\n            v = 10*a + b\\n            if v in m:\\n                ans += m[v]\\n            m[v] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        m = collections.defaultdict(int)\\n        ans = 0\\n        for a, b in dominoes:\\n            if a > b: a, b = b, a\\n            v = 10*a + b\\n            if v in m:\\n                ans += m[v]\\n            m[v] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339957,
                "title": "6-lines-c-with-explanation-0-n-runtime",
                "content": "Key ideas:\\n1. Iterate through dominoes and build a Dictionary (HashMap in Java).\\n2. Form a key from domino values in the same (i.e accending) order so dominoes \\'1:2\\' and \\'2:1\\' will have the same key.\\n3. Count occurences of the key and count number of pairs at the same time.\\n\\nMy initial approach to counting pairs was to count occurences first and then have another iteration through dictionary to calculate pairs.\\nNumber of pairs for N number of occurences is (N-1) + (N-2) + ... + 1 or N*(N-1)/2. \\nThen I realised that pairs can be counted at the same time as occurences, i.e. 1 + 2 + ... + (N-2) + (N-1). \\nSo I started occurences from 0 and count pairs at the same time hence the line: count += ++dictionary[key].\\n\\n```\\npublic int NumEquivDominoPairs(int[][] dominoes)\\n{\\n    var count = 0;\\n    var dictionary = new Dictionary<string, int>();\\n    foreach (var d in dominoes) \\n    {\\n        var key = d[0] < d[1] ? string.Format(\"{0}{1}\", d[0], d[1]) : string.Format(\"{0}{1}\", d[1], d[0]); \\n        if (dictionary.ContainsKey(key)) count += ++dictionary[key]; else dictionary.Add(key, 0);\\n    }\\n    return count;\\n}",
                "solutionTags": [],
                "code": "Key ideas:\\n1. Iterate through dominoes and build a Dictionary (HashMap in Java).\\n2. Form a key from domino values in the same (i.e accending) order so dominoes \\'1:2\\' and \\'2:1\\' will have the same key.\\n3. Count occurences of the key and count number of pairs at the same time.\\n\\nMy initial approach to counting pairs was to count occurences first and then have another iteration through dictionary to calculate pairs.\\nNumber of pairs for N number of occurences is (N-1) + (N-2) + ... + 1 or N*(N-1)/2. \\nThen I realised that pairs can be counted at the same time as occurences, i.e. 1 + 2 + ... + (N-2) + (N-1). \\nSo I started occurences from 0 and count pairs at the same time hence the line: count += ++dictionary[key].\\n\\n```\\npublic int NumEquivDominoPairs(int[][] dominoes)\\n{\\n    var count = 0;\\n    var dictionary = new Dictionary<string, int>();\\n    foreach (var d in dominoes) \\n    {\\n        var key = d[0] < d[1] ? string.Format(\"{0}{1}\", d[0], d[1]) : string.Format(\"{0}{1}\", d[1], d[0]); \\n        if (dictionary.ContainsKey(key)) count += ++dictionary[key]; else dictionary.Add(key, 0);\\n    }\\n    return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 607490,
                "title": "c-solution-with-map",
                "content": "```\\nWe store the pair into hashmap and increment it wheever we encounter this.\\nHow do we store the pair?\\nLet the pair be {a,b} where a store the minimum of the 2 and b stores the maximum of the two.\\n\\nOnce we iterate through the map we our count value will not store n or n-1 nut will store this\\nif n=it->second-1\\ncount+=(n)*(n+1)/2 why?\\nbecause dominoes matching occurs for every domino after it so for example\\n\\n[1,2][1,2][1,2][1,2][2,1][2,1]\\n\\nhere map[{1,2}] = 6\\nbut for the first 1,2 5 are matched with it\\nfor second 1,2 4 are matched with it\\nThus n,n-1,n-2,,,,1 = n*(n+1)/2 (Sum of natural numbers upto n)\\n\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> map;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            int a=min(dominoes[i][0],dominoes[i][1]),b=max(dominoes[i][0],dominoes[i][1]);\\n            map[{a,b}]++;\\n        }\\n        int count=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        {\\n            if(it->second>1)\\n            {\\n                int n=it->second-1;\\n                count+=(n)*(n+1)/2;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe store the pair into hashmap and increment it wheever we encounter this.\\nHow do we store the pair?\\nLet the pair be {a,b} where a store the minimum of the 2 and b stores the maximum of the two.\\n\\nOnce we iterate through the map we our count value will not store n or n-1 nut will store this\\nif n=it->second-1\\ncount+=(n)*(n+1)/2 why?\\nbecause dominoes matching occurs for every domino after it so for example\\n\\n[1,2][1,2][1,2][1,2][2,1][2,1]\\n\\nhere map[{1,2}] = 6\\nbut for the first 1,2 5 are matched with it\\nfor second 1,2 4 are matched with it\\nThus n,n-1,n-2,,,,1 = n*(n+1)/2 (Sum of natural numbers upto n)\\n\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> map;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            int a=min(dominoes[i][0],dominoes[i][1]),b=max(dominoes[i][0],dominoes[i][1]);\\n            map[{a,b}]++;\\n        }\\n        int count=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        {\\n            if(it->second>1)\\n            {\\n                int n=it->second-1;\\n                count+=(n)*(n+1)/2;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519357,
                "title": "intuitive-python-solution-with-comments",
                "content": "`dic` keeps track of how many number of _sorted_ pair that we have seen before. For a given domino pair, if we have seen `x` times before that means we can make `x` number of new pairs. We need to sort the domino pair so that we get a consistent key since we don\\'t want to differentiate let say `[1, 2]` & `[2, 1]`.\\n\\n```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dic = collections.defaultdict(int)\\n        res = 0\\n        for dom in dominoes:\\n            # sort so that we get a consistent key\\n            sdom = tuple(sorted(dom))\\n            \\n            # if we haven\\'t seen it before that means there\\n            # is no pair. if we have seen x number before\\n            # that means we can make x pairs\\n            if sdom in dic:\\n                res += dic[sdom]\\n                \\n            # record that we have seen it\\n            dic[sdom] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dic = collections.defaultdict(int)\\n        res = 0\\n        for dom in dominoes:\\n            # sort so that we get a consistent key\\n            sdom = tuple(sorted(dom))\\n            \\n            # if we haven\\'t seen it before that means there\\n            # is no pair. if we have seen x number before\\n            # that means we can make x pairs\\n            if sdom in dic:\\n                res += dic[sdom]\\n                \\n            # record that we have seen it\\n            dic[sdom] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087193,
                "title": "java-solution-with-explanation",
                "content": "**Simple String key**\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            String val = item[0] < item[1] ? item[0] + \":\" + item[1] : item[1] + \":\" + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```\\n**for better runtime we make the key as integer**\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            int val = item[0] < item[1] ? item[0] *10 + item[1] : item[1] *10 + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            String val = item[0] < item[1] ? item[0] + \":\" + item[1] : item[1] + \":\" + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            int val = item[0] < item[1] ? item[0] *10 + item[1] : item[1] *10 + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920471,
                "title": "simple-concise-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        map<vector<int>,int> m;\\n        for(auto i:dominoes)\\n        {\\n            sort(i.begin(),i.end());\\n            if(m.find(i)!=m.end()) ans+=m[i]++;\\n            else m[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        map<vector<int>,int> m;\\n        for(auto i:dominoes)\\n        {\\n            sort(i.begin(),i.end());\\n            if(m.find(i)!=m.end()) ans+=m[i]++;\\n            else m[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491615,
                "title": "java-t-96-56-s-100-array-to-the-rescue",
                "content": "```\\n\\tpublic int numEquivDominoPairs(int[][] d) {\\n        int pairs = 0; // number of pairs\\n        int[][] count = new int[10][10]; // in this scenario better than hashmap\\n        \\n        for(int i=0;i<d.length;i++){\\n            int m = d[i][0];\\n            int n = d[i][1];\\n            \\n            if(m > n){ // if m is bigger than n just swap them to align with similar dominoes\\n                n = d[i][0];\\n                m = d[i][1];\\n            }\\n            \\n            pairs += count[m][n]; // equivalent to doing \\'n(n+1)/2\\' one time for each unique domino \\n            \\n            count[m][n]++; // increase the occurence count\\n        }\\n        \\n        return pairs;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numEquivDominoPairs(int[][] d) {\\n        int pairs = 0; // number of pairs\\n        int[][] count = new int[10][10]; // in this scenario better than hashmap\\n        \\n        for(int i=0;i<d.length;i++){\\n            int m = d[i][0];\\n            int n = d[i][1];\\n            \\n            if(m > n){ // if m is bigger than n just swap them to align with similar dominoes\\n                n = d[i][0];\\n                m = d[i][1];\\n            }\\n            \\n            pairs += count[m][n]; // equivalent to doing \\'n(n+1)/2\\' one time for each unique domino \\n            \\n            count[m][n]++; // increase the occurence count\\n        }\\n        \\n        return pairs;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340012,
                "title": "c-no-sort",
                "content": "No customized sort.\\n\\nSince it\\'s hard (for me) to sort by first element in ascending order then second in ascending order, use a map to count ```freq```. Map will sort in the aforementioned fashion for you.\\n\\nNotice ```freq[make_pair(d[0], d[1])]``` is first added to ```res``` in each round, then self-increment. \\nThis ensures adding ```1, 2, 3...``` respectively in each round.\\n\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> freq;\\n        int res = 0;\\n\\n        for (vector<int> d : dominoes) {\\n            if (d[0] > d[1]) { \\n\\t        // swap elements\\n                d[0] = d[0] + d[1];\\n                d[1] = d[0] - d[1];\\n                d[0] = d[0] - d[1];\\n            }\\n\\n            res += freq[make_pair(d[0], d[1])]++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```freq```\n```freq[make_pair(d[0], d[1])]```\n```res```\n```1, 2, 3...```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> freq;\\n        int res = 0;\\n\\n        for (vector<int> d : dominoes) {\\n            if (d[0] > d[1]) { \\n\\t        // swap elements\\n                d[0] = d[0] + d[1];\\n                d[1] = d[0] - d[1];\\n                d[0] = d[0] - d[1];\\n            }\\n\\n            res += freq[make_pair(d[0], d[1])]++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309741,
                "title": "python-simple-hashmap",
                "content": "\\n    def numEquivDominoPairs(self, dominoes):\\n        dict1, total = defaultdict(int), 0\\n        \\n        for i, j in dominoes:\\n            min_val = min(i, j)\\n            max_val = max(i, j)\\n            dict1[(min_val, max_val)] += 1\\n            \\n        for i in dict1:\\n            total += dict1[i]*(dict1[i]-1)//2\\n            \\n        return total",
                "solutionTags": [],
                "code": "\\n    def numEquivDominoPairs(self, dominoes):\\n        dict1, total = defaultdict(int), 0\\n        \\n        for i, j in dominoes:\\n            min_val = min(i, j)\\n            max_val = max(i, j)\\n            dict1[(min_val, max_val)] += 1\\n            \\n        for i in dict1:\\n            total += dict1[i]*(dict1[i]-1)//2\\n            \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 1176876,
                "title": "java-by-using-only-array-faster-than-82-89-memory-used-less-than-76-11-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int cn =0;\\n        \\n        int[][] n = new int[10][10];\\n        \\n      \\n        \\n        for(int i = 0 ; i< dominoes.length ; i++){\\n            \\n            if(dominoes[i][0] < dominoes[i][1]){\\n                int t= dominoes[i][0];\\n                dominoes[i][0] = dominoes[i][1];\\n                dominoes[i][1] = t ;\\n            }\\n            \\n            cn = cn +   n[dominoes[i][0]][dominoes[i][1]];\\n            n[dominoes[i][0]][dominoes[i][1]] ++;\\n            \\n        }\\n        \\n       \\n            \\n        return cn;\\n        \\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int cn =0;\\n        \\n        int[][] n = new int[10][10];\\n        \\n      \\n        \\n        for(int i = 0 ; i< dominoes.length ; i++){\\n            \\n            if(dominoes[i][0] < dominoes[i][1]){\\n                int t= dominoes[i][0];\\n                dominoes[i][0] = dominoes[i][1];\\n                dominoes[i][1] = t ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1174121,
                "title": "java-array-hashing-beats-99-10-2ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(dominoes.length) O(1)\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\n\\t\\tint len = dominoes.length, count = 0;\\n\\t\\tint[] map = new int[91];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint[] domino = dominoes[i];\\n\\t\\t\\tint hash1 = 9 * domino[0] + domino[1], hash2 = 9 * domino[1] + domino[0];\\n\\t\\t\\tcount += map[hash1];\\n\\t\\t\\tcount += (hash1 != hash2) ? map[hash2] : 0;\\n\\t\\t\\tmap[hash1]++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(dominoes.length) O(1)\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\n\\t\\tint len = dominoes.length, count = 0;\\n\\t\\tint[] map = new int[91];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint[] domino = dominoes[i];\\n\\t\\t\\tint hash1 = 9 * domino[0] + domino[1], hash2 = 9 * domino[1] + domino[0];\\n\\t\\t\\tcount += map[hash1];\\n\\t\\t\\tcount += (hash1 != hash2) ? map[hash2] : 0;\\n\\t\\t\\tmap[hash1]++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 982936,
                "title": "python-o-n-beats-97-37-dictionary-combinatorial-number",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        num_dic = collections.defaultdict(int)\\n        n = len(dominoes)\\n        for i in range(n):\\n\\t\\t# make dominoe like [1, 2] and [2, 1] become the same\\n            a, b = sorted(dominoes[i])\\n            num_dic[(a, b)] += 1\\n        pairs = 0\\n        for k, v in num_dic.items():\\n\\t\\t# number of equivalents in dictionary\\n            if v >= 2:\\n\\t\\t\\t# formula of comtinational number, C(2, n) = n(n-1)/2. For example, item a, b, c could form three combinations of two: (a, b), (a, c), (b, c)\\n                pairs += (v * (v-1))//2\\n        return pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        num_dic = collections.defaultdict(int)\\n        n = len(dominoes)\\n        for i in range(n):\\n\\t\\t# make dominoe like [1, 2] and [2, 1] become the same\\n            a, b = sorted(dominoes[i])\\n            num_dic[(a, b)] += 1\\n        pairs = 0\\n        for k, v in num_dic.items():\\n\\t\\t# number of equivalents in dictionary\\n            if v >= 2:\\n\\t\\t\\t# formula of comtinational number, C(2, n) = n(n-1)/2. For example, item a, b, c could form three combinations of two: (a, b), (a, c), (b, c)\\n                pairs += (v * (v-1))//2\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819546,
                "title": "javascript-solution-with-object",
                "content": "```\\nvar sum = 0;\\n  var obj = {};\\n  dominoes.map((x) => {\\n    var cha = x.sort((a, b) => a - b).join(\"\");\\n    if (obj.hasOwnProperty(cha)) {\\n      sum += obj[cha];\\n      obj[cha]++;\\n    } else {\\n      obj[cha] = 1;\\n    }\\n  });\\n  return sum;\\n  \\n  ES6:\\n  var numEquivDominoPairs = function (dominoes) {\\n    const dic = {};\\n    let pairs = 0;\\n    dominoes.map((domi) => {\\n        domi.sort((a, b) => a - b);\\n        dic[domi] ? ((pairs += dic[domi]), dic[domi]++) : (dic[domi] = 1);\\n    });\\n    return pairs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sum = 0;\\n  var obj = {};\\n  dominoes.map((x) => {\\n    var cha = x.sort((a, b) => a - b).join(\"\");\\n    if (obj.hasOwnProperty(cha)) {\\n      sum += obj[cha];\\n      obj[cha]++;\\n    } else {\\n      obj[cha] = 1;\\n    }\\n  });\\n  return sum;\\n  \\n  ES6:\\n  var numEquivDominoPairs = function (dominoes) {\\n    const dic = {};\\n    let pairs = 0;\\n    dominoes.map((domi) => {\\n        domi.sort((a, b) => a - b);\\n        dic[domi] ? ((pairs += dic[domi]), dic[domi]++) : (dic[domi] = 1);\\n    });\\n    return pairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597640,
                "title": "python-3-use-dictionary",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        mydic={}\\n        for ele in dominoes:\\n            if ele[0]<=ele[1]:\\n                a=tuple(ele)\\n            else:\\n                a=tuple(ele[::-1])\\n            if a in mydic:\\n                mydic[a]+=1\\n            else:\\n                mydic[a]=1\\n        count=0\\n        for k, v in mydic.items():\\n            if v>1:\\n                count+=v*(v-1)//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        mydic={}\\n        for ele in dominoes:\\n            if ele[0]<=ele[1]:\\n                a=tuple(ele)\\n            else:\\n                a=tuple(ele[::-1])\\n            if a in mydic:\\n                mydic[a]+=1\\n            else:\\n                mydic[a]=1\\n        count=0\\n        for k, v in mydic.items():\\n            if v>1:\\n                count+=v*(v-1)//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510614,
                "title": "simple-java-with-hasmap",
                "content": "```\\nclass Solution {\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> dic = new HashMap<>();\\n        int res = 0;\\n        for(int[] domino : dominoes) {\\n            int val = domino[0] < domino[1] ? domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n            int count = dic.getOrDefault(val,0);\\n            dic.put(val, count + 1);\\n            res = res + count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> dic = new HashMap<>();\\n        int res = 0;\\n        for(int[] domino : dominoes) {\\n            int val = domino[0] < domino[1] ? domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n            int count = dic.getOrDefault(val,0);\\n            dic.put(val, count + 1);\\n            res = res + count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360111,
                "title": "linear-time-linear-space",
                "content": "```\\n\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<String, Integer> domGroup = new HashMap<>();\\n        int totalPairs = 0; // Solution\\n        \\n        for (int[] dominoe: dominoes){\\n            int smallest = dominoe[0] < dominoe[1] ? dominoe[0] : dominoe[1];\\n            int largest = dominoe[1] > dominoe[0] ? dominoe[1] : dominoe[0];\\n            String key = smallest + \"#\" + largest;\\n            domGroup.put(key, domGroup.getOrDefault(key, 0) + 1);\\n        }\\n        \\n        for (String key: domGroup.keySet()){\\n            int count = domGroup.get(key);\\n            totalPairs += (count*(count-1)) / 2;\\n        }\\n        \\n        return totalPairs;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<String, Integer> domGroup = new HashMap<>();\\n        int totalPairs = 0; // Solution\\n        \\n        for (int[] dominoe: dominoes){\\n            int smallest = dominoe[0] < dominoe[1] ? dominoe[0] : dominoe[1];\\n            int largest = dominoe[1] > dominoe[0] ? dominoe[1] : dominoe[0];\\n            String key = smallest + \"#\" + largest;\\n            domGroup.put(key, domGroup.getOrDefault(key, 0) + 1);\\n        }\\n        \\n        for (String key: domGroup.keySet()){\\n            int count = domGroup.get(key);\\n            totalPairs += (count*(count-1)) / 2;\\n        }\\n        \\n        return totalPairs;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483730,
                "title": "java-2-approaches-counting-with-array-counting-with-hashmap",
                "content": "### Counting With Array\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] counts = new int[100];\\n        int pairsCount = 0;\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n            \\n            pairsCount += counts[up * 10 + down]++;\\n        }\\n\\n        return pairsCount;\\n    }\\n}\\n```\\n### Counting With HashMap\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int pairsCountSum = 0;\\n        Map<Integer, Integer> pairsCount = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n\\n            int num = up * 10 + down;\\n            if (!pairsCount.containsKey(num)) {\\n                pairsCount.put(num, 1);\\n            } else {\\n                pairsCountSum += pairsCount.get(num);\\n                pairsCount.put(num, pairsCount.get(num) + 1);\\n            }\\n        }\\n\\n        return pairsCountSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] counts = new int[100];\\n        int pairsCount = 0;\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n            \\n            pairsCount += counts[up * 10 + down]++;\\n        }\\n\\n        return pairsCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int pairsCountSum = 0;\\n        Map<Integer, Integer> pairsCount = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n\\n            int num = up * 10 + down;\\n            if (!pairsCount.containsKey(num)) {\\n                pairsCount.put(num, 1);\\n            } else {\\n                pairsCountSum += pairsCount.get(num);\\n                pairsCount.put(num, pairsCount.get(num) + 1);\\n            }\\n        }\\n\\n        return pairsCountSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598466,
                "title": "hashmap-c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto &x : dominoes) {\\n            int key = 0;\\n            key = key | (1 << x[0]);\\n            key = key | (1 << x[1]);\\n            if(mp.count(key))\\n                ans += mp[key];\\n            mp[key]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto &x : dominoes) {\\n            int key = 0;\\n            key = key | (1 << x[0]);\\n            key = key | (1 << x[1]);\\n            if(mp.count(key))\\n                ans += mp[key];\\n            mp[key]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561757,
                "title": "java-solution-using-hashmap",
                "content": "Step 1 : swap the dominoes[i]->(a,b) according to which one is smaller\\nStep 2 : Creating hashMap with key as a*10+b and value as the number of occurences of (a,b)\\nStep 3 : Counting the values of hashmap which are greater than 1\\nStep 4 : By combination theorem nCr = n!/(n-r)!*r! \\n            here we have to find out the number of pairs we get so n is the value of key and r is 2 as we are            considering pairs\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]>dominoes[i][1])\\n            {\\n                int tmp=dominoes[i][1];\\n                dominoes[i][1]=dominoes[i][0];\\n                dominoes[i][0]=tmp;\\n            }\\n        }\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int c=0;\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(hm.get(dominoes[i][0]*10+dominoes[i][1])==null)\\n            {\\n                hm.put(dominoes[i][0]*10+dominoes[i][1],1);\\n            }\\n            else hm.put(dominoes[i][0]*10+dominoes[i][1],hm.get(dominoes[i][0]*10+dominoes[i][1])+1);\\n            \\n        }\\n        System.out.println(hm);\\n        for(Map.Entry<Integer,Integer>e:hm.entrySet())\\n        {\\n            int k=e.getValue();\\n            if(k>1)c+=((k*(k-1))/2);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]>dominoes[i][1])\\n            {\\n                int tmp=dominoes[i][1];\\n                dominoes[i][1]=dominoes[i][0];\\n                dominoes[i][0]=tmp;\\n            }\\n        }\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int c=0;\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(hm.get(dominoes[i][0]*10+dominoes[i][1])==null)\\n            {\\n                hm.put(dominoes[i][0]*10+dominoes[i][1],1);\\n            }\\n            else hm.put(dominoes[i][0]*10+dominoes[i][1],hm.get(dominoes[i][0]*10+dominoes[i][1])+1);\\n            \\n        }\\n        System.out.println(hm);\\n        for(Map.Entry<Integer,Integer>e:hm.entrySet())\\n        {\\n            int k=e.getValue();\\n            if(k>1)c+=((k*(k-1))/2);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459029,
                "title": "go-without-hashmap-o-n",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    res, cache := 0, make([][]int, 10)\\n    \\n    for i := 0; i < 10; i++ {\\n        cache[i] = make([]int, 10)\\n    }\\n    \\n    for i := 0; i < len(dominoes); i++ {\\n        begin, end := dominoes[i][0], dominoes[i][1]\\n        \\n        res += cache[begin][end]\\n        \\n        if begin != end {\\n            res += cache[end][begin]\\n        }\\n        \\n        \\n        cache[begin][end]++\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    res, cache := 0, make([][]int, 10)\\n    \\n    for i := 0; i < 10; i++ {\\n        cache[i] = make([]int, 10)\\n    }\\n    \\n    for i := 0; i < len(dominoes); i++ {\\n        begin, end := dominoes[i][0], dominoes[i][1]\\n        \\n        res += cache[begin][end]\\n        \\n        if begin != end {\\n            res += cache[end][begin]\\n        }\\n        \\n        \\n        cache[begin][end]++\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330705,
                "title": "simple-c-nlog-n-soln-and-o-1-space",
                "content": "```\\nint numEquivDominoPairs(vector<vector<int>>& d) {\\n        for(int i=0;i<d.size();i++){\\n            if(d[i][0]>d[i][1]) swap(d[i][0],d[i][1]);\\n        }\\n        sort(d.begin(),d.end());\\n        int ans=0;\\n        for(int i=0;i<d.size();){\\n            int j=i+1;\\n            while(j<d.size()&&d[j]==d[i]) j++;\\n            if(j==i+1){\\n                i=j;\\n                continue;\\n            }\\n            ans+=(j-i)*(j-i-1)/2;\\n            i=j;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint numEquivDominoPairs(vector<vector<int>>& d) {\\n        for(int i=0;i<d.size();i++){\\n            if(d[i][0]>d[i][1]) swap(d[i][0],d[i][1]);\\n        }\\n        sort(d.begin(),d.end());\\n        int ans=0;\\n        for(int i=0;i<d.size();){\\n            int j=i+1;\\n            while(j<d.size()&&d[j]==d[i]) j++;\\n            if(j==i+1){\\n                i=j;\\n                continue;\\n            }\\n            ans+=(j-i)*(j-i-1)/2;\\n            i=j;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1643791,
                "title": "java-2ms-100-one-pass-dp-w-arrhash-just-5-lines-thinking-process",
                "content": "Because there are a lot of reoccuring identical domino, 1 scan to hash and another scan over the hash array / map is the first that came to mind. However, we can improve upon this with the principle of Dynamic Programming, with every new identical domino found, there are **\"1 + valid count that ends with previous identical domino\"** We can then count as we loop through the array for the first time, meaing <ins>*1 for loop should suffice*</ins>.\\n\\nWith that in mind, then, we have to come up with a way to group all the identical dominos together. One quick observation is that **those with identical max and min number in the domino are identical, regardless of how the min and max are arranged**, and then next observation is that the number can only go up to 9 at most according to the problem constraint. Hence, we duduce that the HashID of each domino is then <ins>`10 * max + min`</ins>. And this number can only go up to 99 at most. Domino with the same HashID are identical as laid out by this problem. We will utilize an array with size 100 to handle the counting aspect of it. \\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] count = new int[100];\\n        int ans = 0;\\n        for (int[] d : dominoes)\\n            if (++count[hash(d)] > 1) //increment count and if it is >= 2, then\\n                ans += count[hash(d)] - 1; //we add to the ans (remember to -1 because single 1 domino isn\\'t a pair)\\n        return ans;\\n    }\\n\\n    private static int hash(int[] d){ //domino with the same id are the same.\\n        return 10 * Math.max(d[0], d[1]) + Math.min(d[0], d[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] count = new int[100];\\n        int ans = 0;\\n        for (int[] d : dominoes)\\n            if (++count[hash(d)] > 1) //increment count and if it is >= 2, then\\n                ans += count[hash(d)] - 1; //we add to the ans (remember to -1 because single 1 domino isn\\'t a pair)\\n        return ans;\\n    }\\n\\n    private static int hash(int[] d){ //domino with the same id are the same.\\n        return 10 * Math.max(d[0], d[1]) + Math.min(d[0], d[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607621,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int count=0;\\n        map<vector<int>,int>m;\\n        for(int i=0;i<dominoes.size();i++) {\\n            vector<int>aux=dominoes[i];\\n            // sort the pair and store in the hashmap\\n            if(aux[0]>aux[1]) {\\n                swap(aux[0],aux[1]);\\n            }\\n            m[aux]++;\\n        }\\n        for(auto it:m) {\\n            if(it.second>1) {\\n                // so if for any domino we\\'ve \\'n\\' instances then we can make nC2 equivalent pair from them..\\n                int n=it.second;\\n                count+=((n*(n-1))/2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int count=0;\\n        map<vector<int>,int>m;\\n        for(int i=0;i<dominoes.size();i++) {\\n            vector<int>aux=dominoes[i];\\n            // sort the pair and store in the hashmap\\n            if(aux[0]>aux[1]) {\\n                swap(aux[0],aux[1]);\\n            }\\n            m[aux]++;\\n        }\\n        for(auto it:m) {\\n            if(it.second>1) {\\n                // so if for any domino we\\'ve \\'n\\' instances then we can make nC2 equivalent pair from them..\\n                int n=it.second;\\n                count+=((n*(n-1))/2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564329,
                "title": "c-easy-solution-map",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes)\\n    {\\n        map<pair<int, int>, int> mp;\\n        int ans = 0;\\n        for (const auto &i : dominoes)\\n        {\\n            //checking in map and updating \\'ans\\' variable\\n            if (i[0] < i[1])  ans += mp[{i[0], i[1]}];\\n            else  ans += mp[{i[1], i[0]}];\\n            \\n            //updation of map based on small value first and large value second\\n            if (i[0] < i[1])  ++mp[{i[0], i[1]}];\\n            else  ++mp[{i[1], i[0]}];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes)\\n    {\\n        map<pair<int, int>, int> mp;\\n        int ans = 0;\\n        for (const auto &i : dominoes)\\n        {\\n            //checking in map and updating \\'ans\\' variable\\n            if (i[0] < i[1])  ans += mp[{i[0], i[1]}];\\n            else  ans += mp[{i[1], i[0]}];\\n            \\n            //updation of map based on small value first and large value second\\n            if (i[0] < i[1])  ++mp[{i[0], i[1]}];\\n            else  ++mp[{i[1], i[0]}];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514590,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum(v*(v-1)//2 for v in collections.Counter([min(a,b)*10+max(a,b) for a,b in dominoes]).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum(v*(v-1)//2 for v in collections.Counter([min(a,b)*10+max(a,b) for a,b in dominoes]).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452251,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int>m;\\n        int ret=0;\\n        for(auto i:dominoes) {\\n            if(i[0]>i[1]) {\\n                m[{i[1],i[0]}]++;\\n            }\\n            else m[{i[0],i[1]}]++;\\n        }\\n        for(auto i:m) {\\n            ret+=i.second*(i.second-1)/2;\\n        }\\n        return ret;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int>m;\\n        int ret=0;\\n        for(auto i:dominoes) {\\n            if(i[0]>i[1]) {\\n                m[{i[1],i[0]}]++;\\n            }\\n            else m[{i[0],i[1]}]++;\\n        }\\n        for(auto i:m) {\\n            ret+=i.second*(i.second-1)/2;\\n        }\\n        return ret;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405532,
                "title": "c-simple-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        \\n        for(auto &vec : dominoes) {\\n            if(vec[0] > vec[1])\\n                swap(vec[0], vec[1]); //so that we get {2, 1} and {1, 2} counted together\\n            mp[{vec[0], vec[1]}]++;\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto &it : mp) {\\n            int val = it.second;\\n            count += val*(val-1)/2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        \\n        for(auto &vec : dominoes) {\\n            if(vec[0] > vec[1])\\n                swap(vec[0], vec[1]); //so that we get {2, 1} and {1, 2} counted together\\n            mp[{vec[0], vec[1]}]++;\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto &it : mp) {\\n            int val = it.second;\\n            count += val*(val-1)/2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318549,
                "title": "java-approach-using-10x10-grid-o-n-time-o-1-space",
                "content": "[https://github.com/2018hsridhar/Leetcode_Solutions/blob/master/leetcode_1128.java](http://)\\n```\\n/*\\n1128. Number of Equivalent Domino Pairs\\nURL = https://leetcode.com/problems/number-of-equivalent-domino-pairs/\\n\\nThought process : \\n1. Summation of dominoe values - [1,12] here : but can have multiple sums too, so take note of that\\n-> Gets problematic with middle summations though\\n\\n\\n2. Let us generation sums maps\\n\\n2 => [1,1]\\n3 => [1,2], [2,1] \\n4 => [1,3], [3,1], [2,2]\\n5 => [1,4],[4,1],[2,3],[4,3]\\n6 => [1,5],[5,1],[2,4][4,2],[3,3] \\n\\nIdea #2 : sort and compare to previous elements ( after a global sort operation )?\\n\\nA lot of dominos are possible here\\nDomino values are reasonable too : [1,9] only\\n\\nComputational complexity :\\n\\nPairwise comparisons : O(N^2) due to N(N-1)/2 unique number of domino pairings here\\nSpace Complexity, with pairwise comparison approach = O(1) though ... may run into a RLE error\\n\\nEdge case testing  :\\n\\nUse an matrix instead of a hashmap approach, and add indices as we go? Is a 9x9 only!\\n\\n\\n*/\\n\\nclass Solution\\n{\\n    public int numEquivDominoPairs(int[][] dominoes) \\n    {\\n        int numPairs = 0;\\n        int[][] matrix = new int[10][10];\\n        for(int i = 0; i < matrix.length; ++i)\\n            for(int j = 0; j < matrix[0].length; ++j)\\n                matrix[i][j] = 0;\\n        \\n        for(int i = 0; i < dominoes.length; ++i)\\n        {\\n            int[] domino = dominoes[i];\\n            int x = domino[0];\\n            int y = domino[1];\\n            ++matrix[x][y];\\n        }\\n        \\n        // Iterate over upper triangle only\\n        for(int i = 0; i < 10; ++i)\\n        {\\n            for(int j = i; j < 10; ++j)\\n            {\\n                int dominoCount = matrix[i][j];\\n                if(i != j)\\n                    dominoCount += matrix[j][i];\\n                numPairs += (dominoCount*(dominoCount - 1) / 2); // n choose 2 type of thing now!\\n            }\\n        }\\n        return numPairs;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution\\n{\\n    public int numEquivDominoPairs(int[][] dominoes) \\n    {\\n        int numPairs = 0;\\n        int[][] matrix = new int[10][10];\\n        for(int i = 0; i < matrix.length; ++i)\\n            for(int j = 0; j < matrix[0].length; ++j)\\n                matrix[i][j] = 0;\\n        \\n        for(int i = 0; i < dominoes.length; ++i)\\n        {\\n            int[] domino = dominoes[i];\\n            int x = domino[0];\\n            int y = domino[1];\\n            ++matrix[x][y];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1211473,
                "title": "c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tmap< pair<int,int>,int>mp;\\n\\t\\t\\tfor(auto  &p:dominoes){\\n\\t\\t\\t\\tint x=p[0];\\n\\t\\t\\t\\tint y=p[1];\\n\\t\\t\\t\\tif(x>y)swap(x,y);\\n\\t\\t\\t\\tmp[{x,y}]++;\\n\\t\\t\\t}\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(auto &p :mp){\\n\\t\\t\\t\\tif(p.second>=2){\\n\\t\\t\\t\\t\\tint n=p.second;\\n\\t\\t\\t\\t\\tcnt+= (n*(n-1))/2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tmap< pair<int,int>,int>mp;\\n\\t\\t\\tfor(auto  &p:dominoes){\\n\\t\\t\\t\\tint x=p[0];\\n\\t\\t\\t\\tint y=p[1];\\n\\t\\t\\t\\tif(x>y)swap(x,y);\\n\\t\\t\\t\\tmp[{x,y}",
                "codeTag": "Java"
            },
            {
                "id": 1147918,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] arr) {\\n        Map<List<Integer>,Integer> map = new HashMap<>();\\n        int ans =0;\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> list = new LinkedList<>();\\n            if(arr[i][0] > arr[i][1])\\n            {\\n                list.add(arr[i][0]);\\n                list.add(arr[i][1]);\\n            }\\n            else {\\n                list.add(arr[i][1]);\\n                list.add(arr[i][0]);\\n            }\\n            if(map.containsKey(list)){\\n                map.replace(list,1+map.get(list));\\n                ans += map.get(list);\\n            }\\n            else map.put(list,0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if you find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] arr) {\\n        Map<List<Integer>,Integer> map = new HashMap<>();\\n        int ans =0;\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> list = new LinkedList<>();\\n            if(arr[i][0] > arr[i][1])\\n            {\\n                list.add(arr[i][0]);\\n                list.add(arr[i][1]);\\n            }\\n            else {\\n                list.add(arr[i][1]);\\n                list.add(arr[i][0]);\\n            }\\n            if(map.containsKey(list)){\\n                map.replace(list,1+map.get(list));\\n                ans += map.get(list);\\n            }\\n            else map.put(list,0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029486,
                "title": "python-solution",
                "content": "\\th, result = {}, 0\\n\\tfor domino in dominoes:\\n\\t\\ts = tuple(sorted(domino))\\n\\t\\th[s] = h.get(s, 0) + 1\\n\\tfor val in h.values():\\n\\t\\tif val > 1:\\n\\t\\t\\tresult += val * (val - 1) / 2\\n\\treturn result",
                "solutionTags": [],
                "code": "\\th, result = {}, 0\\n\\tfor domino in dominoes:\\n\\t\\ts = tuple(sorted(domino))\\n\\t\\th[s] = h.get(s, 0) + 1\\n\\tfor val in h.values():\\n\\t\\tif val > 1:\\n\\t\\t\\tresult += val * (val - 1) / 2\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 839014,
                "title": "rust-cleaner-rust-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count = HashMap::new();\\n        for d in dominoes {\\n            let d = (d[0].min(d[1]), d[0].max(d[1]));\\n            *count.entry(d).or_insert(0) += 1;\\n        }\\n        count.values().map(|c| (c * (c - 1)) / 2).sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count = HashMap::new();\\n        for d in dominoes {\\n            let d = (d[0].min(d[1]), d[0].max(d[1]));\\n            *count.entry(d).or_insert(0) += 1;\\n        }\\n        count.values().map(|c| (c * (c - 1)) / 2).sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589387,
                "title": "c-faster-than-100-less-than-100-mem-o-n",
                "content": "```\\npublic int NumEquivDominoPairs(int[][] dominoes) {\\n     Dictionary<int, int> numbers = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < dominoes.Length; i++)\\n            {\\n                int key = 0;\\n\\n                if (dominoes[i][0] <= dominoes[i][1])\\n                {\\n                    key = dominoes[i][0] * 10 + dominoes[i][1];\\n                }\\n                else\\n                {\\n                    key = dominoes[i][1] * 10 + dominoes[i][0];\\n                }\\n\\n                if (numbers.TryGetValue(key, out var s))\\n                {\\n                    numbers[key] += 1;\\n                }\\n                else numbers.Add(key, 1);\\n            }\\n            return numbers.Values.Sum(e => e*(e - 1)/2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumEquivDominoPairs(int[][] dominoes) {\\n     Dictionary<int, int> numbers = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < dominoes.Length; i++)\\n            {\\n                int key = 0;\\n\\n                if (dominoes[i][0] <= dominoes[i][1])\\n                {\\n                    key = dominoes[i][0] * 10 + dominoes[i][1];\\n                }\\n                else\\n                {\\n                    key = dominoes[i][1] * 10 + dominoes[i][0];\\n                }\\n\\n                if (numbers.TryGetValue(key, out var s))\\n                {\\n                    numbers[key] += 1;\\n                }\\n                else numbers.Add(key, 1);\\n            }\\n            return numbers.Values.Sum(e => e*(e - 1)/2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487328,
                "title": "python-frozenset-1-liner",
                "content": "As the order of a domino\\'s numbers doesn\\'t matter, we should regard dominos as sets. To use a `Counter`, we need them hashable, so we use `frozenset`.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, D):\\n        return sum(d*(d-1)/2 for d in Counter(map(frozenset, D)).values())\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, D):\\n        return sum(d*(d-1)/2 for d in Counter(map(frozenset, D)).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484568,
                "title": "java-solution",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        int count = 0;\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int[] dominoe : dominoes){\\n            int small = Math.min(dominoe[0], dominoe[1]);\\n            int large = Math.max(dominoe[0], dominoe[1]);\\n            String key = small + \"$\" + large;\\n            count += map.getOrDefault(key,0);\\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        int count = 0;\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int[] dominoe : dominoes){\\n            int small = Math.min(dominoe[0], dominoe[1]);\\n            int large = Math.max(dominoe[0], dominoe[1]);\\n            String key = small + \"$\" + large;\\n            count += map.getOrDefault(key,0);\\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417112,
                "title": "python-3-two-solutions-one-pass-99-38-two-pass-98-03",
                "content": "Method 1 (one pass) (beating 99.38%)\\n1) loop through `dominoes`\\n2) at each domino pair, add the number of equivalent domino pairs observed so far to answer and add count of equivalent domino pairs by 1;\\n3) return the anser.\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0\\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            if x > y: x, y = y, x\\n            key = 10*x + y\\n            ans += freq[key]\\n            freq[key] += 1\\n        return ans \\n```\\nMethod 2 (two pass) (beating 98.03%)\\n1) pass-1, count occurrence of each equivalent domino pair;\\n2) pass-2, loop through the counts and compute 1 + ... + v-1 using formula;\\n3) return the sum \\n4) \\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for x, y in dominoes:\\n            if x > y: x, y = y, x\\n            freq[10*x + y] += 1\\n        return sum(v*(v-1)//2 for v in freq.values())\\n```\\n\\nA two-line version of method 2 is below. \\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        count = Counter((lambda x,y: 10*x+y)(*sorted(d)) for d in dominoes)\\n        return sum(v*(v-1)//2 for v in count.values())\\n```\\n\\nEdited on 4/20/2021 \\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0 \\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            ans += freq[x, y]\\n            if x != y: ans += freq[y, x]\\n            freq[x, y] += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0\\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            if x > y: x, y = y, x\\n            key = 10*x + y\\n            ans += freq[key]\\n            freq[key] += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for x, y in dominoes:\\n            if x > y: x, y = y, x\\n            freq[10*x + y] += 1\\n        return sum(v*(v-1)//2 for v in freq.values())\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        count = Counter((lambda x,y: 10*x+y)(*sorted(d)) for d in dominoes)\\n        return sum(v*(v-1)//2 for v in count.values())\\n```\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0 \\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            ans += freq[x, y]\\n            if x != y: ans += freq[y, x]\\n            freq[x, y] += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 389413,
                "title": "simple-c-solution",
                "content": "```\\nint cmpfunc (const void * a, const void * b)\\n{\\n   return ( *(int*)a - *(int*)b );\\n}\\nint numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    int cnt=1,total=0;\\n    int *arr=malloc(sizeof(int)*dominoesSize);\\n    for(int i=0;i<dominoesSize;i++)\\n    {\\n        if(dominoes[i][0]<dominoes[i][1])\\n            arr[i]=dominoes[i][0]*10+dominoes[i][1];\\n        else\\n            arr[i]=dominoes[i][1]*10+dominoes[i][0];\\n    }\\n    qsort(arr, dominoesSize, sizeof(int), cmpfunc);\\n    for(int i=0;i<dominoesSize-1;i++)\\n    {\\n        while(i+1<dominoesSize&&arr[i]==arr[i+1])\\n        {\\n            //printf(\"%d \",arr[i]);\\n            cnt++;\\n            i++;\\n        }\\n        total+=cnt*(cnt-1)/2;\\n        cnt=1;\\n    }\\n    return total;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint cmpfunc (const void * a, const void * b)\\n{\\n   return ( *(int*)a - *(int*)b );\\n}\\nint numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    int cnt=1,total=0;\\n    int *arr=malloc(sizeof(int)*dominoesSize);\\n    for(int i=0;i<dominoesSize;i++)\\n    {\\n        if(dominoes[i][0]<dominoes[i][1])\\n            arr[i]=dominoes[i][0]*10+dominoes[i][1];\\n        else\\n            arr[i]=dominoes[i][1]*10+dominoes[i][0];\\n    }\\n    qsort(arr, dominoesSize, sizeof(int), cmpfunc);\\n    for(int i=0;i<dominoesSize-1;i++)\\n    {\\n        while(i+1<dominoesSize&&arr[i]==arr[i+1])\\n        {\\n            //printf(\"%d \",arr[i]);\\n            cnt++;\\n            i++;\\n        }\\n        total+=cnt*(cnt-1)/2;\\n        cnt=1;\\n    }\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375987,
                "title": "c-easy-solution-map-free-counting-combination-problem-beats-95-92-100",
                "content": "At first, count all the dominoes and initialize the 9x9 matrix, which had already been initialized with zeros, with the counted values.\\nIt is possible because of the second constraint that tells us the range of the values [1-9].\\nFor example, a domino numbered [1, 1] increases the value of matrix[0][0].\\n\\nNext, think about the possible cases.\\n(1) i == j (diagonal)\\n\\t- consider only 1 sub-case\\n(2) i != j\\n\\t- consider 3 sub-cases\\n\\nFinally, let\\'s count the number of answers.\\ncase (1):\\n\\nIf we have 6 for the matrix[0][0], the problem could be counted as drawing two balls from the pocket which has 6 balls numbered as index of [0][0] numbered domino.\\nIn this sense, 6C2 = 6 * 5 / 2 * 1 = 15 (answers) can be computed. (because swap doesn\\'t have any meanings, so the two conditions, (a==c and b==d), or (a==d and b==c), are counted as one..)\\n\\ncase(2):\\n\\nsub-case #1: matrix[i][j]\\nSAME AS case(1)\\n\\nsub-case #2: matrix[j][i]\\nSAME AS case(1)\\n\\nsub-case #3: matrix[i][j] and matrix[j][j] (*remind (a==c and b==d), or (a==d and b==c))\\n\\nIn this case, the problem could be counted as drawing two balls from two pockets which has matrix[i][j], matrix[j][i] balls each.\\n\\nSUM UP ALL THE ANSWERS FROM case(1) and case (2), then you can get the final result.\\n\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int mat[9][9] = {0,};\\n        int result = 0;\\n        \\n        // init matrix\\n        for(unsigned int i = 0; i < dominoes.size(); i++){\\n            mat[dominoes[i][0] - 1][dominoes[i][1] - 1]++;\\n        }\\n        \\n        // search till diagonal element\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j <= i; j++){\\n\\t\\t\\t\\t// diagonal element case\\n                if(i==j){\\n                    if(mat[i][j] > 1)\\n                       result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// only from [i, j] cases \\n                    if(mat[i][j] > 1)\\n                        result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                    // only from [j, i] cases\\n                    if(mat[j][i] > 1)    \\n                        result += (mat[j][i] * (mat[j][i] - 1)) / 2; // combination\\n                    // from both\\n                    result += (mat[i][j] * mat[j][i]); // permutation\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nTHANK YOU.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int mat[9][9] = {0,};\\n        int result = 0;\\n        \\n        // init matrix\\n        for(unsigned int i = 0; i < dominoes.size(); i++){\\n            mat[dominoes[i][0] - 1][dominoes[i][1] - 1]++;\\n        }\\n        \\n        // search till diagonal element\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j <= i; j++){\\n\\t\\t\\t\\t// diagonal element case\\n                if(i==j){\\n                    if(mat[i][j] > 1)\\n                       result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// only from [i, j] cases \\n                    if(mat[i][j] > 1)\\n                        result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                    // only from [j, i] cases\\n                    if(mat[j][i] > 1)    \\n                        result += (mat[j][i] * (mat[j][i] - 1)) / 2; // combination\\n                    // from both\\n                    result += (mat[i][j] * mat[j][i]); // permutation\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354445,
                "title": "share-my-python3-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        if not dominoes:\\n            return 0\\n        res = 0\\n        help_map = {}\\n        for x, y in dominoes:\\n            if x > y:\\n                x, y = y, x\\n            temp = (x, y)\\n            if temp in help_map:\\n                res += help_map[temp]\\n                help_map[temp] += 1\\n            else:\\n                help_map[temp] = 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        if not dominoes:\\n            return 0\\n        res = 0\\n        help_map = {}\\n        for x, y in dominoes:\\n            if x > y:\\n                x, y = y, x\\n            temp = (x, y)\\n            if temp in help_map:\\n                res += help_map[temp]\\n                help_map[temp] += 1\\n            else:\\n                help_map[temp] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340894,
                "title": "js-o-n-time-and-o-1-space",
                "content": "```\\nconst numEquivDominoPairs = dominoes => {\\n    let occur = Array.from(Array(10), () => Array(10).fill(0));\\n    \\n    for (let [a, b] of dominoes) {\\n        let min = Math.min(a, b);\\n        let max = Math.max(a, b);\\n        \\n        occur[min][max] += 1;\\n    }\\n    \\n    let cnt = 0;\\n    for (let i = 0; i <= 9; i++) {\\n        for (let j = 0; j <= 9; j++) {\\n            let o = Math.max(0, occur[i][j] - 1);        \\n            cnt += (o * (o + 1)) / 2;\\n        }\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numEquivDominoPairs = dominoes => {\\n    let occur = Array.from(Array(10), () => Array(10).fill(0));\\n    \\n    for (let [a, b] of dominoes) {\\n        let min = Math.min(a, b);\\n        let max = Math.max(a, b);\\n        \\n        occur[min][max] += 1;\\n    }\\n    \\n    let cnt = 0;\\n    for (let i = 0; i <= 9; i++) {\\n        for (let j = 0; j <= 9; j++) {\\n            let o = Math.max(0, occur[i][j] - 1);        \\n            cnt += (o * (o + 1)) / 2;\\n        }\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340372,
                "title": "javascript-solution-with-explanation",
                "content": "2 steps:\\n1. create a hashmap to record how many times each domino appears\\n2. if n dominos (n>1), how many combinations can they make? use `n*(n-1)/2)`\\n\\n```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = {};\\n    dominoes.forEach(p => {\\n        const [s,b] = p.sort();\\n        const n = s*10 + b;\\n        if(!map[n]) map[n] = 0;\\n        map[n]++;\\n    });\\n    \\n    return Object.values(map).reduce((res, ct) => res += ct>1 ? ct*(ct-1)/2 : 0, 0);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = {};\\n    dominoes.forEach(p => {\\n        const [s,b] = p.sort();\\n        const n = s*10 + b;\\n        if(!map[n]) map[n] = 0;\\n        map[n]++;\\n    });\\n    \\n    return Object.values(map).reduce((res, ct) => res += ct>1 ? ct*(ct-1)/2 : 0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340322,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            StringBuilder sb = new StringBuilder();\\n            if (domino[0] < domino[1]) {\\n                sb.append(domino[0] + \",\" + domino[1]);\\n            } else {\\n                sb.append(domino[1] + \",\" + domino[0]);\\n            }\\n            if (map.containsKey(sb.toString())) res += map.get(sb.toString());\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            StringBuilder sb = new StringBuilder();\\n            if (domino[0] < domino[1]) {\\n                sb.append(domino[0] + \",\" + domino[1]);\\n            } else {\\n                sb.append(domino[1] + \",\" + domino[0]);\\n            }\\n            if (map.containsKey(sb.toString())) res += map.get(sb.toString());\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340009,
                "title": "java-simple-with-combination",
                "content": "1) To make unique key and avoid dublication with keys \\nhave done this\\n`(Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]))`\\n2) To get all Combination of Domino \\n` n!(r!(n\\u2212r)!)`\\nsince our r =2 always\\n`n*(n-1)/2`\\n\\n\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n\\t\\tfor(int[] d : dominoes){\\n\\t\\t\\tlong key = (Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]));\\n\\t\\t\\tif(!map.containsKey(key)){\\n\\t\\t\\t\\tmap.put(key, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(key, map.get(key) + 1);\\n\\t\\t}\\n\\t\\tint ret = 0;\\n\\t\\tfor(int v : map.values()){\\n\\t\\t\\tret += v*(v-1)/2;\\n\\t\\t}\\n\\t\\treturn ret;",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "1) To make unique key and avoid dublication with keys \\nhave done this\\n`(Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]))`\\n2) To get all Combination of Domino \\n` n!(r!(n\\u2212r)!)`\\nsince our r =2 always\\n`n*(n-1)/2`\\n\\n\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n\\t\\tfor(int[] d : dominoes){\\n\\t\\t\\tlong key = (Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]));\\n\\t\\t\\tif(!map.containsKey(key)){\\n\\t\\t\\t\\tmap.put(key, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(key, map.get(key) + 1);\\n\\t\\t}\\n\\t\\tint ret = 0;\\n\\t\\tfor(int v : map.values()){\\n\\t\\t\\tret += v*(v-1)/2;\\n\\t\\t}\\n\\t\\treturn ret;",
                "codeTag": "Unknown"
            },
            {
                "id": 3959061,
                "title": "2328-ms-in-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863991,
                "title": "java-solution-without-using-hashing-direct-solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n       for(int i=0;i<dominoes.length-1;i++){\\n           int one=dominoes[i][0];\\n           int second=dominoes[i][1];\\n           for(int j=i+1;j<dominoes.length;j++){\\n               int check1=dominoes[j][0];\\n               int check2=dominoes[j][1];\\n               if(one==check1){\\n                   if(second==check2){\\n                       count+=1;\\n                   }\\n               }\\n               else if(one==check2){\\n                   if(second==check1){\\n                       count+=1;\\n                   }\\n               }\\n           }\\n       }\\nreturn count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n       for(int i=0;i<dominoes.length-1;i++){\\n           int one=dominoes[i][0];\\n           int second=dominoes[i][1];\\n           for(int j=i+1;j<dominoes.length;j++){\\n               int check1=dominoes[j][0];\\n               int check2=dominoes[j][1];\\n               if(one==check1){\\n                   if(second==check2){\\n                       count+=1;\\n                   }\\n               }\\n               else if(one==check2){\\n                   if(second==check1){\\n                       count+=1;\\n                   }\\n               }\\n           }\\n       }\\nreturn count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788589,
                "title": "easy-c-solution-hash-table-approach-with-explanation-beats-90-in-both",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        for (auto& d : dominoes) {\\n            if (d[0] > d[1]) \\n                swap(d[0], d[1]); // We swap the numbers so that [1,2] and [2,1] can be counted together as [1,2]\\n            mp[{d[0], d[1]}]++;\\n        }\\n        int ans = 0;\\n        for (auto& m : mp)\\n            ans += m.second * (m.second - 1) / 2; // Formula for sum of first n-1 numbers\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        for (auto& d : dominoes) {\\n            if (d[0] > d[1]) \\n                swap(d[0], d[1]); // We swap the numbers so that [1,2] and [2,1] can be counted together as [1,2]\\n            mp[{d[0], d[1]}]++;\\n        }\\n        int ans = 0;\\n        for (auto& m : mp)\\n            ans += m.second * (m.second - 1) / 2; // Formula for sum of first n-1 numbers\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621111,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096524,
                "title": "easy-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641954,
                "title": "js-very-easy-solution-o-n-with-hashmap",
                "content": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let output = 0;\\n    const hashmap = new Map();\\n    \\n    for (let i = 0 ; i < dominoes.length; i++) {\\n        const key = dominoes[i].toString();\\n        const reverseKey = dominoes[i].reverse().toString();\\n\\n        output += (hashmap.get(key) || 0) + (hashmap.has(reverseKey) && key !== reverseKey ? hashmap.get(reverseKey) : 0);\\n        \\n        \\n        if (!hashmap.has(key)) {\\n            hashmap.set(key, 1);\\n        } else {\\n            hashmap.set(key, hashmap.get(key) + 1);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let output = 0;\\n    const hashmap = new Map();\\n    \\n    for (let i = 0 ; i < dominoes.length; i++) {\\n        const key = dominoes[i].toString();\\n        const reverseKey = dominoes[i].reverse().toString();\\n\\n        output += (hashmap.get(key) || 0) + (hashmap.has(reverseKey) && key !== reverseKey ? hashmap.get(reverseKey) : 0);\\n        \\n        \\n        if (!hashmap.has(key)) {\\n            hashmap.set(key, 1);\\n        } else {\\n            hashmap.set(key, hashmap.get(key) + 1);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2499940,
                "title": "c-solution-using-map",
                "content": "\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int , int> , int > m;\\n        int cnt = 0;\\n        for(vector v : dominoes){\\n            int a = v[0] ,b = v[1];\\n            if(a > b) swap(a , b);\\n            if(m[{a , b}]) cnt += m[{a , b}];\\n            m[{a , b}]++;\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int , int> , int > m;\\n        int cnt = 0;\\n        for(vector v : dominoes){\\n            int a = v[0] ,b = v[1];\\n            if(a > b) swap(a , b);\\n            if(m[{a , b}]) cnt += m[{a , b}];\\n            m[{a , b}]++;\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2191418,
                "title": "easy-to-uderstand-brute-force-c",
                "content": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0;\\n       for(int i=0;i<dominoes.size();i++)\\n           sort(dominoes[i].begin(),dominoes[i].end());\\n        map<vector<int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n            m[dominoes[i]]++;\\n        for(auto x:m)\\n            result+=x.second*(x.second-1)/2;\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0;\\n       for(int i=0;i<dominoes.size();i++)\\n           sort(dominoes[i].begin(),dominoes[i].end());\\n        map<vector<int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n            m[dominoes[i]]++;\\n        for(auto x:m)\\n            result+=x.second*(x.second-1)/2;\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2176290,
                "title": "o-n-time-o-1-space-python-easy",
                "content": "since l is 9*9 array only 81 bit space used\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        l=[[0]*9 for _ in range(10)]\\n        c=0\\n        for i in dominoes:\\n            if(i[0]<i[1]):\\n                c+=l[i[0]-1][i[1]-1]\\n                l[i[0]-1][i[1]-1]+=1\\n            else:\\n                c+=l[i[1]-1][i[0]-1]\\n                l[i[1]-1][i[0]-1]+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        l=[[0]*9 for _ in range(10)]\\n        c=0\\n        for i in dominoes:\\n            if(i[0]<i[1]):\\n                c+=l[i[0]-1][i[1]-1]\\n                l[i[0]-1][i[1]-1]+=1\\n            else:\\n                c+=l[i[1]-1][i[0]-1]\\n                l[i[1]-1][i[0]-1]+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158866,
                "title": "simple-python-solution",
                "content": "```\\nimport math\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            #Just to make everything equal and comparable\\n            if(tuple(i) in d.keys()):   #In python, lists are unhashable so converted the list into tuples\\n                d[tuple(i)]+=1\\n            else:\\n                d[tuple(i)]=1\\n        count=0\\n        for x,y in d.items():\\n            if(y>1):\\n\\t\\t\\t\\tcount+=y*(y-1)//2        #To check the number of pairs, if 2 elements pairs is 1,if 3 pair is 3 and so                                                                     on.....formula is n*n-1/2\\n        return count\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            #Just to make everything equal and comparable\\n            if(tuple(i) in d.keys()):   #In python, lists are unhashable so converted the list into tuples\\n                d[tuple(i)]+=1\\n            else:\\n                d[tuple(i)]=1\\n        count=0\\n        for x,y in d.items():\\n            if(y>1):\\n\\t\\t\\t\\tcount+=y*(y-1)//2        #To check the number of pairs, if 2 elements pairs is 1,if 3 pair is 3 and so                                                                     on.....formula is n*n-1/2\\n        return count\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136036,
                "title": "c-solution-based-on-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> records;\\n        for (int i = 0; i < dominoes.size(); i++){\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            if (records.count({a, b}) == 0){\\n                records.insert({{a, b}, 1});\\n            }\\n            else{\\n                records[{a, b}]++;\\n            }\\n        }\\n        int result = 0;\\n        for (auto it=records.begin(); it!=records.end(); it++){\\n            // it->second\\n            int n = it->second;\\n            result += (n - 1) * n / 2;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> records;\\n        for (int i = 0; i < dominoes.size(); i++){\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            if (records.count({a, b}) == 0){\\n                records.insert({{a, b}, 1});\\n            }\\n            else{\\n                records[{a, b}]++;\\n            }\\n        }\\n        int result = 0;\\n        for (auto it=records.begin(); it!=records.end(); it++){\\n            // it->second\\n            int n = it->second;\\n            result += (n - 1) * n / 2;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081480,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] mat = new int[9][9];\\n        \\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]!=dominoes[i][1])\\n            {\\n            mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            mat[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n            }\\n            else\\n            {\\n                mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }\\n        int c=0;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=i;j<9;j++)\\n            {\\n                c+=sum(mat[i][j]-1);\\n            }\\n        }\\n        return c;\\n    }\\n    \\n    private int sum(int n)\\n    {\\n       return (n*(n+1))/2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] mat = new int[9][9];\\n        \\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]!=dominoes[i][1])\\n            {\\n            mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            mat[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2013314,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bef0b639-52a1-49f5-9ba5-72db5f7e41c7_1651830320.6071334.png)\\n\\n\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        d = collections.Counter(map(frozenset, dominoes))\\n        return sum(math.comb(v, 2) for v in d.values())",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bef0b639-52a1-49f5-9ba5-72db5f7e41c7_1651830320.6071334.png)\\n\\n\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        d = collections.Counter(map(frozenset, dominoes))\\n        return sum(math.comb(v, 2) for v in d.values())",
                "codeTag": "Python3"
            },
            {
                "id": 2001242,
                "title": "java-5-lines-of-code-faster-than-99-19",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tint[] counts = new int[100];\\n\\tint ans = 0;\\n\\tfor (int[] d : dominoes)\\n\\t\\tans += counts[Math.min(d[0], d[1])*10 + Math.max(d[0], d[1])]++;\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tint[] counts = new int[100];\\n\\tint ans = 0;\\n\\tfor (int[] d : dominoes)\\n\\t\\tans += counts[Math.min(d[0], d[1])*10 + Math.max(d[0], d[1])]++;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937753,
                "title": "c",
                "content": "```\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        List<string> temp = new List<string>();\\n\\n        for(int i=0; i< dominoes.Length; i++)\\n        {\\n            Array.Sort(dominoes[i]);\\n            temp.Add(string.Join(\"\", dominoes[i]));\\n        }\\n\\n        return temp.GroupBy(x => x).Where(x => x.Count() != 1).Select( x=>x.Count() * (x.Count() - 1) / 2 ).Sum();\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        List<string> temp = new List<string>();\\n\\n        for(int i=0; i< dominoes.Length; i++)\\n        {\\n            Array.Sort(dominoes[i]);\\n            temp.Add(string.Join(\"\", dominoes[i]));\\n        }\\n\\n        return temp.GroupBy(x => x).Where(x => x.Count() != 1).Select( x=>x.Count() * (x.Count() - 1) / 2 ).Sum();\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1901650,
                "title": "java-2ms-math-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Brute force cannot be used because of the set size.\\n        2. Traverse the dominos and group & count them by min-max value.\\n           As pieces can be from 1 to 9, means their groups will be from 11 to 99.\\n            eg: [1,2] will be the same as [2,1]. Their value is 10 * (min(1,2)) + max(1,2)\\n                => 10 * 1 + 2 = 12.\\n            so pieces[12]++;\\n        3. After finishing traversing, iterate over the counted pieces and if the count is\\n          > 1, calculate the combinations of X by 2.\\n        4. The formula is n!/ (k! * (n-k)!)\\n           As n! can be very large, use the short version of it; (n * (n-1)) / 2. EG n= 40\\n           Eg:  40!         simplify this(divide by 38!) 39 * 40\\n              --------                                  ---------   \\n               2! * (38!)                                   2\\n        5. Return the total result      \\n    */\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] pieces = new int[100];\\n        for (int[] domino : dominoes) {\\n            pieces[10 * Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1])]++;\\n        }\\n        int pairs = 0;\\n        for (int i = 11; i <= 99; i++) {\\n            if (pieces[i] > 1) {\\n                pairs += getCombinations(pieces[i]);\\n            }\\n        }\\n        \\n        return pairs;    \\n    }\\n    \\n    private int getCombinations(int n) {\\n        return (n * (n-1)) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Brute force cannot be used because of the set size.\\n        2. Traverse the dominos and group & count them by min-max value.\\n           As pieces can be from 1 to 9, means their groups will be from 11 to 99.\\n            eg: [1,2] will be the same as [2,1]. Their value is 10 * (min(1,2)) + max(1,2)\\n                => 10 * 1 + 2 = 12.\\n            so pieces[12]++;\\n        3. After finishing traversing, iterate over the counted pieces and if the count is\\n          > 1, calculate the combinations of X by 2.\\n        4. The formula is n!/ (k! * (n-k)!)\\n           As n! can be very large, use the short version of it; (n * (n-1)) / 2. EG n= 40\\n           Eg:  40!         simplify this(divide by 38!) 39 * 40\\n              --------                                  ---------   \\n               2! * (38!)                                   2\\n        5. Return the total result      \\n    */\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] pieces = new int[100];\\n        for (int[] domino : dominoes) {\\n            pieces[10 * Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1])]++;\\n        }\\n        int pairs = 0;\\n        for (int i = 11; i <= 99; i++) {\\n            if (pieces[i] > 1) {\\n                pairs += getCombinations(pieces[i]);\\n            }\\n        }\\n        \\n        return pairs;    \\n    }\\n    \\n    private int getCombinations(int n) {\\n        return (n * (n-1)) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881671,
                "title": "c-java-dictionary-hashmap-solution",
                "content": "**Implementation**\\n* C#\\n```\\npublic class Solution {\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        if(dominoes == null || dominoes.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int res = 0;\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n\\n        foreach(var pair in dominoes)\\n        {\\n            string key = Math.Min(pair[0], pair[1]) + \"-\" + Math.Max(pair[0], pair[1]);  \\n            int cnt = dic.GetValueOrDefault(key,0);\\n            res += cnt;\\n            dic[key] = cnt + 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n* Java\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<String,Integer> map = new HashMap<String,Integer>();\\n        \\n        int res = 0; \\n        for(var pair : dominoes)\\n        {\\n            String key = Math.min(pair[0], pair[1]) + \"-\" + Math.max(pair[0], pair[1]);  \\n            int cnt = map.getOrDefault(key, 0);\\n            res += cnt;\\n            map.put(key, cnt + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        if(dominoes == null || dominoes.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int res = 0;\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n\\n        foreach(var pair in dominoes)\\n        {\\n            string key = Math.Min(pair[0], pair[1]) + \"-\" + Math.Max(pair[0], pair[1]);  \\n            int cnt = dic.GetValueOrDefault(key,0);\\n            res += cnt;\\n            dic[key] = cnt + 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<String,Integer> map = new HashMap<String,Integer>();\\n        \\n        int res = 0; \\n        for(var pair : dominoes)\\n        {\\n            String key = Math.min(pair[0], pair[1]) + \"-\" + Math.max(pair[0], pair[1]);  \\n            int cnt = map.getOrDefault(key, 0);\\n            res += cnt;\\n            map.put(key, cnt + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833075,
                "title": "faster-than-89-memory-usage-less-than-90-c-solution",
                "content": "```\\n int numEquivDominoPairs(vector<vector<int>>& d) {\\n        map<pair<int,int>,int> m;\\n        map<pair<int,int>,int>::iterator itr;\\n        int c=0;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            pair<int,int> p;\\n           p.first=min(d[i][0],d[i][1]);\\n            p.second=max(d[i][1],d[i][0]);\\n            m[p]++;\\n                \\n        }\\n        for(itr=m.begin();itr!=m.end();itr++)\\n        {\\n            int n=itr->second*(itr->second-1);\\n            n=n/2;\\n            c+=n;\\n        }\\n        return c;\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int numEquivDominoPairs(vector<vector<int>>& d) {\\n        map<pair<int,int>,int> m;\\n        map<pair<int,int>,int>::iterator itr;\\n        int c=0;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            pair<int,int> p;\\n           p.first=min(d[i][0],d[i][1]);\\n            p.second=max(d[i][1],d[i][0]);\\n            m[p]++;\\n                \\n        }\\n        for(itr=m.begin();itr!=m.end();itr++)\\n        {\\n            int n=itr->second*(itr->second-1);\\n            n=n/2;\\n            c+=n;\\n        }\\n        return c;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811069,
                "title": "3-lines-python-solution-75-faster-memory-less-than-60",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counter = defaultdict(int)\\n        for domino in dominoes: counter[tuple(sorted(domino))] +=1\\n        return sum([n*(n-1)//2 for n in counter.values()])\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counter = defaultdict(int)\\n        for domino in dominoes: counter[tuple(sorted(domino))] +=1\\n        return sum([n*(n-1)//2 for n in counter.values()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759360,
                "title": "java-3-liner-hashing-explained",
                "content": "**Idea:** Sort the dominoes and count the number of pairs using nC2 formula = n(n - 1) / 2\\n>**T/S:** O(n)/O(n), where n = size(dominoes)\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tfor (var domino : dominoes)\\n\\t\\tdominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t  (k, v) -> v == null ? 1 : v + 1);\\n\\tvar pairs = 0;\\n\\tfor (var count : dominoToCount.values())\\n\\t\\tpairs += count * (count - 1) / 2;\\n\\treturn pairs;\\n}\\n```\\n**Version 2:** 3 liner stream version\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tArrays.stream(dominoes)\\n\\t\\t  .forEach(domino -> dominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   (k, v) -> v == null ? 1 : v + 1));\\n\\treturn dominoToCount.values()\\n\\t\\t\\t\\t\\t\\t.stream()\\n\\t\\t\\t\\t\\t\\t.mapToInt(v -> v * (v - 1) / 2)\\n\\t\\t\\t\\t\\t\\t.sum();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tfor (var domino : dominoes)\\n\\t\\tdominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t  (k, v) -> v == null ? 1 : v + 1);\\n\\tvar pairs = 0;\\n\\tfor (var count : dominoToCount.values())\\n\\t\\tpairs += count * (count - 1) / 2;\\n\\treturn pairs;\\n}\\n```\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tArrays.stream(dominoes)\\n\\t\\t  .forEach(domino -> dominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   (k, v) -> v == null ? 1 : v + 1));\\n\\treturn dominoToCount.values()\\n\\t\\t\\t\\t\\t\\t.stream()\\n\\t\\t\\t\\t\\t\\t.mapToInt(v -> v * (v - 1) / 2)\\n\\t\\t\\t\\t\\t\\t.sum();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1722329,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int n=d.size();\\n        map<vector<int>,int> freq;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> ele=d[i];\\n            if(ele[0]<ele[1])\\n            {\\n                swap(ele[0],ele[1]);\\n            }\\n            freq[ele]++;\\n        }\\n        int ans=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second>1)\\n            {\\n                int x=pr.second;\\n                ans+=(x*(x-1)/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int n=d.size();\\n        map<vector<int>,int> freq;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> ele=d[i];\\n            if(ele[0]<ele[1])\\n            {\\n                swap(ele[0],ele[1]);\\n            }\\n            freq[ele]++;\\n        }\\n        int ans=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second>1)\\n            {\\n                int x=pr.second;\\n                ans+=(x*(x-1)/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578746,
                "title": "c-90-time-91-space-map-sum-of-natural-numbers",
                "content": "```\\nint sum(int n){\\n\\treturn (n * (n+1)) / 2;\\n}\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& arr) {\\n        map<pair<int,int>,int>m;\\n        int summation=0;\\n        for(int i=0;i<arr.size();i++){\\n         \\n            int a=min(arr[i][0],arr[i][1]);\\n            int b=max(arr[i][0],arr[i][1]);\\n           m[{a,b}]++;  \\n        }\\n        for(auto i:m){\\n            summation+=sum(i.second-1);\\n        }\\n        return summation;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint sum(int n){\\n\\treturn (n * (n+1)) / 2;\\n}\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& arr) {\\n        map<pair<int,int>,int>m;\\n        int summation=0;\\n        for(int i=0;i<arr.size();i++){\\n         \\n            int a=min(arr[i][0],arr[i][1]);\\n            int b=max(arr[i][0],arr[i][1]);\\n           m[{a,b}]++;  \\n        }\\n        for(auto i:m){\\n            summation+=sum(i.second-1);\\n        }\\n        return summation;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532449,
                "title": "java-explained-2-solutions-o-n-hashmap-explained",
                "content": "Solution 1 : TLE\\n// TC: O(m * m), where m is dominoes.length\\n```\\n class Solution {\\n     public int numEquivDominoPairs(int[][] dominoes) {\\n         int res = 0;\\n        \\n         for(int i = 0; i < dominoes.length - 1; i++) {\\n             for(int j = i + 1; j < dominoes.length; j++) {\\n                 int[] dominoe1 = dominoes[i];\\n                 int[] dominoe2 = dominoes[j];\\n                \\n                 if(dominoe1[0] == dominoe2[0] && dominoe1[1] == dominoe2[1] || dominoe1[0] == dominoe2[1] && dominoe1[1] == dominoe2[0]) {\\n                     res++;\\n                 }\\n             }\\n         }\\n         return res;\\n     }\\n }\\n```\\n\\nSolution 2: \\n// TC: O(m), where m is dominoes.length\\n// SC: O(100), since max value can be 9, so max number that can be formed is 99\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>(); // this contains the number formed from each elements of a dominoe and its freq (num formed meaning, if domino[i] = [1,2], then we form number 12 ( min(donimoe[0], dominoe[1]) * 10 + max(donimoe[0], dominoe[1])) ) \\n                                                    // we are forming a number like this because we are interested in dominoes where either a == c && b == d OR a == d && b == c (so [1,2] & [2,1] will both form 12 as a number and then freq would be 2 for 12)\\n        \\n        for(int[] dominoe : dominoes) { // read all dominoe from dominoes and form the number out of its values and place in map and find freq of such numbers formed\\n            int number = Math.min(dominoe[0], dominoe[1]) * 10 + Math.max(dominoe[0], dominoe[1]);\\n            map.put(number, map.getOrDefault(number, 0) + 1);\\n        }\\n        \\n        for(int value : map.values()) {\\n            res += value * (value - 1)/2; // n(n-1)/2 find the total combinations from N elements\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n     public int numEquivDominoPairs(int[][] dominoes) {\\n         int res = 0;\\n        \\n         for(int i = 0; i < dominoes.length - 1; i++) {\\n             for(int j = i + 1; j < dominoes.length; j++) {\\n                 int[] dominoe1 = dominoes[i];\\n                 int[] dominoe2 = dominoes[j];\\n                \\n                 if(dominoe1[0] == dominoe2[0] && dominoe1[1] == dominoe2[1] || dominoe1[0] == dominoe2[1] && dominoe1[1] == dominoe2[0]) {\\n                     res++;\\n                 }\\n             }\\n         }\\n         return res;\\n     }\\n }\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>(); // this contains the number formed from each elements of a dominoe and its freq (num formed meaning, if domino[i] = [1,2], then we form number 12 ( min(donimoe[0], dominoe[1]) * 10 + max(donimoe[0], dominoe[1])) ) \\n                                                    // we are forming a number like this because we are interested in dominoes where either a == c && b == d OR a == d && b == c (so [1,2] & [2,1] will both form 12 as a number and then freq would be 2 for 12)\\n        \\n        for(int[] dominoe : dominoes) { // read all dominoe from dominoes and form the number out of its values and place in map and find freq of such numbers formed\\n            int number = Math.min(dominoe[0], dominoe[1]) * 10 + Math.max(dominoe[0], dominoe[1]);\\n            map.put(number, map.getOrDefault(number, 0) + 1);\\n        }\\n        \\n        for(int value : map.values()) {\\n            res += value * (value - 1)/2; // n(n-1)/2 find the total combinations from N elements\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517620,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut res = 0;\\n        let mut table = [[0; 9]; 9];\\n        let combinations = |n: i32| -> i32 { (n - 1) * n / 2 };\\n\\n        // construct an upper triangular matrix\\n        dominoes.iter().for_each(|d| {\\n            let (row, col) = match (d[0] - 1, d[1] - 1) {\\n                (a, b) if a < b => (a, b),\\n                (a, b) => (b, a),\\n            };\\n            table[row as usize][col as usize] += 1;\\n        });\\n\\n        // check the elements above the main diagonal of the matrix\\n        for (start_col, row) in table.iter().enumerate() {\\n            for &num in row[start_col..].iter().filter(|&&num| num > 1) {\\n                res += combinations(num);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Combinatorics"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut res = 0;\\n        let mut table = [[0; 9]; 9];\\n        let combinations = |n: i32| -> i32 { (n - 1) * n / 2 };\\n\\n        // construct an upper triangular matrix\\n        dominoes.iter().for_each(|d| {\\n            let (row, col) = match (d[0] - 1, d[1] - 1) {\\n                (a, b) if a < b => (a, b),\\n                (a, b) => (b, a),\\n            };\\n            table[row as usize][col as usize] += 1;\\n        });\\n\\n        // check the elements above the main diagonal of the matrix\\n        for (start_col, row) in table.iter().enumerate() {\\n            for &num in row[start_col..].iter().filter(|&&num| num > 1) {\\n                res += combinations(num);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439836,
                "title": "python3-nice-hack-to-use-dictionary-faster-than-94",
                "content": "![image](https://assets.leetcode.com/users/images/1095d3ee-7b9e-4bc0-b904-5647a5754eec_1630555519.8157907.png)\\n\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        d, c = dict(), 0\\n        for i in dominoes:\\n            if i[0] > i[1]:\\n                i[0], i[1] = i[1], i[0]\\n\\n            if (i[0], i[1]) not in d:\\n                d[(i[0], i[1])] = 1\\n            else:\\n                d[(i[0], i[1])] += 1\\n\\n        for j in d:\\n            if d[j] > 1:\\n                c += d[j] * (d[j] - 1) // 2\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        d, c = dict(), 0\\n        for i in dominoes:\\n            if i[0] > i[1]:\\n                i[0], i[1] = i[1], i[0]\\n\\n            if (i[0], i[1]) not in d:\\n                d[(i[0], i[1])] = 1\\n            else:\\n                d[(i[0], i[1])] += 1\\n\\n        for j in d:\\n            if d[j] > 1:\\n                c += d[j] * (d[j] - 1) // 2\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408737,
                "title": "python-beats-97-simple",
                "content": "Just count how many pairs, then and add them. During counting, make sure swap the smaller one as first.\\n\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        pairs = defaultdict(int)\\n        for i, j in dominoes:\\n            s = (i, j) if i <= j else (j, i)\\n            pairs[s] += 1\\n        \\n        ans = 0\\n        for pair in pairs:\\n            if pairs[pair] > 1:\\n                ans += (pairs[pair] * (pairs[pair] - 1)) // 2\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        pairs = defaultdict(int)\\n        for i, j in dominoes:\\n            s = (i, j) if i <= j else (j, i)\\n            pairs[s] += 1\\n        \\n        ans = 0\\n        for pair in pairs:\\n            if pairs[pair] > 1:\\n                ans += (pairs[pair] * (pairs[pair] - 1)) // 2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386655,
                "title": "faster-than-97-python",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        t = [tuple(sorted(x)) for x in dominoes ]\\n        dic = dict(collections.Counter(t))\\n        count = 0\\n        for key in dic :\\n            count += (dic[key]-1)*(dic[key])//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        t = [tuple(sorted(x)) for x in dominoes ]\\n        dic = dict(collections.Counter(t))\\n        count = 0\\n        for key in dic :\\n            count += (dic[key]-1)*(dic[key])//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383642,
                "title": "java-solution-beats-97-runtime",
                "content": "We use the fact that the dominoes have values in the set [1,9] and create a 2-dimensional array to store all dominoes that we find (making sure that we add values both directions - *corner case*: indices need to be different so that we don\\'t count a domino twice). For example, a domino (1,2) we will increase the values in our matrix at indexes (1,2) and (2,1). \\n\\nAfter passing through all dominoes, we use all values above the first diagonal and calculate a Gauss sum for each element. For example, if the value in the matrix is 5, that means that we found 5 identical dominoes, and that makes the a total of (4 * 5 / 2 = 10) identical pairs.  \\n\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\t// I used len 10 so that I don\\'t have to use mat[pair[0]-1,pair[1]-1]\\n        int len = 10;\\n        int[][] mat = new int[len][len];\\n        int count = 0;\\n        for (int[] pair: dominoes) {\\n            mat[pair[0]][pair[1]]++;\\n            if (pair[0] != pair[1])\\n                mat[pair[1]][pair[0]]++;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i; j < len; j++) {\\n                int current = mat[i][j];\\n                count += (current * (current - 1)) / 2;\\n            }\\n        } \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\t// I used len 10 so that I don\\'t have to use mat[pair[0]-1,pair[1]-1]\\n        int len = 10;\\n        int[][] mat = new int[len][len];\\n        int count = 0;\\n        for (int[] pair: dominoes) {\\n            mat[pair[0]][pair[1]]++;\\n            if (pair[0] != pair[1])\\n                mat[pair[1]][pair[0]]++;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i; j < len; j++) {\\n                int current = mat[i][j];\\n                count += (current * (current - 1)) / 2;\\n            }\\n        } \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355610,
                "title": "go",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    dict := make(map[[2]int]int)\\n    for _, v := range dominoes {\\n        if v[0] <= v[1] {\\n            dict[[2]int{v[0], v[1]}]++\\n        } else {\\n            dict[[2]int{v[1], v[0]}]++\\n        }\\n    }\\n    res := 0\\n    for _, v := range dict {\\n        res += v * (v - 1) / 2\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    dict := make(map[[2]int]int)\\n    for _, v := range dominoes {\\n        if v[0] <= v[1] {\\n            dict[[2]int{v[0], v[1]}]++\\n        } else {\\n            dict[[2]int{v[1], v[0]}]++\\n        }\\n    }\\n    res := 0\\n    for _, v := range dict {\\n        res += v * (v - 1) / 2\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1301280,
                "title": "java-solution-bitwise",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tMap<Integer, Integer> m = new HashMap<>();\\n\\tint n = dominoes.length;\\n\\tint c = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint mask = 0;\\n\\t\\tmask |= 1 << dominoes[i][0];\\n\\t\\tmask |= 1 << dominoes[i][1];\\n\\t\\tif (!m.containsKey(mask)) {\\n\\t\\t\\tm.put(mask, 1);\\n\\t\\t} else {\\n\\t\\t\\tc += m.get(mask);\\n\\t\\t\\tm.put(mask, m.get(mask) + 1);\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tMap<Integer, Integer> m = new HashMap<>();\\n\\tint n = dominoes.length;\\n\\tint c = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint mask = 0;\\n\\t\\tmask |= 1 << dominoes[i][0];\\n\\t\\tmask |= 1 << dominoes[i][1];\\n\\t\\tif (!m.containsKey(mask)) {\\n\\t\\t\\tm.put(mask, 1);\\n\\t\\t} else {\\n\\t\\t\\tc += m.get(mask);\\n\\t\\t\\tm.put(mask, m.get(mask) + 1);\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266661,
                "title": "using-hashmaps-and-swapping-c",
                "content": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> mp;\\n        for(int i = 0; i<dominoes.size(); i++){\\n            if(dominoes[i][0]>dominoes[i][1]){\\n                swap(dominoes[i][0],dominoes[i][1]);\\n            }\\n        }\\n        for(int i = 0; i<dominoes.size(); i++){\\n            mp[{dominoes[i][0],dominoes[i][1]}]++;\\n        }\\n        int answer = 0;\\n        \\n        for(auto i:mp){\\n            int n = i.second;\\n            answer+= (n*(n-1))/2;\\n        }\\n        return answer;\\n    }\\n};\\n\\n\\nFor any doubts, i will respond in comment section",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> mp;\\n        for(int i = 0; i<dominoes.size(); i++){\\n            if(dominoes[i][0]>dominoes[i][1]){\\n                swap(dominoes[i][0],dominoes[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1215378,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes   )\\n    {\\n       vector<vector<int> >vec(10,vector<int>(10,0));\\n       int ans=0;\\n       for(int i=0;i<dominoes.size();i++)\\n       {\\n           if(dominoes[i][0]<dominoes[i][1])\\n           {\\n               ans+=vec[dominoes[i][0]][dominoes[i][1]]++;\\n           }\\n           else\\n           {\\n                ans+=vec[dominoes[i][1]][dominoes[i][0]]++;\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes   )\\n    {\\n       vector<vector<int> >vec(10,vector<int>(10,0));\\n       int ans=0;\\n       for(int i=0;i<dominoes.size();i++)\\n       {\\n           if(dominoes[i][0]<dominoes[i][1])\\n           {\\n               ans+=vec[dominoes[i][0]][dominoes[i][1]]++;\\n           }\\n           else\\n           {\\n                ans+=vec[dominoes[i][1]][dominoes[i][0]]++;\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190899,
                "title": "a-very-simple-code-using-find-function-in-map-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tint n=dominoes.size();\\n\\t\\t\\tmap<pair<int,int>,int>mp;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint first=min(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tint second=max(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tif(mp.find({first,second})!=mp.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount+=mp[{first,second}];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmp[{first,second}]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tint n=dominoes.size();\\n\\t\\t\\tmap<pair<int,int>,int>mp;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint first=min(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tint second=max(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tif(mp.find({first,second}",
                "codeTag": "Java"
            },
            {
                "id": 1177977,
                "title": "c-99-faster-easy-simple",
                "content": "```class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        vector < int > arr(100,0);\\n        for(int i=0 ; i < dominoes.size();i++)\\n            arr[min(dominoes[i][0]*10+dominoes[i][1],dominoes[i][1]*10+dominoes[i][0])]++;\\n        int ans=0;\\n        for(int  i = 11 ; i < 100 ; i++)\\n        {\\n            if(arr[i]>1)\\n                ans=ans+arr[i]*(arr[i]-1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        vector < int > arr(100,0);\\n        for(int i=0 ; i < dominoes.size();i++)\\n            arr[min(dominoes[i][0]*10+dominoes[i][1],dominoes[i][1]*10+dominoes[i][0])]++;\\n        int ans=0;\\n        for(int  i = 11 ; i < 100 ; i++)\\n        {\\n            if(arr[i]>1)\\n                ans=ans+arr[i]*(arr[i]-1)/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1131593,
                "title": "optimized-and-very-easy-c-implementation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int c,ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            mat[mn][mx]++;\\n        }\\n        \\n        for(int i=1;i<10;i++){\\n            for(int j=i;j<10;j++){\\n                c = mat[i][j];\\n                ans+= c*(c-1)/2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n};\\n\\n\\nMore Optimized:\\n```\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            ans += mat[mn][mx]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int c,ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            mat[mn][mx]++;\\n        }\\n        \\n        for(int i=1;i<10;i++){\\n            for(int j=i;j<10;j++){\\n                c = mat[i][j];\\n                ans+= c*(c-1)/2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            ans += mat[mn][mx]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067503,
                "title": "python3-228ms-beating-93-70",
                "content": "I\\'m pretty sure this is optimal; I had three successive runs with difference of 4ms that made a big difference to the runtime percentile ranking:\\n\\n* 236 ms, faster than 78.18% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n* 232 ms, faster than 87.12% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n* 228 ms, faster than 93.70% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n\\nSo, I feel like I\\'m fighting leetcode noise, rather than the problem, now. \\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counts = collections.Counter(tuple(sorted(domino)) for domino in dominoes)\\n        return sum(c * (c-1) // 2 for c in counts.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counts = collections.Counter(tuple(sorted(domino)) for domino in dominoes)\\n        return sum(c * (c-1) // 2 for c in counts.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062742,
                "title": "python3-easy-o-n",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for p in dominoes:\\n            t = (min(p[0], p[1]), max(p[0], p[1]))\\n            if t in d:\\n                d[t] += 1\\n            else:\\n                d[t] = 1\\n        ans = 0\\n        for t in d:\\n            if d[t] > 1:\\n                ans += d[t]*(d[t]-1)//2\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for p in dominoes:\\n            t = (min(p[0], p[1]), max(p[0], p[1]))\\n            if t in d:\\n                d[t] += 1\\n            else:\\n                d[t] = 1\\n        ans = 0\\n        for t in d:\\n            if d[t] > 1:\\n                ans += d[t]*(d[t]-1)//2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052313,
                "title": "golang-brute-force-solution",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tcounter := 0\\n\\tfor i := 0; i < len(dominoes); i++ {\\n\\t\\tfor j := i + 1; j < len(dominoes); j++ {\\n\\t\\t\\tif (dominoes[i][0] == dominoes[j][0] && dominoes[i][1] == dominoes[j][1]) || \\n\\t\\t\\t\\t(dominoes[i][1] == dominoes[j][0] && dominoes[i][0] == dominoes[j][1]) {\\n\\t\\t\\t\\tcounter++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tcounter := 0\\n\\tfor i := 0; i < len(dominoes); i++ {\\n\\t\\tfor j := i + 1; j < len(dominoes); j++ {\\n\\t\\t\\tif (dominoes[i][0] == dominoes[j][0] && dominoes[i][1] == dominoes[j][1]) || \\n\\t\\t\\t\\t(dominoes[i][1] == dominoes[j][0] && dominoes[i][0] == dominoes[j][1]) {\\n\\t\\t\\t\\tcounter++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035877,
                "title": "c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        for(int i = 0; i < dominoes.size(); i++)\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n        sort(dominoes.begin(), dominoes.end());\\n        dominoes.push_back({0,0});\\n        int res = 0;\\n        int cnt = 1;\\n        vector<int> curr = dominoes[0];\\n        for(int i = 1; i < dominoes.size(); i++)\\n        {\\n            if(dominoes[i] == curr)\\n                cnt++;\\n            else\\n            {\\n                res += cnt * (cnt - 1);\\n                curr = dominoes[i];\\n                cnt = 1;\\n            }\\n        }\\n        return res / 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        for(int i = 0; i < dominoes.size(); i++)\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n        sort(dominoes.begin(), dominoes.end());\\n        dominoes.push_back({0,0});\\n        int res = 0;\\n        int cnt = 1;\\n        vector<int> curr = dominoes[0];\\n        for(int i = 1; i < dominoes.size(); i++)\\n        {\\n            if(dominoes[i] == curr)\\n                cnt++;\\n            else\\n            {\\n                res += cnt * (cnt - 1);\\n                curr = dominoes[i];\\n                cnt = 1;\\n            }\\n        }\\n        return res / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996225,
                "title": "java-beats-98-5-simple-20-lines-using-arrays-only",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        if (dominoes.length < 2) return 0;\\n        \\n        int[][] res = new int[10][10];\\n        \\n        int tCount=0,x,y,x1,y1;\\n            \\n        for (int i=0;i<dominoes.length;i++) {\\n            x = dominoes[i][0];\\n            y = dominoes[i][1];\\n            \\n            x1 = Math.min(x, y);\\n            y1 = Math.max(x, y);\\n            \\n            res[x1][y1] += 1;\\n        }\\n        \\n        for (int i=0;i<10;i++) {\\n            for (int j=0;j<10;j++) {\\n                int val = res[i][j];\\n                if (val > 0) {\\n                    tCount += val*(val-1)/2;\\n                }\\n            }\\n        }\\n        \\n        return tCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        if (dominoes.length < 2) return 0;\\n        \\n        int[][] res = new int[10][10];\\n        \\n        int tCount=0,x,y,x1,y1;\\n            \\n        for (int i=0;i<dominoes.length;i++) {\\n            x = dominoes[i][0];\\n            y = dominoes[i][1];\\n            \\n            x1 = Math.min(x, y);\\n            y1 = Math.max(x, y);\\n            \\n            res[x1][y1] += 1;\\n        }\\n        \\n        for (int i=0;i<10;i++) {\\n            for (int j=0;j<10;j++) {\\n                int val = res[i][j];\\n                if (val > 0) {\\n                    tCount += val*(val-1)/2;\\n                }\\n            }\\n        }\\n        \\n        return tCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977090,
                "title": "java-using-encoding",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes)\\n    {\\n        int arr[] = new int[100];\\n        int s=0;\\n        for(int[] a:dominoes)\\n        {\\n            arr[Math.min(a[0],a[1])*10+Math.max(a[0],a[1])]++;\\n        }\\n        for(int i:arr)\\n        {\\n            s+=(i*(i-1))/2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes)\\n    {\\n        int arr[] = new int[100];\\n        int s=0;\\n        for(int[] a:dominoes)\\n        {\\n            arr[Math.min(a[0],a[1])*10+Math.max(a[0],a[1])]++;\\n        }\\n        for(int i:arr)\\n        {\\n            s+=(i*(i-1))/2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948244,
                "title": "hashmap-javascript",
                "content": "```\\nconst numEquivDominoPairs = dominoes => {\\n  const seen = new Map();\\n  let count = 0;\\n  \\n  dominoes.forEach(domino => {\\n    domino.sort((a,b) => a-b);\\n    const str = domino.join(\\'\\')\\n    if(seen.get(str)){\\n      count += seen.get(str);\\n      seen.set(str, seen.get(str)+1)\\n    }\\n    else\\n      seen.set(str,1)\\n  })\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numEquivDominoPairs = dominoes => {\\n  const seen = new Map();\\n  let count = 0;\\n  \\n  dominoes.forEach(domino => {\\n    domino.sort((a,b) => a-b);\\n    const str = domino.join(\\'\\')\\n    if(seen.get(str)){\\n      count += seen.get(str);\\n      seen.set(str, seen.get(str)+1)\\n    }\\n    else\\n      seen.set(str,1)\\n  })\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946335,
                "title": "java-by-custom-range-class-you-will-learn-something-new-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\n    \\n    class Range {\\n        int a;\\n        int b;\\n        \\n        Range(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            if(this == o) return true;\\n            \\n            if(o == null || this.getClass() != o.getClass()) return false;\\n            \\n            Range r = (Range)o;\\n            \\n            if(r.a != this.a) return false;\\n            \\n            return r.b == this.b;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return (a * 31 + b);\\n        }\\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Range, Integer> hm = new HashMap<>();\\n        int cnt = 0;\\n        for(int i = 0; i < dominoes.length; i += 1) {\\n            int first = dominoes[i][0], second = dominoes[i][1];\\n            Range r = new Range(Math.min(first, second), Math.max(first, second));\\n            hm.put(r, hm.getOrDefault(r, 0) + 1);\\n        }\\n        \\n        /*\\n            If we know that a pair -> (a, b) comes how many times\\n            then it would becomes easy to find out how many \\n            distinct pairs can be made by suing frequency of pair (a, b).\\n            \\n            Num(dis_pairs) = freq * (freq - 1) / 2;\\n            \\n        */\\n        for(int freq : hm.values()) {\\n            cnt += (freq * (freq - 1) / 2);\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Range {\\n        int a;\\n        int b;\\n        \\n        Range(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            if(this == o) return true;\\n            \\n            if(o == null || this.getClass() != o.getClass()) return false;\\n            \\n            Range r = (Range)o;\\n            \\n            if(r.a != this.a) return false;\\n            \\n            return r.b == this.b;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return (a * 31 + b);\\n        }\\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Range, Integer> hm = new HashMap<>();\\n        int cnt = 0;\\n        for(int i = 0; i < dominoes.length; i += 1) {\\n            int first = dominoes[i][0], second = dominoes[i][1];\\n            Range r = new Range(Math.min(first, second), Math.max(first, second));\\n            hm.put(r, hm.getOrDefault(r, 0) + 1);\\n        }\\n        \\n        /*\\n            If we know that a pair -> (a, b) comes how many times\\n            then it would becomes easy to find out how many \\n            distinct pairs can be made by suing frequency of pair (a, b).\\n            \\n            Num(dis_pairs) = freq * (freq - 1) / 2;\\n            \\n        */\\n        for(int freq : hm.values()) {\\n            cnt += (freq * (freq - 1) / 2);\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944279,
                "title": "java-solution",
                "content": "```\\n    private int uniqueKey(int a, int b) {\\n        return a < b ? a * 10 + b : b * 10 + a;            \\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] countByKey = new int[1000];\\n        int result = 0;\\n        for(int[] domino: dominoes) {\\n            int key = uniqueKey(domino[0], domino[1]);\\n            result += countByKey[key]++;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int uniqueKey(int a, int b) {\\n        return a < b ? a * 10 + b : b * 10 + a;            \\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] countByKey = new int[1000];\\n        int result = 0;\\n        for(int[] domino: dominoes) {\\n            int key = uniqueKey(domino[0], domino[1]);\\n            result += countByKey[key]++;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906956,
                "title": "c-hash-table",
                "content": "```\\npublic int NumEquivDominoPairs2(int[][] dominoes)\\n{\\n\\tint[] arr = new int[100];\\n\\tforeach (var d in dominoes)\\n\\t{\\n\\t\\tint t = d[0] * 10 + d[1];\\n\\t\\tif (d[0] > d[1])\\n\\t\\t\\tt = d[1] * 10 + d[0];\\n\\t\\tarr[t]++;\\n\\t}\\n\\n\\tint res = 0;\\n\\tforeach (var a in arr)\\n\\t\\tres += a * (a - 1) / 2;\\n\\n\\treturn res;\\n}\\n```\\n`C#`",
                "solutionTags": [],
                "code": "```\\npublic int NumEquivDominoPairs2(int[][] dominoes)\\n{\\n\\tint[] arr = new int[100];\\n\\tforeach (var d in dominoes)\\n\\t{\\n\\t\\tint t = d[0] * 10 + d[1];\\n\\t\\tif (d[0] > d[1])\\n\\t\\t\\tt = d[1] * 10 + d[0];\\n\\t\\tarr[t]++;\\n\\t}\\n\\n\\tint res = 0;\\n\\tforeach (var a in arr)\\n\\t\\tres += a * (a - 1) / 2;\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881192,
                "title": "java-1ms-solution-beats-100-time-o-n-space-o-1-short-code-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int ans = 0;\\n        int[] bucket = new int[100];\\n        for (int[] domino : dominoes)\\n            bucket[domino[0] * 10 + domino[1]]++;\\n        int ten = 0, one = 0;\\n        for (int i = 11; i < 100; i++) {\\n            int k = bucket[i]; // for 11,22,33...99, add k*(k-1)/2\\n            ten = i / 10;\\n            one = i % 10;\\n            if (one > ten)\\n                k += bucket[one * 10 + ten]; // for bucket[12], k= bucket[12]+bucket[21], then add k*(k-1)/2\\n            else if (one < ten) // for bucket[21], ignore since already counted in bucket[12]\\n                continue;\\n            ans += k * (k - 1) / 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int ans = 0;\\n        int[] bucket = new int[100];\\n        for (int[] domino : dominoes)\\n            bucket[domino[0] * 10 + domino[1]]++;\\n        int ten = 0, one = 0;\\n        for (int i = 11; i < 100; i++) {\\n            int k = bucket[i]; // for 11,22,33...99, add k*(k-1)/2\\n            ten = i / 10;\\n            one = i % 10;\\n            if (one > ten)\\n                k += bucket[one * 10 + ten]; // for bucket[12], k= bucket[12]+bucket[21], then add k*(k-1)/2\\n            else if (one < ten) // for bucket[21], ignore since already counted in bucket[12]\\n                continue;\\n            ans += k * (k - 1) / 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867272,
                "title": "python3-no-dict-math-solution-100-220ms-100-22mb",
                "content": "**Fast Dictionary-Free Solution**\\n\\nWe keep track of how many times we encounter a domino (up to equivalence) by using an array to count the number of occurences and use an encoding for efficiency. As we count, we `pop` from `dominoes` to conserve space. Once we\\'ve counted everything, we use the well-known combinatorial fact that the number of unordered pairs that can be made from `n` objects is `n choose 2 =  n*(n-1)/2`. \\n\\n```python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\tcnt = [0]*73  # (Explanation for 73 in discussion below)\\n\\twhile dominoes: \\n\\t\\td = dominoes.pop()\\n\\t\\tcnt[9*max(d) - 8*min(d) - 1] += 1\\n\\treturn sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nHere we encode the domino  `d=[a,b]` as `E(a,b) = 9*max(a,b) - 8*min(a,b) - 1`.  This encoding is always symmetric and is collision-free whenever  `1 <= a,b <= 9` (which is the case for our dominoes). To see why this claim is true, first note that since `|a-b| = max(a,b) - min(a,b) ` we have\\n\\n```\\n9*|a-b| + min(a,b) - 1\\n= 9*(max(a,b)-min(a,b)) + min(a,b) - 1\\n= 9*max(a,b) - 8*min(a,b) - 1\\n= E(a,b)\\n```\\n\\nThis alternate expression  of `E(a,b)` makes it easier to see why there are no collisions. A quick mental check confirms that `min(a,b)-1` can only be 0,1,2,3,4,5,6,7,8. These are the possible remainders mod 9, thus \\n\\n``` python 3\\nE(a,b) % 9  = min(a,b) -1  # remainder of division by 9\\nE(a,b) // 9 = |a-b|  # division by 9 rounded down (quotient)\\n```\\n\\nSince `max(a,b) = min(a,b) + |a-b|` this let\\'s us undo the encoding as follows:\\n\\n``` python 3\\nmin(a,b) = 1 + E(a,b) % 9 \\nmax(a,b) = 1 + E(a,b) % 9 +  E(a,b)//9\\n```\\n\\nThus, given the encoding `E(a,b)`, we can recover `d=[a,b]` (up to equivalence) since we know the `min` and `max` elements. This means there are no collisions.\\n\\nFinally, it is worth noting that that the the smallest encoding is `0=E(1,1)` and the largest encoding is `72=E(1,9)`. Thus the minimum size for a contiguous array that can hold these values is one of size `73`. \\n\\n---\\n---\\n**Alternate (but less efficient) Encoding**\\nInstead of the above encoding, we could have tried something like  `F(a,b) = 10*max(a,b) + min(a,b)`. This is also collision free since we can take remainders and quotients like before to obtain the `max` and `min`. However, the smallest encoding is `11=F(1,1)` and the largest is `99=F(9,9)`. Thus we need at least `89` slots in the counting array to accomodate this encoding. \\n\\n--- \\n---\\n**Just for Fun: Minimizing Array Size**\\n\\nBasic combinatorics tells us that it should be possible to make the counting array even smaller since we know that there are exactly `9 choose 2 + 9= 9*8/2 + 9 = 45` possible dominos (up to equivalence). By making the encoding more complicated we can reflect this fact. However we will lose some performance due to the more complicated logic, so this is mostly just an interesting exercise. Not really useful for interviews.\\n\\nFirst, let\\'s determine where the `0`\\'s are in the array `cnt`. Then we can shift the nonzero entries around to fill up that empty space. We can write some quick code to generate all pairs and then place a `1` at the encoded index if that position is used and `0` if not. This allows us to see which indices are utilized and which aren\\'t. Printing these values shows us an interesting pattern. \\n\\n``` python 3\\n# Reading left-to-right, top-to-bottom, first index is 0, last index is 72\\n1, 1, 1, 1, 1, 1, 1, 1, 1, \\n1, 1, 1, 1, 1, 1, 1, 1, 0, \\n1, 1, 1, 1, 1, 1, 1, 0, 0, \\n1, 1, 1, 1, 1, 1, 0, 0, 0, \\n1, 1, 1, 1, 1, 0, 0, 0, 0, \\n1, 1, 1, 1, 0, 0, 0, 0, 0, \\n1, 1, 1, 0, 0, 0, 0, 0, 0,\\n1, 1, 0, 0, 0, 0, 0, 0, 0,\\n1\\n```\\n\\nOne approach to fix this is to shift all indices up by `1` then apply `% 73` to wrap things back around, and then reduce the array size to omit the trailing zeroes. Then we can shift by `2` and apply `% 66` and remove trailing zeros. Then shift by `3`, apply `% 60`, then truncate. Etc. This yields the following code:\\n\\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\t# Minimizing array size (Cyclic Shifting + Truncation via Modular Arithmetic)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d)\\n            d = d % 73 + 2\\n            d = d % 66 + 3\\n            d = d % 60 + 4\\n            d = d % 55 + 5\\n            d = d % 51 + 6\\n            d = d % 48 + 7\\n            d = d % 46\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nAnother approach is to manually move the value at `72` to `17`. Then move `63, 64` to `25, 26`. Then move `54,55,56` to `33,34,35`. Then finally move `45,46,47,48` to `41,42,43,44`. We code this in order that moves the most things first.\\n\\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # Minimizing array size (Manually moving the encoding to correct spot)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d) - 1\\n            if 44 < d < 49: d -= 4\\n            elif 53 < d < 57: d -= 21\\n            elif 62 < d < 65: d -= 38\\n            elif d == 72: d = 17\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nOn a final note, I find these two above approaches kinda messy. I think it would be very cool to see if there is a way to do the symmetric collision-free encoding with the minimum array size of `45` in a clean way. Please let me know in comments if you come up with one!\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\tcnt = [0]*73  # (Explanation for 73 in discussion below)\\n\\twhile dominoes: \\n\\t\\td = dominoes.pop()\\n\\t\\tcnt[9*max(d) - 8*min(d) - 1] += 1\\n\\treturn sum([n*(n-1)//2 for n in cnt])\\n```\n```\\n9*|a-b| + min(a,b) - 1\\n= 9*(max(a,b)-min(a,b)) + min(a,b) - 1\\n= 9*max(a,b) - 8*min(a,b) - 1\\n= E(a,b)\\n```\n``` python 3\\nE(a,b) % 9  = min(a,b) -1  # remainder of division by 9\\nE(a,b) // 9 = |a-b|  # division by 9 rounded down (quotient)\\n```\n``` python 3\\nmin(a,b) = 1 + E(a,b) % 9 \\nmax(a,b) = 1 + E(a,b) % 9 +  E(a,b)//9\\n```\n``` python 3\\n# Reading left-to-right, top-to-bottom, first index is 0, last index is 72\\n1, 1, 1, 1, 1, 1, 1, 1, 1, \\n1, 1, 1, 1, 1, 1, 1, 1, 0, \\n1, 1, 1, 1, 1, 1, 1, 0, 0, \\n1, 1, 1, 1, 1, 1, 0, 0, 0, \\n1, 1, 1, 1, 1, 0, 0, 0, 0, \\n1, 1, 1, 1, 0, 0, 0, 0, 0, \\n1, 1, 1, 0, 0, 0, 0, 0, 0,\\n1, 1, 0, 0, 0, 0, 0, 0, 0,\\n1\\n```\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\t# Minimizing array size (Cyclic Shifting + Truncation via Modular Arithmetic)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d)\\n            d = d % 73 + 2\\n            d = d % 66 + 3\\n            d = d % 60 + 4\\n            d = d % 55 + 5\\n            d = d % 51 + 6\\n            d = d % 48 + 7\\n            d = d % 46\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # Minimizing array size (Manually moving the encoding to correct spot)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d) - 1\\n            if 44 < d < 49: d -= 4\\n            elif 53 < d < 57: d -= 21\\n            elif 62 < d < 65: d -= 38\\n            elif d == 72: d = 17\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 863934,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes) {\\n        map<pair<int, int>, int> dp;\\n        for (int i = 0; i < dominoes.size(); ++i) {\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            pair<int, int> tmp(min(a, b), max(a, b));\\n            dp[tmp]++;\\n        }\\n        int ans = 0;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            ans += ((it->second) * (it->second - 1) / 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes) {\\n        map<pair<int, int>, int> dp;\\n        for (int i = 0; i < dominoes.size(); ++i) {\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            pair<int, int> tmp(min(a, b), max(a, b));\\n            dp[tmp]++;\\n        }\\n        int ans = 0;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            ans += ((it->second) * (it->second - 1) / 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861706,
                "title": "o-n-c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n  int cal(int n){\\n        return ((n*(n-1))/2);\\n    }\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n       map<pair<int, int>, int> s;  \\n        int cnt=0;\\n        for(int i=0;i<dominoes.size();i++)\\n            if(s.find({dominoes[i][0],dominoes[i][1]})!=s.end() )\\n            {\\n                s[{dominoes[i][0],dominoes[i][1]}]++;\\n                int n=s[{dominoes[i][0],dominoes[i][1]}];\\n                cnt=cnt-cal(n-1)+cal(n);\\n            }\\n            else if( s.find({dominoes[i][1],dominoes[i][0]})!=s.end()){\\n                  s[{dominoes[i][1],dominoes[i][0]}]++;\\n                int n= s[{dominoes[i][1],dominoes[i][0]}];\\n                 cnt=cnt-cal(n-1)+cal(n);\\n                \\n            }\\n            else\\n                  s[{dominoes[i][0],dominoes[i][1]}]++;\\n          return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int cal(int n){\\n        return ((n*(n-1))/2);\\n    }\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n       map<pair<int, int>, int> s;  \\n        int cnt=0;\\n        for(int i=0;i<dominoes.size();i++)\\n            if(s.find({dominoes[i][0],dominoes[i][1]})!=s.end() )\\n            {\\n                s[{dominoes[i][0],dominoes[i][1]}]++;\\n                int n=s[{dominoes[i][0],dominoes[i][1]}];\\n                cnt=cnt-cal(n-1)+cal(n);\\n            }\\n            else if( s.find({dominoes[i][1],dominoes[i][0]})!=s.end()){\\n                  s[{dominoes[i][1],dominoes[i][0]}]++;\\n                int n= s[{dominoes[i][1],dominoes[i][0]}];\\n                 cnt=cnt-cal(n-1)+cal(n);\\n                \\n            }\\n            else\\n                  s[{dominoes[i][0],dominoes[i][1]}]++;\\n          return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832888,
                "title": "python-3-use-dict",
                "content": "When the length of array is around 50k, it means we don\\'t get Memory Limit Exceeded, and can sacrefice space for speed (since it more often happens TLE for slow speed).\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for dom in dominoes:\\n            a, b = dom[0], dom[1]\\n            if a > b:\\n                a, b = b, a\\n            d[(a, b)] = d.get((a,b), 0) + 1\\n        \\n        res = 0\\n        for v in d.values():\\n            res += (v-1) * v / 2\\n                    \\n        return int(res)",
                "solutionTags": [],
                "code": "When the length of array is around 50k, it means we don\\'t get Memory Limit Exceeded, and can sacrefice space for speed (since it more often happens TLE for slow speed).\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for dom in dominoes:\\n            a, b = dom[0], dom[1]\\n            if a > b:\\n                a, b = b, a\\n            d[(a, b)] = d.get((a,b), 0) + 1\\n        \\n        res = 0\\n        for v in d.values():\\n            res += (v-1) * v / 2\\n                    \\n        return int(res)",
                "codeTag": "Java"
            },
            {
                "id": 822802,
                "title": "a-neat-math-based-solution-in-python",
                "content": "Convert the pairs into tuple keys in a dict. \\nif the count is more than 1, then its the number of occurrences\\nto find the number of pairs possible .. we just nC2 and add it our output.\\nIt took me 45 min to get to this solution.\\n\\n```\\nfrom math import comb\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        hdict = {}\\n        output = 0\\n                \\n        for val in dominoes:            \\n            s_val = tuple(sorted(val))\\n            if s_val in hdict:\\n                hdict[s_val] += 1\\n            else:\\n                hdict[s_val] = 1\\n        \\n        for k, v in hdict.items():\\n            \\n            if v > 1:\\n                output += comb(v, 2)\\n        \\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import comb\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        hdict = {}\\n        output = 0\\n                \\n        for val in dominoes:            \\n            s_val = tuple(sorted(val))\\n            if s_val in hdict:\\n                hdict[s_val] += 1\\n            else:\\n                hdict[s_val] = 1\\n        \\n        for k, v in hdict.items():\\n            \\n            if v > 1:\\n                output += comb(v, 2)\\n        \\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809986,
                "title": "python-3-dictionary-explanation",
                "content": "* For this question we want to keep a record of all the previous dominoes we\\'ve seen, and how many times we\\'ve seen them.\\n* We also want to consider equivalent dominoes under the same \\'count\\'\\n\\t* For example, the dominoes `(1, 2)` and `(2, 1)` should be considered as \\'seen\\' twice, since they are equivalent once rotated.\\n\\t* So the dictionary `dominoToCount` counts up how many matching dominoes we have seen.\\n* In order to pair up matching dominoes, we need some way of mapping dominoes like `(1, 2)` and `(2, 1)` into the same key.\\n\\t* For this we can use the `getKey` function that ensures that both map to the same value, we do this by using the smaller number as the first in the tuple.\\n\\t* So both `(1, 2)` and `(2, 1)` will be mapped to `(1, 2)`.\\n* As we iterate through `dominoes` we add to the running total `equivalentPairs` how many existing equivalent dominoes there are.\\n```\\nfrom typing import Tuple\\n\\nclass Solution:\\n    \\n    def getKey(self, a: int, b: int) -> Tuple[int, int]:\\n        return (a, b) if a < b else (b, a)\\n    \\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        equivalentPairs = 0\\n        dominoes = [tuple(domino) for domino in dominoes]\\n        dominoToCount = {}\\n        \\n        for a, b in dominoes:\\n            key = self.getKey(a, b)\\n            \\n            if key in dominoToCount:\\n                equivalentPairs += dominoToCount[key]\\n                dominoToCount[key] = dominoToCount[key] + 1\\n            else:\\n                dominoToCount[key] = 1\\n                \\n        return equivalentPairs\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import Tuple\\n\\nclass Solution:\\n    \\n    def getKey(self, a: int, b: int) -> Tuple[int, int]:\\n        return (a, b) if a < b else (b, a)\\n    \\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        equivalentPairs = 0\\n        dominoes = [tuple(domino) for domino in dominoes]\\n        dominoToCount = {}\\n        \\n        for a, b in dominoes:\\n            key = self.getKey(a, b)\\n            \\n            if key in dominoToCount:\\n                equivalentPairs += dominoToCount[key]\\n                dominoToCount[key] = dominoToCount[key] + 1\\n            else:\\n                dominoToCount[key] = 1\\n                \\n        return equivalentPairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801653,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int A[9][9];\\n    \\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        memset(A,0,sizeof A);\\n        for(int i = 0;i<dominoes.size();i++){\\n            if(dominoes[i][0]!=dominoes[i][1]){\\n            A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            A[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n                }\\n            else{\\n                A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }    \\n        \\n        int sum =0;\\n\\n        for(int i = 0;i<9;i++){\\n            for(int j = i;j<9;j++){\\n                    sum+=((A[i][j])*(A[i][j]-1))/2;\\n            }\\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int A[9][9];\\n    \\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        memset(A,0,sizeof A);\\n        for(int i = 0;i<dominoes.size();i++){\\n            if(dominoes[i][0]!=dominoes[i][1]){\\n            A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            A[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n                }\\n            else{\\n                A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }    \\n        \\n        int sum =0;\\n\\n        for(int i = 0;i<9;i++){\\n            for(int j = i;j<9;j++){\\n                    sum+=((A[i][j])*(A[i][j]-1))/2;\\n            }\\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727438,
                "title": "c-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& domino) {\\n        int ans=0;\\n        map<pair<int,int>, int> cnt;\\n        for(auto v : domino) {\\n            sort(v.begin(),v.end());\\n            auto p=make_pair(v[0],v[1]);\\n            cnt[p]++;\\n            if(cnt[p]==2) ans++;\\n            else if(cnt[p]>2) ans+=cnt[p]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& domino) {\\n        int ans=0;\\n        map<pair<int,int>, int> cnt;\\n        for(auto v : domino) {\\n            sort(v.begin(),v.end());\\n            auto p=make_pair(v[0],v[1]);\\n            cnt[p]++;\\n            if(cnt[p]==2) ans++;\\n            else if(cnt[p]>2) ans+=cnt[p]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678287,
                "title": "java-o-n-solution-with-o-1-space",
                "content": "It can be solved with HashMap. Iterate over array, sort domino pair, add count of such pairs in map to the answer and increase this counter.\\nI am using array `used` instead of map, because number of possible values is small. It increases performance a little bit\\n\\n```\\nclass Solution {\\n    private static final int MAXIMUM_DOMINO_VALUE = 9;\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int answer = 0;\\n        int[] used = new int[MAXIMUM_DOMINO_VALUE * MAXIMUM_DOMINO_VALUE];\\n        \\n        for (int[] domino : dominoes) {\\n            int smallerSide = (Math.min(domino[0], domino[1]) - 1) * MAXIMUM_DOMINO_VALUE;\\n            int biggerSide = (Math.max(domino[0], domino[1]) - 1);\\n            \\n            answer += used[smallerSide + biggerSide];\\n            used[smallerSide + biggerSide]++;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MAXIMUM_DOMINO_VALUE = 9;\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int answer = 0;\\n        int[] used = new int[MAXIMUM_DOMINO_VALUE * MAXIMUM_DOMINO_VALUE];\\n        \\n        for (int[] domino : dominoes) {\\n            int smallerSide = (Math.min(domino[0], domino[1]) - 1) * MAXIMUM_DOMINO_VALUE;\\n            int biggerSide = (Math.max(domino[0], domino[1]) - 1);\\n            \\n            answer += used[smallerSide + biggerSide];\\n            used[smallerSide + biggerSide]++;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660959,
                "title": "c-simple-3-line-solution",
                "content": "Run-time is `O(N)`, space is `O(1)`.\\n\\n```\\nclass Solution {\\npublic:\\n    static int numEquivDominoPairs(const vector<vector<int>>& dominoes) {\\n        int m[100]{0}, count{0};\\n        for(const auto &d: dominoes) count += m[min(d[0], d[1]) + 10*max(d[0], d[1])]++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int numEquivDominoPairs(const vector<vector<int>>& dominoes) {\\n        int m[100]{0}, count{0};\\n        for(const auto &d: dominoes) count += m[min(d[0], d[1]) + 10*max(d[0], d[1])]++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657664,
                "title": "java-solutions-o-n-time-o-n-space",
                "content": "Basically we need a way to serialize each domino (that is we need a way to check that [1,2] = [2, 1]). In my case I chose to get a number representation, so domino [1,2] and [2,1] would both have a number representation of 12. Then we keep track of frequency of the same dominoes using a hashmap. I just want to point out that the brute force solution would be simply using 2 for loops.\\n\\nUnfortunatley this is just one of those questions where you either know how to solve it, or you don\\'t. I found it very hard to logic my way through.\\n\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            Integer numRepresentation = getNumRepresentation(domino);\\n            if (map.containsKey(numRepresentation)) {\\n                int oldCount = map.get(numRepresentation);\\n                map.put(numRepresentation, oldCount + 1);\\n            }\\n            else map.put(numRepresentation, 0);\\n            count += map.get(numRepresentation);            \\n        }\\n        \\n        return count;\\n    }\\n    \\n    private Integer getNumRepresentation(int[] domino) {\\n        boolean isFirstNumSmaller = domino[0] < domino[1];\\n        return (isFirstNumberSmaller) domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            Integer numRepresentation = getNumRepresentation(domino);\\n            if (map.containsKey(numRepresentation)) {\\n                int oldCount = map.get(numRepresentation);\\n                map.put(numRepresentation, oldCount + 1);\\n            }\\n            else map.put(numRepresentation, 0);\\n            count += map.get(numRepresentation);            \\n        }\\n        \\n        return count;\\n    }\\n    \\n    private Integer getNumRepresentation(int[] domino) {\\n        boolean isFirstNumSmaller = domino[0] < domino[1];\\n        return (isFirstNumberSmaller) domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654656,
                "title": "java-6ms-beats-80-18-superb-oop-plus-override-hashcode-and-equals",
                "content": "```\\nclass Solution {\\n  \\n  public int numEquivDominoPairs(int[][] dominoes) {\\n    \\n    /*\\n    Runtime: 6 ms, faster than 80.81% of Java online submissions for Number of Equivalent Domino Pairs.\\n    Memory Usage: 48.3 MB, less than 100.00% of Java online submissions for Number of Equivalent Domino Pairs.\\n    */\\n    \\n    Map<Domino, Integer> dominoFT = new HashMap<Domino, Integer>();// FT = frequency table\\n    \\n    // populate HashMap with dominoes\\n    for (int[] d : dominoes) {\\n      dominoFT.merge(new Domino(d[0], d[1]), 1, Integer::sum);// nice little merge/sum trick useful for frequency counting...\\n    }\\n    \\n    int quantityOfPairs = 0;\\n    \\n    for (int i : dominoFT.values()) {// all we need are the values, so no need for entrySet() or keySet()\\n      if (i > 1) {\\n        // LeetCode\\'s test cases require:\\n        // 2 matching dominoes counts as 1 pair, BUT!...\\n        // 3 matching dominoes counts as 3 pairs (i.e., it wants handshake formula)\\n        quantityOfPairs += handshakeNumber(i);   \\n      }\\n    }\\n    \\n    return quantityOfPairs;\\n  }\\n  \\n  private int handshakeNumber(int n) {\\n    --n;\\n    return n * (n + 1) / 2;\\n  }\\n  \\n  private class Domino {\\n    \\n    // fields\\n    int smallSpots;\\n    int bigSpots;\\n    \\n    // constructor\\n    Domino (int a, int b) {\\n      if (a < b) {\\n        smallSpots = a;\\n        bigSpots = b;\\n      } else {\\n        smallSpots = b;\\n        bigSpots = a;\\n      }\\n    }\\n    \\n    // methods\\n    \\n    @Override\\n    public boolean equals(Object obj) {\\n      return this.hashCode() == obj.hashCode();\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n      return this.smallSpots * 10 + bigSpots;\\n    }\\n    \\n  }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  \\n  public int numEquivDominoPairs(int[][] dominoes) {\\n    \\n    /*\\n    Runtime: 6 ms, faster than 80.81% of Java online submissions for Number of Equivalent Domino Pairs.\\n    Memory Usage: 48.3 MB, less than 100.00% of Java online submissions for Number of Equivalent Domino Pairs.\\n    */\\n    \\n    Map<Domino, Integer> dominoFT = new HashMap<Domino, Integer>();// FT = frequency table\\n    \\n    // populate HashMap with dominoes\\n    for (int[] d : dominoes) {\\n      dominoFT.merge(new Domino(d[0], d[1]), 1, Integer::sum);// nice little merge/sum trick useful for frequency counting...\\n    }\\n    \\n    int quantityOfPairs = 0;\\n    \\n    for (int i : dominoFT.values()) {// all we need are the values, so no need for entrySet() or keySet()\\n      if (i > 1) {\\n        // LeetCode\\'s test cases require:\\n        // 2 matching dominoes counts as 1 pair, BUT!...\\n        // 3 matching dominoes counts as 3 pairs (i.e., it wants handshake formula)\\n        quantityOfPairs += handshakeNumber(i);   \\n      }\\n    }\\n    \\n    return quantityOfPairs;\\n  }\\n  \\n  private int handshakeNumber(int n) {\\n    --n;\\n    return n * (n + 1) / 2;\\n  }\\n  \\n  private class Domino {\\n    \\n    // fields\\n    int smallSpots;\\n    int bigSpots;\\n    \\n    // constructor\\n    Domino (int a, int b) {\\n      if (a < b) {\\n        smallSpots = a;\\n        bigSpots = b;\\n      } else {\\n        smallSpots = b;\\n        bigSpots = a;\\n      }\\n    }\\n    \\n    // methods\\n    \\n    @Override\\n    public boolean equals(Object obj) {\\n      return this.hashCode() == obj.hashCode();\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n      return this.smallSpots * 10 + bigSpots;\\n    }\\n    \\n  }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646462,
                "title": "javascript-easy-and-readable-solution-using-map-and-math",
                "content": "This solution optimizes for readability and simplicity. We count how many dominos have the same number pairs and then sum up the different combinations of each set.\\n\\nThe math:\\nFor `n` items, the number of different ways to choose `r` items is given by the `nCr` formula\\n```\\nnumCombinations = n! / ((n-r)! * r!)\\n```\\n\\nGiven 2 dominos, the is only 1 way to choose 2 dominos. Given 3 domins, there are 2. For 4, there are 3.\\n\\nWe can further simplify this equation because we know `r = 2`\\n```\\nn! / ((n-2)! * 2!)\\n```\\nThen rewrite `n!` to be `n*(n-1)*(n-2)!`\\n```\\n(n*(n-1)*(n-2)!) / ((n-2)! * 2!)\\n```\\nSimplify\\n```\\nn*(n-1) / 2\\n```\\n\\nSolution:\\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    const counts = {};\\n    \\n    dominoes.forEach(d => {\\n\\t    // this converts all dominos with the same number pair to the same string\\n\\t\\t// [1,2] and [2,1] will get sorted to [1,2]\\n\\t\\t// toString method converts it to a string \"1,2\" so it can be used as keys\\n        const dStr = d.sort().toString();\\n\\t\\t\\n        if (!counts.hasOwnProperty(dStr)) {\\n            counts[dStr] = 0;\\n        }\\n        counts[dStr]++;\\n    })\\n    \\n\\t// sum all counts together while calculating combinations of domino pairs\\n    return Object.values(counts).reduce((sum, count) => {\\n        return sum + (count*(count-1))/2;\\n    }, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Probability and Statistics"
                ],
                "code": "```\\nnumCombinations = n! / ((n-r)! * r!)\\n```\n```\\nn! / ((n-2)! * 2!)\\n```\n```\\n(n*(n-1)*(n-2)!) / ((n-2)! * 2!)\\n```\n```\\nn*(n-1) / 2\\n```\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    const counts = {};\\n    \\n    dominoes.forEach(d => {\\n\\t    // this converts all dominos with the same number pair to the same string\\n\\t\\t// [1,2] and [2,1] will get sorted to [1,2]\\n\\t\\t// toString method converts it to a string \"1,2\" so it can be used as keys\\n        const dStr = d.sort().toString();\\n\\t\\t\\n        if (!counts.hasOwnProperty(dStr)) {\\n            counts[dStr] = 0;\\n        }\\n        counts[dStr]++;\\n    })\\n    \\n\\t// sum all counts together while calculating combinations of domino pairs\\n    return Object.values(counts).reduce((sum, count) => {\\n        return sum + (count*(count-1))/2;\\n    }, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640290,
                "title": "simple-java-using-hashmap",
                "content": "Intuition\\n1. Traverse loop while traversing store each pair in hashmap.\\n2. If the number already exists increment its count in hashmap.\\n3. At the end traverse hasmap and get the result for each pair by calculating its permutations as n pemute= n*(n-1)/2 .\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<Integer,Integer> hsmap=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            int a=Math.min(dominoes[i][0],dominoes[i][1]);\\n            int b=Math.max(dominoes[i][0],dominoes[i][1]);\\n            int key1=a*10+ b;\\n            hsmap.put(key1,hsmap.getOrDefault(key1,0)+1);\\n        }\\n        int count=0;\\n        for(Integer i:hsmap.values())\\n        {\\n            count+=(i*(i-1))/2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<Integer,Integer> hsmap=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            int a=Math.min(dominoes[i][0],dominoes[i][1]);\\n            int b=Math.max(dominoes[i][0],dominoes[i][1]);\\n            int key1=a*10+ b;\\n            hsmap.put(key1,hsmap.getOrDefault(key1,0)+1);\\n        }\\n        int count=0;\\n        for(Integer i:hsmap.values())\\n        {\\n            count+=(i*(i-1))/2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625460,
                "title": "c-solution-std-unordered-map",
                "content": "With numbers of pairs calculation on-the-fly\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n        {\\n            auto it = m.emplace(key_t{x[0], x[1]}, 0).first;\\n            count += it->second;\\n            ++(it->second);\\n        }\\n        return count;\\n    }\\n};\\n```\\nOr with std::accumulate upon collecting information about pairs\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n            ++m[{x[0], x[1]}];\\n        return std::accumulate(m.cbegin(), m.cend(), 0, [](auto sum, auto const &p){ return sum + p.second * (p.second - 1) / 2; });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n        {\\n            auto it = m.emplace(key_t{x[0], x[1]}, 0).first;\\n            count += it->second;\\n            ++(it->second);\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n            ++m[{x[0], x[1]}];\\n        return std::accumulate(m.cbegin(), m.cend(), 0, [](auto sum, auto const &p){ return sum + p.second * (p.second - 1) / 2; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620700,
                "title": "c-calculate-in-1-iteration-using-map",
                "content": "use a map to store a pair as key and it\\'s count so far as value. for counting pairs we just have to just count the same domino processed so far.\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        int s=dominoes.size();\\n        if(s==1)\\n            return ans;\\n        map<pair<int,int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n        int a=min(dominoes[i][0],dominoes[i][1]);\\n        int b=max(dominoes[i][0],dominoes[i][1]);\\n        m[{a,b}]++;\\n        ans+=m[{a,b}]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        int s=dominoes.size();\\n        if(s==1)\\n            return ans;\\n        map<pair<int,int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n        int a=min(dominoes[i][0],dominoes[i][1]);\\n        int b=max(dominoes[i][0],dominoes[i][1]);\\n        m[{a,b}]++;\\n        ans+=m[{a,b}]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617208,
                "title": "python-rust-time-o-n-space-o-n",
                "content": "- **Python**\\n```python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        seen, count = {}, 0\\n        \\n        for d in dominoes:\\n            key = tuple(sorted(d))\\n            if key in seen:\\n                count += seen[key]\\n                seen[key] += 1\\n            else:\\n                seen[key] = 1\\n                \\n        return count\\n```\\n\\n- **Rust**\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut seen: HashMap<(i32,i32), i32> = HashMap::new();\\n        \\n        for d in dominoes.iter() {\\n            let mut t = d.clone();\\n            t.sort();\\n            let key = (t[0], t[1]);\\n            \\n            if seen.contains_key(&key) {\\n                let val = *seen.get(&key).unwrap();\\n                count += val;\\n                seen.insert(key, val + 1);\\n            } else {\\n                seen.insert(key, 1);\\n            }  \\n        } \\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        seen, count = {}, 0\\n        \\n        for d in dominoes:\\n            key = tuple(sorted(d))\\n            if key in seen:\\n                count += seen[key]\\n                seen[key] += 1\\n            else:\\n                seen[key] = 1\\n                \\n        return count\\n```\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut seen: HashMap<(i32,i32), i32> = HashMap::new();\\n        \\n        for d in dominoes.iter() {\\n            let mut t = d.clone();\\n            t.sort();\\n            let key = (t[0], t[1]);\\n            \\n            if seen.contains_key(&key) {\\n                let val = *seen.get(&key).unwrap();\\n                count += val;\\n                seen.insert(key, val + 1);\\n            } else {\\n                seen.insert(key, 1);\\n            }  \\n        } \\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595995,
                "title": "swift",
                "content": "```\\nfunc numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var map = [[Int]: Int]()\\n        for domin in dominoes {\\n            var cur = domin\\n            if cur[0] > cur[1] {\\n                cur = [cur[1], cur[0]]\\n            }\\n            map[cur, default: 0] += 1\\n        }\\n        var res = 0\\n        for value in map.values {\\n            if value > 1 {\\n                res += value * (value - 1) / 2\\n            }\\n        }\\n        return res\\n    }",
                "solutionTags": [],
                "code": "```\\nfunc numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var map = [[Int]: Int]()\\n        for domin in dominoes {\\n            var cur = domin\\n            if cur[0] > cur[1] {\\n                cur = [cur[1], cur[0]]\\n            }\\n            map[cur, default: 0] += 1\\n        }\\n        var res = 0\\n        for value in map.values {\\n            if value > 1 {\\n                res += value * (value - 1) / 2\\n            }\\n        }\\n        return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 568802,
                "title": "javascript-solution-o-n",
                "content": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    const map = new Map()\\n    let count = 0\\n    \\n    for (const [a, b] of dominoes) {\\n        const min = Math.min(a, b)\\n        const max = Math.max(a, b)\\n        const key = min + \"#\" + max\\n        if (!map.has(key)) map.set(key, 0)\\n        count += map.get(key)\\n        map.set(key, map.get(key) + 1)\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    const map = new Map()\\n    let count = 0\\n    \\n    for (const [a, b] of dominoes) {\\n        const min = Math.min(a, b)\\n        const max = Math.max(a, b)\\n        const key = min + \"#\" + max\\n        if (!map.has(key)) map.set(key, 0)\\n        count += map.get(key)\\n        map.set(key, map.get(key) + 1)\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553652,
                "title": "rust-4ms",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn num_equiv_domino_pairs(mut dominoes: Vec<Vec<i32>>) -> i32 {\\n    let mut map: HashMap<i32, i32> = HashMap::new();\\n    for d in &mut dominoes {\\n      d.sort();\\n      *map.entry(d[0] * 10 + d[1]).or_default() += 1;\\n    }\\n    map.values().fold(0, |s, &v| s + v * (v - 1) / 2)\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn num_equiv_domino_pairs(mut dominoes: Vec<Vec<i32>>) -> i32 {\\n    let mut map: HashMap<i32, i32> = HashMap::new();\\n    for d in &mut dominoes {\\n      d.sort();\\n      *map.entry(d[0] * 10 + d[1]).or_default() += 1;\\n    }\\n    map.values().fold(0, |s, &v| s + v * (v - 1) / 2)\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550585,
                "title": "python-1-line",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:                \\n        return sum((v-1)*v//2 for v in collections.Counter([tuple(sorted(x)) for x in dominoes]).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:                \\n        return sum((v-1)*v//2 for v in collections.Counter([tuple(sorted(x)) for x in dominoes]).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538380,
                "title": "java-rewrite-hashcode-and-equals-method",
                "content": "This is not a concise method but a way to use hashCode and equals to solve the problem. The reason is that hashCode of int[] cannot be used to compare int[]. \\n\\n```\\n    class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            int result = 10;\\n            result = x * result + y;\\n            return result;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (o == this) return true;\\n            if (!(o instanceof Point)) {\\n                return false;\\n            }\\n            Point p = (Point) o;\\n            return p.x == x && p.y == y;\\n        }\\n    }\\n\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        if (dominoes == null || dominoes.length == 0) {\\n            return 0;\\n        }\\n        Map<Point, Integer> hm = new HashMap<>();\\n        int res = 0;\\n        for (int[] key : dominoes) {\\n            Point point = new Point(key[0], key[1]);\\n            Point rPoint = new Point(key[1], key[0]);\\n            if (hm.containsKey(point)) {\\n                hm.put(point, hm.get(point) + 1);\\n            } else if(hm.containsKey(rPoint)) {\\n                hm.put(rPoint, hm.get(rPoint) + 1);\\n            } else {\\n                hm.put(point, 1);\\n            }\\n        }\\n        for (int v : hm.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            int result = 10;\\n            result = x * result + y;\\n            return result;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (o == this) return true;\\n            if (!(o instanceof Point)) {\\n                return false;\\n            }\\n            Point p = (Point) o;\\n            return p.x == x && p.y == y;\\n        }\\n    }\\n\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        if (dominoes == null || dominoes.length == 0) {\\n            return 0;\\n        }\\n        Map<Point, Integer> hm = new HashMap<>();\\n        int res = 0;\\n        for (int[] key : dominoes) {\\n            Point point = new Point(key[0], key[1]);\\n            Point rPoint = new Point(key[1], key[0]);\\n            if (hm.containsKey(point)) {\\n                hm.put(point, hm.get(point) + 1);\\n            } else if(hm.containsKey(rPoint)) {\\n                hm.put(rPoint, hm.get(rPoint) + 1);\\n            } else {\\n                hm.put(point, 1);\\n            }\\n        }\\n        for (int v : hm.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522533,
                "title": "kotlin-solution-in-3-lines",
                "content": "I would be submitting two versions of the code that could be simple and small which would result in the solution.\\nSolution1:\\n```\\ndominoes.groupBy { it.min() to it.max() }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```\\nSolution2:\\n```\\ndominoes.groupBy { maxOf(it[0], it[1]) * 10 + minOf(it[0], it[1]) }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```",
                "solutionTags": [],
                "code": "```\\ndominoes.groupBy { it.min() to it.max() }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```\n```\\ndominoes.groupBy { maxOf(it[0], it[1]) * 10 + minOf(it[0], it[1]) }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501941,
                "title": "very-slow-but-work-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dom) {\\n  let count = 0;\\n  \\n  for (let i = 0; i < dom.length; i++) {\\n    for (let j = i + 1; j < dom.length; j++) {\\n      if (dom[i][0] === dom[j][0] && dom[i][1] === dom[j][1] ||\\n          dom[i][0] === dom[j][1] && dom[i][1] === dom[j][0]) count++;\\n    }\\n  }\\n  \\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dom) {\\n  let count = 0;\\n  \\n  for (let i = 0; i < dom.length; i++) {\\n    for (let j = i + 1; j < dom.length; j++) {\\n      if (dom[i][0] === dom[j][0] && dom[i][1] === dom[j][1] ||\\n          dom[i][0] === dom[j][1] && dom[i][1] === dom[j][0]) count++;\\n    }\\n  }\\n  \\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476594,
                "title": "python-double-100",
                "content": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dic = [0]*100\\n        for i, j in dominoes:\\n            if i > j:\\n                i, j = j, i\\n            dic[i*10+j] += 1 \\n        res = 0\\n        for i in range(11,100):\\n            if dic[i] > 1:\\n                res += (dic[i]-1)*dic[i]/2\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dic = [0]*100\\n        for i, j in dominoes:\\n            if i > j:\\n                i, j = j, i\\n            dic[i*10+j] += 1 \\n        res = 0\\n        for i in range(11,100):\\n            if dic[i] > 1:\\n                res += (dic[i]-1)*dic[i]/2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466249,
                "title": "swift-code-o-n-space-and-time-complexity-solution",
                "content": "```\\nclass Solution {\\n    func numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var dict = [String: Int](), count = 0\\n        for pairs in dominoes{\\n            let minimum: Int = min(pairs[0], pairs[1])\\n            let maximum: Int = max(pairs[0], pairs[1])\\n            let number = String(\"\\\\(minimum)\\\\(maximum)\")\\n            if let occurance = dict[number]{\\n                dict[number] = occurance + 1\\n                count += dict[number]!\\n            }else{\\n                dict[number] = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var dict = [String: Int](), count = 0\\n        for pairs in dominoes{\\n            let minimum: Int = min(pairs[0], pairs[1])\\n            let maximum: Int = max(pairs[0], pairs[1])\\n            let number = String(\"\\\\(minimum)\\\\(maximum)\")\\n            if let occurance = dict[number]{\\n                dict[number] = occurance + 1\\n                count += dict[number]!\\n            }else{\\n                dict[number] = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462146,
                "title": "go-98-solution",
                "content": "```go\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tmagic := map[[2]int]int{}\\n\\tfor i := range dominoes {\\n\\t\\tsort.Ints(dominoes[i])\\n\\t\\tmagic[[2]int{dominoes[i][0], dominoes[i][1]}]++\\n\\t}\\n\\n\\tdominoPairCount := 0\\n\\tfor _, v := range magic {\\n\\t\\tdominoPairCount += helper(v)\\n\\t}\\n\\treturn dominoPairCount\\n}\\n\\nfunc helper(n int) int  {\\n\\tif n < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\tn *= n-1\\n\\treturn n / 2\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tmagic := map[[2]int]int{}\\n\\tfor i := range dominoes {\\n\\t\\tsort.Ints(dominoes[i])\\n\\t\\tmagic[[2]int{dominoes[i][0], dominoes[i][1]}]++\\n\\t}\\n\\n\\tdominoPairCount := 0\\n\\tfor _, v := range magic {\\n\\t\\tdominoPairCount += helper(v)\\n\\t}\\n\\treturn dominoPairCount\\n}\\n\\nfunc helper(n int) int  {\\n\\tif n < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\tn *= n-1\\n\\treturn n / 2\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454287,
                "title": "python3-two-methods-using-hash-table-and-itertools-combinations",
                "content": "```\\nimport itertools\\n\\nclass Solution:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tht = {}\\n\\t\\tfor dom in dominoes:\\n\\t\\t\\tht[tuple(sorted(dom))] = ht.get(tuple(sorted(dom)),0) + 1\\n\\t\\tcount = 0\\n\\t\\tfor pair in ht:\\n\\t\\t\\tcount += ht[pair]*(ht[pair]-1)//2\\n\\t\\treturn count\\n\\nclass Solution1:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tif len(dominoes) <= 1:\\n\\t\\t\\treturn 0\\n\\n\\t\\tcombs = [x for x in itertools.combinations(dominoes,2)]\\n\\t\\tcount = 0\\n\\t\\tfor item in combs:\\n\\t\\t\\tif min(item[0]) == min(item[1]) and max(item[0]) == max(item[1]):\\n\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport itertools\\n\\nclass Solution:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tht = {}\\n\\t\\tfor dom in dominoes:\\n\\t\\t\\tht[tuple(sorted(dom))] = ht.get(tuple(sorted(dom)),0) + 1\\n\\t\\tcount = 0\\n\\t\\tfor pair in ht:\\n\\t\\t\\tcount += ht[pair]*(ht[pair]-1)//2\\n\\t\\treturn count\\n\\nclass Solution1:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tif len(dominoes) <= 1:\\n\\t\\t\\treturn 0\\n\\n\\t\\tcombs = [x for x in itertools.combinations(dominoes,2)]\\n\\t\\tcount = 0\\n\\t\\tfor item in combs:\\n\\t\\t\\tif min(item[0]) == min(item[1]) and max(item[0]) == max(item[1]):\\n\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450685,
                "title": "bruteforce-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int numEquivDominoPairs(int[][] d) {\\n\\t\\t\\tint[] visit= new int[d.length];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<d.length;i++){\\n\\t\\t\\t\\tans=fn(d,i,visit,ans);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tpublic int fn(int[][] d, int x,int[] visit, int ans){\\n\\t\\t\\tint count=0;\\n\\t\\t\\tif(visit[x]==0){   \\n\\t\\t\\t\\tvisit[x]=1;\\n\\t\\t\\t\\tfor(int i=0;i<d.length; i++){\\n\\t\\t\\t\\t\\tif(visit[i]==0){\\n\\t\\t\\t\\t\\t\\tif(d[x][0]==d[i][0]&&d[x][1]==d[i][1]){\\n\\t\\t\\t\\t\\t\\t\\tvisit[i]=1;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}else if(d[x][1]==d[i][0]&&d[x][0]==d[i][1]){\\n\\t\\t\\t\\t\\t\\t\\t visit[i]=1;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tans=ans+((count)*(count+1))/2;\\n\\t\\t\\t}  \\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int numEquivDominoPairs(int[][] d) {\\n\\t\\t\\tint[] visit= new int[d.length];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<d.length;i++){\\n\\t\\t\\t\\tans=fn(d,i,visit,ans);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 444487,
                "title": "python-hashmap-100-100",
                "content": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        maps = {}\\n        count = 0\\n        for i in dominoes:\\n            if (i[0],i[1]) not in maps and  (i[1],i[0]) not in maps:\\n                maps[(i[0],i[1])] = 1\\n            else:\\n                if (i[0],i[1]) in maps:\\n                    maps[(i[0],i[1])] += 1\\n                else:\\n                    maps[(i[1],i[0])] += 1\\n        count = 0\\n        for i in maps:\\n            if maps[i] >= 2:\\n                count += maps[i] * (maps[i]-1)//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        maps = {}\\n        count = 0\\n        for i in dominoes:\\n            if (i[0],i[1]) not in maps and  (i[1],i[0]) not in maps:\\n                maps[(i[0],i[1])] = 1\\n            else:\\n                if (i[0],i[1]) in maps:\\n                    maps[(i[0],i[1])] += 1\\n                else:\\n                    maps[(i[1],i[0])] += 1\\n        count = 0\\n        for i in maps:\\n            if maps[i] >= 2:\\n                count += maps[i] * (maps[i]-1)//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427312,
                "title": "hashmap-easy-to-uderstand-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        map<pair<int,int>,int> mp;\\n        int cnt=0;\\n        for(auto& x:dominoes)\\n        {\\n            int a=min(x[0],x[1]);\\n            int b=max(x[0],x[1]);\\n            cnt+=mp[{a,b}]++;\\n        }\\n        \\n       \\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        map<pair<int,int>,int> mp;\\n        int cnt=0;\\n        for(auto& x:dominoes)\\n        {\\n            int a=min(x[0],x[1]);\\n            int b=max(x[0],x[1]);\\n            cnt+=mp[{a,b}]++;\\n        }\\n        \\n       \\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407991,
                "title": "java-o-n-method-using-hashmap",
                "content": "```\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\tMap<String, Integer> dominoToFrequency = new HashMap<>();\\n\\t\\tint count = 0;\\n\\t\\tfor(int[] domino : dominoes) {\\n\\t\\t\\tString key = \"\" + Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1]);\\n\\t\\t\\tdominoToFrequency.put(key, dominoToFrequency.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(Map.Entry<String, Integer> domino : dominoToFrequency.entrySet()) {\\n\\t\\t\\tint n = domino.getValue();\\n\\t\\t\\tif(n >= 2) {\\n\\t\\t\\t\\tcount += n*(n-1)/2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\tMap<String, Integer> dominoToFrequency = new HashMap<>();\\n\\t\\tint count = 0;\\n\\t\\tfor(int[] domino : dominoes) {\\n\\t\\t\\tString key = \"\" + Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1]);\\n\\t\\t\\tdominoToFrequency.put(key, dominoToFrequency.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(Map.Entry<String, Integer> domino : dominoToFrequency.entrySet()) {\\n\\t\\t\\tint n = domino.getValue();\\n\\t\\t\\tif(n >= 2) {\\n\\t\\t\\t\\tcount += n*(n-1)/2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 407141,
                "title": "easy-java-o-n",
                "content": "```\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] count  =  new int[10][10];\\n        int ans = 0;\\n        for (int[] dominoe : dominoes) {\\n            ans += count[dominoe[0]][dominoe[1]];\\n            if(dominoe[0] != dominoe[1]) {\\n                ans += count[dominoe[1]][dominoe[0]];\\n            }\\n            count[dominoe[0]][dominoe[1]]++;\\n   \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] count  =  new int[10][10];\\n        int ans = 0;\\n        for (int[] dominoe : dominoes) {\\n            ans += count[dominoe[0]][dominoe[1]];\\n            if(dominoe[0] != dominoe[1]) {\\n                ans += count[dominoe[1]][dominoe[0]];\\n            }\\n            count[dominoe[0]][dominoe[1]]++;\\n   \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391994,
                "title": "python-easy-understading",
                "content": "```\\ndic = {}\\nfor dominoe in dominoes:\\n\\ttmp = max(dominoe)*10 + min(dominoe)\\n\\tif tmp in dic: dic[tmp] += 1\\n\\telse: dic[tmp] = 0\\n\\nres = 0\\nfor ele in dic:\\n\\tres += dic[ele]*(dic[ele]+1)//2\\n\\nreturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndic = {}\\nfor dominoe in dominoes:\\n\\ttmp = max(dominoe)*10 + min(dominoe)\\n\\tif tmp in dic: dic[tmp] += 1\\n\\telse: dic[tmp] = 0\\n\\nres = 0\\nfor ele in dic:\\n\\tres += dic[ele]*(dic[ele]+1)//2\\n\\nreturn res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378223,
                "title": "java-o-n-time-o-n-space",
                "content": "Approach 1: For each domino, look for all domions to the right, and count all such pairs. Time: O(n^2), Space: O(1)  \\n\\nApproach 2: Sort the dominoes so that all equivalent dominos come together. For this make one pass to fix all such dominos where domino[0] > domino[1]. So each domino will have domino[0] <= domino[1]. After sorting count the equal domino pairs. Time: O(nlogn), Space: O(1) \\n\\nApproach 3: Use hashing. Time: O(n), Space: O(1)\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();  \\n        int count = 0; \\n        for(int[] d : dominoes) {\\n            int key = Math.min(d[0],d[1])*10 + Math.max(d[0],d[1]); \\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        for(int v : map.values()) count += v*(v-1)/2; \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();  \\n        int count = 0; \\n        for(int[] d : dominoes) {\\n            int key = Math.min(d[0],d[1])*10 + Math.max(d[0],d[1]); \\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        for(int v : map.values()) count += v*(v-1)/2; \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378146,
                "title": "python-o-n-with-frozenset",
                "content": "A lot of other solutions encode an entry with something like `min(a, b) + 10 * max(a, b)`. My first thought was to use a `Set`. However, `Set` in Python is not hashable. I ended up using a `frozenset` and a `dictionary`.\\n\\nEnjoy!\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dominoes_count = 0\\n        sets = {}\\n        for pair in dominoes:\\n            this_set = frozenset(pair)\\n            if this_set in sets:\\n                dominoes_count += sets[this_set]\\n                sets[this_set] += 1\\n            else:\\n                sets[this_set] = 1\\n        return dominoes_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dominoes_count = 0\\n        sets = {}\\n        for pair in dominoes:\\n            this_set = frozenset(pair)\\n            if this_set in sets:\\n                dominoes_count += sets[this_set]\\n                sets[this_set] += 1\\n            else:\\n                sets[this_set] = 1\\n        return dominoes_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377910,
                "title": "python-o-n-time-o-n-memory-2-pass-solution",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dict = {}\\n        res = 0\\n        for domino in dominoes:\\n            if domino[0] > domino[1]:\\n                val = tuple([domino[1], domino[0]])\\n            else:\\n                val = tuple(domino)\\n            freq = dict.get(val, 0) + 1\\n            dict[val] = freq\\n        for key in dict:\\n            res += dict[key]*(dict[key] - 1)//2\\n        return res\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 372149,
                "title": "easy-c-solution-using-maps-beats-88-100",
                "content": "Runtime: 40 ms\\nMemory Usage: 20.9 MB\\n\\n```\\nint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        \\n        int n = dominoes.size();\\n        map<pair<int,int>, int> mp;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int minVal = min(dominoes[i][0], dominoes[i][1]);\\n            int maxVal = max(dominoes[i][0], dominoes[i][1]);\\n            \\n            pair<int, int> newEntry{minVal, maxVal};\\n            \\n            if(mp.find(newEntry) != mp.end())\\n            {\\n                count += mp[newEntry];\\n                mp[newEntry]++;\\n            }\\n            else\\n                mp.insert({newEntry, 1});\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Runtime: 40 ms\\nMemory Usage: 20.9 MB\\n\\n```\\nint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        \\n        int n = dominoes.size();\\n        map<pair<int,int>, int> mp;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int minVal = min(dominoes[i][0], dominoes[i][1]);\\n            int maxVal = max(dominoes[i][0], dominoes[i][1]);\\n            \\n            pair<int, int> newEntry{minVal, maxVal};\\n            \\n            if(mp.find(newEntry) != mp.end())\\n            {\\n                count += mp[newEntry];\\n                mp[newEntry]++;\\n            }\\n            else\\n                mp.insert({newEntry, 1});\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 367870,
                "title": "python",
                "content": "```\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n      a = set()\\n      dic = {}\\n      for dom in dominoes:\\n          temp = sorted(dom)\\n          if (temp[0], temp[1]) in dic:\\n              dic[(temp[0], temp[1])] +=  1\\n          else:\\n              dic[(temp[0], temp[1])] =  1\\n       \\n      res = 0\\n      for key, values in dic.items():\\n          if values > 1:\\n              values = values - 1\\n              while values > 0:\\n                  res += values \\n                  values -= 1\\n      return res\\n\\t \\n```",
                "solutionTags": [],
                "code": "```\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n      a = set()\\n      dic = {}\\n      for dom in dominoes:\\n          temp = sorted(dom)\\n          if (temp[0], temp[1]) in dic:\\n              dic[(temp[0], temp[1])] +=  1\\n          else:\\n              dic[(temp[0], temp[1])] =  1\\n       \\n      res = 0\\n      for key, values in dic.items():\\n          if values > 1:\\n              values = values - 1\\n              while values > 0:\\n                  res += values \\n                  values -= 1\\n      return res\\n\\t \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 356136,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] d) {\\n        \\n        Map<Integer, Integer> map = new HashMap();\\n        for (int[] x : d)\\n        {\\n            Arrays.sort(x);\\n            int sig = x[0] * 10 + x[1];\\n            map.put(sig, map.getOrDefault(sig, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        for (int c : map.values())\\n        {\\n            if (c >= 2)\\n            {\\n                count += c * (c - 1) / 2;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] d) {\\n        \\n        Map<Integer, Integer> map = new HashMap();\\n        for (int[] x : d)\\n        {\\n            Arrays.sort(x);\\n            int sig = x[0] * 10 + x[1];\\n            map.put(sig, map.getOrDefault(sig, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        for (int c : map.values())\\n        {\\n            if (c >= 2)\\n            {\\n                count += c * (c - 1) / 2;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354782,
                "title": "go-hashing-o-n-beats-100-space",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    hash, pairs := make(map[string]int), 0\\n    for _, d := range dominoes {\\n        // generate key and reverse key\\n        key, revKey := fmt.Sprintf(\"%v:%v\",d[0],d[1]), fmt.Sprintf(\"%v:%v\",d[1],d[0])\\n        // look for previous pair\\n        if occurs, exists := hash[key]; exists {\\n            pairs += occurs\\n        }\\n        // count occurance\\n        hash[key]++\\n        if d[0] != d[1] {   // prevent [1,1] from double counting\\n            hash[revKey]++\\n        }\\n        \\n    }\\n    return pairs\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    hash, pairs := make(map[string]int), 0\\n    for _, d := range dominoes {\\n        // generate key and reverse key\\n        key, revKey := fmt.Sprintf(\"%v:%v\",d[0],d[1]), fmt.Sprintf(\"%v:%v\",d[1],d[0])\\n        // look for previous pair\\n        if occurs, exists := hash[key]; exists {\\n            pairs += occurs\\n        }\\n        // count occurance\\n        hash[key]++\\n        if d[0] != d[1] {   // prevent [1,1] from double counting\\n            hash[revKey]++\\n        }\\n        \\n    }\\n    return pairs\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354732,
                "title": "easy-understand-c-solution",
                "content": "For each pair, make sure v[0] > v[1] and use v[0] * 10 + v[1] to represent it. \\n\\nLoop the vector and use hashmap to store each kind of equivalent pair numbers. \\n\\nWe can count the answer while looping, If preiously the number of [1, 0] is n for example, if a new [1,0] equivalent piar is find, then the ans will increased by n\\n\\n```\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> m;\\n        int rv = 0;\\n        for (auto &v : dominoes) {\\n            if (v[0] < v[1]) {\\n                swap(v[0], v[1]);\\n            }\\n            int i = v[0] * 10 + v[1];\\n            rv += m[i];\\n            ++m[i];\\n        }\\n        return rv;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> m;\\n        int rv = 0;\\n        for (auto &v : dominoes) {\\n            if (v[0] < v[1]) {\\n                swap(v[0], v[1]);\\n            }\\n            int i = v[0] * 10 + v[1];\\n            rv += m[i];\\n            ++m[i];\\n        }\\n        return rv;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347629,
                "title": "java-o-n-time-o-n-space-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String,Integer> map = new HashMap();\\n        int ans=0;\\n        for(int[] each: dominoes){\\n            String x = each[0]<each[1] ? each[0]+\",\"+each[1] : each[1]+\",\"+each[0];\\n           if(!map.containsKey(x)){\\n                map.put(x,0);\\n           }\\n           int count=map.get(x);\\n            map.put(x,count+1);\\n          }\\n          for(Map.Entry<String,Integer> curr:map.entrySet()){\\n                int cuCo=curr.getValue();\\n                ans+= (cuCo*(cuCo-1))/2;\\n            }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String,Integer> map = new HashMap();\\n        int ans=0;\\n        for(int[] each: dominoes){\\n            String x = each[0]<each[1] ? each[0]+\",\"+each[1] : each[1]+\",\"+each[0];\\n           if(!map.containsKey(x)){\\n                map.put(x,0);\\n           }\\n           int count=map.get(x);\\n            map.put(x,count+1);\\n          }\\n          for(Map.Entry<String,Integer> curr:map.entrySet()){\\n                int cuCo=curr.getValue();\\n                ans+= (cuCo*(cuCo-1))/2;\\n            }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340718,
                "title": "java-super-simple-and-clean-9-line-o-n-solution-beats-100-time-and-100-space",
                "content": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++) {\\n            int tmp=10*Math.min(dominoes[i][0], dominoes[i][1])+Math.max(dominoes[i][0], dominoes[i][1]);\\n            if(map.containsKey(tmp)) map.put(tmp, map.get(tmp)+1);\\n            else map.put(tmp, 1);\\n        }\\n        int res=0;\\n        for(int i : map.values()) res+=i*(i-1)/2;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++) {\\n            int tmp=10*Math.min(dominoes[i][0], dominoes[i][1])+Math.max(dominoes[i][0], dominoes[i][1]);\\n            if(map.containsKey(tmp)) map.put(tmp, map.get(tmp)+1);\\n            else map.put(tmp, 1);\\n        }\\n        int res=0;\\n        for(int i : map.values()) res+=i*(i-1)/2;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 340324,
                "title": "c-solution-o-n",
                "content": "```\\npublic class Solution \\n{\\n    public int NumEquivDominoPairs(int[][] dominoes) \\n    {\\n        var dict = new Dictionary<string, int>();\\n        int sum = 0;\\n        foreach(var d in dominoes)\\n        {\\n            var key = d[0] < d[1] ? d[0] + \":\" + d[1] : d[1] + \":\" + d[0];\\n            if(!dict.ContainsKey(key)) dict[key] = 1;\\n            else sum += dict[key]++;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int NumEquivDominoPairs(int[][] dominoes) \\n    {\\n        var dict = new Dictionary<string, int>();\\n        int sum = 0;\\n        foreach(var d in dominoes)\\n        {\\n            var key = d[0] < d[1] ? d[0] + \":\" + d[1] : d[1] + \":\" + d[0];\\n            if(!dict.ContainsKey(key)) dict[key] = 1;\\n            else sum += dict[key]++;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340252,
                "title": "the-description-is-wrong-isn-t-it",
                "content": "Initially I write my code according to my comprehension about the description, the test result confuses me. Then I read you guys\\' post, I think the description doesn\\'t match what this problem really want us to do.\\n\\n**Let\\'s look at the description:**\\n###### Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.\\n###### \\n###### Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\\n\\nFristly, it demands that a qualified pair (i, j) should satisfy 0<= i < j < length, notice that it\\'s strictly smaller, shouldn\\'t include i <= j.\\nSecondly, for a qualified pair (i,j), it asks us to make sure that dominoes[i] is supposed to be equivalent to dominoes[j]. a.k.a. the i th element of the input dominoes should be identical or can be rotated to j th element. \\n\\n(I assume that sequence starts from 1 instead of 0 given the example test case.) Look at the example test case:\\n###### Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]\\n###### Output: 1\\nAs far as I understand, the logic goes this way:\\n###### 1. The 1st element [1,2] satisfy 0<=i<j<length, and the ith element [1,2] is equivalent to the jth element [2,1], so the answer=0+1=1;\\n###### 2. The 2nd element [2,1] doesn\\'t satisfy 0<=i<j<length, we skip it;\\n###### 3. The 3rd element [3,4] satisfy 0<=i<j<length, but the ith element [3,4] is not equivaleng to the jth element [5,6], the answer remains 1;\\n###### 4. The 4th element doesn\\'t satisfy 0<=i<j<length cuz length=4, we skip it.\\nSo the result is 1.\\n\\nThus here\\'s what I submit in the first place:\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0, length=dominoes.size();\\n        for (auto domino : dominoes) {\\n            int first=domino[0]-1, second=domino[1]-1;\\n            if (first<second&&second<length) {\\n                if ((dominoes[first][0]==dominoes[second][0]&&\\n                        dominoes[first][1]==dominoes[second][1])\\n                    ||\\n                    (dominoes[first][0]==dominoes[second][1]&&\\n                        dominoes[first][1]==dominoes[second][0]))\\n                    ++result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\nBut it didn\\'t pass. Take this failed test case for example:\\n###### Input:\\n###### [[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\n###### Output:\\n###### 0\\n###### Expected:\\n###### 4\\nonly the 4th and 5th elements (i.e. [1,2]) satisfy 0<=i<j<length, let alone neither of them satisfy **dominoes[i] equals to dominoes[j]**.\\nI take a look at other users\\' post, then I figure out that correct answer\\'s logic is completely different from what the description asks for. For instance, from the most voted  post, he encodes each group of equivalent pairs with a 2-digit number and store the count appearance frequency of them in a hash map. I didn\\'t mean that this idea isn\\'t perspicacious, but that solution doesn\\'t filter out domino pair that doesn\\'t satisfy **0<=i<j<length**, it doesn\\'t has anything to do with whether the ith element is equal to the jth element either. What the judge system want us to write is simply not what the description told us, and I\\'m confused why I didn\\'t see anyone point this out.\\nIt might be possible that I misunderstood the description as well, I made the same mistake before. Although this is just a simple problem, the cognitive difference makes me uncomfortable. If there\\'s a clear vulnerability in my reading comprehension about the description, welcome to correct me.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0, length=dominoes.size();\\n        for (auto domino : dominoes) {\\n            int first=domino[0]-1, second=domino[1]-1;\\n            if (first<second&&second<length) {\\n                if ((dominoes[first][0]==dominoes[second][0]&&\\n                        dominoes[first][1]==dominoes[second][1])\\n                    ||\\n                    (dominoes[first][0]==dominoes[second][1]&&\\n                        dominoes[first][1]==dominoes[second][0]))\\n                    ++result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340096,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        res = 0\\n        for i, j in dominoes:\\n            mi, ma = (i, j) if i <=j else (j, i)\\n            key = \\'%d_%d\\' % (mi, ma)\\n            if key not in d:\\n                d[key] = 0\\n            \\n            res += d[key]\\n            \\n            d[key] += 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        res = 0\\n        for i, j in dominoes:\\n            mi, ma = (i, j) if i <=j else (j, i)\\n            key = \\'%d_%d\\' % (mi, ma)\\n            if key not in d:\\n                d[key] = 0\\n            \\n            res += d[key]\\n            \\n            d[key] += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340015,
                "title": "can-any-one-explain-the-problem",
                "content": "Consider below two scenarios:\\n\\n[[1,2],[2,1],[3,4],[5,6]]\\n[1,2] appears twice - expected result = 1\\nIt is repeated once\\n\\n[[1,2],[1,2],[1,1],[1,2],[2,2]]\\n[1,2] appears thrice - expected result = 3\\n\\nIn first case [[1,2] , [1,2]]  = count = 1\\nThen in second case [[1,2] ,[1,2] , [1,2]] count = 2\\nTotal count = 3\\n\\nI still can\\'t get significance of counting like this - it could have straightforward if result of first scenario= 2 & second = 3. Can any one explain more on this?\\n\\nAfter finishing the contest, Based on this, I got following solution (C#):\\n``` csharp\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        Dictionary<(int, int), int> frequency = new Dictionary<(int, int), int>();\\n        int count = 0;\\n        \\n        for(int i = 0; i < dominoes.Length; i++)\\n        {\\n           int d1 = dominoes[i][0];\\n           int d2 = dominoes[i][1];\\n            \\n           if(d1 > d2)\\n           {\\n               int t = d2;\\n               d2 = d1;\\n               d1 = t;\\n           }\\n               \\n           if(frequency.ContainsKey((d1, d2)))\\n           {              \\n               count += frequency[(d1,d2)]++;\\n           }\\n           else\\n           {\\n               frequency[(d1,d2)] = 1;\\n           }           \\n        }        \\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` csharp\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        Dictionary<(int, int), int> frequency = new Dictionary<(int, int), int>();\\n        int count = 0;\\n        \\n        for(int i = 0; i < dominoes.Length; i++)\\n        {\\n           int d1 = dominoes[i][0];\\n           int d2 = dominoes[i][1];\\n            \\n           if(d1 > d2)\\n           {\\n               int t = d2;\\n               d2 = d1;\\n               d1 = t;\\n           }\\n               \\n           if(frequency.ContainsKey((d1, d2)))\\n           {              \\n               count += frequency[(d1,d2)]++;\\n           }\\n           else\\n           {\\n               frequency[(d1,d2)] = 1;\\n           }           \\n        }        \\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340010,
                "title": "java-o-n-solution-with-constant-space",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t    // Construct an array to contain the number of occurrences of all possible ways of number combinations\\n        int[] ref = new int[45];\\n        int res = 0;\\n\\t\\t// Iterate through the dominoes and increment the number of occurrences accordingly\\n        for (int i = 0; i < dominoes.length; i++) {\\n            int[] thisArr = dominoes[i];\\n            int small = Math.min(thisArr[0], thisArr[1]);\\n            int big = Math.max(thisArr[0], thisArr[1]);\\n            ref[10 * (small - 1) + big - small * (small + 1) / 2] += 1;\\n        }\\n       // Number of pairs of dominoes by permutation\\n        for (int i = 0; i < ref.length; i++) {\\n            if (ref[i] > 1) {\\n                res += ref[i] * (ref[i] - 1) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t    // Construct an array to contain the number of occurrences of all possible ways of number combinations\\n        int[] ref = new int[45];\\n        int res = 0;\\n\\t\\t// Iterate through the dominoes and increment the number of occurrences accordingly\\n        for (int i = 0; i < dominoes.length; i++) {\\n            int[] thisArr = dominoes[i];\\n            int small = Math.min(thisArr[0], thisArr[1]);\\n            int big = Math.max(thisArr[0], thisArr[1]);\\n            ref[10 * (small - 1) + big - small * (small + 1) / 2] += 1;\\n        }\\n       // Number of pairs of dominoes by permutation\\n        for (int i = 0; i < ref.length; i++) {\\n            if (ref[i] > 1) {\\n                res += ref[i] * (ref[i] - 1) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566999,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1655925,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1733401,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1678200,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 2029928,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 2013665,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1944528,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1912272,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1715633,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            }
        ]
    }
]