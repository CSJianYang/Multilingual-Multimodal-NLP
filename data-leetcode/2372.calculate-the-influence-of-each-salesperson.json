[
    {
        "title": "Count Hills and Valleys in an Array",
        "question_content": "You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\nReturn the number of hills and valleys in nums.\n&nbsp;\nExample 1:\n\nInput: nums = [2,4,1,1,6,5]\nOutput: 3\nExplanation:\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\nExample 2:\n\nInput: nums = [6,6,5,5,4,1]\nOutput: 0\nExplanation:\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 100\n\t1 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 1879182,
                "title": "two-pointers",
                "content": "Duplicates could be tricky to handle. For that, we use a second pointer (`j`), which we update only when we detect a hill or a valley.\\n\\n**C++**\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n    int res = 0;\\n    for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n        if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n            (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n            ++res;\\n            j = i;\\n        }            \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countHillValley(vector<int>& nums) {\\n    int res = 0;\\n    for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n        if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n            (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n            ++res;\\n            j = i;\\n        }            \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865693,
                "title": "java-one-pass-7-lines-o-1-space",
                "content": "```java\\n public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1866831,
                "title": "python-clean-solution-simple-and-easy",
                "content": "We start by taking a for loop which goes from 1 to length of array -1.\\nSince we cannot take 2 adjacent values such that nums[i] == nums[j]. \\nSo, we update the current value to previous value which will help us in counting the next hill or valley. \\n\\nTime complexity = O(n)\\nSpace complexity = O(1)\\n\\n```class Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley = 0\\n        for i in range(1, len(nums)-1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:     #hill check\\n                hillValley += 1\\n            if nums[i] < nums[i-1] and nums[i] < nums[i+1]:     #valley check\\n                hillValley += 1\\n        return hillValley\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley = 0\\n        for i in range(1, len(nums)-1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:     #hill check\\n                hillValley += 1\\n            if nums[i] < nums[i-1] and nums[i] < nums[i+1]:     #valley check\\n                hillValley += 1\\n        return hillValley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865624,
                "title": "count-hills-and-valleys-in-an-array-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t// taking a new vector\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n\\t\\t//pushing unique elements into new vector\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        int c=0;\\n\\t\\t//checking for valley or hill\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]>v[i-1] and v[i]>v[i+1] or v[i]<v[i-1] and v[i]<v[i+1]){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t// taking a new vector\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n\\t\\t//pushing unique elements into new vector\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        int c=0;\\n\\t\\t//checking for valley or hill\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]>v[i-1] and v[i]>v[i+1] or v[i]<v[i-1] and v[i]<v[i+1]){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865635,
                "title": "java-single-pass-solution-with-comments-o-n-time-o-1-space",
                "content": "\\n    class Solution {\\n        public int countHillValley(int[] nums) {\\n            int result = 0;\\n        \\n\\t\\t\\t// Get head start. Find first index for which nums[index] != nums[index-1]\\n\\t\\t\\tint start = 1;\\n\\t\\t\\twhile(start < nums.length && nums[start] == nums[start-1])\\n\\t\\t\\t\\tstart++;\\n\\n\\t\\t\\tint prev = start-1; //index of prev different value num\\n\\t\\t\\tfor(int i=start; i<nums.length-1; i++) {\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) //If numbers are same, simply ignore them\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(nums[i] > nums[prev] && nums[i] > nums[i+1]) //compare current num with prev number and next number\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[prev] && nums[i] < nums[i+1])\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tprev = i;   // Now your current number will become prev number.\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int countHillValley(int[] nums) {\\n            int result = 0;\\n        \\n\\t\\t\\t// Get head start. Find first index for which nums[index] != nums[index-1]\\n\\t\\t\\tint start = 1;\\n\\t\\t\\twhile(start < nums.length && nums[start] == nums[start-1])\\n\\t\\t\\t\\tstart++;\\n\\n\\t\\t\\tint prev = start-1; //index of prev different value num\\n\\t\\t\\tfor(int i=start; i<nums.length-1; i++) {\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) //If numbers are same, simply ignore them\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(nums[i] > nums[prev] && nums[i] > nums[i+1]) //compare current num with prev number and next number\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[prev] && nums[i] < nums[i+1])\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tprev = i;   // Now your current number will become prev number.\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1865658,
                "title": "easiest-c-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] == nums[i-1]) continue; //  same hill or valley\\n            \\n            int idx = i - 1, jdx = i + 1;\\n            while(idx >= 0 && nums[idx] == nums[i]) idx--;\\n            if(idx < 0) continue; // no left neighbour found\\n\\t\\t\\t\\n            while(jdx < n && nums[jdx] == nums[i]) jdx++;\\n            if(jdx == n) continue; // no right neighbour found\\n            \\n            if(nums[idx] < nums[i] && nums[jdx] < nums[i]) ans++;\\n            else if(nums[idx] > nums[i] && nums[jdx] > nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] == nums[i-1]) continue; //  same hill or valley\\n            \\n            int idx = i - 1, jdx = i + 1;\\n            while(idx >= 0 && nums[idx] == nums[i]) idx--;\\n            if(idx < 0) continue; // no left neighbour found\\n\\t\\t\\t\\n            while(jdx < n && nums[jdx] == nums[i]) jdx++;\\n            if(jdx == n) continue; // no right neighbour found\\n            \\n            if(nums[idx] < nums[i] && nums[jdx] < nums[i]) ans++;\\n            else if(nums[idx] > nums[i] && nums[jdx] > nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866666,
                "title": "count-hills-and-valleys-java-space-o-1-time-o-n-simple-solution",
                "content": "Problem: Finding the non-equal nearest neighbours on both the sides of an array element and comparing those values to decide a peak or valley. It is simple if we there are no duplicate values next to each.\\n\\nFor the adjacent duplicates we have to keep track of the closest neighbour on left and not update it till duplicates are crossed. \\n\\nOnce the adjacent duplicates are done, we can update it for the newer values .\\n\\n```\\npublic int countHillValley(int[] nums) {\\n        int ans = 0;\\n        int prev = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if((nums[i] > nums[i+1] && nums[i] > prev || (nums[i] < nums[i+1] && nums[i] < prev)))\\n                ans++;\\n            if(nums[i] != nums[i+1]){\\n                prev = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n        int ans = 0;\\n        int prev = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if((nums[i] > nums[i+1] && nums[i] > prev || (nums[i] < nums[i+1] && nums[i] < prev)))\\n                ans++;\\n            if(nums[i] != nums[i+1]){\\n                prev = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865655,
                "title": "python3-single-pass-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = 0\\n        candidate = last_num = None\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1]:\\n                if candidate and ((candidate > last_num and candidate > nums[i]) or (candidate < last_num and candidate < nums[i])):\\n                    res += 1\\n                candidate = nums[i]\\n                last_num = nums[i-1]\\n                    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = 0\\n        candidate = last_num = None\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1]:\\n                if candidate and ((candidate > last_num and candidate > nums[i]) or (candidate < last_num and candidate < nums[i])):\\n                    res += 1\\n                candidate = nums[i]\\n                last_num = nums[i-1]\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868487,
                "title": "javascript-filter-loop",
                "content": "By removing side-by-side duplicates, we can shorten the array and remove the need for code that would tell us if a number was part of a previous valley or hill. We then have our loop ignore the edges of the array, as our code tests each number against the one before & after it.\\n\\n```\\nvar countHillValley = function(nums) {\\n    let answer = 0;\\n    nums = nums.filter((a, i, b) => a !== b[i + 1]); // Remove Flatlands\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i - 1] > nums [i] && nums[i] < nums[i + 1]) answer++; // Valley\\n        if (nums[i - 1] < nums [i] && nums[i] > nums[i + 1]) answer++; // Hill\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let answer = 0;\\n    nums = nums.filter((a, i, b) => a !== b[i + 1]); // Remove Flatlands\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i - 1] > nums [i] && nums[i] < nums[i + 1]) answer++; // Valley\\n        if (nums[i - 1] < nums [i] && nums[i] > nums[i + 1]) answer++; // Hill\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865568,
                "title": "c-python-js-simple-explained-o-n-faster-than-100",
                "content": "The idea of this problem is pretty simple, we wish to count the number of Valleys and Hills in the array.\\nThe solution used in this problem is focused on simplicity and being easy to understand.\\nThis is O(n) time complexity, and O(n) memory complexity.\\n\\n**Strategy:**\\n\\nSo, to find if a number is a hill or a valley, we need to see if the neighboring values that aren\\'t the same are both an increase or decrease relative to this number.\\n\\nStep 1:\\n\\nMake sure that there are no neighboring nodes of the same values, so turning something like ``[6,7,7,7,8,8,9,2] -> [6,7,8,9,2]``.\\n\\nStep 2:\\n\\nLoop through the array starting at the 2nd index and up to the 2nd last index, and increase the return value if a nodes neighbors are both greater than or less than the node.\\n\\n**Solution:**\\n\\n**C++**\\n\\n```\\nint countHillValley(vector<int>& ns) {\\n    //Step 1\\n    std::vector<int> nums;\\n    int l = ns[0];\\n    nums.push_back(l);\\n    for (int n : ns) {\\n        if (n != l) {\\n            nums.push_back(n);\\n            l = n;\\n        }\\n    }\\n        \\n    //Step 2.\\n    int ret = 0;\\n    for (int i = 1; i < nums.size() - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    return ret;\\n}\\n```\\n\\n**Python**\\n\\n```\\ndef countHillValley(self, ns: List[int]) -> int:\\n    #Step 1\\n    nums = []\\n    l = ns[0]\\n    nums.append(l)\\n    for n in ns:\\n        if n != l:\\n            nums.append(n)\\n            l = n\\n                \\n    #Step 2\\n    ret = 0\\n    for i in range (1, len(nums) - 1):\\n        if ((nums[i-1] < nums[i]) == (nums[i+1] < nums[i])):\\n             ret += 1\\n            \\n    return ret\\n```\\n\\n**Javascript**\\n\\n```\\nvar countHillValley = function(ns) {\\n    //Step 1\\n    nums = [];\\n    let l = ns[0];\\n    nums.push(l);\\n    for (let i = 0; i < ns.length; i++) {\\n        n = ns[i];\\n        if (n != l) {\\n            l = n;\\n            nums.push(n);\\n        }\\n    }\\n\\n    \\n    //Step 2\\n    let ret = 0;\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    \\n    return ret;        \\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint countHillValley(vector<int>& ns) {\\n    //Step 1\\n    std::vector<int> nums;\\n    int l = ns[0];\\n    nums.push_back(l);\\n    for (int n : ns) {\\n        if (n != l) {\\n            nums.push_back(n);\\n            l = n;\\n        }\\n    }\\n        \\n    //Step 2.\\n    int ret = 0;\\n    for (int i = 1; i < nums.size() - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    return ret;\\n}\\n```\n```\\ndef countHillValley(self, ns: List[int]) -> int:\\n    #Step 1\\n    nums = []\\n    l = ns[0]\\n    nums.append(l)\\n    for n in ns:\\n        if n != l:\\n            nums.append(n)\\n            l = n\\n                \\n    #Step 2\\n    ret = 0\\n    for i in range (1, len(nums) - 1):\\n        if ((nums[i-1] < nums[i]) == (nums[i+1] < nums[i])):\\n             ret += 1\\n            \\n    return ret\\n```\n```\\nvar countHillValley = function(ns) {\\n    //Step 1\\n    nums = [];\\n    let l = ns[0];\\n    nums.push(l);\\n    for (let i = 0; i < ns.length; i++) {\\n        n = ns[i];\\n        if (n != l) {\\n            l = n;\\n            nums.push(n);\\n        }\\n    }\\n\\n    \\n    //Step 2\\n    let ret = 0;\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    \\n    return ret;        \\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1868034,
                "title": "my-easy-java-solution",
                "content": "Only move the previous pointer when we have a hill or valley.\\nElse keep that pointer, never move it.\\n\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int length = nums.length;\\n        int countHillValley = 0;\\n        int previous = nums[0];\\n        for (int i = 1; i < length - 1; i++) {\\n            if (previous < nums[i] && nums[i] > nums[i + 1] || previous > nums[i] && nums[i] < nums[i + 1]) {\\n                previous = nums[i];\\n                countHillValley++;\\n            }\\n        }\\n        return countHillValley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int length = nums.length;\\n        int countHillValley = 0;\\n        int previous = nums[0];\\n        for (int i = 1; i < length - 1; i++) {\\n            if (previous < nums[i] && nums[i] > nums[i + 1] || previous > nums[i] && nums[i] < nums[i + 1]) {\\n                previous = nums[i];\\n                countHillValley++;\\n            }\\n        }\\n        return countHillValley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867081,
                "title": "java-clean-code",
                "content": "```\\npublic int countHillValley(int[] nums) {\\n        int left = nums[0];\\n        int result = 0;\\n\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (isHill(left, nums[i], nums[i + 1]) || isValley(left, nums[i], nums[i + 1])) {\\n                result++;\\n                left = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean isHill(int left, int value, int right) {\\n        return value > left && value > right;\\n    }\\n\\n    private boolean isValley(int left, int value, int right) {\\n        return value < left && value < right;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n        int left = nums[0];\\n        int result = 0;\\n\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (isHill(left, nums[i], nums[i + 1]) || isValley(left, nums[i], nums[i + 1])) {\\n                result++;\\n                left = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean isHill(int left, int value, int right) {\\n        return value > left && value > right;\\n    }\\n\\n    private boolean isValley(int left, int value, int right) {\\n        return value < left && value < right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1867075,
                "title": "c-6-lines-with-std-erase-and-std-unique-2-lines-using-count-if",
                "content": "```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i-1] < nums[i] && nums[i] > nums[i+1])  // hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1]); // valley\\n\\treturn n;\\n}\\n```\\n\\nAs suggested by @izackwu, detection of hill or valley can be reduced :\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i - 1] > nums[i]) == (nums[i] < nums[i + 1]); // hill or valley\\n   return n;\\n}\\n```\\n\\nJust for the fun of ccode golfing, we can even drop it to 2 lines using (or abusing) `std::count_if` :\\n\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); \\n\\treturn nums.size()>2?count_if(next(nums.begin()), prev(nums.end()),[](const int& a) {return (*(&a-1) > a) == (a < *(&a+1));}):0;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i-1] < nums[i] && nums[i] > nums[i+1])  // hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1]); // valley\\n\\treturn n;\\n}\\n```\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i - 1] > nums[i]) == (nums[i] < nums[i + 1]); // hill or valley\\n   return n;\\n}\\n```\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); \\n\\treturn nums.size()>2?count_if(next(nums.begin()), prev(nums.end()),[](const int& a) {return (*(&a-1) > a) == (a < *(&a+1));}):0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552317,
                "title": "python-clean-concise-short-and-simple",
                "content": "You will be able to understand the solution using the comments. \\nLet me know if any questions. \\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley  = 0 \\n\\t\\t\\n\\t\\t#Here we will keep track of the left neighbour \\n        #Initially left neighbour is the 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n                \\n        return hillValley\\n```\\n\\nWe can also have another solution in which we update the left neighbour in a different way:\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        #Here we will keep track of the left neighbour \\n        hillValley  = 0 \\n        #Initially left neighbour is the left 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                hillValley  += 1\\n            \\n            #If current element and next element are not same then current element will be the \\n            #left neighbour for next element\\n            #If not then the old left neighbour will continue.            \\n            if nums[i] != nums[i+1]:\\n                leftNeighbour = nums[i]\\n                \\n        return hillValley \\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley  = 0 \\n\\t\\t\\n\\t\\t#Here we will keep track of the left neighbour \\n        #Initially left neighbour is the 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n                \\n        return hillValley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528962,
                "title": "python-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        increasing, changed = -1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                changed += int(increasing == 0)\\n                increasing = 1\\n            elif nums[i] < nums[i - 1]:\\n                changed += int(increasing == 1)\\n                increasing = 0\\n        return changed\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        increasing, changed = -1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                changed += int(increasing == 0)\\n                increasing = 1\\n            elif nums[i] < nums[i - 1]:\\n                changed += int(increasing == 1)\\n                increasing = 0\\n        return changed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865653,
                "title": "python-simple-iteration-o-n",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        c = 0\\n        i = 1\\n        while i <len(nums)-1:\\n            j = i+1\\n            while j < len(nums)-1 and nums[j] == nums[i]:\\n                j += 1\\n            if (nums[i-1] > nums[i] and nums[j] > nums[i]) or (nums[i-1] < nums[i] and nums[j] < nums[i]):\\n                    c += 1\\n            i = j\\n        return c\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        c = 0\\n        i = 1\\n        while i <len(nums)-1:\\n            j = i+1\\n            while j < len(nums)-1 and nums[j] == nums[i]:\\n                j += 1\\n            if (nums[i-1] > nums[i] and nums[j] > nums[i]) or (nums[i-1] < nums[i] and nums[j] < nums[i]):\\n                    c += 1\\n            i = j\\n        return c\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2595420,
                "title": "java-array-faster-than-100-java-submissions",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] a){\\n        int r=0,left=a[0];\\n        for(int i=1;i<a.length-1;i++){\\n            if(left<a[i] && a[i]>a[i+1] || left>a[i] && a[i]<a[i+1]){\\n                r++;\\n                left=a[i];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] a){\\n        int r=0,left=a[0];\\n        for(int i=1;i<a.length-1;i++){\\n            if(left<a[i] && a[i]>a[i+1] || left>a[i] && a[i]<a[i+1]){\\n                r++;\\n                left=a[i];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866869,
                "title": "python3-one-pass-o-1-space",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        \\n        #cnt: An integer to store total hills and valleys\\n        #left: Highest point of hill or lowest point of valley left of the current index\\n        cnt, left = 0, nums[0]\\n        \\n        for i in range(1, len(nums)-1):\\n            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):\\n                cnt+=1\\n                left=nums[i]\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        \\n        #cnt: An integer to store total hills and valleys\\n        #left: Highest point of hill or lowest point of valley left of the current index\\n        cnt, left = 0, nums[0]\\n        \\n        for i in range(1, len(nums)-1):\\n            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):\\n                cnt+=1\\n                left=nums[i]\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866196,
                "title": "c-easy-to-understand-beginners-friendly-using-pointer",
                "content": "**Please upvote if it helps **\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int ans = 0;                   // for storing the final result\\n        int k = -1;                    // it is used as a pointer for the new creating nums without duplicaccy\\n        int size = 0;                  // it will store the size of new nums \\n    \\n        //eliminating duplicates from the array\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(k == -1 or nums[k]!=nums[i])       // k==-1 means first element and if there is no duplicaccy then  \\n            {\\n                size++;                           // increase the size\\n                nums[k+1] = nums[i];              // assign the i to k+1\\n                k++;                              // move pointer to the next\\n            }\\n        }\\n    \\n        for(int i = 1; i<size-1; i++)\\n        {\\n            // H  ills\\n            if((nums[i]>nums[i+1] and nums[i]>nums[i-1]))\\n            {\\n                ans++;\\n            }\\n            \\n            // Valleys\\n            if((nums[i]<nums[i+1] and nums[i]<nums[i-1]))\\n            {\\n                ans++;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helps **",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int ans = 0;                   // for storing the final result\\n        int k = -1;                    // it is used as a pointer for the new creating nums without duplicaccy\\n        int size = 0;                  // it will store the size of new nums \\n    \\n        //eliminating duplicates from the array\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(k == -1 or nums[k]!=nums[i])       // k==-1 means first element and if there is no duplicaccy then  \\n            {\\n                size++;                           // increase the size\\n                nums[k+1] = nums[i];              // assign the i to k+1\\n                k++;                              // move pointer to the next\\n            }\\n        }\\n    \\n        for(int i = 1; i<size-1; i++)\\n        {\\n            // H  ills\\n            if((nums[i]>nums[i+1] and nums[i]>nums[i-1]))\\n            {\\n                ans++;\\n            }\\n            \\n            // Valleys\\n            if((nums[i]<nums[i+1] and nums[i]<nums[i-1]))\\n            {\\n                ans++;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576588,
                "title": "tail-pointer",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = size(nums);\\n        int count=0;\\n        int i=1,j=0; // j is a tail pointer\\n        for(i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return count;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/ebe03d36-f10f-4b43-aebb-8a3f2c73c77b_1685388122.1682274.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = size(nums);\\n        int count=0;\\n        int i=1,j=0; // j is a tail pointer\\n        for(i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412861,
                "title": "count-hills-and-valleys-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i, count=0, hill=0, valley=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i-1]<nums[i] && hill==0)\\n            {\\n                hill=1;\\n                if(valley==1)\\n                {\\n                    count++;\\n                    valley=0;\\n                }\\n            }\\n            else if(nums[i-1]>nums[i])\\n            {\\n                valley=1;\\n                if(hill==1)\\n                {\\n                    count++;\\n                    hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i, count=0, hill=0, valley=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i-1]<nums[i] && hill==0)\\n            {\\n                hill=1;\\n                if(valley==1)\\n                {\\n                    count++;\\n                    valley=0;\\n                }\\n            }\\n            else if(nums[i-1]>nums[i])\\n            {\\n                valley=1;\\n                if(hill==1)\\n                {\\n                    count++;\\n                    hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169968,
                "title": "python-clean-solution-explanation-of-an-edge-case",
                "content": "# Intuition\\nWe are iterating from 1st to last -1 element.\\nFor each one determine is it hill or velly:\\nelement-1 < element > element + 1 or element-1 > element < element + 1\\n\\n# Approach\\nImportant to not count the same velly [4, ***1,1,1*** ,4] multiple times.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(1, len(nums)-1):\\n            # edge case, the same velly!\\n            # adjacent indexes should be considered as one velly or hill\\n            # to handle this, we can check if next value is the same as current\\n            # for example in [4,1,1,6]\\n            # [4, 1(we are here), 1(detected next value), 6]\\n            # replace the first 1 by 4 (4 is a previous value)\\n            # as result we get: [4,4,1,6]\\n            # so thet at the next iteration the second 1 will be detected as a valley\\n            # [4,4,1(we are here),6] \\n            # 4 > 1 < 6\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            elif nums[i-1] > nums[i] < nums[i+1] or nums[i-1] < nums[i] > nums[i+1]:\\n                result += 1\\n        return result\\n            \\n\\n            \\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(1, len(nums)-1):\\n            # edge case, the same velly!\\n            # adjacent indexes should be considered as one velly or hill\\n            # to handle this, we can check if next value is the same as current\\n            # for example in [4,1,1,6]\\n            # [4, 1(we are here), 1(detected next value), 6]\\n            # replace the first 1 by 4 (4 is a previous value)\\n            # as result we get: [4,4,1,6]\\n            # so thet at the next iteration the second 1 will be detected as a valley\\n            # [4,4,1(we are here),6] \\n            # 4 > 1 < 6\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            elif nums[i-1] > nums[i] < nums[i+1] or nums[i-1] < nums[i] > nums[i+1]:\\n                result += 1\\n        return result\\n            \\n\\n            \\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147988,
                "title": "cool-single-pass-java-solution-beats-100-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }\\n                prevDiff = nextDiff;\\n            }\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }\\n                prevDiff = nextDiff;\\n            }\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950309,
                "title": "java-time-complexity-o-n-space-o-1-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int count = 0;\\n        for(int i = 1; i<arr.length-1; i++){\\n            if( arr[i] == arr[i+1]){ \\n                arr[i] = arr[i-1];\\n                continue;\\n            }\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                count++;\\n            }else if(arr[i]<arr[i-1] && arr[i]<arr[i+1]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] arr) {\\n        int count = 0;\\n        for(int i = 1; i<arr.length-1; i++){\\n            if( arr[i] == arr[i+1]){ \\n                arr[i] = arr[i-1];\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2563706,
                "title": "with-explanation-comments-time-4-ms-61-39-space-9-mb-38-09",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        //initialize a counter for both hills and valleys\\n        int counter=0;\\n        \\n        //initialize a new vector for the non-repeated numbers\\n        vector<int> res;\\n        \\n        //save the first array value as the first unique one\\n        res.push_back(nums[0]);\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<nums.size();i++)\\n            \\n            //check if the current one doesn\\'t equal to the last saved value\\n            if(nums[i]!=nums[i-1]){\\n                //add the non-repeated number to the new array\\n                res.push_back(nums[i]);\\n            }\\n    \\n        //loop over the whole unique array numbers        \\n        for(int i=1;i<res.size()-1;i++)\\n            \\n            //check of the two conditions: if their both neighbors are greater-> hill++ | both are smaller-> valley++ -> or counter++ for simplicity\\n            if(res[i]>res[i+1] && res[i]>res[i-1] || res[i] < res[i+1] && res[i]<res[i-1])\\n                counter++;\\n        \\n        //return the hill+vally values-> general counter value\\n        return counter;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        //initialize a counter for both hills and valleys\\n        int counter=0;\\n        \\n        //initialize a new vector for the non-repeated numbers\\n        vector<int> res;\\n        \\n        //save the first array value as the first unique one\\n        res.push_back(nums[0]);\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<nums.size();i++)\\n            \\n            //check if the current one doesn\\'t equal to the last saved value\\n            if(nums[i]!=nums[i-1]){\\n                //add the non-repeated number to the new array\\n                res.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2272429,
                "title": "easy-to-understand-c-o-n-solution",
                "content": "\\'\\'\\'\\n     //Time Complexity : O(n)  Space Complexity : O(1)\\n   \\n        int countHillValley(vector<int>& nums) {\\n        \\n        int hills=0, valleys=0;\\n\\n        //Index before and after the \\'i\\' th index for which we are checking for hill or valley \\n        int low=0, high=1;\\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n            low=i-1;\\n            high=i+1;\\n            \\n            //Handling Duplicates \\n            while(high<nums.size() && nums[high]==nums[i]) high++;\\n            if(high==nums.size()) break;\\n            \\n\\t\\t\\t//Check for Hill or Valley \\n            if(nums[i]<nums[low] && nums[i]<nums[high]) valleys++;\\n            else if(nums[i]>nums[low] && nums[i]>nums[high]) hills++;\\n            \\n            //Directly jump to high(index) and -1 because i will be incremented in loop itself \\n            i=high-1;\\n        }\\n        \\n        return hills+valleys;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n     //Time Complexity : O(n)  Space Complexity : O(1)\\n   \\n        int countHillValley(vector<int>& nums) {\\n        \\n        int hills=0, valleys=0;\\n\\n        //Index before and after the \\'i\\' th index for which we are checking for hill or valley \\n        int low=0, high=1;\\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n            low=i-1;\\n            high=i+1;\\n            \\n            //Handling Duplicates \\n            while(high<nums.size() && nums[high]==nums[i]) high++;\\n            if(high==nums.size()) break;\\n            \\n\\t\\t\\t//Check for Hill or Valley \\n            if(nums[i]<nums[low] && nums[i]<nums[high]) valleys++;\\n            else if(nums[i]>nums[low] && nums[i]>nums[high]) hills++;\\n            \\n            //Directly jump to high(index) and -1 because i will be incremented in loop itself \\n            i=high-1;\\n        }\\n        \\n        return hills+valleys;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2160938,
                "title": "typescript-o-n-time-o-1-space",
                "content": "Remember previous status, going up or going down. If current node goes down since previous status is going up, it meas you just past a valley. Or conversely, you just past a hill.\\n```ts\\nfunction countHillValley(nums: number[]): number {\\n  let res = 0, status: boolean;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] === nums[i - 1]) continue;\\n    \\n    if (status === undefined) {\\n      if (nums[i] < nums[i - 1]) status = false\\n      else status = true;\\n      \\n      continue;\\n    }\\n    \\n    if (status && nums[i] < nums[i - 1] || !status && nums[i] > nums[i - 1]) res++, status = !status\\n  }\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction countHillValley(nums: number[]): number {\\n  let res = 0, status: boolean;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] === nums[i - 1]) continue;\\n    \\n    if (status === undefined) {\\n      if (nums[i] < nums[i - 1]) status = false\\n      else status = true;\\n      \\n      continue;\\n    }\\n    \\n    if (status && nums[i] < nums[i - 1] || !status && nums[i] > nums[i - 1]) res++, status = !status\\n  }\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058335,
                "title": "count-hills-and-valleys-in-an-array-java-easy",
                "content": "```\\n\\n       int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left=arr[i];     \\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left=arr[i];\\n            }\\n        }\\n        return ans;\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n       int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left=arr[i];     \\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left=arr[i];\\n            }\\n        }\\n        return ans;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977956,
                "title": "java-o-n-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int leftNeighbour = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if(leftNeighbour < nums[i] && nums[i+1] < nums[i])\\n                count++;\\n            if(leftNeighbour > nums[i] && nums[i+1] > nums[i])\\n                count++;\\n            if(nums[i] != nums[i+1])\\n                leftNeighbour = nums[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int leftNeighbour = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if(leftNeighbour < nums[i] && nums[i+1] < nums[i])\\n                count++;\\n            if(leftNeighbour > nums[i] && nums[i+1] > nums[i])\\n                count++;\\n            if(nums[i] != nums[i+1])\\n                leftNeighbour = nums[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950026,
                "title": "vert-simple-commented-solution-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int answer = 0;\\n         // this removes equal adjacent numbers.\\n     \\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        \\n        //Note the start (1) and the end (size-1) as the first and the last number can\\'t be a valley or a hill.\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\t  if ((nums[i-1] < nums[i] && nums[i] > nums[i+1])  // if it\\'s a hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1])) // if it\\'s a valley\\n              answer++;\\n\\treturn answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int answer = 0;\\n         // this removes equal adjacent numbers.\\n     \\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        \\n        //Note the start (1) and the end (size-1) as the first and the last number can\\'t be a valley or a hill.\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\t  if ((nums[i-1] < nums[i] && nums[i] > nums[i+1])  // if it\\'s a hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1])) // if it\\'s a valley\\n              answer++;\\n\\treturn answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932870,
                "title": "python",
                "content": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        nums1 = [nums[0]]\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums1[-1]:\\n                nums1.append(nums[i])\\n        cnt = 0\\n        for i in range(1, len(nums1) - 1):\\n            if nums1[i - 1] < nums1[i] > nums1[i + 1] or nums1[i - 1] > nums1[i] < nums1[i + 1]:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        nums1 = [nums[0]]\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums1[-1]:\\n                nums1.append(nums[i])\\n        cnt = 0\\n        for i in range(1, len(nums1) - 1):\\n            if nums1[i - 1] < nums1[i] > nums1[i + 1] or nums1[i - 1] > nums1[i] < nums1[i + 1]:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1870566,
                "title": "c-one-pass-solution",
                "content": "```\\n\\tpublic int CountHillValley(int[] nums) {\\n        var count = 0;\\n        int leftBorder = nums[0];\\n        for (int i=1; i<nums.Length-1; i++) {\\n            if (nums[i] == nums[i+1]) \\n               continue;\\n            if (IsHill(nums[i], leftBorder, nums[i+1]) || IsValley(nums[i], leftBorder, nums[i+1])) \\n                count++;\\n            leftBorder = nums[i];\\n        }\\n        return count;\\n    }\\n\\t\\n\\tbool IsValley(int height, int leftBorder, int rightBorder)\\n        => height < leftBorder && height < rightBorder;\\n                \\n    bool IsHill(int height, int leftBorder, int rightBorder)\\n        => height > leftBorder && height > rightBorder;\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int CountHillValley(int[] nums) {\\n        var count = 0;\\n        int leftBorder = nums[0];\\n        for (int i=1; i<nums.Length-1; i++) {\\n            if (nums[i] == nums[i+1]) \\n               continue;\\n            if (IsHill(nums[i], leftBorder, nums[i+1]) || IsValley(nums[i], leftBorder, nums[i+1])) \\n                count++;\\n            leftBorder = nums[i];\\n        }\\n        return count;\\n    }\\n\\t\\n\\tbool IsValley(int height, int leftBorder, int rightBorder)\\n        => height < leftBorder && height < rightBorder;\\n                \\n    bool IsHill(int height, int leftBorder, int rightBorder)\\n        => height > leftBorder && height > rightBorder;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868597,
                "title": "easy-solution-with-full-explanation-c-o-n-time-o-n-space",
                "content": "The question would be trivial if duplicate elements cannot be beside each other, as we would only have to compare v[i - 1] and v[i + 1] for i from 1 to N - 1. Therefore, we must come up with a method to remove adjacent elements that are equal. \\n\\nKey Observation: Adjacent duplicates will not affect the result. \\nSuppose there is a valley. Adding another trough beside the lowest element will not change the result, as there will still only be one valley. \\n\\nWithout loss of generality, adding another peak beside the highest element will not change the result, as there will still only be one peak. \\n\\nShown in the image below, adjacent duplicates do not affect the result. \\n![image](https://assets.leetcode.com/users/images/98308d6b-7748-4165-b99d-104c77961a17_1647815885.0251374.png)\\n\\n\\nTherefore, the array can be \"condensed\" by removing adjacement duplicates. \\n\\nImplementation\\nStep 1: make a new array and insert elements from the original array without adjacent duplicates. \\nStep 2. Iterate through 1 ... N - 2 (0 indexed) and count number of hills and valleys. \\n\\nTime Complexity: O(N). Traverse the graph once to make the new array, and once to count the number of peaks and troughs. \\nSpace Complexity: O(N). Insert all elements into new array without adjacent duplicates. \\n\\nC++ Implementation: \\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> v;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(v.size() == 0 || v.back() != nums[i]) v.push_back(nums[i]);\\n        }\\n        int res = 0;\\n        for(int i = 1; i < v.size() - 1; i++){\\n            if(v[i] < v[i - 1] && v[i] < v[i + 1]) res++;\\n            else if(v[i] > v[i - 1] && v[i] > v[i + 1]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> v;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(v.size() == 0 || v.back() != nums[i]) v.push_back(nums[i]);\\n        }\\n        int res = 0;\\n        for(int i = 1; i < v.size() - 1; i++){\\n            if(v[i] < v[i - 1] && v[i] < v[i + 1]) res++;\\n            else if(v[i] > v[i - 1] && v[i] > v[i + 1]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866016,
                "title": "java-linear-time",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n         int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left = arr[i];\\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n         int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left = arr[i];\\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865638,
                "title": "0ms-100-faster-o-n-2-solutions-explained-with-steps",
                "content": "If any questions, please let me know.  I will be updating the step-by-step dry run shortly.\\nIf you liked it, pls **Upvote** :)\\n\\n\\n**Solution 1:** \\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(n)\\n\\n## Dry Run:\\n\\n\\tInitialize res[] =  [\\' \\', \\' \\', \\' \\', \\' \\', \\' \\', \\' \\']\\n\\t\\n\\t                  0  1  2  3  4  5\\n\\t nums[]= \\t     [2, 4, 1, 1, 6, 5]\\n\\ti: 0, res[]:     [ ,  ,  ,  ,  ,  ]\\n\\ti: 1, res[]:     [ , H,  ,  ,  ,  ]               // keep updating \\'res\\' array in each iteration of i\\n\\ti: 2, res[]:     [ , H, v,  ,  ,  ]\\n\\ti: 3, res[]:     [ , H, v, V,  ,  ]\\n\\ti: 4, res[]:     [ , H, v, V, H,  ]\\n\\t\\n\\tNow, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\tSo, return count = 3   (because, H, V, H)\\n\\n## Code:\\n\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tchar[] res = new char[len];\\n\\t\\t\\tArrays.fill(res,\\' \\');\\n\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i-1]){                                                 // if... num at i > num at i-1                      \\n\\t\\t\\t\\t\\tif(nums[i] > nums[i+1]){ res[i] = \\'H\\'; }                                 // also, if num at i > num at i+1. => found Hill. Mark as \\'H\\'   \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'h\\'; }                           // else, if num at i == num at i+1. Then mark as \\'h\\' instead of \\'H\\'. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    // Means, it may or may not be hill, and will be figured out in next steps.\\n\\t\\t\\t\\t}else if( nums[i] < nums[i-1] ){                                         // Else if....\\n\\t\\t\\t\\t\\tif(nums[i] < nums[i+1]){ res[i] = \\'V\\'; }                                 //  means, found Valley. So, mark as \\'V\\' \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'v\\'; }                              // Means, it may or may not be a valley, and will be figured out in next steps.\\n\\t\\t\\t\\t}else{                                                                   // Else.. Here we will figure out if \\'v\\' becomes valley \\'V\\', and if \\'h\\' becomes hill \\'H\\'\\n\\t\\t\\t\\t\\tif( res[i-1] == \\'v\\' && nums[i] < nums[i+1] ){ res[i] = \\'V\\'; }     \\n\\t\\t\\t\\t\\telse if( res[i-1] == \\'h\\' && nums[i] > nums[i+1] ){ res[i] = \\'H\\'; }\\n\\t\\t\\t\\t\\telse{ res[i] = res[i-1]; }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}        \\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){                                              // Now, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\t\\t\\t\\tif(res[i] == \\'H\\' || res[i] == \\'V\\'){ count++; }   \\n\\t\\t\\t}        \\n\\t\\t\\treturn count;\\n\\t\\t}\\n//\\n//\\n//\\n//\\n\\n**Solution 2:**\\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(1)  // constant\\n## Code:\\t\\n    public int countHillValley(int[] nums) {\\n        int count = 0, prev = 0;\\n        \\n\\t\\tfor(int i=1; i<nums.length-1; i++) {\\n\\t\\t\\tif(nums[i] == nums[i+1]){ continue; }                     // if this and next values are equal, we can not yet confirm if there is Hill or Valley.\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif( (nums[i] > nums[prev] && nums[i] > nums[i+1]) || (nums[i] < nums[prev] && nums[i] < nums[i+1]) ){ \\n                    count++; \\n                }\\n\\t\\t\\t\\tprev = i;  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\t\\t\\nIf you liked it, pls **Upvote** :)\\n**NOTE:** I mentioned these 2 solutions keeping **coding interviews** in mind, as it may be better to first give a brute-force or sub optimal solution, and then more optimal solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "If any questions, please let me know.  I will be updating the step-by-step dry run shortly.\\nIf you liked it, pls **Upvote** :)\\n\\n\\n**Solution 1:** \\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(n)\\n\\n## Dry Run:\\n\\n\\tInitialize res[] =  [\\' \\', \\' \\', \\' \\', \\' \\', \\' \\', \\' \\']\\n\\t\\n\\t                  0  1  2  3  4  5\\n\\t nums[]= \\t     [2, 4, 1, 1, 6, 5]\\n\\ti: 0, res[]:     [ ,  ,  ,  ,  ,  ]\\n\\ti: 1, res[]:     [ , H,  ,  ,  ,  ]               // keep updating \\'res\\' array in each iteration of i\\n\\ti: 2, res[]:     [ , H, v,  ,  ,  ]\\n\\ti: 3, res[]:     [ , H, v, V,  ,  ]\\n\\ti: 4, res[]:     [ , H, v, V, H,  ]\\n\\t\\n\\tNow, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\tSo, return count = 3   (because, H, V, H)\\n\\n## Code:\\n\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tchar[] res = new char[len];\\n\\t\\t\\tArrays.fill(res,\\' \\');\\n\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i-1]){                                                 // if... num at i > num at i-1                      \\n\\t\\t\\t\\t\\tif(nums[i] > nums[i+1]){ res[i] = \\'H\\'; }                                 // also, if num at i > num at i+1. => found Hill. Mark as \\'H\\'   \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'h\\'; }                           // else, if num at i == num at i+1. Then mark as \\'h\\' instead of \\'H\\'. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    // Means, it may or may not be hill, and will be figured out in next steps.\\n\\t\\t\\t\\t}else if( nums[i] < nums[i-1] ){                                         // Else if....\\n\\t\\t\\t\\t\\tif(nums[i] < nums[i+1]){ res[i] = \\'V\\'; }                                 //  means, found Valley. So, mark as \\'V\\' \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'v\\'; }                              // Means, it may or may not be a valley, and will be figured out in next steps.\\n\\t\\t\\t\\t}else{                                                                   // Else.. Here we will figure out if \\'v\\' becomes valley \\'V\\', and if \\'h\\' becomes hill \\'H\\'\\n\\t\\t\\t\\t\\tif( res[i-1] == \\'v\\' && nums[i] < nums[i+1] ){ res[i] = \\'V\\'; }     \\n\\t\\t\\t\\t\\telse if( res[i-1] == \\'h\\' && nums[i] > nums[i+1] ){ res[i] = \\'H\\'; }\\n\\t\\t\\t\\t\\telse{ res[i] = res[i-1]; }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}        \\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){                                              // Now, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\t\\t\\t\\tif(res[i] == \\'H\\' || res[i] == \\'V\\'){ count++; }   \\n\\t\\t\\t}        \\n\\t\\t\\treturn count;\\n\\t\\t}\\n//\\n//\\n//\\n//\\n\\n**Solution 2:**\\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(1)  // constant\\n## Code:\\t\\n    public int countHillValley(int[] nums) {\\n        int count = 0, prev = 0;\\n        \\n\\t\\tfor(int i=1; i<nums.length-1; i++) {\\n\\t\\t\\tif(nums[i] == nums[i+1]){ continue; }                     // if this and next values are equal, we can not yet confirm if there is Hill or Valley.\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif( (nums[i] > nums[prev] && nums[i] > nums[i+1]) || (nums[i] < nums[prev] && nums[i] < nums[i+1]) ){ \\n                    count++; \\n                }\\n\\t\\t\\t\\tprev = i;  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\t\\t\\nIf you liked it, pls **Upvote** :)\\n**NOTE:** I mentioned these 2 solutions keeping **coding interviews** in mind, as it may be better to first give a brute-force or sub optimal solution, and then more optimal solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 1865637,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n           \\n            if(nums[i]==nums[i-1]) continue; \\n            int l = nums[i-1];\\n            int r = nums[i+1];\\n            \\n            if(l==nums[i]){\\n                int j = i;\\n                while(j>=0 && nums[j]==l){\\n                    j--;\\n                }\\n                if(j<0) continue;\\n                if(nums[j]==l) continue;\\n                else l = nums[j];\\n            }\\n            if(r==nums[i]){\\n                int j = i;\\n                while(j<nums.size() && nums[j]==r){\\n                    j++;\\n                }\\n                if(j==nums.size()) continue;\\n                if(nums[j]==r) continue;\\n                else r = nums[j];\\n            }\\n            \\n            if(nums[i]>l && nums[i]>r) ans++;\\n            else if(l>nums[i] && r>nums[i]) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n           \\n            if(nums[i]==nums[i-1]) continue; \\n            int l = nums[i-1];\\n            int r = nums[i+1];\\n            \\n            if(l==nums[i]){\\n                int j = i;\\n                while(j>=0 && nums[j]==l){\\n                    j--;\\n                }\\n                if(j<0) continue;\\n                if(nums[j]==l) continue;\\n                else l = nums[j];\\n            }\\n            if(r==nums[i]){\\n                int j = i;\\n                while(j<nums.size() && nums[j]==r){\\n                    j++;\\n                }\\n                if(j==nums.size()) continue;\\n                if(nums[j]==r) continue;\\n                else r = nums[j];\\n            }\\n            \\n            if(nums[i]>l && nums[i]>r) ans++;\\n            else if(l>nums[i] && r>nums[i]) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865633,
                "title": "simople-c-solution-easy-0-n",
                "content": "```\\nint n=nums.size();\\n    int count=0;\\n    for(int i=0;i<n;i++){\\n        int j=i-1;\\n        int k=i+1;\\n        if(i>0 and i<n-1){\\n            if(nums[i]==nums[j]){\\n                continue;\\n            }\\n        }\\n        while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n            if(nums[i]==nums[j])\\n            j--;\\n            if(nums[i]==nums[k])\\n            k++;\\n        }\\n        if(j>=0 and k<n){\\n            if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n            else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n        }\\n    }\\n    return count;\\n```",
                "solutionTags": [],
                "code": "```\\nint n=nums.size();\\n    int count=0;\\n    for(int i=0;i<n;i++){\\n        int j=i-1;\\n        int k=i+1;\\n        if(i>0 and i<n-1){\\n            if(nums[i]==nums[j]){\\n                continue;\\n            }\\n        }\\n        while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n            if(nums[i]==nums[j])\\n            j--;\\n            if(nums[i]==nums[k])\\n            k++;\\n        }\\n        if(j>=0 and k<n){\\n            if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n            else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n        }\\n    }\\n    return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865570,
                "title": "simple-c-solution-with-o-n-tc",
                "content": "\\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int j=i-1;\\n            int k=i+1;\\n            if(i>0 and i<n-1){\\n                if(nums[i]==nums[j]){\\n                    continue;\\n                }\\n            }\\n            while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n                if(nums[i]==nums[j])\\n                j--;\\n                if(nums[i]==nums[k])\\n                k++;\\n            }\\n            if(j>=0 and k<n){\\n                if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n                else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int j=i-1;\\n            int k=i+1;\\n            if(i>0 and i<n-1){\\n                if(nums[i]==nums[j]){\\n                    continue;\\n                }\\n            }\\n            while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n                if(nums[i]==nums[j])\\n                j--;\\n                if(nums[i]==nums[k])\\n                k++;\\n            }\\n            if(j>=0 and k<n){\\n                if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n                else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 3355594,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size(), prev = nums[0], ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            while(i < n && nums[i] == nums[i - 1]) i++;\\n            if(i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev))) {\\n                ans++;\\n            }\\n            prev = nums[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countHillValley(nums []int) int {\\n    var n, prev, ans int = len(nums), nums[0], 0\\n    for i := 1; i < n; i++ {\\n        for i < n && nums[i] == nums[i - 1] {i++}\\n        if i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev)) {\\n            ans++\\n        }\\n        prev = nums[i - 1]\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size(), prev = nums[0], ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            while(i < n && nums[i] == nums[i - 1]) i++;\\n            if(i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev))) {\\n                ans++;\\n            }\\n            prev = nums[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countHillValley(nums []int) int {\\n    var n, prev, ans int = len(nums), nums[0], 0\\n    for i := 1; i < n; i++ {\\n        for i < n && nums[i] == nums[i - 1] {i++}\\n        if i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev)) {\\n            ans++\\n        }\\n        prev = nums[i - 1]\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246224,
                "title": "o-n-tc-o-1-sc-without-filtering",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let res = 0;\\n    let i = 1;\\n    while (i < nums.length - 1) {\\n        const startIndex = i;\\n        if (nums[i] === nums[i + 1]) {\\n            while (nums[i] === nums[i + 1]) i++;\\n        }\\n        const endIndex = i;\\n        if (\\n            nums[startIndex] > nums[startIndex - 1] && nums[endIndex] > nums[endIndex + 1] ||\\n            nums[startIndex] < nums[startIndex - 1] && nums[endIndex] < nums[endIndex + 1]\\n        ) {\\n            res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let res = 0;\\n    let i = 1;\\n    while (i < nums.length - 1) {\\n        const startIndex = i;\\n        if (nums[i] === nums[i + 1]) {\\n            while (nums[i] === nums[i + 1]) i++;\\n        }\\n        const endIndex = i;\\n        if (\\n            nums[startIndex] > nums[startIndex - 1] && nums[endIndex] > nums[endIndex + 1] ||\\n            nums[startIndex] < nums[startIndex - 1] && nums[endIndex] < nums[endIndex + 1]\\n        ) {\\n            res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243372,
                "title": "c-solution-beats-100-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n    vector<int> v;\\n    v.push_back(nums[0]);\\n    for (int i = 1; i < nums.size(); i++)\\n    {\\n        if (nums[i] != nums[i - 1])\\n            v.push_back(nums[i]);\\n    }\\n    int count=0;\\n    int i = 1;\\n    while (i < v.size() - 1)\\n    {\\n        if (v[i] > v[i - 1] && v[i] > v[i + 1])\\n            count++;\\n        else if (v[i] < v[i - 1] && v[i] < v[i + 1])\\n            count++;\\n        i++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n    vector<int> v;\\n    v.push_back(nums[0]);\\n    for (int i = 1; i < nums.size(); i++)\\n    {\\n        if (nums[i] != nums[i - 1])\\n            v.push_back(nums[i]);\\n    }\\n    int count=0;\\n    int i = 1;\\n    while (i < v.size() - 1)\\n    {\\n        if (v[i] > v[i - 1] && v[i] > v[i + 1])\\n            count++;\\n        else if (v[i] < v[i - 1] && v[i] < v[i + 1])\\n            count++;\\n        i++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170115,
                "title": "hills-and-valleys-js-splice-easy-to-undestand-w-comments",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let sum = 0                                                 //store sum of hills and valleys\\n    for (let i = 1; i < nums.length - 1; i++) {                 //loop all nums except fist / last\\n        while (nums[i+1] == nums[i])                            //remove same elements in nums\\n            nums.splice(i + 1, 1)                          \\n        if ( nums[i] > nums[i - 1] &&  nums[i] > nums[i + 1] )  //if hill? -> sum ++\\n            sum ++\\n        if ( nums[i] < nums[i - 1] &&  nums[i] < nums[i + 1] )  //if valley? -> sum ++  \\n            sum ++        \\n    }\\n    return sum          //return sum of hills and valleys\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let sum = 0                                                 //store sum of hills and valleys\\n    for (let i = 1; i < nums.length - 1; i++) {                 //loop all nums except fist / last\\n        while (nums[i+1] == nums[i])                            //remove same elements in nums\\n            nums.splice(i + 1, 1)                          \\n        if ( nums[i] > nums[i - 1] &&  nums[i] > nums[i + 1] )  //if hill? -> sum ++\\n            sum ++\\n        if ( nums[i] < nums[i - 1] &&  nums[i] < nums[i + 1] )  //if valley? -> sum ++  \\n            sum ++        \\n    }\\n    return sum          //return sum of hills and valleys\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2732107,
                "title": "two-pointers-python",
                "content": "Two pointers (Python solution)\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left, right = 1, 2\\n        total = 0\\n        while right < len(nums):\\n            if nums[left] != nums[right]:\\n                if (nums[left-1] < nums[left] and nums[right] < nums[left]) or (nums[left-1] > nums[left] and nums[right] > nums[left]):\\n                    total += 1\\n                left = right\\n            right += 1\\n        return total\\n```\\nThis is my first post. Please give me feedback about it. Cheers!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left, right = 1, 2\\n        total = 0\\n        while right < len(nums):\\n            if nums[left] != nums[right]:\\n                if (nums[left-1] < nums[left] and nums[right] < nums[left]) or (nums[left-1] > nums[left] and nums[right] > nums[left]):\\n                    total += 1\\n                left = right\\n            right += 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663165,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left = None\\n        right = None\\n        total = 0\\n        for i in range(1, len(nums)-1):\\n\\n            if nums[i] == nums[i+1]:\\n                continue\\n            for j in range(-i+1,1):\\n\\n                if nums[-j] < nums[i]:\\n                    \\n                    left = 0\\n                    break\\n                elif nums[-j] > nums[i]:\\n                    left = 1\\n                    break\\n                else:\\n                    continue\\n            for k in range(i+1,len(nums)):\\n\\n                if nums[k] < nums[i]:\\n                    right = 0\\n                    break\\n                elif nums[k] > nums[i]:\\n                    right = 1\\n                    break\\n                else:\\n                    continue\\n\\n            if left == right:\\n                total += 1\\n\\n        return total\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left = None\\n        right = None\\n        total = 0\\n        for i in range(1, len(nums)-1):\\n\\n            if nums[i] == nums[i+1]:\\n                continue\\n            for j in range(-i+1,1):\\n\\n                if nums[-j] < nums[i]:\\n                    \\n                    left = 0\\n                    break\\n                elif nums[-j] > nums[i]:\\n                    left = 1\\n                    break\\n                else:\\n                    continue\\n            for k in range(i+1,len(nums)):\\n\\n                if nums[k] < nums[i]:\\n                    right = 0\\n                    break\\n                elif nums[k] > nums[i]:\\n                    right = 1\\n                    break\\n                else:\\n                    continue\\n\\n            if left == right:\\n                total += 1\\n\\n        return total\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647858,
                "title": "c-fastest-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& n) {\\n        int a=n.size();\\n        int b=0;\\n        for(int i=0;i<a-1;i++)\\n        {\\n            if(n[i]==n[i+1])\\n            {\\n                n.erase(n.begin()+i);\\n                i=i-1;\\n                a=a-1;\\n            }\\n        }\\n        for(int i=1;i<a-1;i++)\\n        {\\n            if((n[i]>n[i-1]&&n[i]>n[i+1])||(n[i]<n[i-1]&&n[i]<n[i+1]))\\n            {\\n                b++;\\n            }\\n        }\\n        return b;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& n) {\\n        int a=n.size();\\n        int b=0;\\n        for(int i=0;i<a-1;i++)\\n        {\\n            if(n[i]==n[i+1])\\n            {\\n                n.erase(n.begin()+i);\\n                i=i-1;\\n                a=a-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2623247,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;)\\n        {\\n            int num=nums[i];\\n            int idx1=i+1;\\n            int idx2=i-1;\\n            while(idx1<nums.size() and nums[idx1]==num)\\n            {\\n                idx1++;\\n            }\\n            while(idx2>0 and nums[idx2]==num)\\n            {\\n                idx2--;\\n            }\\n            if(idx1==nums.size() || idx2<0)\\n            {\\n                break;\\n            }\\n            if((nums[i]<nums[idx1] and nums[i]<nums[idx2]) || (nums[i]>nums[idx1] and nums[i]>nums[idx2]))\\n            {\\n                ans++;\\n            }\\n            i=idx1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;)\\n        {\\n            int num=nums[i];\\n            int idx1=i+1;\\n            int idx2=i-1;\\n            while(idx1<nums.size() and nums[idx1]==num)\\n            {\\n                idx1++;\\n            }\\n            while(idx2>0 and nums[idx2]==num)\\n            {\\n                idx2--;\\n            }\\n            if(idx1==nums.size() || idx2<0)\\n            {\\n                break;\\n            }\\n            if((nums[i]<nums[idx1] and nums[i]<nums[idx2]) || (nums[i]>nums[idx1] and nums[i]>nums[idx2]))\\n            {\\n                ans++;\\n            }\\n            i=idx1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567837,
                "title": "easy-java-solution-beginner-friendly-simple",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 1;i < n-1; i ++){\\n\\t\\t\\t//assigning the immediate left from the index i\\n            int left = i-1;\\n\\t\\t\\t//assigning the immediate right from the index i\\n            int right = i+1;\\n\\t\\t\\t//Searching for the closest neighbour at the left whose value not equal to the ith index\\n            while(left != 0 && nums[left] == nums[i]){\\n                left--;\\n            }\\n\\t\\t\\t//Searching for the closest neighbour at the right whose value not equal to the ith index and not equal to the left closest neighbour\\n            while(right != n && nums[right] == nums[i] && nums[left] == nums[right]){\\n                right++;\\n            }\\n\\t\\t\\t//checking if any of the left and right index does meet the closest neighbour\\n            if(left == -1 || right == n){\\n                continue;\\n            }\\n\\t\\t\\t//check if its a hill\\n            if(nums[i] > nums[left] && nums[i] > nums[right]){\\n                count++;\\n\\t\\t\\t\\t//if its a hill no need to check if its valley or not\\n                continue;\\n            }\\n\\t\\t\\t//check if its a valley\\n            if(nums[i] < nums[left] && nums[i] < nums[right]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 1;i < n-1; i ++){\\n\\t\\t\\t//assigning the immediate left from the index i\\n            int left = i-1;\\n\\t\\t\\t//assigning the immediate right from the index i\\n            int right = i+1;\\n\\t\\t\\t//Searching for the closest neighbour at the left whose value not equal to the ith index\\n            while(left != 0 && nums[left] == nums[i]){\\n                left--;\\n            }\\n\\t\\t\\t//Searching for the closest neighbour at the right whose value not equal to the ith index and not equal to the left closest neighbour\\n            while(right != n && nums[right] == nums[i] && nums[left] == nums[right]){\\n                right++;\\n            }\\n\\t\\t\\t//checking if any of the left and right index does meet the closest neighbour\\n            if(left == -1 || right == n){\\n                continue;\\n            }\\n\\t\\t\\t//check if its a hill\\n            if(nums[i] > nums[left] && nums[i] > nums[right]){\\n                count++;\\n\\t\\t\\t\\t//if its a hill no need to check if its valley or not\\n                continue;\\n            }\\n\\t\\t\\t//check if its a valley\\n            if(nums[i] < nums[left] && nums[i] < nums[right]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551677,
                "title": "java-o-n-with-explanation",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tif(nums.length<=2) return 0;\\n\\t\\t\\tint pre = nums[0]; // record the previous num \\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tfor(int i=1; i<nums.length-1; ++i){\\n\\t\\t\\t\\tif(nums[i] == nums[i-1]) continue; // find a duplicate, which could be in the same hills or valley as the previous number, we just ignore \\n\\n\\t\\t\\t\\tint cur=nums[i]; // record current num \\n\\t\\t\\t\\tint next=nums[i+1];// record the next num \\n\\t\\t\\t\\tint j=i+1; \\n\\n\\t\\t\\t\\twhile(next==cur){ // if next == cur, we have to skip it \\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tif(j>nums.length-1)break; // if next > nums.length-1, we run out of number; \\n\\t\\t\\t\\t\\tnext = nums[j]; // we find a valid number \\n\\t\\t\\t\\t\\ti=j-1; // i should jump to the last duplicate number of cur \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif((pre<cur && cur>next) || (pre>cur && next>cur)){ // compute hills or valley \\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tpre = cur; // relocate pre \\n\\t\\t\\t}\\n\\t\\t\\treturn res; \\n\\t\\t}\\n\\t}\\n\\n\\t// time O(n)\\n\\t// space O(1)",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tif(nums.length<=2) return 0;\\n\\t\\t\\tint pre = nums[0]; // record the previous num \\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tfor(int i=1; i<nums.length-1; ++i){\\n\\t\\t\\t\\tif(nums[i] == nums[i-1]) continue; // find a duplicate, which could be in the same hills or valley as the previous number, we just ignore \\n\\n\\t\\t\\t\\tint cur=nums[i]; // record current num \\n\\t\\t\\t\\tint next=nums[i+1];// record the next num \\n\\t\\t\\t\\tint j=i+1; \\n\\n\\t\\t\\t\\twhile(next==cur){ // if next == cur, we have to skip it \\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tif(j>nums.length-1)break; // if next > nums.length-1, we run out of number; \\n\\t\\t\\t\\t\\tnext = nums[j]; // we find a valid number \\n\\t\\t\\t\\t\\ti=j-1; // i should jump to the last duplicate number of cur \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2501526,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    public int countHillValley(int[] nums) {\\n        int len = nums.length - 1;\\n        int temp = nums[0];\\n        int count = 0;\\n\\t\\t\\n        for (int i = 1; i < len; i++) {\\n            while (i < len && nums[i] == nums[i+1]) i++;\\n            if (i < len && isHillsOrValleys(temp, nums[i], nums[i+1])) count++;\\n            temp = nums[i];\\n        }\\n        return count;\\n    }\\n    \\n    private boolean isHillsOrValleys(int left, int mid, int right){\\n        return (left > mid && mid < right) || (left < mid && mid > right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2461987,
                "title": "java-solution-1ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int cnt = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            if (arr[i] == arr[i-1]) continue;\\n            if (arr[i] == arr[i+1]) {\\n                int right = getRight(arr, i), left = getLeft(arr, i);\\n                if (right == -1 || left == -1) continue;\\n                if (left > arr[i]) {\\n                    if (arr[i] < right) cnt++;\\n                }\\n                else if (left < arr[i]) {\\n                    if (arr[i] > right) cnt++;\\n                }\\n            }\\n            else if (arr[i-1] > arr[i]) {\\n                if (arr[i] < arr[i+1]) cnt++;\\n            }\\n            else if (arr[i-1] < arr[i]) {\\n                if (arr[i] > arr[i+1]) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    private static int getLeft(int[] arr, int i) {\\n        for (int k = i-1; k >= 0; k--) {\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n\\n    private static int getRight(int[] arr, int i) {\\n        for (int k = i+1; k < arr.length; k++){\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int cnt = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            if (arr[i] == arr[i-1]) continue;\\n            if (arr[i] == arr[i+1]) {\\n                int right = getRight(arr, i), left = getLeft(arr, i);\\n                if (right == -1 || left == -1) continue;\\n                if (left > arr[i]) {\\n                    if (arr[i] < right) cnt++;\\n                }\\n                else if (left < arr[i]) {\\n                    if (arr[i] > right) cnt++;\\n                }\\n            }\\n            else if (arr[i-1] > arr[i]) {\\n                if (arr[i] < arr[i+1]) cnt++;\\n            }\\n            else if (arr[i-1] < arr[i]) {\\n                if (arr[i] > arr[i+1]) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    private static int getLeft(int[] arr, int i) {\\n        for (int k = i-1; k >= 0; k--) {\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n\\n    private static int getRight(int[] arr, int i) {\\n        for (int k = i+1; k < arr.length; k++){\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435109,
                "title": "q2210-accepted-c-sol-using-two-methods-easy-simple",
                "content": "Solution 1 Using Vector Extra Space\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=0;\\n        int a=0;\\n        for(int i=1;i<n-1;i++){\\n            if((nums[i]>nums[j] && nums[i]>nums[i+1])|| \\n               (nums[j]>nums[i] && nums[i]<nums[i+1])){\\n                a++;\\n                j=i;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\\nSolution 2 Using Two Pointer Approach\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v;\\n        v.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n            if(nums[i]!=nums[i-1])\\n                v.push_back(nums[i]);\\n        int a=0;\\n        for(int i=1;i<v.size()-1;i++){\\n            if((v[i]>v[i-1] && v[i]>v[i+1])||(v[i]<v[i-1] && v[i]<v[i+1]))\\n                a++;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=0;\\n        int a=0;\\n        for(int i=1;i<n-1;i++){\\n            if((nums[i]>nums[j] && nums[i]>nums[i+1])|| \\n               (nums[j]>nums[i] && nums[i]<nums[i+1])){\\n                a++;\\n                j=i;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v;\\n        v.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n            if(nums[i]!=nums[i-1])\\n                v.push_back(nums[i]);\\n        int a=0;\\n        for(int i=1;i<v.size()-1;i++){\\n            if((v[i]>v[i-1] && v[i]>v[i+1])||(v[i]<v[i-1] && v[i]<v[i+1]))\\n                a++;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411775,
                "title": "java-easy-one",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length;i++){\\n            int l=i-1;\\n            int r=i+1;\\n            while(l>=0 && nums[l]==nums[i]) l--;\\n            while(r<nums.length && nums[r]==nums[i]) r++;\\n            if(l<0 || r>=nums.length) continue;\\n            if(nums[i]==nums[i+1]) continue;\\n            if(nums[i]>nums[l] && nums[i]>nums[r]) c++;\\n            if(nums[i]<nums[l] && nums[i]<nums[r]) c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length;i++){\\n            int l=i-1;\\n            int r=i+1;\\n            while(l>=0 && nums[l]==nums[i]) l--;\\n            while(r<nums.length && nums[r]==nums[i]) r++;\\n            if(l<0 || r>=nums.length) continue;\\n            if(nums[i]==nums[i+1]) continue;\\n            if(nums[i]>nums[l] && nums[i]>nums[r]) c++;\\n            if(nums[i]<nums[l] && nums[i]<nums[r]) c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316611,
                "title": "simple-traverse-c",
                "content": "**Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = nums[0];\\n        int hills = 0 , valleys = 0;\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i]==last){\\n                last = nums[i];\\n                continue;\\n            }\\n            \\n            if(nums[i]>last && nums[i]>nums[i+1])\\n                hills++ , last = nums[i];\\n            else if(nums[i]<last && nums[i]<nums[i+1])\\n                valleys++ , last = nums[i];\\n            \\n        }\\n        \\n        return hills+valleys;\\n    }\\n};\\n```\\n\\nThank You!",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = nums[0];\\n        int hills = 0 , valleys = 0;\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i]==last){\\n                last = nums[i];\\n                continue;\\n            }\\n            \\n            if(nums[i]>last && nums[i]>nums[i+1])\\n                hills++ , last = nums[i];\\n            else if(nums[i]<last && nums[i]<nums[i+1])\\n                valleys++ , last = nums[i];\\n            \\n        }\\n        \\n        return hills+valleys;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279305,
                "title": "easy-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]>prev && nums[i]>nums[i+1] || nums[i]<prev && nums[i]<nums[i+1]){\\n                count++;\\n                prev=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]>prev && nums[i]>nums[i+1] || nums[i]<prev && nums[i]<nums[i+1]){\\n                count++;\\n                prev=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242017,
                "title": "java-1-ms-o-n-explained",
                "content": "**The Idea:\\n~ - ~ - ~ -**\\n\\nCreate a \"slopes\" array, in the following manner --->\\n**The first identical digits in nums, will be noted as -1 in the slopes array.**\\nWhen digit is greater than the previous, the \"slope\" will be noted as **1**.\\nWhen digit is smaller than the previous, the \"slope\" will be noted as **0**.\\nWhen digit is equals to the previous, the \"slope\" will be noted **as the previous slope.**\\n\\nThe trick is to count how many times the slope changes, **as long as it not equlas -1.**\\n(Meaning ---> we ignore the beginning).\\n\\nExample:\\n~ - ~ - ~ -\\n\\nArray: >>>>>>>>>>>>>>>>>>>>>>>>>> { 1, 1, 1,  1, 1, 1, 1, 57, 57, 57, 50, 50, 50, 50, 22, 22, 22, 86 }\\nIts corresponding slopes array would be: { -1, -1,-1,-1,-1,-1,-1 ,1   ,1,   1  **(x)**  ,0   ,0  ,0    ,0   ,0   ,0   ,0  **(x)** ,1 }\\nNumber of slope changes (each change designated with x) is **2**.\\n\\nMore examples:\\n~ - ~ - ~ - ~ - ~ -\\n\\n{  6,  5,     10 }\\n{ -1,  0, **(x)** 1 }\\nNumber of slope changes (each change designated with x) is **1**.\\n\\n{ 8, 2,      5, 7, 7,       2,    10,      3,      6,      2}\\n{-1, 0, **(x)** 1, 1, 1, **(x)** 0, **(x)** 1, **(x)** 0, **(x)** 1, **(x)** 0}\\nNumber of slope changes (each change designated with x) is **6**.\\n\\n { 6, 6, 5, 5, 4, 1 }\\n {-1,-1, 0, 0, 0, 0 }\\nNumber of slope changes (each change designated with x) is **0**.\\n\\n{  2, 4,      1, 1,       6,      5 }\\n{ -1, 1, **(x)** 0, 0, **(x)** 1, **(x)** 0 }\\nNumber of slope changes (each change designated with x) is **3**.\\n\\n    public int countHillValley(int[] nums) {\\n        int counter = 0, previous = -1;\\n        int[] slopes = new int[nums.length];\\n        slopes[0] = -1;\\n\\n        if (nums[0] < nums[1]) slopes[1] = 1;\\n        else if (nums[0] > nums[1]) slopes[1] = 0;\\n        else slopes[1] = -1;\\n\\n        for (int i = 2; i < nums.length; i++)\\n            if (nums[i] == nums[i - 1]) slopes[i] = slopes[i - 1];\\n            else if (nums[i] > nums[i - 1]) slopes[i] = 1;\\n            else slopes[i] = 0;\\n\\n        for (int i = 1; i < slopes.length; i++) {\\n            if (previous != -1 && slopes[i] != previous)\\n                counter++;\\n\\n            previous = slopes[i];\\n        }\\n\\n        return counter;\\n    }\\n\\nPlease **upvote** if you liked to solution :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "**The Idea:\\n~ - ~ - ~ -**\\n\\nCreate a \"slopes\" array, in the following manner --->\\n**The first identical digits in nums, will be noted as -1 in the slopes array.**\\nWhen digit is greater than the previous, the \"slope\" will be noted as **1**.\\nWhen digit is smaller than the previous, the \"slope\" will be noted as **0**.\\nWhen digit is equals to the previous, the \"slope\" will be noted **as the previous slope.**\\n\\nThe trick is to count how many times the slope changes, **as long as it not equlas -1.**\\n(Meaning ---> we ignore the beginning).\\n\\nExample:\\n~ - ~ - ~ -\\n\\nArray: >>>>>>>>>>>>>>>>>>>>>>>>>> { 1, 1, 1,  1, 1, 1, 1, 57, 57, 57, 50, 50, 50, 50, 22, 22, 22, 86 }\\nIts corresponding slopes array would be: { -1, -1,-1,-1,-1,-1,-1 ,1   ,1,   1  **(x)**  ,0   ,0  ,0    ,0   ,0   ,0   ,0  **(x)** ,1 }\\nNumber of slope changes (each change designated with x) is **2**.\\n\\nMore examples:\\n~ - ~ - ~ - ~ - ~ -\\n\\n{  6,  5,     10 }\\n{ -1,  0, **(x)** 1 }\\nNumber of slope changes (each change designated with x) is **1**.\\n\\n{ 8, 2,      5, 7, 7,       2,    10,      3,      6,      2}\\n{-1, 0, **(x)** 1, 1, 1, **(x)** 0, **(x)** 1, **(x)** 0, **(x)** 1, **(x)** 0}\\nNumber of slope changes (each change designated with x) is **6**.\\n\\n { 6, 6, 5, 5, 4, 1 }\\n {-1,-1, 0, 0, 0, 0 }\\nNumber of slope changes (each change designated with x) is **0**.\\n\\n{  2, 4,      1, 1,       6,      5 }\\n{ -1, 1, **(x)** 0, 0, **(x)** 1, **(x)** 0 }\\nNumber of slope changes (each change designated with x) is **3**.\\n\\n    public int countHillValley(int[] nums) {\\n        int counter = 0, previous = -1;\\n        int[] slopes = new int[nums.length];\\n        slopes[0] = -1;\\n\\n        if (nums[0] < nums[1]) slopes[1] = 1;\\n        else if (nums[0] > nums[1]) slopes[1] = 0;\\n        else slopes[1] = -1;\\n\\n        for (int i = 2; i < nums.length; i++)\\n            if (nums[i] == nums[i - 1]) slopes[i] = slopes[i - 1];\\n            else if (nums[i] > nums[i - 1]) slopes[i] = 1;\\n            else slopes[i] = 0;\\n\\n        for (int i = 1; i < slopes.length; i++) {\\n            if (previous != -1 && slopes[i] != previous)\\n                counter++;\\n\\n            previous = slopes[i];\\n        }\\n\\n        return counter;\\n    }\\n\\nPlease **upvote** if you liked to solution :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2167204,
                "title": "python-lists-very-easy-to-follow",
                "content": "```\\n def countHillValley(self, nums: List[int]) -> int:\\n        nn=nums.copy()\\n        i = 1\\n        while i < len(nn) and len(nn) > 0:\\n            if nn[i] == nn[i-1]:\\n                nn.pop(i)\\n            else:\\n                i+=1\\n                   \\n        i = 1\\n        count = 0\\n        while i < len(nn)-1:\\n            if nn[i] > nn[i-1] and nn[i] > nn[i+1]:                \\n                count+= 1\\n                i+=1\\n            elif nn[i] < nn[i-1] and nn[i] < nn[i+1]:                \\n                count+= 1\\n                i+=1           \\n            else:                \\n                i+=1\\n                \\n        \\n        return count",
                "solutionTags": [],
                "code": "```\\n def countHillValley(self, nums: List[int]) -> int:\\n        nn=nums.copy()\\n        i = 1\\n        while i < len(nn) and len(nn) > 0:\\n            if nn[i] == nn[i-1]:\\n                nn.pop(i)\\n            else:\\n                i+=1\\n                   \\n        i = 1\\n        count = 0\\n        while i < len(nn)-1:\\n            if nn[i] > nn[i-1] and nn[i] > nn[i+1]:                \\n                count+= 1\\n                i+=1\\n            elif nn[i] < nn[i-1] and nn[i] < nn[i+1]:                \\n                count+= 1\\n                i+=1           \\n            else:                \\n                i+=1\\n                \\n        \\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2136198,
                "title": "explained-with-comments-no-extra-space-easy-to-understand-c",
                "content": "**A VERY EASY WAY TO HANDLE DUPLICATES IS TO REPLACE FIRST DUPLICATE WITH IT\\'S PREVIOUS ELEMENT THUS TENDING TO NORMAL CASE!**\\n```\\n  int countHillValley(vector<int>& nums) {\\n        int hv=0;   //hv for total number of hills and valley\\n        int mid=1;     //will do start from index 1 as no need to check for 0th index\\n        while(mid<(nums.size()-1))   //will end with size-2 because last element does not make a hill or valley\\n        {\\n            if((nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) || (nums[mid]<nums[mid-1] && nums[mid]<nums[mid+1])) //just put conditions over there for hills and valley\\n                hv++;\\n            else{\\n                if(nums[mid]==nums[mid+1])     //for same element \\n                   nums[mid]= nums[mid-1];       //updating duplicate element with its previous one\\n                }   \\n            mid++;\\n        }\\n        return hv;\\n    }\\n\\t```\\n\\t**PLEASE DO UPVOTE IF YOU UNDERSTAND THE SOLUTION**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int countHillValley(vector<int>& nums) {\\n        int hv=0;   //hv for total number of hills and valley\\n        int mid=1;     //will do start from index 1 as no need to check for 0th index\\n        while(mid<(nums.size()-1))   //will end with size-2 because last element does not make a hill or valley\\n        {\\n            if((nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) || (nums[mid]<nums[mid-1] && nums[mid]<nums[mid+1])) //just put conditions over there for hills and valley\\n                hv++;\\n            else{\\n                if(nums[mid]==nums[mid+1])     //for same element \\n                   nums[mid]= nums[mid-1];       //updating duplicate element with its previous one\\n                }   \\n            mid++;\\n        }\\n        return hv;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064402,
                "title": "java-1ms-alternative-solution",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. For each index 1 .. n-2 try to expand a search window with 2 indexes: left and right.\\n        2. while (i >= 0 and nums[left] == nums[i]) left--;\\n           while (right < nums.length and nums[right] == nums[i]) right++;\\n           EG: [3,1,1,1,1,17];\\n             #1 step 1 will start from index 1\\n             #2 a. first while will stop at 3 since it\\'s the first index != nums[1]\\n                b. second while will stop at 17 since it\\'s the first index != nums[i];\\n        3. If right >= nums.length break immediately as all the numbers are equal and no hill/valley can exist\\n        4. If left >= 0, check if you have a valley or hill between nums[left], nums[i], nums[right].\\n           If yes, increment the count\\n        5. Our index will be updated with the right index, as this is the first non equal i index. \\n           Everything between i and right will be part of the same hill or valley.\\n    */\\n    public int countHillValley(int[] nums) {\\n        int hillsAndValleys = 0;\\n        int i = 0;\\n        int left, right;\\n        while (i < nums.length -1) {\\n            left = i -1;\\n            right = i +1;\\n            while(left >= 0 && nums[left] == nums[i]) {\\n                left--;\\n            }\\n            while(right < nums.length && nums[right] == nums[i]) {\\n                right++;\\n            }\\n            if (right == nums.length) {\\n                break;\\n            }\\n            if (left >= 0) {\\n                if ((nums[left] < nums[i] && nums[i] > nums[right]) || \\n                    (nums[left] > nums[i] && nums[i] < nums[right])) {\\n                    hillsAndValleys++;\\n                }\\n            }\\n            i = right;\\n        }\\n        return hillsAndValleys;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. For each index 1 .. n-2 try to expand a search window with 2 indexes: left and right.\\n        2. while (i >= 0 and nums[left] == nums[i]) left--;\\n           while (right < nums.length and nums[right] == nums[i]) right++;\\n           EG: [3,1,1,1,1,17];\\n             #1 step 1 will start from index 1\\n             #2 a. first while will stop at 3 since it\\'s the first index != nums[1]\\n                b. second while will stop at 17 since it\\'s the first index != nums[i];\\n        3. If right >= nums.length break immediately as all the numbers are equal and no hill/valley can exist\\n        4. If left >= 0, check if you have a valley or hill between nums[left], nums[i], nums[right].\\n           If yes, increment the count\\n        5. Our index will be updated with the right index, as this is the first non equal i index. \\n           Everything between i and right will be part of the same hill or valley.\\n    */\\n    public int countHillValley(int[] nums) {\\n        int hillsAndValleys = 0;\\n        int i = 0;\\n        int left, right;\\n        while (i < nums.length -1) {\\n            left = i -1;\\n            right = i +1;\\n            while(left >= 0 && nums[left] == nums[i]) {\\n                left--;\\n            }\\n            while(right < nums.length && nums[right] == nums[i]) {\\n                right++;\\n            }\\n            if (right == nums.length) {\\n                break;\\n            }\\n            if (left >= 0) {\\n                if ((nums[left] < nums[i] && nums[i] > nums[right]) || \\n                    (nums[left] > nums[i] && nums[i] < nums[right])) {\\n                    hillsAndValleys++;\\n                }\\n            }\\n            i = right;\\n        }\\n        return hillsAndValleys;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061606,
                "title": "approach-using-3-pointers-basic-level-logic-beats-100-submissions-0ms",
                "content": "Basic approach: \\nPointers:\\nInitially, \\'prev\\' will point to 0th index\\n\\'current\\' will point to first index, \\n\\'next\\' will point to second index,\\n\\'count\\' to count hills & valleys\\n\\nLoop till your \\'next\\' reached last index.\\n\\n* (EQUAL NEIGHBOURS) check if your values in current is same as next, if yes , move \\'current\\' and \\'next\\' to +1 index and skip the iteration using continue;\\n* (NON EQUAL NEIGHBOURS-VALLEY) If your current value is less than both \\'prev\\' and \\'next\\', increase your count+1\\n* (NON EQUAL NEIGHBOURS-HILL) If your current value is greater than both \\'prev\\' and \\'next\\', increase your count+1\\n* Finally, make \\'prev\\' index to current, \\'current\\' index to next, and increase next+1; \\n\\nNOTE: You can reduce your space complexity by using i+1 instead of defining \\'next\\', but then you have to make amendments to your algorithm. \\n\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=0;\\n        int next=2;\\n        int current=1;\\n        while(next<nums.length)\\n        {\\n            if(nums[current]==nums[next])\\n            {  \\n             current+=1;next+=1;\\n             continue;\\n            }\\n            \\n            else\\n            {    \\n            if(nums[prev]>nums[current] && nums[next]>nums[current])\\n            {   \\n                count++;\\n                \\n            }\\n            else if(nums[prev]<nums[curent] && nums[next]<nums[current])\\n            {   \\n                count++; \\n             }\\n            }\\n            prev=current;current=next;next++;\\n            \\n            \\n        }\\n        return(count);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=0;\\n        int next=2;\\n        int current=1;\\n        while(next<nums.length)\\n        {\\n            if(nums[current]==nums[next])\\n            {  \\n             current+=1;next+=1;\\n             continue;\\n            }\\n            \\n            else\\n            {    \\n            if(nums[prev]>nums[current] && nums[next]>nums[current])\\n            {   \\n                count++;\\n                \\n            }\\n            else if(nums[prev]<nums[curent] && nums[next]<nums[current])\\n            {   \\n                count++; \\n             }\\n            }\\n            prev=current;current=next;next++;\\n            \\n            \\n        }\\n        return(count);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046453,
                "title": "java-0ms-beats-100-dp-approach-with-three-variables",
                "content": "My dynamic programming approach used three values (`left`, `mid`, and `right`) to track the elevation values in the array. `right` represented the current array value, and `mid` and `left` were updated as appropriate to reflect the previous elevation trend. \\n\\n<table>\\n<tr ><th>`left`</th><th>`mid`</th><th>`right`</th><th>Value Diagram</th><th>Meaning</th></tr>\\n<tr><td>low</td><td>high</td><td>low</td><td style=\"text-align: center;\">__\\u203E\\u203E__</td><td>hill</td></tr>\\n<tr><td>high</td><td>low</td><td>high</td><td style=\"text-align: center;\">\\u203E\\u203E__\\u203E\\u203E</td><td>valley</td></tr>\\n<tr><td>low</td><td>equal or lower than `left`</td><td>equal or lower than `mid`</td><td style=\"text-align: center;\">\\u203E\\u203E\\u23AF__</td><td>non-increasing trend</td></tr>\\n<tr><td>high</td><td>equal or higher than `left`</td><td>equal or higher than `mid`</td><td style=\"text-align: center;\">__\\u23AF\\u203E\\u203E</td><td>non-decreasing trend</td></tr>\\n</table>\\n\\n```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Count Hills and Valleys in an Array.\\nMemory Usage: 40.2 MB, less than 93.01% of Java online submissions for Count Hills and Valleys in an Array.\\nElapsed dev time: 0h:24m\\n*/\\n\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int numHillsValleys = 0;  // what we\\'ll return\\n        \\n        int left = nums[0];\\n        int mid = nums[0];\\n        int right = nums[0];\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            \\n            right = nums[i];\\n            \\n            // case: found valley\\n            if (left > mid && mid < right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-increasing slope\\n            if (left >= mid && mid >= right) {\\n                mid = right;  // update mid\\n            }\\n            // case: found hill\\n            if (left < mid && mid > right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-decreasing slope\\n            if (left <= mid && mid <= right) {\\n                mid = right;  // update mid\\n            }\\n        }\\n        \\n        return numHillsValleys;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Count Hills and Valleys in an Array.\\nMemory Usage: 40.2 MB, less than 93.01% of Java online submissions for Count Hills and Valleys in an Array.\\nElapsed dev time: 0h:24m\\n*/\\n\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int numHillsValleys = 0;  // what we\\'ll return\\n        \\n        int left = nums[0];\\n        int mid = nums[0];\\n        int right = nums[0];\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            \\n            right = nums[i];\\n            \\n            // case: found valley\\n            if (left > mid && mid < right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-increasing slope\\n            if (left >= mid && mid >= right) {\\n                mid = right;  // update mid\\n            }\\n            // case: found hill\\n            if (left < mid && mid > right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-decreasing slope\\n            if (left <= mid && mid <= right) {\\n                mid = right;  // update mid\\n            }\\n        }\\n        \\n        return numHillsValleys;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989771,
                "title": "c-easy-o-n-solution-with-full-explanation",
                "content": "Hey all..\\nI have solved this using 3 Methods in cpp using two pointers and basic traversing and counting.\\nI have commented in the code so that it can be useful..\\nIf you have any doubts be free to ask..\\nand please upvote if you understood or found it useful :)\\n\\nThank you..\\n```\\n// Method 1:- Removing adjacent duplicates and finding.\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n\\t\\t// Creating a new vector to store elements with no adjacency duplicates.\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//Traversing vector to remove adjacent duplicates.\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n\\t\\t// Adding last element because it was missing in the traversal.\\n        if(nums[n-2]!=nums[n-1]){\\n            ans.push_back(nums[n-1]);\\n        }\\n        \\n\\t\\t//If new vector formed has no elements means its monotonic(Increasing or decreasing or all elements are same)\\n        int l=ans.size();\\n        if(l==0 or l==1){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//This is to just check normally any valley or hill appears in new vector and incrementing every time we get it.\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i]<ans[i-1] and ans[i]<ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n            if(ans[i]>ans[i-1] and ans[i]>ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n        }\\n        return count;\\n\\n\\n// Method 2:- Same as method 1,but tricky one..\\n           int hills =0;\\n           int valleys = 0;\\n           for(int i=1;i<nums.size()-1;i++){\\n               if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n                   hills++;\\n               else if(nums[i-1]>nums[i] && nums[i]<nums[i+1])\\n                   valleys++;\\n\\t\\t\\t  // Same above method,but in this if we find any adjacent duplicates,we just replace first duplicate one by its previous element.\\n              else nums[i]=nums[i-1];\\n           }\\n           return hills+valleys;\\n        \\n// Method 3 :- Two pointers\\n      int countHillValley(vector<int>& nums) {\\n           int count = 0;\\n           for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n           if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n               (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n               ++count;\\n               j = i;\\n           }            \\n           return count;\\n          }\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n// Method 1:- Removing adjacent duplicates and finding.\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n\\t\\t// Creating a new vector to store elements with no adjacency duplicates.\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//Traversing vector to remove adjacent duplicates.\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n\\t\\t// Adding last element because it was missing in the traversal.\\n        if(nums[n-2]!=nums[n-1]){\\n            ans.push_back(nums[n-1]);\\n        }\\n        \\n\\t\\t//If new vector formed has no elements means its monotonic(Increasing or decreasing or all elements are same)\\n        int l=ans.size();\\n        if(l==0 or l==1){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//This is to just check normally any valley or hill appears in new vector and incrementing every time we get it.\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i]<ans[i-1] and ans[i]<ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n            if(ans[i]>ans[i-1] and ans[i]>ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n        }\\n        return count;\\n\\n\\n// Method 2:- Same as method 1,but tricky one..\\n           int hills =0;\\n           int valleys = 0;\\n           for(int i=1;i<nums.size()-1;i++){\\n               if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n                   hills++;\\n               else if(nums[i-1]>nums[i] && nums[i]<nums[i+1])\\n                   valleys++;\\n\\t\\t\\t  // Same above method,but in this if we find any adjacent duplicates,we just replace first duplicate one by its previous element.\\n              else nums[i]=nums[i-1];\\n           }\\n           return hills+valleys;\\n        \\n// Method 3 :- Two pointers\\n      int countHillValley(vector<int>& nums) {\\n           int count = 0;\\n           for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n           if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n               (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n               ++count;\\n               j = i;\\n           }            \\n           return count;\\n          }\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976013,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i=1; i<nums.length-1; i++){\\n            int pre = i-1;\\n            if(nums[i] == nums[i+1]){\\n                while(nums[i]==nums[i+1] && i<nums.length-2){\\n                    i++;\\n                }\\n            }\\n            if((nums[i] > nums[pre] && nums[i] > nums[i+1]) || (nums[i] < nums[pre] && nums[i] < nums[i+1])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i=1; i<nums.length-1; i++){\\n            int pre = i-1;\\n            if(nums[i] == nums[i+1]){\\n                while(nums[i]==nums[i+1] && i<nums.length-2){\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1959470,
                "title": "simple-java-solution-with-comment-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    //balance will be 1 if hill and -1 if valley, and count will be updated based on the last balance value\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int balance = 0;\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                if(balance == -1)\\n                    count++;\\n                balance = 1;\\n            }\\n            if(nums[i] < nums[i-1]) {\\n                if(balance == 1)\\n                    count++;\\n                balance = -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //balance will be 1 if hill and -1 if valley, and count will be updated based on the last balance value\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int balance = 0;\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                if(balance == -1)\\n                    count++;\\n                balance = 1;\\n            }\\n            if(nums[i] < nums[i-1]) {\\n                if(balance == 1)\\n                    count++;\\n                balance = -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908197,
                "title": "python-linear-solution",
                "content": "Traverse the array\\'s internal elements (from ``1`` to ``n-1``) and maintaining previous and current values, and comparing to the next value. For the current skipping all values equal to current (since adjacent equal elements are parts pf the same hill or valley).\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        cnt = 0\\n        n = len(nums)\\n        prev = nums[0]\\n        i = 1\\n        while i < n-1:\\n            current = nums[i]\\n            while i < n-1 and nums[i] == nums[i+1]:\\n                i += 1\\n            if i >= n-1:\\n                break\\n            if current < prev and current < nums[i+1] or \\\\\\n               current > prev and current > nums[i+1]:\\n                cnt += 1\\n            prev = current\\n            i += 1\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        cnt = 0\\n        n = len(nums)\\n        prev = nums[0]\\n        i = 1\\n        while i < n-1:\\n            current = nums[i]\\n            while i < n-1 and nums[i] == nums[i+1]:\\n                i += 1\\n            if i >= n-1:\\n                break\\n            if current < prev and current < nums[i+1] or \\\\\\n               current > prev and current > nums[i+1]:\\n                cnt += 1\\n            prev = current\\n            i += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903461,
                "title": "easy-javascript",
                "content": "```\\nvar countHillValley = function(nums) {\\n    let arr=[];\\n    for(let i=0; i<nums.length; i++){\\n      if(nums[i]!==nums[i-1]){arr.push(nums[i]);}\\n    }\\n    let count=0;\\n    for(let i=1; i<arr.length-1; i++){\\n      if(arr[i-1]<arr[i] && arr[i+1]<arr[i]){count++;}\\n      else if(arr[i-1]>arr[i] && arr[i+1]>arr[i]){count++;}\\n    }\\n    return count; \\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let arr=[];\\n    for(let i=0; i<nums.length; i++){\\n      if(nums[i]!==nums[i-1]){arr.push(nums[i]);}\\n    }\\n    let count=0;\\n    for(let i=1; i<arr.length-1; i++){\\n      if(arr[i-1]<arr[i] && arr[i+1]<arr[i]){count++;}\\n      else if(arr[i-1]>arr[i] && arr[i+1]>arr[i]){count++;}\\n    }\\n    return count; \\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894612,
                "title": "2210-count-hills-and-valleys-in-an-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& v) {\\n     \\n        int n = v.size();\\n        \\n        int c = 0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            if(i!=1 && v[i]==v[i-1]) continue;\\n            \\n            int l = i-1 , h = i+1;\\n            \\n            while(l>=0 && v[l]==v[i]) l--;\\n            while(h<n  && v[h]==v[i]) h++;\\n            \\n            if(l<0 || h>=n) continue;\\n            \\n            if(v[i] > v[l] && v[i] > v[h]) c++;\\n            if(v[i] < v[l] && v[i] < v[h]) c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& v) {\\n     \\n        int n = v.size();\\n        \\n        int c = 0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            if(i!=1 && v[i]==v[i-1]) continue;\\n            \\n            int l = i-1 , h = i+1;\\n            \\n            while(l>=0 && v[l]==v[i]) l--;\\n            while(h<n  && v[h]==v[i]) h++;\\n            \\n            if(l<0 || h>=n) continue;\\n            \\n            if(v[i] > v[l] && v[i] > v[h]) c++;\\n            if(v[i] < v[l] && v[i] < v[h]) c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892793,
                "title": "java-1ms-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int res=0;\\n        // left pointer will being updated only when is encountered with valley or hill\\n        // to solve the problem with adjent indices since they are the same part of hill or valley \\n       int left=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n          \\n            int right = nums[i+1];\\n            int curr = nums[i];\\n          \\n          \\n         \\n          \\n        if((curr>left && curr>right)||(curr<left && curr<right))\\n        {\\n              res++;\\n              left=nums[i];\\n        }\\n                  \\n      \\n        \\n            \\n\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int res=0;\\n        // left pointer will being updated only when is encountered with valley or hill\\n        // to solve the problem with adjent indices since they are the same part of hill or valley \\n       int left=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n          \\n            int right = nums[i+1];\\n            int curr = nums[i];\\n          \\n          \\n         \\n          \\n        if((curr>left && curr>right)||(curr<left && curr<right))\\n        {\\n              res++;\\n              left=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1888448,
                "title": "python-solution-o-n-linear-time-and-space-over-90-faster",
                "content": "First, obtain a new list containing the unique adjacent values only!\\nApply hill and valley checks on each element of new list!\\n```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        uniqs = [nums[0]]\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[i-1]:\\n                uniqs.append(nums[i])\\n        print(uniqs)\\n        ans = 0\\n        for i in range(1,len(uniqs)-1):\\n            if uniqs[i] > uniqs[i-1] and uniqs[i] > uniqs[i+1]:\\n                # hill case\\n                ans += 1\\n            if uniqs[i] < uniqs[i-1] and uniqs[i] < uniqs[i+1]:\\n                # valley case\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        uniqs = [nums[0]]\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[i-1]:\\n                uniqs.append(nums[i])\\n        print(uniqs)\\n        ans = 0\\n        for i in range(1,len(uniqs)-1):\\n            if uniqs[i] > uniqs[i-1] and uniqs[i] > uniqs[i+1]:\\n                # hill case\\n                ans += 1\\n            if uniqs[i] < uniqs[i-1] and uniqs[i] < uniqs[i+1]:\\n                # valley case\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1886080,
                "title": "python-one-pass-o-n-time-o-1-space",
                "content": "**Algorithm Details**\\n* Keep track of previous potential hill/valley\\n* If flat surface i.e equal elements keep incrementing\\n* Check if new unequal element is same as before or not, if yes increment count\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        prev = None; cnt = 0\\n        for i in range(len(nums)):\\n            while i < len(nums) - 1 and nums[i+1] == nums[i]:\\n                i += 1\\n            \\n\\t\\t\\t# edge case 1: end of array\\n            if i+1 >= len(nums):\\n                break\\n            \\n\\t\\t\\t#edge case 2: start of array\\n            if prev == None:\\n                prev = nums[i]\\n                continue\\n            \\n            if ( prev > nums[i] and nums[i+1] > nums[i] ) or ( prev < nums[i] and nums[i+1] < nums[i] ):\\n                cnt += 1\\n                \\n            prev = nums[i]\\n            \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        prev = None; cnt = 0\\n        for i in range(len(nums)):\\n            while i < len(nums) - 1 and nums[i+1] == nums[i]:\\n                i += 1\\n            \\n\\t\\t\\t# edge case 1: end of array\\n            if i+1 >= len(nums):\\n                break\\n            \\n\\t\\t\\t#edge case 2: start of array\\n            if prev == None:\\n                prev = nums[i]\\n                continue\\n            \\n            if ( prev > nums[i] and nums[i+1] > nums[i] ) or ( prev < nums[i] and nums[i+1] < nums[i] ):\\n                cnt += 1\\n                \\n            prev = nums[i]\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883086,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n        for(int i=1;i<n-1;i++){\\n           \\n            if(nums[i]==nums[i-1]){\\n                continue;\\n            }\\n             int j=i-1,k=i+1;\\n            \\n            while(k<n && nums[i]==nums[k]){\\n                k++;\\n            }\\n            \\n            while(j>=0 && nums[i]==nums[j]){\\n                j--;\\n            }\\n            \\n            if(k>=n || j<0){\\n                continue;\\n            }\\n            \\n            if(nums[i]>nums[k] && nums[i]>nums[j]){\\n                count++;\\n            }\\n            else if(nums[i]<nums[k] && nums[i]<nums[j]){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n        for(int i=1;i<n-1;i++){\\n           \\n            if(nums[i]==nums[i-1]){\\n                continue;\\n            }\\n             int j=i-1,k=i+1;\\n            \\n            while(k<n && nums[i]==nums[k]){\\n                k++;\\n            }\\n            \\n            while(j>=0 && nums[i]==nums[j]){\\n                j--;\\n            }\\n            \\n            if(k>=n || j<0){\\n                continue;\\n            }\\n            \\n            if(nums[i]>nums[k] && nums[i]>nums[j]){\\n                count++;\\n            }\\n            else if(nums[i]<nums[k] && nums[i]<nums[j]){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1870613,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut cur_sign;\\n        let mut count = 0;\\n        let mut prev_sign = 0;\\n        for (&x, &y) in nums.iter().zip(nums[1..].iter()).filter(|(x, y)| x != y) {\\n            cur_sign = (y - x).signum();\\n            if cur_sign != prev_sign && prev_sign != 0 {\\n                count += 1;\\n            }\\n            prev_sign = cur_sign;\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut cur_sign;\\n        let mut count = 0;\\n        let mut prev_sign = 0;\\n        for (&x, &y) in nums.iter().zip(nums[1..].iter()).filter(|(x, y)| x != y) {\\n            cur_sign = (y - x).signum();\\n            if cur_sign != prev_sign && prev_sign != 0 {\\n                count += 1;\\n            }\\n            prev_sign = cur_sign;\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870313,
                "title": "a-few-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun countHillValley(A: IntArray): Int {\\n        var cnt = 0\\n        for (i in 1 until A.size - 1) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1]\\n            cnt += if (A[i - 1] < A[i] && A[i] > A[i + 1]) 1 else 0\\n            cnt += if (A[i - 1] > A[i] && A[i] < A[i + 1]) 1 else 0\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countHillValley = (A, cnt = 0) => {\\n    for (let i = 1; i + 1 < A.length; ++i) {\\n        if (A[i] == A[i + 1])\\n            A[i] = A[i - 1];\\n        cnt += Number(A[i - 1] < A[i] && A[i] > A[i + 1]);\\n        cnt += Number(A[i - 1] > A[i] && A[i] < A[i + 1]);\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countHillValley(self, A: List[int], cnt = 0) -> int:\\n        for i in range(1, len(A) - 1):\\n            if A[i] == A[i + 1]:\\n                A[i] = A[i - 1]\\n            cnt += int(A[i - 1] < A[i] > A[i + 1])\\n            cnt += int(A[i - 1] > A[i] < A[i + 1])\\n        return cnt\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_hill_valley(A_: VI) -> i32 {\\n        let mut cnt = 0;\\n        let mut A = A_.clone();\\n        for i in 1..A.len() - 1 {\\n            if A[i] == A[i + 1] {\\n                A[i] = A[i - 1];\\n            }\\n            cnt += if A[i - 1] < A[i] && A[i] > A[i + 1] { 1 } else { 0 };\\n            cnt += if A[i - 1] > A[i] && A[i] < A[i + 1] { 1 } else { 0 };\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int countHillValley(VI& A, int cnt = 0) {\\n        for (auto i{ 1 }; i + 1 < A.size(); ++i) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1];\\n            cnt += A[i - 1] > A[i] && A[i] < A[i + 1];\\n            cnt += A[i - 1] < A[i] && A[i] > A[i + 1];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countHillValley(A: IntArray): Int {\\n        var cnt = 0\\n        for (i in 1 until A.size - 1) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1]\\n            cnt += if (A[i - 1] < A[i] && A[i] > A[i + 1]) 1 else 0\\n            cnt += if (A[i - 1] > A[i] && A[i] < A[i + 1]) 1 else 0\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countHillValley = (A, cnt = 0) => {\\n    for (let i = 1; i + 1 < A.length; ++i) {\\n        if (A[i] == A[i + 1])\\n            A[i] = A[i - 1];\\n        cnt += Number(A[i - 1] < A[i] && A[i] > A[i + 1]);\\n        cnt += Number(A[i - 1] > A[i] && A[i] < A[i + 1]);\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countHillValley(self, A: List[int], cnt = 0) -> int:\\n        for i in range(1, len(A) - 1):\\n            if A[i] == A[i + 1]:\\n                A[i] = A[i - 1]\\n            cnt += int(A[i - 1] < A[i] > A[i + 1])\\n            cnt += int(A[i - 1] > A[i] < A[i + 1])\\n        return cnt\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_hill_valley(A_: VI) -> i32 {\\n        let mut cnt = 0;\\n        let mut A = A_.clone();\\n        for i in 1..A.len() - 1 {\\n            if A[i] == A[i + 1] {\\n                A[i] = A[i - 1];\\n            }\\n            cnt += if A[i - 1] < A[i] && A[i] > A[i + 1] { 1 } else { 0 };\\n            cnt += if A[i - 1] > A[i] && A[i] < A[i + 1] { 1 } else { 0 };\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int countHillValley(VI& A, int cnt = 0) {\\n        for (auto i{ 1 }; i + 1 < A.size(); ++i) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1];\\n            cnt += A[i - 1] > A[i] && A[i] < A[i + 1];\\n            cnt += A[i - 1] < A[i] && A[i] > A[i + 1];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868506,
                "title": "java-solutions",
                "content": "**Time: O(n) Space: O(n)**\\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    List<Integer> uniqueVals = new ArrayList<>();\\n    for (int n : nums) {\\n      if (uniqueVals.isEmpty() || uniqueVals.get(uniqueVals.size() - 1) != n) {\\n        uniqueVals.add(n);\\n      }\\n    }\\n    int count = 0;\\n    for (int i = 1; i < uniqueVals.size() - 1; i++) {\\n      if ((uniqueVals.get(i) > uniqueVals.get(i - 1))\\n          == (uniqueVals.get(i) > uniqueVals.get(i + 1))) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\n\\nSimple example of uniqueVals:\\n![image](https://assets.leetcode.com/users/images/ad0f1077-c405-4338-98b6-3ffc257527a3_1647811688.047779.png)\\n\\n\\nIt is not necessary to keep track of all the unique values, we can just keep track of three:\\nhttps://leetcode.com/problems/count-hills-and-valleys-in-an-array/discuss/1865658/Easiest-C++-Solution-oror-Two-Pointers/1316542\\n**Time: O(n) Space: O(1)**\\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    int unique1 = -1, unique2 = -1, count = 0;\\n    for (int unique3 : nums) {\\n      if (unique3 != unique2) {\\n        if (unique1 != -1 && (unique2 > unique3) == (unique2 > unique1)) count++;\\n        unique1 = unique2;\\n        unique2 = unique3;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    List<Integer> uniqueVals = new ArrayList<>();\\n    for (int n : nums) {\\n      if (uniqueVals.isEmpty() || uniqueVals.get(uniqueVals.size() - 1) != n) {\\n        uniqueVals.add(n);\\n      }\\n    }\\n    int count = 0;\\n    for (int i = 1; i < uniqueVals.size() - 1; i++) {\\n      if ((uniqueVals.get(i) > uniqueVals.get(i - 1))\\n          == (uniqueVals.get(i) > uniqueVals.get(i + 1))) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    int unique1 = -1, unique2 = -1, count = 0;\\n    for (int unique3 : nums) {\\n      if (unique3 != unique2) {\\n        if (unique1 != -1 && (unique2 > unique3) == (unique2 > unique1)) count++;\\n        unique1 = unique2;\\n        unique2 = unique3;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868455,
                "title": "java-0ms-beats-100",
                "content": "```\\n public int countHillValley(int[] nums) {\\n        int count=0;\\n        int nonEqL=0;\\n        int nonEqR=0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            if(nums[i] != nums[i-1]) {  //set non equal left\\n                nonEqL = nums[i-1];\\n            }\\n            \\n            if(nums[i] != nums[i+1]) {  //set non equal right\\n                nonEqR = nums[i+1];\\n            }\\n            //should either be greater than both non equal left and non eq right to be counted as a hill\\n\\t\\t\\t// OR less than both non equal left and non eq right to be counted as a valley\\n            if((nonEqL != 0 && nonEqR != 0) \\n               && ((nums[i] > nonEqL && nums[i] > nonEqR) \\n                    || (nums[i] < nonEqL && nums[i] < nonEqR))) { \\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int countHillValley(int[] nums) {\\n        int count=0;\\n        int nonEqL=0;\\n        int nonEqR=0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            if(nums[i] != nums[i-1]) {  //set non equal left\\n                nonEqL = nums[i-1];\\n            }\\n            \\n            if(nums[i] != nums[i+1]) {  //set non equal right\\n                nonEqR = nums[i+1];\\n            }\\n            //should either be greater than both non equal left and non eq right to be counted as a hill\\n\\t\\t\\t// OR less than both non equal left and non eq right to be counted as a valley\\n            if((nonEqL != 0 && nonEqR != 0) \\n               && ((nums[i] > nonEqL && nums[i] > nonEqR) \\n                    || (nums[i] < nonEqL && nums[i] < nonEqR))) { \\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868448,
                "title": "java-easy-o-n-count-hills-and-valleys-with-comments",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int count=0;\\n        \\n        for ( int i=1 ; i < nums.length-1 ; i++)  \\n        {\\n            // 1. find  hill \\n            // left neighbor smaller\\n            if(nums[i-1] < nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(  i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                \\n                 // if we get right closest neighbor is smaller , this is hill\\n                 if ( i < nums.length-1 && nums[i+1] < nums[i])\\n                   count++;\\n            }   \\n             // 1. find  Valley\\n              // left neighbor greater\\n            else if(nums[i-1] > nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                 // if we get right closest neighbor is greater , this is Valley\\n               if ( i < nums.length-1 && nums[i+1] > nums[i])\\n                   count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int count=0;\\n        \\n        for ( int i=1 ; i < nums.length-1 ; i++)  \\n        {\\n            // 1. find  hill \\n            // left neighbor smaller\\n            if(nums[i-1] < nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(  i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                \\n                 // if we get right closest neighbor is smaller , this is hill\\n                 if ( i < nums.length-1 && nums[i+1] < nums[i])\\n                   count++;\\n            }   \\n             // 1. find  Valley\\n              // left neighbor greater\\n            else if(nums[i-1] > nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                 // if we get right closest neighbor is greater , this is Valley\\n               if ( i < nums.length-1 && nums[i+1] > nums[i])\\n                   count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868412,
                "title": "inplace-c-o-n-two-pointer",
                "content": "# Steps\\n* **Remove the duplicates** from the original array.(**using two pointer**)\\n* **Count the Hills and Valleys** `nums[i - 1] >  nums[i] && nums[i] < nums[i + 1])` for valley and `nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]` for Hills.\\n* **Time Complexity is O(n) and space complexity os O(1) so inplace algorithm**\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        int count = 0;\\n        int i = 0,j = 1;\\n        while(j != nums.size()){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        while(i < nums.size() - 1){\\n            nums.pop_back();\\n        }\\n        for(int i = 1;i < nums.size() - 1;i++){\\n            if(nums[i - 1] >  nums[i] && nums[i] < nums[i + 1]){\\n                count ++;\\n            }\\n            else if(nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        int count = 0;\\n        int i = 0,j = 1;\\n        while(j != nums.size()){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        while(i < nums.size() - 1){\\n            nums.pop_back();\\n        }\\n        for(int i = 1;i < nums.size() - 1;i++){\\n            if(nums[i - 1] >  nums[i] && nums[i] < nums[i + 1]){\\n                count ++;\\n            }\\n            else if(nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1868305,
                "title": "cpp-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int counter=0;\\n        nums = remove(nums);\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i] > nums[i+1] && nums[i] > nums[i-1]) { counter++; }\\n            else if(nums[i] < nums[i+1] && nums[i] < nums[i-1]) { counter++; }\\n        }\\n        \\n        return counter;\\n    }\\npublic:\\n    vector<int> remove(vector<int> &temp){\\n        vector<int> ans;\\n        for(int i=0;i<temp.size()-1;i++){\\n            if(temp[i] != temp[i+1])\\n                ans.push_back(temp[i]);\\n        }\\n        ans.push_back(temp[temp.size()-1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int counter=0;\\n        nums = remove(nums);\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i] > nums[i+1] && nums[i] > nums[i-1]) { counter++; }\\n            else if(nums[i] < nums[i+1] && nums[i] < nums[i-1]) { counter++; }\\n        }\\n        \\n        return counter;\\n    }\\npublic:\\n    vector<int> remove(vector<int> &temp){\\n        vector<int> ans;\\n        for(int i=0;i<temp.size()-1;i++){\\n            if(temp[i] != temp[i+1])\\n                ans.push_back(temp[i]);\\n        }\\n        ans.push_back(temp[temp.size()-1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867498,
                "title": "c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int res=0;\\n        \\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            //removing duplicates\\n            if(nums[i]==nums[i-1]) continue;\\n            \\n            int left = i-1;\\n            int right = i+1;\\n            \\n            // finding unique number to the left\\n            while(left>0 && nums[left]==nums[i])\\n                left--;\\n            \\n            // finding unique number to the right\\n            while(right<n-1 && nums[right]==nums[i])\\n                right++;\\n            \\n            //hill\\n            if(nums[left] < nums[i] && nums[right] < nums[i])\\n                res++;\\n            //valley\\n            else if(nums[left] > nums[i] && nums[right] > nums[i])\\n                res++;\\n            \\n        }\\n        \\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int res=0;\\n        \\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            //removing duplicates\\n            if(nums[i]==nums[i-1]) continue;\\n            \\n            int left = i-1;\\n            int right = i+1;\\n            \\n            // finding unique number to the left\\n            while(left>0 && nums[left]==nums[i])\\n                left--;\\n            \\n            // finding unique number to the right\\n            while(right<n-1 && nums[right]==nums[i])\\n                right++;\\n            \\n            //hill\\n            if(nums[left] < nums[i] && nums[right] < nums[i])\\n                res++;\\n            //valley\\n            else if(nums[left] > nums[i] && nums[right] > nums[i])\\n                res++;\\n            \\n        }\\n        \\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866949,
                "title": "simple-cpp-solution-count-hills-and-valleys",
                "content": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>::iterator it;\\n      \\n        it = std::unique(nums.begin(), nums.begin() + nums.size());\\n        nums.resize(std::distance(nums.begin(), it));\\n        int cnt=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>nums[i-1])&&(nums[i]>nums[i+1])){cnt++;}\\n            else if((nums[i]<nums[i-1])&&(nums[i]<nums[i+1])){cnt++;}\\n          \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>::iterator it;\\n      \\n        it = std::unique(nums.begin(), nums.begin() + nums.size());\\n        nums.resize(std::distance(nums.begin(), it));\\n        int cnt=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>nums[i-1])&&(nums[i]>nums[i+1])){cnt++;}",
                "codeTag": "Java"
            },
            {
                "id": 1866808,
                "title": "5-line-c-solution-unique-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        int n=nums.size(), h=0;\\n        for(int i=0;i<n-2;i++)\\n            if((nums[i]<nums[i+1] and nums[i+1]>nums[i+2]) or (nums[i]>nums[i+1] and nums[i+1]<nums[i+2]))   h++;\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        int n=nums.size(), h=0;\\n        for(int i=0;i<n-2;i++)\\n            if((nums[i]<nums[i+1] and nums[i+1]>nums[i+2]) or (nums[i]>nums[i+1] and nums[i+1]<nums[i+2]))   h++;\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866756,
                "title": "c-o-n-time-o-1-space-beats-100-c-solutions-easy-solution-with-explaination",
                "content": "**Psuedocode**\\n1-Remove all repeating elements\\n2-Counting hills and valleys is now easy using an ans (count) variable\\n3-Use a for loop and check these conditon\\n\\ta-(nums[i]>nums[i+1] && nums[i]>nums[i-1]) Conditon for valid hill\\n\\tb-(nums[i]<nums[i-1] && nums[i]<nums[i+1]) Condtion for valid valley\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t\\t//removed repeating numbers using unique stl\\n        vector<int>::iterator ip;\\n        ip=unique(nums.begin(),nums.begin()+nums.size());\\n        nums.resize(distance(nums.begin(),ip));\\n\\t\\t//used ans to count hills and valleys\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n                ans++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t\\t//removed repeating numbers using unique stl\\n        vector<int>::iterator ip;\\n        ip=unique(nums.begin(),nums.begin()+nums.size());\\n        nums.resize(distance(nums.begin(),ip));\\n\\t\\t//used ans to count hills and valleys\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n                ans++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866388,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n          int ans = 0;\\n          int i = 1;\\n          while(i < nums.size() - 1){\\n              int ele = nums[i];\\n              int j = i -1;\\n              bool flag1 = true, flag2 = true;\\n              while(nums[j] == ele){\\n                  j--;\\n                  if(j < 0) {flag1 = false; break;}\\n              }\\n              \\n              int k = i + 1;\\n               while(nums[k] == ele){\\n                  k++;\\n                  if(k >= nums.size()) {flag2 = false; break;}\\n              }\\n              \\n              if(flag1 && flag2){\\n                  if(ele > nums[j] && ele > nums[k]) ans++;\\n                  else if(ele < nums[j] && ele < nums[k]) ans++;\\n              }\\n               // skippings the duplicates \\n                while(nums[i] == ele) i++;\\n          }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n          int ans = 0;\\n          int i = 1;\\n          while(i < nums.size() - 1){\\n              int ele = nums[i];\\n              int j = i -1;\\n              bool flag1 = true, flag2 = true;\\n              while(nums[j] == ele){\\n                  j--;\\n                  if(j < 0) {flag1 = false; break;}",
                "codeTag": "Java"
            },
            {
                "id": 1865900,
                "title": "difference-arrary-to-count-the-flip-direction-o-n-o-1",
                "content": "nums = [2,4,1,1,6,5]\\ndiff_arr=[ 2,-3,0,5,-1]\\nPN = [+,-,0,+,-]\\n\\nthe count equal the positive and negtive flips(+ -> - or - ->+);\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 2) return 0;\\n\\t\\t\\n        int dif = 0;\\n        int prev = 0;\\n        int count = 0;  // count is the result \\n\\t\\t\\n        for(int i = 1;i < n;i++){\\n            dif = nums[i] - nums[i-1];\\n\\t\\t\\t// if there is flips, count increased\\n            if(dif*prev < 0){\\n                count++;\\n            }\\n\\t\\t\\t// save the cur state(positive or negtive) as prev\\n            if(dif != 0){\\n                prev = dif;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 2) return 0;\\n\\t\\t\\n        int dif = 0;\\n        int prev = 0;\\n        int count = 0;  // count is the result \\n\\t\\t\\n        for(int i = 1;i < n;i++){\\n            dif = nums[i] - nums[i-1];\\n\\t\\t\\t// if there is flips, count increased\\n            if(dif*prev < 0){\\n                count++;\\n            }\\n\\t\\t\\t// save the cur state(positive or negtive) as prev\\n            if(dif != 0){\\n                prev = dif;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865672,
                "title": "beginners-friendly-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n                continue;\\n            int first=-1;\\n            int second=-1;\\n         \\n            bool temp1=false;\\n            bool temp2=false;\\n           \\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    first=nums[j];\\n                    // cout<<nums[j];\\n                    temp1=true;\\n                     break;\\n                }\\n            }\\n            \\n           \\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    second=nums[j];\\n                    temp2=true;\\n                   \\n                    break;\\n                    \\n                }\\n            }\\n            \\n            if(temp1==true&&temp2==true)\\n            {\\n                if(first<nums[i]&&second<nums[i])\\n                {   count+=1;}\\n                else if(first>nums[i]&&second>nums[i])\\n                {  count+=1;}\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n                continue;\\n            int first=-1;\\n            int second=-1;\\n         \\n            bool temp1=false;\\n            bool temp2=false;\\n           \\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    first=nums[j];\\n                    // cout<<nums[j];\\n                    temp1=true;\\n                     break;\\n                }\\n            }\\n            \\n           \\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    second=nums[j];\\n                    temp2=true;\\n                   \\n                    break;\\n                    \\n                }\\n            }\\n            \\n            if(temp1==true&&temp2==true)\\n            {\\n                if(first<nums[i]&&second<nums[i])\\n                {   count+=1;}\\n                else if(first>nums[i]&&second>nums[i])\\n                {  count+=1;}\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1865664,
                "title": "simple-java-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=0;i<nums.length;i++){\\n            Boolean isPrevLower = null;\\n            Boolean isNextLower = null;\\n            int j = i-1;\\n            while(j>=0){ \\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isPrevLower = true;\\n                    else\\n                        isPrevLower = false;\\n\\n                    break;\\n                }\\n                j--;\\n            }\\n            j = i+1;\\n            while(j<nums.length){\\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isNextLower = true;\\n                    else\\n                        isNextLower = false;\\n                    \\n                    break;\\n                }else\\n                    i=j;\\n                j++;\\n            }\\n            if(isPrevLower!=null && isNextLower!=null && isPrevLower == isNextLower)\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=0;i<nums.length;i++){\\n            Boolean isPrevLower = null;\\n            Boolean isNextLower = null;\\n            int j = i-1;\\n            while(j>=0){ \\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isPrevLower = true;\\n                    else\\n                        isPrevLower = false;\\n\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1865663,
                "title": "python-sol",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hills,valley=0,0\\n        n=len(nums)\\n        if n<3:\\n            return 0\\n        \\n        for i in range(1,len(nums)):\\n            if i==i-1:\\n                continue\\n            for j in range(i,len(nums)):\\n                if i!=j and nums[i]!=nums[j]:\\n                    if nums[i]>nums[i-1] and nums[i]>nums[j] : \\n                        hills+=1\\n                        break\\n                    elif nums[i]<nums[i-1] and nums[i]<nums[j]: \\n                        valley+=1\\n                        break\\n                    elif (nums[i]>nums[i-1] and nums[i]<nums[j])or (nums[i]<nums[i-1] and nums[i]>nums[j]):\\n                        break\\n        return hills+valley\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hills,valley=0,0\\n        n=len(nums)\\n        if n<3:\\n            return 0\\n        \\n        for i in range(1,len(nums)):\\n            if i==i-1:\\n                continue\\n            for j in range(i,len(nums)):\\n                if i!=j and nums[i]!=nums[j]:\\n                    if nums[i]>nums[i-1] and nums[i]>nums[j] : \\n                        hills+=1\\n                        break\\n                    elif nums[i]<nums[i-1] and nums[i]<nums[j]: \\n                        valley+=1\\n                        break\\n                    elif (nums[i]>nums[i-1] and nums[i]<nums[j])or (nums[i]<nums[i-1] and nums[i]>nums[j]):\\n                        break\\n        return hills+valley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865581,
                "title": "java-easy-solution-single-loop",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if(nums.length<3){\\n            return 0;\\n        }\\n        int hills = 0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i-1]==nums[i] && i>1){\\n                nums[i-1] = nums[i-2];\\n            }\\n            if(nums[i]>nums[i-1] && nums[i]>nums[i+1]){\\n                hills++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                hills++;\\n            }\\n        }\\n        return hills;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if(nums.length<3){\\n            return 0;\\n        }\\n        int hills = 0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i-1]==nums[i] && i>1){\\n                nums[i-1] = nums[i-2];\\n            }\\n            if(nums[i]>nums[i-1] && nums[i]>nums[i+1]){\\n                hills++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                hills++;\\n            }\\n        }\\n        return hills;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086393,
                "title": "python-clean-and-easy-to-understand-o-n",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def countHillValley(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        length = len(nums)\\n        for i in range(1, length - 1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i - 1]\\n                continue\\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\\n                count += 1\\n            elif nums[i - 1] > nums[i] and nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                continue\\n        return count\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countHillValley(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        length = len(nums)\\n        for i in range(1, length - 1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i - 1]\\n                continue\\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\\n                count += 1\\n            elif nums[i - 1] > nums[i] and nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                continue\\n        return count\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085717,
                "title": "beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n =nums.size();\\n        int count=0;\\n        int j=0;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else \\n            continue;\\n        }\\n        return count;\\n    }\\n};    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n =nums.size();\\n        int count=0;\\n        int j=0;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else \\n            continue;\\n        }\\n        return count;\\n    }\\n};    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083954,
                "title": "single-pass-t-o-n-s-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nvar countHillValley = function(nums) {\\n    let counter = 0;\\n    let i = 1;\\n\\n    while (i < nums.length - 1) {\\n        const num = nums[i];\\n        const prevNum = nums[i - 1];\\n        const nextNum = (() => {\\n            while (nums[i + 1] === num) {\\n                i += 1;\\n            }\\n            return nums[i + 1];\\n        })();\\n        if ((prevNum < num && nextNum < num) ||\\n            (prevNum > num && nextNum > num)) {\\n            counter += 1;\\n        }\\n        i += 1;\\n    }\\n    return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let counter = 0;\\n    let i = 1;\\n\\n    while (i < nums.length - 1) {\\n        const num = nums[i];\\n        const prevNum = nums[i - 1];\\n        const nextNum = (() => {\\n            while (nums[i + 1] === num) {\\n                i += 1;\\n            }\\n            return nums[i + 1];\\n        })();\\n        if ((prevNum < num && nextNum < num) ||\\n            (prevNum > num && nextNum > num)) {\\n            counter += 1;\\n        }\\n        i += 1;\\n    }\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081836,
                "title": "cpp-short-simple",
                "content": "---\\n\\n# Complexity\\n- Time complexity:\\n\\uD83D\\uDFE2 $$O(n)$$ \\n\\n- Space complexity:\\n\\uD83D\\uDFE2 $$O(n)$$ \\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int hill = 0; \\n        int valley = 0;\\n        vector<int> nums1;\\n        nums1.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] == nums[i-1]) continue;\\n            nums1.push_back(nums[i]);\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] > nums1[i-1] && nums1[i] > nums1[i+1]) hill++;\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] < nums1[i-1] && nums1[i] < nums1[i+1]) valley++;\\n        }\\n\\n        return hill+valley;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int hill = 0; \\n        int valley = 0;\\n        vector<int> nums1;\\n        nums1.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] == nums[i-1]) continue;\\n            nums1.push_back(nums[i]);\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] > nums1[i-1] && nums1[i] > nums1[i+1]) hill++;\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] < nums1[i-1] && nums1[i] < nums1[i+1]) valley++;\\n        }\\n\\n        return hill+valley;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069204,
                "title": "easy-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        r = []\\n        i = 1\\n        while i < len(nums)-1:\\n            temp = nums[:i][::-1] \\n            for j in temp:                \\n                if (nums[i] != j ) :\\n                    break\\n            for k in nums[i+1:] :\\n                if (nums[i] != k) :\\n                    break\\n            if (nums[i] > j and nums[i] > k) or (nums[i] < j and nums[i] < k) :\\n                l = [j, k]\\n                r += [l]\\n            i += 1\\n        \\n        if r:\\n            c = 0\\n            for i in range(len(r)-1) :\\n                if r[i] != r[i+1] :\\n                    c += 1\\n            return c+1\\n        return 0\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        r = []\\n        i = 1\\n        while i < len(nums)-1:\\n            temp = nums[:i][::-1] \\n            for j in temp:                \\n                if (nums[i] != j ) :\\n                    break\\n            for k in nums[i+1:] :\\n                if (nums[i] != k) :\\n                    break\\n            if (nums[i] > j and nums[i] > k) or (nums[i] < j and nums[i] < k) :\\n                l = [j, k]\\n                r += [l]\\n            i += 1\\n        \\n        if r:\\n            c = 0\\n            for i in range(len(r)-1) :\\n                if r[i] != r[i+1] :\\n                    c += 1\\n            return c+1\\n        return 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067657,
                "title": "ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    const arr=nums.filter((a,i,b)=> a!=b[i+1]);\\n    let flag=0;\\n    \\n    for(i=1;i<=arr.length-1;i++){\\n        if(arr[i-1]<arr[i]&&arr[i+1]<arr[i]){\\n            flag++;\\n        }\\n        else if(arr[i-1]>arr[i]&&arr[i+1]>arr[i]){\\n            flag++;\\n        }\\n    }\\n    \\n   return flag;\\n    \\n\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    const arr=nums.filter((a,i,b)=> a!=b[i+1]);\\n    let flag=0;\\n    \\n    for(i=1;i<=arr.length-1;i++){\\n        if(arr[i-1]<arr[i]&&arr[i+1]<arr[i]){\\n            flag++;\\n        }\\n        else if(arr[i-1]>arr[i]&&arr[i+1]>arr[i]){\\n            flag++;\\n        }\\n    }\\n    \\n   return flag;\\n    \\n\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050081,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n          if(nums[i]>nums[i-1]&&nums[i]>nums[i+1] || nums[i]<nums[i-1]&&nums[i]<nums[i+1])\\n          {\\n              count++;\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n          if(nums[i]>nums[i-1]&&nums[i]>nums[i+1] || nums[i]<nums[i-1]&&nums[i]<nums[i+1])\\n          {\\n              count++;\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042920,
                "title": "easy-java-solution",
                "content": "```\\n        int count = 0;\\n        int i = 1;\\n        int len = nums.length;\\n\\n        while (i < len - 1) {\\n\\n            if (nums[i] == nums[i + 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int j = i - 1;\\n            int k = i + 1;\\n\\n            while (j != 0 && nums[i] == nums[j]) {\\n                j--;\\n            }\\n            while (k < len && nums[i] == nums[k]) {\\n                k++;\\n            }\\n\\n            if (nums[i] > nums[j] && nums[i] > nums[k]) count++;\\n\\n            else if (nums[i] < nums[j] && nums[i] < nums[k]) count++;\\n\\n            i++;\\n\\n\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n        int count = 0;\\n        int i = 1;\\n        int len = nums.length;\\n\\n        while (i < len - 1) {\\n\\n            if (nums[i] == nums[i + 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int j = i - 1;\\n            int k = i + 1;\\n\\n            while (j != 0 && nums[i] == nums[j]) {\\n                j--;\\n            }\\n            while (k < len && nums[i] == nums[k]) {\\n                k++;\\n            }\\n\\n            if (nums[i] > nums[j] && nums[i] > nums[k]) count++;\\n\\n            else if (nums[i] < nums[j] && nums[i] < nums[k]) count++;\\n\\n            i++;\\n\\n\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006488,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        vector<int> traversal;\\n        traversal.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            traversal.push_back(nums[i]);\\n        }\\n        bool inc=traversal[0]<traversal[1];\\n        int count=1;\\n        for(int i=0;i<traversal.size()-1;i++)\\n        {\\n            if(traversal[i]<traversal[i+1]&&!inc)\\n            {\\n                inc=true;\\n                count++;\\n            }\\n            if(traversal[i]>traversal[i+1]&&inc)\\n            {\\n                inc=false;\\n                count++;\\n            }\\n        }\\n        return count-1;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        vector<int> traversal;\\n        traversal.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            traversal.push_back(nums[i]);\\n        }\\n        bool inc=traversal[0]<traversal[1];\\n        int count=1;\\n        for(int i=0;i<traversal.size()-1;i++)\\n        {\\n            if(traversal[i]<traversal[i+1]&&!inc)\\n            {\\n                inc=true;\\n                count++;\\n            }\\n            if(traversal[i]>traversal[i+1]&&inc)\\n            {\\n                inc=false;\\n                count++;\\n            }\\n        }\\n        return count-1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990242,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    int left = nums[0];\\n\\n    for (int i = 1; i + 1 < nums.size(); ++i)\\n      if (left < nums[i] && nums[i] > nums[i + 1] ||  // Hill\\n          left > nums[i] && nums[i] < nums[i + 1]) {  // Valley\\n        ++ans;\\n        left = nums[i];\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    int left = nums[0];\\n\\n    for (int i = 1; i + 1 < nums.size(); ++i)\\n      if (left < nums[i] && nums[i] > nums[i + 1] ||  // Hill\\n          left > nums[i] && nums[i] < nums[i + 1]) {  // Valley\\n        ++ans;\\n        left = nums[i];\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982923,
                "title": "typescript-javascript-simple-solution",
                "content": "# Code\\n```\\nfunction countHillValley(nums: number[]): number {\\n    let result = 0;\\n    let prev = nums[0];\\n\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        const curr = nums[i];\\n        const next = nums[i + 1];\\n        \\n        if (curr === next) continue;\\n\\n        if (curr > prev && curr > next) {\\n            result++;\\n        }\\n\\n        if (curr < prev && curr < next) {\\n            result++;\\n        }\\n\\n        prev = curr;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction countHillValley(nums: number[]): number {\\n    let result = 0;\\n    let prev = nums[0];\\n\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        const curr = nums[i];\\n        const next = nums[i + 1];\\n        \\n        if (curr === next) continue;\\n\\n        if (curr > prev && curr > next) {\\n            result++;\\n        }\\n\\n        if (curr < prev && curr < next) {\\n            result++;\\n        }\\n\\n        prev = curr;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972297,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        position = 1\\n        count = 0\\n\\n        while position < len(nums) - 1:\\n            low = position -1\\n            high = position + 1\\n\\n            while low >= 1:\\n                if nums[low] == nums[position]:\\n                    low -= 1\\n                else:\\n                    break\\n            \\n            while high < len(nums) - 1:\\n                if nums[high] == nums[position]:\\n                    high += 1\\n                else:\\n                    break\\n            \\n            if nums[low] < nums[position] and nums[position] > nums[high]:\\n                count += 1\\n            \\n            if nums[low] > nums[position] and nums[position] < nums[high]:\\n                count += 1\\n            \\n            position = high\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        position = 1\\n        count = 0\\n\\n        while position < len(nums) - 1:\\n            low = position -1\\n            high = position + 1\\n\\n            while low >= 1:\\n                if nums[low] == nums[position]:\\n                    low -= 1\\n                else:\\n                    break\\n            \\n            while high < len(nums) - 1:\\n                if nums[high] == nums[position]:\\n                    high += 1\\n                else:\\n                    break\\n            \\n            if nums[low] < nums[position] and nums[position] > nums[high]:\\n                count += 1\\n            \\n            if nums[low] > nums[position] and nums[position] < nums[high]:\\n                count += 1\\n            \\n            position = high\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946563,
                "title": "java-beat-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            int j = i;\\n            while (j<nums.length-2 && nums[j] == nums[j+1]) {\\n                j++;\\n            }\\n            if ((nums[i-1] < nums[i] && nums[i] > nums[j+1]) || (nums[i-1] > nums[i] && nums[i] < nums[j+1])) {\\n                count++;\\n            }\\n            i = j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            int j = i;\\n            while (j<nums.length-2 && nums[j] == nums[j+1]) {\\n                j++;\\n            }\\n            if ((nums[i-1] < nums[i] && nums[i] > nums[j+1]) || (nums[i-1] > nums[i] && nums[i] < nums[j+1])) {\\n                count++;\\n            }\\n            i = j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923963,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n             int prev=i-1;\\n             int next=i+1;\\n             if(nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             while(prev>=0 && nums[prev]==nums[i])\\n             {\\n                prev--;\\n             }\\n             while(next<nums.size() && nums[next]==nums[i])\\n             {\\n                next++;\\n             }\\n             if(prev<0 || next>=nums.size())\\n             {\\n                 continue;\\n             }\\n             if(nums[i]>nums[prev]  && nums[i]>nums[next])\\n             {\\n                 count++;\\n                 \\n             }\\n             if(nums[i]<nums[next] && nums[i]<nums[prev])\\n             {\\n                 count++;\\n             }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n             int prev=i-1;\\n             int next=i+1;\\n             if(nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             while(prev>=0 && nums[prev]==nums[i])\\n             {\\n                prev--;\\n             }\\n             while(next<nums.size() && nums[next]==nums[i])\\n             {\\n                next++;\\n             }\\n             if(prev<0 || next>=nums.size())\\n             {\\n                 continue;\\n             }\\n             if(nums[i]>nums[prev]  && nums[i]>nums[next])\\n             {\\n                 count++;\\n                 \\n             }\\n             if(nums[i]<nums[next] && nums[i]<nums[prev])\\n             {\\n                 count++;\\n             }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920918,
                "title": "rust-beats-100-o-n-o-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        let mut uphill = nums[1].cmp(&nums[0]);\\n        for i in 1..nums.len() {\\n            match nums[i].cmp(&nums[i - 1]) {\\n                std::cmp::Ordering::Greater => {\\n                    if uphill == std::cmp::Ordering::Less {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Greater;\\n                }\\n                std::cmp::Ordering::Equal => (),\\n                std::cmp::Ordering::Less => {\\n                    if uphill == std::cmp::Ordering::Greater {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Less;\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        let mut uphill = nums[1].cmp(&nums[0]);\\n        for i in 1..nums.len() {\\n            match nums[i].cmp(&nums[i - 1]) {\\n                std::cmp::Ordering::Greater => {\\n                    if uphill == std::cmp::Ordering::Less {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Greater;\\n                }\\n                std::cmp::Ordering::Equal => (),\\n                std::cmp::Ordering::Less => {\\n                    if uphill == std::cmp::Ordering::Greater {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Less;\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914698,
                "title": "python-simple-solution-beats-93-user-in-both-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        arr=[]\\n        left=nums[0]\\n        for i in range(1,len(nums)-1):\\n            j=i+1\\n\\n            if left==nums[i]:\\n                continue\\n            while j<len(nums) and nums[i]==nums[j]:\\n                j+=1\\n            if j>=len(nums):\\n                continue\\n            right=nums[j]\\n            if left<nums[i] and right<nums[i]:\\n                arr.append(\\'hill\\')\\n                left=nums[i]\\n            elif left>nums[i] and right>nums[i]:\\n                arr.append(\\'valley\\')\\n                left=nums[i]\\n    \\n        val=\\'\\'\\n        count=0\\n        for i in range(len(arr)):\\n            if arr[i]!=val:\\n                count+=1\\n            val=arr[i]\\n            \\n        return(count)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        arr=[]\\n        left=nums[0]\\n        for i in range(1,len(nums)-1):\\n            j=i+1\\n\\n            if left==nums[i]:\\n                continue\\n            while j<len(nums) and nums[i]==nums[j]:\\n                j+=1\\n            if j>=len(nums):\\n                continue\\n            right=nums[j]\\n            if left<nums[i] and right<nums[i]:\\n                arr.append(\\'hill\\')\\n                left=nums[i]\\n            elif left>nums[i] and right>nums[i]:\\n                arr.append(\\'valley\\')\\n                left=nums[i]\\n    \\n        val=\\'\\'\\n        count=0\\n        for i in range(len(arr)):\\n            if arr[i]!=val:\\n                count+=1\\n            val=arr[i]\\n            \\n        return(count)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901205,
                "title": "iteration-tracking-last-hill-or-valley-checking-valley-or-hill-iteratively",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }\\n        int numberOfHills = 0;\\n        int numberOfValleys = 0;\\n        int indexOfLastHillOrValley = 0;\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            //is Hill?\\n            if (nums[i] > nums[indexOfLastHillOrValley] && nums[i] > nums[i + 1]) {\\n                numberOfHills++;\\n                indexOfLastHillOrValley = i;\\n            } else if (nums[i] < nums[indexOfLastHillOrValley] && nums[i] < nums[i + 1]) {\\n                numberOfValleys++;\\n                indexOfLastHillOrValley = i;\\n            }\\n        }\\n        return numberOfHills + numberOfValleys;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }\\n        int numberOfHills = 0;\\n        int numberOfValleys = 0;\\n        int indexOfLastHillOrValley = 0;\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            //is Hill?\\n            if (nums[i] > nums[indexOfLastHillOrValley] && nums[i] > nums[i + 1]) {\\n                numberOfHills++;\\n                indexOfLastHillOrValley = i;\\n            } else if (nums[i] < nums[indexOfLastHillOrValley] && nums[i] < nums[i + 1]) {\\n                numberOfValleys++;\\n                indexOfLastHillOrValley = i;\\n            }\\n        }\\n        return numberOfHills + numberOfValleys;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892683,
                "title": "c-o-n-solution-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c = 0;\\n        int prev = nums[0];\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>prev && nums[i]>nums[i+1]) || \\n                (nums[i]<prev && nums[i]<nums[i+1])){\\n                c++;\\n                prev=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c = 0;\\n        int prev = nums[0];\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>prev && nums[i]>nums[i+1]) || \\n                (nums[i]<prev && nums[i]<nums[i+1])){\\n                c++;\\n                prev=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879937,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        arr.add(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            arr.add(nums[i]);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            System.out.println(arr.get(i)+\" \");\\n        }\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            if(arr.get(i)>arr.get(i-1)&&arr.get(i)>arr.get(i+1))\\n            count++;\\n            else if(arr.get(i)<arr.get(i-1)&&arr.get(i)<arr.get(i+1))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        arr.add(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            arr.add(nums[i]);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            System.out.println(arr.get(i)+\" \");\\n        }\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            if(arr.get(i)>arr.get(i-1)&&arr.get(i)>arr.get(i+1))\\n            count++;\\n            else if(arr.get(i)<arr.get(i-1)&&arr.get(i)<arr.get(i+1))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879550,
                "title": "scala",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def countHillValley(nums: Array[Int]): Int = {\\n        var isHill: Option[Boolean] = None\\n        (1 until nums.length).map { i => \\n            val prev = nums(i-1)\\n            val curr = nums(i)\\n            if(prev != curr) {\\n                if (prev > curr) {\\n                    val result = isHill match {\\n                        case Some(true) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(false)\\n                    result\\n                } else {\\n                    val result = isHill match {\\n                        case Some(false) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(true)\\n                    result\\n                }\\n            } else 0\\n        }.sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countHillValley(nums: Array[Int]): Int = {\\n        var isHill: Option[Boolean] = None\\n        (1 until nums.length).map { i => \\n            val prev = nums(i-1)\\n            val curr = nums(i)\\n            if(prev != curr) {\\n                if (prev > curr) {\\n                    val result = isHill match {\\n                        case Some(true) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(false)\\n                    result\\n                } else {\\n                    val result = isHill match {\\n                        case Some(false) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(true)\\n                    result\\n                }\\n            } else 0\\n        }.sum\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3872802,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>nums[i-1]&&nums[i]>nums[i+1])||(nums[i]<nums[i-1]&&nums[i]<nums[i+1])){\\n                c++;\\n            }\\n            if(nums[i]==nums[i+1])\\n                nums[i]=nums[i-1];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>nums[i-1]&&nums[i]>nums[i+1])||(nums[i]<nums[i-1]&&nums[i]<nums[i+1])){\\n                c++;\\n            }\\n            if(nums[i]==nums[i+1])\\n                nums[i]=nums[i-1];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858259,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]!=v[j])\\n            {\\n                v.push_back(nums[i]);\\n                j++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=1;i<v.size()-1;i++)\\n        {\\n            if(v[i]>v[i-1]&&v[i]>v[i+1])\\n            cnt++;\\n            if(v[i]<v[i-1] && v[i]<v[i+1])\\n            cnt++;\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]!=v[j])\\n            {\\n                v.push_back(nums[i]);\\n                j++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=1;i<v.size()-1;i++)\\n        {\\n            if(v[i]>v[i-1]&&v[i]>v[i+1])\\n            cnt++;\\n            if(v[i]<v[i-1] && v[i]<v[i+1])\\n            cnt++;\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857687,
                "title": "javasctipt-very-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe dont care about the number of indeces in valleys and hills, so remove all adjacent elements of same value. Then loop through the resultant array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a new array where no element is of same value and are adjacent. \\n2. iterate starting from idx 1 and till one before last and check if each idx you are at is either bigger or smaller its left and right neighbors. \\n3. if so, add to the result\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n2 * O(n) since we loop through array twice, discard constant -> so O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) since we create another array of potentially size equal to the original array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let cnt = 0;\\n    const u =  []\\n\\n    for (const n of nums) {\\n        if (u.length === 0 || u.at(-1) !== n) {\\n            u.push(n)\\n        }\\n    }\\n\\n    for (let i = 1; i<u.length-1; i++) {\\n        if (u[i] > u[i-1] && u[i] > u[i+1] ||\\n        u[i] < u[i-1] && u[i] < u[i+1]) {\\n            cnt++;\\n        }\\n    }\\n\\n    return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let cnt = 0;\\n    const u =  []\\n\\n    for (const n of nums) {\\n        if (u.length === 0 || u.at(-1) !== n) {\\n            u.push(n)\\n        }\\n    }\\n\\n    for (let i = 1; i<u.length-1; i++) {\\n        if (u[i] > u[i-1] && u[i] > u[i+1] ||\\n        u[i] < u[i-1] && u[i] < u[i+1]) {\\n            cnt++;\\n        }\\n    }\\n\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810778,
                "title": "o-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity:```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n            if ((nums[j] < nums[i] && nums[i] > nums[i + 1]) ||\\n                (nums[j] > nums[i] && nums[i] < nums[i + 1])) {\\n                ++ans;\\n                j = i;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n            if ((nums[j] < nums[i] && nums[i] > nums[i + 1]) ||\\n                (nums[j] > nums[i] && nums[i] < nums[i + 1])) {\\n                ++ans;\\n                j = i;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808368,
                "title": "java-array-traversal-100-fast-quickest-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int ans = 0;\\n        for(int i=1 ; i<nums.length-1; i++){\\n            if(nums[i]==nums[i-1]) {continue;}\\n            int left = closestLeft(i,nums);\\n            int rigt = closestRigt(i,nums);\\n            if(left>nums[i] && rigt>nums[i]) ans++;\\n            if(left<nums[i] && rigt<nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    private int closestLeft(int index, int[] arr) {\\n        if(arr[index-1]!=arr[index]) return arr[index-1];\\n        else {\\n            int i = index-1;\\n            while(i>0){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i--;\\n            }\\n            return arr[index];\\n        }\\n    }\\n    private int closestRigt(int index, int[] arr) {\\n        if(arr[index+1]!=arr[index]) return arr[index+1];\\n        else {\\n            int i = index+1;\\n            while(i<arr.length){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i++;\\n            }\\n            return arr[index];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int ans = 0;\\n        for(int i=1 ; i<nums.length-1; i++){\\n            if(nums[i]==nums[i-1]) {continue;}\\n            int left = closestLeft(i,nums);\\n            int rigt = closestRigt(i,nums);\\n            if(left>nums[i] && rigt>nums[i]) ans++;\\n            if(left<nums[i] && rigt<nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    private int closestLeft(int index, int[] arr) {\\n        if(arr[index-1]!=arr[index]) return arr[index-1];\\n        else {\\n            int i = index-1;\\n            while(i>0){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i--;\\n            }\\n            return arr[index];\\n        }\\n    }\\n    private int closestRigt(int index, int[] arr) {\\n        if(arr[index+1]!=arr[index]) return arr[index+1];\\n        else {\\n            int i = index+1;\\n            while(i<arr.length){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i++;\\n            }\\n            return arr[index];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782614,
                "title": "easy-c-solution",
                "content": "# Intuition\\nLook for closest left and right non-equal numbers\\n# Approach\\nSkip the equal numbers and look for hills and valleys by accessing closest left and right non-equal numbers. Make three variables l,m,r to denote left, middle and right values.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int l = 0;\\n        int m = 1;\\n        int r = 2;\\n        while(r<nums.size()){\\n            if((nums[l] > nums[m] && nums[r] > nums[m]) ||\\n                (nums[l] < nums[m] && nums[r] < nums[m])\\n            ){\\n                cout<<nums[l]<<\" \"<<nums[m]<<\" \"<<nums[r]<<endl;\\n                count++;\\n                r++;\\n                m++;\\n                l= m-1;\\n            }else if(nums[l]==nums[m]){\\n                r++;\\n                m++;\\n                l++;\\n            }else if(nums[r]==nums[m]){\\n                r++;\\n                m++;\\n            }else{\\n                r++;\\n                m++;\\n                l++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int l = 0;\\n        int m = 1;\\n        int r = 2;\\n        while(r<nums.size()){\\n            if((nums[l] > nums[m] && nums[r] > nums[m]) ||\\n                (nums[l] < nums[m] && nums[r] < nums[m])\\n            ){\\n                cout<<nums[l]<<\" \"<<nums[m]<<\" \"<<nums[r]<<endl;\\n                count++;\\n                r++;\\n                m++;\\n                l= m-1;\\n            }else if(nums[l]==nums[m]){\\n                r++;\\n                m++;\\n                l++;\\n            }else if(nums[r]==nums[m]){\\n                r++;\\n                m++;\\n            }else{\\n                r++;\\n                m++;\\n                l++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3780341,
                "title": "beats-100-memory-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {         \\n         int left=-1;\\n         int count=0;\\n          for (int i=0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n              continue;\\n            }\\n            int right=nums[i+1];\\n            if(left!=-1 && nums[i]>left && nums[i]>right || nums[i]<left && nums[i]<right)\\n            {\\n                count++;\\n            }\\n\\n            left= nums[i];\\n        }\\n         return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {         \\n         int left=-1;\\n         int count=0;\\n          for (int i=0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n              continue;\\n            }\\n            int right=nums[i+1];\\n            if(left!=-1 && nums[i]>left && nums[i]>right || nums[i]<left && nums[i]<right)\\n            {\\n                count++;\\n            }\\n\\n            left= nums[i];\\n        }\\n         return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778163,
                "title": "best-way-to-solve-problem-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i=0,count=0,hill=0,valley=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]<nums[i] && hill==0){\\n                hill=1;\\n                if(valley==1){\\n                count++;\\n                valley=0;\\n                }\\n            }\\n             else if(nums[i-1]>nums[i] && valley==0)\\n            {\\n                valley=1;\\n                if(hill==1){\\n                count++;\\n                hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i=0,count=0,hill=0,valley=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]<nums[i] && hill==0){\\n                hill=1;\\n                if(valley==1){\\n                count++;\\n                valley=0;\\n                }\\n            }\\n             else if(nums[i-1]>nums[i] && valley==0)\\n            {\\n                valley=1;\\n                if(hill==1){\\n                count++;\\n                hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773052,
                "title": "python-3-solution",
                "content": "we first create a new list with no same element in adjacent indices.That will make our calculation easier.and then just by basic comparision with the previous and former element we can calculate the ans.This logic is easy to understand for the beginners.thank you .Happy Coding. If u like this solution plz give an upvote\\n\\n\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        num1=[]\\n        nums.append(0)\\n        \\n        c=0\\n        for i in range (len(nums)-1):\\n            if(nums[i]!=nums[i+1]):\\n                num1.append(nums[i])\\n                \\n                \\n        for i in range(1,len(num1)-1):\\n            if(num1[i]>num1[i+1] and num1[i]>num1[i-1]):\\n                c+=1\\n            elif(num1[i]<num1[i+1] and num1[i]<num1[i-1]):\\n                c+=1\\n            else:\\n                continue\\n        return c\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        num1=[]\\n        nums.append(0)\\n        \\n        c=0\\n        for i in range (len(nums)-1):\\n            if(nums[i]!=nums[i+1]):\\n                num1.append(nums[i])\\n                \\n                \\n        for i in range(1,len(num1)-1):\\n            if(num1[i]>num1[i+1] and num1[i]>num1[i-1]):\\n                c+=1\\n            elif(num1[i]<num1[i+1] and num1[i]<num1[i-1]):\\n                c+=1\\n            else:\\n                continue\\n        return c\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761858,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int result = 0;\\n        int idxXtrmStart = 1;\\n        int idxXtrmEnd = idxXtrmStart;\\n        while (idxXtrmEnd < (nums.size() - 1))\\n        {\\n            while ((idxXtrmEnd < (nums.size() - 2)) &&\\n                    (nums[idxXtrmEnd] == nums[idxXtrmEnd+1]))\\n            {\\n                idxXtrmEnd++;\\n            }\\n            if ( ((nums[idxXtrmStart] > nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] > nums[idxXtrmEnd + 1])) ||\\n                 ((nums[idxXtrmStart] < nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] < nums[idxXtrmEnd + 1])))\\n            {\\n                result++;\\n            }\\n            idxXtrmStart = idxXtrmEnd + 1;\\n            idxXtrmEnd = idxXtrmStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int result = 0;\\n        int idxXtrmStart = 1;\\n        int idxXtrmEnd = idxXtrmStart;\\n        while (idxXtrmEnd < (nums.size() - 1))\\n        {\\n            while ((idxXtrmEnd < (nums.size() - 2)) &&\\n                    (nums[idxXtrmEnd] == nums[idxXtrmEnd+1]))\\n            {\\n                idxXtrmEnd++;\\n            }\\n            if ( ((nums[idxXtrmStart] > nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] > nums[idxXtrmEnd + 1])) ||\\n                 ((nums[idxXtrmStart] < nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] < nums[idxXtrmEnd + 1])))\\n            {\\n                result++;\\n            }\\n            idxXtrmStart = idxXtrmEnd + 1;\\n            idxXtrmEnd = idxXtrmStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754852,
                "title": "easy-to-understand-java-beginner-s-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prev=nums[0];\\n        int count=0,j=0,i=0;\\n        int[] temp=new int[nums.length];\\n        for( i=0;i<nums.length-1;i++)\\n        {\\nif(nums[i]==nums[i+1])\\ncontinue;\\ntemp[j++]=nums[i];\\n        }\\n        temp[j]=nums[i];\\n        for(int k=1;k<j;k++)\\n        {\\n     if(temp[k]<temp[k-1] && temp[k]<temp[k+1])\\n    count++;\\n    if(temp[k]>temp[k-1] && temp[k]>temp[k+1])\\n    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prev=nums[0];\\n        int count=0,j=0,i=0;\\n        int[] temp=new int[nums.length];\\n        for( i=0;i<nums.length-1;i++)\\n        {\\nif(nums[i]==nums[i+1])\\ncontinue;\\ntemp[j++]=nums[i];\\n        }\\n        temp[j]=nums[i];\\n        for(int k=1;k<j;k++)\\n        {\\n     if(temp[k]<temp[k-1] && temp[k]<temp[k+1])\\n    count++;\\n    if(temp[k]>temp[k-1] && temp[k]>temp[k+1])\\n    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750511,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        // if current >= left && current >= right => hill\\n        // current <= left && current <= right => valley;\\n\\n        let count = 0;\\n        let lastElement = 0;\\n        let current = nums[0];\\n        let lst = [current];\\n\\n        for(let i=1;i<nums.length;i++){\\n            if (current != nums[i])lst.push(nums[i]);\\n            current = nums[i];\\n        }\\n        \\n\\n        for(let i=0;i<lst.length-1;i++){\\n            let current = lst[i];\\n            if (current >= lst[i-1] && current >= lst[i+1])count+=1;\\n            else if (current <= lst[i-1] && current <= lst[i+1])count+=1;            \\n        }\\n\\n        return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        // if current >= left && current >= right => hill\\n        // current <= left && current <= right => valley;\\n\\n        let count = 0;\\n        let lastElement = 0;\\n        let current = nums[0];\\n        let lst = [current];\\n\\n        for(let i=1;i<nums.length;i++){\\n            if (current != nums[i])lst.push(nums[i]);\\n            current = nums[i];\\n        }\\n        \\n\\n        for(let i=0;i<lst.length-1;i++){\\n            let current = lst[i];\\n            if (current >= lst[i-1] && current >= lst[i+1])count+=1;\\n            else if (current <= lst[i-1] && current <= lst[i+1])count+=1;            \\n        }\\n\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748747,
                "title": "java-easy-solution-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748746,
                "title": "java-easy-solution-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730058,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728749,
                "title": "best-solution-in-o-n-time-and-space-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n\\n        vector<int> arr{nums[0]};\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]!=nums[i]){\\n                arr.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i=1; i<arr.size()-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > arr[i-1]) count++;\\n\\n            else if(arr[i] <arr[i+1] && arr[i]<arr[i-1]) count++;\\n\\n\\n        }\\n\\n        return count;\\n\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n\\n        vector<int> arr{nums[0]};\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]!=nums[i]){\\n                arr.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i=1; i<arr.size()-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > arr[i-1]) count++;\\n\\n            else if(arr[i] <arr[i+1] && arr[i]<arr[i-1]) count++;\\n\\n\\n        }\\n\\n        return count;\\n\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724501,
                "title": "java-simple-readable",
                "content": "Code is self explanatory, but feel free to ask questions\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int countHillValley(int[] nums) {\\n\\tvar hilleys = 0;\\n\\tvar prev = nums[0];\\n\\n\\tfor (var i = 1; i + 1 < nums.length; i++) {\\n\\t\\tif (nums[i] == prev)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvar isHill = prev < nums[i] && nums[i] > nums[i + 1];\\n\\t\\tvar isValley = prev > nums[i] && nums[i] < nums[i + 1];\\n\\n\\t\\tif (isHill || isValley)\\n\\t\\t\\thilleys++;\\n\\t\\tif (nums[i] != nums[i + 1])\\n\\t\\t\\tprev = nums[i];\\n\\t}\\n\\n\\treturn hilleys;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n\\tvar hilleys = 0;\\n\\tvar prev = nums[0];\\n\\n\\tfor (var i = 1; i + 1 < nums.length; i++) {\\n\\t\\tif (nums[i] == prev)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvar isHill = prev < nums[i] && nums[i] > nums[i + 1];\\n\\t\\tvar isValley = prev > nums[i] && nums[i] < nums[i + 1];\\n\\n\\t\\tif (isHill || isValley)\\n\\t\\t\\thilleys++;\\n\\t\\tif (nums[i] != nums[i + 1])\\n\\t\\t\\tprev = nums[i];\\n\\t}\\n\\n\\treturn hilleys;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721426,
                "title": "2-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count= 0, left = nums[0];\\n        for(int i = 1; i < nums.length - 1; i++)\\n            if(left < nums[i] && nums[i] > nums[i + 1] || left > nums[i] && nums[i] < nums[i + 1]){\\n                count++;\\n                left = nums[i];\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count= 0, left = nums[0];\\n        for(int i = 1; i < nums.length - 1; i++)\\n            if(left < nums[i] && nums[i] > nums[i + 1] || left > nums[i] && nums[i] < nums[i + 1]){\\n                count++;\\n                left = nums[i];\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711856,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Mantain a pointer for the leftmost element of a hill or a valley\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int pointer=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if( (pointer<nums[i] && nums[i]>nums[i+1]) || (nums[i]<pointer && nums[i]<nums[i+1]) ){\\n                count++;\\n                pointer=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n//commment if you like the solution\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int pointer=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if( (pointer<nums[i] && nums[i]>nums[i+1]) || (nums[i]<pointer && nums[i]<nums[i+1]) ){\\n                count++;\\n                pointer=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n//commment if you like the solution\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704360,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        counter = 0\\n        temp = nums[0]\\n        for ind, i in enumerate(nums[1:-1], start=1):\\n            if i < temp and i < nums[ind + 1] or i > temp and i > nums[ind+1]:\\n                counter += 1\\n                temp = i\\n        return counter       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        counter = 0\\n        temp = nums[0]\\n        for ind, i in enumerate(nums[1:-1], start=1):\\n            if i < temp and i < nums[ind + 1] or i > temp and i > nums[ind+1]:\\n                counter += 1\\n                temp = i\\n        return counter       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696321,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        let diff = nums[1] - nums[0];\\n        let currDiff = 0;\\n        let count = 0;\\n        for(let i = 2; i < nums.length; i++) {\\n            currDiff = nums[i] - nums[i - 1];\\n            if(currDiff != 0) {\\n                if(currDiff * diff < 0) count++;\\n                diff = currDiff;\\n            }\\n        }\\n        return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        let diff = nums[1] - nums[0];\\n        let currDiff = 0;\\n        let count = 0;\\n        for(let i = 2; i < nums.length; i++) {\\n            currDiff = nums[i] - nums[i - 1];\\n            if(currDiff != 0) {\\n                if(currDiff * diff < 0) count++;\\n                diff = currDiff;\\n            }\\n        }\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690943,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove adjecent duplicates and apply the condition \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        nums.clear();\\n      \\n        int count=0;\\n        for(int i=2;i<res.size();i++){\\n            if(res[i-2]>res[i-1] && res[i-1]<res[i]){\\n                count++;\\n            }\\n            else if(res[i-2]<res[i-1] && res[i-1]>res[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        nums.clear();\\n      \\n        int count=0;\\n        for(int i=2;i<res.size();i++){\\n            if(res[i-2]>res[i-1] && res[i-1]<res[i]){\\n                count++;\\n            }\\n            else if(res[i-2]<res[i-1] && res[i-1]>res[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689763,
                "title": "scala-solution",
                "content": "# Code\\n```\\nobject Solution {\\n    def countHillValley(list: Array[Int]): Int = {\\n    var i = 0\\n      var count: Int = 0\\n      while (i < list.length - 1) {\\n        val leftNonEqual = (i - 1 to 0 by -1).collectFirst { case x if list(x) != list(i) => x }\\n        val rightNonEqual = (i + 1 until list.length).collectFirst { case x if list(x) != list(i) => x }\\n\\n        val isHillOrValley = for {\\n          left <- leftNonEqual\\n          right <- rightNonEqual\\n        } yield (list(left) < list(i) && list(i) > list(right)) || (list(left) > list(i) && list(i) < list(right))\\n\\n        i = rightNonEqual.getOrElse(i + 1)\\n        count += (isHillOrValley match {\\n          case Some(true) => 1\\n          case _ => 0\\n        })\\n      }\\n\\n      count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countHillValley(list: Array[Int]): Int = {\\n    var i = 0\\n      var count: Int = 0\\n      while (i < list.length - 1) {\\n        val leftNonEqual = (i - 1 to 0 by -1).collectFirst { case x if list(x) != list(i) => x }\\n        val rightNonEqual = (i + 1 until list.length).collectFirst { case x if list(x) != list(i) => x }\\n\\n        val isHillOrValley = for {\\n          left <- leftNonEqual\\n          right <- rightNonEqual\\n        } yield (list(left) < list(i) && list(i) > list(right)) || (list(left) > list(i) && list(i) < list(right))\\n\\n        i = rightNonEqual.getOrElse(i + 1)\\n        count += (isHillOrValley match {\\n          case Some(true) => 1\\n          case _ => 0\\n        })\\n      }\\n\\n      count\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3688446,
                "title": "easy-c-for-beginner",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2) as for every element we are traversing the array for left and right in worst case it can go n2\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as we are not using any as such space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n\\n        for(int i=1;i<n-1;i++){\\n            // if same hill\\n            if(nums[i] == nums[i+1])continue;\\n\\n            // else find the first left index which is not equal\\n            int j = i-1;\\n            int left = -1;\\n            while(j >= 0){\\n                if(nums[j] != nums[i]){\\n                    left = nums[j];\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            // also find the first right index which is not equal\\n            j=i+1;\\n            int right = -1;\\n            while(j < n){\\n                if(nums[j] != nums[i]){\\n                    right = nums[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            // if u have both left and right available i.e != -1 then check for hill or valley and increase the ans\\n            if(left != -1 and right != -1 and nums[i] > left and nums[i] > right)ans++;\\n            else if(left != -1 and right != -1 and nums[i] < left and nums[i] < right)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n\\n        for(int i=1;i<n-1;i++){\\n            // if same hill\\n            if(nums[i] == nums[i+1])continue;\\n\\n            // else find the first left index which is not equal\\n            int j = i-1;\\n            int left = -1;\\n            while(j >= 0){\\n                if(nums[j] != nums[i]){\\n                    left = nums[j];\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            // also find the first right index which is not equal\\n            j=i+1;\\n            int right = -1;\\n            while(j < n){\\n                if(nums[j] != nums[i]){\\n                    right = nums[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            // if u have both left and right available i.e != -1 then check for hill or valley and increase the ans\\n            if(left != -1 and right != -1 and nums[i] > left and nums[i] > right)ans++;\\n            else if(left != -1 and right != -1 and nums[i] < left and nums[i] < right)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686323,
                "title": "c-single-pass-elegant-clean-easy-o-1-space-o-n-time",
                "content": "# Intuition\\nIncrement the count in case: \\n    - When we are at the hill and if we have already seen the valley in the past. \\n    - When we are at the Valley and if we have already seen the Hill in the past. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // last_pos = 0  --> Initial position\\n    // last_pos = 1  --> At the Hill.\\n    // last_pos = 2  --> At the Valley.\\n\\n    #define START   0\\n    #define HILL    1\\n    #define VALLEY  2\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0, last_pos = START;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                count += (last_pos == VALLEY ? 1 : 0);\\n                last_pos = HILL;\\n            } else if (nums[i] < nums[i - 1]) {\\n                count += (last_pos == HILL ? 1 : 0);\\n                last_pos = VALLEY;\\n            }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // last_pos = 0  --> Initial position\\n    // last_pos = 1  --> At the Hill.\\n    // last_pos = 2  --> At the Valley.\\n\\n    #define START   0\\n    #define HILL    1\\n    #define VALLEY  2\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0, last_pos = START;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                count += (last_pos == VALLEY ? 1 : 0);\\n                last_pos = HILL;\\n            } else if (nums[i] < nums[i - 1]) {\\n                count += (last_pos == HILL ? 1 : 0);\\n                last_pos = VALLEY;\\n            }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678492,
                "title": "easy-o-n-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ct=0,n=nums.size();\\n        vector<int> dp1(n,-1),dp2(n,-1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==nums[i-1]) dp1[i]=dp1[i-1];\\n            else dp1[i]=nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]==nums[i+1]) dp2[i]=dp2[i+1];\\n            else dp2[i]=nums[i+1];\\n        }\\n        for(int i=1;i<n-1;i++){\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]>dp1[i] && nums[i]>dp2[i] && nums[i]!=nums[i-1]) ct++;\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]<dp1[i] && nums[i]<dp2[i] && nums[i]!=nums[i-1]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ct=0,n=nums.size();\\n        vector<int> dp1(n,-1),dp2(n,-1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==nums[i-1]) dp1[i]=dp1[i-1];\\n            else dp1[i]=nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]==nums[i+1]) dp2[i]=dp2[i+1];\\n            else dp2[i]=nums[i+1];\\n        }\\n        for(int i=1;i<n-1;i++){\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]>dp1[i] && nums[i]>dp2[i] && nums[i]!=nums[i-1]) ct++;\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]<dp1[i] && nums[i]<dp2[i] && nums[i]!=nums[i-1]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676413,
                "title": "easy-c-solution-beginner-friendly-two-pointer-tail-pointer-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    for (int i=1, j=0; i<nums.size()-1; i++)\\n        if((nums[j]<nums[i] && nums[i]>nums[i+1]) || (nums[j]>nums[i] && nums[i]<nums[i+1]))\\n        {\\n            ans++;\\n            j = i;\\n        }            \\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    for (int i=1, j=0; i<nums.size()-1; i++)\\n        if((nums[j]<nums[i] && nums[i]>nums[i+1]) || (nums[j]>nums[i] && nums[i]<nums[i+1]))\\n        {\\n            ans++;\\n            j = i;\\n        }            \\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671491,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n\\n        for (int i=1 ; i<nums.size()-1 ; i++){\\n            int left=-1 , right=-1;\\n            int j=i-1 ; \\n            while (j>=0){\\n                if (nums[j] != nums[i]){\\n                    left = j;\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            j = i+1;\\n            while (j<nums.size()){\\n                if (nums[j] != nums[i]){\\n                    right = j;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (left == -1 || right == -1)\\n                continue;\\n\\n            if (nums[i]>max(nums[left] , nums[right]) || nums[i]<min(nums[left] , nums[right])){    \\n                if (nums[i] != nums[i-1]) {\\n                    ans++;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n\\n        for (int i=1 ; i<nums.size()-1 ; i++){\\n            int left=-1 , right=-1;\\n            int j=i-1 ; \\n            while (j>=0){\\n                if (nums[j] != nums[i]){\\n                    left = j;\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            j = i+1;\\n            while (j<nums.size()){\\n                if (nums[j] != nums[i]){\\n                    right = j;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (left == -1 || right == -1)\\n                continue;\\n\\n            if (nums[i]>max(nums[left] , nums[right]) || nums[i]<min(nums[left] , nums[right])){    \\n                if (nums[i] != nums[i-1]) {\\n                    ans++;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665297,
                "title": "1ms-solution-and-100-less-memory-ovecomplicated-solution-rust-tm-noob",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut i: usize = 1;\\n        while i < nums.len()-1 {\\n            let mut temp_i: usize = i;\\n            let mut what: u8 = 0;\\n            // o: neither, 1: hill, 2: valley\\n            while temp_i > 0{\\n                temp_i -= 1;\\n                if nums[i] < nums[temp_i]{\\n                    what = 2; // valley\\n                    break;\\n                }\\n                if nums[i] > nums[temp_i]{\\n                    what = 1; // hill\\n                    break;\\n                }\\n                what = 0;\\n                if temp_i == 0 {break;}\\n            }\\n            if what == 0 {\\n                i += 1;\\n                continue;\\n            }\\n            let mut temp_i: usize = i;\\n            while temp_i < nums.len(){\\n                temp_i += 1;\\n                if what == 2 && nums[i] < nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                if what == 1 && nums[i] > nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                what = 0;\\n            }\\n            if what == 0  {i += 1;}\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut i: usize = 1;\\n        while i < nums.len()-1 {\\n            let mut temp_i: usize = i;\\n            let mut what: u8 = 0;\\n            // o: neither, 1: hill, 2: valley\\n            while temp_i > 0{\\n                temp_i -= 1;\\n                if nums[i] < nums[temp_i]{\\n                    what = 2; // valley\\n                    break;\\n                }\\n                if nums[i] > nums[temp_i]{\\n                    what = 1; // hill\\n                    break;\\n                }\\n                what = 0;\\n                if temp_i == 0 {break;}\\n            }\\n            if what == 0 {\\n                i += 1;\\n                continue;\\n            }\\n            let mut temp_i: usize = i;\\n            while temp_i < nums.len(){\\n                temp_i += 1;\\n                if what == 2 && nums[i] < nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                if what == 1 && nums[i] > nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                what = 0;\\n            }\\n            if what == 0  {i += 1;}\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3656200,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=i-1,k=i+1;\\n            while(j>=0 && nums[j]==nums[i]) j--;\\n            while(k<nums.size() && nums[k]==nums[i]) k++;\\n            if(j>=0 && k<nums.size())\\n            {\\n                if(nums[i]>nums[j] && nums[i]>nums[k]) c++;\\n                if(nums[i]<nums[j] && nums[i]<nums[k]) c++;\\n                i=k-1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=i-1,k=i+1;\\n            while(j>=0 && nums[j]==nums[i]) j--;\\n            while(k<nums.size() && nums[k]==nums[i]) k++;\\n            if(j>=0 && k<nums.size())\\n            {\\n                if(nums[i]>nums[j] && nums[i]>nums[k]) c++;\\n                if(nums[i]<nums[j] && nums[i]<nums[k]) c++;\\n                i=k-1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647317,
                "title": "php-two-pointers-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countHillValley($nums) {\\n        $j = 0;\\n        $count = 0;\\n\\n        // Iterate through the array, excluding the first and last elements\\n        for($i = 1; $i < count($nums)-1; $i++) {\\n            \\n            // Check if the current element is part of a hill\\n            if($nums[$i] > $nums[$j] && $nums[$i] > $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n            \\n            // Check if the current element is part of a valley\\n            if($nums[$i] < $nums[$j] && $nums[$i] < $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countHillValley($nums) {\\n        $j = 0;\\n        $count = 0;\\n\\n        // Iterate through the array, excluding the first and last elements\\n        for($i = 1; $i < count($nums)-1; $i++) {\\n            \\n            // Check if the current element is part of a hill\\n            if($nums[$i] > $nums[$j] && $nums[$i] > $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n            \\n            // Check if the current element is part of a valley\\n            if($nums[$i] < $nums[$j] && $nums[$i] < $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602803,
                "title": "eliminate-duplicates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEliminate Duplicates and check the condition for a hill or a valley. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate over the array (after removing duplicates) and compare current elements with the one before and the one after and if the number is smaller than both or greater than both, increase the number of valleys/hills by one.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntime: O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace: O(n)\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = [nums[0]]\\n        for x in nums[1:]:\\n            if x != res[-1]:\\n                res.append(x)\\n\\n        ans = 0\\n        for i in range(1, len(res) - 1):\\n            if (res[i] > res[i -1] and res[i] > res[i+1]\\n                or res[i] < res[i -1] and res[i] < res[i+1]):\\n                ans += 1    \\n\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = [nums[0]]\\n        for x in nums[1:]:\\n            if x != res[-1]:\\n                res.append(x)\\n\\n        ans = 0\\n        for i in range(1, len(res) - 1):\\n            if (res[i] > res[i -1] and res[i] > res[i+1]\\n                or res[i] < res[i -1] and res[i] < res[i+1]):\\n                ans += 1    \\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597019,
                "title": "o-n-c-faster-than-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n      \\n int i=0,j=i+2;\\n int id=1;\\n   int count=0;\\n while(id<nums.size()-1){\\n   if(nums[id]==nums[j]){\\n     j++;\\n     id++;\\n     continue;\\n     }\\n   \\n     \\n   if(nums[i]<nums[id]&&nums[id]>nums[j])\\n  count++;\\n if(nums[i]>nums[id]&&nums[id]<nums[j])\\n\\n  count++;\\n     \\n \\n i=id,id++,j++;    \\n }    \\n     \\n  return count;\\n    }\\n};[](http://)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n      \\n int i=0,j=i+2;\\n int id=1;\\n   int count=0;\\n while(id<nums.size()-1){\\n   if(nums[id]==nums[j]){\\n     j++;\\n     id++;\\n     continue;\\n     }\\n   \\n     \\n   if(nums[i]<nums[id]&&nums[id]>nums[j])\\n  count++;\\n if(nums[i]>nums[id]&&nums[id]<nums[j])\\n\\n  count++;\\n     \\n \\n i=id,id++,j++;    \\n }    \\n     \\n  return count;\\n    }\\n};[](http://)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590537,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        ans=0\\n        prev=0\\n        for i in range(1,len(nums)-1):\\n            curr=i\\n            if (nums[curr]<nums[prev] and nums[curr]<nums[curr+1]) or (nums[curr]>nums[curr+1] and nums[curr]>nums[prev]):\\n                ans+=1\\n                prev=curr\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        ans=0\\n        prev=0\\n        for i in range(1,len(nums)-1):\\n            curr=i\\n            if (nums[curr]<nums[prev] and nums[curr]<nums[curr+1]) or (nums[curr]>nums[curr+1] and nums[curr]>nums[prev]):\\n                ans+=1\\n                prev=curr\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590450,
                "title": "count-hills-and-valleys-in-an-array-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n        vector<int> pre, suf;\\n        suf.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    pre.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==nums.size()-1)\\n                pre.push_back(0);\\n            }\\n        }\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    suf.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==0)\\n                suf.push_back(0);\\n            }\\n        }\\n\\n        pre.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cout<<pre[i]<<\" \"<<suf[i]<<endl;\\n        }\\n\\n        int hill=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==0 || i==nums.size()-1)\\n            continue;\\n\\n            cout<<\"nums=\"<<nums[i]<<\" pre=\"<<pre[i]<<\" suf=\"<<suf[i]<<endl;\\n            if(nums[i]==nums[i-1])\\n            continue;\\n\\n            if(nums[i]>pre[i] && nums[i]>suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;\\n            }\\n            else if(nums[i]<pre[i] && nums[i]<suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;}\\n        }\\n\\n        return hill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n        vector<int> pre, suf;\\n        suf.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    pre.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==nums.size()-1)\\n                pre.push_back(0);\\n            }\\n        }\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    suf.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==0)\\n                suf.push_back(0);\\n            }\\n        }\\n\\n        pre.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cout<<pre[i]<<\" \"<<suf[i]<<endl;\\n        }\\n\\n        int hill=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==0 || i==nums.size()-1)\\n            continue;\\n\\n            cout<<\"nums=\"<<nums[i]<<\" pre=\"<<pre[i]<<\" suf=\"<<suf[i]<<endl;\\n            if(nums[i]==nums[i-1])\\n            continue;\\n\\n            if(nums[i]>pre[i] && nums[i]>suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;\\n            }\\n            else if(nums[i]<pre[i] && nums[i]<suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;}\\n        }\\n\\n        return hill;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3580508,
                "title": "beats-100-o-n-vector",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n         for(int i=1;i<nums.size();i++)\\n         {\\n             if(nums[i]!=nums[i-1])\\n              v.push_back(nums[i]);\\n         }\\n         int count=0,i=1;\\n         while(i<v.size()-1)\\n         {\\n             if(v[i]<v[i-1]&&v[i]<v[i+1])\\n               count++;\\n             else if(v[i]>v[i-1]&&v[i]>v[i+1])  \\n                 count++;\\n            i++;     \\n         }\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n         for(int i=1;i<nums.size();i++)\\n         {\\n             if(nums[i]!=nums[i-1])\\n              v.push_back(nums[i]);\\n         }\\n         int count=0,i=1;\\n         while(i<v.size()-1)\\n         {\\n             if(v[i]<v[i-1]&&v[i]<v[i+1])\\n               count++;\\n             else if(v[i]>v[i-1]&&v[i]>v[i+1])  \\n                 count++;\\n            i++;     \\n         }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567207,
                "title": "beats-72-85-simple-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        int count = 0;\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i-1]>ans[i] && ans[i]<ans[i+1]){\\n                count ++;\\n            }\\n            else if(ans[i-1]<ans[i] && ans[i]>ans[i+1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        int count = 0;\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i-1]>ans[i] && ans[i]<ans[i+1]){\\n                count ++;\\n            }\\n            else if(ans[i-1]<ans[i] && ans[i]>ans[i+1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550699,
                "title": "very-easy-to-read-python-solution-o-n-time-and-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: O(N) for iterating through nums once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) for constants\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        sum = 0\\n        # working with left, middle, and right and passing those values to the left in the loop\\n        # just storing indices\\n        m, r = 0, 1\\n        while True:\\n            # pass values from right to left\\n            l, m = m, r\\n\\n            # find right value and skip duplicates. The prior line passing down values makes it so the duplicates are skipped again.\\n            while r < len(nums)-1 and nums[r] == nums[m]: r += 1\\n\\n            # if left and right are greater than m. hill. OR left and right less than m. valley. increment sum\\n            if nums[l] > nums[m] and nums[r] > nums[m] or nums[l] < nums[m] and nums[r] < nums[m]: sum += 1\\n\\n            # if right has hit end of the list return sum\\n            if r == len(nums)-1: return sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        sum = 0\\n        # working with left, middle, and right and passing those values to the left in the loop\\n        # just storing indices\\n        m, r = 0, 1\\n        while True:\\n            # pass values from right to left\\n            l, m = m, r\\n\\n            # find right value and skip duplicates. The prior line passing down values makes it so the duplicates are skipped again.\\n            while r < len(nums)-1 and nums[r] == nums[m]: r += 1\\n\\n            # if left and right are greater than m. hill. OR left and right less than m. valley. increment sum\\n            if nums[l] > nums[m] and nums[r] > nums[m] or nums[l] < nums[m] and nums[r] < nums[m]: sum += 1\\n\\n            # if right has hit end of the list return sum\\n            if r == len(nums)-1: return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548284,
                "title": "simple-iteration-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int left = nums[0], right;\\n        for(int i=1; i < nums.size()-1; i++){\\n            if(nums[i]==nums[i+1]) continue;\\n            right = nums[i + 1];\\n            if(left < nums[i] and right < nums[i] or left > nums[i] and right > nums[i]) count++;\\n            left = nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        for(int i=1; i < nums.size()-1; i++){\\n            int left = -1, right = -1;\\n            if(nums[i]==nums[i-1]){\\n                int j = i - 1;\\n                while(j!=-1){\\n                    if(nums[i]!=nums[j]){\\n                        left = nums[j];\\n                        break;\\n                    }\\n                    j--;\\n                }\\n                if(left == -1) continue;\\n            }\\n            else left = nums[i-1];\\n\\n            if(nums[i]==nums[i+1]){\\n                int j = i + 1;\\n                while(j!=nums.size()){\\n                    if(nums[i]!=nums[j]){\\n                        right = nums[j];\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                if(right == -1) continue;\\n            }\\n            else right = nums[i+1];\\n            if(((nums[i] < left and nums[i] < right) or (nums[i] > left and nums[i] > right)) and nums[i]!=nums[i-1]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int left = nums[0], right;\\n        for(int i=1; i < nums.size()-1; i++){\\n            if(nums[i]==nums[i+1]) continue;\\n            right = nums[i + 1];\\n            if(left < nums[i] and right < nums[i] or left > nums[i] and right > nums[i]) count++;\\n            left = nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        for(int i=1; i < nums.size()-1; i++){\\n            int left = -1, right = -1;\\n            if(nums[i]==nums[i-1]){\\n                int j = i - 1;\\n                while(j!=-1){\\n                    if(nums[i]!=nums[j]){\\n                        left = nums[j];\\n                        break;\\n                    }\\n                    j--;\\n                }\\n                if(left == -1) continue;\\n            }\\n            else left = nums[i-1];\\n\\n            if(nums[i]==nums[i+1]){\\n                int j = i + 1;\\n                while(j!=nums.size()){\\n                    if(nums[i]!=nums[j]){\\n                        right = nums[j];\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                if(right == -1) continue;\\n            }\\n            else right = nums[i+1];\\n            if(((nums[i] < left and nums[i] < right) or (nums[i] > left and nums[i] > right)) and nums[i]!=nums[i-1]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542126,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i = 1, j = 0, k = 2; i < nums.length - 1; i++, j++, k++) {\\n            boolean isTheSameHillOrValley = i > 1 && nums[i] == nums[i - 1];\\n            if (!isTheSameHillOrValley) {\\n                int l = nums[j], m = nums[i], r = nums[k];\\n                if (l == m) {\\n                    int index = j;\\n                    while (index > 0 && l == m) {\\n                        l = nums[--index];\\n                    }\\n                }\\n                if (r == m) {\\n                    int index = k;\\n                    while (index + 1 < nums.length && r == m) {\\n                        r = nums[++index];\\n                    }\\n                }\\n                if ((m > l && m > r) || (m < l && m < r)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i = 1, j = 0, k = 2; i < nums.length - 1; i++, j++, k++) {\\n            boolean isTheSameHillOrValley = i > 1 && nums[i] == nums[i - 1];\\n            if (!isTheSameHillOrValley) {\\n                int l = nums[j], m = nums[i], r = nums[k];\\n                if (l == m) {\\n                    int index = j;\\n                    while (index > 0 && l == m) {\\n                        l = nums[--index];\\n                    }\\n                }\\n                if (r == m) {\\n                    int index = k;\\n                    while (index + 1 < nums.length && r == m) {\\n                        r = nums[++index];\\n                    }\\n                }\\n                if ((m > l && m > r) || (m < l && m < r)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525060,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        auto result = 0;\\n        for (auto l = 0, m = 1, r = 2; r < nums.size(); ++m, ++r) {\\n            if (nums[m] == nums[r]) continue;\\n            if (nums[l] > nums[m] && nums[m] < nums[r] || nums[l] < nums[m] && nums[m] > nums[r]) ++result;\\n            l = m;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        auto result = 0;\\n        for (auto l = 0, m = 1, r = 2; r < nums.size(); ++m, ++r) {\\n            if (nums[m] == nums[r]) continue;\\n            if (nums[l] > nums[m] && nums[m] < nums[r] || nums[l] < nums[m] && nums[m] > nums[r]) ++result;\\n            l = m;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515009,
                "title": "java-beats-100-solution",
                "content": "# Intuition -- Iteration over the array.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach-- Iterating over the array and checking the conditions according to questions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        int left = nums[0];\\n        int end = nums[nums.length-1];\\n        int hill = 0;\\n        int valley=0; \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]!=left && nums[i]>left && nums[i]>nums[i+1]){\\n                hill++;\\n                left=nums[i];\\n            }else if(nums[i]!=left && nums[i]<left && nums[i]<nums[i+1]){\\n                valley++;\\n                left=nums[i];\\n            }\\n            \\n        }\\n        return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        int left = nums[0];\\n        int end = nums[nums.length-1];\\n        int hill = 0;\\n        int valley=0; \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]!=left && nums[i]>left && nums[i]>nums[i+1]){\\n                hill++;\\n                left=nums[i];\\n            }else if(nums[i]!=left && nums[i]<left && nums[i]<nums[i+1]){\\n                valley++;\\n                left=nums[i];\\n            }\\n            \\n        }\\n        return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483965,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int val=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>val&&nums[i]>nums[i+1])||(nums[i]<val&&nums[i]<nums[i+1])){\\n                count++;\\n                 val=nums[i];\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int val=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>val&&nums[i]>nums[i+1])||(nums[i]<val&&nums[i]<nums[i+1])){\\n                count++;\\n                 val=nums[i];\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1846182,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1675543,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1974428,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1942903,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1698914,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Positions on Street With Required Brightness",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Count Unguarded Cells in the Grid",
        "question_content": "<p>You are given two integers <code>m</code> and <code>n</code> representing a <strong>0-indexed</strong> <code>m x n</code> grid. You are also given two 2D integer arrays <code>guards</code> and <code>walls</code> where <code>guards[i] = [row<sub>i</sub>, col<sub>i</sub>]</code> and <code>walls[j] = [row<sub>j</sub>, col<sub>j</sub>]</code> represent the positions of the <code>i<sup>th</sup></code> guard and <code>j<sup>th</sup></code> wall respectively.</p>\n\n<p>A guard can see <b>every</b> cell in the four cardinal directions (north, east, south, or west) starting from their position unless <strong>obstructed</strong> by a wall or another guard. A cell is <strong>guarded</strong> if there is <strong>at least</strong> one guard that can see it.</p>\n\n<p>Return<em> the number of unoccupied cells that are <strong>not</strong> <strong>guarded</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png\" style=\"width: 300px; height: 204px;\" />\n<pre>\n<strong>Input:</strong> m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png\" style=\"width: 200px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= guards.length, walls.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>2 &lt;= guards.length + walls.length &lt;= m * n</code></li>\n\t<li><code>guards[i].length == walls[j].length == 2</code></li>\n\t<li><code>0 &lt;= row<sub>i</sub>, row<sub>j</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= col<sub>i</sub>, col<sub>j</sub> &lt; n</code></li>\n\t<li>All the positions in <code>guards</code> and <code>walls</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1994554,
                "title": "easy-c-code-with-explanation",
                "content": "Solving by brute force,\\n\\nWe first create a grid of the given rows & columns and initiliaze every cell to 0. We indicate the walls as -2 and guards as 2.\\nWe iterate over the entire guards, for every guard we traverse in the 4 directions (left,right,up,down) until we find a wall or a guard.\\nUntil we find a wall or guard, we mark the cell as 1 to indicate it can be guarded by the guard.\\n\\nSo finally we just count the elements which are 0, so these are the cells which are not guarded.\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        // m is no. of rows, n is no. of columns, g is guards vector and w is walls vector\\n        vector<vector<int>> v(m, vector<int> (n,0));\\n        int k = w.size();\\n        for(int i=0;i<k;i++){\\n            int x = w[i][0], y = w[i][1];\\n            v[x][y] = -2;\\n        }\\n        k = g.size();\\n        for(int i=0;i<k;i++){\\n            int x = g[i][0], y = g[i][1];\\n            v[x][y] = 2;\\n        }\\n        for(int j=0;j<k;j++){\\n            int x = g[j][0], y = g[j][1];\\n            for(int i=x-1;i>=0;i--){ // up\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=x+1;i<m;i++){ // down\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=y-1;i>=0;i--){ // left\\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n            for(int i=y+1;i<n;i++){ // right\\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!v[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Reason for solutions which got TLE:**\\nLet\\'s say if m=10^5 and n=1 and g = 10^5-1 guards are present one after another in the same line from first cell.\\nIf we don\\'t mark the guards prior for checking the guarded cells, then you end up travelling the same cell many times as you don\\'t know some other cells of guard.\\nThen time complexity = (g-1) + (g-2) + ... 1 = g*(g-1)/2. So it is nearly equal to 10^9. So it leads to TLE.\\n\\nSo marking the guard cells prior to checking, stops the revisiting of cell as you stop the iteration, whenever you find a guard.\\n\\nThanks to @kurshcise for pointing it out.\\nYou can find out his explanation in the comments.\\n\\n**Upvote if it helps !**\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        // m is no. of rows, n is no. of columns, g is guards vector and w is walls vector\\n        vector<vector<int>> v(m, vector<int> (n,0));\\n        int k = w.size();\\n        for(int i=0;i<k;i++){\\n            int x = w[i][0], y = w[i][1];\\n            v[x][y] = -2;\\n        }\\n        k = g.size();\\n        for(int i=0;i<k;i++){\\n            int x = g[i][0], y = g[i][1];\\n            v[x][y] = 2;\\n        }\\n        for(int j=0;j<k;j++){\\n            int x = g[j][0], y = g[j][1];\\n            for(int i=x-1;i>=0;i--){ // up\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=x+1;i<m;i++){ // down\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=y-1;i>=0;i--){ // left\\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n            for(int i=y+1;i<n;i++){ // right\\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!v[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994547,
                "title": "java-simulation",
                "content": "Original thought:\\n\\n1. Mark all the walls.\\n2. Mark all the guards, while pushing their position into a queue\\n3. For each entry in the queue, traverse in all 4 directions until a Guard or Wall is reached\\n4. Iterate over the entire grid counting for non Guard(G), Wall(W), Protected(P) cells\\n\\nOptimized: Using existing `guards` array eliminating queue, and reverse counting marked cells(G,W,P) eliminating O(m * n) iteration for counting.\\n\\nThanks @gengineer, @alisol33 and @boolanik for valuable suggestions\\n```\\nclass Solution\\n{\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        char[][] grid= new char[m][n];\\n        int count = m*n - guards.length - walls.length;\\n        for(int[] wall : walls)\\n        {\\n            int x = wall[0], y = wall[1];\\n            grid[x][y] = \\'W\\';\\n        }\\n        for(int[] guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            grid[x][y] = \\'G\\';\\n        }\\n        for(int[] point : guards)\\n        {\\n            for(int dir[] : dirs)\\n            {\\n                int x = point[0] + dir[0];\\n                int y = point[1] + dir[1];\\n                while(!(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == \\'G\\' || grid[x][y] == \\'W\\'))\\n                {\\n                    if(grid[x][y] != \\'P\\')\\n                        count--;\\n                    grid[x][y] = \\'P\\';\\n                    x += dir[0];\\n                    y += dir[1];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nOriginal solution\\n```\\nclass Solution\\n{\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        char[][] grid= new char[m][n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int[] wall : walls)\\n        {\\n            int x = wall[0], y = wall[1];\\n            grid[x][y] = \\'W\\';\\n        }\\n        for(int[] guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            grid[x][y] = \\'G\\';\\n            queue.offer(guard);\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            int[] point = queue.poll();\\n            for(int dir[] : dirs)\\n            {\\n                int x = point[0] + dir[0];\\n                int y = point[1] + dir[1];\\n                while(!(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == \\'G\\' || grid[x][y] == \\'W\\'))\\n                {\\n                    grid[x][y] = \\'P\\';\\n                    x += dir[0];\\n                    y += dir[1];\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] != \\'G\\' && grid[i][j] != \\'W\\' && grid[i][j] != \\'P\\')\\n                    count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        char[][] grid= new char[m][n];\\n        int count = m*n - guards.length - walls.length;\\n        for(int[] wall : walls)\\n        {\\n            int x = wall[0], y = wall[1];\\n            grid[x][y] = \\'W\\';\\n        }\\n        for(int[] guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            grid[x][y] = \\'G\\';\\n        }\\n        for(int[] point : guards)\\n        {\\n            for(int dir[] : dirs)\\n            {\\n                int x = point[0] + dir[0];\\n                int y = point[1] + dir[1];\\n                while(!(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == \\'G\\' || grid[x][y] == \\'W\\'))\\n                {\\n                    if(grid[x][y] != \\'P\\')\\n                        count--;\\n                    grid[x][y] = \\'P\\';\\n                    x += dir[0];\\n                    y += dir[1];\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        char[][] grid= new char[m][n];\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int[] wall : walls)\\n        {\\n            int x = wall[0], y = wall[1];\\n            grid[x][y] = \\'W\\';\\n        }\\n        for(int[] guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            grid[x][y] = \\'G\\';\\n            queue.offer(guard);\\n        }\\n        while(!queue.isEmpty())\\n        {\\n            int[] point = queue.poll();\\n            for(int dir[] : dirs)\\n            {\\n                int x = point[0] + dir[0];\\n                int y = point[1] + dir[1];\\n                while(!(x < 0 || y < 0 || x >= m || y >= n || grid[x][y] == \\'G\\' || grid[x][y] == \\'W\\'))\\n                {\\n                    grid[x][y] = \\'P\\';\\n                    x += dir[0];\\n                    y += dir[1];\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] != \\'G\\' && grid[i][j] != \\'W\\' && grid[i][j] != \\'P\\')\\n                    count++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994677,
                "title": "python-very-simple-python-solution",
                "content": "**Idea**\\nCreate grid. Map locations of guards and walls and set location to `1`\\nIterate through guard locations and visit horizontal and vertical locations until we hit a wall/guard (**not guard path**) or the end of the map. Set these guard path locations to `2`.  We set this to `2` instead of `1` in order to distinguish guard path and original guard/wall. Count the remaining `0`s (not guard path, guard or wall). \\n\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for x, y in guards+walls:\\n            dp[x][y] = 1\\n               \\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        \\n        for x, y in guards:\\n            for dx, dy in directions:\\n                curr_x = x\\n                curr_y = y\\n                \\n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and dp[curr_x+dx][curr_y+dy] != 1:\\n                    curr_x += dx\\n                    curr_y += dy\\n                    dp[curr_x][curr_y] = 2\\n                    \\n        return sum(1 for i in range(m) for j in range(n) if dp[i][j] == 0)                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        dp = [[0] * n for _ in range(m)]\\n        for x, y in guards+walls:\\n            dp[x][y] = 1\\n               \\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        \\n        for x, y in guards:\\n            for dx, dy in directions:\\n                curr_x = x\\n                curr_y = y\\n                \\n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and dp[curr_x+dx][curr_y+dy] != 1:\\n                    curr_x += dx\\n                    curr_y += dy\\n                    dp[curr_x][curr_y] = 2\\n                    \\n        return sum(1 for i in range(m) for j in range(n) if dp[i][j] == 0)                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001912,
                "title": "bitmask-tracing-vs-binary-search",
                "content": "#### Bitmask Tracing\\nHere, we build a grid to place guards and walls, and trace guarded cells. \\n\\nOne way to avoid TLE is to place all guards first (and walls, of course), and then trace from each guard in four directions until you hit an edge, a wall, or another guard.\\n\\nHere, however, we track the direction for each cell using a bitmask. We stop when we hit a cell that was already traced in the same direction. That way, we do not have to place all guards first.\\n\\n**C++**\\n```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    int not_guarded = m * n - walls.size();\\n    vector<vector<int>> g(m, vector<int>(n));\\n    for (const auto &wall : walls)\\n        g[wall[0]][wall[1]] = 15;\\n    for (const auto &gd : guards)\\n        for (int d = 0; d < 4; ++d)\\n            for (int i = gd[0], j = gd[1]; min(i, j) >= 0 && i < m && j < n && (g[i][j] & (1 << d)) == 0; ) {\\n                not_guarded -= g[i][j] == 0;\\n                g[i][j] += (1 << d);\\n                i += dir[d];\\n                j += dir[d + 1];\\n            }\\n    return not_guarded;\\n}\\n```\\n#### Binary Search\\nThis solution is efficient for a large grid with a few guards and walls.\\n\\nFor this solution, we track the position of guards and walls in `rows` and `cols` arrays, sorted. Instead of using a grid to trace guarded cells, we use binary search to find out the closest guard or wall in all four directions.\\n\\nWhen there is a wall in all four directions (or nothing), the cell is not guarded. \\n\\n**C++**\\n```cpp\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    vector<vector<pair<int, int>>> rows(m, vector<pair<int, int>>{{-1, 1}, {n, 1}}), cols(n, vector<pair<int, int>>{{-1, 1}, {m, 1}});\\n    for (auto &g : guards) {\\n        rows[g[0]].push_back({g[1], 0});\\n        cols[g[1]].push_back({g[0], 0});\\n    }\\n    for (auto &w : walls) {\\n        rows[w[0]].push_back({w[1], 1});\\n        cols[w[1]].push_back({w[0], 1});\\n    }\\n    for (auto &r : rows)\\n        sort(begin(r), end(r));\\n    for (auto &c : cols)\\n        sort(begin(c), end(c));\\n    int res = 0;\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n            auto it_r = lower_bound(begin(rows[i]), end(rows[i]), pair<int, int>{j, 0});\\n            auto it_c = lower_bound(begin(cols[j]), end(cols[j]), pair<int, int>{i, 0});\\n            if (it_r->first == j && it_c->first == i)\\n                continue;\\n            if (it_r->second == 0 || it_c->second == 0 || prev(it_r)->second == 0 || prev(it_c)->second == 0)\\n                continue;         \\n            ++res;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    int not_guarded = m * n - walls.size();\\n    vector<vector<int>> g(m, vector<int>(n));\\n    for (const auto &wall : walls)\\n        g[wall[0]][wall[1]] = 15;\\n    for (const auto &gd : guards)\\n        for (int d = 0; d < 4; ++d)\\n            for (int i = gd[0], j = gd[1]; min(i, j) >= 0 && i < m && j < n && (g[i][j] & (1 << d)) == 0; ) {\\n                not_guarded -= g[i][j] == 0;\\n                g[i][j] += (1 << d);\\n                i += dir[d];\\n                j += dir[d + 1];\\n            }\\n    return not_guarded;\\n}\\n```\n```cpp\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    vector<vector<pair<int, int>>> rows(m, vector<pair<int, int>>{{-1, 1}, {n, 1}}), cols(n, vector<pair<int, int>>{{-1, 1}, {m, 1}});\\n    for (auto &g : guards) {\\n        rows[g[0]].push_back({g[1], 0});\\n        cols[g[1]].push_back({g[0], 0});\\n    }\\n    for (auto &w : walls) {\\n        rows[w[0]].push_back({w[1], 1});\\n        cols[w[1]].push_back({w[0], 1});\\n    }\\n    for (auto &r : rows)\\n        sort(begin(r), end(r));\\n    for (auto &c : cols)\\n        sort(begin(c), end(c));\\n    int res = 0;\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n            auto it_r = lower_bound(begin(rows[i]), end(rows[i]), pair<int, int>{j, 0});\\n            auto it_c = lower_bound(begin(cols[j]), end(cols[j]), pair<int, int>{i, 0});\\n            if (it_r->first == j && it_c->first == i)\\n                continue;\\n            if (it_r->second == 0 || it_c->second == 0 || prev(it_r)->second == 0 || prev(it_c)->second == 0)\\n                continue;         \\n            ++res;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994758,
                "title": "c-runtime-o-m-n-explained-solution",
                "content": "### Structures used:\\n* mat - 2D vector of size *m* x *n* - Used to mark gaurds(denoted by 2) and walls(denoted by 1)\\n* arr - 3D vector of size *m* x *n* x *4* - marks the position of gaurd in all four positions with respect to the current position.\\n\\n### Explanation\\n* Section 1\\n\\tInitialises the Guards and walls in *mat*\\n* Section 2\\n\\tThe 4 loops check for guards/walls(if any) at current location in all 4 directions. And sets the value of *vector arr*\\n* Section 3\\n\\tfor any position (i, j) to be unguarded, there shouldnt be any gaurd in 4 directions wrt to (i, j). So last loop check for the same and increments *ans* if cell (i, j) is found to be free\\n\\n```\\nint countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) \\n{  \\n    vector<vector<int> > mat(m, vector<int> (n, 0));\\n    vector<vector<vector<int> > > arr(m, vector<vector<int>> (n, vector<int> (4, 0)));\\n    \\n    \\n    //SECTION 1\\n    //Setting up the walls\\n    for(int i = 0; i<w.size(); i++)\\n        mat[w[i][0]][w[i][1]] = -1;\\n\\n    //Setting up the gaurds\\n    for(int i = 0; i<g.size(); i++)\\n        mat[g[i][0]][g[i][1]] = 2; \\n\\n   \\n    //SECTION 2\\n    int left = 0, right = 1, up = 2, down = 3; \\n    //Guards to the left of (i, j)\\n    for(int i =0; i<m; i++)\\n    {\\n        int gg = -1; \\n        for(int j = 0; j< n; j++)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][left] = gg; \\n        }\\n    }\\n    \\n    //Guards to the right of (i, j) \\n    for(int i = 0; i<m; i++)\\n    {\\n        int gg = -1; \\n        for(int j = n-1; j>-1; j--)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][right] = gg;\\n        }\\n    }\\n    \\n    //Guards above (i, j)\\n    for(int j = 0; j < n; j++)\\n    {\\n        int gg = -1; \\n        for(int i = 0; i < m; i++)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][up] = gg; \\n        }\\n    }\\n    \\n    //Guards below (i, j)\\n    for(int j = 0; j < n; j++)\\n    {\\n        int gg = -1; \\n        for(int i = m-1; i > -1; i--)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][down] = gg; \\n        }\\n    }\\n    \\n\\n    //SECTION 3\\n    int ans = 0; \\n    \\n    for(int i =0; i<m; i++)\\n    {\\n        for(int j = 0; j < n; j++)\\n        {\\n            if(arr[i][j][left] == -1 and arr[i][j][right] == -1 and arr[i][j][up] == -1 and arr[i][j][down] == -1)\\n                ans++;\\n        }\\n    }\\n    \\n    return ans;        \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nint countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) \\n{  \\n    vector<vector<int> > mat(m, vector<int> (n, 0));\\n    vector<vector<vector<int> > > arr(m, vector<vector<int>> (n, vector<int> (4, 0)));\\n    \\n    \\n    //SECTION 1\\n    //Setting up the walls\\n    for(int i = 0; i<w.size(); i++)\\n        mat[w[i][0]][w[i][1]] = -1;\\n\\n    //Setting up the gaurds\\n    for(int i = 0; i<g.size(); i++)\\n        mat[g[i][0]][g[i][1]] = 2; \\n\\n   \\n    //SECTION 2\\n    int left = 0, right = 1, up = 2, down = 3; \\n    //Guards to the left of (i, j)\\n    for(int i =0; i<m; i++)\\n    {\\n        int gg = -1; \\n        for(int j = 0; j< n; j++)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][left] = gg; \\n        }\\n    }\\n    \\n    //Guards to the right of (i, j) \\n    for(int i = 0; i<m; i++)\\n    {\\n        int gg = -1; \\n        for(int j = n-1; j>-1; j--)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][right] = gg;\\n        }\\n    }\\n    \\n    //Guards above (i, j)\\n    for(int j = 0; j < n; j++)\\n    {\\n        int gg = -1; \\n        for(int i = 0; i < m; i++)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][up] = gg; \\n        }\\n    }\\n    \\n    //Guards below (i, j)\\n    for(int j = 0; j < n; j++)\\n    {\\n        int gg = -1; \\n        for(int i = m-1; i > -1; i--)\\n        {\\n            if(mat[i][j] == -1)\\n                gg = -1; \\n            else if(mat[i][j] == 2)\\n                gg = j;\\n            else if(mat[i][j] == 0)\\n                arr[i][j][down] = gg; \\n        }\\n    }\\n    \\n\\n    //SECTION 3\\n    int ans = 0; \\n    \\n    for(int i =0; i<m; i++)\\n    {\\n        for(int j = 0; j < n; j++)\\n        {\\n            if(arr[i][j][left] == -1 and arr[i][j][right] == -1 and arr[i][j][up] == -1 and arr[i][j][down] == -1)\\n                ans++;\\n        }\\n    }\\n    \\n    return ans;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994782,
                "title": "simulation",
                "content": "**Mark all the unguarded cells upward, downward, right and left of a guarded cell until Guarded or Walled Cell is found.**\\n\\n**Where :**\\n```\\ng -> cell with a guard\\nw -> cell with a wall\\nd -> guarded cells\\nu -> unguarded cells\\n```\\n```\\nclass Solution {\\npublic:\\n    \\n    void markThem(vector<vector<char>>& prison, int r, int c, int m, int n) {\\n\\n\\t\\t// marking Unguarded Cell in the Right as Guarded until a Guarded or Walled Cell is found.\\n        for (int j=c+1; j<n; j++) {\\n\\t\\t\\t// breaking if wall is found as guard cannot see past that wall.\\n\\t\\t\\t// breaking if cell has a guard as that guard will mark the rest of cells.\\n            if (prison[r][j] == \\'w\\' or prison[r][j] == \\'g\\')    break;\\n            prison[r][j] = \\'d\\'; // marking unguarded cell as guarded.\\n        }\\n\\t\\t\\n\\t\\t// marking Unguarded Cell in the Left as Guarded until a Guarded or Walled Cell is found.\\n        for (int j=c-1; j>=0; j--) {\\n            if (prison[r][j] == \\'w\\' or prison[r][j] == \\'g\\')    break;\\n            prison[r][j] = \\'d\\';\\n        }\\n        \\n\\t\\t// marking Unguarded Cell in the Downward as Guarded until a Guarded or Walled Cell is found.\\n        for (int i=r+1; i<m; i++) {\\n            if (prison[i][c] == \\'w\\' or prison[i][c] == \\'g\\')    break;\\n            prison[i][c] = \\'d\\';\\n        }\\n\\t\\t\\n\\t\\t// marking Unguarded Cell Upward as Guarded until a Guarded or Walled Cell is found.\\n        for (int i=r-1; i>=0; i--) {\\n            if (prison[i][c] == \\'w\\' or prison[i][c] == \\'g\\')    break;\\n            prison[i][c] = \\'d\\';\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        int res = 0;\\n        vector<vector<char>> prison(m, vector<char>(n, \\'u\\'));\\n        \\n        for (auto& g : guards)  prison[g[0]][g[1]] = \\'g\\';\\n        for (auto& w : walls)    prison[w[0]][w[1]] = \\'w\\';\\n        \\n\\t\\tfor (auto& g : guards)\\n             markThem(prison, g[0], g[1], m, n);\\n        \\n        for (auto& row : prison)\\n            for (auto& cell : row)\\n                if (cell == \\'u\\') res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ng -> cell with a guard\\nw -> cell with a wall\\nd -> guarded cells\\nu -> unguarded cells\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void markThem(vector<vector<char>>& prison, int r, int c, int m, int n) {\\n\\n\\t\\t// marking Unguarded Cell in the Right as Guarded until a Guarded or Walled Cell is found.\\n        for (int j=c+1; j<n; j++) {\\n\\t\\t\\t// breaking if wall is found as guard cannot see past that wall.\\n\\t\\t\\t// breaking if cell has a guard as that guard will mark the rest of cells.\\n            if (prison[r][j] == \\'w\\' or prison[r][j] == \\'g\\')    break;\\n            prison[r][j] = \\'d\\'; // marking unguarded cell as guarded.\\n        }\\n\\t\\t\\n\\t\\t// marking Unguarded Cell in the Left as Guarded until a Guarded or Walled Cell is found.\\n        for (int j=c-1; j>=0; j--) {\\n            if (prison[r][j] == \\'w\\' or prison[r][j] == \\'g\\')    break;\\n            prison[r][j] = \\'d\\';\\n        }\\n        \\n\\t\\t// marking Unguarded Cell in the Downward as Guarded until a Guarded or Walled Cell is found.\\n        for (int i=r+1; i<m; i++) {\\n            if (prison[i][c] == \\'w\\' or prison[i][c] == \\'g\\')    break;\\n            prison[i][c] = \\'d\\';\\n        }\\n\\t\\t\\n\\t\\t// marking Unguarded Cell Upward as Guarded until a Guarded or Walled Cell is found.\\n        for (int i=r-1; i>=0; i--) {\\n            if (prison[i][c] == \\'w\\' or prison[i][c] == \\'g\\')    break;\\n            prison[i][c] = \\'d\\';\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        int res = 0;\\n        vector<vector<char>> prison(m, vector<char>(n, \\'u\\'));\\n        \\n        for (auto& g : guards)  prison[g[0]][g[1]] = \\'g\\';\\n        for (auto& w : walls)    prison[w[0]][w[1]] = \\'w\\';\\n        \\n\\t\\tfor (auto& g : guards)\\n             markThem(prison, g[0], g[1], m, n);\\n        \\n        for (auto& row : prison)\\n            for (auto& cell : row)\\n                if (cell == \\'u\\') res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994568,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs( vector<vector<int>> &grid,int x,int y,int m,int n,int dir){\\n        if(x<0 || y<0 || x>=m || y>=n) return;\\n        if(grid[x][y]==2 || grid[x][y]==1) return;\\n        grid[x][y]=3;\\n        if(dir==1){\\n            dfs(grid,x+1,y,m,n,dir);\\n        }\\n        else if(dir==2){\\n            dfs(grid,x,y+1,m,n,dir);\\n        }\\n        else if(dir==3){\\n            dfs(grid,x-1,y,m,n,dir);\\n        }\\n        else{\\n            dfs(grid,x,y-1,m,n,dir);\\n        }\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n         vector<vector<int>> grid(m,vector<int>(n,0));\\n        //marking guards\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            grid[x][y]=1;\\n        }\\n        // marking walls\\n         for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0];\\n            int y=walls[i][1];\\n            grid[x][y]=2;\\n        }\\n        // dfs in each of 4 directions\\n          for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n              dfs(grid,x+1,y,m,n,1);\\n              dfs(grid,x,y+1,m,n,2);\\n              dfs(grid,x-1,y,m,n,3);\\n              dfs(grid,x,y-1,m,n,4);\\n          }\\n        long long int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs( vector<vector<int>> &grid,int x,int y,int m,int n,int dir){\\n        if(x<0 || y<0 || x>=m || y>=n) return;\\n        if(grid[x][y]==2 || grid[x][y]==1) return;\\n        grid[x][y]=3;\\n        if(dir==1){\\n            dfs(grid,x+1,y,m,n,dir);\\n        }\\n        else if(dir==2){\\n            dfs(grid,x,y+1,m,n,dir);\\n        }\\n        else if(dir==3){\\n            dfs(grid,x-1,y,m,n,dir);\\n        }\\n        else{\\n            dfs(grid,x,y-1,m,n,dir);\\n        }\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n         vector<vector<int>> grid(m,vector<int>(n,0));\\n        //marking guards\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            grid[x][y]=1;\\n        }\\n        // marking walls\\n         for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0];\\n            int y=walls[i][1];\\n            grid[x][y]=2;\\n        }\\n        // dfs in each of 4 directions\\n          for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n              dfs(grid,x+1,y,m,n,1);\\n              dfs(grid,x,y+1,m,n,2);\\n              dfs(grid,x-1,y,m,n,3);\\n              dfs(grid,x,y-1,m,n,4);\\n          }\\n        long long int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994620,
                "title": "c-quick-code-easy-to-understand-dfs-o-m-n",
                "content": "### DFS Solution ~ O(M*N)\\n- This is a basic DFS question, but with few extra condition checks.\\n- Initially we mark the existence of \\n\\t- **`walls`** as **`2`** \\n\\t- **`guards`** as **`3`**\\n\\t- **`vison of guards`** as **`1`**.\\n- Here we don\\'t require `visited` array, since we can do it using the `walls` and other `guards` in adjacent cell. \\n- Keep track of the changes using the `occupied` count and our answer would be the remaining  count.\\n\\n![image](https://assets.leetcode.com/users/images/f9ea4a0a-c03b-4c39-b305-30e97d8aa513_1651334847.8484206.png)\\n\\n```cpp\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    int dir[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n\\tvector<vector<int>> grid(m, vector<int>(n, 0));\\n    int occupied = walls.size() + guards.size();\\n\\t\\n    for(auto& w: walls)\\n        grid[w[0]][w[1]] = 2;\\n\\n    for(auto& g: guards)\\n        grid[g[0]][g[1]] = 3;\\n\\n\\t// DFS from each guards position\\n    for(auto& g: guards){\\n        int x = g[0], y = g[1];\\n\\n        for(int k=0; k<4; k++){\\n            int dx = x, dy = y;\\n            while(true){\\n                dx += dir[k][0];   \\n                dy += dir[k][1];\\n\\n\\t\\t\\t\\t// break if you see a wall, or if another guard is standing infront of you. (\"not vision\")\\n                if(min(dx, dy) < 0 || dx == m || dy == n || grid[dx][dy] == 2 || grid[dx][dy] == 3)\\n                    break;\\n\\n\\t\\t\\t\\t// if two guards can vision the same cell (1,0) or (1, 3) in example, dont occupy++\\n                if(grid[dx][dy] != 1){\\n                    grid[dx][dy] = 1;\\n                    occupied++;\\n                }\\n            }\\n        }\\n    }\\n    return m*n - occupied;\\n}\\n```\\n\\n**Upvote and let\\'s make all others read :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n    int dir[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n\\tvector<vector<int>> grid(m, vector<int>(n, 0));\\n    int occupied = walls.size() + guards.size();\\n\\t\\n    for(auto& w: walls)\\n        grid[w[0]][w[1]] = 2;\\n\\n    for(auto& g: guards)\\n        grid[g[0]][g[1]] = 3;\\n\\n\\t// DFS from each guards position\\n    for(auto& g: guards){\\n        int x = g[0], y = g[1];\\n\\n        for(int k=0; k<4; k++){\\n            int dx = x, dy = y;\\n            while(true){\\n                dx += dir[k][0];   \\n                dy += dir[k][1];\\n\\n\\t\\t\\t\\t// break if you see a wall, or if another guard is standing infront of you. (\"not vision\")\\n                if(min(dx, dy) < 0 || dx == m || dy == n || grid[dx][dy] == 2 || grid[dx][dy] == 3)\\n                    break;\\n\\n\\t\\t\\t\\t// if two guards can vision the same cell (1,0) or (1, 3) in example, dont occupy++\\n                if(grid[dx][dy] != 1){\\n                    grid[dx][dy] = 1;\\n                    occupied++;\\n                }\\n            }\\n        }\\n    }\\n    return m*n - occupied;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994570,
                "title": "c-easy-o-m-n-with-inline-explanation",
                "content": "```\\n //function to check Wall and Guard \\n    bool check(int i,int j,vector<vector<int>> &vec){\\n        if(vec[i][j]==0 || vec[i][j]==1) return false;\\n        return true;\\n    }\\n    \\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        //Wall=0, Guard=1, Red=2, Green=3 \\n        vector<vector<int>> vec (m,vector<int>(n,3)); //grid with all green visit\\n        \\n        //fill the wall and Guard in grid \\n        for(int i=0;i<g.size();i++) vec[g[i][0]][g[i][1]]=1;\\n        for(int i=0;i<w.size();i++) vec[w[i][0]][w[i][1]]=0;\\n        \\n        //visit all cell\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vec[i][j]==1){       //consider each Guard\\n                    for(int up=i-1;up>=0;up--){  // check vertically up column\\n                        if(!check(up,j,vec))break;\\n                        vec[up][j]=2;\\n                    }\\n                    for(int down=i+1;down<m;down++){ // check vertically down column\\n                        if(!check(down,j,vec))break;\\n                        vec[down][j]=2;\\n                    }\\n                    for(int left=j-1;left>=0;left--){  // check horizontally left row\\n                        if(!check(i,left,vec))break;\\n                        vec[i][left]=2;\\n                    }\\n                    for(int rt=j+1;rt<n;rt++){   // check horizontally right row\\n                        if(!check(i,rt,vec))break;\\n                        vec[i][rt]=2;\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vec[i][j]==3) cnt++;  // Count Green region\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n //function to check Wall and Guard \\n    bool check(int i,int j,vector<vector<int>> &vec){\\n        if(vec[i][j]==0 || vec[i][j]==1) return false;\\n        return true;\\n    }\\n    \\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        //Wall=0, Guard=1, Red=2, Green=3 \\n        vector<vector<int>> vec (m,vector<int>(n,3)); //grid with all green visit\\n        \\n        //fill the wall and Guard in grid \\n        for(int i=0;i<g.size();i++) vec[g[i][0]][g[i][1]]=1;\\n        for(int i=0;i<w.size();i++) vec[w[i][0]][w[i][1]]=0;\\n        \\n        //visit all cell\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vec[i][j]==1){       //consider each Guard\\n                    for(int up=i-1;up>=0;up--){  // check vertically up column\\n                        if(!check(up,j,vec))break;\\n                        vec[up][j]=2;\\n                    }\\n                    for(int down=i+1;down<m;down++){ // check vertically down column\\n                        if(!check(down,j,vec))break;\\n                        vec[down][j]=2;\\n                    }\\n                    for(int left=j-1;left>=0;left--){  // check horizontally left row\\n                        if(!check(i,left,vec))break;\\n                        vec[i][left]=2;\\n                    }\\n                    for(int rt=j+1;rt<n;rt++){   // check horizontally right row\\n                        if(!check(i,rt,vec))break;\\n                        vec[i][rt]=2;\\n                    }\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(vec[i][j]==3) cnt++;  // Count Green region\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995164,
                "title": "easy-to-understand-c-solution",
                "content": "i have included my code with comments that are easy to understand......feel free to comment your queries......thanks\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& walls) {\\n        set<pair<int,int>> settu;//stores walls\\n        set<pair<int,int>> gua;//stores guards\\n        \\n        for(int i=0;i<walls.size();i++){\\n            settu.insert({walls[i][0],walls[i][1]});\\n        }\\n        \\n        for(int i=0;i<g.size();i++){\\n            gua.insert({g[i][0],g[i][1]});\\n        }\\n        \\n        set<pair<int,int>> unq;//stores cells that are guarded.\\n        \\n        for(auto it : g){\\n            int i = it[0]-1;\\n            int j = it[1];\\n            //below while loop is to move from i-1 to 0. that is moving up from the guard\\n            while(i>=0){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    i--;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            i = it[0]+1;\\n            //below while loop is to move from i+1 to m. that is moving down from the guard\\n            while(i<m){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    i++;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            j = it[1]-1;\\n            i = it[0];\\n            //below while loop is to move from j-1 to 0. that is moving left from the guard\\n            while(j>=0){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    j--;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            j = it[1]+1;\\n            //below while loop is to move from j+1 to n. that is moving right from the guard\\n            while(j<n){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    j++;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            \\n        }\\n        \\n        return m*n-settu.size()-gua.size()-unq.size();//finally return the remaining cells which are not guarded, guards, walls;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& walls) {\\n        set<pair<int,int>> settu;//stores walls\\n        set<pair<int,int>> gua;//stores guards\\n        \\n        for(int i=0;i<walls.size();i++){\\n            settu.insert({walls[i][0],walls[i][1]});\\n        }\\n        \\n        for(int i=0;i<g.size();i++){\\n            gua.insert({g[i][0],g[i][1]});\\n        }\\n        \\n        set<pair<int,int>> unq;//stores cells that are guarded.\\n        \\n        for(auto it : g){\\n            int i = it[0]-1;\\n            int j = it[1];\\n            //below while loop is to move from i-1 to 0. that is moving up from the guard\\n            while(i>=0){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    i--;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            i = it[0]+1;\\n            //below while loop is to move from i+1 to m. that is moving down from the guard\\n            while(i<m){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    i++;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            j = it[1]-1;\\n            i = it[0];\\n            //below while loop is to move from j-1 to 0. that is moving left from the guard\\n            while(j>=0){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    j--;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            j = it[1]+1;\\n            //below while loop is to move from j+1 to n. that is moving right from the guard\\n            while(j<n){\\n                if(gua.find({i,j})!=gua.end()){\\n                    break;//breaking if we found a guard.\\n                }\\n                if(settu.find({i,j})==settu.end()){\\n                    unq.insert({i,j});//include current cell if it is not a wall\\n                    j++;\\n                }else{\\n                    break;//break if it is a wall\\n                }\\n            }\\n            \\n        }\\n        \\n        return m*n-settu.size()-gua.size()-unq.size();//finally return the remaining cells which are not guarded, guards, walls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994551,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m,vector<int>(n,-1));\\n        int l=guards.size();\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n            grid[guards[i][0]][guards[i][1]]=0;\\n        }\\n        \\n        int l2=walls.size();\\n        for(int i=0;i<l2;i++)\\n        {\\n            grid[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n           int x,y;\\n            x=guards[i][0];\\n            y=guards[i][1];\\n            int p;\\n            p=x+1;\\n            \\n            while(p<m)\\n            {\\n\\n                if(grid[p][y]==2||grid[p][y]==0)\\n                {\\n                    break;\\n                }                \\n                grid[p][y]=1;\\n                p++;\\n            }\\n            \\n            p=x-1;\\n            while(p>=0)\\n            {\\n                  if(grid[p][y]==2||grid[p][y]==0)\\n                {\\n                    break;\\n                }                \\n                grid[p][y]=1;\\n                p--;\\n            }\\n             p=y-1;\\n            while(p>=0)\\n            {\\n                  if(grid[x][p]==2||grid[x][p]==0)\\n                {\\n                    break;\\n                }                \\n                grid[x][p]=1;\\n                p--;\\n            }\\n             p=y+1;\\n            while(p<n)\\n            {\\n                  if(grid[x][p]==2||grid[x][p]==0)\\n                {\\n                    break;\\n                }                \\n                grid[x][p]=1;\\n                p++;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==-1)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m,vector<int>(n,-1));\\n        int l=guards.size();\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n            grid[guards[i][0]][guards[i][1]]=0;\\n        }\\n        \\n        int l2=walls.size();\\n        for(int i=0;i<l2;i++)\\n        {\\n            grid[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n        for(int i=0;i<l;i++)\\n        {\\n           int x,y;\\n            x=guards[i][0];\\n            y=guards[i][1];\\n            int p;\\n            p=x+1;\\n            \\n            while(p<m)\\n            {\\n\\n                if(grid[p][y]==2||grid[p][y]==0)\\n                {\\n                    break;\\n                }                \\n                grid[p][y]=1;\\n                p++;\\n            }\\n            \\n            p=x-1;\\n            while(p>=0)\\n            {\\n                  if(grid[p][y]==2||grid[p][y]==0)\\n                {\\n                    break;\\n                }                \\n                grid[p][y]=1;\\n                p--;\\n            }\\n             p=y-1;\\n            while(p>=0)\\n            {\\n                  if(grid[x][p]==2||grid[x][p]==0)\\n                {\\n                    break;\\n                }                \\n                grid[x][p]=1;\\n                p--;\\n            }\\n             p=y+1;\\n            while(p<n)\\n            {\\n                  if(grid[x][p]==2||grid[x][p]==0)\\n                {\\n                    break;\\n                }                \\n                grid[x][p]=1;\\n                p++;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==-1)\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995423,
                "title": "java-easy-clear-solution-step-by-step",
                "content": "# | JAVA | Step by step Solution -->\\n1. We wil create a matrix call `res` with dimensions (`m`,`n`). When created, the matrix will contain only zeros.\\n    Zeros represent unguarded cells.\\n\\n2. We add the walls to the correct positions in `res`, the same case for the guards. \\n    Walls will be represented in `res` with the number 2 and guards using the number 1.\\n\\t\\n3. We start parsing the matrix, if we find a 1 (guard), we try to change the respective cells \\n    affected in `res` with the number 3 until we face a wall or another guard.\\n\\t\\n4. Once all the guards have guarded their respective cells, we parse the matrix again, if we find\\n    a zero (unguarded cell) we add one to the counter (`result`).\\n\\n5. We return `result` :). Hope you have understand it!! \\n\\nLeave a like and a comment if you have any question.\\n\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] res = new int[m][n];   //We create the matrix with the proper dimension\\n        int result = 0, cnti, cntj;\\n        for(int[] i : walls){       //We insert all the walls\\n            res[i[0]][i[1]] = 2;\\n        }\\n        for(int[] i : guards){      //We insert all the guards\\n            res[i[0]][i[1]] = 1;  \\n        }\\n        for(int i = 0; i < res.length;i++){\\n            for(int j = 0; j < res[i].length;j++){\\n                if(res[i][j] == 1){     //If we found a guard...\\n                    cnti = i;   //Position of the guard\\n                    cntj = j;   //Position of the guard\\n                    while(cnti-1 != -1 && res[cnti-1][cntj] != 2 && res[cnti-1][cntj] != 1){  //If we can go up in the matrix...\\n                        res[cnti-1][cntj] = 3;\\n                        cnti--;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cnti+1 != m && res[cnti+1][cntj] != 2 && res[cnti+1][cntj] != 1){   //If we can go down in the matrix...\\n                        res[cnti+1][cntj] = 3;\\n                        cnti++;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cntj-1 != -1 && res[cnti][cntj-1] != 2 && res[cnti][cntj-1] != 1){  //If we can go to left in the matrix...\\n                        res[cnti][cntj-1] = 3;\\n                        cntj--;\\n                    }\\n                    cntj = j;  //We reset the value to the initial one\\n                    while(cntj+1 != n && res[cnti][cntj+1] != 2 && res[cnti][cntj+1] != 1){  //If we can go to rigth in the matrix...\\n                        res[cnti][cntj+1] = 3;\\n                        cntj++;\\n                    }\\n                }\\n            }\\n        }\\n        for(int[] i : res){   //Once we have marked the correct squares in the matrix...\\n            for(int j : i){\\n                if(j == 0){   //If we find a \\'0\\', we add one to the counter as it is an unguarded cell\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;  //We return the number of unguarded cells\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] res = new int[m][n];   //We create the matrix with the proper dimension\\n        int result = 0, cnti, cntj;\\n        for(int[] i : walls){       //We insert all the walls\\n            res[i[0]][i[1]] = 2;\\n        }\\n        for(int[] i : guards){      //We insert all the guards\\n            res[i[0]][i[1]] = 1;  \\n        }\\n        for(int i = 0; i < res.length;i++){\\n            for(int j = 0; j < res[i].length;j++){\\n                if(res[i][j] == 1){     //If we found a guard...\\n                    cnti = i;   //Position of the guard\\n                    cntj = j;   //Position of the guard\\n                    while(cnti-1 != -1 && res[cnti-1][cntj] != 2 && res[cnti-1][cntj] != 1){  //If we can go up in the matrix...\\n                        res[cnti-1][cntj] = 3;\\n                        cnti--;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cnti+1 != m && res[cnti+1][cntj] != 2 && res[cnti+1][cntj] != 1){   //If we can go down in the matrix...\\n                        res[cnti+1][cntj] = 3;\\n                        cnti++;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cntj-1 != -1 && res[cnti][cntj-1] != 2 && res[cnti][cntj-1] != 1){  //If we can go to left in the matrix...\\n                        res[cnti][cntj-1] = 3;\\n                        cntj--;\\n                    }\\n                    cntj = j;  //We reset the value to the initial one\\n                    while(cntj+1 != n && res[cnti][cntj+1] != 2 && res[cnti][cntj+1] != 1){  //If we can go to rigth in the matrix...\\n                        res[cnti][cntj+1] = 3;\\n                        cntj++;\\n                    }\\n                }\\n            }\\n        }\\n        for(int[] i : res){   //Once we have marked the correct squares in the matrix...\\n            for(int j : i){\\n                if(j == 0){   //If we find a \\'0\\', we add one to the counter as it is an unguarded cell\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;  //We return the number of unguarded cells\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995003,
                "title": "easy-bfs-approach-with-c-code-with-explanation",
                "content": "# Logic: - \\n**Step 1** : Construct 2D matrix ,iterate through guards and wall vectors and fill them in our 2D matrix\\nFew conventions i used for identifying each of them\\nEmpty Space -> 0\\nGuard -> -1\\nWall -> 1\\n**Step 2**: Fill index of all guards in queue (we will pick each one of them and make them travel in all 4 directions)\\n**Step 3**: Pick one index and from that index travel in all 4 directions and mark the cell as 2(personal convention to identify places already visited by a Guard). keep on picking till we make queue empty\\n**Step4**: In the end count all cell still having value as 0\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n       swap(n,m);  // did this so that n can denote rows and m can denote coloumns\\n\\t   // Step 1\\n       vector<vector<int>> mat(n,vector<int>(m));\\n      // filling matrix with 0 for all places\\n       for(int i=0;i<n;i++)\\n       {\\n         for(int j=0;j<m;j++)\\n         {\\n           mat[i][j]=0;\\n         }\\n       }\\n      \\n       queue<pair<int,int>>q;\\n      \\n\\t  // Step 2\\n      // marking -1 at all pos where guard is present and pushing that index to queue\\n       for(int i=0;i<guards.size();i++)\\n       {\\n         int x=guards[i][0];\\n         int y=guards[i][1];\\n         mat[x][y]=-1;\\n         q.push({x,y});\\n       }\\n      \\n      // marking 1 at all places where there\\'s a wall\\n       for(int i=0;i<walls.size();i++)\\n       {\\n         int x=walls[i][0];\\n         int y=walls[i][1];\\n         mat[x][y]=1;\\n       }\\n      \\n       \\n        // made for travelling top,down,left,right\\n        vector<int>dx={-1,+1,0,0};\\n        vector<int>dy={0,0,-1,+1};\\n      \\n\\t   // Step 3\\n\\t   \\n         while(q.size())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            for(int i=0;i<4;i++)\\n            {\\n\\t\\t\\t   // nx is new value of x ,ny is new value of y \\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                // keep on moving in that direction uptill we encounter wall or guard , we have marked\\n                // 2 as place thats already visited by other guard\\n                while(nx>=0 and nx<n and ny>=0 and ny<m and (mat[nx][ny]==0 or mat[nx][ny]==2))\\n                {\\n                    mat[nx][ny]=2;\\n                    nx+=dx[i];\\n                    ny+=dy[i];\\n                }\\n                     \\n             }\\n        }\\n         // Step 4  \\n        // in the end just count the places which are still 0 (empty)\\n          int cnt=0;\\n          for(int i=0;i<n;i++)\\n          {\\n            for(int j=0;j<m;j++)\\n            {\\n              if(mat[i][j]==0)\\n              {\\n                cnt++;\\n              }\\n            }\\n          }\\n                      \\n           return cnt;           \\n      \\n       \\n      \\n      \\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n       swap(n,m);  // did this so that n can denote rows and m can denote coloumns\\n\\t   // Step 1\\n       vector<vector<int>> mat(n,vector<int>(m));\\n      // filling matrix with 0 for all places\\n       for(int i=0;i<n;i++)\\n       {\\n         for(int j=0;j<m;j++)\\n         {\\n           mat[i][j]=0;\\n         }\\n       }\\n      \\n       queue<pair<int,int>>q;\\n      \\n\\t  // Step 2\\n      // marking -1 at all pos where guard is present and pushing that index to queue\\n       for(int i=0;i<guards.size();i++)\\n       {\\n         int x=guards[i][0];\\n         int y=guards[i][1];\\n         mat[x][y]=-1;\\n         q.push({x,y});\\n       }\\n      \\n      // marking 1 at all places where there\\'s a wall\\n       for(int i=0;i<walls.size();i++)\\n       {\\n         int x=walls[i][0];\\n         int y=walls[i][1];\\n         mat[x][y]=1;\\n       }\\n      \\n       \\n        // made for travelling top,down,left,right\\n        vector<int>dx={-1,+1,0,0};\\n        vector<int>dy={0,0,-1,+1};\\n      \\n\\t   // Step 3\\n\\t   \\n         while(q.size())\\n        {\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            for(int i=0;i<4;i++)\\n            {\\n\\t\\t\\t   // nx is new value of x ,ny is new value of y \\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                // keep on moving in that direction uptill we encounter wall or guard , we have marked\\n                // 2 as place thats already visited by other guard\\n                while(nx>=0 and nx<n and ny>=0 and ny<m and (mat[nx][ny]==0 or mat[nx][ny]==2))\\n                {\\n                    mat[nx][ny]=2;\\n                    nx+=dx[i];\\n                    ny+=dy[i];\\n                }\\n                     \\n             }\\n        }\\n         // Step 4  \\n        // in the end just count the places which are still 0 (empty)\\n          int cnt=0;\\n          for(int i=0;i<n;i++)\\n          {\\n            for(int j=0;j<m;j++)\\n            {\\n              if(mat[i][j]==0)\\n              {\\n                cnt++;\\n              }\\n            }\\n          }\\n                      \\n           return cnt;           \\n      \\n       \\n      \\n      \\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037652,
                "title": "c-o-mn-beats-96-18-simple-dfs-with-explanation-and-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> g(m,vector<char>(n,\\'0\\'));\\n        \\n        //fill the position of guards.\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0],y=guards[i][1];\\n            g[x][y]=\\'g\\';\\n        }\\n        \\n        //fill the position of walls\\n        for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0],y=walls[i][1];\\n            g[x][y]=\\'w\\';\\n        }\\n        \\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0],y=guards[i][1];\\n            \\n            //check for guards or walls in upper direction.\\n            for(int j=x-1;j>=0;j--){\\n                if(g[j][y]==\\'g\\' or g[j][y]==\\'w\\'){\\n                    break;\\n                }\\n                g[j][y] = \\'1\\'; //fill the cell as guarded\\n            }\\n            \\n            //check for guards or walls in right direction.\\n            for(int j=y+1;j<n;j++){\\n                if(g[x][j]==\\'g\\' or g[x][j]==\\'w\\'){\\n                    break;\\n                }\\n                g[x][j] = \\'1\\';\\n            }\\n            \\n            //check for guards or walls in downward direction.\\n            for(int j=x+1;j<m;j++){\\n                if(g[j][y]==\\'g\\' or g[j][y]==\\'w\\'){\\n                    break;\\n                }\\n                g[j][y] = \\'1\\';\\n            }\\n            \\n            //check for guards or walls in left direction.\\n            for(int j=y-1;j>=0;j--){\\n                if(g[x][j]==\\'g\\' or g[x][j]==\\'w\\'){\\n                    break;\\n                }\\n                g[x][j] = \\'1\\';\\n            }\\n        }\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if g[i][j] is \\'0\\' it means the cell is not guarded.\\n                if(g[i][j]==\\'0\\'){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> g(m,vector<char>(n,\\'0\\'));\\n        \\n        //fill the position of guards.\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0],y=guards[i][1];\\n            g[x][y]=\\'g\\';\\n        }\\n        \\n        //fill the position of walls\\n        for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0],y=walls[i][1];\\n            g[x][y]=\\'w\\';\\n        }\\n        \\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0],y=guards[i][1];\\n            \\n            //check for guards or walls in upper direction.\\n            for(int j=x-1;j>=0;j--){\\n                if(g[j][y]==\\'g\\' or g[j][y]==\\'w\\'){\\n                    break;\\n                }\\n                g[j][y] = \\'1\\'; //fill the cell as guarded\\n            }\\n            \\n            //check for guards or walls in right direction.\\n            for(int j=y+1;j<n;j++){\\n                if(g[x][j]==\\'g\\' or g[x][j]==\\'w\\'){\\n                    break;\\n                }\\n                g[x][j] = \\'1\\';\\n            }\\n            \\n            //check for guards or walls in downward direction.\\n            for(int j=x+1;j<m;j++){\\n                if(g[j][y]==\\'g\\' or g[j][y]==\\'w\\'){\\n                    break;\\n                }\\n                g[j][y] = \\'1\\';\\n            }\\n            \\n            //check for guards or walls in left direction.\\n            for(int j=y-1;j>=0;j--){\\n                if(g[x][j]==\\'g\\' or g[x][j]==\\'w\\'){\\n                    break;\\n                }\\n                g[x][j] = \\'1\\';\\n            }\\n        }\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //if g[i][j] is \\'0\\' it means the cell is not guarded.\\n                if(g[i][j]==\\'0\\'){\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997416,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] g, int[][] w) {\\n        int a[][]=new int[m][n];\\n        for(int i=0;i<g.length;i++)\\n        {\\n            a[g[i][0]][g[i][1]]=1;\\n        }\\n        for(int i=0;i<w.length;i++)\\n        {\\n            a[w[i][0]][w[i][1]]=2;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==1)\\n                {\\n                    for(int k=j-1;k>=0;k--)\\n                    {\\n                        if(a[i][k]==2||a[i][k]==1)\\n                            break;\\n                        else\\n                            a[i][k]=3;\\n                    }\\n                    for(int k=j+1;k<n;k++)\\n                    {\\n                        if(a[i][k]==2||a[i][k]==1)\\n                            break;\\n                        else\\n                            a[i][k]=3;\\n                    }\\n                    for(int k=i-1;k>=0;k--)\\n                    {\\n                        if(a[k][j]==2||a[k][j]==1)\\n                            break;\\n                        else\\n                            a[k][j]=3;\\n                    }\\n                    for(int k=i+1;k<m;k++)\\n                    {\\n                        if(a[k][j]==2||a[k][j]==1)\\n                            break;\\n                        else\\n                            a[k][j]=3;\\n                    }\\n                }\\n            }\\n        }\\n        int c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==0)\\n                    c++;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countUnguarded(int m, int n, int[][] g, int[][] w) {\\n        int a[][]=new int[m][n];\\n        for(int i=0;i<g.length;i++)\\n        {\\n            a[g[i][0]][g[i][1]]=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1995512,
                "title": "easy-to-understand-cpp-code-with-explanation",
                "content": "```\\nSolving by brute force,\\n\\nWe first create a grid of the given rows & columns and initiliaze every cell to 0. We indicate the walls as 2  and guards as 1.\\nWe iterate over the entire guards, for every guard we traverse in the 4 directions (left,right,up,down) until we find a wall or a guard.\\nUntil we find a wall or guard, we mark the cell as -1 to indicate it can be guarded by the guard.\\n\\nSo finally we just count the elements which are 0, so these are the cells which are not guarded.\\n\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> v(m, vector<int>(n, 0));\\n        for(auto arr : guards){\\n            int r = arr[0];\\n            int c = arr[1];\\n            v[r][c] = 1;\\n        }\\n        for(auto arr : walls){\\n            int r = arr[0];\\n            int c = arr[1];\\n            v[r][c] = 2;\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(v[i][j] == 1){\\n                    int k = i + 1;\\n                    while((k < m && v[k][j] != 1 && v[k][j] != 2)){//down\\n                        v[k][j] = -1;\\n                        k++;\\n                    }\\n                    k = i - 1;\\n                    while((k >= 0 && v[k][j] != 1 && v[k][j] != 2)){//up\\n                        v[k][j] = -1;\\n                        k--;\\n                    }\\n                    k = j - 1;\\n                    while((k >= 0 && v[i][k] != 1 && v[i][k] != 2)){//left\\n                        v[i][k] = -1;\\n                        k--;\\n                    }\\n                    k = j + 1;\\n                    while((k < n && v[i][k] != 1  && v[i][k] != 2)){//right\\n                        v[i][k] = -1;\\n                        k++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(v[i][j] == 0) cnt++;\\n                // cout << v[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\nplease upvote if it helps!!\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nSolving by brute force,\\n\\nWe first create a grid of the given rows & columns and initiliaze every cell to 0. We indicate the walls as 2  and guards as 1.\\nWe iterate over the entire guards, for every guard we traverse in the 4 directions (left,right,up,down) until we find a wall or a guard.\\nUntil we find a wall or guard, we mark the cell as -1 to indicate it can be guarded by the guard.\\n\\nSo finally we just count the elements which are 0, so these are the cells which are not guarded.\\n\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> v(m, vector<int>(n, 0));\\n        for(auto arr : guards){\\n            int r = arr[0];\\n            int c = arr[1];\\n            v[r][c] = 1;\\n        }\\n        for(auto arr : walls){\\n            int r = arr[0];\\n            int c = arr[1];\\n            v[r][c] = 2;\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(v[i][j] == 1){\\n                    int k = i + 1;\\n                    while((k < m && v[k][j] != 1 && v[k][j] != 2)){//down\\n                        v[k][j] = -1;\\n                        k++;\\n                    }\\n                    k = i - 1;\\n                    while((k >= 0 && v[k][j] != 1 && v[k][j] != 2)){//up\\n                        v[k][j] = -1;\\n                        k--;\\n                    }\\n                    k = j - 1;\\n                    while((k >= 0 && v[i][k] != 1 && v[i][k] != 2)){//left\\n                        v[i][k] = -1;\\n                        k--;\\n                    }\\n                    k = j + 1;\\n                    while((k < n && v[i][k] != 1  && v[i][k] != 2)){//right\\n                        v[i][k] = -1;\\n                        k++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(v[i][j] == 0) cnt++;\\n                // cout << v[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\nplease upvote if it helps!!\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994734,
                "title": "straighforward-one-direction-dfs-solution-python",
                "content": "Idea is to mark all locations which the guard can see with some arbitrary value. Then later just count the non marked cells.\\n\\nSimply initiate **4** DFS on each of the guard. Each for top, right, bottom, left. And mark that 1-Direction Path.\\n\\n```\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\t# step1: Build matrix\\n    mat = [[0] * n for i in range(m)]\\n\\n    for i, j in guards:\\n        mat[i][j] = \"G\"\\n\\n    for i, j in walls:\\n        mat[i][j] = \"W\"\\n\\n\\t# TOP, RIGHT, BOTTOM, LEFT\\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\\n\\n    def isValid(i, j):\\n        if i < 0 or j < 0 or i >= m or j >= n:\\n            return False\\n        return True\\n\\n    def dfs(i, j, direction):\\n        if not isValid(i, j):\\n            return\\n\\n        if mat[i][j] == \"W\" or mat[i][j] == \"G\" :\\n            return\\n\\n        mat[i][j] = \"X\"\\n\\n        x, y = direction\\n        new_i = i + x\\n        new_j = j + y\\n        if isValid(new_i, new_j):\\n            dfs(new_i, new_j, direction)\\n\\n\\t# do dfs on each direction, and keep going in that direction\\n    for i in range(m):\\n        for j in range(n):\\n            if mat[i][j] == \"G\":\\n                dfs(i - 1, j, directions[0]) # always go up\\n                dfs(i, j + 1, directions[1]) # always go right\\n                dfs(i + 1, j, directions[2]) # always go down\\n                dfs(i, j - 1, directions[3]) # always go left\\n\\n\\t# count unmarked cells as safe\\n    c = 0\\n    for i in range(m):\\n        for j in range(n):\\n            if mat[i][j] == 0:\\n                c += 1\\n\\n    return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\t# step1: Build matrix\\n    mat = [[0] * n for i in range(m)]\\n\\n    for i, j in guards:\\n        mat[i][j] = \"G\"\\n\\n    for i, j in walls:\\n        mat[i][j] = \"W\"\\n\\n\\t# TOP, RIGHT, BOTTOM, LEFT\\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\\n\\n    def isValid(i, j):\\n        if i < 0 or j < 0 or i >= m or j >= n:\\n            return False\\n        return True\\n\\n    def dfs(i, j, direction):\\n        if not isValid(i, j):\\n            return\\n\\n        if mat[i][j] == \"W\" or mat[i][j] == \"G\" :\\n            return\\n\\n        mat[i][j] = \"X\"\\n\\n        x, y = direction\\n        new_i = i + x\\n        new_j = j + y\\n        if isValid(new_i, new_j):\\n            dfs(new_i, new_j, direction)\\n\\n\\t# do dfs on each direction, and keep going in that direction\\n    for i in range(m):\\n        for j in range(n):\\n            if mat[i][j] == \"G\":\\n                dfs(i - 1, j, directions[0]) # always go up\\n                dfs(i, j + 1, directions[1]) # always go right\\n                dfs(i + 1, j, directions[2]) # always go down\\n                dfs(i, j - 1, directions[3]) # always go left\\n\\n\\t# count unmarked cells as safe\\n    c = 0\\n    for i in range(m):\\n        for j in range(n):\\n            if mat[i][j] == 0:\\n                c += 1\\n\\n    return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2111213,
                "title": "easy-to-understand-c-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int m, int n, vector <vector <int>>& grid, int& count, int r, int c) {\\n        for (int i = r+1; i < m; i++) {\\n            if (grid[i][c] == 1 || grid[i][c] == 2) break;\\n            if (grid[i][c] == 0) {\\n                count++;\\n                grid[i][c] = 3;\\n            }\\n        }\\n        for (int i = r-1; i >= 0; i--) {\\n            if (grid[i][c] == 1 || grid[i][c] == 2) break;\\n            if (grid[i][c] == 0) {\\n                count++;\\n                grid[i][c] = 3;\\n            }\\n        }\\n        for (int i = c+1; i < n; i++) {\\n            if (grid[r][i] == 1 || grid[r][i] == 2) break;\\n            if (grid[r][i] == 0) {\\n                count++;\\n                grid[r][i] = 3;\\n            }\\n        }\\n        for (int i = c-1; i >= 0; i--) {\\n            if (grid[r][i] == 1 || grid[r][i] == 2) break;\\n            if (grid[r][i] == 0) {\\n                count++;\\n                grid[r][i] = 3;\\n            }\\n        }\\n        \\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector <vector <int>> grid(m, vector <int>(n, 0));\\n        // 0: free cell\\n        // 1: guard\\n        // 2: wall\\n        // 3: visited\\n        for (auto g : guards) {\\n            grid[g[0]][g[1]] = 1;\\n        }\\n        for (auto w : walls) {\\n            grid[w[0]][w[1]] = 2;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    helper(m, n, grid, count, i, j);\\n                }\\n            }\\n        }\\n        return m*n - guards.size() - walls.size() - count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    void helper(int m, int n, vector <vector <int>>& grid, int& count, int r, int c) {\\n        for (int i = r+1; i < m; i++) {\\n            if (grid[i][c] == 1 || grid[i][c] == 2) break;\\n            if (grid[i][c] == 0) {\\n                count++;\\n                grid[i][c] = 3;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2017228,
                "title": "java-dfs-based-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int castle[][]=new int[m][n];\\n        for(int guard[]:guards){\\n            castle[guard[0]][guard[1]]=1;\\n        }\\n        for(int wall[]:walls){\\n            castle[wall[0]][wall[1]]=2;\\n        }\\n        for(int guard[]:guards){\\n            dfs(castle, guard[0]-1, guard[1], m, n, 1);\\n            dfs(castle, guard[0], guard[1]+1, m, n, 2);\\n            dfs(castle, guard[0]+1, guard[1], m, n, 3);\\n            dfs(castle, guard[0], guard[1]-1, m, n, 4);\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(castle[i][j]==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    public void dfs(int castle[][], int i, int j, int m, int n, int dir){\\n        if(i<0||j<0||i>=m||j>=n||castle[i][j]==2||castle[i][j]==1){\\n            return;\\n        }\\n        castle[i][j]=3;\\n        if(dir==1){\\n            dfs(castle, i-1, j, m, n, 1);\\n        }\\n        else if(dir==2){\\n            dfs(castle, i, j+1, m, n, 2);\\n        }\\n        else if(dir==3){\\n            dfs(castle, i+1, j, m, n, 3);\\n        }\\n        else{\\n            dfs(castle, i, j-1, m, n, 4);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int castle[][]=new int[m][n];\\n        for(int guard[]:guards){\\n            castle[guard[0]][guard[1]]=1;\\n        }\\n        for(int wall[]:walls){\\n            castle[wall[0]][wall[1]]=2;\\n        }\\n        for(int guard[]:guards){\\n            dfs(castle, guard[0]-1, guard[1], m, n, 1);\\n            dfs(castle, guard[0], guard[1]+1, m, n, 2);\\n            dfs(castle, guard[0]+1, guard[1], m, n, 3);\\n            dfs(castle, guard[0], guard[1]-1, m, n, 4);\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(castle[i][j]==0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    public void dfs(int castle[][], int i, int j, int m, int n, int dir){\\n        if(i<0||j<0||i>=m||j>=n||castle[i][j]==2||castle[i][j]==1){\\n            return;\\n        }\\n        castle[i][j]=3;\\n        if(dir==1){\\n            dfs(castle, i-1, j, m, n, 1);\\n        }\\n        else if(dir==2){\\n            dfs(castle, i, j+1, m, n, 2);\\n        }\\n        else if(dir==3){\\n            dfs(castle, i+1, j, m, n, 3);\\n        }\\n        else{\\n            dfs(castle, i, j-1, m, n, 4);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010759,
                "title": "c-dfs-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int x,int y,vector<vector<int>>&grid,int dir,int m,int n)\\n    {\\n        if(x<0 or y<0 or x>=m or y>=n)\\n            return;\\n        if(grid[x][y]==2 or grid[x][y]==1)\\n            return;\\n        grid[x][y]=3;\\n        \\n        if(dir==1)\\n            dfs(x+1,y,grid,dir,m,n);\\n        else if(dir==2)\\n            dfs(x,y+1,grid,2,m,n);\\n        else if(dir==3)\\n            dfs(x-1,y,grid,3,m,n);\\n        else\\n            dfs(x,y-1,grid,4,m,n);\\n            \\n            \\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        \\n        int i,j;\\n        for(auto i:guards)\\n        {\\n            grid[i[0]][i[1]]=1;\\n        }\\n        for(auto i:walls)\\n        {\\n            grid[i[0]][i[1]]=2;\\n        }\\n        \\n        for(auto i:guards)\\n        {\\n            int x=i[0];\\n            int y=i[1];\\n            dfs(x+1,y,grid,1,m,n);\\n            dfs(x,y+1,grid,2,m,n);\\n            dfs(x-1,y,grid,3,m,n);\\n            dfs(x,y-1,grid,4,m,n);\\n            \\n        }\\n        int count=0;\\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int x,int y,vector<vector<int>>&grid,int dir,int m,int n)\\n    {\\n        if(x<0 or y<0 or x>=m or y>=n)\\n            return;\\n        if(grid[x][y]==2 or grid[x][y]==1)\\n            return;\\n        grid[x][y]=3;\\n        \\n        if(dir==1)\\n            dfs(x+1,y,grid,dir,m,n);\\n        else if(dir==2)\\n            dfs(x,y+1,grid,2,m,n);\\n        else if(dir==3)\\n            dfs(x-1,y,grid,3,m,n);\\n        else\\n            dfs(x,y-1,grid,4,m,n);\\n            \\n            \\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        \\n        int i,j;\\n        for(auto i:guards)\\n        {\\n            grid[i[0]][i[1]]=1;\\n        }\\n        for(auto i:walls)\\n        {\\n            grid[i[0]][i[1]]=2;\\n        }\\n        \\n        for(auto i:guards)\\n        {\\n            int x=i[0];\\n            int y=i[1];\\n            dfs(x+1,y,grid,1,m,n);\\n            dfs(x,y+1,grid,2,m,n);\\n            dfs(x-1,y,grid,3,m,n);\\n            dfs(x,y-1,grid,4,m,n);\\n            \\n        }\\n        int count=0;\\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998029,
                "title": "c-2-approach-iterative-dfs",
                "content": "*for reference:* \\n**cell[ i ][ j ]=**\\n0-> not guarded zone\\n1-> can be watched [guarded zone]\\n2-> guards \\n3-> walls\\n\\n\\n**Iterative:**\\n```\\nclass Solution {\\npublic:\\n    void traverse(int i,int j,vector<vector<int>>& cell){\\n        for(int k=i-1;k>=0;k--){ // up side traverse\\n            if(cell[k][j]==3 or cell[k][j]==2) break;\\n            else cell[k][j]=1;\\n        }\\n        for(int k=i+1;k<cell.size();k++){ //down side traverse\\n            if(cell[k][j]==3 or cell[k][j]==2) break;\\n            else cell[k][j]=1;\\n        }\\n        for(int k=j-1;k>=0;k--){ //left side traverse\\n            if(cell[i][k]==3 or cell[i][k]==2) break;\\n            else cell[i][k]=1;\\n        }\\n        for(int k=j+1;k<cell[i].size();k++){ //right side traverse\\n            if(cell[i][k]==3 or cell[i][k]==2) break;\\n            else cell[i][k]=1;\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> cell(m, vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            cell[guards[i][0]][guards[i][1]]=2;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            cell[walls[i][0]][walls[i][1]]=3;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            traverse(guards[i][0],guards[i][1],cell);\\n        }\\n        int count=0;\\n        for(auto x:cell){\\n            for(auto y:x)\\n                if(y==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\n**DFS:**\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,vector<vector<int>>& cell, char direction){\\n        if(i<0 or i>=cell.size() or j<0 or j>=cell[i].size() or cell[i][j]==2 or cell[i][j]==3)\\n            return;\\n        cell[i][j]=1;\\n        if(direction==\\'U\\')\\n            dfs(i-1,j,cell,\\'U\\');\\n        if(direction==\\'D\\')\\n            dfs(i+1,j,cell,\\'D\\');\\n        if(direction==\\'L\\')\\n            dfs(i,j-1,cell,\\'L\\');\\n        if(direction==\\'R\\')\\n            dfs(i,j+1,cell,\\'R\\');\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> cell(m, vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            cell[guards[i][0]][guards[i][1]]=2;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            cell[walls[i][0]][walls[i][1]]=3;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            dfs(guards[i][0]-1,guards[i][1],cell,\\'U\\'); // up\\n            dfs(guards[i][0]+1,guards[i][1],cell,\\'D\\'); // down\\n            dfs(guards[i][0],guards[i][1]-1,cell,\\'L\\'); // left\\n            dfs(guards[i][0],guards[i][1]+1,cell,\\'R\\'); // right\\n        }\\n        int count=0;\\n        for(auto x:cell){\\n            for(auto y:x)\\n                if(y==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(int i,int j,vector<vector<int>>& cell){\\n        for(int k=i-1;k>=0;k--){ // up side traverse\\n            if(cell[k][j]==3 or cell[k][j]==2) break;\\n            else cell[k][j]=1;\\n        }\\n        for(int k=i+1;k<cell.size();k++){ //down side traverse\\n            if(cell[k][j]==3 or cell[k][j]==2) break;\\n            else cell[k][j]=1;\\n        }\\n        for(int k=j-1;k>=0;k--){ //left side traverse\\n            if(cell[i][k]==3 or cell[i][k]==2) break;\\n            else cell[i][k]=1;\\n        }\\n        for(int k=j+1;k<cell[i].size();k++){ //right side traverse\\n            if(cell[i][k]==3 or cell[i][k]==2) break;\\n            else cell[i][k]=1;\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> cell(m, vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            cell[guards[i][0]][guards[i][1]]=2;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            cell[walls[i][0]][walls[i][1]]=3;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            traverse(guards[i][0],guards[i][1],cell);\\n        }\\n        int count=0;\\n        for(auto x:cell){\\n            for(auto y:x)\\n                if(y==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,vector<vector<int>>& cell, char direction){\\n        if(i<0 or i>=cell.size() or j<0 or j>=cell[i].size() or cell[i][j]==2 or cell[i][j]==3)\\n            return;\\n        cell[i][j]=1;\\n        if(direction==\\'U\\')\\n            dfs(i-1,j,cell,\\'U\\');\\n        if(direction==\\'D\\')\\n            dfs(i+1,j,cell,\\'D\\');\\n        if(direction==\\'L\\')\\n            dfs(i,j-1,cell,\\'L\\');\\n        if(direction==\\'R\\')\\n            dfs(i,j+1,cell,\\'R\\');\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> cell(m, vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            cell[guards[i][0]][guards[i][1]]=2;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            cell[walls[i][0]][walls[i][1]]=3;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            dfs(guards[i][0]-1,guards[i][1],cell,\\'U\\'); // up\\n            dfs(guards[i][0]+1,guards[i][1],cell,\\'D\\'); // down\\n            dfs(guards[i][0],guards[i][1]-1,cell,\\'L\\'); // left\\n            dfs(guards[i][0],guards[i][1]+1,cell,\\'R\\'); // right\\n        }\\n        int count=0;\\n        for(auto x:cell){\\n            for(auto y:x)\\n                if(y==0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995531,
                "title": "java-brute-force-matrix-filling-simulation-no-bfs-dfs-anything",
                "content": "The problem looks complex at first. But look at the constraints:\\n```\\n1 <= m, n <= 100,000\\n2 <= m * n <= 100,000\\n```\\ni.e. matrix max size is 100,000. Cosnidering using a char matrix - so size is ~ 100kb * 4 bytes of char = 400kb. Not much. If you use char array, you reduce the size.\\nAlso, 100,000 iterations is not much.\\nSo I thought that \"Let me try brute force first\". I did bruteforce, but hit TLE. That was because of the way I laid out my code. Eventually I got it working.\\n\\nSome basic stuff\\n1. Each wall is a blocker.\\n2. Each guard is a blocker. Although he can also see other cells.\\n\\t- so solve guard in 2 steps.\\n\\t- Step 1: Mark him as a block\\n\\t- Step 2: Mark the area he can view\\n3. Area blocked by a guard\\'s view is different than one blocked by Wall/Guard. Why? Because a guard\\'s view can cross this block in any direction.\\n4. So we end up with two kind of blocks \\n\\t- full block - wall/guard\\n\\t- view block - guard\\'s view\\n\\tLet\\'s denote these by 1 and 2 respectively.\\n5. So we store 3 states\\n\\t- un-blocked - 0\\n\\t- full blocked - 1\\n\\t- view blocked - 2\\nNote: These can also be represented by Boolean as it has 3 states (null, true, false) to optimize space usage and reduce it to 100kb. But I am not going to do that.\\n6. Finally - we can either parse whole prison again to get a count of free cells. Or just do this count while filling up. In my code I am counting it when filling up the prison. You could do it after filling up too - to make your code simpler.\\n7. Time Complexity = O ( guards * (ROWS + COLS)).\\n\\t- For each guard, I am marking row & col as view blocked - hence ROWS + COLS\\n\\t- So guard * (ROWS + COLS)\\n8. Code has a print() to show state of prison after calculation of every guard. This shall let you visualize how the code is working.\\n\\nHere is a simulation of example of question.\\nRemember\\n* 0 = un-blocked\\n* 1 = fully blocked\\n* 2 = view blocked\\n```\\nAfter filling walls and guards\\n  1  1  0  0  0  0\\n  0  1  0  0  1  0\\n  0  0  1  1  0  0\\n  0  0  0  0  0  0\\nAfter solving guard[0][0]\\n  1  1  0  0  0  0\\n  2  1  0  0  1  0\\n  2  0  1  1  0  0\\n  2  0  0  0  0  0\\nAfter solving guard[1][1]\\n  1  1  0  0  0  0\\n  2  1  2  2  1  0\\n  2  2  1  1  0  0\\n  2  2  0  0  0  0\\nAfter solving guard[2][3]\\n  1  1  0  2  0  0\\n  2  1  2  2  1  0\\n  2  2  1  1  2  2\\n  2  2  0  2  0  0\\n```\\n\\n\\nFinally the code\\n```\\nclass Solution {\\n    public int countUnguarded(int ROWS, int COLS, int[][] guards, int[][] walls) {\\n        int[][] prison = new int[ROWS][COLS];\\n        \\n        int prisonCells = ROWS * COLS;\\n        \\n        // Filling up prison with walls\\n        int walledCells = walls.length;\\n        for(int[] wall: walls) {\\n            prison[wall[0]][wall[1]] = 1;\\n        }\\n        \\n        // Filling up prison with guards\\n        int guardedCells = guards.length;\\n        for(int[] guard: guards) {\\n            prison[guard[0]][guard[1]] = 1;\\n        }\\n        \\n        // For each guard, marking view path\\n        for(int[] guard: guards) {\\n            int guardRow = guard[0];\\n            int guardCol = guard[1];\\n\\n            // run to top, not counting guard\\'s cell\\n            for(int row = guardRow - 1, col = guardCol; row >= 0 && prison[row][col] != 1;  row--) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to bottom, not counting guard\\'s cell\\n            for(int row = guardRow + 1, col = guardCol; row < ROWS && prison[row][col] != 1; row++) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to left, not counting guard\\'s cell\\n            for(int row = guardRow, col = guardCol - 1; col >= 0 && prison[row][col] != 1; col--) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to right, not counting guard\\'s cell\\n            for(int row = guardRow, col = guardCol + 1; col < COLS && prison[row][col] != 1; col++) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // Comment out this line before submission - only for simulation\\n            print(prison, \"After solving guard[\"+guard[0]+\"][\"+guard[1]+\"]\");\\n            \\n        }\\n        \\n        return prisonCells - (guardedCells + walledCells);\\n    }\\n    \\n    \\n    private void print(int[][] arr, String message) {\\n        System.out.println(message);\\n        for(int r = 0; r < arr.length; r++) {\\n            for(int c = 0; c < arr[0].length; c++) {\\n                System.out.print(\"  \" + arr[r][c]);\\n            }\\n            System.out.println(\"\");\\n        }\\n    }\\n}\\n```\\n\\nRemember to remove the call to print(arr) before submitting. \\n\\n",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\n1 <= m, n <= 100,000\\n2 <= m * n <= 100,000\\n```\n```\\nAfter filling walls and guards\\n  1  1  0  0  0  0\\n  0  1  0  0  1  0\\n  0  0  1  1  0  0\\n  0  0  0  0  0  0\\nAfter solving guard[0][0]\\n  1  1  0  0  0  0\\n  2  1  0  0  1  0\\n  2  0  1  1  0  0\\n  2  0  0  0  0  0\\nAfter solving guard[1][1]\\n  1  1  0  0  0  0\\n  2  1  2  2  1  0\\n  2  2  1  1  0  0\\n  2  2  0  0  0  0\\nAfter solving guard[2][3]\\n  1  1  0  2  0  0\\n  2  1  2  2  1  0\\n  2  2  1  1  2  2\\n  2  2  0  2  0  0\\n```\n```\\nclass Solution {\\n    public int countUnguarded(int ROWS, int COLS, int[][] guards, int[][] walls) {\\n        int[][] prison = new int[ROWS][COLS];\\n        \\n        int prisonCells = ROWS * COLS;\\n        \\n        // Filling up prison with walls\\n        int walledCells = walls.length;\\n        for(int[] wall: walls) {\\n            prison[wall[0]][wall[1]] = 1;\\n        }\\n        \\n        // Filling up prison with guards\\n        int guardedCells = guards.length;\\n        for(int[] guard: guards) {\\n            prison[guard[0]][guard[1]] = 1;\\n        }\\n        \\n        // For each guard, marking view path\\n        for(int[] guard: guards) {\\n            int guardRow = guard[0];\\n            int guardCol = guard[1];\\n\\n            // run to top, not counting guard\\'s cell\\n            for(int row = guardRow - 1, col = guardCol; row >= 0 && prison[row][col] != 1;  row--) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to bottom, not counting guard\\'s cell\\n            for(int row = guardRow + 1, col = guardCol; row < ROWS && prison[row][col] != 1; row++) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to left, not counting guard\\'s cell\\n            for(int row = guardRow, col = guardCol - 1; col >= 0 && prison[row][col] != 1; col--) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // run to right, not counting guard\\'s cell\\n            for(int row = guardRow, col = guardCol + 1; col < COLS && prison[row][col] != 1; col++) {\\n                if(prison[row][col] != 2) {  // to avoid counting view block cell twice\\n                    guardedCells++;\\n                }\\n                prison[row][col] = 2;\\n            }\\n            \\n            // Comment out this line before submission - only for simulation\\n            print(prison, \"After solving guard[\"+guard[0]+\"][\"+guard[1]+\"]\");\\n            \\n        }\\n        \\n        return prisonCells - (guardedCells + walledCells);\\n    }\\n    \\n    \\n    private void print(int[][] arr, String message) {\\n        System.out.println(message);\\n        for(int r = 0; r < arr.length; r++) {\\n            for(int c = 0; c < arr[0].length; c++) {\\n                System.out.print(\"  \" + arr[r][c]);\\n            }\\n            System.out.println(\"\");\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995260,
                "title": "explained-an-elegant-simple-approach-100-faster-and-100-better-space",
                "content": "Just a couple of points to consider, and its a piece of cake;\\n> 1. We begin by marking Guard and Wall on a grid to do our analysis.\\n> 2. Then iteratively, we will go to each guard and see how far it can see in all 4 cardinal directions. We will keep looking until we find a wall (or a guard, explained later).\\nHere is the Code;\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid(m, vector<int> (n, 0));\\n        for(int i=0; i<g.size(); i++){\\n            grid[g[i][0]][g[i][1]]=2;\\n        }\\n\\t\\t\\n        for(int i=0; i<w.size(); i++){\\n            grid[w[i][0]][w[i][1]]=-2;\\n        }\\n        \\n        for(int i=0; i<g.size(); i++){\\n            int cx = g[i][0];\\n            int cy = g[i][1];\\n            for(int i=cx+1; i<m; i++){\\n                if(grid[i][cy]==2 || grid[i][cy]==-2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int i=cx-1; i>=0; i--){\\n                if(grid[i][cy]==2 || grid[i][cy]==-2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int j=cy+1; j<n; j++){\\n                if(grid[cx][j]==2 || grid[cx][j]==-2) break;\\n                grid[cx][j]=1;\\n            }\\n            for(int j=cy-1; j>=0; j--){\\n                if(grid[cx][j]==2 || grid[cx][j]==-2) break;\\n                grid[cx][j]=1;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0) ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```\\n\\n\\nNow, One interesting thing is, We can optimize this code (slightly) by eliminating the redundant calculations. Here\\'s how;\\n> 1. In a manner of speaking, wall and guard are almost same when it comes to obstructing the view of a guard. If there is a wall (or a guard) in the view-line of a guard, we can stop looking more for it. Why? Because wall is obstructing guard\\'s view (obviously!) and the other guard will perform the same way as the first guard\\'s sight.\\nSo, we can update the code as;\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid(m, vector<int> (n, 0));\\n        \\n        for(int i=0; i<g.size(); i++){\\n            grid[g[i][0]][g[i][1]]=2;\\n        }\\n        \\n        for(int i=0; i<w.size(); i++){\\n            grid[w[i][0]][w[i][1]]=2;\\n        }\\n        \\n        for(int i=0; i<g.size(); i++){\\n            int cx = g[i][0];\\n            int cy = g[i][1];\\n            for(int i=cx+1; i<m; i++){\\n                if(grid[i][cy]==2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int i=cx-1; i>=0; i--){\\n                if(grid[i][cy]==2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int j=cy+1; j<n; j++){\\n                if(grid[cx][j]==2) break;\\n                grid[cx][j]=1;\\n            }\\n            for(int j=cy-1; j>=0; j--){\\n                if(grid[cx][j]==2) break;\\n                grid[cx][j]=1;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0) ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```\\n\\nLet me know if you\\'d like to add any point of if I have missed anything.\\nHappy Coding!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid(m, vector<int> (n, 0));\\n        for(int i=0; i<g.size(); i++){\\n            grid[g[i][0]][g[i][1]]=2;\\n        }\\n\\t\\t\\n        for(int i=0; i<w.size(); i++){\\n            grid[w[i][0]][w[i][1]]=-2;\\n        }\\n        \\n        for(int i=0; i<g.size(); i++){\\n            int cx = g[i][0];\\n            int cy = g[i][1];\\n            for(int i=cx+1; i<m; i++){\\n                if(grid[i][cy]==2 || grid[i][cy]==-2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int i=cx-1; i>=0; i--){\\n                if(grid[i][cy]==2 || grid[i][cy]==-2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int j=cy+1; j<n; j++){\\n                if(grid[cx][j]==2 || grid[cx][j]==-2) break;\\n                grid[cx][j]=1;\\n            }\\n            for(int j=cy-1; j>=0; j--){\\n                if(grid[cx][j]==2 || grid[cx][j]==-2) break;\\n                grid[cx][j]=1;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0) ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid(m, vector<int> (n, 0));\\n        \\n        for(int i=0; i<g.size(); i++){\\n            grid[g[i][0]][g[i][1]]=2;\\n        }\\n        \\n        for(int i=0; i<w.size(); i++){\\n            grid[w[i][0]][w[i][1]]=2;\\n        }\\n        \\n        for(int i=0; i<g.size(); i++){\\n            int cx = g[i][0];\\n            int cy = g[i][1];\\n            for(int i=cx+1; i<m; i++){\\n                if(grid[i][cy]==2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int i=cx-1; i>=0; i--){\\n                if(grid[i][cy]==2) break;\\n                grid[i][cy]=1;\\n            }\\n            for(int j=cy+1; j<n; j++){\\n                if(grid[cx][j]==2) break;\\n                grid[cx][j]=1;\\n            }\\n            for(int j=cy-1; j>=0; j--){\\n                if(grid[cx][j]==2) break;\\n                grid[cx][j]=1;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0) ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995166,
                "title": "java-easy-commented-iterative",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        int[][] grid = new int[n][m];\\n        //1-> guard\\n        //2-> walls \\n        //3-> guarded\\n        //0-> not guarded\\n\\t\\t\\n\\t\\t//putting values for guard\\n        for(int[] i : guards) {\\n            grid[i[0]][i[1]] = 1;\\n        }\\n        \\n\\t\\t//putting values for walls\\n        for(int[] i : walls) {\\n            grid[i[0]][i[1]] = 2;\\n        }\\n        \\n\\t\\t//traversing guards\\n        for(int j = 0; j < guards.length; j++) {\\n\\t\\t\\t//x and y co ordinate for guard\\n            int x = guards[j][0], y = guards[j][1];\\n            \\n\\t\\t\\t//traversing right side of guard\\n            for(int i = x+1; i < n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[i][y] == 0) grid[i][y] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[i][y] == 2 || grid[i][y] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing left side of guard\\n            for(int i = x-1; i >= 0; i--) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[i][y] == 0) grid[i][y] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[i][y] == 2 || grid[i][y] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing upper side of guard\\n            for(int i = y+1; i < m; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[x][i] == 0) grid[x][i] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[x][i] == 2 || grid[x][i] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing lower side fo guard\\n            for(int i = y-1; i >= 0; i--) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[x][i] == 0) grid[x][i] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[x][i] == 2 || grid[x][i] == 1) break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i =0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 0) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nDo upvote if the solution helped \\u270C",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        int[][] grid = new int[n][m];\\n        //1-> guard\\n        //2-> walls \\n        //3-> guarded\\n        //0-> not guarded\\n\\t\\t\\n\\t\\t//putting values for guard\\n        for(int[] i : guards) {\\n            grid[i[0]][i[1]] = 1;\\n        }\\n        \\n\\t\\t//putting values for walls\\n        for(int[] i : walls) {\\n            grid[i[0]][i[1]] = 2;\\n        }\\n        \\n\\t\\t//traversing guards\\n        for(int j = 0; j < guards.length; j++) {\\n\\t\\t\\t//x and y co ordinate for guard\\n            int x = guards[j][0], y = guards[j][1];\\n            \\n\\t\\t\\t//traversing right side of guard\\n            for(int i = x+1; i < n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[i][y] == 0) grid[i][y] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[i][y] == 2 || grid[i][y] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing left side of guard\\n            for(int i = x-1; i >= 0; i--) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[i][y] == 0) grid[i][y] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[i][y] == 2 || grid[i][y] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing upper side of guard\\n            for(int i = y+1; i < m; i++) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[x][i] == 0) grid[x][i] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[x][i] == 2 || grid[x][i] == 1) break;\\n            }\\n            \\n\\t\\t\\t//traversing lower side fo guard\\n            for(int i = y-1; i >= 0; i--) {\\n\\t\\t\\t\\n\\t\\t\\t\\t//if not guarded, guard the walls\\n                if(grid[x][i] == 0) grid[x][i] = 3;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//breaking if encountered a wall or guard (as we will be traversing for that guard while traversing \"guards\" array)\\n                else if(grid[x][i] == 2 || grid[x][i] == 1) break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i =0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 0) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994806,
                "title": "simple-python-code",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        vis = [[0]*n for _ in range(m)]\\n        # i - rows, j - colums\\n        # sum(row.count(\\'hit\\') for row in grid)\\n        for i,j in walls:\\n            vis[i][j] = 2\\n        for i,j in guards:\\n            vis[i][j] = 2\\n        for i,j in guards:\\n            for l in range(j-1,-1,-1):\\n                if self.checkWall(i,l,vis):\\n                    break    \\n                vis[i][l] = 1\\n            for r in range(j+1,n):\\n                if self.checkWall(i,r,vis):\\n                    break\\n                vis[i][r] = 1\\n            for u in range(i-1,-1,-1):\\n                if self.checkWall(u,j,vis):\\n                    break\\n                vis[u][j] = 1\\n            for d in range(i+1,m):\\n                if self.checkWall(d,j, vis):\\n                    break\\n                vis[d][j] = 1\\n        return sum(row.count(0) for row in vis)\\n        \\n    def checkWall(self, i, j, vis):\\n        if vis[i][j] ==2:\\n            return True\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        vis = [[0]*n for _ in range(m)]\\n        # i - rows, j - colums\\n        # sum(row.count(\\'hit\\') for row in grid)\\n        for i,j in walls:\\n            vis[i][j] = 2\\n        for i,j in guards:\\n            vis[i][j] = 2\\n        for i,j in guards:\\n            for l in range(j-1,-1,-1):\\n                if self.checkWall(i,l,vis):\\n                    break    \\n                vis[i][l] = 1\\n            for r in range(j+1,n):\\n                if self.checkWall(i,r,vis):\\n                    break\\n                vis[i][r] = 1\\n            for u in range(i-1,-1,-1):\\n                if self.checkWall(u,j,vis):\\n                    break\\n                vis[u][j] = 1\\n            for d in range(i+1,m):\\n                if self.checkWall(d,j, vis):\\n                    break\\n                vis[d][j] = 1\\n        return sum(row.count(0) for row in vis)\\n        \\n    def checkWall(self, i, j, vis):\\n        if vis[i][j] ==2:\\n            return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994707,
                "title": "solved-why-my-code-gives-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void help(vector<vector<int>> &mat,vector<int> g){\\n        // below\\n        for(int i=g[0];i<mat.size();i++){\\n            if(mat[i][g[1]]==-1){\\n                break;\\n            }else{\\n                mat[i][g[1]] = 1;\\n            }\\n        }\\n        // above\\n        for(int i=g[0];i>=0;i--){\\n            if(mat[i][g[1]]==-1){\\n                break;\\n            }else{\\n                mat[i][g[1]] = 1;\\n            }\\n        }\\n        //left\\n        for(int i=g[1];i>=0;i--){\\n            if(mat[g[0]][i]==-1){\\n                break;\\n            }else{\\n                mat[g[0]][i] = 1;\\n            }\\n        }\\n        // right\\n        for(int i=g[1];i<mat[0].size();i++){\\n            if(mat[g[0]][i]==-1){\\n                break;\\n            }else{\\n                mat[g[0]][i] = 1;\\n            }\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        for(int i=0;i<guards.size();i++){\\n            mat[guards[i][0]][guards[i][1]] = 1;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            mat[walls[i][0]][walls[i][1]] = -1;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            help(mat,guards[i]);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void help(vector<vector<int>> &mat,vector<int> g){\\n        // below\\n        for(int i=g[0];i<mat.size();i++){\\n            if(mat[i][g[1]]==-1){\\n                break;\\n            }else{\\n                mat[i][g[1]] = 1;\\n            }\\n        }\\n        // above\\n        for(int i=g[0];i>=0;i--){\\n            if(mat[i][g[1]]==-1){\\n                break;\\n            }else{\\n                mat[i][g[1]] = 1;\\n            }\\n        }\\n        //left\\n        for(int i=g[1];i>=0;i--){\\n            if(mat[g[0]][i]==-1){\\n                break;\\n            }else{\\n                mat[g[0]][i] = 1;\\n            }\\n        }\\n        // right\\n        for(int i=g[1];i<mat[0].size();i++){\\n            if(mat[g[0]][i]==-1){\\n                break;\\n            }else{\\n                mat[g[0]][i] = 1;\\n            }\\n        }\\n    }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        for(int i=0;i<guards.size();i++){\\n            mat[guards[i][0]][guards[i][1]] = 1;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            mat[walls[i][0]][walls[i][1]] = -1;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            help(mat,guards[i]);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994704,
                "title": "easy-brute-force-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<short int>> vec(m,vector<short int>(n,0));\\n\\t\\t// to check all directions in which we have already travelled\\n        bool vis[m][n][4];\\n        memset(vis,false,sizeof(vis));\\n        for(auto i:w)\\n            vec[i[0]][i[1]]=-1;\\n        \\n        for(auto i:g)\\n        {\\n\\t\\t\\t// marking true at 0 index of vec[i][j] -> upward direction from this point is visited\\n            for(int j=i[0];j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[j][i[1]]!=-1 && !vis[j][i[1]][0])\\n\\t\\t\\t\\t\\tvec[j][i[1]]=1,vis[j][i[1]][0]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 1 index of vec[i][j] -> left direction from this point is visited\\n            for(int j=i[1]-1;j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[i[0]][j]!=-1  && !vis[i[0]][j][1])\\n\\t\\t\\t\\t\\tvec[i[0]][j]=1,vis[i[0]][j][1]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 2 index of vec[i][j] -> downward direction from this point is visited\\n            for(int j=i[0]+1;j<m;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[j][i[1]]!=-1 && !vis[j][i[1]][2])\\n\\t\\t\\t\\t\\tvec[j][i[1]]=1,vis[j][i[1]][2]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 3 index of vec[i][j] -> right direction from this point is visited\\n            for(int j=i[1]+1;j<n;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[i[0]][j]!=-1 && !vis[i[0]][j][3])\\n\\t\\t\\t\\t\\tvec[i[0]][j]=1,vis[i[0]][j][3]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        int c=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vec[i][j]==0)\\n                    c++;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<short int>> vec(m,vector<short int>(n,0));\\n\\t\\t// to check all directions in which we have already travelled\\n        bool vis[m][n][4];\\n        memset(vis,false,sizeof(vis));\\n        for(auto i:w)\\n            vec[i[0]][i[1]]=-1;\\n        \\n        for(auto i:g)\\n        {\\n\\t\\t\\t// marking true at 0 index of vec[i][j] -> upward direction from this point is visited\\n            for(int j=i[0];j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[j][i[1]]!=-1 && !vis[j][i[1]][0])\\n\\t\\t\\t\\t\\tvec[j][i[1]]=1,vis[j][i[1]][0]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 1 index of vec[i][j] -> left direction from this point is visited\\n            for(int j=i[1]-1;j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[i[0]][j]!=-1  && !vis[i[0]][j][1])\\n\\t\\t\\t\\t\\tvec[i[0]][j]=1,vis[i[0]][j][1]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 2 index of vec[i][j] -> downward direction from this point is visited\\n            for(int j=i[0]+1;j<m;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[j][i[1]]!=-1 && !vis[j][i[1]][2])\\n\\t\\t\\t\\t\\tvec[j][i[1]]=1,vis[j][i[1]][2]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\t// marking true at 3 index of vec[i][j] -> right direction from this point is visited\\n            for(int j=i[1]+1;j<n;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(vec[i[0]][j]!=-1 && !vis[i[0]][j][3])\\n\\t\\t\\t\\t\\tvec[i[0]][j]=1,vis[i[0]][j][3]=1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        int c=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vec[i][j]==0)\\n                    c++;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994669,
                "title": "c-o-4-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        int cnt=0;\\n        for(int i=0;i<walls.size();i++){\\n            mat[walls[i][0]][walls[i][1]]=1;\\n        }\\n        \\n        for(int i=0;i<guards.size();i++){\\n            mat[guards[i][0]][guards[i][1]]=2;\\n        }\\n        \\n        \\n        //row-wise left iterating\\n        for(int i=0;i<m;i++){\\n            bool guard=false;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    guard=false;\\n                }else if(mat[i][j]==0 and guard==true){\\n                    mat[i][j]=3;\\n                }else if(mat[i][j]==2){\\n                    guard=true;\\n                }\\n            }\\n        }\\n        \\n        //row-wise right iterating\\n        for(int i=0;i<m;i++){\\n            bool guard=false;\\n            for(int j=n-1;j>=0;j--){\\n                if(mat[i][j]==1){\\n                    guard=false;\\n                }else if(mat[i][j]==0 and guard==true){\\n                    mat[i][j]=3;\\n                }else if(mat[i][j]==2){\\n                    guard=true;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            bool guard=false;\\n            for(int j=0;j<m;j++){\\n                if(mat[j][i]==1){\\n                    guard=false;\\n                }else if(mat[j][i]==0 and guard==true){\\n                    mat[j][i]=3;\\n                }else if(mat[j][i]==2){\\n                    guard=true;\\n                }\\n                // cout<<j<<\" \"<<i<<\" \"<<guard<<endl;\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            bool guard=false;\\n            for(int j=m-1;j>=0;j--){\\n                if(mat[j][i]==1){\\n                    guard=false;\\n                }else if(mat[j][i]==0 and guard==true){\\n                    mat[j][i]=3;\\n                }else if(mat[j][i]==2){\\n                    guard=true;\\n                }\\n                // cout<<j<<\" \"<<i<<\" \"<<guard<<endl;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==0){\\n                    cnt++;\\n                }\\n                // cout<<mat[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        int cnt=0;\\n        for(int i=0;i<walls.size();i++){\\n            mat[walls[i][0]][walls[i][1]]=1;\\n        }\\n        \\n        for(int i=0;i<guards.size();i++){\\n            mat[guards[i][0]][guards[i][1]]=2;\\n        }\\n        \\n        \\n        //row-wise left iterating\\n        for(int i=0;i<m;i++){\\n            bool guard=false;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    guard=false;\\n                }else if(mat[i][j]==0 and guard==true){\\n                    mat[i][j]=3;\\n                }else if(mat[i][j]==2){\\n                    guard=true;\\n                }\\n            }\\n        }\\n        \\n        //row-wise right iterating\\n        for(int i=0;i<m;i++){\\n            bool guard=false;\\n            for(int j=n-1;j>=0;j--){\\n                if(mat[i][j]==1){\\n                    guard=false;\\n                }else if(mat[i][j]==0 and guard==true){\\n                    mat[i][j]=3;\\n                }else if(mat[i][j]==2){\\n                    guard=true;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            bool guard=false;\\n            for(int j=0;j<m;j++){\\n                if(mat[j][i]==1){\\n                    guard=false;\\n                }else if(mat[j][i]==0 and guard==true){\\n                    mat[j][i]=3;\\n                }else if(mat[j][i]==2){\\n                    guard=true;\\n                }\\n                // cout<<j<<\" \"<<i<<\" \"<<guard<<endl;\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            bool guard=false;\\n            for(int j=m-1;j>=0;j--){\\n                if(mat[j][i]==1){\\n                    guard=false;\\n                }else if(mat[j][i]==0 and guard==true){\\n                    mat[j][i]=3;\\n                }else if(mat[j][i]==2){\\n                    guard=true;\\n                }\\n                // cout<<j<<\" \"<<i<<\" \"<<guard<<endl;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==0){\\n                    cnt++;\\n                }\\n                // cout<<mat[i][j]<<\" \";\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994653,
                "title": "c-solution-traverse-in-all-direction",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m,vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            grid[guards[i][0]][guards[i][1]]=1;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            grid[walls[i][0]][walls[i][1]]=2;\\n        }\\n//         left to right\\n        auto temp1=grid,temp2=grid,temp3=grid,temp4=grid;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp1[i][j]==2 || temp1[i][j]==1)\\n                    continue;\\n                if(j>0 && temp1[i][j-1]==1)\\n                    temp1[i][j]=1;\\n            }\\n        }\\n//      right to left\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(temp2[i][j]==2 || temp2[i][j]==1)\\n                    continue;\\n                if(j<n-1 && temp2[i][j+1]==1)\\n                    temp2[i][j]=1;\\n            }\\n        }\\n//       top to down\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp3[i][j]==2 ||  temp3[i][j]==1)\\n                    continue;\\n                if(i>0 && temp3[i-1][j]==1)\\n                    temp3[i][j]=1;\\n            }\\n        }\\n//        down to top\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(temp4[i][j]==2 || temp4[i][j]==1)\\n                    continue;\\n                if(i<m-1 && temp4[i+1][j]==1)\\n                    temp4[i][j]=1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp1[i][j]==0 && temp2[i][j]==0 && temp3[i][j]==0 && temp4[i][j]==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m,vector<int>(n));\\n        for(int i=0;i<guards.size();i++){\\n            grid[guards[i][0]][guards[i][1]]=1;\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            grid[walls[i][0]][walls[i][1]]=2;\\n        }\\n//         left to right\\n        auto temp1=grid,temp2=grid,temp3=grid,temp4=grid;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp1[i][j]==2 || temp1[i][j]==1)\\n                    continue;\\n                if(j>0 && temp1[i][j-1]==1)\\n                    temp1[i][j]=1;\\n            }\\n        }\\n//      right to left\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(temp2[i][j]==2 || temp2[i][j]==1)\\n                    continue;\\n                if(j<n-1 && temp2[i][j+1]==1)\\n                    temp2[i][j]=1;\\n            }\\n        }\\n//       top to down\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp3[i][j]==2 ||  temp3[i][j]==1)\\n                    continue;\\n                if(i>0 && temp3[i-1][j]==1)\\n                    temp3[i][j]=1;\\n            }\\n        }\\n//        down to top\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(temp4[i][j]==2 || temp4[i][j]==1)\\n                    continue;\\n                if(i<m-1 && temp4[i+1][j]==1)\\n                    temp4[i][j]=1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp1[i][j]==0 && temp2[i][j]==0 && temp3[i][j]==0 && temp4[i][j]==0)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994573,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        \\n        int n1=walls.size();\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            v[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n        //***************************************\\n        \\n        n1=guards.size();\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            \\n            v[x][y]=0;\\n        }\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            \\n            \\n            int p=y+1;\\n            while(p<n)\\n            {\\n                if(v[x][p]==0 || v[x][p]==2)\\n                {\\n                    break;\\n                }\\n                v[x][p]=1;\\n                p++;\\n            }\\n            p=y-1;\\n            while(p>=0)\\n            {\\n                if(v[x][p]==0 || v[x][p]==2)\\n                {\\n                    break;\\n                }\\n                v[x][p]=1;\\n                p--;\\n            }\\n            int q=x+1;\\n            while(q<m)\\n            {\\n                if(v[q][y]==0 || v[q][y]==2)\\n                {\\n                    break;\\n                }\\n                v[q][y]=1;\\n                q++;\\n            }\\n            q=x-1;\\n            while(q>=0)\\n            {\\n                if(v[q][y]==0 || v[q][y]==2)\\n                {\\n                    break;\\n                }\\n                v[q][y]=1;\\n                q--;\\n            }\\n            \\n        }\\n        int res=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // cout<<v[i][j]<<\" \";\\n                if(v[i][j]==-1) res++;\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        \\n        int n1=walls.size();\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            v[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n        //***************************************\\n        \\n        n1=guards.size();\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            \\n            v[x][y]=0;\\n        }\\n        \\n        for(int i=0;i<n1;i++)\\n        {\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            \\n            \\n            int p=y+1;\\n            while(p<n)\\n            {\\n                if(v[x][p]==0 || v[x][p]==2)\\n                {\\n                    break;\\n                }\\n                v[x][p]=1;\\n                p++;\\n            }\\n            p=y-1;\\n            while(p>=0)\\n            {\\n                if(v[x][p]==0 || v[x][p]==2)\\n                {\\n                    break;\\n                }\\n                v[x][p]=1;\\n                p--;\\n            }\\n            int q=x+1;\\n            while(q<m)\\n            {\\n                if(v[q][y]==0 || v[q][y]==2)\\n                {\\n                    break;\\n                }\\n                v[q][y]=1;\\n                q++;\\n            }\\n            q=x-1;\\n            while(q>=0)\\n            {\\n                if(v[q][y]==0 || v[q][y]==2)\\n                {\\n                    break;\\n                }\\n                v[q][y]=1;\\n                q--;\\n            }\\n            \\n        }\\n        int res=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // cout<<v[i][j]<<\" \";\\n                if(v[i][j]==-1) res++;\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3491880,
                "title": "bfs-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int visit[][]=new int[m][n];\\n        int delRow[]={0,0,1,-1};\\n        int delCol[]={1,-1,0,0};\\n        //\\'G\\'=1, \\'W=2\\'\\n        \\n        for(int i=0;i<walls.length;i++){\\n            visit[walls[i][0]][walls[i][1]]=1;\\n        }\\n        Queue<Pair>q=new LinkedList<>();\\n        \\n        \\n        for(int i=0;i<guards.length;i++){\\n            int start=guards[i][0];\\n            int end=guards[i][1];\\n            q.add(new Pair(start,end));\\n            visit[start][end]=2;\\n        }\\n        \\n        \\n        while(!q.isEmpty()){\\n            Pair pr=q.poll();\\n            int row=pr.first;\\n            int col=pr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                int nrow=row+delRow[i];\\n                int ncol=col+delCol[i];\\n                \\n                while(nrow<m && nrow>=0 && ncol<n && ncol>=0 && visit[nrow][ncol]!=1 && visit[nrow][ncol]!=2){\\n                    visit[nrow][ncol]=-1;\\n                    nrow+=delRow[i];\\n                    ncol+=delCol[i];\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visit[i][j]==0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    \\n    public void bfs(int start,int end,int visit[][],int delRow[],int delCol[],int m,int n){\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n    Pair(int first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\n\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int visit[][]=new int[m][n];\\n        int delRow[]={0,0,1,-1};\\n        int delCol[]={1,-1,0,0};\\n        //\\'G\\'=1, \\'W=2\\'\\n        \\n        for(int i=0;i<walls.length;i++){\\n            visit[walls[i][0]][walls[i][1]]=1;\\n        }\\n        Queue<Pair>q=new LinkedList<>();\\n        \\n        \\n        for(int i=0;i<guards.length;i++){\\n            int start=guards[i][0];\\n            int end=guards[i][1];\\n            q.add(new Pair(start,end));\\n            visit[start][end]=2;\\n        }\\n        \\n        \\n        while(!q.isEmpty()){\\n            Pair pr=q.poll();\\n            int row=pr.first;\\n            int col=pr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                int nrow=row+delRow[i];\\n                int ncol=col+delCol[i];\\n                \\n                while(nrow<m && nrow>=0 && ncol<n && ncol>=0 && visit[nrow][ncol]!=1 && visit[nrow][ncol]!=2){\\n                    visit[nrow][ncol]=-1;\\n                    nrow+=delRow[i];\\n                    ncol+=delCol[i];\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visit[i][j]==0){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    \\n    public void bfs(int start,int end,int visit[][],int delRow[],int delCol[],int m,int n){\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185282,
                "title": "python-dfs-solution-with-explaination",
                "content": "Idea is to mark all locations which the guard can see with \\'X\\' value. Then later just count the non marked cells.\\n\\nDefines a named tuple called \"Directions\" with two fields x and y, which represents the movement directions on a 2D grid.\\n\\n\\nCreates a matrix with zeros of size m x n and fills it with \\'G\\' and \\'W\\' for the guard and wall locations, respectively.\\n\\nIt then performs a depth-first search starting from each guard location, moving in each of the four directions specified by the Directions named tuple.\\n\\nDuring the depth-first search, if the search goes out of bounds, hits a wall or another guard, it stops. Otherwise, it marks the current cell as \\'X\\' to indicate it has been visited and continues the search in the specified direction.\\n\\nAfter the search is complete, the method counts the number of cells in the matrix that are still 0 (i.e., unguarded) and returns the count.\\n\\n\\n```\\nfrom collections import namedtuple\\nfrom typing import List\\n\\nDirections = namedtuple(\\'Directions\\', [\\'x\\', \\'y\\'])\\nup = Directions(-1, 0)\\ndown = Directions(1, 0)\\nleft = Directions(0, -1)\\nright = Directions(0, 1)\\n\\n\\ndef countUnguarded(m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n    matrix = [[0 for _ in range(n)] for _ in range(m)]\\n    for x, y in guards:\\n        matrix[x][y] = \\'G\\'\\n    for x, y in walls:\\n        matrix[x][y] = \\'W\\'\\n\\n    def dfs(row, col, direction):\\n        if row < 0 or row >= m or col < 0 or col >= n or matrix[row][col] == \\'W\\' or matrix[row][col] == \\'G\\':\\n            return\\n\\n        matrix[row][col] = \\'X\\'\\n        dfs(row + direction.x, col + direction.y, direction)\\n\\n    for x in range(m):\\n        for y in range(n):\\n            if matrix[x][y] == \\'G\\':\\n                dfs(x + 1, y, down)\\n                dfs(x - 1, y, up)\\n                dfs(x, y + 1, right)\\n                dfs(x, y - 1, left)\\n\\n    counter = 0\\n    for x in range(m):\\n        for y in range(n):\\n            if matrix[x][y] == 0:\\n                counter += 1\\n\\n    return counter\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import namedtuple\\nfrom typing import List\\n\\nDirections = namedtuple(\\'Directions\\', [\\'x\\', \\'y\\'])\\nup = Directions(-1, 0)\\ndown = Directions(1, 0)\\nleft = Directions(0, -1)\\nright = Directions(0, 1)\\n\\n\\ndef countUnguarded(m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n    matrix = [[0 for _ in range(n)] for _ in range(m)]\\n    for x, y in guards:\\n        matrix[x][y] = \\'G\\'\\n    for x, y in walls:\\n        matrix[x][y] = \\'W\\'\\n\\n    def dfs(row, col, direction):\\n        if row < 0 or row >= m or col < 0 or col >= n or matrix[row][col] == \\'W\\' or matrix[row][col] == \\'G\\':\\n            return\\n\\n        matrix[row][col] = \\'X\\'\\n        dfs(row + direction.x, col + direction.y, direction)\\n\\n    for x in range(m):\\n        for y in range(n):\\n            if matrix[x][y] == \\'G\\':\\n                dfs(x + 1, y, down)\\n                dfs(x - 1, y, up)\\n                dfs(x, y + 1, right)\\n                dfs(x, y - 1, left)\\n\\n    counter = 0\\n    for x in range(m):\\n        for y in range(n):\\n            if matrix[x][y] == 0:\\n                counter += 1\\n\\n    return counter\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2278891,
                "title": "95-faster-python-solution",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        def moveLeft(r, c):\\n            r, c = r, c-1\\n            if c<0 or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveLeft(r, c)\\n        def moveRight(r, c):\\n            r, c = r, c+1\\n            if c>=n or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveRight(r, c)\\n        def moveTop(r, c):\\n            r, c = r-1, c\\n            if r<0 or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveTop(r, c)\\n        def moveBot(r, c):\\n            r, c = r+1, c\\n            if r>=m or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveBot(r,c)\\n        grid = []\\n        \\n        \\n        for i in range(m):\\n            grid.append([False]*n)\\n        for r, c in guards:\\n            grid[r][c] = \"G\"\\n        for r, c in walls:\\n            grid[r][c] = \"W\"\\n        for r, c in guards:\\n            moveTop(r, c)\\n            moveBot(r,c)\\n            moveLeft(r, c)\\n            moveRight(r, c)\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == False:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        def moveLeft(r, c):\\n            r, c = r, c-1\\n            if c<0 or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveLeft(r, c)\\n        def moveRight(r, c):\\n            r, c = r, c+1\\n            if c>=n or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveRight(r, c)\\n        def moveTop(r, c):\\n            r, c = r-1, c\\n            if r<0 or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveTop(r, c)\\n        def moveBot(r, c):\\n            r, c = r+1, c\\n            if r>=m or grid[r][c] == \"W\" or grid[r][c] ==\"G\":\\n                return\\n            grid[r][c]=True\\n            moveBot(r,c)\\n        grid = []\\n        \\n        \\n        for i in range(m):\\n            grid.append([False]*n)\\n        for r, c in guards:\\n            grid[r][c] = \"G\"\\n        for r, c in walls:\\n            grid[r][c] = \"W\"\\n        for r, c in guards:\\n            moveTop(r, c)\\n            moveBot(r,c)\\n            moveLeft(r, c)\\n            moveRight(r, c)\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == False:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244039,
                "title": "python3-simple-logic-memory-efficient",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        ROWS = m; COLS = n\\n        guarded = set()\\n        guards = set((r,c) for r,c in guards)\\n        walls = set((r,c) for r,c in walls)\\n        \\n        for R,C in guards:\\n            \\n            #right\\n            for c in range(C+1,COLS):\\n                if (R,c) in guards or (R,c) in walls:\\n                    break\\n                guarded.add((R,c))\\n            #left\\n            for c in range(C-1,-1,-1):\\n                if (R,c) in guards or (R,c) in walls:\\n                    break\\n                guarded.add((R,c))\\n            #up\\n            for r in range(R-1,-1,-1):\\n                if (r,C) in guards or (r,C) in walls:\\n                    break\\n                guarded.add((r,C))\\n            #down\\n            for r in range(R+1,ROWS):\\n                if (r,C) in guards or (r,C) in walls:\\n                    break\\n                guarded.add((r,C))\\n        \\n        return ROWS*COLS - len(guards) - len(walls) - len(guarded)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        ROWS = m; COLS = n\\n        guarded = set()\\n        guards = set((r,c) for r,c in guards)\\n        walls = set((r,c) for r,c in walls)\\n        \\n        for R,C in guards:\\n            \\n            #right\\n            for c in range(C+1,COLS):\\n                if (R,c) in guards or (R,c) in walls:\\n                    break\\n                guarded.add((R,c))\\n            #left\\n            for c in range(C-1,-1,-1):\\n                if (R,c) in guards or (R,c) in walls:\\n                    break\\n                guarded.add((R,c))\\n            #up\\n            for r in range(R-1,-1,-1):\\n                if (r,C) in guards or (r,C) in walls:\\n                    break\\n                guarded.add((r,C))\\n            #down\\n            for r in range(R+1,ROWS):\\n                if (r,C) in guards or (r,C) in walls:\\n                    break\\n                guarded.add((r,C))\\n        \\n        return ROWS*COLS - len(guards) - len(walls) - len(guarded)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2166638,
                "title": "a-few-solutions",
                "content": "`walk` in all four cardinal directions (up, right, down, left) from guard cell `i`,`j` to mark `seen` cells.  Then return the cardinality of the matrix `M * N` minus the cardinality of the `seen` set.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countUnguarded(M: Int, N: Int, G_: Array<IntArray>, W_: Array<IntArray>): Int {\\n        var seen = mutableSetOf<String>()\\n        var key = { i: Int, j: Int -> \"$i,$j\" }\\n        var G = G_.map{ key(it[0], it[1]) }.toSet()\\n        var W = W_.map{ key(it[0], it[1]) }.toSet()\\n        fun walk(row: Int, col: Int) {\\n            for ((di, dj) in listOf(Pair(-1, 0), Pair(0, 1), Pair(1, 0), Pair(0, -1))) {\\n                var i = row\\n                var j = col\\n                while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                    i += di\\n                    j += dj\\n                    var k = key(i, j)\\n                    if (G.contains(k) || W.contains(k))\\n                        break\\n                    seen.add(k)\\n                }\\n            }\\n        }\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var k = key(i, j)\\n                if (G.contains(k)) { seen.add(k); walk(i, j) }\\n                if (W.contains(k)) { seen.add(k) }\\n            }\\n        }\\n        return M * N - seen.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countUnguarded = (M, N, G_, W_, seen = new Set()) => {\\n    let key = (i, j) => `${i},${j}`;\\n    let G = new Set([...G_].map(([i, j]) => key(i, j))),\\n        W = new Set([...W_].map(([i, j]) => key(i, j)));\\n    let walk = (row, col) => {\\n        for (let [di, dj] of [[-1, 0], [0, 1], [1, 0], [0, -1]]) {\\n            let i = row,\\n                j = col;\\n            while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                i += di;\\n                j += dj;\\n                k = key(i, j);\\n                if (G.has(k) || W.has(k))\\n                    break;\\n                seen.add(k);\\n            }\\n        }\\n    };\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let k = key(i, j);\\n            if (G.has(k)) seen.add(k), walk(i, j);\\n            if (W.has(k)) seen.add(k);\\n        }\\n    }\\n    return M * N - seen.size;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countUnguarded(self, M: int, N: int, G: List[List[int]], W: List[List[int]]) -> int:\\n        seen = set()\\n        G = set([(i, j) for i, j in G])\\n        W = set([(i, j) for i, j in W])\\n        def walk(row, col):\\n            for di, dj in [[-1, 0], [0, 1], [1, 0], [0, -1]]:\\n                i = row\\n                j = col\\n                while 0 <= i + di < M and 0 <= j + dj < N:\\n                    i += di\\n                    j += dj\\n                    if (i, j) in G or (i, j) in W:\\n                        break\\n                    seen.add((i, j))\\n        for i in range(M):\\n            for j in range(N):\\n                if (i, j) in G: seen.add((i, j)); walk(i, j)\\n                if (i, j) in W: seen.add((i, j))\\n        return M * N - len(seen)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_unguarded(M: i32, N: i32, G_: VVI, W_: VVI) -> i32 {\\n        let mut G = HashSet::new();\\n        let mut W = HashSet::new();\\n        let mut seen = HashSet::new();\\n        let key = (|i, j| format!(\"{},{}\", i, j));\\n        for pair in G_ { G.insert(key(pair[0], pair[1])); }\\n        for pair in W_ { W.insert(key(pair[0], pair[1])); }\\n        let mut walk = (|row, col| {\\n            let k = key(row, col);\\n            seen.insert(k.clone());\\n            if W.contains(&k) {\\n                return;\\n            }\\n            for (di, dj) in vec![(-1, 0), (0, 1), (1, 0), (0, -1)] {\\n                let mut i = row;\\n                let mut j = col;\\n                while 0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N {\\n                    i += di;\\n                    j += dj;\\n                    let k = key(i, j);\\n                    if G.contains(&k) || W.contains(&k) {\\n                        break;\\n                    }\\n                    seen.insert(k.clone());\\n                }\\n            }\\n        });\\n        for i in 0..M {\\n            for j in 0..N {\\n                let k = key(i, j);\\n                if G.contains(&k) || W.contains(&k) {\\n                    walk(i as i32, j as i32);\\n                }\\n            }\\n        }\\n        return M * N - seen.len() as i32;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Set = unordered_set<string>;\\n    int countUnguarded(int M, int N, VVI& G_, VVI& W_, Set G = {}, Set W = {}, Set seen = {}) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        for (auto& pair: G_) G.insert(key(pair[0], pair[1]));\\n        for (auto& pair: W_) W.insert(key(pair[0], pair[1]));\\n        auto walk = [&](auto row, auto col) {\\n            for (auto [di, dj]: Pairs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) {\\n                auto i = row,\\n                     j = col;\\n                while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                    i += di;\\n                    j += dj;\\n                    auto k = key(i, j);\\n                    if (G.find(k) != G.end() || W.find(k) != W.end())\\n                        break;\\n                    seen.insert(k);\\n                }\\n            }\\n        };\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto k = key(i, j);\\n                if (G.find(k) != G.end()) seen.insert(k), walk(i, j);\\n                if (W.find(k) != W.end()) seen.insert(k);\\n            }\\n        }\\n        return M * N - seen.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countUnguarded(M: Int, N: Int, G_: Array<IntArray>, W_: Array<IntArray>): Int {\\n        var seen = mutableSetOf<String>()\\n        var key = { i: Int, j: Int -> \"$i,$j\" }\\n        var G = G_.map{ key(it[0], it[1]) }.toSet()\\n        var W = W_.map{ key(it[0], it[1]) }.toSet()\\n        fun walk(row: Int, col: Int) {\\n            for ((di, dj) in listOf(Pair(-1, 0), Pair(0, 1), Pair(1, 0), Pair(0, -1))) {\\n                var i = row\\n                var j = col\\n                while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                    i += di\\n                    j += dj\\n                    var k = key(i, j)\\n                    if (G.contains(k) || W.contains(k))\\n                        break\\n                    seen.add(k)\\n                }\\n            }\\n        }\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var k = key(i, j)\\n                if (G.contains(k)) { seen.add(k); walk(i, j) }\\n                if (W.contains(k)) { seen.add(k) }\\n            }\\n        }\\n        return M * N - seen.size\\n    }\\n}\\n```\n```\\nlet countUnguarded = (M, N, G_, W_, seen = new Set()) => {\\n    let key = (i, j) => `${i},${j}`;\\n    let G = new Set([...G_].map(([i, j]) => key(i, j))),\\n        W = new Set([...W_].map(([i, j]) => key(i, j)));\\n    let walk = (row, col) => {\\n        for (let [di, dj] of [[-1, 0], [0, 1], [1, 0], [0, -1]]) {\\n            let i = row,\\n                j = col;\\n            while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                i += di;\\n                j += dj;\\n                k = key(i, j);\\n                if (G.has(k) || W.has(k))\\n                    break;\\n                seen.add(k);\\n            }\\n        }\\n    };\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let k = key(i, j);\\n            if (G.has(k)) seen.add(k), walk(i, j);\\n            if (W.has(k)) seen.add(k);\\n        }\\n    }\\n    return M * N - seen.size;\\n};\\n```\n```\\nclass Solution:\\n    def countUnguarded(self, M: int, N: int, G: List[List[int]], W: List[List[int]]) -> int:\\n        seen = set()\\n        G = set([(i, j) for i, j in G])\\n        W = set([(i, j) for i, j in W])\\n        def walk(row, col):\\n            for di, dj in [[-1, 0], [0, 1], [1, 0], [0, -1]]:\\n                i = row\\n                j = col\\n                while 0 <= i + di < M and 0 <= j + dj < N:\\n                    i += di\\n                    j += dj\\n                    if (i, j) in G or (i, j) in W:\\n                        break\\n                    seen.add((i, j))\\n        for i in range(M):\\n            for j in range(N):\\n                if (i, j) in G: seen.add((i, j)); walk(i, j)\\n                if (i, j) in W: seen.add((i, j))\\n        return M * N - len(seen)\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_unguarded(M: i32, N: i32, G_: VVI, W_: VVI) -> i32 {\\n        let mut G = HashSet::new();\\n        let mut W = HashSet::new();\\n        let mut seen = HashSet::new();\\n        let key = (|i, j| format!(\"{},{}\", i, j));\\n        for pair in G_ { G.insert(key(pair[0], pair[1])); }\\n        for pair in W_ { W.insert(key(pair[0], pair[1])); }\\n        let mut walk = (|row, col| {\\n            let k = key(row, col);\\n            seen.insert(k.clone());\\n            if W.contains(&k) {\\n                return;\\n            }\\n            for (di, dj) in vec![(-1, 0), (0, 1), (1, 0), (0, -1)] {\\n                let mut i = row;\\n                let mut j = col;\\n                while 0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N {\\n                    i += di;\\n                    j += dj;\\n                    let k = key(i, j);\\n                    if G.contains(&k) || W.contains(&k) {\\n                        break;\\n                    }\\n                    seen.insert(k.clone());\\n                }\\n            }\\n        });\\n        for i in 0..M {\\n            for j in 0..N {\\n                let k = key(i, j);\\n                if G.contains(&k) || W.contains(&k) {\\n                    walk(i as i32, j as i32);\\n                }\\n            }\\n        }\\n        return M * N - seen.len() as i32;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Pair = pair<int, int>;\\n    using Pairs = vector<Pair>;\\n    using Set = unordered_set<string>;\\n    int countUnguarded(int M, int N, VVI& G_, VVI& W_, Set G = {}, Set W = {}, Set seen = {}) {\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        for (auto& pair: G_) G.insert(key(pair[0], pair[1]));\\n        for (auto& pair: W_) W.insert(key(pair[0], pair[1]));\\n        auto walk = [&](auto row, auto col) {\\n            for (auto [di, dj]: Pairs{{-1, 0}, {0, 1}, {1, 0}, {0, -1}}) {\\n                auto i = row,\\n                     j = col;\\n                while (0 <= i + di && i + di < M && 0 <= j + dj && j + dj < N) {\\n                    i += di;\\n                    j += dj;\\n                    auto k = key(i, j);\\n                    if (G.find(k) != G.end() || W.find(k) != W.end())\\n                        break;\\n                    seen.insert(k);\\n                }\\n            }\\n        };\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto k = key(i, j);\\n                if (G.find(k) != G.end()) seen.insert(k), walk(i, j);\\n                if (W.find(k) != W.end()) seen.insert(k);\\n            }\\n        }\\n        return M * N - seen.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118234,
                "title": "simple-java-simulation",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] mat=new int[m][n];\\n        for(int[] d:walls){\\n            mat[d[0]][d[1]]=1;\\n        }\\n        for(int[] d:guards){\\n            mat[d[0]][d[1]]=2;\\n        }\\n        for(int[] d:guards){\\n            bfs(mat,d[0],d[1]);\\n        }\\n        int cnt=0;\\n        for(int[] d:mat){\\n            for(int num:d){\\n                if(num==0)cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int[][] dir=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n    public void bfs(int[][] mat,int i,int j){\\n        mat[i][j]=2;\\n        for(int k=0;k<4;k++){\\n            int r=i,c=j;\\n            \\n            while(r+dir[k][0]>=0 && r+dir[k][0]<mat.length && c+dir[k][1]>=0 && c+dir[k][1]<mat[0].length && mat[r+dir[k][0]][c+dir[k][1]]!=1 && mat[r+dir[k][0]][c+dir[k][1]]!=2){\\n                r+=dir[k][0];\\n                c+=dir[k][1];\\n                mat[r][c]=-1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] mat=new int[m][n];\\n        for(int[] d:walls){\\n            mat[d[0]][d[1]]=1;\\n        }\\n        for(int[] d:guards){\\n            mat[d[0]][d[1]]=2;\\n        }\\n        for(int[] d:guards){\\n            bfs(mat,d[0],d[1]);\\n        }\\n        int cnt=0;\\n        for(int[] d:mat){\\n            for(int num:d){\\n                if(num==0)cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    int[][] dir=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n    public void bfs(int[][] mat,int i,int j){\\n        mat[i][j]=2;\\n        for(int k=0;k<4;k++){\\n            int r=i,c=j;\\n            \\n            while(r+dir[k][0]>=0 && r+dir[k][0]<mat.length && c+dir[k][1]>=0 && c+dir[k][1]<mat[0].length && mat[r+dir[k][0]][c+dir[k][1]]!=1 && mat[r+dir[k][0]][c+dir[k][1]]!=2){\\n                r+=dir[k][0];\\n                c+=dir[k][1];\\n                mat[r][c]=-1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076774,
                "title": "java-solution-with-explanation",
                "content": "1. THe max ans can be m * n (no of cells)\\n2. We label guard cells  as  \\'G\\' and  walls cell as \\'W\\' and remove those from ans\\n3. THen we lable every other cell as \\'U\\' -> unguarded\\n4. Then we run loop four time for every direction - Left,Right,Top, Bottom.\\n5. In each loop for every cell we check if this cell is unnguarded and if the surronding of the cell is directly guard cell or indirectly guarded. If it is the case we remove this from our ans. \\n\\n **Here surronding is important. If we are checking for left then we should check only left and not worrying about what on it\\'s top or bottom or right and if it guarded by someone then we label it as \\'L\\'  (Symbol for Guarded by someone in left) resetting the character there if any bcz once we done for checking one direction it won\\'t matter for next direction**\\n\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        m = m;\\n        n = n;\\n        int ans = m * n;\\n        char[][] visisted = new char[m][n];\\n        for(int[] wall:walls){\\n            visisted[wall[0]][wall[1]] = \\'W\\';\\n            ans--;\\n        }\\n        for(int[] wall:guards){\\n            visisted[wall[0]][wall[1]] = \\'G\\';\\n            ans--;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                visisted[i][j] = \\'U\\';\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                if(j == 0) continue;\\n                \\n                if(visisted[i][j-1] == \\'G\\' || visisted[i][j-1] == \\'L\\'){\\n                    ans--;\\n                    visisted[i][j] = \\'L\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=n-1;j>=0;j--){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                if(j == n-1) continue;\\n                if(visisted[i][j+1] == \\'G\\' || visisted[i][j+1] == \\'R\\'){\\n                    if(visisted[i][j] == \\'U\\') ans--;\\n                    visisted[i][j] = \\'R\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visisted[j][i] == \\'G\\' || visisted[j][i] == \\'W\\') continue;\\n                if(j == 0) continue;\\n                if(visisted[j-1][i] == \\'G\\' || visisted[j-1][i] == \\'T\\'){\\n                    if(visisted[j][i] == \\'U\\') ans--;\\n                    visisted[j][i] = \\'T\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>=0;j--){\\n                if(visisted[j][i] == \\'G\\' || visisted[j][i] == \\'W\\') continue;\\n                if(j == m-1) continue;\\n                if(visisted[j+1][i] == \\'G\\' || visisted[j+1][i] == \\'B\\'){\\n                    if(visisted[j][i] == \\'U\\') ans--;\\n                    visisted[j][i] = \\'B\\';\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```\\n\\nPls upvote if helpful. Thanks\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        m = m;\\n        n = n;\\n        int ans = m * n;\\n        char[][] visisted = new char[m][n];\\n        for(int[] wall:walls){\\n            visisted[wall[0]][wall[1]] = \\'W\\';\\n            ans--;\\n        }\\n        for(int[] wall:guards){\\n            visisted[wall[0]][wall[1]] = \\'G\\';\\n            ans--;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                visisted[i][j] = \\'U\\';\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                if(j == 0) continue;\\n                \\n                if(visisted[i][j-1] == \\'G\\' || visisted[i][j-1] == \\'L\\'){\\n                    ans--;\\n                    visisted[i][j] = \\'L\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=n-1;j>=0;j--){\\n                if(visisted[i][j] == \\'G\\' || visisted[i][j] == \\'W\\') continue;\\n                if(j == n-1) continue;\\n                if(visisted[i][j+1] == \\'G\\' || visisted[i][j+1] == \\'R\\'){\\n                    if(visisted[i][j] == \\'U\\') ans--;\\n                    visisted[i][j] = \\'R\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(visisted[j][i] == \\'G\\' || visisted[j][i] == \\'W\\') continue;\\n                if(j == 0) continue;\\n                if(visisted[j-1][i] == \\'G\\' || visisted[j-1][i] == \\'T\\'){\\n                    if(visisted[j][i] == \\'U\\') ans--;\\n                    visisted[j][i] = \\'T\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>=0;j--){\\n                if(visisted[j][i] == \\'G\\' || visisted[j][i] == \\'W\\') continue;\\n                if(j == m-1) continue;\\n                if(visisted[j+1][i] == \\'G\\' || visisted[j+1][i] == \\'B\\'){\\n                    if(visisted[j][i] == \\'U\\') ans--;\\n                    visisted[j][i] = \\'B\\';\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023384,
                "title": "javascript-solution-with-explanation-o-m-n-time-space",
                "content": "**Main Idea**\\n1. Create the grid with m rows and n columns\\n2. Fill the grid with the given guards\\n3. Fill the grid with the given walls\\n4. Loop through the guards and move up, left, down, right from each guard marking their view keeping in mind that other guards can overwrite this view.\\n5. Count the free cells.\\n\\n```\\nvar countUnguarded = function(m, n, guards, walls) {\\n    let board = new Array(m).fill(0).map(_=>new Array(n).fill(0))\\n    \\n    // 0 - Empty\\n    // 1 - Guard\\n    // 2 - Wall\\n    // 3 - Guard view\\n    \\n    const DIRECTIONS = [\\n        [-1, 0],\\n        [0, 1],\\n        [1, 0],\\n        [0, -1]\\n    ]\\n    \\n    for(let [guardRow, guardCol] of guards) board[guardRow][guardCol] = 1\\n    \\n    for(let [wallRow, wallCol] of walls) board[wallRow][wallCol] = 2\\n    \\n    for(let [guardRow, guardCol] of guards){\\n        //Loop through row with the same col\\n        //Go down from current row\\n        let row = guardRow + 1\\n        while(row < m){\\n            //Stop if you encounter a wall or guard\\n            if(board[row][guardCol] == 1 || board[row][guardCol] == 2) break\\n            board[row][guardCol] = 3\\n            row++\\n        }\\n        //Go up from current row\\n        row = guardRow - 1\\n        while(row >= 0){\\n            if(board[row][guardCol] == 1 || board[row][guardCol] == 2) break\\n            board[row][guardCol] = 3\\n            row--\\n        }\\n        \\n        \\n        //Loop through col with the same row\\n        //Go right from current col\\n        let col = guardCol + 1\\n        while(col < n){\\n            if(board[guardRow][col] == 1 || board[guardRow][col] == 2) break\\n            board[guardRow][col] = 3\\n            col++\\n        }\\n        \\n        //Go left from current col\\n        col = guardCol - 1\\n        while(col >= 0){\\n            if(board[guardRow][col] == 1 || board[guardRow][col] == 2) break\\n            board[guardRow][col] = 3\\n            col--\\n        }\\n    }\\n    \\n\\t//Count the free cells\\n    let freeCount = 0\\n    for(let i = 0; i < m; i++){\\n        for(let j = 0; j < n; j++){\\n            if(board[i][j] == 0) freeCount++\\n        }\\n    }\\n    \\n    return freeCount\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar countUnguarded = function(m, n, guards, walls) {\\n    let board = new Array(m).fill(0).map(_=>new Array(n).fill(0))\\n    \\n    // 0 - Empty\\n    // 1 - Guard\\n    // 2 - Wall\\n    // 3 - Guard view\\n    \\n    const DIRECTIONS = [\\n        [-1, 0],\\n        [0, 1],\\n        [1, 0],\\n        [0, -1]\\n    ]\\n    \\n    for(let [guardRow, guardCol] of guards) board[guardRow][guardCol] = 1\\n    \\n    for(let [wallRow, wallCol] of walls) board[wallRow][wallCol] = 2\\n    \\n    for(let [guardRow, guardCol] of guards){\\n        //Loop through row with the same col\\n        //Go down from current row\\n        let row = guardRow + 1\\n        while(row < m){\\n            //Stop if you encounter a wall or guard\\n            if(board[row][guardCol] == 1 || board[row][guardCol] == 2) break\\n            board[row][guardCol] = 3\\n            row++\\n        }\\n        //Go up from current row\\n        row = guardRow - 1\\n        while(row >= 0){\\n            if(board[row][guardCol] == 1 || board[row][guardCol] == 2) break\\n            board[row][guardCol] = 3\\n            row--\\n        }\\n        \\n        \\n        //Loop through col with the same row\\n        //Go right from current col\\n        let col = guardCol + 1\\n        while(col < n){\\n            if(board[guardRow][col] == 1 || board[guardRow][col] == 2) break\\n            board[guardRow][col] = 3\\n            col++\\n        }\\n        \\n        //Go left from current col\\n        col = guardCol - 1\\n        while(col >= 0){\\n            if(board[guardRow][col] == 1 || board[guardRow][col] == 2) break\\n            board[guardRow][col] = 3\\n            col--\\n        }\\n    }\\n    \\n\\t//Count the free cells\\n    let freeCount = 0\\n    for(let i = 0; i < m; i++){\\n        for(let j = 0; j < n; j++){\\n            if(board[i][j] == 0) freeCount++\\n        }\\n    }\\n    \\n    return freeCount\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2011574,
                "title": "count-unguarded-cells-in-grid",
                "content": "class Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        \\n        \\n        vector<vector<int>> g(m,vector<int> (n,0));\\n        \\n        \\n        for(int i=0;i<guards.size();i++)\\n        {\\n            g[guards[i][0]][guards[i][1]]=2;\\n        }\\n        \\n         for(int i=0;i<walls.size();i++)\\n        {\\n            g[walls[i][0]][walls[i][1]]=2;\\n        }\\n        \\n          for(int i=0;i<guards.size();i++)\\n        {\\n            int x=guards[i][0],y=guards[i][1];\\n              \\n              \\n              for(int i=x+1;i<m;i++)\\n              {\\n                  if(g[i][y]==2)\\n                  {\\n                      break;\\n                  }\\n                  else\\n                  {\\n                      g[i][y]=1;\\n                  }\\n              }\\n              \\n              for(int i=x-1;i>=0;i--)\\n              {\\n                  if(g[i][y]==2)\\n                  {\\n                      break;\\n                  }\\n                  else\\n                  {\\n                      g[i][y]=1;\\n                  }\\n              }\\n              \\n              for(int i=y+1;i<n;i++)\\n              {\\n                  if(g[x][i]==2)\\n                  {\\n                      break;\\n                  }\\n                  else\\n                  {\\n                      g[x][i]=1;\\n                  }\\n              }\\n              \\n               for(int i=y-1;i>=0;i--)\\n              {\\n                  if(g[x][i]==2)\\n                  {\\n                      break;\\n                  }\\n                  else\\n                  {\\n                      g[x][i]=1;\\n                  }\\n              }\\n        }\\n        \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(g[i][j]==0)\\n                {\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        \\n        \\n        vector<vector<int>> g(m,vector<int> (n,0));\\n        \\n        \\n        for(int i=0;i<guards.size();i++)\\n        {\\n            g[guards[i][0]][guards[i][1]]=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1998683,
                "title": "python-3-o-m-n-simulation",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        # U -> Unguarded\\n        # O -> Wall/Guard position\\n        # G -> Guarded/Within sight of Guard\\n        grid = [[\\'U\\' for _ in range(n)] for _ in range(m)]\\n        \\n        def traverse_and_mark(x: int, y:int, di:Tuple[int, int]) -> None:\\n            r, c = di\\n            x += r\\n            y += c\\n            while x >= 0 and x < m and y >= 0 and y < n and grid[x][y] != \\'O\\':\\n                grid[x][y] = \\'G\\'\\n                x += r\\n                y += c\\n                \\n        for x, y in chain(guards, walls):\\n            grid[x][y] = \\'O\\'\\n            \\n        for x, y in guards:\\n            # left\\n            traverse_and_mark(x, y, (0, -1))\\n            # right\\n            traverse_and_mark(x, y, (0, 1))\\n            # up\\n            traverse_and_mark(x, y, (-1, 0))\\n            # down\\n            traverse_and_mark(x, y, (1, 0))\\n\\n        return list(chain(*grid)).count(\\'U\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        # U -> Unguarded\\n        # O -> Wall/Guard position\\n        # G -> Guarded/Within sight of Guard\\n        grid = [[\\'U\\' for _ in range(n)] for _ in range(m)]\\n        \\n        def traverse_and_mark(x: int, y:int, di:Tuple[int, int]) -> None:\\n            r, c = di\\n            x += r\\n            y += c\\n            while x >= 0 and x < m and y >= 0 and y < n and grid[x][y] != \\'O\\':\\n                grid[x][y] = \\'G\\'\\n                x += r\\n                y += c\\n                \\n        for x, y in chain(guards, walls):\\n            grid[x][y] = \\'O\\'\\n            \\n        for x, y in guards:\\n            # left\\n            traverse_and_mark(x, y, (0, -1))\\n            # right\\n            traverse_and_mark(x, y, (0, 1))\\n            # up\\n            traverse_and_mark(x, y, (-1, 0))\\n            # down\\n            traverse_and_mark(x, y, (1, 0))\\n\\n        return list(chain(*grid)).count(\\'U\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998018,
                "title": "traverse-rows-l-r-r-l-and-cols-u-d-d-p",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int res=m*n-walls.length-guards.length;\\n        int a[][]=new int[m][n];\\n        for(int i[]:walls) a[i[0]][i[1]]=1;\\n        for(int i[]:guards) a[i[0]][i[1]]=2;\\n        for(int i=0;i<m;i++){\\n            int prev=0;\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]==1 || a[i][j]==2) prev=a[i][j];\\n                else if(a[i][j]==0 && prev==2){\\n                     a[i][j]=3;\\n                     res--;\\n                }\\n            }\\n            prev=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(a[i][j]==1 || a[i][j]==2) prev=a[i][j];\\n                else if(a[i][j]==0 && prev==2){\\n                        a[i][j]=3;\\n                        res--;\\n                }\\n            } \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int prev=0;\\n            for(int j=0;j<m;j++){\\n                if(a[j][i]==1 || a[j][i]==2) prev=a[j][i];\\n                else if(a[j][i]==0 && prev==2){\\n                     a[j][i]=3;\\n                     res--;\\n                }\\n            }\\n            prev=0;\\n            for(int j=m-1;j>=0;j--){\\n                if(a[j][i]==1 || a[j][i]==2) prev=a[j][i];\\n                else if(a[j][i]==0 && prev==2){\\n                    a[j][i]=3;\\n                    res--;\\n                }\\n            }   \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int res=m*n-walls.length-guards.length;\\n        int a[][]=new int[m][n];\\n        for(int i[]:walls) a[i[0]][i[1]]=1;\\n        for(int i[]:guards) a[i[0]][i[1]]=2;\\n        for(int i=0;i<m;i++){\\n            int prev=0;\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]==1 || a[i][j]==2) prev=a[i][j];\\n                else if(a[i][j]==0 && prev==2){\\n                     a[i][j]=3;\\n                     res--;\\n                }\\n            }\\n            prev=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(a[i][j]==1 || a[i][j]==2) prev=a[i][j];\\n                else if(a[i][j]==0 && prev==2){\\n                        a[i][j]=3;\\n                        res--;\\n                }\\n            } \\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int prev=0;\\n            for(int j=0;j<m;j++){\\n                if(a[j][i]==1 || a[j][i]==2) prev=a[j][i];\\n                else if(a[j][i]==0 && prev==2){\\n                     a[j][i]=3;\\n                     res--;\\n                }\\n            }\\n            prev=0;\\n            for(int j=m-1;j>=0;j--){\\n                if(a[j][i]==1 || a[j][i]==2) prev=a[j][i];\\n                else if(a[j][i]==0 && prev==2){\\n                    a[j][i]=3;\\n                    res--;\\n                }\\n            }   \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997129,
                "title": "python-easy-solution",
                "content": "All i did is just made a two dimensional array in which i put the walls already and just track the coordinate whether it\\'s left right up or down is already visited or not . if not then just traverse through all it\\'s possible left right up and down positions.\\nsorry for bad english.\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, g: List[List[int]], w: List[List[int]]) -> int:\\n        ans = []\\n        arr=[[[-1,-1]]*(n) for i in range(m)]\\n        for i,j in w:\\n            arr[i][j] = [\"w\",\"w\"]\\n        g.sort()\\n        for i,j in g:\\n            p,q = i,j\\n            r,s = i,j\\n            while(p<m and arr[p][j][0]!=\"w\" and arr[p][j][1]!=\"r\"):\\n                arr[p][j] = [1,\"r\"]\\n                p+=1\\n            while(q<n and arr[i][q][0]!=\"w\" and arr[i][q][1]!=\"d\"):\\n                arr[i][q] = [1,\"d\"]\\n                q+=1\\n            while(r>=0 and arr[r][j][0]!=\"w\" and arr[r][j][1]!=\"l\"):\\n                arr[r][j] = [1,\"l\"]\\n                r-=1\\n            while(s>=0 and arr[i][s][0]!=\"w\" and arr[i][s][1]!=\"u\"):\\n                arr[i][s] = [1,\"u\"]\\n                s-=1\\n        ans=0\\n        for i in range(m):\\n            for j in range(n):\\n                if arr[i][j]==[-1,-1]:\\n                    ans+=1\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "All i did is just made a two dimensional array in which i put the walls already and just track the coordinate whether it\\'s left right up or down is already visited or not . if not then just traverse through all it\\'s possible left right up and down positions.\\nsorry for bad english.\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, g: List[List[int]], w: List[List[int]]) -> int:\\n        ans = []\\n        arr=[[[-1,-1]]*(n) for i in range(m)]\\n        for i,j in w:\\n            arr[i][j] = [\"w\",\"w\"]\\n        g.sort()\\n        for i,j in g:\\n            p,q = i,j\\n            r,s = i,j\\n            while(p<m and arr[p][j][0]!=\"w\" and arr[p][j][1]!=\"r\"):\\n                arr[p][j] = [1,\"r\"]\\n                p+=1\\n            while(q<n and arr[i][q][0]!=\"w\" and arr[i][q][1]!=\"d\"):\\n                arr[i][q] = [1,\"d\"]\\n                q+=1\\n            while(r>=0 and arr[r][j][0]!=\"w\" and arr[r][j][1]!=\"l\"):\\n                arr[r][j] = [1,\"l\"]\\n                r-=1\\n            while(s>=0 and arr[i][s][0]!=\"w\" and arr[i][s][1]!=\"u\"):\\n                arr[i][s] = [1,\"u\"]\\n                s-=1\\n        ans=0\\n        for i in range(m):\\n            for j in range(n):\\n                if arr[i][j]==[-1,-1]:\\n                    ans+=1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1995806,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        \\n        int[][] result = new int[m][n];\\n        //guards = 1, walls 2 // checked = 3\\n        \\n        for(int i=0;i<guards.length;i++)\\n            result[guards[i][0]][guards[i][1]] = 1;\\n        \\n        \\n        for(int i=0;i<walls.length;i++)\\n            result[walls[i][0]][walls[i][1]] =2;\\n        \\n        \\n        for(int i = 0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(result[i][j]==1)guard(result, i, j,m,n);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0}\\n        }\\n        \\n        int count =0;\\n        for(int i = 0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(result[i][j] ==0) count++;\\n                \\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public static void guard(int[][] result, int row, int col,int m,int n){\\n        \\n        int i = row;\\n        //check up\\n        while(i >0 ){\\n            i--;\\n            if(result[i][col] == 2 || result[i][col] == 1) break;\\n            result[i][col] =3;\\n            \\n        }\\n        \\n        //check down\\n        i=row;\\n        \\n        while(i< m-1){\\n            i++;\\n            if(result[i][col]==2 || result[i][col] == 1) break;\\n            result[i][col] = 3;\\n        }\\n \\xA0 \\xA0 \\xA0 \\n \\xA0 \\xA0 \\xA0 \\xA0//check left\\n \\xA0 \\xA0 \\xA0 \\xA0int j = col;\\n \\xA0 \\xA0 \\xA0 \\xA0while(j>0){\\n            j--;\\n            if(result[row][j]==2 || result[row][j] == 1) break;\\n            result[row][j] = 3;\\n        }\\n        \\n        //check right\\n        j = col;\\n        while(j < n-1){\\n            j++;\\n            if(result[row][j]==2 || result[row][j] == 1) break;\\n            result[row][j] = 3;\\n        }      \\n            \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        \\n        int[][] result = new int[m][n];\\n        //guards = 1, walls 2 // checked = 3\\n        \\n        for(int i=0;i<guards.length;i++)\\n            result[guards[i][0]][guards[i][1]] = 1;\\n        \\n        \\n        for(int i=0;i<walls.length;i++)\\n            result[walls[i][0]][walls[i][1]] =2;\\n        \\n        \\n        for(int i = 0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(result[i][j]==1)guard(result, i, j,m,n);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0}\\n        }\\n        \\n        int count =0;\\n        for(int i = 0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(result[i][j] ==0) count++;\\n                \\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    public static void guard(int[][] result, int row, int col,int m,int n){\\n        \\n        int i = row;\\n        //check up\\n        while(i >0 ){\\n            i--;\\n            if(result[i][col] == 2 || result[i][col] == 1) break;\\n            result[i][col] =3;\\n            \\n        }\\n        \\n        //check down\\n        i=row;\\n        \\n        while(i< m-1){\\n            i++;\\n            if(result[i][col]==2 || result[i][col] == 1) break;\\n            result[i][col] = 3;\\n        }\\n \\xA0 \\xA0 \\xA0 \\n \\xA0 \\xA0 \\xA0 \\xA0//check left\\n \\xA0 \\xA0 \\xA0 \\xA0int j = col;\\n \\xA0 \\xA0 \\xA0 \\xA0while(j>0){\\n            j--;\\n            if(result[row][j]==2 || result[row][j] == 1) break;\\n            result[row][j] = 3;\\n        }\\n        \\n        //check right\\n        j = col;\\n        while(j < n-1){\\n            j++;\\n            if(result[row][j]==2 || result[row][j] == 1) break;\\n            result[row][j] = 3;\\n        }      \\n            \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995296,
                "title": "easy-c-code-beats-100-tc-memory",
                "content": "```\\n int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n\\t\\t  int gr[m][n];\\n        memset(gr,0,sizeof(gr));\\n        for(auto& x : walls){\\n            gr[x[0]][x[1]] = -2;\\n        }\\n        for(auto& x : guards){\\n            gr[x[0]][x[1]] = -1;\\n        }\\n     \\n        for(int i = 0 ; i < m ; i++){\\n            int count = 1;\\n            for(int j = 0 ;j < n ; j++){\\n                if(gr[i][j] == -2){\\n                    count = 1;\\n                    continue;\\n                } \\n                if(gr[i][j] == -1) count = 0;\\n                gr[i][j]+=count;\\n            }\\n            count = 1;\\n            for(int j = n-1 ;j >= 0 ; j--){\\n                 if(gr[i][j] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[i][j] == -1) count = 0;\\n                gr[i][j]+=count;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int count = 1;\\n            for(int j = 0 ;j < m ; j++){\\n                 if(gr[j][i] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[j][i] == -1) count = 0;\\n                gr[j][i]+=count;\\n            }\\n            count = 1;\\n            for(int j = m-1 ;j >= 0 ; j--){\\n                 if(gr[j][i] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[j][i] == -1) count = 0;\\n                gr[j][i]+=count;\\n            }\\n        }\\n    \\n       \\n        int ans = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ;j++) ans+=(gr[i][j] == 4);\\n        }\\n        return ans;\\n            \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n\\t\\t  int gr[m][n];\\n        memset(gr,0,sizeof(gr));\\n        for(auto& x : walls){\\n            gr[x[0]][x[1]] = -2;\\n        }\\n        for(auto& x : guards){\\n            gr[x[0]][x[1]] = -1;\\n        }\\n     \\n        for(int i = 0 ; i < m ; i++){\\n            int count = 1;\\n            for(int j = 0 ;j < n ; j++){\\n                if(gr[i][j] == -2){\\n                    count = 1;\\n                    continue;\\n                } \\n                if(gr[i][j] == -1) count = 0;\\n                gr[i][j]+=count;\\n            }\\n            count = 1;\\n            for(int j = n-1 ;j >= 0 ; j--){\\n                 if(gr[i][j] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[i][j] == -1) count = 0;\\n                gr[i][j]+=count;\\n            }\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int count = 1;\\n            for(int j = 0 ;j < m ; j++){\\n                 if(gr[j][i] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[j][i] == -1) count = 0;\\n                gr[j][i]+=count;\\n            }\\n            count = 1;\\n            for(int j = m-1 ;j >= 0 ; j--){\\n                 if(gr[j][i] == -2){\\n                    count = 1;\\n                    continue;\\n                }\\n                if(gr[j][i] == -1) count = 0;\\n                gr[j][i]+=count;\\n            }\\n        }\\n    \\n       \\n        int ans = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ;j++) ans+=(gr[i][j] == 4);\\n        }\\n        return ans;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995217,
                "title": "c-hash-map-binary-search-accepted",
                "content": "Time complexity - ```O(M*N*log(max(M,N)))```\\nSpace complexity - ```O(M*N)```\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        unordered_map<int, vector<int>> guardsRowMap, wallsRowMap, guardsColMap, wallsColMap;\\n        \\n        for (vector<int> guard : guards) {\\n            guardsRowMap[guard[0]].push_back(guard[1]);\\n            guardsColMap[guard[1]].push_back(guard[0]);\\n        }\\n        for (vector<int> wall : walls) {\\n            wallsRowMap[wall[0]].push_back(wall[1]);\\n            wallsColMap[wall[1]].push_back(wall[0]);\\n        }\\n        \\n        for (auto& item : guardsRowMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : wallsRowMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : guardsColMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : wallsColMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        \\n        \\n        int count = 0;\\n        for (int row=0; row<m; row++) {\\n            for (int col=0; col<n; col++) {\\n                \\n                int guard_idx, wall_idx;\\n                \\n                guard_idx = lower_bound(guardsColMap[col].begin(), guardsColMap[col].end(), row) - guardsColMap[col].begin();\\n                if (guard_idx != guardsColMap[col].size() and guardsColMap[col][guard_idx] == row)    continue;\\n                \\n                wall_idx = lower_bound(wallsColMap[col].begin(), wallsColMap[col].end(), row) - wallsColMap[col].begin();\\n                if (wall_idx != wallsColMap[col].size() and wallsColMap[col][wall_idx] == row)  continue;\\n                \\n                if (guard_idx != 0 and \\n                    (wall_idx == 0 or guardsColMap[col][guard_idx-1] > wallsColMap[col][wall_idx-1]))\\n                    continue;\\n                if (guard_idx != guardsColMap[col].size() and \\n                    (wall_idx == wallsColMap[col].size() or guardsColMap[col][guard_idx] < wallsColMap[col][wall_idx]))\\n                    continue;\\n                \\n                guard_idx = lower_bound(guardsRowMap[row].begin(), guardsRowMap[row].end(), col) - guardsRowMap[row].begin();\\n                wall_idx = lower_bound(wallsRowMap[row].begin(), wallsRowMap[row].end(), col) - wallsRowMap[row].begin();\\n                \\n                if (guard_idx != 0 and \\n                    (wall_idx == 0 or guardsRowMap[row][guard_idx-1] > wallsRowMap[row][wall_idx-1]))\\n                    continue;\\n                if (guard_idx != guardsRowMap[row].size() and \\n                    (wall_idx == wallsRowMap[row].size() or guardsRowMap[row][guard_idx] < wallsRowMap[row][wall_idx]))\\n                    continue;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```O(M*N*log(max(M,N)))```\n```O(M*N)```\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        unordered_map<int, vector<int>> guardsRowMap, wallsRowMap, guardsColMap, wallsColMap;\\n        \\n        for (vector<int> guard : guards) {\\n            guardsRowMap[guard[0]].push_back(guard[1]);\\n            guardsColMap[guard[1]].push_back(guard[0]);\\n        }\\n        for (vector<int> wall : walls) {\\n            wallsRowMap[wall[0]].push_back(wall[1]);\\n            wallsColMap[wall[1]].push_back(wall[0]);\\n        }\\n        \\n        for (auto& item : guardsRowMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : wallsRowMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : guardsColMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        for (auto& item : wallsColMap) {\\n            sort(item.second.begin(), item.second.end());\\n        }\\n        \\n        \\n        int count = 0;\\n        for (int row=0; row<m; row++) {\\n            for (int col=0; col<n; col++) {\\n                \\n                int guard_idx, wall_idx;\\n                \\n                guard_idx = lower_bound(guardsColMap[col].begin(), guardsColMap[col].end(), row) - guardsColMap[col].begin();\\n                if (guard_idx != guardsColMap[col].size() and guardsColMap[col][guard_idx] == row)    continue;\\n                \\n                wall_idx = lower_bound(wallsColMap[col].begin(), wallsColMap[col].end(), row) - wallsColMap[col].begin();\\n                if (wall_idx != wallsColMap[col].size() and wallsColMap[col][wall_idx] == row)  continue;\\n                \\n                if (guard_idx != 0 and \\n                    (wall_idx == 0 or guardsColMap[col][guard_idx-1] > wallsColMap[col][wall_idx-1]))\\n                    continue;\\n                if (guard_idx != guardsColMap[col].size() and \\n                    (wall_idx == wallsColMap[col].size() or guardsColMap[col][guard_idx] < wallsColMap[col][wall_idx]))\\n                    continue;\\n                \\n                guard_idx = lower_bound(guardsRowMap[row].begin(), guardsRowMap[row].end(), col) - guardsRowMap[row].begin();\\n                wall_idx = lower_bound(wallsRowMap[row].begin(), wallsRowMap[row].end(), col) - wallsRowMap[row].begin();\\n                \\n                if (guard_idx != 0 and \\n                    (wall_idx == 0 or guardsRowMap[row][guard_idx-1] > wallsRowMap[row][wall_idx-1]))\\n                    continue;\\n                if (guard_idx != guardsRowMap[row].size() and \\n                    (wall_idx == wallsRowMap[row].size() or guardsRowMap[row][guard_idx] < wallsRowMap[row][wall_idx]))\\n                    continue;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995141,
                "title": "c-o-n-27-lines-simple-code",
                "content": "In this algorithm every cell will be travel at most 4 times.\\nSo, the time complexity is 4 * N  (assume N = m * n here)\\n\\n```C++\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int cnt=0; //the counter of the number of guarded place\\n        vector<vector<int>> grid = vector<vector<int>>(m, vector<int>(n, 0));\\n        //no-guarded 0, guarded 1.  , guards 2, walls 3, \\n        for(auto&g : guards) grid[g[0]][g[1]] = 2;\\n        for(auto&w : walls) grid[w[0]][w[1]] = 3;\\n        \\n        //configure guarded place\\n        vector<vector<int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n        for(auto&g: guards) {            \\n            for(auto& dir:dirs) {\\n                int i = g[0], j = g[1];       \\n                while(true) {\\n                    i += dir[0];\\n                    j += dir[1];                \\n                    if(i<0 || i>=m || j<0 || j>=n || grid[i][j]>1) break;\\n                    cnt += (grid[i][j] == 0);\\n                    grid[i][j] = 1;\\n                }                \\n            }\\n        }\\n        return m*n-cnt-guards.size()-walls.size();        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int cnt=0; //the counter of the number of guarded place\\n        vector<vector<int>> grid = vector<vector<int>>(m, vector<int>(n, 0));\\n        //no-guarded 0, guarded 1.  , guards 2, walls 3, \\n        for(auto&g : guards) grid[g[0]][g[1]] = 2;\\n        for(auto&w : walls) grid[w[0]][w[1]] = 3;\\n        \\n        //configure guarded place\\n        vector<vector<int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};\\n        for(auto&g: guards) {            \\n            for(auto& dir:dirs) {\\n                int i = g[0], j = g[1];       \\n                while(true) {\\n                    i += dir[0];\\n                    j += dir[1];                \\n                    if(i<0 || i>=m || j<0 || j>=n || grid[i][j]>1) break;\\n                    cnt += (grid[i][j] == 0);\\n                    grid[i][j] = 1;\\n                }                \\n            }\\n        }\\n        return m*n-cnt-guards.size()-walls.size();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995124,
                "title": "c-explanation-with-code",
                "content": "here we will first intialize the walls and then guards.Then we will check in all direction in matrix if there is another guard or wall present .if yes then we will stop else\\nwe intialize other the column which are gaurded with some value.\\n```\\nclass Solution {\\npublic:\\nint countUnguarded(int m, int n, vector& guards, vector& walls) {vector matrix(m,vector(n,0));int x=0;\\n\\n//Intialize walls\\nfor(int i=0;i<walls.size();i++)\\n{\\nmatrix[walls[i][0]][walls[i][1]]=2;\\n}\\n//Intialize guards\\nfor(int i=0;i<guards.size();i++)\\n{\\nmatrix[guards[i][0]][guards[i][1]]=1;\\n}\\n//Now check for walls or other guards in all direction\\nfor(int i=0;i<guards.size();i++)\\n{ //Move right\\nfor(int j=guards[i][1]+1;j<n;j++)\\n{if(matrix[guards[i][0]][j]==2 ||matrix[guards[i][0]][j]==1 )break;\\nmatrix[guards[i][0]][j]=5;\\n}\\n//Move left\\nfor(int j=guards[i][1]-1;j>=0;j--)\\n{if(matrix[guards[i][0]][j]==2||matrix[guards[i][0]][j]==1)break;\\nmatrix[guards[i][0]][j]=5;\\n}\\n//Move down\\nfor(int j=guards[i][0]+1;j<m;j++)\\n{if( matrix[j][guards[i][1]]==2 || matrix[j][guards[i][1]]==1)break;\\nmatrix[j][guards[i][1]]=5;\\n}\\n//Move up\\nfor(int j=guards[i][0]-1;j>=0;j--)\\n{if( matrix[j][guards[i][1]]==2 || matrix[j][guards[i][1]]==1)break;\\nmatrix[j][guards[i][1]]=5;\\n}\\n\\n}\\nfor(int i=0;i<m;i++)\\n{\\nfor(int j=0;j<n;j++)\\n{//Print matrix for better understanding.\\n//cout<<matrix[i][j]<<\" \";\\nif(matrix[i][j]==0)x++;\\n}cout<<endl;\\n}\\nreturn x;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countUnguarded(int m, int n, vector& guards, vector& walls) {vector matrix(m,vector(n,0));int x=0;\\n\\n//Intialize walls\\nfor(int i=0;i<walls.size();i++)\\n{\\nmatrix[walls[i][0]][walls[i][1]]=2;\\n}\\n//Intialize guards\\nfor(int i=0;i<guards.size();i++)\\n{\\nmatrix[guards[i][0]][guards[i][1]]=1;\\n}\\n//Now check for walls or other guards in all direction\\nfor(int i=0;i<guards.size();i++)\\n{ //Move right\\nfor(int j=guards[i][1]+1;j<n;j++)\\n{if(matrix[guards[i][0]][j]==2 ||matrix[guards[i][0]][j]==1 )break;\\nmatrix[guards[i][0]][j]=5;\\n}\\n//Move left\\nfor(int j=guards[i][1]-1;j>=0;j--)\\n{if(matrix[guards[i][0]][j]==2||matrix[guards[i][0]][j]==1)break;\\nmatrix[guards[i][0]][j]=5;\\n}\\n//Move down\\nfor(int j=guards[i][0]+1;j<m;j++)\\n{if( matrix[j][guards[i][1]]==2 || matrix[j][guards[i][1]]==1)break;\\nmatrix[j][guards[i][1]]=5;\\n}\\n//Move up\\nfor(int j=guards[i][0]-1;j>=0;j--)\\n{if( matrix[j][guards[i][1]]==2 || matrix[j][guards[i][1]]==1)break;\\nmatrix[j][guards[i][1]]=5;\\n}\\n\\n}\\nfor(int i=0;i<m;i++)\\n{\\nfor(int j=0;j<n;j++)\\n{//Print matrix for better understanding.\\n//cout<<matrix[i][j]<<\" \";\\nif(matrix[i][j]==0)x++;\\n}cout<<endl;\\n}\\nreturn x;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1995090,
                "title": "c-easy-dfs-in-4-directions-100-faster",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\nclass Solution {\\n    bool valid(int i,int j,int &n,int &m)\\n    {\\n        return i>=0&&j>=0&&i<n&&j<m;\\n    }\\npublic:\\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<char>>grid(n,vector<char>(m,\\'.\\'));\\n        \\n        for(auto &w:walls)\\n            grid[w[0]][w[1]]=\\'b\\';\\n        \\n        for(auto &g:guards)\\n            grid[g[0]][g[1]]=\\'b\\';\\n        \\n        int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto &g:guards)\\n        {\\n            int i=g[0],j=g[1];\\n            for(int k=0;k<4;k++)\\n            {\\n                i=g[0]+dir[k][0];\\n                j=g[1]+dir[k][1];\\n                while(valid(i,j,n,m)&&grid[i][j]!=\\'b\\')\\n                {\\n                    grid[i][j]=\\'m\\';\\n                    i+=dir[k][0];\\n                    j+=dir[k][1];\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(auto &x:grid)\\n        {\\n            for(auto &y:x)\\n            {\\n               res+=(y==\\'.\\'); \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool valid(int i,int j,int &n,int &m)\\n    {\\n        return i>=0&&j>=0&&i<n&&j<m;\\n    }\\npublic:\\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<char>>grid(n,vector<char>(m,\\'.\\'));\\n        \\n        for(auto &w:walls)\\n            grid[w[0]][w[1]]=\\'b\\';\\n        \\n        for(auto &g:guards)\\n            grid[g[0]][g[1]]=\\'b\\';\\n        \\n        int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n        for(auto &g:guards)\\n        {\\n            int i=g[0],j=g[1];\\n            for(int k=0;k<4;k++)\\n            {\\n                i=g[0]+dir[k][0];\\n                j=g[1]+dir[k][1];\\n                while(valid(i,j,n,m)&&grid[i][j]!=\\'b\\')\\n                {\\n                    grid[i][j]=\\'m\\';\\n                    i+=dir[k][0];\\n                    j+=dir[k][1];\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(auto &x:grid)\\n        {\\n            for(auto &y:x)\\n            {\\n               res+=(y==\\'.\\'); \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995079,
                "title": "python-beats-100-very-concise",
                "content": "![image](https://assets.leetcode.com/users/images/b18687df-bcf9-46b8-8d0f-ba2493928aea_1651340009.2805262.png)\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        nums = [[1]*n for i in range(m)]\\n        for i , j in walls+guards:\\n            nums[i][j] = 0\\n            \\n        dir = [(1 , 0) , (-1 , 0) , (0 , 1) , (0 , -1)]\\n        for di , dj in guards:\\n            #nums[di][dj] = 0\\n            \\n            for x , y in dir:\\n                i = di\\n                j = dj\\n                while 0 <= i+x < m and 0 <= j+y < n and nums[i+x][j+y] != 0:\\n                    i +=x\\n                    j +=y\\n                    nums[i][j] = 2\\n                    \\n        return sum(1 for i in range(m) for j in range(n) if nums[i][j] == 1) \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\n\\n\\n\\n\\n\\n\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        nums = [[1]*n for i in range(m)]\\n        for i , j in walls+guards:\\n            nums[i][j] = 0\\n            \\n        dir = [(1 , 0) , (-1 , 0) , (0 , 1) , (0 , -1)]\\n        for di , dj in guards:\\n            #nums[di][dj] = 0\\n            \\n            for x , y in dir:\\n                i = di\\n                j = dj\\n                while 0 <= i+x < m and 0 <= j+y < n and nums[i+x][j+y] != 0:\\n                    i +=x\\n                    j +=y\\n                    nums[i][j] = 2\\n                    \\n        return sum(1 for i in range(m) for j in range(n) if nums[i][j] == 1) \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994790,
                "title": "java-100-fastest-two-treemaps-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        // 1 -> guard, 2 -> wall\\n        int count = 0;\\n        TreeMap<Integer, Integer>[] row = new TreeMap[m];\\n        TreeMap<Integer, Integer>[] col = new TreeMap[n];\\n        Set<List<Integer>> set = new HashSet<>();\\n        \\n        for(int i = 0; i < m; i++) row[i] = new TreeMap<>();\\n        for(int i = 0; i < n; i++) col[i] = new TreeMap<>();\\n        \\n        for(int[] i : guards) {\\n            row[i[0]].put(i[1], 1);  \\n            col[i[1]].put(i[0], 1);\\n        }\\n        \\n        for(int[] i : walls) {\\n            row[i[0]].put(i[1], 2);\\n            col[i[1]].put(i[0], 2);\\n            set.add(List.of(i[0], i[1]));\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(set.contains(List.of(i, j))) continue;\\n                if((row[i].floorEntry(j) == null || row[i].floorEntry(j).getValue() == 2) &&\\n                    (row[i].ceilingEntry(j) == null || row[i].ceilingEntry(j).getValue() == 2) &&\\n                    (col[j].floorEntry(i) == null || col[j].floorEntry(i).getValue() == 2) &&\\n                   (col[j].ceilingEntry(i) == null || col[j].ceilingEntry(i).getValue() == 2))\\n                       count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        // 1 -> guard, 2 -> wall\\n        int count = 0;\\n        TreeMap<Integer, Integer>[] row = new TreeMap[m];\\n        TreeMap<Integer, Integer>[] col = new TreeMap[n];\\n        Set<List<Integer>> set = new HashSet<>();\\n        \\n        for(int i = 0; i < m; i++) row[i] = new TreeMap<>();\\n        for(int i = 0; i < n; i++) col[i] = new TreeMap<>();\\n        \\n        for(int[] i : guards) {\\n            row[i[0]].put(i[1], 1);  \\n            col[i[1]].put(i[0], 1);\\n        }\\n        \\n        for(int[] i : walls) {\\n            row[i[0]].put(i[1], 2);\\n            col[i[1]].put(i[0], 2);\\n            set.add(List.of(i[0], i[1]));\\n        }\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(set.contains(List.of(i, j))) continue;\\n                if((row[i].floorEntry(j) == null || row[i].floorEntry(j).getValue() == 2) &&\\n                    (row[i].ceilingEntry(j) == null || row[i].ceilingEntry(j).getValue() == 2) &&\\n                    (col[j].floorEntry(i) == null || col[j].floorEntry(i).getValue() == 2) &&\\n                   (col[j].ceilingEntry(i) == null || col[j].ceilingEntry(i).getValue() == 2))\\n                       count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994773,
                "title": "java-brute-force-solution",
                "content": "**Explanation**\\n\\n* We first place the walls and guards in our answer array with -1 for walls and 1 for guards. \\n* After that we traverse in all four directions for every guard and keep marking the traversed positions as 2 until we either encounter a guard or a wall.\\n* In the end, traverse the answer array and count the 0\\'s, the number of 0\\'s is the answer.\\n\\n```\\npublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] ans = new int[m][n];\\n        int x = 0, y = 0;\\n        \\n        for (int[] wall : walls) {\\n            x = wall[0];\\n            y = wall[1];\\n            \\n            ans[x][y] = -1;  \\n        }\\n    \\n        for (int[] grd : guards) {\\n            x = grd[0];\\n            y = grd[1];\\n            \\n            ans[x][y] = 1;\\n        }\\n        \\n        for (int[] grd : guards) {\\n            x = grd[0];\\n            y = grd[1];\\n            \\n            for (int i = y + 1; i < n; i++) {\\n                if (ans[x][i] == -1 || ans[x][i] == 1) {\\n                    break;\\n                }\\n                ans[x][i] = 2;\\n            }\\n            \\n            for (int i = x + 1; i < m; i++) {\\n                if (ans[i][y] == -1 || ans[i][y] == 1) {\\n                    break;\\n                }\\n                ans[i][y] = 2;\\n            }\\n            \\n            for (int i = y - 1; i >= 0; i--) {\\n                if (ans[x][i] == -1 || ans[x][i] == 1) {\\n                    break;\\n                }\\n                ans[x][i] = 2;\\n            }\\n            \\n            for (int i = x - 1; i >= 0; i--) {\\n                if (ans[i][y] == -1 || ans[i][y] == 1) {\\n                    break;\\n                }\\n                ans[i][y] = 2;\\n            }\\n        }\\n        \\n        int c = 0;\\n        \\n        for (int[] arr : ans) {\\n            for (int i : arr) {\\n                if (i == 0) {\\n                    c++;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```\\n\\n**Bonus Tip**\\n* Don\\'t try to place guards while solving for every guard, do it before only, to avoid TLE\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] ans = new int[m][n];\\n        int x = 0, y = 0;\\n        \\n        for (int[] wall : walls) {\\n            x = wall[0];\\n            y = wall[1];\\n            \\n            ans[x][y] = -1;  \\n        }\\n    \\n        for (int[] grd : guards) {\\n            x = grd[0];\\n            y = grd[1];\\n            \\n            ans[x][y] = 1;\\n        }\\n        \\n        for (int[] grd : guards) {\\n            x = grd[0];\\n            y = grd[1];\\n            \\n            for (int i = y + 1; i < n; i++) {\\n                if (ans[x][i] == -1 || ans[x][i] == 1) {\\n                    break;\\n                }\\n                ans[x][i] = 2;\\n            }\\n            \\n            for (int i = x + 1; i < m; i++) {\\n                if (ans[i][y] == -1 || ans[i][y] == 1) {\\n                    break;\\n                }\\n                ans[i][y] = 2;\\n            }\\n            \\n            for (int i = y - 1; i >= 0; i--) {\\n                if (ans[x][i] == -1 || ans[x][i] == 1) {\\n                    break;\\n                }\\n                ans[x][i] = 2;\\n            }\\n            \\n            for (int i = x - 1; i >= 0; i--) {\\n                if (ans[i][y] == -1 || ans[i][y] == 1) {\\n                    break;\\n                }\\n                ans[i][y] = 2;\\n            }\\n        }\\n        \\n        int c = 0;\\n        \\n        for (int[] arr : ans) {\\n            for (int i : arr) {\\n                if (i == 0) {\\n                    c++;\\n                }\\n            }\\n        }\\n        \\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994764,
                "title": "found-something-new-about-submission-brute-force-simplest-solution",
                "content": "**Approach**\\nConsidering every guard position as strarting cell. Iterate in all four directions/moves(up, right, down, left) on that cell following given constraints i.e. if any wall appears then don\\'t iterate further.\\n\\n**Update**\\nI got AC in same solution by a small change.\\n\\nInstead of using two unordered_map (umm and gmm) I have used only one and it got accepted ;)\\n\\n**Initial Doubt**\\nCan anyone expain why this solution giving TLE for large test cases?\\n\\nThis code passed 37/47 testcases.\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        using pi = pair<int, int>;\\n        vector<vector<int>> visited(m, vector<int>(n, 1));\\n    \\n        unordered_map<int, unordered_map<int, int>> umm, gmm;\\n        \\n        for(auto x: walls){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        for(auto x: guards){\\n            gmm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        \\n        for(auto guard: guards) {\\n            int gx = guard[0];\\n            int gy = guard[1];\\n            \\n                // visited[gx][gy] = -1;\\n                \\n                \\n                // moving up\\n                for(int upx = gx-1; upx >= 0; upx--) {\\n                    if(umm[upx][gy] == 1 or gmm[upx][gy] == 1) {\\n                        break;\\n                    }\\n                    visited[upx][gy] = -1;\\n                }\\n                \\n                // right\\n                for(int rx = gy+1; rx <n; ++rx){\\n                    if(umm[gx][rx] == 1 or gmm[gx][rx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][rx] = -1;\\n                }\\n                \\n                // down\\n                for(int dx = gx+1; dx<m; dx++){\\n                    if(umm[dx][gy] == 1 or gmm[dx][gy] == 1){\\n                        break;\\n                    }\\n                    visited[dx][gy] = -1;\\n                }\\n                \\n                // left\\n                for(int lx = gy - 1; lx >= 0; lx--) {\\n                    if(umm[gx][lx] == 1 or gmm[gx][lx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][lx] = -1;\\n                }\\n                \\n                \\n        }\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<n; ++j) {\\n                if(visited[i][j] == 1){\\n                    cnt++;\\n                } \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\n\\nIn the contest my submission passed 32/47 testcases while second submission passed 37/47 testcases.\\nThe difference between two is, I have console output some values for debug in former which I removed in second submission.\\n\\nAlso, after clubbing two unordered_map into I got AC.\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        using pi = pair<int, int>;\\n        vector<vector<int>> visited(m, vector<int>(n, 1));\\n        unordered_map<int, unordered_map<int, int>> umm;\\n        \\n        for(auto x: walls){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        for(auto x: guards){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        \\n        for(auto guard: guards) {\\n            int gx = guard[0];\\n            int gy = guard[1];\\n            \\n               \\n                \\n                // moving up\\n                for(int upx = gx-1; upx >= 0; upx--) {\\n                    if(umm[upx][gy] == 1) {\\n                        break;\\n                    }\\n                    visited[upx][gy] = -1;\\n                }\\n                \\n                // right\\n                for(int rx = gy+1; rx <n; ++rx){\\n                    if(umm[gx][rx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][rx] = -1;\\n                }\\n                \\n                // down\\n                for(int dx = gx+1; dx<m; dx++){\\n                    if(umm[dx][gy] == 1){\\n                        break;\\n                    }\\n                    visited[dx][gy] = -1;\\n                }\\n                \\n                // left\\n                for(int lx = gy - 1; lx >= 0; lx--) {\\n                    if(umm[gx][lx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][lx] = -1;\\n                }\\n                \\n                \\n        }\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<n; ++j) {\\n                // cout << visited[i][j] << \" \";\\n                if(visited[i][j] == 1){\\n                    cnt++;\\n                } \\n            }\\n            // cout << endl;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        using pi = pair<int, int>;\\n        vector<vector<int>> visited(m, vector<int>(n, 1));\\n    \\n        unordered_map<int, unordered_map<int, int>> umm, gmm;\\n        \\n        for(auto x: walls){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        for(auto x: guards){\\n            gmm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        \\n        for(auto guard: guards) {\\n            int gx = guard[0];\\n            int gy = guard[1];\\n            \\n                // visited[gx][gy] = -1;\\n                \\n                \\n                // moving up\\n                for(int upx = gx-1; upx >= 0; upx--) {\\n                    if(umm[upx][gy] == 1 or gmm[upx][gy] == 1) {\\n                        break;\\n                    }\\n                    visited[upx][gy] = -1;\\n                }\\n                \\n                // right\\n                for(int rx = gy+1; rx <n; ++rx){\\n                    if(umm[gx][rx] == 1 or gmm[gx][rx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][rx] = -1;\\n                }\\n                \\n                // down\\n                for(int dx = gx+1; dx<m; dx++){\\n                    if(umm[dx][gy] == 1 or gmm[dx][gy] == 1){\\n                        break;\\n                    }\\n                    visited[dx][gy] = -1;\\n                }\\n                \\n                // left\\n                for(int lx = gy - 1; lx >= 0; lx--) {\\n                    if(umm[gx][lx] == 1 or gmm[gx][lx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][lx] = -1;\\n                }\\n                \\n                \\n        }\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<n; ++j) {\\n                if(visited[i][j] == 1){\\n                    cnt++;\\n                } \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        using pi = pair<int, int>;\\n        vector<vector<int>> visited(m, vector<int>(n, 1));\\n        unordered_map<int, unordered_map<int, int>> umm;\\n        \\n        for(auto x: walls){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        for(auto x: guards){\\n            umm[x[0]][x[1]] = 1;\\n            visited[x[0]][x[1]] = -1;\\n        }\\n        \\n        for(auto guard: guards) {\\n            int gx = guard[0];\\n            int gy = guard[1];\\n            \\n               \\n                \\n                // moving up\\n                for(int upx = gx-1; upx >= 0; upx--) {\\n                    if(umm[upx][gy] == 1) {\\n                        break;\\n                    }\\n                    visited[upx][gy] = -1;\\n                }\\n                \\n                // right\\n                for(int rx = gy+1; rx <n; ++rx){\\n                    if(umm[gx][rx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][rx] = -1;\\n                }\\n                \\n                // down\\n                for(int dx = gx+1; dx<m; dx++){\\n                    if(umm[dx][gy] == 1){\\n                        break;\\n                    }\\n                    visited[dx][gy] = -1;\\n                }\\n                \\n                // left\\n                for(int lx = gy - 1; lx >= 0; lx--) {\\n                    if(umm[gx][lx] == 1) {\\n                        break;\\n                    }\\n                    visited[gx][lx] = -1;\\n                }\\n                \\n                \\n        }\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<m; ++i){\\n            for(int j=0; j<n; ++j) {\\n                // cout << visited[i][j] << \" \";\\n                if(visited[i][j] == 1){\\n                    cnt++;\\n                } \\n            }\\n            // cout << endl;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994737,
                "title": "javascript-java-direct-way",
                "content": "Main idea:\\n(1) set walls and guards in grid\\n(2) for each guard, check 4 directions, if find obstacle, stop\\n\\njavascript: 707ms\\n```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst hit = (cur) => {\\n    if (cur == \\'W\\') return true;\\n    if (cur == \\'G\\') return true;\\n    return false;\\n}\\n\\nconst countUnguarded = (n, m, guards, walls) => {\\n    let visit = initialize2DArray(n, m), cnt = 0;\\n    for (const [x, y] of walls) visit[x][y] = \\'W\\';\\n    for (const [x, y] of guards) visit[x][y] = \\'G\\';\\n    for (const [x, y] of guards) {\\n        for (let j = y + 1; j < m; j++) { // right\\n            if (hit(visit[x][j])) break;\\n            visit[x][j] = \"R\";\\n        }\\n        for (let j = y - 1; j >= 0; j--) { // left\\n            if (hit(visit[x][j])) break;\\n            visit[x][j] = \"R\";\\n        }\\n        for (let i = x + 1; i < n; i++) { // down\\n            if (hit(visit[i][y])) break;\\n            visit[i][y] = \"R\";\\n        }\\n        for (let i = x - 1; i >= 0; i--) { // up\\n            if (hit(visit[i][y])) break;\\n            visit[i][y] = \"R\";\\n        }\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (visit[i][j] == 0) cnt++;\\n        }\\n    }\\n    return cnt;\\n};\\n```\\njava: 26ms\\n```\\nclass Solution {\\n     public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        char[][] visit = new char[n][m];\\n        int cnt = 0;\\n        for (int[] wall : walls) visit[wall[0]][wall[1]] = \\'W\\';\\n        for (int[] guard : guards) visit[guard[0]][guard[1]] = \\'G\\';\\n        for (int[] guard : guards) {\\n            int x = guard[0], y = guard[1];\\n            for (int j = y + 1; j < m; j++) { // right\\n                if (hit(visit[x][j])) break;\\n                visit[x][j] = \\'R\\';\\n            }\\n            for (int j = y - 1; j >= 0; j--) { // left\\n                if (hit(visit[x][j])) break;\\n                visit[x][j] = \\'R\\';\\n            }\\n            for (int i = x + 1; i < n; i++) { // down\\n                if (hit(visit[i][y])) break;\\n                visit[i][y] = \\'R\\';\\n            }\\n            for (int i = x - 1; i >= 0; i--) { // up\\n                if (hit(visit[i][y])) break;\\n                visit[i][y] = \\'R\\';\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (visit[i][j] == 0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    boolean hit(char cur) {\\n        if (cur == \\'W\\') return true;\\n        if (cur == \\'G\\') return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nconst initialize2DArray = (n, m) => { let d = []; for (let i = 0; i < n; i++) { let t = Array(m).fill(0); d.push(t); } return d; };\\n\\nconst hit = (cur) => {\\n    if (cur == \\'W\\') return true;\\n    if (cur == \\'G\\') return true;\\n    return false;\\n}\\n\\nconst countUnguarded = (n, m, guards, walls) => {\\n    let visit = initialize2DArray(n, m), cnt = 0;\\n    for (const [x, y] of walls) visit[x][y] = \\'W\\';\\n    for (const [x, y] of guards) visit[x][y] = \\'G\\';\\n    for (const [x, y] of guards) {\\n        for (let j = y + 1; j < m; j++) { // right\\n            if (hit(visit[x][j])) break;\\n            visit[x][j] = \"R\";\\n        }\\n        for (let j = y - 1; j >= 0; j--) { // left\\n            if (hit(visit[x][j])) break;\\n            visit[x][j] = \"R\";\\n        }\\n        for (let i = x + 1; i < n; i++) { // down\\n            if (hit(visit[i][y])) break;\\n            visit[i][y] = \"R\";\\n        }\\n        for (let i = x - 1; i >= 0; i--) { // up\\n            if (hit(visit[i][y])) break;\\n            visit[i][y] = \"R\";\\n        }\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (visit[i][j] == 0) cnt++;\\n        }\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution {\\n     public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        char[][] visit = new char[n][m];\\n        int cnt = 0;\\n        for (int[] wall : walls) visit[wall[0]][wall[1]] = \\'W\\';\\n        for (int[] guard : guards) visit[guard[0]][guard[1]] = \\'G\\';\\n        for (int[] guard : guards) {\\n            int x = guard[0], y = guard[1];\\n            for (int j = y + 1; j < m; j++) { // right\\n                if (hit(visit[x][j])) break;\\n                visit[x][j] = \\'R\\';\\n            }\\n            for (int j = y - 1; j >= 0; j--) { // left\\n                if (hit(visit[x][j])) break;\\n                visit[x][j] = \\'R\\';\\n            }\\n            for (int i = x + 1; i < n; i++) { // down\\n                if (hit(visit[i][y])) break;\\n                visit[i][y] = \\'R\\';\\n            }\\n            for (int i = x - 1; i >= 0; i--) { // up\\n                if (hit(visit[i][y])) break;\\n                visit[i][y] = \\'R\\';\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (visit[i][j] == 0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    boolean hit(char cur) {\\n        if (cur == \\'W\\') return true;\\n        if (cur == \\'G\\') return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994725,
                "title": "python-dfs",
                "content": "We iterate through the whole matrix.\\nWhenever we come across a guard , we start the `dfs` operation in all the 4 directions.\\nDuring the operation , we set the cells in those directions to `0` .\\nWe stop the operation when:\\n* We go out of matrix bound\\n* We encounter a wall or another guard\\n* We come across a `0` cell WHICH has been set to `0` by a operation in similar direction i.e horizontal (East and West) or vertical (North and South)\\n\\nFinally we count the number of unguarded cells \\n\\n\\n\\n```py\\nclass Solution:\\n    def countUnguarded(self, r: int, c: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        arr = [[(1, (1, 1))] * c for _ in range(r)]\\n        for x, y in guards:\\n            arr[x][y] = \"G\"\\n        for x, y in walls:\\n            arr[x][y] = \"W\"\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def dfs(x, y, dx, dy):\\n            if x >= r or y >= c or x < 0 or y < 0 \\\\\\n                    or (arr[x][y][0] == 0 and (arr[x][y][1][0] == dx or arr[x][y][1][1] == dy)) \\\\\\n                    or arr[x][y] == \"W\" or arr[x][y] == \"G\":\\n                return\\n\\n            arr[x][y] = (0, (dx, dy))\\n            dfs(x + dx, y + dy, dx, dy)\\n\\n        for x, y in product(range(r), range(c)):\\n            if arr[x][y] == \"G\":\\n                for dx, dy in dirs:\\n                    dfs(x + dx, y + dy, dx, dy)\\n        sol = 0\\n        for x, y in product(range(r), range(c)):\\n            if arr[x][y][0] == 1:\\n                sol += 1\\n\\n        return sol\\n\\n\\n\\n```\\n\\nIf you have any questions , feel free to ask\\n\\n**Happy Coding !!**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n    def countUnguarded(self, r: int, c: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        arr = [[(1, (1, 1))] * c for _ in range(r)]\\n        for x, y in guards:\\n            arr[x][y] = \"G\"\\n        for x, y in walls:\\n            arr[x][y] = \"W\"\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        def dfs(x, y, dx, dy):\\n            if x >= r or y >= c or x < 0 or y < 0 \\\\\\n                    or (arr[x][y][0] == 0 and (arr[x][y][1][0] == dx or arr[x][y][1][1] == dy)) \\\\\\n                    or arr[x][y] == \"W\" or arr[x][y] == \"G\":\\n                return\\n\\n            arr[x][y] = (0, (dx, dy))\\n            dfs(x + dx, y + dy, dx, dy)\\n\\n        for x, y in product(range(r), range(c)):\\n            if arr[x][y] == \"G\":\\n                for dx, dy in dirs:\\n                    dfs(x + dx, y + dy, dx, dy)\\n        sol = 0\\n        for x, y in product(range(r), range(c)):\\n            if arr[x][y][0] == 1:\\n                sol += 1\\n\\n        return sol\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994710,
                "title": "java-one-direction-at-a-time-linear-time",
                "content": "Other appraoches that i have seen are not linear. We are visiting one cell by multiple wall query. here we are iterating 4 time for each direction.\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        //  guard right\\n        int[][] a = new int[m][n];\\n        //  guard left\\n        int[][] b = new int[m][n];\\n        //  guard top\\n        int[][] c = new int[m][n];\\n        //  guard bottom\\n        int[][] d = new int[m][n];\\n        \\n        //  making walls\\n        for (int[] p : walls) {\\n            a[p[0]][p[1]] = -1;\\n            b[p[0]][p[1]] = -1;\\n            c[p[0]][p[1]] = -1;\\n            d[p[0]][p[1]] = -1;\\n        }\\n        \\n        //  making guards\\n        for (int[] p : guards) {\\n            a[p[0]][p[1]] = 1;\\n            b[p[0]][p[1]] = 1;\\n            c[p[0]][p[1]] = 1;\\n            d[p[0]][p[1]] = 1;\\n        }\\n        \\n        //  right\\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (a[i][j] == 0) {\\n                    if (a[i][j - 1] == 1) {\\n                        a[i][j] = 1;\\n                    } else {\\n                        a[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //  left\\n        for (int j = n - 2; j >= 0; j--) {\\n            for (int i = 0; i < m; i++) {\\n                if (b[i][j] == 0) {\\n                    if (b[i][j + 1] == 1) {\\n                        b[i][j] = 1;\\n                    } else {\\n                        b[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        //  top\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (c[i][j] == 0) {\\n                    if (c[i - 1][j] == 1) {\\n                        c[i][j] = 1;\\n                    } else {\\n                        c[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // bottom\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                if (d[i][j] == 0) {\\n                    if (d[i + 1][j] == 1) {\\n                        d[i][j] = 1;\\n                    } else {\\n                        d[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (a[i][j] == 0 && b[i][j] == 0 && c[i][j] == 0 && d[i][j] == 0) {\\n                    answer++;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```\\n```\\nTime : O(4*m*n)\\nSpace : O(4*m*n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        //  guard right\\n        int[][] a = new int[m][n];\\n        //  guard left\\n        int[][] b = new int[m][n];\\n        //  guard top\\n        int[][] c = new int[m][n];\\n        //  guard bottom\\n        int[][] d = new int[m][n];\\n        \\n        //  making walls\\n        for (int[] p : walls) {\\n            a[p[0]][p[1]] = -1;\\n            b[p[0]][p[1]] = -1;\\n            c[p[0]][p[1]] = -1;\\n            d[p[0]][p[1]] = -1;\\n        }\\n        \\n        //  making guards\\n        for (int[] p : guards) {\\n            a[p[0]][p[1]] = 1;\\n            b[p[0]][p[1]] = 1;\\n            c[p[0]][p[1]] = 1;\\n            d[p[0]][p[1]] = 1;\\n        }\\n        \\n        //  right\\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < m; i++) {\\n                if (a[i][j] == 0) {\\n                    if (a[i][j - 1] == 1) {\\n                        a[i][j] = 1;\\n                    } else {\\n                        a[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //  left\\n        for (int j = n - 2; j >= 0; j--) {\\n            for (int i = 0; i < m; i++) {\\n                if (b[i][j] == 0) {\\n                    if (b[i][j + 1] == 1) {\\n                        b[i][j] = 1;\\n                    } else {\\n                        b[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        //  top\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (c[i][j] == 0) {\\n                    if (c[i - 1][j] == 1) {\\n                        c[i][j] = 1;\\n                    } else {\\n                        c[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // bottom\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                if (d[i][j] == 0) {\\n                    if (d[i + 1][j] == 1) {\\n                        d[i][j] = 1;\\n                    } else {\\n                        d[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (a[i][j] == 0 && b[i][j] == 0 && c[i][j] == 0 && d[i][j] == 0) {\\n                    answer++;\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n```\n```\\nTime : O(4*m*n)\\nSpace : O(4*m*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994701,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(pair<int,int> &a,pair<int,int> &b) {\\n        if(a.first!=b.first) return a.first<b.first;\\n        return a.second<b.second;\\n   \\n}\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<pair<int,int>>> p_row(m);\\n        vector<vector<pair<int,int>>> p_col(n);\\n        \\n        \\n        vector<vector<int>> v(m,vector<int> (n,1));\\n        \\n        for(int i=0;i<guards.size();i++){\\n            p_row[guards[i][0]].push_back({guards[i][1],0});\\n            p_col[guards[i][1]].push_back({guards[i][0],0}); \\n            \\n            v[guards[i][0]][guards[i][1]]=-1;\\n        }\\n        \\n        for(int i=0;i<walls.size();i++){\\n            p_row[walls[i][0]].push_back({walls[i][1],1});\\n            p_col[walls[i][1]].push_back({walls[i][0],1}); \\n            \\n            v[walls[i][0]][walls[i][1]]=-1;\\n            \\n        }\\n       \\n        for(int i=0;i<p_row.size();i++){\\n            sort(p_row[i].begin(),p_row[i].end());\\n            \\n        }\\n        for(int i=0;i<p_col.size();i++){\\n            sort(p_col[i].begin(),p_col[i].end());\\n            \\n        }\\n\\n        \\n        long long count=0;\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                int row=i;\\n                int col=j;\\n                if(v[row][col]==-1) continue;\\n                \\n                bool f=1;\\n                pair p={col,-1};\\n                int ind=lower_bound(p_row[row].begin(),p_row[row].end(),p)-p_row[row].begin();\\n                if(!(ind==p_row[row].size() || p_row[row][ind].second==1))\\n                    continue;\\n                \\n                ind=lower_bound(p_row[row].begin(),p_row[row].end(),p)-p_row[row].begin()-1;\\n                \\n                if(ind>-1 && ind<col && p_row[row][ind].second==0)\\n                    continue;\\n                \\n                p={row,-1};\\n                \\n                ind=lower_bound(p_col[col].begin(),p_col[col].end(),p)-p_col[col].begin();\\n                if(!(ind==p_col[col].size() || p_col[col][ind].second==1))\\n                    continue;\\n                \\n                ind=lower_bound(p_col[col].begin(),p_col[col].end(),p)-p_col[col].begin()-1;\\n                if(ind>-1 && ind<row && p_col[col][ind].second==0)\\n                    continue;\\n                \\n\\n                count++;\\n               \\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(pair<int,int> &a,pair<int,int> &b) {\\n        if(a.first!=b.first) return a.first<b.first;\\n        return a.second<b.second;\\n   \\n}\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<pair<int,int>>> p_row(m);\\n        vector<vector<pair<int,int>>> p_col(n);\\n        \\n        \\n        vector<vector<int>> v(m,vector<int> (n,1));\\n        \\n        for(int i=0;i<guards.size();i++){\\n            p_row[guards[i][0]].push_back({guards[i][1],0});\\n            p_col[guards[i][1]].push_back({guards[i][0],0}); \\n            \\n            v[guards[i][0]][guards[i][1]]=-1;\\n        }\\n        \\n        for(int i=0;i<walls.size();i++){\\n            p_row[walls[i][0]].push_back({walls[i][1],1});\\n            p_col[walls[i][1]].push_back({walls[i][0],1}); \\n            \\n            v[walls[i][0]][walls[i][1]]=-1;\\n            \\n        }\\n       \\n        for(int i=0;i<p_row.size();i++){\\n            sort(p_row[i].begin(),p_row[i].end());\\n            \\n        }\\n        for(int i=0;i<p_col.size();i++){\\n            sort(p_col[i].begin(),p_col[i].end());\\n            \\n        }\\n\\n        \\n        long long count=0;\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                int row=i;\\n                int col=j;\\n                if(v[row][col]==-1) continue;\\n                \\n                bool f=1;\\n                pair p={col,-1};\\n                int ind=lower_bound(p_row[row].begin(),p_row[row].end(),p)-p_row[row].begin();\\n                if(!(ind==p_row[row].size() || p_row[row][ind].second==1))\\n                    continue;\\n                \\n                ind=lower_bound(p_row[row].begin(),p_row[row].end(),p)-p_row[row].begin()-1;\\n                \\n                if(ind>-1 && ind<col && p_row[row][ind].second==0)\\n                    continue;\\n                \\n                p={row,-1};\\n                \\n                ind=lower_bound(p_col[col].begin(),p_col[col].end(),p)-p_col[col].begin();\\n                if(!(ind==p_col[col].size() || p_col[col][ind].second==1))\\n                    continue;\\n                \\n                ind=lower_bound(p_col[col].begin(),p_col[col].end(),p)-p_col[col].begin()-1;\\n                if(ind>-1 && ind<row && p_col[col][ind].second==0)\\n                    continue;\\n                \\n\\n                count++;\\n               \\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994691,
                "title": "java-easy-understanding",
                "content": "```\\npublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        HashSet<String> wSet = new HashSet();\\n        HashSet<String> gSet = new HashSet();\\n        HashSet<String> vis = new HashSet();\\n        \\n        for(int []wall:walls){\\n            int x=wall[0];\\n            int y=wall[1];\\n            String str=x+\",\"+y;\\n            wSet.add(str);\\n            vis.add(str);\\n        }\\n        \\n        for(int []guard:guards){\\n            int x=guard[0];\\n            int y=guard[1];\\n            String str=x+\",\"+y;\\n            gSet.add(str);\\n            vis.add(str);\\n        }\\n        \\n        for(int []guard:guards){\\n            int x=guard[0];\\n            int y=guard[1];\\n            \\n            for(int i=x+1;i<m;i++){\\n                String str=i+\",\"+y;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int i=x-1;i>=0;i--){\\n                String str=i+\",\"+y;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int j=y+1;j<n;j++){\\n                String str=x+\",\"+j;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int j=y-1;j>=0;j--){\\n                String str=x+\",\"+j;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n        }\\n        \\n        return (m*n-vis.size());\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        HashSet<String> wSet = new HashSet();\\n        HashSet<String> gSet = new HashSet();\\n        HashSet<String> vis = new HashSet();\\n        \\n        for(int []wall:walls){\\n            int x=wall[0];\\n            int y=wall[1];\\n            String str=x+\",\"+y;\\n            wSet.add(str);\\n            vis.add(str);\\n        }\\n        \\n        for(int []guard:guards){\\n            int x=guard[0];\\n            int y=guard[1];\\n            String str=x+\",\"+y;\\n            gSet.add(str);\\n            vis.add(str);\\n        }\\n        \\n        for(int []guard:guards){\\n            int x=guard[0];\\n            int y=guard[1];\\n            \\n            for(int i=x+1;i<m;i++){\\n                String str=i+\",\"+y;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int i=x-1;i>=0;i--){\\n                String str=i+\",\"+y;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int j=y+1;j<n;j++){\\n                String str=x+\",\"+j;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n            \\n            for(int j=y-1;j>=0;j--){\\n                String str=x+\",\"+j;\\n                if(wSet.contains(str) || gSet.contains(str)){\\n                    break;\\n                }\\n                vis.add(str);\\n            }\\n        }\\n        \\n        return (m*n-vis.size());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994648,
                "title": "simple-just-see-from-all-4-directions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> vis;\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n             vector<vector<int>>vis(m,vector<int>(n,0));\\n             vector<vector<int>> g(m,vector<int>(n,0));\\n             // guards as 2 , walls as 1 \\n             for(int i=0; i<walls.size(); i++) g[walls[i][0]][walls[i][1]]=1;\\n             for(int i=0; i<guards.size(); i++) g[guards[i][0]][guards[i][1]]=2;\\n             // see from all four directions\\n             for(int i=0; i<n; i++) {\\n                 int see=0;\\n                 for(int j=0; j<m; j++) {\\n                       if(g[j][i]==2) {\\n                           see=1;\\n                            vis[j][i]=1;\\n                       }else if(g[j][i]==1) {\\n                           see=0;\\n                            vis[j][i]=1;\\n                       }else {\\n                           vis[j][i]=max(vis[j][i],see);\\n                       }\\n                 }\\n             }\\n             for(int i=0; i<n; i++) {\\n                 int see=0;\\n                 for(int j=m-1; j>=0; j--) {\\n                       if(g[j][i]==2) {\\n                           see=1;\\n                       }else if(g[j][i]==1) {\\n                           see=0;\\n                           vis[j][i]=1;\\n                       }else {\\n                           vis[j][i]=max(vis[j][i],see);\\n                       }\\n                 }\\n             }\\n             for(int i=0; i<m; i++) {\\n                 int see=0;\\n                 for(int j=0; j<n; j++) {\\n                      if(g[i][j]==2) {\\n                           see=1;\\n                           vis[i][j]=1;\\n                      }else if(g[i][j]==1) {\\n                           see=0;\\n                           vis[i][j]=1;\\n                      }else {\\n                          vis[i][j]=max(vis[i][j],see);\\n                      }\\n                 }\\n             }\\n            for(int i=0; i<m; i++) {\\n                 int see=0;\\n                 for(int j=n-1; j>=0; j--) {\\n                      if(g[i][j]==2) {\\n                           see=1;\\n                           vis[i][j]=1;\\n                      }else if(g[i][j]==1) {\\n                           see=0;\\n                           vis[i][j]=1;\\n                      }else {\\n                          vis[i][j]=max(vis[i][j],see);\\n                      }\\n                 }\\n             }\\n        \\n        int cnt=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) cnt+=vis[i][j]==0;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> vis;\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n             vector<vector<int>>vis(m,vector<int>(n,0));\\n             vector<vector<int>> g(m,vector<int>(n,0));\\n             // guards as 2 , walls as 1 \\n             for(int i=0; i<walls.size(); i++) g[walls[i][0]][walls[i][1]]=1;\\n             for(int i=0; i<guards.size(); i++) g[guards[i][0]][guards[i][1]]=2;\\n             // see from all four directions\\n             for(int i=0; i<n; i++) {\\n                 int see=0;\\n                 for(int j=0; j<m; j++) {\\n                       if(g[j][i]==2) {\\n                           see=1;\\n                            vis[j][i]=1;\\n                       }else if(g[j][i]==1) {\\n                           see=0;\\n                            vis[j][i]=1;\\n                       }else {\\n                           vis[j][i]=max(vis[j][i],see);\\n                       }\\n                 }\\n             }\\n             for(int i=0; i<n; i++) {\\n                 int see=0;\\n                 for(int j=m-1; j>=0; j--) {\\n                       if(g[j][i]==2) {\\n                           see=1;\\n                       }else if(g[j][i]==1) {\\n                           see=0;\\n                           vis[j][i]=1;\\n                       }else {\\n                           vis[j][i]=max(vis[j][i],see);\\n                       }\\n                 }\\n             }\\n             for(int i=0; i<m; i++) {\\n                 int see=0;\\n                 for(int j=0; j<n; j++) {\\n                      if(g[i][j]==2) {\\n                           see=1;\\n                           vis[i][j]=1;\\n                      }else if(g[i][j]==1) {\\n                           see=0;\\n                           vis[i][j]=1;\\n                      }else {\\n                          vis[i][j]=max(vis[i][j],see);\\n                      }\\n                 }\\n             }\\n            for(int i=0; i<m; i++) {\\n                 int see=0;\\n                 for(int j=n-1; j>=0; j--) {\\n                      if(g[i][j]==2) {\\n                           see=1;\\n                           vis[i][j]=1;\\n                      }else if(g[i][j]==1) {\\n                           see=0;\\n                           vis[i][j]=1;\\n                      }else {\\n                          vis[i][j]=max(vis[i][j],see);\\n                      }\\n                 }\\n             }\\n        \\n        int cnt=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) cnt+=vis[i][j]==0;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994621,
                "title": "simple-efficient-code",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\nvoid dfs(vector<vector<ll>>& v, ll i = 0, ll j = 0, char dir = \\'u\\') {\\n    ll m = v.size(), n = v[0].size();\\n    if (i < 0 || j < 0 || i >= m || j >= n || v[i][j]>0) return;\\n    v[i][j] = -1;\\n    if (dir == \\'u\\') dfs(v, i - 1, j, \\'u\\');\\n    if (dir == \\'d\\') dfs(v, i + 1, j, \\'d\\');\\n    if (dir == \\'l\\') dfs(v, i, j - 1, \\'l\\');\\n    if (dir == \\'r\\') dfs(v, i, j + 1, \\'r\\');\\n}\\n\\n// -1gd 0uo 1 g 2 w\\nint countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n    vector<vector<ll>>v(m, vector<ll>(n, 0));\\n    for (const auto& it : g)\\n        v[it[0]][it[1]] = 1;\\n    for (const auto& it : w)\\n        v[it[0]][it[1]] = 2;\\n    for (ll i = 0;i < m;++i) {\\n        for (ll j = 0;j < n;++j) {\\n            if (v[i][j] == 1) {\\n                dfs(v, i + 1, j, \\'d\\');\\n                dfs(v, i - 1, j, \\'u\\');\\n                dfs(v, i, j + 1, \\'r\\');\\n                dfs(v, i, j - 1, \\'l\\');\\n            }\\n        }\\n    }\\n    ll res = 0;\\n    for (ll i = 0;i < m;++i) {\\n        for (ll j = 0;j < n;++j) {\\n            if (v[i][j] == 0) {\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\nvoid dfs(vector<vector<ll>>& v, ll i = 0, ll j = 0, char dir = \\'u\\') {\\n    ll m = v.size(), n = v[0].size();\\n    if (i < 0 || j < 0 || i >= m || j >= n || v[i][j]>0) return;\\n    v[i][j] = -1;\\n    if (dir == \\'u\\') dfs(v, i - 1, j, \\'u\\');\\n    if (dir == \\'d\\') dfs(v, i + 1, j, \\'d\\');\\n    if (dir == \\'l\\') dfs(v, i, j - 1, \\'l\\');\\n    if (dir == \\'r\\') dfs(v, i, j + 1, \\'r\\');\\n}\\n\\n// -1gd 0uo 1 g 2 w\\nint countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n    vector<vector<ll>>v(m, vector<ll>(n, 0));\\n    for (const auto& it : g)\\n        v[it[0]][it[1]] = 1;\\n    for (const auto& it : w)\\n        v[it[0]][it[1]] = 2;\\n    for (ll i = 0;i < m;++i) {\\n        for (ll j = 0;j < n;++j) {\\n            if (v[i][j] == 1) {\\n                dfs(v, i + 1, j, \\'d\\');\\n                dfs(v, i - 1, j, \\'u\\');\\n                dfs(v, i, j + 1, \\'r\\');\\n                dfs(v, i, j - 1, \\'l\\');\\n            }\\n        }\\n    }\\n    ll res = 0;\\n    for (ll i = 0;i < m;++i) {\\n        for (ll j = 0;j < n;++j) {\\n            if (v[i][j] == 0) {\\n                res++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994595,
                "title": "scala",
                "content": "```scala\\ndef countUnguarded(m: Int, n: Int, guards: Array[Array[Int]], walls: Array[Array[Int]]): Int = {\\n  val arr = Array.fill(m)(Array.fill(n)(\\'o\\'))\\n\\n  def isObstacle(i: Int, j: Int): Boolean = arr(i)(j) == \\'G\\' || arr(i)(j) == \\'W\\'\\n\\n  def markIPlus(i: Int, j: Int): Unit =\\n    if(i < m && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markIPlus(i + 1, j)\\n    }\\n\\n  def markIMinus(i: Int, j: Int): Unit =\\n    if(i >= 0 && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markIMinus(i - 1, j)\\n    }\\n\\n  def markJPlus(i: Int, j: Int): Unit =\\n    if(j < n && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markJPlus(i, j + 1)\\n    }\\n\\n  def markJMinus(i: Int, j: Int): Unit =\\n    if(j >= 0 && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markJMinus(i, j - 1)\\n    }\\n\\n  guards.foreach { case Array(i, j) => arr(i)(j) = \\'G\\' }\\n  walls.foreach { case Array(i, j) => arr(i)(j) = \\'W\\' }\\n\\n  guards.foreach { case Array(i, j) =>\\n    markIPlus(i + 1, j)\\n    markIMinus(i - 1, j)\\n    markJPlus(i, j + 1)\\n    markJMinus(i, j - 1)\\n  }\\n\\n  var cnt = 0\\n  for {\\n    i <- 0 until m\\n    j <- 0 until n\\n  } if(arr(i)(j) == \\'o\\') cnt += 1\\n\\n  cnt\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef countUnguarded(m: Int, n: Int, guards: Array[Array[Int]], walls: Array[Array[Int]]): Int = {\\n  val arr = Array.fill(m)(Array.fill(n)(\\'o\\'))\\n\\n  def isObstacle(i: Int, j: Int): Boolean = arr(i)(j) == \\'G\\' || arr(i)(j) == \\'W\\'\\n\\n  def markIPlus(i: Int, j: Int): Unit =\\n    if(i < m && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markIPlus(i + 1, j)\\n    }\\n\\n  def markIMinus(i: Int, j: Int): Unit =\\n    if(i >= 0 && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markIMinus(i - 1, j)\\n    }\\n\\n  def markJPlus(i: Int, j: Int): Unit =\\n    if(j < n && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markJPlus(i, j + 1)\\n    }\\n\\n  def markJMinus(i: Int, j: Int): Unit =\\n    if(j >= 0 && !isObstacle(i, j)) {\\n      arr(i)(j) = \\'g\\'\\n      markJMinus(i, j - 1)\\n    }\\n\\n  guards.foreach { case Array(i, j) => arr(i)(j) = \\'G\\' }\\n  walls.foreach { case Array(i, j) => arr(i)(j) = \\'W\\' }\\n\\n  guards.foreach { case Array(i, j) =>\\n    markIPlus(i + 1, j)\\n    markIMinus(i - 1, j)\\n    markJPlus(i, j + 1)\\n    markJMinus(i, j - 1)\\n  }\\n\\n  var cnt = 0\\n  for {\\n    i <- 0 until m\\n    j <- 0 until n\\n  } if(arr(i)(j) == \\'o\\') cnt += 1\\n\\n  cnt\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994591,
                "title": "python-solution-using-dfs",
                "content": "\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        #Create a matrix, hint from question\\n        mat = [[0 for _ in range(n)] for _ in range(m)] \\n        \\n        for [i,j] in guards:\\n            mat[i][j] = 1   \\n        for [i,j] in walls:\\n            mat[i][j] = -1\\n        \\n        #dfs for marking paths.\\n        def dfs(i,j,di):\\n            if i<0 or i>=m or j<0 or j>=n or mat[i][j] == 1 or mat[i][j] == -1:\\n                return\\n            else:\\n                mat[i][j] = 2\\n            i = i + lst[di]\\n            j = j + lst[di+1]\\n            dfs(i,j,di)\\n        \\n        lst = [1,0,-1,0,1]\\n        for [i,j] in guards:\\n            for idx in range(4):  \\n                k = i + lst[idx]\\n                l = j + lst[idx+1]\\n                dfs(k,l,idx)\\n        \\n        #count uncovered cells.\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    count +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        #Create a matrix, hint from question\\n        mat = [[0 for _ in range(n)] for _ in range(m)] \\n        \\n        for [i,j] in guards:\\n            mat[i][j] = 1   \\n        for [i,j] in walls:\\n            mat[i][j] = -1\\n        \\n        #dfs for marking paths.\\n        def dfs(i,j,di):\\n            if i<0 or i>=m or j<0 or j>=n or mat[i][j] == 1 or mat[i][j] == -1:\\n                return\\n            else:\\n                mat[i][j] = 2\\n            i = i + lst[di]\\n            j = j + lst[di+1]\\n            dfs(i,j,di)\\n        \\n        lst = [1,0,-1,0,1]\\n        for [i,j] in guards:\\n            for idx in range(4):  \\n                k = i + lst[idx]\\n                l = j + lst[idx+1]\\n                dfs(k,l,idx)\\n        \\n        #count uncovered cells.\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    count +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994587,
                "title": "java-easy-approach-simple-solution",
                "content": "```\\nclass Solution {\\nint[] x = {-1,0,0,1};\\n    int[] y = {0,1,-1,0};\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        char[][] visited = new char[m][n];\\n        for(char[] ch : visited){\\n            Arrays.fill(ch, \\'X\\');\\n        }\\n        for(int[] g : guards){\\n            visited[g[0]][g[1]] = \\'G\\';\\n        }\\n        for(int[] w : walls){\\n            visited[w[0]][w[1]] = \\'W\\';\\n        }\\n        for(int i = 0; i < visited.length; i++){\\n            for(int j = 0; j < visited[0].length; j++){\\n                if(visited[i][j] == \\'G\\'){\\n                    dfsLeft(m, n, visited, i, j);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                 //System.out.print(visited[i][j] + \" \");\\n                if(visited[i][j] == \\'X\\'){\\n                   \\n                    count++;\\n                }\\n            }\\n            //System.out.println();\\n        }\\n        return count;\\n    }\\n    \\n    public void dfsLeft(int m, int n, char[][] visited, int i, int j){\\n        int ab = j;\\n        while(ab >= 0 && !(visited[i][ab]== \\'W\\')) {\\n            if(j == ab){\\n                ab--;\\n                continue;\\n            }\\n            if(visited[i][ab] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[i][ab] = \\'A\\';\\n            ab--;\\n        }\\n        ab = j;\\n        while(ab < n && !(visited[i][ab] == \\'W\\') ){\\n            if(j == ab){\\n                ab++;\\n                continue;\\n            }\\n            if(visited[i][ab] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[i][ab] = \\'A\\';\\n            ab++;\\n        }\\n        ab = i;\\n        while(ab >= 0 && !(visited[ab][j] == \\'W\\')  ){\\n            if(i == ab){\\n                ab--;\\n                continue;\\n            }\\n            if(visited[ab][j] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[ab][j] = \\'A\\';\\n            ab--;\\n        }\\n        ab = i;\\n        while(ab < m && !(visited[ab][j] == \\'W\\')){\\n            if(i == ab){\\n                ab++;\\n                continue;\\n            }\\n            if(visited[ab][j] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[ab][j] = \\'A\\';\\n            ab++;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nint[] x = {-1,0,0,1};\\n    int[] y = {0,1,-1,0};\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        char[][] visited = new char[m][n];\\n        for(char[] ch : visited){\\n            Arrays.fill(ch, \\'X\\');\\n        }\\n        for(int[] g : guards){\\n            visited[g[0]][g[1]] = \\'G\\';\\n        }\\n        for(int[] w : walls){\\n            visited[w[0]][w[1]] = \\'W\\';\\n        }\\n        for(int i = 0; i < visited.length; i++){\\n            for(int j = 0; j < visited[0].length; j++){\\n                if(visited[i][j] == \\'G\\'){\\n                    dfsLeft(m, n, visited, i, j);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                 //System.out.print(visited[i][j] + \" \");\\n                if(visited[i][j] == \\'X\\'){\\n                   \\n                    count++;\\n                }\\n            }\\n            //System.out.println();\\n        }\\n        return count;\\n    }\\n    \\n    public void dfsLeft(int m, int n, char[][] visited, int i, int j){\\n        int ab = j;\\n        while(ab >= 0 && !(visited[i][ab]== \\'W\\')) {\\n            if(j == ab){\\n                ab--;\\n                continue;\\n            }\\n            if(visited[i][ab] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[i][ab] = \\'A\\';\\n            ab--;\\n        }\\n        ab = j;\\n        while(ab < n && !(visited[i][ab] == \\'W\\') ){\\n            if(j == ab){\\n                ab++;\\n                continue;\\n            }\\n            if(visited[i][ab] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[i][ab] = \\'A\\';\\n            ab++;\\n        }\\n        ab = i;\\n        while(ab >= 0 && !(visited[ab][j] == \\'W\\')  ){\\n            if(i == ab){\\n                ab--;\\n                continue;\\n            }\\n            if(visited[ab][j] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[ab][j] = \\'A\\';\\n            ab--;\\n        }\\n        ab = i;\\n        while(ab < m && !(visited[ab][j] == \\'W\\')){\\n            if(i == ab){\\n                ab++;\\n                continue;\\n            }\\n            if(visited[ab][j] == \\'G\\') {\\n            \\tbreak;\\n            }\\n            visited[ab][j] = \\'A\\';\\n            ab++;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994578,
                "title": "c-easy-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // In this question, we first create the matrix and try to mark all the cells which are gaurded and at the end we count all the empty cells.\\n    // implementation is pretty straight forward.\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m, vector<int>(n, 0)); // empty cell 0, guard 1, and walls 2, gaurded 3\\n        for(auto guard : guards) {\\n            mat[guard[0]][guard[1]] = 1;\\n        }\\n        for(auto wall : walls) {\\n            mat[wall[0]][wall[1]] = 2;\\n        }\\n        bool isGaurded = false;\\n        // for rows\\n        for(int i=0;i<m;i++) {\\n            isGaurded = false;\\n            for(int j=0;j<n;j++) { // left --> right\\n                if(mat[i][j] == 2) { // it is a wall\\n                    isGaurded = false;\\n                    continue;\\n                }\\n                if(isGaurded and mat[i][j] != 1)\\n                    mat[i][j] = 3;\\n                if(mat[i][j] == 1)\\n                    isGaurded = true;\\n            }\\n            isGaurded = false;\\n            for(int j=n-1;j>=0;j--) { // right --> left\\n                if(mat[i][j] == 2) {\\n                    isGaurded = false;\\n                    continue;\\n                }\\n                if(isGaurded and mat[i][j] != 1)\\n                    mat[i][j] = 3;\\n                if(mat[i][j] == 1)\\n                    isGaurded = true;\\n            }\\n        }\\n        isGaurded = false;\\n        // for columns\\n        for(int i=0;i<n;i++) {\\n            isGaurded = false;\\n            for(int j=0;j<m;j++) { // up to bottom\\n                if(mat[j][i] == 2) { // it is a wall\\n                    isGaurded = false;\\n                    continue;\\n                }\\n                if(isGaurded and mat[j][i] != 1)\\n                    mat[j][i] = 3;\\n                if(mat[j][i] == 1)\\n                    isGaurded = true;\\n            }\\n            isGaurded = false;\\n            for(int j=m-1;j>=0;j--) { // bottom to ip\\n                if(mat[j][i] == 2) {\\n                    isGaurded = false;\\n                    continue;\\n                }\\n                if(isGaurded and mat[j][i] != 1)\\n                    mat[j][i] = 3;\\n                if(mat[j][i] == 1)\\n                    isGaurded = true;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(mat[i][j] == 0) ans++; // counting empty cells\\n            }\\n        }\\n        return ans;\\n        // upvote if you find it helpful. Thanks\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    // In this question, we first create the matrix and try to mark all the cells which are gaurded and at the end we count all the empty cells.\\n    // implementation is pretty straight forward.\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mat(m, vector<int>(n, 0)); // empty cell 0, guard 1, and walls 2, gaurded 3\\n        for(auto guard : guards) {\\n            mat[guard[0]][guard[1]] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1994560,
                "title": "python-dfs-greedy-o-mn",
                "content": "The solution is simple. We have to consider position of all guards and do a depth first search in either direction (left,, right, top, bottom) only and check if we encounter wall or another guard. If yes, we stop otherwise we add the solution to the guarded set. \\n\\nOnce we have all the cells that are guarded, we can find the unguarded by checking all cells, if they exist in guarded or guard or wall list in O(mn). \\n\\n\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        guarded = set()\\n        guard_set = set()\\n        wall_set = set()\\n        \\n\\t\\tfor guard in guards:  guard_set.add((guard[0], guard[1]))\\n        for wall in walls: wall_set.add((wall[0], wall[1]))\\n\\t\\t\\n\\t\\t# left, right, bottom, top\\n        directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n\\t\\t\\n        # find all guarded\\n        for guard in guards:\\n            for dx, dy in directions:\\n                x, y = guard\\n                \\n\\t\\t\\t\\t# travel one direction\\n                while 0 <= x + dx < m and 0 <= y + dy < n:\\n                    x, y = x + dx , y + dy\\n                    if (x, y) in guard_set or (x, y) in wall_set: break\\n                    guarded.add((x, y))\\n         \\n\\t\\t# count unguarded\\n        not_guarded_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) not in guarded and (i, j) not in wall_set and (i, j) not in guard_set:\\n                    not_guarded_count += 1\\n        \\n        return not_guarded_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        guarded = set()\\n        guard_set = set()\\n        wall_set = set()\\n        \\n\\t\\tfor guard in guards:  guard_set.add((guard[0], guard[1]))\\n        for wall in walls: wall_set.add((wall[0], wall[1]))\\n\\t\\t\\n\\t\\t# left, right, bottom, top\\n        directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]\\n\\t\\t\\n        # find all guarded\\n        for guard in guards:\\n            for dx, dy in directions:\\n                x, y = guard\\n                \\n\\t\\t\\t\\t# travel one direction\\n                while 0 <= x + dx < m and 0 <= y + dy < n:\\n                    x, y = x + dx , y + dy\\n                    if (x, y) in guard_set or (x, y) in wall_set: break\\n                    guarded.add((x, y))\\n         \\n\\t\\t# count unguarded\\n        not_guarded_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) not in guarded and (i, j) not in wall_set and (i, j) not in guard_set:\\n                    not_guarded_count += 1\\n        \\n        return not_guarded_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994557,
                "title": "simple-commented-solution-o-m-n-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //Traverse in all four directions, if possible then visit and mark them as guarded\\n        void traverse(vector<vector<int>> &mat, int i, int j) {\\n            int k;\\n            //right\\n            k = j+1;\\n            while(k < mat[0].size()) {\\n                if(mat[i][k] == 1 || mat[i][k] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[i][k] = 3;\\n                ++k;\\n            }\\n            //left\\n            k = j-1;\\n            while(k >= 0) {\\n                if(mat[i][k] == 1 || mat[i][k] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[i][k] = 3;\\n                --k;\\n            }\\n            \\n            //down\\n            k = i+1;\\n            while(k < mat.size()) {\\n                if(mat[k][j] == 1 || mat[k][j] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[k][j] = 3;\\n                ++k;\\n            }\\n            \\n            //up\\n            k = i-1;\\n            while(k >= 0) {\\n                if(mat[k][j] == 1 || mat[k][j] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[k][j] = 3;\\n                --k;\\n            }\\n        }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        //0 means unoccupied\\n        //1 means guard\\n        //2 means wall\\n        //3 means guarded\\n        \\n        vector<vector<int>> mat(m, vector<int>(n, 0));\\n        \\n        //Mark all the guards\\n        for(int i = 0; i < guards.size(); ++i) {\\n            mat[guards[i][0]][guards[i][1]] = 1;\\n        }\\n        \\n        //Mark all the walls\\n        for(int i = 0; i < walls.size(); ++i) {\\n            mat[walls[i][0]][walls[i][1]] = 2;\\n        }\\n        \\n       //For each guard, try to guard cells by traversing in all four diections \\n       for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(mat[i][j] == 1) {\\n                    traverse(mat, i, j);\\n                }\\n               \\n            } \\n        }\\n        \\n        //Count all the remaing cells, that cannot be guarded\\n        int unguarded = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(mat[i][j] == 0) {\\n                    unguarded++;\\n                }\\n            }\\n        }\\n        \\n        return unguarded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Traverse in all four directions, if possible then visit and mark them as guarded\\n        void traverse(vector<vector<int>> &mat, int i, int j) {\\n            int k;\\n            //right\\n            k = j+1;\\n            while(k < mat[0].size()) {\\n                if(mat[i][k] == 1 || mat[i][k] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[i][k] = 3;\\n                ++k;\\n            }\\n            //left\\n            k = j-1;\\n            while(k >= 0) {\\n                if(mat[i][k] == 1 || mat[i][k] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[i][k] = 3;\\n                --k;\\n            }\\n            \\n            //down\\n            k = i+1;\\n            while(k < mat.size()) {\\n                if(mat[k][j] == 1 || mat[k][j] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[k][j] = 3;\\n                ++k;\\n            }\\n            \\n            //up\\n            k = i-1;\\n            while(k >= 0) {\\n                if(mat[k][j] == 1 || mat[k][j] == 2) //If wall or guard we can\\'t go furthur\\n                    break;\\n                mat[k][j] = 3;\\n                --k;\\n            }\\n        }\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        //0 means unoccupied\\n        //1 means guard\\n        //2 means wall\\n        //3 means guarded\\n        \\n        vector<vector<int>> mat(m, vector<int>(n, 0));\\n        \\n        //Mark all the guards\\n        for(int i = 0; i < guards.size(); ++i) {\\n            mat[guards[i][0]][guards[i][1]] = 1;\\n        }\\n        \\n        //Mark all the walls\\n        for(int i = 0; i < walls.size(); ++i) {\\n            mat[walls[i][0]][walls[i][1]] = 2;\\n        }\\n        \\n       //For each guard, try to guard cells by traversing in all four diections \\n       for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(mat[i][j] == 1) {\\n                    traverse(mat, i, j);\\n                }\\n               \\n            } \\n        }\\n        \\n        //Count all the remaing cells, that cannot be guarded\\n        int unguarded = 0;\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(mat[i][j] == 0) {\\n                    unguarded++;\\n                }\\n            }\\n        }\\n        \\n        return unguarded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090677,
                "title": "c-a-somewhat-different-approach",
                "content": "# Intuition\\nI wanted to avoid holding full grid in memory. So I look at the problem from a bit different perspective - how to check if particular square is *safe* or not.\\n\\n# Approach\\n- To speed up checks build Column and Row dictionaries for guards and walls.\\n- Values in Dictionaries hold sorted list of object\\'s coordinates.\\n- To check - find the closest guards in 4 directions by using binary search.\\n- Check if any walls block you from the found guards sight - again binary search.\\n\\n# Complexity\\n- Time complexity:\\n$O(m*n*(log(walls+guards))$\\n\\n- Space complexity:\\n$O(mn)$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    //guards positions for rows and columns\\n    Dictionary<int, List<int>> rowGuard = new();\\n    Dictionary<int, List<int>> colGuard = new();\\n    //wall positions for rows and columns\\n    Dictionary<int, List<int>> rowWall = new();\\n    Dictionary<int, List<int>> colWall = new();\\n\\n    void sort(Dictionary<int, List<int>> info)\\n    {\\n        foreach (var kv in info)\\n            kv.Value.Sort();\\n    }\\n    // fill row and column dictionaries for guards/walls\\n    void prepareDictionaries(int[][] g, Dictionary<int, List<int>> rowInfo, Dictionary<int, List<int>> colInfo)\\n    {\\n        foreach (var yx in g)\\n        {\\n            var y = yx[0];\\n            var x = yx[1];\\n\\n            rowInfo.TryAdd(y, new());\\n            rowInfo[y].Add(x);\\n\\n            colInfo.TryAdd(x, new());\\n            colInfo[x].Add(y);\\n        }\\n        sort(rowInfo);\\n        sort(colInfo);\\n    }\\n\\n    bool checkDir(int pos, List<int> guards, List<int>? walls)\\n    {\\n        // Locate nearby guards\\n        var guardIndex = ~guards.BinarySearch(pos);\\n\\n        int? leftGuard = (guardIndex > 0) ? guards[guardIndex - 1] : null;\\n        int? rightGuard = (guardIndex < guards.Count) ? guards[guardIndex] : null;\\n        // Any guard from \"left/up\" or \"right/down\" present\\n        if (leftGuard.HasValue || rightGuard.HasValue)\\n        {\\n            int leftWall = -1;\\n            int rightWall = int.MaxValue;\\n\\n            if (walls != null)\\n            {\\n                // Check if maybe theres a wall nearby\\n                var wallIndex = ~walls.BinarySearch(pos);\\n                leftWall = (wallIndex > 0) ? walls[wallIndex - 1] : -1;\\n                rightWall = (wallIndex < walls.Count) ? walls[wallIndex] : int.MaxValue;\\n            }\\n            // check if guard to the \"left\" is present and not blocked by a wall\\n            if (leftGuard.HasValue && leftGuard.Value > leftWall)\\n                return false;\\n            // check if guard to the \"right\" is present and not blocked by a wall\\n            if (rightGuard.HasValue && rightGuard.Value < rightWall)\\n                return false;\\n        }\\n        // we are in a safe cell\\n        return true;\\n    }\\n\\n    bool isSafe(int col, int row)\\n    {\\n        bool XdirOK = true;\\n        bool YDirOK = true;\\n        // If we are on top of a wall\\n        if (colWall.ContainsKey(col) && colWall[col].BinarySearch(row) >= 0)\\n            return false;\\n        // If we are on top of a guard\\n        if (colGuard.ContainsKey(col) && colGuard[col].BinarySearch(row) >= 0)\\n            return false;\\n\\n        // Check if theres a guard on current row\\n        if (rowGuard.ContainsKey(row))\\n        {\\n            // pass a wall information, if there is one\\n            XdirOK = checkDir(col, rowGuard[row], rowWall.ContainsKey(row) ? rowWall[row] : null);\\n        }\\n        // Bother checking for guard in current column only if it makes ense\\n        if (XdirOK && colGuard.ContainsKey(col))\\n        {\\n            YDirOK = checkDir(row, colGuard[col], colWall.ContainsKey(col) ? colWall[col] : null);\\n        }\\n\\n        return XdirOK && YDirOK;\\n    }\\n\\n\\n    public int CountUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        prepareDictionaries(guards, rowGuard, colGuard);\\n        prepareDictionaries(walls, rowWall, colWall);\\n\\n        int free = 0;\\n        // Just check each square is it safe\\n        for (int r = 0; r < m; r++)\\n        {\\n            for (int c = 0; c < n; c++)\\n            {\\n                if (isSafe(c, r))\\n                    free++;\\n            }\\n        }\\n\\n        return free;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    //guards positions for rows and columns\\n    Dictionary<int, List<int>> rowGuard = new();\\n    Dictionary<int, List<int>> colGuard = new();\\n    //wall positions for rows and columns\\n    Dictionary<int, List<int>> rowWall = new();\\n    Dictionary<int, List<int>> colWall = new();\\n\\n    void sort(Dictionary<int, List<int>> info)\\n    {\\n        foreach (var kv in info)\\n            kv.Value.Sort();\\n    }\\n    // fill row and column dictionaries for guards/walls\\n    void prepareDictionaries(int[][] g, Dictionary<int, List<int>> rowInfo, Dictionary<int, List<int>> colInfo)\\n    {\\n        foreach (var yx in g)\\n        {\\n            var y = yx[0];\\n            var x = yx[1];\\n\\n            rowInfo.TryAdd(y, new());\\n            rowInfo[y].Add(x);\\n\\n            colInfo.TryAdd(x, new());\\n            colInfo[x].Add(y);\\n        }\\n        sort(rowInfo);\\n        sort(colInfo);\\n    }\\n\\n    bool checkDir(int pos, List<int> guards, List<int>? walls)\\n    {\\n        // Locate nearby guards\\n        var guardIndex = ~guards.BinarySearch(pos);\\n\\n        int? leftGuard = (guardIndex > 0) ? guards[guardIndex - 1] : null;\\n        int? rightGuard = (guardIndex < guards.Count) ? guards[guardIndex] : null;\\n        // Any guard from \"left/up\" or \"right/down\" present\\n        if (leftGuard.HasValue || rightGuard.HasValue)\\n        {\\n            int leftWall = -1;\\n            int rightWall = int.MaxValue;\\n\\n            if (walls != null)\\n            {\\n                // Check if maybe theres a wall nearby\\n                var wallIndex = ~walls.BinarySearch(pos);\\n                leftWall = (wallIndex > 0) ? walls[wallIndex - 1] : -1;\\n                rightWall = (wallIndex < walls.Count) ? walls[wallIndex] : int.MaxValue;\\n            }\\n            // check if guard to the \"left\" is present and not blocked by a wall\\n            if (leftGuard.HasValue && leftGuard.Value > leftWall)\\n                return false;\\n            // check if guard to the \"right\" is present and not blocked by a wall\\n            if (rightGuard.HasValue && rightGuard.Value < rightWall)\\n                return false;\\n        }\\n        // we are in a safe cell\\n        return true;\\n    }\\n\\n    bool isSafe(int col, int row)\\n    {\\n        bool XdirOK = true;\\n        bool YDirOK = true;\\n        // If we are on top of a wall\\n        if (colWall.ContainsKey(col) && colWall[col].BinarySearch(row) >= 0)\\n            return false;\\n        // If we are on top of a guard\\n        if (colGuard.ContainsKey(col) && colGuard[col].BinarySearch(row) >= 0)\\n            return false;\\n\\n        // Check if theres a guard on current row\\n        if (rowGuard.ContainsKey(row))\\n        {\\n            // pass a wall information, if there is one\\n            XdirOK = checkDir(col, rowGuard[row], rowWall.ContainsKey(row) ? rowWall[row] : null);\\n        }\\n        // Bother checking for guard in current column only if it makes ense\\n        if (XdirOK && colGuard.ContainsKey(col))\\n        {\\n            YDirOK = checkDir(row, colGuard[col], colWall.ContainsKey(col) ? colWall[col] : null);\\n        }\\n\\n        return XdirOK && YDirOK;\\n    }\\n\\n\\n    public int CountUnguarded(int m, int n, int[][] guards, int[][] walls)\\n    {\\n        prepareDictionaries(guards, rowGuard, colGuard);\\n        prepareDictionaries(walls, rowWall, colWall);\\n\\n        int free = 0;\\n        // Just check each square is it safe\\n        for (int r = 0; r < m; r++)\\n        {\\n            for (int c = 0; c < n; c++)\\n            {\\n                if (isSafe(c, r))\\n                    free++;\\n            }\\n        }\\n\\n        return free;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085417,
                "title": "27-lines-easy-to-understand",
                "content": "# Intuition\\nThe usual walk in 4 directions from each guard and mark space as guarded.\\n\\nHowever, can optimise time by stopping the walk when you encounter a guard (and of course wall).\\n\\nTo avoid the final extra iteration over the space grid to count unguarded cells, can include a counter of empty space that is decremented as spaces are marked as guarded.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        space = [[\\'e\\' for _ in range(n)] for _ in range(m)]\\n        empty = m*n - len(guards) - len(walls)\\n        for guard in guards:\\n            space[guard[0]][guard[1]] = \\'o\\'\\n\\n        for wall in walls:\\n            space[wall[0]][wall[1]] = \\'o\\'\\n\\n        def walk(r, c):\\n            for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\\n                row, col = r + dy, c + dx\\n\\n                while row >= 0 and row < m and col >= 0 and col < n:\\n                    if space[row][col] == \\'e\\':\\n                        space[row][col] = \\'g\\'\\n                        nonlocal empty\\n                        empty -= 1\\n                    elif space[row][col] == \\'o\\':\\n                        break\\n                    row, col = row + dy, col + dx\\n\\n        for guard in guards:\\n            walk(guard[0], guard[1])\\n\\n        return empty\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        space = [[\\'e\\' for _ in range(n)] for _ in range(m)]\\n        empty = m*n - len(guards) - len(walls)\\n        for guard in guards:\\n            space[guard[0]][guard[1]] = \\'o\\'\\n\\n        for wall in walls:\\n            space[wall[0]][wall[1]] = \\'o\\'\\n\\n        def walk(r, c):\\n            for dx, dy in [(0, -1), (0, 1), (1, 0), (-1, 0)]:\\n                row, col = r + dy, c + dx\\n\\n                while row >= 0 and row < m and col >= 0 and col < n:\\n                    if space[row][col] == \\'e\\':\\n                        space[row][col] = \\'g\\'\\n                        nonlocal empty\\n                        empty -= 1\\n                    elif space[row][col] == \\'o\\':\\n                        break\\n                    row, col = row + dy, col + dx\\n\\n        for guard in guards:\\n            walk(guard[0], guard[1])\\n\\n        return empty\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044107,
                "title": "a-good-greedy-question-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int count = 0;\\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        for(int i=0;i<walls.size();i++){\\n            int r =  walls[i][0];\\n            int c = walls[i][1];\\n            grid[r][c] = 2;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            grid[r][c] = 1;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            int r1 = r,c1 = c;\\n            c--;\\n            while(c>=0 && grid[r][c] !=2  && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                c--;\\n            }\\n            r = r1,c = c1;\\n            c++;\\n            while(c<n && grid[r][c] !=2   && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                c++;\\n            }\\n            r = r1,c = c1;\\n            r--;\\n            while(r>=0 && grid[r][c] != 2 && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                r--;\\n            }\\n            r = r1,c = c1;\\n            r++;\\n            while(r<m && grid[r][c] != 2 && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                r++;\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 0)count++;\\n\\n              //  cout<<grid[i][j]<<\" \";\\n            }\\n         //   cout<<endl;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int count = 0;\\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        for(int i=0;i<walls.size();i++){\\n            int r =  walls[i][0];\\n            int c = walls[i][1];\\n            grid[r][c] = 2;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            grid[r][c] = 1;\\n        }\\n        for(int i=0;i<guards.size();i++){\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            int r1 = r,c1 = c;\\n            c--;\\n            while(c>=0 && grid[r][c] !=2  && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                c--;\\n            }\\n            r = r1,c = c1;\\n            c++;\\n            while(c<n && grid[r][c] !=2   && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                c++;\\n            }\\n            r = r1,c = c1;\\n            r--;\\n            while(r>=0 && grid[r][c] != 2 && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                r--;\\n            }\\n            r = r1,c = c1;\\n            r++;\\n            while(r<m && grid[r][c] != 2 && grid[r][c]!=1){\\n                grid[r][c] = -1;\\n                r++;\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 0)count++;\\n\\n              //  cout<<grid[i][j]<<\" \";\\n            }\\n         //   cout<<endl;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4015711,
                "title": "direction-based-dfs-cpp",
                "content": "## Intuition\\nThe intuition behind the solution is to use DFS to mark all the cells that are guarded by the guards and then count the unguarded cells.\\n\\n## Approach\\n1. Initialize a 2D grid `dp` with dimensions `m x n` and initialize all cells to -1. This grid will be used to mark cells that are guarded by guards.\\n\\n2. Iterate through the `guards` array and set the corresponding cells in the `dp` grid to 0 to mark them as guarded.\\n\\n3. Iterate through the `walls` array and set the corresponding cells in the `dp` grid to 0 to mark them as well. Walls also obstruct the view.\\n\\n4. For each guard position in `guards`, perform DFS in all four cardinal directions (north, south, east, and west) to mark all the cells that can be seen by that guard. The DFS function `dfs` takes the guard\\'s position and direction as parameters.\\n\\n5. After marking all the cells that are guarded, count the number of unmarked cells (cells with -1 in the `dp` grid) and return the count as the result.\\n\\n## Complexity\\n- Time complexity: The DFS traversal visits each cell at most once, so the time complexity is O(m * n), where m is the number of rows and n is the number of columns in the grid.\\n- Space complexity: The space complexity is O(m * n) due to the `dp` grid used to mark cells.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,int m,int n,vector<vector<int>>&grid,int d){\\n        if(i<0 or j<0 or j>=n or i>=m or grid[i][j]==0) return;\\n        grid[i][j]=1;\\n        if(d==1) dfs(i+1,j,m,n,grid,1);\\n        else if(d==2) dfs(i-1,j,m,n,grid,2);\\n        else if(d==3) dfs(i,j+1,m,n,grid,3);\\n        else dfs(i,j-1,m,n,grid,4);\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        for(auto i:g) dp[i[0]][i[1]]=0;\\n        for(auto i:w) dp[i[0]][i[1]]=0;\\n        for(auto i:g){\\n            int s=i[0];\\n            int e=i[1];\\n            dfs(s+1,e,m,n,dp,1);\\n            dfs(s-1,e,m,n,dp,2);\\n            dfs(s,e+1,m,n,dp,3);\\n            dfs(s,e-1,m,n,dp,4);\\n        }\\n        for(auto i:dp) for(auto j:i) if(j==-1) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,int m,int n,vector<vector<int>>&grid,int d){\\n        if(i<0 or j<0 or j>=n or i>=m or grid[i][j]==0) return;\\n        grid[i][j]=1;\\n        if(d==1) dfs(i+1,j,m,n,grid,1);\\n        else if(d==2) dfs(i-1,j,m,n,grid,2);\\n        else if(d==3) dfs(i,j+1,m,n,grid,3);\\n        else dfs(i,j-1,m,n,grid,4);\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        for(auto i:g) dp[i[0]][i[1]]=0;\\n        for(auto i:w) dp[i[0]][i[1]]=0;\\n        for(auto i:g){\\n            int s=i[0];\\n            int e=i[1];\\n            dfs(s+1,e,m,n,dp,1);\\n            dfs(s-1,e,m,n,dp,2);\\n            dfs(s,e+1,m,n,dp,3);\\n            dfs(s,e-1,m,n,dp,4);\\n        }\\n        for(auto i:dp) for(auto j:i) if(j==-1) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015258,
                "title": "c-bit-manipulation",
                "content": "# Intuition\\nFirst we need init matrix with information about guards and walls. First we need insert walls there. Then we may insert guards one by one and after every insertion, mark cells guarded until we met another wall or guard.\\nTo avoid TLE we may stop marking cell guarded in this row or column if it was already marked guarded by another guard cell in the same row or column.\\nTo mark that the current cell is guarded by a guard in its row, I set its `1`-bit, to mark cell guarded by a column I used another bit, `2`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        auto mat = vector(m, vector<int>(n, 0));\\n        for (const auto& w : walls)\\n            mat[w[0]][w[1]] = -1;\\n        for (const auto& g : guards) {\\n            mat[g[0]][g[1]] = -1;\\n            for (int i = g[0] - 1; i >= 0 && !(mat[i][g[1]] & 1); --i)\\n                mat[i][g[1]] |= 1;\\n            for (int i = g[0] + 1; i < m && !(mat[i][g[1]] & 1); ++i)\\n                mat[i][g[1]] |= 1;\\n            for (int i = g[1] - 1; i >= 0  && !(mat[g[0]][i] & 2); --i)\\n                mat[g[0]][i] |= 2;\\n            for (int i = g[1] + 1; i < n  && !(mat[g[0]][i] & 2); ++i)\\n                mat[g[0]][i] |= 2;\\n        }\\n        return accumulate(mat.begin(), mat.end(), 0, [](int r, const auto& v) {\\n            return r + count(v.begin(), v.end(), 0);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        auto mat = vector(m, vector<int>(n, 0));\\n        for (const auto& w : walls)\\n            mat[w[0]][w[1]] = -1;\\n        for (const auto& g : guards) {\\n            mat[g[0]][g[1]] = -1;\\n            for (int i = g[0] - 1; i >= 0 && !(mat[i][g[1]] & 1); --i)\\n                mat[i][g[1]] |= 1;\\n            for (int i = g[0] + 1; i < m && !(mat[i][g[1]] & 1); ++i)\\n                mat[i][g[1]] |= 1;\\n            for (int i = g[1] - 1; i >= 0  && !(mat[g[0]][i] & 2); --i)\\n                mat[g[0]][i] |= 2;\\n            for (int i = g[1] + 1; i < n  && !(mat[g[0]][i] & 2); ++i)\\n                mat[g[0]][i] |= 2;\\n        }\\n        return accumulate(mat.begin(), mat.end(), 0, [](int r, const auto& v) {\\n            return r + count(v.begin(), v.end(), 0);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005574,
                "title": "better-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<Units>> objects (m, vector<Units>(n, Units::GREEN));\\n        vector<vector<Units>> grids (m, vector<Units>(n, Units::GREEN));\\n\\n        for (const auto& aWall : walls) {\\n            objects[aWall[0]][aWall[1]] = Units::WALL;\\n        }\\n\\n        for (const auto& aGuard : guards) {\\n            objects[aGuard[0]][aGuard[1]] = Units::GUARD;\\n        }\\n\\n        for (int i = 0; i < m; ++i) {\\n            Units lastCell = Units::GREEN;\\n            for (int j = 0; j < n; ++j)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n\\n            lastCell = Units::GREEN;\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            Units lastCell = Units::GREEN;\\n            for (int i = 0; i < m; ++i)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n\\n            lastCell = Units::GREEN;\\n            for (int i = m - 1; i >= 0; --i)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (objects[i][j] == Units::GREEN && grids[i][j] == Units::GREEN)\\n                    ++result;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\nprivate:\\n    enum class Units : unsigned char {\\n        GREEN = 0,\\n        RED,\\n        GUARD,\\n        WALL\\n    };\\n\\n    void recordOrFill(Units currCell, Units& lastCell, Units& gridCell) {\\n        if (currCell == Units::GUARD)\\n            lastCell = Units::GUARD;\\n        else if (currCell == Units::WALL)\\n            lastCell = Units::GREEN;\\n\\n        if (lastCell == Units::GUARD)\\n            gridCell = Units::GUARD;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<Units>> objects (m, vector<Units>(n, Units::GREEN));\\n        vector<vector<Units>> grids (m, vector<Units>(n, Units::GREEN));\\n\\n        for (const auto& aWall : walls) {\\n            objects[aWall[0]][aWall[1]] = Units::WALL;\\n        }\\n\\n        for (const auto& aGuard : guards) {\\n            objects[aGuard[0]][aGuard[1]] = Units::GUARD;\\n        }\\n\\n        for (int i = 0; i < m; ++i) {\\n            Units lastCell = Units::GREEN;\\n            for (int j = 0; j < n; ++j)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n\\n            lastCell = Units::GREEN;\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            Units lastCell = Units::GREEN;\\n            for (int i = 0; i < m; ++i)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n\\n            lastCell = Units::GREEN;\\n            for (int i = m - 1; i >= 0; --i)\\n            {\\n                recordOrFill(objects[i][j], lastCell, grids[i][j]);\\n            }\\n        }\\n\\n        int result = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                if (objects[i][j] == Units::GREEN && grids[i][j] == Units::GREEN)\\n                    ++result;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\nprivate:\\n    enum class Units : unsigned char {\\n        GREEN = 0,\\n        RED,\\n        GUARD,\\n        WALL\\n    };\\n\\n    void recordOrFill(Units currCell, Units& lastCell, Units& gridCell) {\\n        if (currCell == Units::GUARD)\\n            lastCell = Units::GUARD;\\n        else if (currCell == Units::WALL)\\n            lastCell = Units::GREEN;\\n\\n        if (lastCell == Units::GUARD)\\n            gridCell = Units::GUARD;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963756,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    int ans = 0;\\n    vector<vector<char>> grid(m, vector<char>(n));\\n    vector<vector<char>> left(m, vector<char>(n));\\n    vector<vector<char>> right(m, vector<char>(n));\\n    vector<vector<char>> up(m, vector<char>(n));\\n    vector<vector<char>> down(m, vector<char>(n));\\n\\n    for (const vector<int>& guard : guards)\\n      grid[guard[0]][guard[1]] = \\'G\\';\\n\\n    for (const vector<int>& wall : walls)\\n      grid[wall[0]][wall[1]] = \\'W\\';\\n\\n    for (int i = 0; i < m; ++i) {\\n      char lastCell = 0;\\n      for (int j = 0; j < n; ++j)\\n        recordOrFill(grid[i][j], lastCell, left[i][j]);\\n      lastCell = 0;\\n      for (int j = n - 1; j >= 0; --j)\\n        recordOrFill(grid[i][j], lastCell, right[i][j]);\\n    }\\n\\n    for (int j = 0; j < n; ++j) {\\n      char lastCell = 0;\\n      for (int i = 0; i < m; ++i)\\n        recordOrFill(grid[i][j], lastCell, up[i][j]);\\n      lastCell = 0;\\n      for (int i = m - 1; i >= 0; --i)\\n        recordOrFill(grid[i][j], lastCell, down[i][j]);\\n    }\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (grid[i][j] == 0 && left[i][j] != \\'G\\' && right[i][j] != \\'G\\' &&\\n            up[i][j] != \\'G\\' && down[i][j] != \\'G\\')\\n          ++ans;\\n\\n    return ans;\\n  }\\n\\n private:\\n  void recordOrFill(char currCell, char& lastCell, char& infoCell) {\\n    if (currCell == \\'G\\' || currCell == \\'W\\')\\n      lastCell = currCell;\\n    else\\n      infoCell = lastCell;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    int ans = 0;\\n    vector<vector<char>> grid(m, vector<char>(n));\\n    vector<vector<char>> left(m, vector<char>(n));\\n    vector<vector<char>> right(m, vector<char>(n));\\n    vector<vector<char>> up(m, vector<char>(n));\\n    vector<vector<char>> down(m, vector<char>(n));\\n\\n    for (const vector<int>& guard : guards)\\n      grid[guard[0]][guard[1]] = \\'G\\';\\n\\n    for (const vector<int>& wall : walls)\\n      grid[wall[0]][wall[1]] = \\'W\\';\\n\\n    for (int i = 0; i < m; ++i) {\\n      char lastCell = 0;\\n      for (int j = 0; j < n; ++j)\\n        recordOrFill(grid[i][j], lastCell, left[i][j]);\\n      lastCell = 0;\\n      for (int j = n - 1; j >= 0; --j)\\n        recordOrFill(grid[i][j], lastCell, right[i][j]);\\n    }\\n\\n    for (int j = 0; j < n; ++j) {\\n      char lastCell = 0;\\n      for (int i = 0; i < m; ++i)\\n        recordOrFill(grid[i][j], lastCell, up[i][j]);\\n      lastCell = 0;\\n      for (int i = m - 1; i >= 0; --i)\\n        recordOrFill(grid[i][j], lastCell, down[i][j]);\\n    }\\n\\n    for (int i = 0; i < m; ++i)\\n      for (int j = 0; j < n; ++j)\\n        if (grid[i][j] == 0 && left[i][j] != \\'G\\' && right[i][j] != \\'G\\' &&\\n            up[i][j] != \\'G\\' && down[i][j] != \\'G\\')\\n          ++ans;\\n\\n    return ans;\\n  }\\n\\n private:\\n  void recordOrFill(char currCell, char& lastCell, char& infoCell) {\\n    if (currCell == \\'G\\' || currCell == \\'W\\')\\n      lastCell = currCell;\\n    else\\n      infoCell = lastCell;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890427,
                "title": "solution-using-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid( m, vector<int>(n , 0));\\n        // cantSee =0 , g = 1 , w =2 ,CanSee =3 \\n\\n        for( int i =0; i<g.size()  ; i++){\\n            grid[g[i][0]][g[i][1]] =1;\\n        }\\n         for( int i =0; i<w.size()  ; i++){\\n            grid[w[i][0]][w[i][1]] =2;\\n        }\\n        for( int ii =0; ii< g.size(); ii++)\\n        {\\n            int x =g[ii][0] , y = g[ii][1];\\n            for( int i =x-1 ; i >=0 ; i--){\\n                if( grid[i][y]==2 or grid[i][y]==1)break;\\n                grid[i][y] =3;\\n            }\\n             for( int i =x+1 ; i <m ; i++){\\n                if( grid[i][y]==2 or grid[i][y]==1)break;\\n                grid[i][y] =3;\\n            }\\n            for( int i =y-1 ; i >=0 ; i--){\\n                if( grid[x][i]==2 or grid[x][i]==1)break;\\n                grid[x][i] =3;\\n            }\\n             for( int i =y+1 ; i <n ; i++){\\n                if( grid[x][i]==2 or grid[x][i]==1)break;\\n                grid[x][i] =3;\\n            }\\n        }\\n\\n\\n    int ans =0;\\n    for( int i =0; i <  m ;i ++){\\n        for( int j =0; j < n ; j++){\\n            // cout<<grid[i][j]<<\" \";\\n            if( grid[i][j]==0) ans ++;\\n        }\\n        // cout<<endl;\\n    }\\n    return ans ;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> grid( m, vector<int>(n , 0));\\n        // cantSee =0 , g = 1 , w =2 ,CanSee =3 \\n\\n        for( int i =0; i<g.size()  ; i++){\\n            grid[g[i][0]][g[i][1]] =1;\\n        }\\n         for( int i =0; i<w.size()  ; i++){\\n            grid[w[i][0]][w[i][1]] =2;\\n        }\\n        for( int ii =0; ii< g.size(); ii++)\\n        {\\n            int x =g[ii][0] , y = g[ii][1];\\n            for( int i =x-1 ; i >=0 ; i--){\\n                if( grid[i][y]==2 or grid[i][y]==1)break;\\n                grid[i][y] =3;\\n            }\\n             for( int i =x+1 ; i <m ; i++){\\n                if( grid[i][y]==2 or grid[i][y]==1)break;\\n                grid[i][y] =3;\\n            }\\n            for( int i =y-1 ; i >=0 ; i--){\\n                if( grid[x][i]==2 or grid[x][i]==1)break;\\n                grid[x][i] =3;\\n            }\\n             for( int i =y+1 ; i <n ; i++){\\n                if( grid[x][i]==2 or grid[x][i]==1)break;\\n                grid[x][i] =3;\\n            }\\n        }\\n\\n\\n    int ans =0;\\n    for( int i =0; i <  m ;i ++){\\n        for( int j =0; j < n ; j++){\\n            // cout<<grid[i][j]<<\" \";\\n            if( grid[i][j]==0) ans ++;\\n        }\\n        // cout<<endl;\\n    }\\n    return ans ;    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3809864,
                "title": "python-easy-solution-using-dfs-beats-100",
                "content": "# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        visited = [[0] * n for _ in range(m)]\\n        for i, j in walls:\\n            visited[i][j] = -1\\n        for i, j in guards:\\n            visited[i][j] = -1\\n        def search(i, j):\\n            ans = 0\\n            #up\\n            r = i - 1\\n            while r >= 0 and visited[r][j] != -1:\\n                if visited[r][j] == 0:\\n                    visited[r][j] = 1\\n                    ans += 1\\n                r -= 1\\n            #down\\n            r = i + 1\\n            while r < m and visited[r][j] != -1:\\n                if visited[r][j] == 0:\\n                    visited[r][j] = 1\\n                    ans += 1\\n                r += 1\\n            #left\\n            c = j - 1\\n            while c >= 0 and visited[i][c] != -1:\\n                if visited[i][c] == 0:\\n                    visited[i][c] = 1\\n                    ans += 1\\n                c -= 1\\n            #right\\n            c = j + 1\\n            while c < n and visited[i][c] != -1:\\n                if visited[i][c] == 0:\\n                    visited[i][c] = 1\\n                    ans += 1\\n                c += 1\\n            return ans\\n        ans = m*n\\n        for i, j in guards:\\n            ans -= search(i, j)\\n        return ans - len(guards) - len(walls) \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        visited = [[0] * n for _ in range(m)]\\n        for i, j in walls:\\n            visited[i][j] = -1\\n        for i, j in guards:\\n            visited[i][j] = -1\\n        def search(i, j):\\n            ans = 0\\n            #up\\n            r = i - 1\\n            while r >= 0 and visited[r][j] != -1:\\n                if visited[r][j] == 0:\\n                    visited[r][j] = 1\\n                    ans += 1\\n                r -= 1\\n            #down\\n            r = i + 1\\n            while r < m and visited[r][j] != -1:\\n                if visited[r][j] == 0:\\n                    visited[r][j] = 1\\n                    ans += 1\\n                r += 1\\n            #left\\n            c = j - 1\\n            while c >= 0 and visited[i][c] != -1:\\n                if visited[i][c] == 0:\\n                    visited[i][c] = 1\\n                    ans += 1\\n                c -= 1\\n            #right\\n            c = j + 1\\n            while c < n and visited[i][c] != -1:\\n                if visited[i][c] == 0:\\n                    visited[i][c] = 1\\n                    ans += 1\\n                c += 1\\n            return ans\\n        ans = m*n\\n        for i, j in guards:\\n            ans -= search(i, j)\\n        return ans - len(guards) - len(walls) \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714076,
                "title": "o-n-m-2",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere for every cell i will define two types of scans up-down scan (zero) and left-right scan (one)\\n\\nThis way i will tend to reduce the redendency.\\n# Complexity\\n- Time complexity:O(2mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        map<pair<int,int>,bool>mp;\\n        //mapping coordinates for walls;\\n        for(auto e:walls){\\n            mp[{e[0],e[1]}] = true;\\n        }\\n\\n        //make a vis array of m*n*2;\\n        //the state 0 is for up-down explore and 1 is for left-right explore;\\n        bool vis[m][n][2];\\n        \\n        memset(vis,false,sizeof(vis));\\n        for(auto e:guards){\\n            for(int i = 0;i<2;i++){\\n                int x = e[0],y = e[1];\\n                if(vis[x][y][i])continue;\\n                //if i == 1  then explore possible left-right;\\n                //if i == 0 then explore possible up-down;\\n                if(i == 0){\\n                    vis[x][y][i] = true;\\n                    for(int k = x - 1;k>=0;k--){\\n                        if(mp[{k,y}])break;\\n                        vis[k][y][i] = true;\\n                    }\\n                    for(int k = x + 1;k<m;k++){\\n                        if(mp[{k,y}])break;\\n                        vis[k][y][i] = true;\\n                    }\\n                }\\n                else{\\n                    vis[x][y][i] = true;\\n                    for(int k = y - 1;k>=0;k--){\\n                        if(mp[{x,k}])break;\\n                        vis[x][k][i] = true;\\n                    }\\n                    for(int k = y + 1;k<n;k++){\\n                        if(mp[{x,k}])break;\\n                        vis[x][k][i] = true;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(mp[{i,j}])continue;\\n                if(!(vis[i][j][0] || vis[i][j][1]))ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        map<pair<int,int>,bool>mp;\\n        //mapping coordinates for walls;\\n        for(auto e:walls){\\n            mp[{e[0],e[1]}] = true;\\n        }\\n\\n        //make a vis array of m*n*2;\\n        //the state 0 is for up-down explore and 1 is for left-right explore;\\n        bool vis[m][n][2];\\n        \\n        memset(vis,false,sizeof(vis));\\n        for(auto e:guards){\\n            for(int i = 0;i<2;i++){\\n                int x = e[0],y = e[1];\\n                if(vis[x][y][i])continue;\\n                //if i == 1  then explore possible left-right;\\n                //if i == 0 then explore possible up-down;\\n                if(i == 0){\\n                    vis[x][y][i] = true;\\n                    for(int k = x - 1;k>=0;k--){\\n                        if(mp[{k,y}])break;\\n                        vis[k][y][i] = true;\\n                    }\\n                    for(int k = x + 1;k<m;k++){\\n                        if(mp[{k,y}])break;\\n                        vis[k][y][i] = true;\\n                    }\\n                }\\n                else{\\n                    vis[x][y][i] = true;\\n                    for(int k = y - 1;k>=0;k--){\\n                        if(mp[{x,k}])break;\\n                        vis[x][k][i] = true;\\n                    }\\n                    for(int k = y + 1;k<n;k++){\\n                        if(mp[{x,k}])break;\\n                        vis[x][k][i] = true;\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(mp[{i,j}])continue;\\n                if(!(vis[i][j][0] || vis[i][j][1]))ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583883,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        import numpy as np\\n        self.matrix = [[0 for i in range(n)] for j in range(m)]\\n        wall_set = set()\\n        for a,b in walls:\\n            wall_set.add((a,b))\\n        @cache\\n        def dfs(i,j, flag, direct):\\n            if i<0 or j<0 or i>=m or j>=n:\\n                return \\n            if flag == False:\\n\\n                if (i,j) in wall_set:\\n                    self.matrix[i][j] = 1\\n                    flag = True\\n                else:\\n                    self.matrix[i][j] = 1\\n                    if direct == \\'up\\':\\n                        dfs(i-1,j, flag, direct)\\n                    if direct == \\'left\\':\\n                        dfs(i,j-1, flag, direct)\\n                    if direct == \\'right\\':\\n                        dfs(i,j+1, flag, direct)\\n                    if direct == \\'down\\':\\n                        dfs(i+1,j, flag, direct)\\n\\n            else:\\n                return \\n            return \\n        \\n        for r, c in guards:\\n            up = dfs(r,c, False, \\'up\\')\\n            left = dfs(r,c, False, \\'left\\')\\n            right = dfs(r,c, False, \\'right\\')\\n            down = dfs(r,c, False, \\'down\\')\\n\\n        c=0\\n        for i in range(len(self.matrix)):\\n            for j in range(len(self.matrix[0])):\\n                if (i,j) in wall_set:\\n                    continue\\n                if self.matrix[i][j] == 0:\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        import numpy as np\\n        self.matrix = [[0 for i in range(n)] for j in range(m)]\\n        wall_set = set()\\n        for a,b in walls:\\n            wall_set.add((a,b))\\n        @cache\\n        def dfs(i,j, flag, direct):\\n            if i<0 or j<0 or i>=m or j>=n:\\n                return \\n            if flag == False:\\n\\n                if (i,j) in wall_set:\\n                    self.matrix[i][j] = 1\\n                    flag = True\\n                else:\\n                    self.matrix[i][j] = 1\\n                    if direct == \\'up\\':\\n                        dfs(i-1,j, flag, direct)\\n                    if direct == \\'left\\':\\n                        dfs(i,j-1, flag, direct)\\n                    if direct == \\'right\\':\\n                        dfs(i,j+1, flag, direct)\\n                    if direct == \\'down\\':\\n                        dfs(i+1,j, flag, direct)\\n\\n            else:\\n                return \\n            return \\n        \\n        for r, c in guards:\\n            up = dfs(r,c, False, \\'up\\')\\n            left = dfs(r,c, False, \\'left\\')\\n            right = dfs(r,c, False, \\'right\\')\\n            down = dfs(r,c, False, \\'down\\')\\n\\n        c=0\\n        for i in range(len(self.matrix)):\\n            for j in range(len(self.matrix[0])):\\n                if (i,j) in wall_set:\\n                    continue\\n                if self.matrix[i][j] == 0:\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579998,
                "title": "c-using-specific-direction-traversal",
                "content": "# Intuition\\nThink in terms of blocked cells(Guard facing another guard or any wall).\\n\\n# Approach\\nRun BFS from any guard in a specific direction(up,down,right,left) until another blocked cell is faced.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M . N + guard.length . log(map.size()))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>traverse = {{-1,0},{0,1},{0,-1},{1,0}};\\n    bool isValid(int a,int b, int m,int n,map<pair<int,int>,int>&w,map<pair<int,int>,int>&v){\\n        return a>=0 and b>=0 and a<m and b<n and w.find({a,b})==w.end() and v.find({a,b})==v.end();\\n        \\n    }\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        pair<int,int> i = traverse[0], j = traverse[1];\\n        pair<int,int> x = traverse[2], y = traverse[3];\\n        map<pair<int,int>,int>w,v;\\n        for(auto i:walls){\\n           w[{i[0],i[1]}]++;\\n        }\\n        for(auto i:guards){\\n           w[{i[0],i[1]}]++;\\n        }\\n        for(auto c:guards){\\n            vis[c[0]][c[1]] = true;\\n        }\\n        for(auto c:walls){\\n            vis[c[0]][c[1]] = true;\\n        }\\n        for(auto c:guards){\\n            int a = i.first+c[0], b = i.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n            vis[a][b] = true;\\n            a += i.first, b+= i.second;\\n            \\n            }\\n             a = j.first+c[0], b = j.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n            vis[a][b] = true;\\n            a += j.first, b+= j.second;\\n            \\n            }\\n             a = x.first+c[0], b = x.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n                vis[a][b] = true;\\n            a += x.first, b+= x.second;\\n           \\n            }\\n             a = y.first+c[0], b = y.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n                vis[a][b] = true;\\n            a += y.first, b+= y.second;\\n            \\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                if(!vis[i][j]){ans++;}\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>traverse = {{-1,0},{0,1},{0,-1},{1,0}};\\n    bool isValid(int a,int b, int m,int n,map<pair<int,int>,int>&w,map<pair<int,int>,int>&v){\\n        return a>=0 and b>=0 and a<m and b<n and w.find({a,b})==w.end() and v.find({a,b})==v.end();\\n        \\n    }\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        pair<int,int> i = traverse[0], j = traverse[1];\\n        pair<int,int> x = traverse[2], y = traverse[3];\\n        map<pair<int,int>,int>w,v;\\n        for(auto i:walls){\\n           w[{i[0],i[1]}]++;\\n        }\\n        for(auto i:guards){\\n           w[{i[0],i[1]}]++;\\n        }\\n        for(auto c:guards){\\n            vis[c[0]][c[1]] = true;\\n        }\\n        for(auto c:walls){\\n            vis[c[0]][c[1]] = true;\\n        }\\n        for(auto c:guards){\\n            int a = i.first+c[0], b = i.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n            vis[a][b] = true;\\n            a += i.first, b+= i.second;\\n            \\n            }\\n             a = j.first+c[0], b = j.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n            vis[a][b] = true;\\n            a += j.first, b+= j.second;\\n            \\n            }\\n             a = x.first+c[0], b = x.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n                vis[a][b] = true;\\n            a += x.first, b+= x.second;\\n           \\n            }\\n             a = y.first+c[0], b = y.second+c[1];\\n            while(isValid(a,b,m,n,w,v)){\\n                vis[a][b] = true;\\n            a += y.first, b+= y.second;\\n            \\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                if(!vis[i][j]){ans++;}\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480032,
                "title": "easy-comprehension-is-facilitated-by-a-comprehensive-elucidation-provided-alongside",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe perform a depth-first search (DFS) for each guard in all four possible directions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Establish a temporary map for the purpose of tracking unguarded blocks.\\n2. Designate and categorize all locations of both guards and walls.\\n3. Conduct a Depth-First Search (DFS) on each guard\\'s four directional possibilities.\\n4. Appropriately identify and mark all cells that have been covered.\\n5. Tally the total count of unguarded cells.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(m,n)G) where G is the number of guards\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        # tmp map to keep track on which block is not guarded\\n        tmp_map = [[0 for _ in range(n)] for _ in range(m)] \\n        # label all guards with 1\\n        for [i,j] in guards:\\n            tmp_map[i][j] = 1\\n        # label all walls with -1   \\n        for [i,j] in walls:\\n            tmp_map[i][j] = -1\\n        \\n        # dfs to label all the cells that are guarded by guards\\n        def dfs(i, j, di):\\n            if i<0 or i>=m or j<0 or j>=n or tmp_map[i][j] == 1 or tmp_map[i][j] == -1:\\n                # if out of bound or guarded or wall, return\\n                return\\n            else:\\n                tmp_map[i][j] = 2\\n            # di is the direction of the guard\\n            i = i + lst[di]\\n            j = j + lst[di+1]\\n            dfs(i,j,di)\\n        \\n        # 4 directions\\n        lst = [1, 0, -1, 0, 1]\\n        for [i, j] in guards:\\n            # dfs to label all the cells that are guarded by guards in 4 directions\\n            for idx in range(4):  \\n                k = i + lst[idx]\\n                l = j + lst[idx+1]\\n                dfs(k, l, idx)\\n        \\n        # count uncovered cells.\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if tmp_map[i][j] == 0:\\n                    count += 1\\n        return count\\n\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        # tmp map to keep track on which block is not guarded\\n        tmp_map = [[0 for _ in range(n)] for _ in range(m)] \\n        # label all guards with 1\\n        for [i,j] in guards:\\n            tmp_map[i][j] = 1\\n        # label all walls with -1   \\n        for [i,j] in walls:\\n            tmp_map[i][j] = -1\\n        \\n        # dfs to label all the cells that are guarded by guards\\n        def dfs(i, j, di):\\n            if i<0 or i>=m or j<0 or j>=n or tmp_map[i][j] == 1 or tmp_map[i][j] == -1:\\n                # if out of bound or guarded or wall, return\\n                return\\n            else:\\n                tmp_map[i][j] = 2\\n            # di is the direction of the guard\\n            i = i + lst[di]\\n            j = j + lst[di+1]\\n            dfs(i,j,di)\\n        \\n        # 4 directions\\n        lst = [1, 0, -1, 0, 1]\\n        for [i, j] in guards:\\n            # dfs to label all the cells that are guarded by guards in 4 directions\\n            for idx in range(4):  \\n                k = i + lst[idx]\\n                l = j + lst[idx+1]\\n                dfs(k, l, idx)\\n        \\n        # count uncovered cells.\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if tmp_map[i][j] == 0:\\n                    count += 1\\n        return count\\n\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470072,
                "title": "easy-java-begineer-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int ans[][];\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int mat[][]=new int[m][n];\\n        ans=new int[m][n];\\n        for(int i=0;i<guards.length;i++){\\n            mat[guards[i][0]][guards[i][1]]=1;\\n            ans[guards[i][0]][guards[i][1]]=1;\\n        }\\n        for(int i=0;i<walls.length;i++){\\n            mat[walls[i][0]][walls[i][1]]=-1;\\n            ans[walls[i][0]][walls[i][1]]=-1;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    dfs(i,j,m,n,mat);\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(ans[i][j]==0)res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int r,int c,int m,int n,int mat[][]){\\n        int r1=r+1;\\n        int r2=r-1;\\n        int c1=c+1;\\n        int c2=c-1;\\n        while(c1<n){\\n            if(mat[r][c1]==1)break;\\n            else if(mat[r][c1]==-1)break;\\n            ans[r][c1]=1;\\n            c1++;\\n        }\\n        while(c2>=0){\\n            if(mat[r][c2]==1)break;\\n            else if(mat[r][c2]==-1)break;\\n            ans[r][c2]=1;\\n            c2--;\\n        }\\n        while(r1<m){\\n            if(mat[r1][c]==1)break;\\n            else if(mat[r1][c]==-1)break;\\n            ans[r1][c]=1;\\n            r1++;\\n        }\\n        while(r2>=0){\\n            if(mat[r2][c]==1)break;\\n            else if(mat[r2][c]==-1)break;\\n            ans[r2][c]=1;\\n            r2--;\\n        }\\n    }\\n}\\n//guard-1\\n//not guard-0\\n//wall--1\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    int ans[][];\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int mat[][]=new int[m][n];\\n        ans=new int[m][n];\\n        for(int i=0;i<guards.length;i++){\\n            mat[guards[i][0]][guards[i][1]]=1;\\n            ans[guards[i][0]][guards[i][1]]=1;\\n        }\\n        for(int i=0;i<walls.length;i++){\\n            mat[walls[i][0]][walls[i][1]]=-1;\\n            ans[walls[i][0]][walls[i][1]]=-1;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    dfs(i,j,m,n,mat);\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(ans[i][j]==0)res++;\\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int r,int c,int m,int n,int mat[][]){\\n        int r1=r+1;\\n        int r2=r-1;\\n        int c1=c+1;\\n        int c2=c-1;\\n        while(c1<n){\\n            if(mat[r][c1]==1)break;\\n            else if(mat[r][c1]==-1)break;\\n            ans[r][c1]=1;\\n            c1++;\\n        }\\n        while(c2>=0){\\n            if(mat[r][c2]==1)break;\\n            else if(mat[r][c2]==-1)break;\\n            ans[r][c2]=1;\\n            c2--;\\n        }\\n        while(r1<m){\\n            if(mat[r1][c]==1)break;\\n            else if(mat[r1][c]==-1)break;\\n            ans[r1][c]=1;\\n            r1++;\\n        }\\n        while(r2>=0){\\n            if(mat[r2][c]==1)break;\\n            else if(mat[r2][c]==-1)break;\\n            ans[r2][c]=1;\\n            r2--;\\n        }\\n    }\\n}\\n//guard-1\\n//not guard-0\\n//wall--1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459614,
                "title": "simple-java-solution",
                "content": "# Tip\\nYou Should stop seeing perticular direction if you came across any gaurd or wall\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif gaurd ==> cell be 1;\\nif wall ==> cell be 2;\\nif the cell can be seen by any gaurd then ==> cell be 3;\\nyou can check that by looping through all the four directions\\n\\nAt the end the answer will be no of cells with \"-1\".\\n\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] grid = new int[m][n];\\n        for(int[] i:grid){\\n            Arrays.fill(i,-1);\\n        }\\n        for(int i[]:guards){\\n            grid[i[0]][i[1]] = 1;\\n        }\\n        for(int i[]:walls){\\n            grid[i[0]][i[1]] = 2;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) helper(i,j,grid);\\n            }\\n        }\\n        int answer = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++) if(grid[i][j]==-1) answer++;\\n        }\\n        return answer;\\n    }\\n    public void helper(int row,int col,int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=col+1;i<n;i++){\\n            if(grid[row][i]==-1) grid[row][i] = 3;\\n            if(grid[row][i]==2||grid[row][i]==1) break;\\n        }\\n        for(int i=col-1;i>=0;i--){\\n            if(grid[row][i]==-1) grid[row][i] = 3;\\n            if(grid[row][i]==2||grid[row][i]==1) break;\\n        }\\n        for(int i=row+1;i<m;i++){\\n            if(grid[i][col]==-1) grid[i][col] = 3;\\n            if(grid[i][col]==2||grid[i][col]==1) break;\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            if(grid[i][col]==-1) grid[i][col] = 3;\\n            if(grid[i][col]==2||grid[i][col]==1) break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] grid = new int[m][n];\\n        for(int[] i:grid){\\n            Arrays.fill(i,-1);\\n        }\\n        for(int i[]:guards){\\n            grid[i[0]][i[1]] = 1;\\n        }\\n        for(int i[]:walls){\\n            grid[i[0]][i[1]] = 2;\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) helper(i,j,grid);\\n            }\\n        }\\n        int answer = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++) if(grid[i][j]==-1) answer++;\\n        }\\n        return answer;\\n    }\\n    public void helper(int row,int col,int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for(int i=col+1;i<n;i++){\\n            if(grid[row][i]==-1) grid[row][i] = 3;\\n            if(grid[row][i]==2||grid[row][i]==1) break;\\n        }\\n        for(int i=col-1;i>=0;i--){\\n            if(grid[row][i]==-1) grid[row][i] = 3;\\n            if(grid[row][i]==2||grid[row][i]==1) break;\\n        }\\n        for(int i=row+1;i<m;i++){\\n            if(grid[i][col]==-1) grid[i][col] = 3;\\n            if(grid[i][col]==2||grid[i][col]==1) break;\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            if(grid[i][col]==-1) grid[i][col] = 3;\\n            if(grid[i][col]==2||grid[i][col]==1) break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446868,
                "title": "100-fast-simple-java-solution-with-intuition-and-code",
                "content": "# Intuition\\nIntuition in simple, we have to find the number of unseen cells, i.e. the number of cells not seen by any guards, For that we need to create a matrix of size =m*n; now instead of taking it an integer matrix , I took a character matrix as it takes lesser space as compared to an integer matrix.\\n\\n# Approach\\n\\nI will createa matrix to mark the position of walls, guards and cells.I will store count= m*n as the number of cells. I will subtract the position of guards and walls while I mark their positions. Once I marked, I will place the index of all the guards as a pair {row,col} in a queue dataStructure. Take out one pair out one by one , Each time we will go in all the 4 directions until I get to a wall or a guard or onr of the 4 ends. In this traversal I will subtract each time I find an unvisited cell as that cell will be converted into a visited cell \\'R\\'.\\nAt the end of the day I will be left with the count of all remaining safe cells unseen by the guads.\\n\\n# Complexity\\n- Time complexity:\\nO(n*4)\\n- Space complexity:\\nO(m*n);\\n# Code\\n```\\nclass Solution {\\n    private class pair{\\n        int r;int c;\\n        public pair(int r,int c){\\n            this.r=r;\\n            this.c=c;\\n        }\\n    }\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        char[][]grid=new char[m][n];\\n        Queue<pair>q=new LinkedList<pair>();\\n        int count=m*n;\\n        for(int i=0;i<guards.length;i++){\\n            grid[guards[i][0]][guards[i][1]]=\\'G\\';\\n            q.add(new pair(guards[i][0],guards[i][1]));\\n            count--;\\n        }\\n        for(int i=0;i<walls.length;i++){\\n            grid[walls[i][0]][walls[i][1]]=\\'W\\';\\n            count--;\\n        } \\n        int delRow[]={-1,0,1,0};      \\n        int delCol[]={0,1,0,-1};\\n        while(!q.isEmpty()){\\n            int r=q.peek().r;\\n            int c=q.peek().c;\\n            q.remove();\\n            for(int i=0;i<4;i++){\\n                int nrow=r+delRow[i];\\n                int ncol=c+delCol[i];\\n                while(nrow>=0&&nrow<m&&ncol>=0&&ncol<n&&(grid[nrow][ncol]!=\\'W\\'&&grid[nrow][ncol]!=\\'G\\')){\\n                    if(grid[nrow][ncol]!=\\'R\\'){\\n                        count--;\\n                    }\\n                    grid[nrow][ncol]=\\'R\\';\\n                    nrow+=delRow[i];\\n                    ncol+=delCol[i];\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private class pair{\\n        int r;int c;\\n        public pair(int r,int c){\\n            this.r=r;\\n            this.c=c;\\n        }\\n    }\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        char[][]grid=new char[m][n];\\n        Queue<pair>q=new LinkedList<pair>();\\n        int count=m*n;\\n        for(int i=0;i<guards.length;i++){\\n            grid[guards[i][0]][guards[i][1]]=\\'G\\';\\n            q.add(new pair(guards[i][0],guards[i][1]));\\n            count--;\\n        }\\n        for(int i=0;i<walls.length;i++){\\n            grid[walls[i][0]][walls[i][1]]=\\'W\\';\\n            count--;\\n        } \\n        int delRow[]={-1,0,1,0};      \\n        int delCol[]={0,1,0,-1};\\n        while(!q.isEmpty()){\\n            int r=q.peek().r;\\n            int c=q.peek().c;\\n            q.remove();\\n            for(int i=0;i<4;i++){\\n                int nrow=r+delRow[i];\\n                int ncol=c+delCol[i];\\n                while(nrow>=0&&nrow<m&&ncol>=0&&ncol<n&&(grid[nrow][ncol]!=\\'W\\'&&grid[nrow][ncol]!=\\'G\\')){\\n                    if(grid[nrow][ncol]!=\\'R\\'){\\n                        count--;\\n                    }\\n                    grid[nrow][ncol]=\\'R\\';\\n                    nrow+=delRow[i];\\n                    ncol+=delCol[i];\\n                }\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434656,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func countUnguarded(_ m: Int, _ n: Int, _ guards: [[Int]], _ walls: [[Int]]) -> Int {\\n        \\n        var cells = Array(repeating: Array(repeating: 1, count: n), count: m)\\n\\n        for w in walls { cells[w[0]][w[1]] = -1 }\\n        for g in guards { cells[g[0]][g[1]] = -1 }\\n\\n        for g in guards {\\n\\n            for x in (0..<g[0]).reversed() {\\n                guard cells[x][g[1]] != -1 else { break }\\n                cells[x][g[1]] = 0\\n            }\\n\\n            for x in (g[0]..<m).dropFirst() {\\n                guard cells[x][g[1]] != -1 else { break }\\n                cells[x][g[1]] = 0\\n            }\\n\\n            for y in (0..<g[1]).reversed() {\\n                guard cells[g[0]][y] != -1 else { break }\\n                cells[g[0]][y] = 0\\n            }\\n\\n            for y in (g[1]..<n).dropFirst() {\\n                guard cells[g[0]][y] != -1 else { break }\\n                cells[g[0]][y] = 0\\n            }\\n        }\\n\\n        return cells\\n            .map { $0.reduce(0) { $0 + max($1, 0) } }\\n            .reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countUnguarded(_ m: Int, _ n: Int, _ guards: [[Int]], _ walls: [[Int]]) -> Int {\\n        \\n        var cells = Array(repeating: Array(repeating: 1, count: n), count: m)\\n\\n        for w in walls { cells[w[0]][w[1]] = -1 }\\n        for g in guards { cells[g[0]][g[1]] = -1 }\\n\\n        for g in guards {\\n\\n            for x in (0..<g[0]).reversed() {\\n                guard cells[x][g[1]] != -1 else { break }\\n                cells[x][g[1]] = 0\\n            }\\n\\n            for x in (g[0]..<m).dropFirst() {\\n                guard cells[x][g[1]] != -1 else { break }\\n                cells[x][g[1]] = 0\\n            }\\n\\n            for y in (0..<g[1]).reversed() {\\n                guard cells[g[0]][y] != -1 else { break }\\n                cells[g[0]][y] = 0\\n            }\\n\\n            for y in (g[1]..<n).dropFirst() {\\n                guard cells[g[0]][y] != -1 else { break }\\n                cells[g[0]][y] = 0\\n            }\\n        }\\n\\n        return cells\\n            .map { $0.reduce(0) { $0 + max($1, 0) } }\\n            .reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416939,
                "title": "c-brute-force-ac",
                "content": "# Intuition\\nVisit all 4 directions of a guard which can be visited.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(n,vector<char>(m,\\'0\\'));\\n        for(int i=0;i<guards.size();i++)\\n        {\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            grid[r][c] = \\'G\\';\\n        }\\n        for(int i=0;i<walls.size();i++)\\n        {\\n            int r = walls[i][0];\\n            int c = walls[i][1];\\n            grid[r][c] = \\'W\\';\\n        }\\n        for(int i=0;i<guards.size();i++)\\n        {\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(grid[r][j]==\\'W\\' || grid[r][j]==\\'G\\')\\n                break;\\n                if(grid[r][j]==\\'0\\')\\n                grid[r][j] = \\'1\\';\\n            }\\n            for(int j=c+1;j<m;j++)\\n            {\\n                if(grid[r][j]==\\'W\\' || grid[r][j]==\\'G\\')\\n                break;\\n                if(grid[r][j]==\\'0\\')\\n                grid[r][j] = \\'1\\';\\n            }\\n            for(int j=r-1;j>=0;j--)\\n            {\\n                if(grid[j][c]==\\'W\\' || grid[j][c]==\\'G\\')\\n                break;\\n                if(grid[j][c]==\\'0\\')\\n                grid[j][c] = \\'1\\';\\n            }\\n            for(int j=r+1;j<n;j++)\\n            {\\n                if(grid[j][c]==\\'W\\' || grid[j][c]==\\'G\\')\\n                break;\\n                if(grid[j][c]==\\'0\\')\\n                grid[j][c] = \\'1\\';\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'0\\')\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(n,vector<char>(m,\\'0\\'));\\n        for(int i=0;i<guards.size();i++)\\n        {\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            grid[r][c] = \\'G\\';\\n        }\\n        for(int i=0;i<walls.size();i++)\\n        {\\n            int r = walls[i][0];\\n            int c = walls[i][1];\\n            grid[r][c] = \\'W\\';\\n        }\\n        for(int i=0;i<guards.size();i++)\\n        {\\n            int r = guards[i][0];\\n            int c = guards[i][1];\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(grid[r][j]==\\'W\\' || grid[r][j]==\\'G\\')\\n                break;\\n                if(grid[r][j]==\\'0\\')\\n                grid[r][j] = \\'1\\';\\n            }\\n            for(int j=c+1;j<m;j++)\\n            {\\n                if(grid[r][j]==\\'W\\' || grid[r][j]==\\'G\\')\\n                break;\\n                if(grid[r][j]==\\'0\\')\\n                grid[r][j] = \\'1\\';\\n            }\\n            for(int j=r-1;j>=0;j--)\\n            {\\n                if(grid[j][c]==\\'W\\' || grid[j][c]==\\'G\\')\\n                break;\\n                if(grid[j][c]==\\'0\\')\\n                grid[j][c] = \\'1\\';\\n            }\\n            for(int j=r+1;j<n;j++)\\n            {\\n                if(grid[j][c]==\\'W\\' || grid[j][c]==\\'G\\')\\n                break;\\n                if(grid[j][c]==\\'0\\')\\n                grid[j][c] = \\'1\\';\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==\\'0\\')\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413013,
                "title": "highly-explained-entire-thought-process-c-o-n-m-space-and-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought for a long time, how to do it better than brute force solution, but anything didn\\'t came in my mind. So, i decided to write the brute force solution.So, while writing i came up with a thought that if a guard has already visited a particular cell in that direction, then the cell is guarded, if any others guard is present in the path in that direction, so he need not to visit all the cells in that direction, G----G----- i.e if the path is visited by one guard while in that direction, other guard need not to travel in the same direction as all path are already visited by first guard\\n\\n\\nLet us try to understand it!\\nG..........\\nthe path first guard visited in that direction.\\nif after, there is also a guard in that path\\nG...G...... he need not to visit the cell in that direction\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. A matrix of size m*n is created and intialised to 0\\n2. To check for the walls, it is marked as 1\\n3. We start iterate over the guards\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int arr[m][n], count = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++) arr[i][j] = 0;\\n        }\\n\\n        for(auto &it : walls){\\n            arr[it[0]][it[1]] = 1;\\n        }\\n\\n        // if left = 3, right = 4, top = 5, bottom = 6;\\n\\n        for(auto &it : guards){\\n            int row = it[0], col = it[1];\\n            arr[row][col] = 2;\\n            //travelling towards upward, break if guard is present, wall, already traverse by some guard in that direction.\\n            for(int i = row-1 ; i >= 0 ; i--){\\n                if(arr[i][col] == 1 || arr[i][col] == 2 || arr[i][col] == 5) break;\\n                arr[i][col] = 5; \\n            }\\n            //traversing towards downward\\n            for(int i = row+1 ; i < m ; i++){\\n                if(arr[i][col] == 1 || arr[i][col] == 2 || arr[i][col] == 6) break;\\n                arr[i][col] = 6;\\n            }\\n            //traversing towards left\\n            for(int j = col-1; j >= 0 ; j--){\\n                if(arr[row][j] == 1 || arr[row][j] == 2 || arr[row][j] == 3) break;\\n                arr[row][j] = 3;\\n            }\\n            //traversing towards right\\n            for(int j = col+1; j < n ; j++){\\n                if(arr[row][j] == 1 || arr[row][j] == 2 || arr[row][j] == 4) break;\\n                arr[row][j] = 4;\\n            }\\n        }\\n        \\n        for(int i = 0; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(arr[i][j] == 0) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nIf you find it useful, please upvote it!",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int arr[m][n], count = 0;\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++) arr[i][j] = 0;\\n        }\\n\\n        for(auto &it : walls){\\n            arr[it[0]][it[1]] = 1;\\n        }\\n\\n        // if left = 3, right = 4, top = 5, bottom = 6;\\n\\n        for(auto &it : guards){\\n            int row = it[0], col = it[1];\\n            arr[row][col] = 2;\\n            //travelling towards upward, break if guard is present, wall, already traverse by some guard in that direction.\\n            for(int i = row-1 ; i >= 0 ; i--){\\n                if(arr[i][col] == 1 || arr[i][col] == 2 || arr[i][col] == 5) break;\\n                arr[i][col] = 5; \\n            }\\n            //traversing towards downward\\n            for(int i = row+1 ; i < m ; i++){\\n                if(arr[i][col] == 1 || arr[i][col] == 2 || arr[i][col] == 6) break;\\n                arr[i][col] = 6;\\n            }\\n            //traversing towards left\\n            for(int j = col-1; j >= 0 ; j--){\\n                if(arr[row][j] == 1 || arr[row][j] == 2 || arr[row][j] == 3) break;\\n                arr[row][j] = 3;\\n            }\\n            //traversing towards right\\n            for(int j = col+1; j < n ; j++){\\n                if(arr[row][j] == 1 || arr[row][j] == 2 || arr[row][j] == 4) break;\\n                arr[row][j] = 4;\\n            }\\n        }\\n        \\n        for(int i = 0; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(arr[i][j] == 0) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329202,
                "title": "c-golang-simulation",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(m, vector<char>(n, -1));\\n        int cannotVisit = walls.size() + guards.size();\\n        for(vector<int> wall: walls) {\\n            grid[wall[0]][wall[1]] = 0;\\n        }\\n        for(vector<int> guard: guards) {\\n            grid[guard[0]][guard[1]] = 0;\\n        }\\n        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for(vector<int> guard: guards) {\\n            for(auto dir: dirs) {\\n                for(int i = 1; ; i++) {\\n                    int x = guard[0] + i * dir[0];\\n                    int y = guard[1] + i * dir[1];\\n                    if(x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) break;\\n                    cannotVisit += grid[x][y] == -1;\\n                    grid[x][y] = 1;\\n                }\\n            }\\n        }\\n        return m * n - cannotVisit;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n    grid := make([][]int, m)\\n    for i := 0; i < m; i++ {grid[i] = make([]int, n)} \\n    for _, wall := range walls {\\n        grid[wall[0]][wall[1]] = 1\\n    }\\n    for _, guard := range guards {\\n        grid[guard[0]][guard[1]] = 1\\n    }\\n    dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n    cannotVisit := len(guards) + len(walls)\\n    for _, guard := range guards {\\n        for _, dir := range dirs {\\n            for i := 1; ; i++ {\\n                x := guard[0] + i * dir[0]\\n                y := guard[1] + i * dir[1]\\n                if x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 1 {break}\\n                if grid[x][y] == 0 {cannotVisit++}\\n                grid[x][y] = 2\\n            }\\n        }\\n    }\\n    return m * n - cannotVisit\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(m, vector<char>(n, -1));\\n        int cannotVisit = walls.size() + guards.size();\\n        for(vector<int> wall: walls) {\\n            grid[wall[0]][wall[1]] = 0;\\n        }\\n        for(vector<int> guard: guards) {\\n            grid[guard[0]][guard[1]] = 0;\\n        }\\n        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for(vector<int> guard: guards) {\\n            for(auto dir: dirs) {\\n                for(int i = 1; ; i++) {\\n                    int x = guard[0] + i * dir[0];\\n                    int y = guard[1] + i * dir[1];\\n                    if(x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) break;\\n                    cannotVisit += grid[x][y] == -1;\\n                    grid[x][y] = 1;\\n                }\\n            }\\n        }\\n        return m * n - cannotVisit;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n    grid := make([][]int, m)\\n    for i := 0; i < m; i++ {grid[i] = make([]int, n)} \\n    for _, wall := range walls {\\n        grid[wall[0]][wall[1]] = 1\\n    }\\n    for _, guard := range guards {\\n        grid[guard[0]][guard[1]] = 1\\n    }\\n    dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\\n    cannotVisit := len(guards) + len(walls)\\n    for _, guard := range guards {\\n        for _, dir := range dirs {\\n            for i := 1; ; i++ {\\n                x := guard[0] + i * dir[0]\\n                y := guard[1] + i * dir[1]\\n                if x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 1 {break}\\n                if grid[x][y] == 0 {cannotVisit++}\\n                grid[x][y] = 2\\n            }\\n        }\\n    }\\n    return m * n - cannotVisit\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321844,
                "title": "very-simple-python-just-made-the-given-picture-still-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCould definiently make this faster, it does only check one given direction at a time, but it still gets the job done, and is pretty easy to follow.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        matrix = [[\\'g\\' for i in range(n)] for i in range(m)]\\n        for i in guards:\\n            matrix[i[0]][i[1]] = \\'G\\'\\n        for i in walls:\\n            matrix[i[0]][i[1]] = \\'W\\' \\n        \\n        \\'\\'\\'\\n        matrix = [[\\'G\\',\\'W\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\'],\\n                  [\\'g\\',\\'G\\',\\'g\\',\\'g\\',\\'W\\',\\'g\\'],\\n                  [\\'g\\',\\'g\\',\\'W\\',\\'G\\',\\'g\\',\\'g\\'],\\n                  [\\'g\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\']]\\n        wanted to match the picture\\n\\n        \\'G\\' = Guard\\n        \\'W\\' = Wall\\n        \\'g\\' = green, not seen by guard\\n        \\'r\\' = red, seen by guard\\n        \\'\\'\\'\\n\\n        count = 0\\n        for x,y in guards:\\n            if x > 0: # checks left of the current guard\\n                for j in range(x-1,-1,-1):\\n                    curr = matrix[j][y]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[j][y]=\\'r\\'\\n\\n            if x < m-1: # checks right of the current guard\\n                for j in range(x+1,m):\\n                    curr = matrix[j][y]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[j][y]=\\'r\\'\\n            \\n            if y > 0: # checks above of the current guard\\n                for j in range(y-1,-1,-1):\\n                    curr = matrix[x][j]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[x][j]=\\'r\\'\\n            \\n            if y < n-1: # checks below of the current guard\\n                for j in range(y+1,n):\\n                    curr = matrix[x][j]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[x][j]=\\'r\\'\\n        \\n        for i in matrix: # goes through matrix counting green boxes\\n            for j in i:\\n                if j == \\'g\\':\\n                    count += 1       \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        matrix = [[\\'g\\' for i in range(n)] for i in range(m)]\\n        for i in guards:\\n            matrix[i[0]][i[1]] = \\'G\\'\\n        for i in walls:\\n            matrix[i[0]][i[1]] = \\'W\\' \\n        \\n        \\'\\'\\'\\n        matrix = [[\\'G\\',\\'W\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\'],\\n                  [\\'g\\',\\'G\\',\\'g\\',\\'g\\',\\'W\\',\\'g\\'],\\n                  [\\'g\\',\\'g\\',\\'W\\',\\'G\\',\\'g\\',\\'g\\'],\\n                  [\\'g\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\',\\'g\\']]\\n        wanted to match the picture\\n\\n        \\'G\\' = Guard\\n        \\'W\\' = Wall\\n        \\'g\\' = green, not seen by guard\\n        \\'r\\' = red, seen by guard\\n        \\'\\'\\'\\n\\n        count = 0\\n        for x,y in guards:\\n            if x > 0: # checks left of the current guard\\n                for j in range(x-1,-1,-1):\\n                    curr = matrix[j][y]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[j][y]=\\'r\\'\\n\\n            if x < m-1: # checks right of the current guard\\n                for j in range(x+1,m):\\n                    curr = matrix[j][y]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[j][y]=\\'r\\'\\n            \\n            if y > 0: # checks above of the current guard\\n                for j in range(y-1,-1,-1):\\n                    curr = matrix[x][j]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[x][j]=\\'r\\'\\n            \\n            if y < n-1: # checks below of the current guard\\n                for j in range(y+1,n):\\n                    curr = matrix[x][j]\\n                    if curr == \\'W\\' or curr == \\'G\\':\\n                        break\\n                    else:\\n                        matrix[x][j]=\\'r\\'\\n        \\n        for i in matrix: # goes through matrix counting green boxes\\n            for j in i:\\n                if j == \\'g\\':\\n                    count += 1       \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314900,
                "title": "python-simple-clean-and-commented-code-o-n-2",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        res = [[1]*n for _ in range(m)]\\n        cnt = 0 # count of guarded cells\\n        \\n        # mark all the walls\\n        for wall in walls:\\n            r, c = wall[0], wall[1]\\n            res[r][c] = -1\\n            # every wall is a guarded cell\\n            cnt += 1\\n        \\n        # mark all the guards\\n        for guard in guards:\\n            r, c = guard[0], guard[1]\\n            res[r][c] = -1\\n            # every guard is a guarded cell\\n            cnt += 1\\n            \\n        # check if a point is within the bounds of the grid\\n        def is_valid(r, c):\\n            if r < 0 or r >= m or c < 0 or c >= n: return False\\n            return True\\n        \\n        # function to mark the guarded cells\\n        def mark_cells(x, y, r, c, cnt):\\n            while is_valid(r+x, c+y):\\n                r += x\\n                c += y\\n                # if cell is a wall or guard, return the same count\\n                if res[r][c] == -1:\\n                    return cnt\\n                \\n                # if cell is not a wall or not a guard\\n                # and you visit it for the same time, increase the count of guarded cells\\n                if res[r][c] != 0: \\n                    cnt += 1\\n                \\n                # mark the cell as guarded\\n                res[r][c] = 0\\n            return cnt\\n        \\n        \\n        # 4 cardinal directions\\n        dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]]\\n        \\n        # for every guard,\\n        # mark cells in all 4 cardnal directions\\n        for guard in guards:\\n            for cord in dirs:\\n                cnt = mark_cells(cord[0], cord[1], guard[0], guard[1], cnt)\\n        \\n        # unguarded cells = total cells - guarded cells\\n        unguarded = (m*n) - cnt\\n        return unguarded\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        res = [[1]*n for _ in range(m)]\\n        cnt = 0 # count of guarded cells\\n        \\n        # mark all the walls\\n        for wall in walls:\\n            r, c = wall[0], wall[1]\\n            res[r][c] = -1\\n            # every wall is a guarded cell\\n            cnt += 1\\n        \\n        # mark all the guards\\n        for guard in guards:\\n            r, c = guard[0], guard[1]\\n            res[r][c] = -1\\n            # every guard is a guarded cell\\n            cnt += 1\\n            \\n        # check if a point is within the bounds of the grid\\n        def is_valid(r, c):\\n            if r < 0 or r >= m or c < 0 or c >= n: return False\\n            return True\\n        \\n        # function to mark the guarded cells\\n        def mark_cells(x, y, r, c, cnt):\\n            while is_valid(r+x, c+y):\\n                r += x\\n                c += y\\n                # if cell is a wall or guard, return the same count\\n                if res[r][c] == -1:\\n                    return cnt\\n                \\n                # if cell is not a wall or not a guard\\n                # and you visit it for the same time, increase the count of guarded cells\\n                if res[r][c] != 0: \\n                    cnt += 1\\n                \\n                # mark the cell as guarded\\n                res[r][c] = 0\\n            return cnt\\n        \\n        \\n        # 4 cardinal directions\\n        dirs = [[-1, 0], [0, 1], [1, 0], [0, -1]]\\n        \\n        # for every guard,\\n        # mark cells in all 4 cardnal directions\\n        for guard in guards:\\n            for cord in dirs:\\n                cnt = mark_cells(cord[0], cord[1], guard[0], guard[1], cnt)\\n        \\n        # unguarded cells = total cells - guarded cells\\n        unguarded = (m*n) - cnt\\n        return unguarded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308178,
                "title": "c-solution-95-faster-detailed-comments-included",
                "content": "**Please do upvote \\u2B06\\uFE0F the solution to keep me motivated :)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int cnt = 0;\\n\\n        // create a visited array to mark those cells which are guarded by the guards.\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n\\n        // mark the guard\\'s positions as 2\\n        for(auto& it:guards) {\\n            vis[it[0]][it[1]] = 2;\\n        }\\n\\n        // mark the walls\\'s positions as 3    \\n        for(auto& it:walls) {\\n            vis[it[0]][it[1]] = 3;\\n        }\\n\\n        for(auto& it:guards) {\\n            // mark row if possible\\n            // mark left part\\n            int r,c;\\n            r = it[0];\\n            c = it[1]-1;\\n            while(c>=0) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                c--;\\n            }\\n\\n            // mark right part\\n            c = it[1]+1;\\n            while(c<n) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                c++;\\n            }\\n\\n            // mark top part\\n            r = it[0]-1;\\n            c = it[1];\\n            while(r>=0) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                r--;\\n            }\\n\\n            // mark bottom part\\n            r = it[0]+1;\\n            c = it[1];\\n            while(r<m) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                r++;\\n            }\\n        }\\n\\n        // count unguarded cells\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(vis[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int cnt = 0;\\n\\n        // create a visited array to mark those cells which are guarded by the guards.\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n\\n        // mark the guard\\'s positions as 2\\n        for(auto& it:guards) {\\n            vis[it[0]][it[1]] = 2;\\n        }\\n\\n        // mark the walls\\'s positions as 3    \\n        for(auto& it:walls) {\\n            vis[it[0]][it[1]] = 3;\\n        }\\n\\n        for(auto& it:guards) {\\n            // mark row if possible\\n            // mark left part\\n            int r,c;\\n            r = it[0];\\n            c = it[1]-1;\\n            while(c>=0) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                c--;\\n            }\\n\\n            // mark right part\\n            c = it[1]+1;\\n            while(c<n) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                c++;\\n            }\\n\\n            // mark top part\\n            r = it[0]-1;\\n            c = it[1];\\n            while(r>=0) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                r--;\\n            }\\n\\n            // mark bottom part\\n            r = it[0]+1;\\n            c = it[1];\\n            while(r<m) {\\n                if(vis[r][c]==2 || vis[r][c]==3) break;\\n                else if(vis[r][c]==0) vis[r][c]=1;\\n                r++;\\n            }\\n        }\\n\\n        // count unguarded cells\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(vis[i][j]==0) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296117,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>> grid(m, vector<int> (n,0));\\n        for(auto guard: guards)\\n        {\\n            grid[guard[0]][guard[1]]=2;\\n        }\\n        for(auto wall: walls)\\n        {\\n            grid[wall[0]][wall[1]]=3;\\n        }\\n        for(auto guard: guards)\\n        {\\n            int r=guard[0], c=guard[1];\\n            int x=r-1, y=c;\\n            while(x>=0 && grid[x][y]!=2 && grid[x][y]!=3) grid[x--][y]=1;\\n            x=r+1;\\n            while(x<m && grid[x][y]!=2 && grid[x][y]!=3) grid[x++][y]=1;\\n            x=r,y=c-1;\\n            while(y>=0 && grid[x][y]!=2 && grid[x][y]!=3) grid[x][y--]=1;\\n            y=c+1;\\n            while(y<n && grid[x][y]!=2 && grid[x][y]!=3) grid[x][y++]=1;\\n        }\\n        int ans=0;\\n        for(int x=0; x<m; x++)\\n        {\\n            for(int y=0; y<n; y++) if(!grid[x][y]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>> grid(m, vector<int> (n,0));\\n        for(auto guard: guards)\\n        {\\n            grid[guard[0]][guard[1]]=2;\\n        }\\n        for(auto wall: walls)\\n        {\\n            grid[wall[0]][wall[1]]=3;\\n        }\\n        for(auto guard: guards)\\n        {\\n            int r=guard[0], c=guard[1];\\n            int x=r-1, y=c;\\n            while(x>=0 && grid[x][y]!=2 && grid[x][y]!=3) grid[x--][y]=1;\\n            x=r+1;\\n            while(x<m && grid[x][y]!=2 && grid[x][y]!=3) grid[x++][y]=1;\\n            x=r,y=c-1;\\n            while(y>=0 && grid[x][y]!=2 && grid[x][y]!=3) grid[x][y--]=1;\\n            y=c+1;\\n            while(y<n && grid[x][y]!=2 && grid[x][y]!=3) grid[x][y++]=1;\\n        }\\n        int ans=0;\\n        for(int x=0; x<m; x++)\\n        {\\n            for(int y=0; y<n; y++) if(!grid[x][y]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279777,
                "title": "c-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> space( m , vector<int> (n, 0));\\n        \\n        for(int i=0;i<walls.size();i++) {\\n            vector<int> v = walls[i];\\n            space[v[0]][v[1]]=-1;\\n        }\\n        for(int i=0;i<guards.size();i++) {\\n            vector<int> v = guards[i];\\n            space[v[0]][v[1]]=1;\\n        }\\n        for(int i=0;i<guards.size();i++) {\\n            int x = guards[i][0];\\n            int y = guards[i][1];\\n            \\n            \\n            for(int j=x-1;j>=0;j--) {\\n                if(space[j][y]==-1 || space[j][y]==1) {\\n                    break;\\n                }\\n                space[j][y]=5;\\n            }\\n\\n            for(int j=x+1;j<m;j++) {\\n                if(space[j][y]==-1 || space[j][y]==1) {\\n                    break;\\n                }\\n                space[j][y]=5;\\n            }\\n\\n            for(int j=y-1;j>=0;j--) {\\n                if(space[x][j]==-1 || space[x][j]==1) {\\n                    break;\\n                }\\n                space[x][j]=5;\\n            }\\n            for(int j=y+1;j<n;j++) {\\n                if(space[x][j]==-1 || space[x][j]==1) {\\n                    break;\\n                }\\n                space[x][j]=5;\\n            }\\n        }\\n        int count =0;\\n        for(int i=0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(space[i][j]==0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> space( m , vector<int> (n, 0));\\n        \\n        for(int i=0;i<walls.size();i++) {\\n            vector<int> v = walls[i];\\n            space[v[0]][v[1]]=-1;\\n        }\\n        for(int i=0;i<guards.size();i++) {\\n            vector<int> v = guards[i];\\n            space[v[0]][v[1]]=1;\\n        }\\n        for(int i=0;i<guards.size();i++) {\\n            int x = guards[i][0];\\n            int y = guards[i][1];\\n            \\n            \\n            for(int j=x-1;j>=0;j--) {\\n                if(space[j][y]==-1 || space[j][y]==1) {\\n                    break;\\n                }\\n                space[j][y]=5;\\n            }\\n\\n            for(int j=x+1;j<m;j++) {\\n                if(space[j][y]==-1 || space[j][y]==1) {\\n                    break;\\n                }\\n                space[j][y]=5;\\n            }\\n\\n            for(int j=y-1;j>=0;j--) {\\n                if(space[x][j]==-1 || space[x][j]==1) {\\n                    break;\\n                }\\n                space[x][j]=5;\\n            }\\n            for(int j=y+1;j<n;j++) {\\n                if(space[x][j]==-1 || space[x][j]==1) {\\n                    break;\\n                }\\n                space[x][j]=5;\\n            }\\n        }\\n        int count =0;\\n        for(int i=0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(space[i][j]==0) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244933,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int res = 0, used = walls.size() + guards.size();\\n        \\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        vector<vector<int>> grid(m, vector<int>(n, 0));\\n\\n        for (auto& g : guards) {\\n            grid[g[0]][g[1]] = 2;\\n        }\\n\\n        for (auto& w : walls) {\\n            grid[w[0]][w[1]] = 3;\\n        }\\n\\n        for (auto& d : dir) {\\n            for (auto& g : guards) {\\n                for (int i = g[0] + d[0], j = g[1] + d[1]; i >= 0 && i < m && j >= 0 && j < n; i += d[0], j += d[1]) {\\n                    if (grid[i][j] == 2 || grid[i][j] == 3) break;\\n                    if (grid[i][j] == 0) {\\n                        used++;\\n                        grid[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return m * n - used;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int res = 0, used = walls.size() + guards.size();\\n        \\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        vector<vector<int>> grid(m, vector<int>(n, 0));\\n\\n        for (auto& g : guards) {\\n            grid[g[0]][g[1]] = 2;\\n        }\\n\\n        for (auto& w : walls) {\\n            grid[w[0]][w[1]] = 3;\\n        }\\n\\n        for (auto& d : dir) {\\n            for (auto& g : guards) {\\n                for (int i = g[0] + d[0], j = g[1] + d[1]; i >= 0 && i < m && j >= 0 && j < n; i += d[0], j += d[1]) {\\n                    if (grid[i][j] == 2 || grid[i][j] == 3) break;\\n                    if (grid[i][j] == 0) {\\n                        used++;\\n                        grid[i][j] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return m * n - used;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199180,
                "title": "c",
                "content": "```\\n\\n\\nint countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize){\\n    int i, j, k;\\n    int** data = (int**)malloc(m * sizeof(int*));\\n    for(i = 0; i < m ; i++){\\n        data[i] = calloc(n , sizeof(int));\\n    }\\n    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;\\n\\n    for(int i = 0 ; i < guardsSize; i++){\\n        int r = guards[i][0] ;\\n        int c = guards[i][1] ;\\n        data[r][c] = 1 ;\\n    }\\n    \\n    for(int i = 0 ; i < wallsSize; i++){\\n        int r = walls[i][0] ;\\n        int c = walls[i][1] ;\\n        data[r][c] = 2 ;\\n    }\\n    \\n    for(int i = 0; i < guardsSize; i++){\\n        int r = guards[i][0] ;\\n        int c = guards[i][1] ;\\n        for(int k = 0; k < 4; k++){\\n            for(int j = 1; ; j++){\\n                int rr = r + dir[k][0]* j ;\\n                int cc = c + dir[k][1]* j ;\\n                if(rr < 0 || cc < 0 || rr >= m || cc >= n)\\n                    break ;\\n                if(data[rr][cc] == 2 || data[rr][cc] == 1)\\n                    break ;\\n                data[rr][cc] = 3 ;\\n            }\\n        }\\n    }\\n    \\n    int ans = 0 ;\\n    for(int i = 0; i < m ;i++){\\n        for(int j = 0; j < n; j++){\\n            if(data[i][j] == 0)\\n                ans++ ;\\n        }\\n        free(data[i]) ;\\n    }\\n    free(data) ;\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint countUnguarded(int m, int n, int** guards, int guardsSize, int* guardsColSize, int** walls, int wallsSize, int* wallsColSize){\\n    int i, j, k;\\n    int** data = (int**)malloc(m * sizeof(int*));\\n    for(i = 0; i < m ; i++){\\n        data[i] = calloc(n , sizeof(int));\\n    }\\n    int dir[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;\\n\\n    for(int i = 0 ; i < guardsSize; i++){\\n        int r = guards[i][0] ;\\n        int c = guards[i][1] ;\\n        data[r][c] = 1 ;\\n    }\\n    \\n    for(int i = 0 ; i < wallsSize; i++){\\n        int r = walls[i][0] ;\\n        int c = walls[i][1] ;\\n        data[r][c] = 2 ;\\n    }\\n    \\n    for(int i = 0; i < guardsSize; i++){\\n        int r = guards[i][0] ;\\n        int c = guards[i][1] ;\\n        for(int k = 0; k < 4; k++){\\n            for(int j = 1; ; j++){\\n                int rr = r + dir[k][0]* j ;\\n                int cc = c + dir[k][1]* j ;\\n                if(rr < 0 || cc < 0 || rr >= m || cc >= n)\\n                    break ;\\n                if(data[rr][cc] == 2 || data[rr][cc] == 1)\\n                    break ;\\n                data[rr][cc] = 3 ;\\n            }\\n        }\\n    }\\n    \\n    int ans = 0 ;\\n    for(int i = 0; i < m ;i++){\\n        for(int j = 0; j < n; j++){\\n            if(data[i][j] == 0)\\n                ans++ ;\\n        }\\n        free(data[i]) ;\\n    }\\n    free(data) ;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3182552,
                "title": "rare-top-1-approach",
                "content": "\\n```\\nclass Solution {\\n    enum class CellState {\\n        Guard,\\n        Wall,\\n        GuardedV,\\n        GuardedH,\\n        GuardedBoth,\\n        Unguarded\\n    }\\n    \\n    fun countUnguarded(m: Int, n: Int, guards: Array<IntArray>, walls: Array<IntArray>): Int {\\n\\t\\t// Simulated grid\\n        val grid = Array<Array<CellState>>(m) { Array<CellState>(n) { CellState.Unguarded } }\\n        \\n\\t\\t// Placing walls\\n        for (wall in walls) grid[wall[0]][wall[1]] = CellState.Wall\\n\\t\\t\\n\\t\\t// Traversing the row\\n        fun guardHorizontal(x: Int, y: Int) {\\n\\t\\t\\t// Ensure we are within bounds\\n            if (x < 0 || x >= grid.size) return\\n            if (y < 0 || y >= grid[x].size) return\\n\\t\\t\\t\\n\\t\\t\\t// Stop moving when hit another guard or wall\\n            if (grid[x][y] == CellState.Guard || grid[x][y] == CellState.Wall) return\\n\\t\\t\\t\\n\\t\\t\\t// If the cell is already guarded by a guard on this row, we can stop moving\\n            if (grid[x][y] == CellState.GuardedH || grid[x][y] == CellState.GuardedBoth) return\\n            \\n\\t\\t\\t// If the cell is guarded by a guard on the crossing column mark cell as guarded both horizontally and vertically\\n\\t\\t\\t// Otherwise mark cell as guarded only horizontally\\n            grid[x][y] = if (grid[x][y] == CellState.Unguarded) CellState.GuardedH else CellState.GuardedBoth\\n\\t\\t\\t\\n\\t\\t\\t// Move both left and right from current cell\\n            guardHorizontal(x, y - 1)\\n            guardHorizontal(x, y + 1)\\n        }\\n        \\n\\t\\t// Traversing the column\\n        fun guardVertical(x: Int, y: Int) {\\n\\t\\t\\t// Ensure we are within bounds\\n            if (x < 0 || x >= grid.size) return\\n            if (y < 0 || y >= grid[x].size) return\\n\\t\\t\\t\\n\\t\\t\\t// Stop moving when hit another guard or wall\\n            if (grid[x][y] == CellState.Guard || grid[x][y] == CellState.Wall) return\\n\\t\\t\\t\\n\\t\\t\\t// If the cell is already guarded by a guard on this column, we can stop moving\\n            if (grid[x][y] == CellState.GuardedV || grid[x][y] == CellState.GuardedBoth) return\\n            \\n\\t\\t\\t// If the cell is already guarded by a guard on the crossing row mark cell as guarded both horizontally and vertically\\n\\t\\t\\t// Otherwise mark cell as guarded only vertically\\n            grid[x][y] = if (grid[x][y] == CellState.Unguarded) CellState.GuardedV else CellState.GuardedBoth\\n\\t\\t\\t\\n\\t\\t\\t// Move both up and down from current cell\\n            guardVertical(x + 1, y)\\n            guardVertical(x - 1, y)\\n        }\\n        \\n        // Guarding cells\\n        for (guard in guards) {\\n            grid[guard[0]][guard[1]] = CellState.Guard\\n\\t\\t\\t\\n\\t\\t\\t// Move up and down from guard\\'s position to mark cells as guarded\\n            guardVertical(guard[0] - 1, guard[1])\\n            guardVertical(guard[0] + 1, guard[1])\\n\\t\\t\\t\\n\\t\\t\\t// Move left and right from guard\\'s position to mark cells as guarded\\n            guardHorizontal(guard[0], guard[1] - 1)\\n            guardHorizontal(guard[0], guard[1] + 1)\\n        }\\n        \\n        // Counting unguarded cells\\n        var count = 0\\n        for (x in grid.indices)\\n            for (y in grid[x].indices) if (grid[x][y] == CellState.Unguarded) count++\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    enum class CellState {\\n        Guard,\\n        Wall,\\n        GuardedV,\\n        GuardedH,\\n        GuardedBoth,\\n        Unguarded\\n    }\\n    \\n    fun countUnguarded(m: Int, n: Int, guards: Array<IntArray>, walls: Array<IntArray>): Int {\\n\\t\\t// Simulated grid\\n        val grid = Array<Array<CellState>>(m) { Array<CellState>(n) { CellState.Unguarded } }\\n        \\n\\t\\t// Placing walls\\n        for (wall in walls) grid[wall[0]][wall[1]] = CellState.Wall\\n\\t\\t\\n\\t\\t// Traversing the row\\n        fun guardHorizontal(x: Int, y: Int) {\\n\\t\\t\\t// Ensure we are within bounds\\n            if (x < 0 || x >= grid.size) return\\n            if (y < 0 || y >= grid[x].size) return\\n\\t\\t\\t\\n\\t\\t\\t// Stop moving when hit another guard or wall\\n            if (grid[x][y] == CellState.Guard || grid[x][y] == CellState.Wall) return\\n\\t\\t\\t\\n\\t\\t\\t// If the cell is already guarded by a guard on this row, we can stop moving\\n            if (grid[x][y] == CellState.GuardedH || grid[x][y] == CellState.GuardedBoth) return\\n            \\n\\t\\t\\t// If the cell is guarded by a guard on the crossing column mark cell as guarded both horizontally and vertically\\n\\t\\t\\t// Otherwise mark cell as guarded only horizontally\\n            grid[x][y] = if (grid[x][y] == CellState.Unguarded) CellState.GuardedH else CellState.GuardedBoth\\n\\t\\t\\t\\n\\t\\t\\t// Move both left and right from current cell\\n            guardHorizontal(x, y - 1)\\n            guardHorizontal(x, y + 1)\\n        }\\n        \\n\\t\\t// Traversing the column\\n        fun guardVertical(x: Int, y: Int) {\\n\\t\\t\\t// Ensure we are within bounds\\n            if (x < 0 || x >= grid.size) return\\n            if (y < 0 || y >= grid[x].size) return\\n\\t\\t\\t\\n\\t\\t\\t// Stop moving when hit another guard or wall\\n            if (grid[x][y] == CellState.Guard || grid[x][y] == CellState.Wall) return\\n\\t\\t\\t\\n\\t\\t\\t// If the cell is already guarded by a guard on this column, we can stop moving\\n            if (grid[x][y] == CellState.GuardedV || grid[x][y] == CellState.GuardedBoth) return\\n            \\n\\t\\t\\t// If the cell is already guarded by a guard on the crossing row mark cell as guarded both horizontally and vertically\\n\\t\\t\\t// Otherwise mark cell as guarded only vertically\\n            grid[x][y] = if (grid[x][y] == CellState.Unguarded) CellState.GuardedV else CellState.GuardedBoth\\n\\t\\t\\t\\n\\t\\t\\t// Move both up and down from current cell\\n            guardVertical(x + 1, y)\\n            guardVertical(x - 1, y)\\n        }\\n        \\n        // Guarding cells\\n        for (guard in guards) {\\n            grid[guard[0]][guard[1]] = CellState.Guard\\n\\t\\t\\t\\n\\t\\t\\t// Move up and down from guard\\'s position to mark cells as guarded\\n            guardVertical(guard[0] - 1, guard[1])\\n            guardVertical(guard[0] + 1, guard[1])\\n\\t\\t\\t\\n\\t\\t\\t// Move left and right from guard\\'s position to mark cells as guarded\\n            guardHorizontal(guard[0], guard[1] - 1)\\n            guardHorizontal(guard[0], guard[1] + 1)\\n        }\\n        \\n        // Counting unguarded cells\\n        var count = 0\\n        for (x in grid.indices)\\n            for (y in grid[x].indices) if (grid[x][y] == CellState.Unguarded) count++\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143075,
                "title": "c-simulation",
                "content": "```\\nclass Solution {\\nprivate:\\n    int move(vector<vector<int>> &grid, vector<vector<bool>> &visited, int i, int j, string dir) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid.at(i).size()) return 0;\\n\\n        // see a wall, go back\\n        if(grid.at(i).at(j) == 2) return 0;\\n\\n        // see a guard, go back\\n        if(grid.at(i).at(j) == 1) return 0;\\n\\n        // used to make sure we\\'re not over-counting already visited cells\\n        int num = visited.at(i).at(j) == false ? 1 : 0;\\n\\n        // cell is now visited\\n        visited.at(i).at(j) = true;\\n\\n        if(dir == \"up\")    return num + move(grid, visited, i - 1, j, dir);\\n        if(dir == \"down\")  return num + move(grid, visited, i + 1, j, dir);\\n        if(dir == \"left\")  return num + move(grid, visited, i, j - 1, dir);\\n        if(dir == \"right\") return num + move(grid, visited, i, j + 1, dir);\\n\\n        return 0; \\n    }\\n\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m, vector<int>(n, 0));\\n\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        // come across a guard\\n        for(vector<int> &coords : guards) \\n            grid.at(coords.at(0)).at(coords.at(1)) = 1;\\n\\n        // come across a wall\\n        for(vector<int> &coords : walls) \\n            grid.at(coords.at(0)).at(coords.at(1)) = 2;\\n\\n        // we do not count the guard nor the wall cells in our grid\\n        int totalCells = m * n - (guards.size() + walls.size());\\n\\n        // traversing grid based on simulation\\n        for(int i = 0; i < grid.size(); i++)\\n            for(int j = 0; j < grid.at(i).size(); j++)\\n                if(grid.at(i).at(j) == 1) { \\n                    totalCells -= move(grid, visited, i - 1, j, \"up\");\\n                    totalCells -= move(grid, visited, i + 1, j, \"down\");\\n                    totalCells -= move(grid, visited, i, j - 1, \"left\");\\n                    totalCells -= move(grid, visited, i, j + 1, \"right\");\\n                }\\n        \\n\\n\\n        return totalCells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int move(vector<vector<int>> &grid, vector<vector<bool>> &visited, int i, int j, string dir) {\\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid.at(i).size()) return 0;\\n\\n        // see a wall, go back\\n        if(grid.at(i).at(j) == 2) return 0;\\n\\n        // see a guard, go back\\n        if(grid.at(i).at(j) == 1) return 0;\\n\\n        // used to make sure we\\'re not over-counting already visited cells\\n        int num = visited.at(i).at(j) == false ? 1 : 0;\\n\\n        // cell is now visited\\n        visited.at(i).at(j) = true;\\n\\n        if(dir == \"up\")    return num + move(grid, visited, i - 1, j, dir);\\n        if(dir == \"down\")  return num + move(grid, visited, i + 1, j, dir);\\n        if(dir == \"left\")  return num + move(grid, visited, i, j - 1, dir);\\n        if(dir == \"right\") return num + move(grid, visited, i, j + 1, dir);\\n\\n        return 0; \\n    }\\n\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> grid(m, vector<int>(n, 0));\\n\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        // come across a guard\\n        for(vector<int> &coords : guards) \\n            grid.at(coords.at(0)).at(coords.at(1)) = 1;\\n\\n        // come across a wall\\n        for(vector<int> &coords : walls) \\n            grid.at(coords.at(0)).at(coords.at(1)) = 2;\\n\\n        // we do not count the guard nor the wall cells in our grid\\n        int totalCells = m * n - (guards.size() + walls.size());\\n\\n        // traversing grid based on simulation\\n        for(int i = 0; i < grid.size(); i++)\\n            for(int j = 0; j < grid.at(i).size(); j++)\\n                if(grid.at(i).at(j) == 1) { \\n                    totalCells -= move(grid, visited, i - 1, j, \"up\");\\n                    totalCells -= move(grid, visited, i + 1, j, \"down\");\\n                    totalCells -= move(grid, visited, i, j - 1, \"left\");\\n                    totalCells -= move(grid, visited, i, j + 1, \"right\");\\n                }\\n        \\n\\n\\n        return totalCells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135379,
                "title": "java-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] ground = new int[m][n];\\n\\n        for(int[] guard : guards){\\n            ground[guard[0]][guard[1]] = 1;\\n        }\\n        for(int[] wall : walls){\\n            ground[wall[0]][wall[1]] = 2;\\n        }\\n        \\n        for(int[] guard : guards){\\n            processGround(guard[0], guard[1], ground, m, n);\\n        }\\n        int count = 0;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(ground[i][j] == 0)\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    void processGround(int i, int j, int[][] ground, int m, int n){\\n        //Process TOP\\n        int tempI = i - 1; \\n        while(tempI >= 0){\\n            if(ground[tempI][j] == 0){\\n                ground[tempI][j] = 3;\\n            } else if(ground[tempI][j] != 3){\\n                break;\\n            }\\n            tempI--;\\n        }\\n\\n        //Process DOWN\\n        tempI = i + 1; \\n        while(tempI < m){\\n            if(ground[tempI][j] == 0){\\n                ground[tempI][j] = 3;\\n            } else if(ground[tempI][j] != 3){\\n                break;\\n            }\\n            tempI++;\\n        }\\n\\n        //Process LEFT\\n        int tempJ = j - 1; \\n        while(tempJ >= 0){\\n            if(ground[i][tempJ] == 0){\\n                ground[i][tempJ] = 3;\\n            } else if(ground[i][tempJ] != 3){\\n                break;\\n            }\\n            tempJ--;\\n        }\\n\\n        //Process RIGHT\\n        tempJ = j + 1; \\n        while(tempJ < n){\\n            if(ground[i][tempJ] == 0){\\n                ground[i][tempJ] = 3;\\n            } else if(ground[i][tempJ] != 3){\\n                break;\\n            }\\n            tempJ++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] ground = new int[m][n];\\n\\n        for(int[] guard : guards){\\n            ground[guard[0]][guard[1]] = 1;\\n        }\\n        for(int[] wall : walls){\\n            ground[wall[0]][wall[1]] = 2;\\n        }\\n        \\n        for(int[] guard : guards){\\n            processGround(guard[0], guard[1], ground, m, n);\\n        }\\n        int count = 0;\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(ground[i][j] == 0)\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    void processGround(int i, int j, int[][] ground, int m, int n){\\n        //Process TOP\\n        int tempI = i - 1; \\n        while(tempI >= 0){\\n            if(ground[tempI][j] == 0){\\n                ground[tempI][j] = 3;\\n            } else if(ground[tempI][j] != 3){\\n                break;\\n            }\\n            tempI--;\\n        }\\n\\n        //Process DOWN\\n        tempI = i + 1; \\n        while(tempI < m){\\n            if(ground[tempI][j] == 0){\\n                ground[tempI][j] = 3;\\n            } else if(ground[tempI][j] != 3){\\n                break;\\n            }\\n            tempI++;\\n        }\\n\\n        //Process LEFT\\n        int tempJ = j - 1; \\n        while(tempJ >= 0){\\n            if(ground[i][tempJ] == 0){\\n                ground[i][tempJ] = 3;\\n            } else if(ground[i][tempJ] != 3){\\n                break;\\n            }\\n            tempJ--;\\n        }\\n\\n        //Process RIGHT\\n        tempJ = j + 1; \\n        while(tempJ < n){\\n            if(ground[i][tempJ] == 0){\\n                ground[i][tempJ] = 3;\\n            } else if(ground[i][tempJ] != 3){\\n                break;\\n            }\\n            tempJ++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115079,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m, n, guards, walls):\\n        def goLeft(i, j):\\n            if j < 0 or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goLeft(i, j - 1)\\n        def goRight(i, j):\\n            if j >= n or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goRight(i, j + 1)\\n        def goBottom(i, j):\\n            if i >= m or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goBottom(i + 1, j)\\n        def goUp(i, j):\\n            if i < 0 or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goUp(i - 1, j)\\n        walls = set((i, j) for i, j in walls)\\n        guards = set((i, j) for i, j in guards)\\n        seen = set()\\n        for i, j in guards:\\n            goLeft(i, j - 1)\\n            goRight(i, j + 1)\\n            goBottom(i + 1, j)\\n            goUp(i - 1, j)\\n        return (m * n) - len(walls) - len(guards) - len(seen)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m, n, guards, walls):\\n        def goLeft(i, j):\\n            if j < 0 or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goLeft(i, j - 1)\\n        def goRight(i, j):\\n            if j >= n or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goRight(i, j + 1)\\n        def goBottom(i, j):\\n            if i >= m or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goBottom(i + 1, j)\\n        def goUp(i, j):\\n            if i < 0 or (i, j) in walls or (i, j) in guards:\\n                return\\n            seen.add((i, j))\\n            goUp(i - 1, j)\\n        walls = set((i, j) for i, j in walls)\\n        guards = set((i, j) for i, j in guards)\\n        seen = set()\\n        for i, j in guards:\\n            goLeft(i, j - 1)\\n            goRight(i, j + 1)\\n            goBottom(i + 1, j)\\n            goUp(i - 1, j)\\n        return (m * n) - len(walls) - len(guards) - len(seen)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111093,
                "title": "python-binary-search",
                "content": "Step 1. Setup the grid assigning walls and guards to their respective positions\\nStep 2. Loop through the grid and append to our lists so that each of our row and column lists are in sorted order\\nStep 3. Loop through the grid again and if we see and empty column binary search for guards left/right and up/down from our posion using the lists we setup in step 2\\nStep 4. If we do not see any guards add 1 to the result. At the end return our result\\n\\n\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        \\n        gMap = defaultdict(list)\\n        \\n        grid = [[0 for j in range(n)] for i in range(m)]\\n        \\n        \\n        for x,y in guards:\\n            \\n            grid[x][y] = \\'G\\'\\n\\n\\n        for x,y in walls:\\n            \\n            grid[x][y] = \\'W\\'\\n\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] != 0:\\n                    val = grid[r][c]\\n                    gMap[\\'r\\' + str(r)].append((c,val))\\n                    gMap[\\'c\\' + str(c)].append((r,val))\\n        \\n  \\n        res = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    #scan for closest between row/col up/down left/right if all W or out of bounds its good\\n                    #if any are guards its not good\\n                    arrC = gMap[\\'r\\' + str(r)]\\n                    arrR = gMap[\\'c\\' + str(c)]\\n                    cIdx = 0\\n                    rIdx = 0\\n                    \\n                    #scan for guards watching us\\n                    if len(arrC) > 0:\\n                        cIdx = bisect.bisect_left(arrC, c,key=lambda i: i[0])\\n                        cIdx -=1\\n                        if cIdx >= 0 and arrC[cIdx][1] == \\'G\\' or cIdx + 1 < len(arrC) and arrC[cIdx+1][1] == \\'G\\':\\n                            continue\\n                            \\n                    if len(arrR) > 0:\\n                        rIdx = bisect.bisect_left(arrR, r,key=lambda i: i[0])\\n                        rIdx -=1\\n                        if rIdx >= 0 and arrR[rIdx][1] == \\'G\\' or rIdx + 1 < len(arrR) and arrR[rIdx+1][1] == \\'G\\':\\n                            continue\\n\\n                    res +=1\\n        \\n        \\n        return res\\n                \\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "Step 1. Setup the grid assigning walls and guards to their respective positions\\nStep 2. Loop through the grid and append to our lists so that each of our row and column lists are in sorted order\\nStep 3. Loop through the grid again and if we see and empty column binary search for guards left/right and up/down from our posion using the lists we setup in step 2\\nStep 4. If we do not see any guards add 1 to the result. At the end return our result\\n\\n\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        \\n        gMap = defaultdict(list)\\n        \\n        grid = [[0 for j in range(n)] for i in range(m)]\\n        \\n        \\n        for x,y in guards:\\n            \\n            grid[x][y] = \\'G\\'\\n\\n\\n        for x,y in walls:\\n            \\n            grid[x][y] = \\'W\\'\\n\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] != 0:\\n                    val = grid[r][c]\\n                    gMap[\\'r\\' + str(r)].append((c,val))\\n                    gMap[\\'c\\' + str(c)].append((r,val))\\n        \\n  \\n        res = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    #scan for closest between row/col up/down left/right if all W or out of bounds its good\\n                    #if any are guards its not good\\n                    arrC = gMap[\\'r\\' + str(r)]\\n                    arrR = gMap[\\'c\\' + str(c)]\\n                    cIdx = 0\\n                    rIdx = 0\\n                    \\n                    #scan for guards watching us\\n                    if len(arrC) > 0:\\n                        cIdx = bisect.bisect_left(arrC, c,key=lambda i: i[0])\\n                        cIdx -=1\\n                        if cIdx >= 0 and arrC[cIdx][1] == \\'G\\' or cIdx + 1 < len(arrC) and arrC[cIdx+1][1] == \\'G\\':\\n                            continue\\n                            \\n                    if len(arrR) > 0:\\n                        rIdx = bisect.bisect_left(arrR, r,key=lambda i: i[0])\\n                        rIdx -=1\\n                        if rIdx >= 0 and arrR[rIdx][1] == \\'G\\' or rIdx + 1 < len(arrR) and arrR[rIdx+1][1] == \\'G\\':\\n                            continue\\n\\n                    res +=1\\n        \\n        \\n        return res\\n                \\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 3104334,
                "title": "c-easy-to-understand-code",
                "content": "# Approach\\n- Create a grid or visited matrix of m rows and n columns \\nInitialise it to 0 \\n- Now traverse and mark guards cell with 2 and walls cell with -2\\n- Now traverse the grid cell with value 2\\nand traverse linerally uptil maximum row/column value \\nand mark the cell as 1 i.e they are visited, guarded by gurad.\\n- Now count all the remaining cells with 0. This will give the cells which remain unguarded.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> dx={0,-1,1,0};\\n    vector<int> dy={-1,0,0,1};\\n\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<int>> grid(m,vector<int>(n,0));\\n\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            grid[x][y]=2;\\n        }\\n\\n        for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0];\\n            int y=walls[i][1];\\n            grid[x][y]=-2;\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){                    \\n                    for(int k=0;k<4;k++){\\n                        int nx=i+dx[k];\\n                        int ny=j+dy[k];\\n                            while(nx>=0 && nx<m && ny>=0 && ny<n && (grid[nx][ny]==0 ||grid[nx][ny]==1)){\\n                                grid[nx][ny]=1;\\n                                nx+=dx[k];\\n                                ny+=dy[k];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0)count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> dx={0,-1,1,0};\\n    vector<int> dy={-1,0,0,1};\\n\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<int>> grid(m,vector<int>(n,0));\\n\\n        for(int i=0;i<guards.size();i++){\\n            int x=guards[i][0];\\n            int y=guards[i][1];\\n            grid[x][y]=2;\\n        }\\n\\n        for(int i=0;i<walls.size();i++){\\n            int x=walls[i][0];\\n            int y=walls[i][1];\\n            grid[x][y]=-2;\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==2){                    \\n                    for(int k=0;k<4;k++){\\n                        int nx=i+dx[k];\\n                        int ny=j+dy[k];\\n                            while(nx>=0 && nx<m && ny>=0 && ny<n && (grid[nx][ny]==0 ||grid[nx][ny]==1)){\\n                                grid[nx][ny]=1;\\n                                nx+=dx[k];\\n                                ny+=dy[k];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0)count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077764,
                "title": "beats-98-easy-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        \\n    //2 is for guards\\n    //1 is for walls\\n\\n    int[][]grid=new int[m][n];\\n\\n    //filling up the coordinates of guarded cell\\n    for(int i=0;i<guards.length;i++){\\n        grid[guards[i][0]][guards[i][1]]=2;\\n    }\\n    //filling up the coordinates of walls cell\\n    for(int i=0;i<walls.length;i++){\\n        grid[walls[i][0]][walls[i][1]]=1;\\n    }\\n\\n    for(int i=0;i<grid.length;i++){\\n\\n        for(int j=0;j<grid[0].length;j++){\\n\\n        if(grid[i][j]==2){\\n        \\n        //for up\\n        int p=i-1;\\n        int o=j;\\n        while(p>=0&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            p--;\\n        }\\n        //for down\\n        p=i+1;\\n        o=j;\\n        while(p<grid.length&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            p++;\\n        }\\n        //for left\\n        p=i;\\n        o=j-1;\\n        while(o>=0&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            o--;\\n        }\\n        //for right\\n        p=i;\\n        o=j+1;\\n        while(o<grid[0].length&&(grid[p][o]==0||grid[p][o]==-1))\\n        {\\n            grid[p][o]=-1;\\n            o++;\\n        }\\n\\n        }\\n\\n        }\\n    }\\n\\n    int count=0;\\n\\n    for(int i=0;i<grid.length;i++){\\n        for(int j=0;j<grid[0].length;j++){\\n            if(grid[i][j]==0)count++;\\n        }\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        \\n    //2 is for guards\\n    //1 is for walls\\n\\n    int[][]grid=new int[m][n];\\n\\n    //filling up the coordinates of guarded cell\\n    for(int i=0;i<guards.length;i++){\\n        grid[guards[i][0]][guards[i][1]]=2;\\n    }\\n    //filling up the coordinates of walls cell\\n    for(int i=0;i<walls.length;i++){\\n        grid[walls[i][0]][walls[i][1]]=1;\\n    }\\n\\n    for(int i=0;i<grid.length;i++){\\n\\n        for(int j=0;j<grid[0].length;j++){\\n\\n        if(grid[i][j]==2){\\n        \\n        //for up\\n        int p=i-1;\\n        int o=j;\\n        while(p>=0&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            p--;\\n        }\\n        //for down\\n        p=i+1;\\n        o=j;\\n        while(p<grid.length&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            p++;\\n        }\\n        //for left\\n        p=i;\\n        o=j-1;\\n        while(o>=0&&(grid[p][o]==0||grid[p][o]==-1)){\\n            grid[p][o]=-1;\\n            o--;\\n        }\\n        //for right\\n        p=i;\\n        o=j+1;\\n        while(o<grid[0].length&&(grid[p][o]==0||grid[p][o]==-1))\\n        {\\n            grid[p][o]=-1;\\n            o++;\\n        }\\n\\n        }\\n\\n        }\\n    }\\n\\n    int count=0;\\n\\n    for(int i=0;i<grid.length;i++){\\n        for(int j=0;j<grid[0].length;j++){\\n            if(grid[i][j]==0)count++;\\n        }\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050780,
                "title": "linear-array-representation-strategy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGuards shouldn\\'t make attempts in directions they can\\'t visit (borders/walls/other guards). Should iterate and observe through all the guards.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEventually got to an idea to decrease the time complexity to represent the matrix as a **linear Array**. This strategy helped a lot where each column and row cell can be defined by multiplying on either `m` or `n`. All the description of my approach in details can be found inside comments of the code itself.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Guard = number[]\\ntype Guards = Guard[]\\ntype Cells = Map<number, boolean | null>\\n\\nfunction getCell(posM: number, posN: number, n: number): number {\\n    return posM * n + posN\\n}\\n\\nfunction guardObserve(guard: Guard, m: number, n: number, cells: Cells): void {\\n    // A dictionary of possible directions\\n    // As well an initial state\\n    const directionsVisited = {\\n        top: false,\\n        right: false,\\n        bottom: false,\\n        left: false\\n    }\\n\\n    const [gM, gN] = guard\\n    const guardCell = getCell(gM, gN, n)\\n\\n    // define the directions we don\\'t need to visit if it hits the border\\n    if(gM === 0) directionsVisited.top = true\\n    if(gN === 0) directionsVisited.left = true\\n    if(gM === m - 1) directionsVisited.bottom = true\\n    if(gN === n - 1) directionsVisited.right = true\\n\\n    const directions = (Object.keys(directionsVisited) as [keyof typeof  directionsVisited]).filter(d => !directionsVisited[d])\\n\\n    dLoop: for(let direction of directions) {\\n        let cell = guardCell\\n        let isBorder = false\\n        let nextCell: boolean | null | undefined;\\n\\n        // Goes through all the cells till it reaches the border OR next guard OR wall\\n        // Then we start over with another direction (that\\'s why we need for loop label)\\n        while(!isBorder) {\\n            switch(direction) {\\n                case \\'top\\':\\n                    cell -= n\\n                    nextCell = cells.get(cell)\\n                    isBorder = !(cell >= 0) || nextCell === null\\n\\n                    if(isBorder) continue dLoop\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n                    break;\\n                case \\'right\\':\\n                    cell++\\n                    nextCell = cells.get(cell)\\n                    isBorder = (cell + 1) % n === 0 || nextCell === null\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n\\n                    if(isBorder) continue dLoop\\n                    break;\\n                case \\'bottom\\':\\n                    cell += n\\n                    nextCell = cells.get(cell)\\n                    isBorder = !(cell <= cells.size) || nextCell === null\\n\\n                    if(isBorder) continue dLoop\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n                    break;\\n                case \\'left\\':\\n                    cell--\\n                    nextCell = cells.get(cell)\\n                    isBorder = cell % n === 0 || nextCell === null\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n\\n                    if(isBorder) continue dLoop\\n                    break;\\n            }\\n        }\\n    }\\n\\n}\\n\\n\\nfunction countUnguarded(m: number, n: number, guards: Guards, walls: number[][]): number {\\n//    Strategy:\\n// - create map of visits\\n// - apply walls & guards as null in visits\\n// - make a function that will move guards with constraints\\n// - calculate unvisited\\n    let cells: Cells = new Map([...Array(m * n).keys()].map(key => ([key, false])))\\n\\n    // Mark the cells with wall or guards to use them as boundaries\\n    // in further calculations\\n    for(let [wM, wN] of [...walls, ...guards]) {\\n        cells.set(getCell(wM, wN, n), null)\\n    }\\n\\n    // Iterate through each guard and calculate visits\\n    for(let guard of guards) {\\n        guardObserve(guard, m, n, cells)\\n    }\\n\\n    // Simply return all the unvisited cells\\n    return [...cells].reduce((counter, [_, flag]) => flag !== null && !flag ? ++counter : counter, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\ntype Guard = number[]\\ntype Guards = Guard[]\\ntype Cells = Map<number, boolean | null>\\n\\nfunction getCell(posM: number, posN: number, n: number): number {\\n    return posM * n + posN\\n}\\n\\nfunction guardObserve(guard: Guard, m: number, n: number, cells: Cells): void {\\n    // A dictionary of possible directions\\n    // As well an initial state\\n    const directionsVisited = {\\n        top: false,\\n        right: false,\\n        bottom: false,\\n        left: false\\n    }\\n\\n    const [gM, gN] = guard\\n    const guardCell = getCell(gM, gN, n)\\n\\n    // define the directions we don\\'t need to visit if it hits the border\\n    if(gM === 0) directionsVisited.top = true\\n    if(gN === 0) directionsVisited.left = true\\n    if(gM === m - 1) directionsVisited.bottom = true\\n    if(gN === n - 1) directionsVisited.right = true\\n\\n    const directions = (Object.keys(directionsVisited) as [keyof typeof  directionsVisited]).filter(d => !directionsVisited[d])\\n\\n    dLoop: for(let direction of directions) {\\n        let cell = guardCell\\n        let isBorder = false\\n        let nextCell: boolean | null | undefined;\\n\\n        // Goes through all the cells till it reaches the border OR next guard OR wall\\n        // Then we start over with another direction (that\\'s why we need for loop label)\\n        while(!isBorder) {\\n            switch(direction) {\\n                case \\'top\\':\\n                    cell -= n\\n                    nextCell = cells.get(cell)\\n                    isBorder = !(cell >= 0) || nextCell === null\\n\\n                    if(isBorder) continue dLoop\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n                    break;\\n                case \\'right\\':\\n                    cell++\\n                    nextCell = cells.get(cell)\\n                    isBorder = (cell + 1) % n === 0 || nextCell === null\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n\\n                    if(isBorder) continue dLoop\\n                    break;\\n                case \\'bottom\\':\\n                    cell += n\\n                    nextCell = cells.get(cell)\\n                    isBorder = !(cell <= cells.size) || nextCell === null\\n\\n                    if(isBorder) continue dLoop\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n                    break;\\n                case \\'left\\':\\n                    cell--\\n                    nextCell = cells.get(cell)\\n                    isBorder = cell % n === 0 || nextCell === null\\n\\n                    if(nextCell !== null) {\\n                        cells.set(cell, true)\\n                    }\\n\\n                    if(isBorder) continue dLoop\\n                    break;\\n            }\\n        }\\n    }\\n\\n}\\n\\n\\nfunction countUnguarded(m: number, n: number, guards: Guards, walls: number[][]): number {\\n//    Strategy:\\n// - create map of visits\\n// - apply walls & guards as null in visits\\n// - make a function that will move guards with constraints\\n// - calculate unvisited\\n    let cells: Cells = new Map([...Array(m * n).keys()].map(key => ([key, false])))\\n\\n    // Mark the cells with wall or guards to use them as boundaries\\n    // in further calculations\\n    for(let [wM, wN] of [...walls, ...guards]) {\\n        cells.set(getCell(wM, wN, n), null)\\n    }\\n\\n    // Iterate through each guard and calculate visits\\n    for(let guard of guards) {\\n        guardObserve(guard, m, n, cells)\\n    }\\n\\n    // Simply return all the unvisited cells\\n    return [...cells].reduce((counter, [_, flag]) => flag !== null && !flag ? ++counter : counter, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3049746,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void right(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        right(i,j+1,m,n,arr,visited);\\n    }\\n    void left(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n       \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        left(i,j-1,m,n,arr,visited);\\n    }\\n    void down(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        down(i+1,j,m,n,arr,visited);\\n    }\\n    void up(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        up(i-1,j,m,n,arr,visited);\\n    }\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        vector<vector<char>> arr(m,vector<char>(n,\\'.\\'));\\n        for(int i=0;i<guards.size();i++){\\n            \\n            int row=guards[i][0];\\n            int col=guards[i][1];\\n            arr[row][col]=\\'G\\';\\n        }\\n        for(int i=0;i<walls.size();i++){\\n            \\n            int row=walls[i][0];\\n            int col=walls[i][1];\\n            arr[row][col]=\\'W\\';\\n        }\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(arr[i][j]==\\'G\\'){\\n                    \\n                    up(i-1,j,m,n,arr,visited);\\n                    down(i+1,j,m,n,arr,visited);\\n                    left(i,j-1,m,n,arr,visited);\\n                    right(i,j+1,m,n,arr,visited);\\n                }\\n            }\\n        }\\n        long long count=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(arr[i][j]!=\\'G\\' && arr[i][j]!=\\'W\\' && visited[i][j]!=true){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    void right(int i,int j,int m,int n,vector<vector<char>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || arr[i][j]==\\'W\\' || arr[i][j]==\\'G\\'){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3023734,
                "title": "c-faster-than-99-loop-through-guards",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply loop thourgh all guards to see how many cells are watched. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a ```vector<string> cells``` to store the states of cells: \\n- \\'w\\': cell occupied by a wall\\n- \\'g\\': cell occupied by a guard\\n- \\'h\\': cell watched horizonally\\n- \\'v\\': cell watched vertically\\n- \\'b\\': cell watched both horizonally & vertically\\n- \\'u\\': cell unwatched and unoccupied\\n\\n\\'h\\' and \\'v\\' are defined to reduce redundant check.  \\n\\nWe assume that all cells are \\'u\\' at first. Thus the result would be initialized as ```int res = m * n;```\\n\\nFirst step, mark all walls and guards. Everytime a cell is occupied, ```--res;```\\n\\nSecond step, go through all ```guards``` to mark watched cells. When going vertically, switch case the cell\\n- \\'u\\': subtract ```res``` and mark it as \\'v\\';\\n- \\'v\\' or \\'b\\': cell has been checked by another guard, so this cell and all other cells vertically after it do not need to be checked\\n- \\'w\\': there is a wall, so this cell and all cells vertically after it are not watched by this guard\\n- \\'h\\': this cell is watched horizonally, so ```res``` should not decrease by 1; despite, we are not sure whether the cells vertically after it is checked, so the loop should go on\\n\\nThe horizonal checking is similar to the steps above. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst case $O(m*n)$: when guards are placed across all rows and columns\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(m*n)$, the recording strings\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<string> cells(m, string(n, \\'u\\')); // unguarded\\n        int res = m*n;\\n        for ( vector<int>& w: walls ){\\n            --res;\\n            cells[w[0]][w[1]] = \\'w\\';\\n        }\\n        for ( vector<int>& g: guards ){\\n            --res;\\n            cells[g[0]][g[1]] = \\'g\\';\\n        }\\n        for ( vector<int>& g: guards ){\\n            bool stop = false;\\n            for ( int i = g[0]-1; ~i && !stop ; --i ){\\n                char& c = cells[i][g[1]];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'v\\';} break;\\n                    case \\'h\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int i = g[0]+1; i != m && !stop ; ++i ){\\n                char& c = cells[i][g[1]];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'v\\';} break;\\n                    case \\'h\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int j = g[1]-1; ~j && !stop ; --j ){\\n                char& c = cells[g[0]][j];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'h\\';} break;\\n                    case \\'v\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int j = g[1]+1; j != n && !stop ; ++j ){\\n                char& c = cells[g[0]][j];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'h\\';} break;\\n                    case \\'v\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```vector<string> cells```\n```int res = m * n;```\n```--res;```\n```guards```\n```res```\n```res```\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<string> cells(m, string(n, \\'u\\')); // unguarded\\n        int res = m*n;\\n        for ( vector<int>& w: walls ){\\n            --res;\\n            cells[w[0]][w[1]] = \\'w\\';\\n        }\\n        for ( vector<int>& g: guards ){\\n            --res;\\n            cells[g[0]][g[1]] = \\'g\\';\\n        }\\n        for ( vector<int>& g: guards ){\\n            bool stop = false;\\n            for ( int i = g[0]-1; ~i && !stop ; --i ){\\n                char& c = cells[i][g[1]];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'v\\';} break;\\n                    case \\'h\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int i = g[0]+1; i != m && !stop ; ++i ){\\n                char& c = cells[i][g[1]];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'v\\';} break;\\n                    case \\'h\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int j = g[1]-1; ~j && !stop ; --j ){\\n                char& c = cells[g[0]][j];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'h\\';} break;\\n                    case \\'v\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n            stop = false;\\n            for ( int j = g[1]+1; j != n && !stop ; ++j ){\\n                char& c = cells[g[0]][j];\\n                switch ( c ){\\n                    case \\'u\\': {--res; c = \\'h\\';} break;\\n                    case \\'v\\': c = \\'b\\'; break;\\n                    default: stop = true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015518,
                "title": "c-easy-to-understand-simple-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    int[][] grid;\\n    int maxRow;\\n    int maxCol;\\n    int freeSpace;\\n    //1 = Guard\\n    //2 = Wall\\n    //0 = Free Space\\n  \\n    public int CountUnguarded(int maxRow, int maxCol, int[][] guards, int[][] walls) {\\n      grid = new int[maxRow][];\\n      this.maxRow = maxRow;\\n      this.maxCol = maxCol;\\n      freeSpace = maxRow * maxCol;\\n      \\n      for(int r=0;r<maxRow;r++){\\n        grid[r] = new int[maxCol];\\n      }\\n      \\n      foreach(var wall in walls){\\n        grid[wall[0]][wall[1]] = 2;\\n        freeSpace--;\\n      }\\n      \\n      foreach(var guard in guards){\\n        grid[guard[0]][guard[1]] = 1;\\n        freeSpace--;\\n      }\\n      \\n      foreach(var guard in guards){\\n        Guard(guard[0], guard[1]);\\n      }\\n      \\n      return freeSpace;\\n    }\\n  \\n    private void Guard(int row, int col){\\n      Up(row,col);\\n      Down(row,col);\\n      Left(row,col);\\n      Right(row,col);\\n    }\\n  \\n    private void Up(int row, int col){\\n      while(true){\\n        var nextRow = --row;\\n        var nextCol = col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }        \\n      }\\n    }\\n  \\n    private void Down(int row, int col){\\n      while(true){\\n        var nextRow = ++row;\\n        var nextCol = col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private void Left(int row, int col){\\n      while(true){\\n        var nextRow = row;\\n        var nextCol = --col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private void Right(int row, int col){\\n      while(true){\\n        var nextRow = row;\\n        var nextCol = ++col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private bool OutOfBound(int row, int col){\\n      return row >= maxRow || row < 0 || col >= maxCol || col < 0;\\n    }\\n  \\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[][] grid;\\n    int maxRow;\\n    int maxCol;\\n    int freeSpace;\\n    //1 = Guard\\n    //2 = Wall\\n    //0 = Free Space\\n  \\n    public int CountUnguarded(int maxRow, int maxCol, int[][] guards, int[][] walls) {\\n      grid = new int[maxRow][];\\n      this.maxRow = maxRow;\\n      this.maxCol = maxCol;\\n      freeSpace = maxRow * maxCol;\\n      \\n      for(int r=0;r<maxRow;r++){\\n        grid[r] = new int[maxCol];\\n      }\\n      \\n      foreach(var wall in walls){\\n        grid[wall[0]][wall[1]] = 2;\\n        freeSpace--;\\n      }\\n      \\n      foreach(var guard in guards){\\n        grid[guard[0]][guard[1]] = 1;\\n        freeSpace--;\\n      }\\n      \\n      foreach(var guard in guards){\\n        Guard(guard[0], guard[1]);\\n      }\\n      \\n      return freeSpace;\\n    }\\n  \\n    private void Guard(int row, int col){\\n      Up(row,col);\\n      Down(row,col);\\n      Left(row,col);\\n      Right(row,col);\\n    }\\n  \\n    private void Up(int row, int col){\\n      while(true){\\n        var nextRow = --row;\\n        var nextCol = col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }        \\n      }\\n    }\\n  \\n    private void Down(int row, int col){\\n      while(true){\\n        var nextRow = ++row;\\n        var nextCol = col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private void Left(int row, int col){\\n      while(true){\\n        var nextRow = row;\\n        var nextCol = --col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private void Right(int row, int col){\\n      while(true){\\n        var nextRow = row;\\n        var nextCol = ++col;\\n        \\n        if(OutOfBound(nextRow,nextCol)) return;\\n        if(grid[nextRow][nextCol] == 2) return;\\n        if(grid[nextRow][nextCol] == 1) return;\\n        \\n        if(grid[nextRow][nextCol] == 0){\\n          freeSpace--;\\n          grid[nextRow][nextCol] = -1;\\n        }     \\n      }\\n    }\\n  \\n    private bool OutOfBound(int row, int col){\\n      return row >= maxRow || row < 0 || col >= maxCol || col < 0;\\n    }\\n  \\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942345,
                "title": "golang-294-ms-13-1-mb",
                "content": "```\\nconst Unguarded = 0\\nconst (\\n\\tGuardedHorizontally = 1 << iota\\n\\tGuardedVertically   = 1 << iota\\n)\\n\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n\\tgrid := make([][]byte, m)\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tgrid[i] = make([]byte, n)\\n\\t}\\n\\tfor _, wall := range walls {\\n\\t\\tgrid[wall[0]][wall[1]] = GuardedHorizontally | GuardedVertically\\n\\t}\\n\\tfor _, guard := range guards {\\n\\t\\ti, j := guard[0], guard[1]\\n\\t\\tgrid[i][j] = GuardedHorizontally | GuardedVertically\\n\\t\\tfor i := i - 1; i >= 0 && grid[i][j]&GuardedVertically == Unguarded; i-- {\\n\\t\\t\\tgrid[i][j] |= GuardedVertically\\n\\t\\t}\\n\\t\\tfor i := i + 1; i < m && grid[i][j]&GuardedVertically == Unguarded; i++ {\\n\\t\\t\\tgrid[i][j] |= GuardedVertically\\n\\t\\t}\\n\\t\\tfor j := j - 1; j >= 0 && grid[i][j]&GuardedHorizontally == Unguarded; j-- {\\n\\t\\t\\tgrid[i][j] |= GuardedHorizontally\\n\\t\\t}\\n\\t\\tfor j := j + 1; j < n && grid[i][j]&GuardedHorizontally == Unguarded; j++ {\\n\\t\\t\\tgrid[i][j] |= GuardedHorizontally\\n\\t\\t}\\n\\t}\\n\\tvar result int\\n\\tfor _, row := range grid {\\n\\t\\tfor _, cell := range row {\\n\\t\\t\\tif cell == Unguarded {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst Unguarded = 0\\nconst (\\n\\tGuardedHorizontally = 1 << iota\\n\\tGuardedVertically   = 1 << iota\\n)\\n\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n\\tgrid := make([][]byte, m)\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tgrid[i] = make([]byte, n)\\n\\t}\\n\\tfor _, wall := range walls {\\n\\t\\tgrid[wall[0]][wall[1]] = GuardedHorizontally | GuardedVertically\\n\\t}\\n\\tfor _, guard := range guards {\\n\\t\\ti, j := guard[0], guard[1]\\n\\t\\tgrid[i][j] = GuardedHorizontally | GuardedVertically\\n\\t\\tfor i := i - 1; i >= 0 && grid[i][j]&GuardedVertically == Unguarded; i-- {\\n\\t\\t\\tgrid[i][j] |= GuardedVertically\\n\\t\\t}\\n\\t\\tfor i := i + 1; i < m && grid[i][j]&GuardedVertically == Unguarded; i++ {\\n\\t\\t\\tgrid[i][j] |= GuardedVertically\\n\\t\\t}\\n\\t\\tfor j := j - 1; j >= 0 && grid[i][j]&GuardedHorizontally == Unguarded; j-- {\\n\\t\\t\\tgrid[i][j] |= GuardedHorizontally\\n\\t\\t}\\n\\t\\tfor j := j + 1; j < n && grid[i][j]&GuardedHorizontally == Unguarded; j++ {\\n\\t\\t\\tgrid[i][j] |= GuardedHorizontally\\n\\t\\t}\\n\\t}\\n\\tvar result int\\n\\tfor _, row := range grid {\\n\\t\\tfor _, cell := range row {\\n\\t\\t\\tif cell == Unguarded {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2890864,
                "title": "c-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to solve problem in $$O(m*n)$$ time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate matrix, a, and first add 16 in cell where are the guards and 23 in cells where are the walls. Set 0 to the rest of the cells. Iterate through matrix from left, right, top, bottom, and remember did we encouter Wall or Guard in that row/ column.\\nIf we last encountered Guard that means that that cell is guarded. We use different number to clarify from which side the cell is guarded: 0x1000 from left, 0b0100 from right, 0b0010 from top, 0b0001 from bottom. Add the end we count unguarded cells.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int a[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                a[i][j] = 0;\\n            }\\n        }\\n        for (auto& g : guards) {\\n            a[g[0]][g[1]] = 16;\\n        }\\n        for (auto& w : walls) {\\n            a[w[0]][w[1]] = 32;\\n        }\\n        char cur = \\'X\\';\\n        // pass from left\\n        for (int i = 0; i < m; ++i) {\\n            cur = \\'X\\';\\n            for (int j = 0; j < n; ++j) {\\n                if (a[i][j] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[i][j] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[i][j] = a[i][j] | 0b1000;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from right\\n        for (int i = 0; i < m; ++i) {\\n            cur = \\'X\\';\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (a[i][j] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[i][j] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[i][j] = a[i][j] | 0b0100;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from top\\n        for (int i = 0; i < n; ++i) {\\n            cur = \\'X\\';\\n            for (int j = 0; j < m; ++j) {\\n                if (a[j][i] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[j][i] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[j][i] = a[j][i] | 0b0010;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from bottom\\n        for (int i = 0; i < n; ++i) {\\n            cur = \\'X\\';\\n            for (int j = m - 1; j >= 0; --j) {\\n                if (a[j][i] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[j][i] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[j][i] = a[j][i] | 0b0001;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (a[i][j] == 0) {\\n                    ++count;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int a[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                a[i][j] = 0;\\n            }\\n        }\\n        for (auto& g : guards) {\\n            a[g[0]][g[1]] = 16;\\n        }\\n        for (auto& w : walls) {\\n            a[w[0]][w[1]] = 32;\\n        }\\n        char cur = \\'X\\';\\n        // pass from left\\n        for (int i = 0; i < m; ++i) {\\n            cur = \\'X\\';\\n            for (int j = 0; j < n; ++j) {\\n                if (a[i][j] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[i][j] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[i][j] = a[i][j] | 0b1000;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from right\\n        for (int i = 0; i < m; ++i) {\\n            cur = \\'X\\';\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (a[i][j] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[i][j] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[i][j] = a[i][j] | 0b0100;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from top\\n        for (int i = 0; i < n; ++i) {\\n            cur = \\'X\\';\\n            for (int j = 0; j < m; ++j) {\\n                if (a[j][i] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[j][i] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[j][i] = a[j][i] | 0b0010;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // pass from bottom\\n        for (int i = 0; i < n; ++i) {\\n            cur = \\'X\\';\\n            for (int j = m - 1; j >= 0; --j) {\\n                if (a[j][i] == 16) {\\n                    cur = \\'G\\';\\n                }\\n                else if (a[j][i] == 32) {\\n                    cur = \\'W\\';\\n                }\\n                else {\\n                    if (cur == \\'G\\') {\\n                        a[j][i] = a[j][i] | 0b0001;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (a[i][j] == 0) {\\n                    ++count;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876688,
                "title": "count-unguarded-cells-in-the-grid",
                "content": "# Intuition\\nthe main problem is about to count the cells which are guarded by any of the guards\\n\\n# Approach\\nwe will count the number of guarded cells by iterating every guard\\'s four direction path until we encounter any wall or guard\\n\\n# Complexity\\n- Time complexity:over all time complexity is O(m*n)\\n\\n- Space complexity:we are using 2D array of m*n size ,so O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> v(m,vector<char>(n,\\'0\\'));\\n        int a=guards.size();\\n        for(int i=0;i<a;i++){\\n              v[guards[i][0]][guards[i][1]]=\\'G\\';\\n        }\\n        int b=walls.size();\\n        for(int i=0;i<b;i++){\\n              v[walls[i][0]][walls[i][1]]=\\'W\\';\\n        }\\n        int ct(0);\\n        for(int i=0;i<a;i++){\\n              int x=guards[i][0];\\n              int y=guards[i][1];\\n              int s=x+1,o=x-1,ss=y+1,oo=y-1;\\n//downward path\\n              while(s<m && (v[s][y]!=\\'W\\' && v[s][y]!=\\'G\\')){\\n                  if(v[s][y]==\\'0\\') ct++;\\n                  v[s][y]=\\'1\\';\\n                  s++;\\n              }\\n//upward path\\n              while(o>=0 && (v[o][y]!=\\'W\\' && v[o][y]!=\\'G\\')){\\n                  if(v[o][y]==\\'0\\') ct++;\\n                  v[o][y]=\\'1\\';\\n                  o--;\\n              }\\n//rightward path\\n              while(ss<n && (v[x][ss]!=\\'W\\' && v[x][ss]!=\\'G\\')){\\n                  if(v[x][ss]==\\'0\\') ct++;\\n                  v[x][ss]=\\'1\\';\\n                  ss++;\\n              }\\n//leftward path\\n              while(oo>=0 && (v[x][oo]!=\\'W\\' && v[x][oo]!=\\'G\\')){\\n                  if(v[x][oo]==\\'0\\') ct++;\\n                  v[x][oo]=\\'1\\';\\n                  oo--;\\n              }\\n        }\\n//total cells - aquired cells\\n        return m*n-a-b-ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> v(m,vector<char>(n,\\'0\\'));\\n        int a=guards.size();\\n        for(int i=0;i<a;i++){\\n              v[guards[i][0]][guards[i][1]]=\\'G\\';\\n        }\\n        int b=walls.size();\\n        for(int i=0;i<b;i++){\\n              v[walls[i][0]][walls[i][1]]=\\'W\\';\\n        }\\n        int ct(0);\\n        for(int i=0;i<a;i++){\\n              int x=guards[i][0];\\n              int y=guards[i][1];\\n              int s=x+1,o=x-1,ss=y+1,oo=y-1;\\n//downward path\\n              while(s<m && (v[s][y]!=\\'W\\' && v[s][y]!=\\'G\\')){\\n                  if(v[s][y]==\\'0\\') ct++;\\n                  v[s][y]=\\'1\\';\\n                  s++;\\n              }\\n//upward path\\n              while(o>=0 && (v[o][y]!=\\'W\\' && v[o][y]!=\\'G\\')){\\n                  if(v[o][y]==\\'0\\') ct++;\\n                  v[o][y]=\\'1\\';\\n                  o--;\\n              }\\n//rightward path\\n              while(ss<n && (v[x][ss]!=\\'W\\' && v[x][ss]!=\\'G\\')){\\n                  if(v[x][ss]==\\'0\\') ct++;\\n                  v[x][ss]=\\'1\\';\\n                  ss++;\\n              }\\n//leftward path\\n              while(oo>=0 && (v[x][oo]!=\\'W\\' && v[x][oo]!=\\'G\\')){\\n                  if(v[x][oo]==\\'0\\') ct++;\\n                  v[x][oo]=\\'1\\';\\n                  oo--;\\n              }\\n        }\\n//total cells - aquired cells\\n        return m*n-a-b-ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876586,
                "title": "java-dfs-with-some-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        int grid[][]=new int[n][m];\\n        for(int guard[]:guards)\\n            grid[guard[0]][guard[1]]=2;\\n        for(int wall[]:walls)\\n            grid[wall[0]][wall[1]]=-2;\\n        for(int guard[]:guards){\\n                dfs(guard[0]-1, guard[1],grid,n,m,1);\\n                dfs(guard[0],guard[1]+1,grid,n,m, 2);\\n                dfs(guard[0]+1, guard[1],grid,n,m,3);\\n                dfs(guard[0], guard[1]-1,grid,n,m,4);\\n        }\\n       int count = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j]!=-1 && grid[i][j] != -2 && grid[i][j] != 2)\\n                    count++;\\n        \\n        return count;\\n    }\\n    void dfs(int i,int j,int grid[][],int n,int m,int val){\\n        if(i>=n ||i<0||j<0||j>=m ||grid[i][j]==2||grid[i][j]==-2)\\n            return ;\\n        // if(grid[i][j]==-1)\\n        //     return;\\n        //we are not writing the above statement as\\n          /////    -1\\n        // G -1 -1 -1 -1 -1 W\\n        //         -1\\n        //(when we reach the mid point if we return we will not go down)\\n        grid[i][j]=-1;//marking it visited\\n        if(val==1)\\n            dfs(i-1,j,grid,n,m,1);\\n        else if(val==2)\\n            dfs(i,j+1,grid,n,m,2);\\n        else if(val==3)\\n            dfs(i+1,j,grid,n,m,3);\\n        else\\n            dfs(i,j-1,grid,n,m,4);\\n            return ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int n, int m, int[][] guards, int[][] walls) {\\n        int grid[][]=new int[n][m];\\n        for(int guard[]:guards)\\n            grid[guard[0]][guard[1]]=2;\\n        for(int wall[]:walls)\\n            grid[wall[0]][wall[1]]=-2;\\n        for(int guard[]:guards){\\n                dfs(guard[0]-1, guard[1],grid,n,m,1);\\n                dfs(guard[0],guard[1]+1,grid,n,m, 2);\\n                dfs(guard[0]+1, guard[1],grid,n,m,3);\\n                dfs(guard[0], guard[1]-1,grid,n,m,4);\\n        }\\n       int count = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(grid[i][j]!=-1 && grid[i][j] != -2 && grid[i][j] != 2)\\n                    count++;\\n        \\n        return count;\\n    }\\n    void dfs(int i,int j,int grid[][],int n,int m,int val){\\n        if(i>=n ||i<0||j<0||j>=m ||grid[i][j]==2||grid[i][j]==-2)\\n            return ;\\n        // if(grid[i][j]==-1)\\n        //     return;\\n        //we are not writing the above statement as\\n          /////    -1\\n        // G -1 -1 -1 -1 -1 W\\n        //         -1\\n        //(when we reach the mid point if we return we will not go down)\\n        grid[i][j]=-1;//marking it visited\\n        if(val==1)\\n            dfs(i-1,j,grid,n,m,1);\\n        else if(val==2)\\n            dfs(i,j+1,grid,n,m,2);\\n        else if(val==3)\\n            dfs(i+1,j,grid,n,m,3);\\n        else\\n            dfs(i,j-1,grid,n,m,4);\\n            return ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2875447,
                "title": "simple-c-solution-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    int total ;\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n\\n        total = 0 ;\\n        vector<vector<int>>mat(m,vector<int>(n,0)) ;\\n\\n        for(auto&k:guards)\\n            mat[k[0]][k[1]] = 1 ;\\n        \\n        for(auto&k:walls)\\n            mat[k[0]][k[1]] = 2 ;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( mat[i][j] == 1 )\\n                {\\n                    dfs(mat,i+1,j,m,n,1) ;\\n                    dfs(mat,i-1,j,m,n,2) ;\\n                    dfs(mat,i,j+1,m,n,3) ;\\n                    dfs(mat,i,j-1,m,n,4) ;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( mat[i][j] == 0 )\\n                    total++ ;\\n                //cout<<mat[i][j]<<\"  \" ;\\n            }\\n            //cout<<endl ;\\n        }\\n\\n        return total ;\\n    }\\n    \\n\\n   void dfs(vector<vector<int>>&mat,int x,int y,int m,int n,int dir)\\n    {\\n        if( min(x,y) < 0 || x >= m || y >= n )\\n            return ;\\n\\n        if( mat[x][y] == 2 || mat[x][y] == 1 )\\n            return ;\\n\\n        mat[x][y] = 3 ;\\n        \\n        if( dir == 1 )\\n            dfs(mat,x+1,y,m,n,1) ;\\n        if( dir == 2 )\\n            dfs(mat,x-1,y,m,n,2) ;\\n        if( dir == 3 )\\n            dfs(mat,x,y+1,m,n,3) ;\\n        if( dir == 4 )\\n            dfs(mat,x,y-1,m,n,4) ;\\n        \\n        return ;\\n    }\\n\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    int total ;\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n\\n        total = 0 ;\\n        vector<vector<int>>mat(m,vector<int>(n,0)) ;\\n\\n        for(auto&k:guards)\\n            mat[k[0]][k[1]] = 1 ;\\n        \\n        for(auto&k:walls)\\n            mat[k[0]][k[1]] = 2 ;\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( mat[i][j] == 1 )\\n                {\\n                    dfs(mat,i+1,j,m,n,1) ;\\n                    dfs(mat,i-1,j,m,n,2) ;\\n                    dfs(mat,i,j+1,m,n,3) ;\\n                    dfs(mat,i,j-1,m,n,4) ;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( mat[i][j] == 0 )\\n                    total++ ;\\n                //cout<<mat[i][j]<<\"  \" ;\\n            }\\n            //cout<<endl ;\\n        }\\n\\n        return total ;\\n    }\\n    \\n\\n   void dfs(vector<vector<int>>&mat,int x,int y,int m,int n,int dir)\\n    {\\n        if( min(x,y) < 0 || x >= m || y >= n )\\n            return ;\\n\\n        if( mat[x][y] == 2 || mat[x][y] == 1 )\\n            return ;\\n\\n        mat[x][y] = 3 ;\\n        \\n        if( dir == 1 )\\n            dfs(mat,x+1,y,m,n,1) ;\\n        if( dir == 2 )\\n            dfs(mat,x-1,y,m,n,2) ;\\n        if( dir == 3 )\\n            dfs(mat,x,y+1,m,n,3) ;\\n        if( dir == 4 )\\n            dfs(mat,x,y-1,m,n,4) ;\\n        \\n        return ;\\n    }\\n\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2863588,
                "title": "simple-solution-using-traversing-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void seeall(int i,int j, vector<vector<char>> &g){\\n        // go up\\n        for(int r = i-1;r>=0;r--){\\n            if(g[r][j] == \\'N\\' || g[r][j] == \\'V\\'){\\n                g[r][j] = \\'V\\';\\n            }else break;\\n        }\\n        // go down\\n        for(int r = i+1;r<g.size();r++){\\n            if(g[r][j] == \\'N\\' || g[r][j] == \\'V\\'){\\n                g[r][j] = \\'V\\';\\n            }else break;\\n        }\\n        // go left\\n        for(int c = j-1;c>=0;c--){\\n            if(g[i][c] == \\'N\\' || g[i][c] == \\'V\\'){\\n                g[i][c] = \\'V\\';\\n            }else break;\\n        }\\n        // go right\\n        for(int c = j+1;c<g[0].size();c++){\\n            if(g[i][c] == \\'N\\' || g[i][c] == \\'V\\'){\\n                g[i][c] = \\'V\\';\\n            }else break;\\n        }\\n    }\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(m,vector<char>(n,\\'N\\'));\\n        // Now fill with wall and gaurd\\n        for(auto x: guards){\\n            grid[x[0]][x[1]] = \\'G\\';\\n        }\\n        for(auto x: walls){\\n            grid[x[0]][x[1]] = \\'W\\';\\n        }\\n        // Now for each gaurd mark every cell V\\n        for(auto x: guards){\\n            seeall(x[0],x[1],grid);\\n        }\\n        int ans = 0 ;\\n        for(auto x: grid){\\n            for(auto c: x) if(c == \\'N\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void seeall(int i,int j, vector<vector<char>> &g){\\n        // go up\\n        for(int r = i-1;r>=0;r--){\\n            if(g[r][j] == \\'N\\' || g[r][j] == \\'V\\'){\\n                g[r][j] = \\'V\\';\\n            }else break;\\n        }\\n        // go down\\n        for(int r = i+1;r<g.size();r++){\\n            if(g[r][j] == \\'N\\' || g[r][j] == \\'V\\'){\\n                g[r][j] = \\'V\\';\\n            }else break;\\n        }\\n        // go left\\n        for(int c = j-1;c>=0;c--){\\n            if(g[i][c] == \\'N\\' || g[i][c] == \\'V\\'){\\n                g[i][c] = \\'V\\';\\n            }else break;\\n        }\\n        // go right\\n        for(int c = j+1;c<g[0].size();c++){\\n            if(g[i][c] == \\'N\\' || g[i][c] == \\'V\\'){\\n                g[i][c] = \\'V\\';\\n            }else break;\\n        }\\n    }\\n\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> grid(m,vector<char>(n,\\'N\\'));\\n        // Now fill with wall and gaurd\\n        for(auto x: guards){\\n            grid[x[0]][x[1]] = \\'G\\';\\n        }\\n        for(auto x: walls){\\n            grid[x[0]][x[1]] = \\'W\\';\\n        }\\n        // Now for each gaurd mark every cell V\\n        for(auto x: guards){\\n            seeall(x[0],x[1],grid);\\n        }\\n        int ans = 0 ;\\n        for(auto x: grid){\\n            for(auto c: x) if(c == \\'N\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844859,
                "title": "row-sweeping-and-rotating-matrix",
                "content": "# Intuition\\nFirstly I thought of making something like bruteforce, for each guard mark every node which is under his supervision, but that will take $$O(n*m*(n+ m))$$ complexity, since for each guard n*m we are going to mark n + m places visited by him. \\n    2nd Solution can be by sweeping on matrix from top row to bottom marking nodes which are guarded by some upper guard. \\n# Approach\\nFor that we needs to be done for all 4 directions, to make implementation easy I choose to rotate matrix and then always sweeping from top to bottom marking guards supervision. \\n\\n# Complexity\\n- Time complexity:  $$O(n*m)$$ to make matrix and operating on it\\n<!-- Add your time complexity here, e.g. -->\\n\\n- Space complexity: $$O(n*m)$$ some constant steps are done on matrix n*m \\n<!-- Add your space complexity here, e.g.  -->\\n\\n# Code\\n```\\nclass Solution {\\n    void sweep(vector<vector<char> > &matrix){\\n        vector<char> prev(matrix[0].size(),\\'U\\'); \\n        for(int i=0;i<matrix.size();i+=1){\\n            for(int j=0;j<matrix[0].size();j+=1){\\n                auto &ch = matrix[i][j]; \\n                if(ch == \\'W\\') // means remove any previous guarding being done \\n                    prev[j] = \\'U\\'; \\n                else if(ch == \\'U\\') // check if someone above it guards it \\n                    ch = prev[j]; \\n                else if(ch == \\'G\\')// this is guard mark it as saviour of others  \\n                    prev[j] = \\'P\\'; \\n            }\\n        }\\n        return; \\n    }\\n    vector<vector<char> >  rotate(vector<vector<char> > &matrix){ // anticloclwise movement \\n        // just by looking at what index value going where after rotation is implemeted in code \\n        int n = matrix.size(); \\n        int m = matrix[0].size(); \\n        vector<vector<char> > res(m,vector<char>(n,\\'U\\')); \\n        int x = m-1,y = 0; \\n        for(int i=0,y = 0;i<n;i+=1,y+=1){\\n            for(int j=0,x = m-1;j<m;j+=1,x-=1){\\n                res[x][y] = matrix[i][j]; \\n            }\\n        }\\n        return res; \\n    }\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char> > matrix(m,vector<char>(n,\\'U\\')); \\n        for(auto &elm: guards){\\n            matrix[elm[0]][elm[1]] = \\'G\\'; \\n        }\\n        for(auto &elm: walls){\\n            matrix[elm[0]][elm[1]] = \\'W\\'; \\n        }\\n        for(int i=0;i<4;i+=1){\\n            sweep(matrix); \\n            matrix = rotate(matrix); \\n        }\\n        int count = 0; \\n        for(auto &v : matrix){\\n            for(auto &elm: v){\\n                count += (elm == \\'U\\'); \\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void sweep(vector<vector<char> > &matrix){\\n        vector<char> prev(matrix[0].size(),\\'U\\'); \\n        for(int i=0;i<matrix.size();i+=1){\\n            for(int j=0;j<matrix[0].size();j+=1){\\n                auto &ch = matrix[i][j]; \\n                if(ch == \\'W\\') // means remove any previous guarding being done \\n                    prev[j] = \\'U\\'; \\n                else if(ch == \\'U\\') // check if someone above it guards it \\n                    ch = prev[j]; \\n                else if(ch == \\'G\\')// this is guard mark it as saviour of others  \\n                    prev[j] = \\'P\\'; \\n            }\\n        }\\n        return; \\n    }\\n    vector<vector<char> >  rotate(vector<vector<char> > &matrix){ // anticloclwise movement \\n        // just by looking at what index value going where after rotation is implemeted in code \\n        int n = matrix.size(); \\n        int m = matrix[0].size(); \\n        vector<vector<char> > res(m,vector<char>(n,\\'U\\')); \\n        int x = m-1,y = 0; \\n        for(int i=0,y = 0;i<n;i+=1,y+=1){\\n            for(int j=0,x = m-1;j<m;j+=1,x-=1){\\n                res[x][y] = matrix[i][j]; \\n            }\\n        }\\n        return res; \\n    }\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char> > matrix(m,vector<char>(n,\\'U\\')); \\n        for(auto &elm: guards){\\n            matrix[elm[0]][elm[1]] = \\'G\\'; \\n        }\\n        for(auto &elm: walls){\\n            matrix[elm[0]][elm[1]] = \\'W\\'; \\n        }\\n        for(int i=0;i<4;i+=1){\\n            sweep(matrix); \\n            matrix = rotate(matrix); \\n        }\\n        int count = 0; \\n        for(auto &v : matrix){\\n            for(auto &elm: v){\\n                count += (elm == \\'U\\'); \\n            }\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807659,
                "title": "cpp-easy-to-understand-4-dirn-from-every-guard",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<char>>mat;\\nint count;\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls)    \\n{\\n\\tcount=0;\\n    mat.resize(m,vector<char>(n,\\' \\'));\\n\\tfor(int i=0;i<guards.size();i++)\\n\\t{\\n\\t    int r = guards[i][0];\\n\\t    int c = guards[i][1];\\n\\t    mat[r][c] = \\'g\\';\\n    }\\n\\tfor(int i=0;i<walls.size();i++)\\n\\t{\\n\\t    int r = walls[i][0];\\n\\t    int c = walls[i][1];\\n\\t    mat[r][c] = \\'w\\';\\n    }       \\n\\t//if some empty cell is being guarded by some other guard it would mark it as \\'*\"   \\n    for(int i=0;i<mat.size();i++)\\n    {\\n    \\tfor(int j=0;j<mat[i].size();j++)\\n    \\t{\\n    \\t\\tif(mat[i][j]==\\' \\' or  mat[i][j]==\\'*\\' or mat[i][j]==\\'w\\')\\n    \\t\\t{\\n    \\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(mat[i][j] == \\'g\\')\\n\\t\\t\\t{\\n\\t\\t\\t    fun(i,j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<mat.size();i++)\\n\\t{\\n\\t\\tfor(int j=0;j<mat[i].size();j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j] == \\' \\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\nvoid fun(int row,int col)\\n{\\n\\tint temp_row;\\n\\tint temp_col;\\n\\t\\n\\t//checking up\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\n\\twhile(temp_row >= 0)\\n\\t{\\n        temp_row--;\\n         \\n        if(temp_row < 0)\\n        break;\\n\\n        if((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n\\t\\tmat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking down\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_row < mat.size())\\n\\t{\\n        temp_row++;\\n\\t\\t\\n        if(temp_row >= mat.size())\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking left\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_col>=0)\\n\\t{\\n\\t\\ttemp_col--;\\n\\n        if(temp_col < 0)\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking right\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_col < mat[0].size())\\n\\t{\\n\\t\\ttemp_col++;\\n\\t\\t\\n        if(temp_col >= mat[0].size())\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\tmat[row][col] = \\'g\\';\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<char>>mat;\\nint count;\\nint countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls)    \\n{\\n\\tcount=0;\\n    mat.resize(m,vector<char>(n,\\' \\'));\\n\\tfor(int i=0;i<guards.size();i++)\\n\\t{\\n\\t    int r = guards[i][0];\\n\\t    int c = guards[i][1];\\n\\t    mat[r][c] = \\'g\\';\\n    }\\n\\tfor(int i=0;i<walls.size();i++)\\n\\t{\\n\\t    int r = walls[i][0];\\n\\t    int c = walls[i][1];\\n\\t    mat[r][c] = \\'w\\';\\n    }       \\n\\t//if some empty cell is being guarded by some other guard it would mark it as \\'*\"   \\n    for(int i=0;i<mat.size();i++)\\n    {\\n    \\tfor(int j=0;j<mat[i].size();j++)\\n    \\t{\\n    \\t\\tif(mat[i][j]==\\' \\' or  mat[i][j]==\\'*\\' or mat[i][j]==\\'w\\')\\n    \\t\\t{\\n    \\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\telse if(mat[i][j] == \\'g\\')\\n\\t\\t\\t{\\n\\t\\t\\t    fun(i,j);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<mat.size();i++)\\n\\t{\\n\\t\\tfor(int j=0;j<mat[i].size();j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j] == \\' \\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\nvoid fun(int row,int col)\\n{\\n\\tint temp_row;\\n\\tint temp_col;\\n\\t\\n\\t//checking up\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\n\\twhile(temp_row >= 0)\\n\\t{\\n        temp_row--;\\n         \\n        if(temp_row < 0)\\n        break;\\n\\n        if((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n\\t\\tmat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking down\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_row < mat.size())\\n\\t{\\n        temp_row++;\\n\\t\\t\\n        if(temp_row >= mat.size())\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking left\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_col>=0)\\n\\t{\\n\\t\\ttemp_col--;\\n\\n        if(temp_col < 0)\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\t//checking right\\n\\ttemp_row = row;\\n\\ttemp_col = col;\\n\\twhile(temp_col < mat[0].size())\\n\\t{\\n\\t\\ttemp_col++;\\n\\t\\t\\n        if(temp_col >= mat[0].size())\\n        break;\\n\\n\\t\\tif((temp_row!=row or temp_col!=col) and (mat[temp_row][temp_col]==\\'g\\' or mat[temp_row][temp_col]==\\'w\\'))\\n\\t\\tbreak;\\n\\n        mat[temp_row][temp_col] = \\'*\\';\\n\\t}\\n\\t\\n\\tmat[row][col] = \\'g\\';\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757738,
                "title": "c-solution-using-random-shuffle",
                "content": "```\\nclass Solution {\\n public:\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    vector<vector<int>> g(m, vector<int>(n));\\n    for (auto& v : walls) g[v[0]][v[1]] = 1;\\n    auto rng = std::default_random_engine{};\\n    shuffle(guards.begin(), guards.end(), rng);\\n    for (auto& v : guards) {\\n      int x = v[0], y = v[1];\\n      g[x][y] = 2;\\n      static int d[] = {-1, 0, 1, 0, -1};\\n      for (int k = 0; k < 4; k++) {\\n        int dx = d[k], dy = d[k + 1];\\n        for (int s = 1;; s++) {\\n          int nx = x + s * dx, ny = y + s * dy;\\n          if (0 <= nx && nx < m && 0 <= ny && ny < n) {\\n            if (g[nx][ny] == 1 || g[nx][ny] == 2) break;\\n            g[nx][ny] = 3;\\n          } else\\n            break;\\n        }\\n      }\\n    }\\n\\n    int res = 0;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++)\\n        if (!g[i][j]) res++;\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    vector<vector<int>> g(m, vector<int>(n));\\n    for (auto& v : walls) g[v[0]][v[1]] = 1;\\n    auto rng = std::default_random_engine{};\\n    shuffle(guards.begin(), guards.end(), rng);\\n    for (auto& v : guards) {\\n      int x = v[0], y = v[1];\\n      g[x][y] = 2;\\n      static int d[] = {-1, 0, 1, 0, -1};\\n      for (int k = 0; k < 4; k++) {\\n        int dx = d[k], dy = d[k + 1];\\n        for (int s = 1;; s++) {\\n          int nx = x + s * dx, ny = y + s * dy;\\n          if (0 <= nx && nx < m && 0 <= ny && ny < n) {\\n            if (g[nx][ny] == 1 || g[nx][ny] == 2) break;\\n            g[nx][ny] = 3;\\n          } else\\n            break;\\n        }\\n      }\\n    }\\n\\n    int res = 0;\\n    for (int i = 0; i < m; i++)\\n      for (int j = 0; j < n; j++)\\n        if (!g[i][j]) res++;\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757724,
                "title": "golang-bitmasking",
                "content": "```go\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n  mat := make([][]int, m)\\n  for i := 0; i < m; i++ {\\n    mat[i] = make([]int, n)\\n  }\\n  var occupied int\\n  for _, wall := range walls {\\n    mat[wall[0]][wall[1]] = -1\\n    occupied++\\n  }\\n  // We mark the matrix with bitmasking of whether horizontal or vertical\\n  // coverage present at a specific cell.\\n  // 01 - horizontal\\n  // 10 - vertical\\n  // 11 - both horizontal and vertical\\n  // 00 - no coverage\\n  directions := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n  markers := [4]int{1, 2, 1, 2}\\n  for _, guard := range guards {\\n    mat[guard[0]][guard[1]] = 3 // Coverage at both horizontal and vertical\\n    occupied++\\n  }\\n  // Now let\\'s mark all the positions that each guard can watch\\n  for _, guard := range guards {\\n    for idx, dir := range directions {\\n      x, y := guard[0] + dir[0], guard[1] + dir[1]\\n      for x >= 0 && x < m && y >= 0 && y < n && mat[x][y] != -1 && mat[x][y] & markers[idx] == 0 {\\n        if mat[x][y] == 0 {\\n          occupied++\\n        }\\n        mat[x][y] = mat[x][y] | markers[idx]\\n        x, y = x + dir[0], y + dir[1]\\n      }\\n    }\\n  }\\n  return m*n - occupied\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bitmask"
                ],
                "code": "```go\\nfunc countUnguarded(m int, n int, guards [][]int, walls [][]int) int {\\n  mat := make([][]int, m)\\n  for i := 0; i < m; i++ {\\n    mat[i] = make([]int, n)\\n  }\\n  var occupied int\\n  for _, wall := range walls {\\n    mat[wall[0]][wall[1]] = -1\\n    occupied++\\n  }\\n  // We mark the matrix with bitmasking of whether horizontal or vertical\\n  // coverage present at a specific cell.\\n  // 01 - horizontal\\n  // 10 - vertical\\n  // 11 - both horizontal and vertical\\n  // 00 - no coverage\\n  directions := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n  markers := [4]int{1, 2, 1, 2}\\n  for _, guard := range guards {\\n    mat[guard[0]][guard[1]] = 3 // Coverage at both horizontal and vertical\\n    occupied++\\n  }\\n  // Now let\\'s mark all the positions that each guard can watch\\n  for _, guard := range guards {\\n    for idx, dir := range directions {\\n      x, y := guard[0] + dir[0], guard[1] + dir[1]\\n      for x >= 0 && x < m && y >= 0 && y < n && mat[x][y] != -1 && mat[x][y] & markers[idx] == 0 {\\n        if mat[x][y] == 0 {\\n          occupied++\\n        }\\n        mat[x][y] = mat[x][y] | markers[idx]\\n        x, y = x + dir[0], y + dir[1]\\n      }\\n    }\\n  }\\n  return m*n - occupied\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2719870,
                "title": "find-free-cells-by-subtracting-occupied-cells-by-guards-java-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n       char[][] grid = new char[m][n];\\n        for (int[] g : guards)\\n            grid[g[0]][g[1]] = \\'G\\';\\n        for (int[] w : walls)\\n            grid[w[0]][w[1]] = \\'W\\';\\n\\n        int[] count = new int[1];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'G\\')\\n                    simulate(grid, i, j, count);\\n            }\\n        }\\n        return (m * n) - (guards.length + walls.length + count[0]);\\n    }\\n    \\n   public void simulate(char[][] grid, int row, int col, int[] count) {\\n        // UP check\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (grid[i][col] == \\'G\\' || grid[i][col] == \\'W\\') {\\n                break;\\n            } else if (grid[i][col] != \\'C\\') {\\n                grid[i][col] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n        // Down check\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (grid[i][col] == \\'G\\' || grid[i][col] == \\'W\\') {\\n                break;\\n            } else if (grid[i][col] != \\'C\\') {\\n                grid[i][col] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n\\n        // Left check\\n        for (int i = col - 1; i >= 0; i--) {\\n            if (grid[row][i] == \\'G\\' || grid[row][i] == \\'W\\') {\\n                break;\\n            } else if (grid[row][i] != \\'C\\') {\\n                grid[row][i] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n\\n        // Right check\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (grid[row][i] == \\'G\\' || grid[row][i] == \\'W\\') {\\n                break;\\n            } else if (grid[row][i] != \\'C\\') {\\n                grid[row][i] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n       char[][] grid = new char[m][n];\\n        for (int[] g : guards)\\n            grid[g[0]][g[1]] = \\'G\\';\\n        for (int[] w : walls)\\n            grid[w[0]][w[1]] = \\'W\\';\\n\\n        int[] count = new int[1];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == \\'G\\')\\n                    simulate(grid, i, j, count);\\n            }\\n        }\\n        return (m * n) - (guards.length + walls.length + count[0]);\\n    }\\n    \\n   public void simulate(char[][] grid, int row, int col, int[] count) {\\n        // UP check\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (grid[i][col] == \\'G\\' || grid[i][col] == \\'W\\') {\\n                break;\\n            } else if (grid[i][col] != \\'C\\') {\\n                grid[i][col] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n        // Down check\\n        for (int i = row + 1; i < grid.length; i++) {\\n            if (grid[i][col] == \\'G\\' || grid[i][col] == \\'W\\') {\\n                break;\\n            } else if (grid[i][col] != \\'C\\') {\\n                grid[i][col] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n\\n        // Left check\\n        for (int i = col - 1; i >= 0; i--) {\\n            if (grid[row][i] == \\'G\\' || grid[row][i] == \\'W\\') {\\n                break;\\n            } else if (grid[row][i] != \\'C\\') {\\n                grid[row][i] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n\\n        // Right check\\n        for (int i = col + 1; i < grid[0].length; i++) {\\n            if (grid[row][i] == \\'G\\' || grid[row][i] == \\'W\\') {\\n                break;\\n            } else if (grid[row][i] != \\'C\\') {\\n                grid[row][i] = \\'C\\';\\n                count[0]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718108,
                "title": "different-approach-o-n-2-just-visit-the-matrix-twice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngoing from left to right, if there is wall on right side of guard then elements after that are not guarded\\n\\ngoing from  right to left , if there is wall on left side of guard then elements after that are not guarded\\n\\ngoing from  top to down , if there is wall on down side of guard then elements down to that are not guarded\\n\\ngoing from  down to top , if there is wall on top side of guard then elements top to that are not guarded\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] mat = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(mat[i],1);\\n        //-1 walls ,-5-> guard,0 -> guarded,1->unguarded\\n        for(int[] i: walls) mat[i[0]][i[1]] = -1;\\n        for(int[] i: guards) mat[i[0]][i[1]] = -5;\\n        for(int i=0;i<m;i++){\\n            int left = 0,right = n-1;\\n            int lug = 1,rug = 1;\\n            for(;left<n;left++,right--){\\n                if(mat[i][left]==-5)lug=0;\\n                else if(mat[i][left]==-1) lug=1;\\n                else mat[i][left]&=lug;\\n                \\n                if(mat[i][right]==-5)rug=0;\\n                else if(mat[i][right]==-1) rug=1;\\n                else mat[i][right]&=rug;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int left = 0,right = m-1;\\n            int lug = 1,rug = 1;\\n            for(;left<m;left++,right--){\\n                if(mat[left][i]==-5)lug=0;\\n                else if(mat[left][i]==-1) lug=1;\\n                else mat[left][i]&=lug;\\n                \\n                if(mat[right][i]==-5)rug=0;\\n                else if(mat[right][i]==-1) rug=1;\\n                else mat[right][i]&=rug;\\n            }\\n        }\\n        int res =0 ;\\n        for(int[] m1: mat){\\n            for(int m11: m1) res+=(m11==1?1:0);\\n        }\\n       // print(mat);\\n        return res;\\n    }\\n    static void print(int[][] mat){\\n        System.out.println(Arrays.deepToString(mat));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] mat = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(mat[i],1);\\n        //-1 walls ,-5-> guard,0 -> guarded,1->unguarded\\n        for(int[] i: walls) mat[i[0]][i[1]] = -1;\\n        for(int[] i: guards) mat[i[0]][i[1]] = -5;\\n        for(int i=0;i<m;i++){\\n            int left = 0,right = n-1;\\n            int lug = 1,rug = 1;\\n            for(;left<n;left++,right--){\\n                if(mat[i][left]==-5)lug=0;\\n                else if(mat[i][left]==-1) lug=1;\\n                else mat[i][left]&=lug;\\n                \\n                if(mat[i][right]==-5)rug=0;\\n                else if(mat[i][right]==-1) rug=1;\\n                else mat[i][right]&=rug;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int left = 0,right = m-1;\\n            int lug = 1,rug = 1;\\n            for(;left<m;left++,right--){\\n                if(mat[left][i]==-5)lug=0;\\n                else if(mat[left][i]==-1) lug=1;\\n                else mat[left][i]&=lug;\\n                \\n                if(mat[right][i]==-5)rug=0;\\n                else if(mat[right][i]==-1) rug=1;\\n                else mat[right][i]&=rug;\\n            }\\n        }\\n        int res =0 ;\\n        for(int[] m1: mat){\\n            for(int m11: m1) res+=(m11==1?1:0);\\n        }\\n       // print(mat);\\n        return res;\\n    }\\n    static void print(int[][] mat){\\n        System.out.println(Arrays.deepToString(mat));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713446,
                "title": "python3-count-as-you-go-commented-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs most of the other approaches we need some kind of array to keep track which cells are seen/occupied.\\n\\nAs we want to diffferentiate between occupied by wall/guard or already seen, we need to use ints.\\n\\nThis solution differs a little bit from the others as we are creating our result as we gou and mark our cells. Therefore we do not need to go over our array again to compute the result by summing cells.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first we intialize the array and the number of unseen cells, which are m*n.\\n\\nAfter that we place all the walls and guards. For each occupied cell our result gets automatically decreased by one.\\n\\nThen we iterate over all guards and for each guard we go in every direction and mark the cells as seen. We decrease the result only if the cell was previously unseed.\\n\\nNOTE: Placing the guards already before this loop (in the first loop), saves a lot of time as we can immediately break once we hit a guard or a wall.\\n\\nPlacing the guards in this Loop results in TLE for some test cases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(len(guards)*(m+n)) as we go through each column and row for each guard in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\n        # make the grid which cells are guarded\\n        unseen = [[1]*n for _ in range(m)]\\n\\n        # initialize a the number of unseen cells\\n        result = m*n\\n\\n        # set all the walls and guards\\n        for rx, cx in walls + guards:\\n\\n            # place the wall\\n            unseen[rx][cx] = 0\\n\\n            # subtract from result\\n            result -= 1\\n        \\n        # now go over all the guards and update result\\n        # grx is guard row index\\n        # gcx is guard column index\\n        # brx is \"blick\" row index (blick is german for view)\\n        # bcx is \"blick\" column index\\n        for grx, gcx in guards:\\n\\n            # go from this position till the left end or until we hit a wall\\n            for bcx in range(gcx-1, -1, -1):\\n\\n                # check whether we change an unseen box\\n                if unseen[grx][bcx] == 1:\\n                    unseen[grx][bcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[grx][bcx] == 0:\\n                    break\\n            \\n            # go from this position to the right end or wall\\n            for bcx in range(gcx+1, n):\\n                \\n                # check whether we change an unseen box\\n                if unseen[grx][bcx] == 1:\\n                    unseen[grx][bcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[grx][bcx] == 0:\\n                    break\\n            \\n            # go from this position up and check for end or walls\\n            for brx in range(grx-1, -1, -1):\\n                \\n                # check whether we change an unseen box\\n                if unseen[brx][gcx] == 1:\\n                    unseen[brx][gcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[brx][gcx] == 0:\\n                    break\\n                \\n            # go from this position down and check for end or walls\\n            for brx in range(grx+1, m):\\n                \\n                # check whether we change an unseen box\\n                if unseen[brx][gcx] == 1:\\n                    unseen[brx][gcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[brx][gcx] == 0:\\n                    break\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n\\n        # make the grid which cells are guarded\\n        unseen = [[1]*n for _ in range(m)]\\n\\n        # initialize a the number of unseen cells\\n        result = m*n\\n\\n        # set all the walls and guards\\n        for rx, cx in walls + guards:\\n\\n            # place the wall\\n            unseen[rx][cx] = 0\\n\\n            # subtract from result\\n            result -= 1\\n        \\n        # now go over all the guards and update result\\n        # grx is guard row index\\n        # gcx is guard column index\\n        # brx is \"blick\" row index (blick is german for view)\\n        # bcx is \"blick\" column index\\n        for grx, gcx in guards:\\n\\n            # go from this position till the left end or until we hit a wall\\n            for bcx in range(gcx-1, -1, -1):\\n\\n                # check whether we change an unseen box\\n                if unseen[grx][bcx] == 1:\\n                    unseen[grx][bcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[grx][bcx] == 0:\\n                    break\\n            \\n            # go from this position to the right end or wall\\n            for bcx in range(gcx+1, n):\\n                \\n                # check whether we change an unseen box\\n                if unseen[grx][bcx] == 1:\\n                    unseen[grx][bcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[grx][bcx] == 0:\\n                    break\\n            \\n            # go from this position up and check for end or walls\\n            for brx in range(grx-1, -1, -1):\\n                \\n                # check whether we change an unseen box\\n                if unseen[brx][gcx] == 1:\\n                    unseen[brx][gcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[brx][gcx] == 0:\\n                    break\\n                \\n            # go from this position down and check for end or walls\\n            for brx in range(grx+1, m):\\n                \\n                # check whether we change an unseen box\\n                if unseen[brx][gcx] == 1:\\n                    unseen[brx][gcx] = -1\\n                    result -= 1\\n                \\n                # check whether we hit a wall or other guard\\n                elif unseen[brx][gcx] == 0:\\n                    break\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702687,
                "title": "no-tle-bfs-how-to-eliminate-tle-c-explained",
                "content": "The problem is a simple **DFS** problem where you traverse in a all **4-directions** without any **turn** and mark all the cells as **visible** in the process.\\nAfter marking all the cell visible you need to traverse the matrix and find count of all **hidden** cells.\\n\\n# **Why does TLE happens?**\\n\\n **TLE** occurs because you are processing for some of the **cells** which are already marked as **visible**. This ***extra work*** can be eleminiated if you reach a already marked **visible** cell and you check if the **direction** in which this cell was marked is the **same** **direction** your current **DFS** call is moving in, if **yes** then **no** need to mark further as the cells ahead are already marked with some previous **DFS** call which marked the current cell\\n \\n *Note the overlaps of colors in bottom right right matrix state:*\\n\\n![image](https://assets.leetcode.com/users/images/4b00679b-4c3e-4e1b-8f45-f735d8119cad_1665672976.6947653.png)\\n\\n\\n\\n\\n```\\ntypedef pair<int,int> pr;\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    \\n    int countUnguarded(int sz1, int sz2, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        \\n        n=sz1;m=sz2;\\n        vector<vector<pr>> a(n,vector<pr>(m,{1,-1}));\\n        \\n        for(auto i:w) a[i[0]][i[1]].first=0;\\n        queue<pair<pr,int> > q;\\n        \\n        // 2->Guard , 1->Empty , 0->Wall 3->Visible\\n        \\n        for(auto i:g) a[i[0]][i[1]].first=2,q.push({{i[0],i[1]},4});\\n        \\n        while(!q.empty()){\\n            \\n            auto curr=q.front().first;\\n            int dir=q.front().second;\\n            q.pop();\\n            \\n            int x=curr.first,y=curr.second;\\n            \\n            a[x][y].first=3;a[x][y].second=dir;\\n            \\n            for(int i=0;i<4;i++){\\n                int x1=x+dx[i],y1=y+dy[i];\\n                \\n                if(x1<0 || y1<0 || x1>n-1 || y1>m-1) continue;\\n                \\n                if(a[x1][y1].first==2 || a[x1][y1].first==0) continue;\\n                \\n                if(a[x1][y1].first==3 && a[x1][y1].second==dir) continue;\\n                \\n                if(dir==i || dir==4) q.push({ {x1,y1} ,i });\\n                \\n            }\\n            \\n        }\\n              \\n        int ans=0;for(auto i:a) for(auto j:i) if(j.first==1) ans++;return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<int,int> pr;\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    \\n    int countUnguarded(int sz1, int sz2, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        \\n        n=sz1;m=sz2;\\n        vector<vector<pr>> a(n,vector<pr>(m,{1,-1}));\\n        \\n        for(auto i:w) a[i[0]][i[1]].first=0;\\n        queue<pair<pr,int> > q;\\n        \\n        // 2->Guard , 1->Empty , 0->Wall 3->Visible\\n        \\n        for(auto i:g) a[i[0]][i[1]].first=2,q.push({{i[0],i[1]},4});\\n        \\n        while(!q.empty()){\\n            \\n            auto curr=q.front().first;\\n            int dir=q.front().second;\\n            q.pop();\\n            \\n            int x=curr.first,y=curr.second;\\n            \\n            a[x][y].first=3;a[x][y].second=dir;\\n            \\n            for(int i=0;i<4;i++){\\n                int x1=x+dx[i],y1=y+dy[i];\\n                \\n                if(x1<0 || y1<0 || x1>n-1 || y1>m-1) continue;\\n                \\n                if(a[x1][y1].first==2 || a[x1][y1].first==0) continue;\\n                \\n                if(a[x1][y1].first==3 && a[x1][y1].second==dir) continue;\\n                \\n                if(dir==i || dir==4) q.push({ {x1,y1} ,i });\\n                \\n            }\\n            \\n        }\\n              \\n        int ans=0;for(auto i:a) for(auto j:i) if(j.first==1) ans++;return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694671,
                "title": "count-unguarded-cells-simple-no-dfs-direct-by-loops-comments",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        l=[[0 for x in range(n)]for y in range(m)]\\n        for i in walls:\\n            x=i[0]\\n            y=i[1]\\n            l[x][y]=1\\n        for i in guards:\\n            x=i[0]\\n            y=i[1]\\n            l[x][y]=2\\n        \\n        \\n        \\n        \\n        for i in guards:\\n            x=i[0]\\n            y=i[1]\\n            #up\\n            for up in range(x-1,-1,-1):\\n                if l[up][y]==1 or l[up][y]==2:\\n                    break\\n                else:\\n                    l[up][y]=3\\n            #down\\n            for down in range(x+1,m):\\n                if l[down][y]==1 or l[down][y]==2:\\n                    break\\n                else:\\n                    l[down][y]=3\\n            #left\\n            for left in range(y-1,-1,-1):\\n                if l[x][left]==1 or l[x][left]==2:\\n                    break\\n                else:\\n                    l[x][left]=3\\n            #right\\n            for right in range(y+1,n):\\n                if l[x][right]==1 or l[x][right]==2:\\n                    break\\n                else:\\n                    l[x][right]=3\\n        c=0\\n        for i in range(m):\\n            for j in range(n):\\n                if l[i][j]==0:\\n                    c+=1\\n        return c\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        l=[[0 for x in range(n)]for y in range(m)]\\n        for i in walls:\\n            x=i[0]\\n            y=i[1]\\n            l[x][y]=1\\n        for i in guards:\\n            x=i[0]\\n            y=i[1]\\n            l[x][y]=2\\n        \\n        \\n        \\n        \\n        for i in guards:\\n            x=i[0]\\n            y=i[1]\\n            #up\\n            for up in range(x-1,-1,-1):\\n                if l[up][y]==1 or l[up][y]==2:\\n                    break\\n                else:\\n                    l[up][y]=3\\n            #down\\n            for down in range(x+1,m):\\n                if l[down][y]==1 or l[down][y]==2:\\n                    break\\n                else:\\n                    l[down][y]=3\\n            #left\\n            for left in range(y-1,-1,-1):\\n                if l[x][left]==1 or l[x][left]==2:\\n                    break\\n                else:\\n                    l[x][left]=3\\n            #right\\n            for right in range(y+1,n):\\n                if l[x][right]==1 or l[x][right]==2:\\n                    break\\n                else:\\n                    l[x][right]=3\\n        c=0\\n        for i in range(m):\\n            for j in range(n):\\n                if l[i][j]==0:\\n                    c+=1\\n        return c\\n\\t\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2678234,
                "title": "c-check-4-directions",
                "content": "```\\n    enum State{\\n        NO,\\n        YES,\\n        GUARD,\\n        WALL\\n    };\\n        \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        auto mat = vector(m, vector(n, State::NO));\\n        for(auto& v:guards) mat[v[0]][v[1]] = GUARD;\\n        for(auto& v:walls) mat[v[0]][v[1]] = WALL;\\n        \\n        auto op = [&](int i, int j, State& pre) mutable {\\n            auto& x = mat[i][j];\\n            if (x == NO){\\n                if (pre == GUARD) {\\n                    x = YES;\\n                }\\n            }\\n            else if (x == GUARD || x == WALL) pre = x;\\n        };\\n        \\n        for(int j=0;j<n;j++){\\n            State pre = WALL;\\n            for(int i=0; i<m; i++) op(i, j, pre);\\n            pre = WALL;\\n            for(int i=m-1; i>=0; i--) op(i, j, pre);\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            State pre = WALL;\\n            for(int j=0; j<n; j++)  op(i, j, pre);\\n            pre = WALL;\\n            for(int j=n-1; j>=0; j--) op(i, j, pre);\\n        }        \\n        \\n        int res = 0;\\n        for(auto& v:mat) res += count(v.begin(), v.end(), State::NO);        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    enum State{\\n        NO,\\n        YES,\\n        GUARD,\\n        WALL\\n    };\\n        \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        auto mat = vector(m, vector(n, State::NO));\\n        for(auto& v:guards) mat[v[0]][v[1]] = GUARD;\\n        for(auto& v:walls) mat[v[0]][v[1]] = WALL;\\n        \\n        auto op = [&](int i, int j, State& pre) mutable {\\n            auto& x = mat[i][j];\\n            if (x == NO){\\n                if (pre == GUARD) {\\n                    x = YES;\\n                }\\n            }\\n            else if (x == GUARD || x == WALL) pre = x;\\n        };\\n        \\n        for(int j=0;j<n;j++){\\n            State pre = WALL;\\n            for(int i=0; i<m; i++) op(i, j, pre);\\n            pre = WALL;\\n            for(int i=m-1; i>=0; i--) op(i, j, pre);\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            State pre = WALL;\\n            for(int j=0; j<n; j++)  op(i, j, pre);\\n            pre = WALL;\\n            for(int j=n-1; j>=0; j--) op(i, j, pre);\\n        }        \\n        \\n        int res = 0;\\n        for(auto& v:mat) res += count(v.begin(), v.end(), State::NO);        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2651735,
                "title": "c-easy-short-answer",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> v(m, vector<int> (n,0));\\n        int k = w.size();\\n        for(int i=0;i<k;i++){\\n            int x = w[i][0], y = w[i][1];\\n            v[x][y] = -2;\\n        }\\n        k = g.size();\\n        for(int i=0;i<k;i++){\\n            int x = g[i][0], y = g[i][1];\\n            v[x][y] = 2;\\n        }\\n        for(int j=0;j<k;j++){\\n            int x = g[j][0], y = g[j][1];\\n            for(int i=x-1;i>=0;i--){ \\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=x+1;i<m;i++){\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=y-1;i>=0;i--){ \\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n            for(int i=y+1;i<n;i++){ \\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!v[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n        vector<vector<int>> v(m, vector<int> (n,0));\\n        int k = w.size();\\n        for(int i=0;i<k;i++){\\n            int x = w[i][0], y = w[i][1];\\n            v[x][y] = -2;\\n        }\\n        k = g.size();\\n        for(int i=0;i<k;i++){\\n            int x = g[i][0], y = g[i][1];\\n            v[x][y] = 2;\\n        }\\n        for(int j=0;j<k;j++){\\n            int x = g[j][0], y = g[j][1];\\n            for(int i=x-1;i>=0;i--){ \\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=x+1;i<m;i++){\\n                if(v[i][y]==-2 || v[i][y]==2) break;\\n                v[i][y] = 1;\\n            }\\n            for(int i=y-1;i>=0;i--){ \\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n            for(int i=y+1;i<n;i++){ \\n                if(v[x][i]==-2 || v[x][i]==2) break;\\n                v[x][i] = 1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!v[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603369,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>> v(m,vector<int> (n,0));\\n        for(auto &a : walls)\\n        {\\n            v[a[0]][a[1]]=-1;\\n        }\\n        for(auto &a : guards)\\n        {\\n            v[a[0]][a[1]]=1;\\n        }\\n        for(auto &a : guards)\\n        {\\n            int x = a[0];\\n            int y = a[1];\\n            for(int i=x-1; i>=0; i--)\\n            {\\n                if(v[i][y]==-1 || v[i][y]==1)\\n                    break;\\n                else\\n                    v[i][y]=2;\\n            }\\n            for(int i=x+1; i<m; i++)\\n            {\\n                if(v[i][y]==-1 || v[i][y]==1)\\n                    break;\\n                else\\n                    v[i][y]=2;\\n            }\\n            for(int i=y-1; i>=0; i--)\\n            {\\n                if(v[x][i]==1 || v[x][i]==-1)\\n                    break;\\n                else\\n                    v[x][i]=2;\\n            }\\n            for(int i=y+1; i<n; i++)\\n            {\\n                if(v[x][i]==1 || v[x][i]==-1)\\n                    break;\\n                else\\n                    v[x][i]=2;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                if(!v[i][j])\\n                    ans++;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>> v(m,vector<int> (n,0));\\n        for(auto &a : walls)\\n        {\\n            v[a[0]][a[1]]=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578482,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> field(m, vector<char>(n, \\'e\\'));\\n        for(const auto &g : guards) {\\n            field[g[0]][g[1]] = \\'g\\';\\n        }\\n        for(const auto &w : walls) {\\n            field[w[0]][w[1]] = \\'w\\';\\n        }\\n        for(const auto &g : guards) {\\n            const int r = g[0];\\n            const int c = g[1];\\n            // move up until we reach a guard, a wall or a border\\n            for(int i = r - 1; i >= 0; --i) {\\n                if(field[i][c] == \\'e\\' || field[i][c] == \\'p\\') {\\n                    field[i][c] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move down until we reach a guard, a wall or a border\\n            for(int i = r + 1; i < m; ++i) {\\n                if(field[i][c] == \\'e\\' || field[i][c] == \\'p\\') {\\n                    field[i][c] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move left until we reach a guard, a wall or a border\\n            for(int i = c - 1; i >= 0; --i) {\\n                if(field[r][i] == \\'e\\' || field[r][i] == \\'p\\') {\\n                    field[r][i] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move right until we reach a guard, a wall or a border\\n            for(int i = c + 1; i < n; ++i) {\\n                if(field[r][i] == \\'e\\' || field[r][i] == \\'p\\') {\\n                    field[r][i] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        // count a number of non-protected cells (\\'e\\' -> empty)\\n        for(const auto &r : field) {\\n            ans += count(r.cbegin(), r.cend(), \\'e\\');\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> field(m, vector<char>(n, \\'e\\'));\\n        for(const auto &g : guards) {\\n            field[g[0]][g[1]] = \\'g\\';\\n        }\\n        for(const auto &w : walls) {\\n            field[w[0]][w[1]] = \\'w\\';\\n        }\\n        for(const auto &g : guards) {\\n            const int r = g[0];\\n            const int c = g[1];\\n            // move up until we reach a guard, a wall or a border\\n            for(int i = r - 1; i >= 0; --i) {\\n                if(field[i][c] == \\'e\\' || field[i][c] == \\'p\\') {\\n                    field[i][c] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move down until we reach a guard, a wall or a border\\n            for(int i = r + 1; i < m; ++i) {\\n                if(field[i][c] == \\'e\\' || field[i][c] == \\'p\\') {\\n                    field[i][c] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move left until we reach a guard, a wall or a border\\n            for(int i = c - 1; i >= 0; --i) {\\n                if(field[r][i] == \\'e\\' || field[r][i] == \\'p\\') {\\n                    field[r][i] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n            // move right until we reach a guard, a wall or a border\\n            for(int i = c + 1; i < n; ++i) {\\n                if(field[r][i] == \\'e\\' || field[r][i] == \\'p\\') {\\n                    field[r][i] = \\'p\\';\\n                } else\\n                    break;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        // count a number of non-protected cells (\\'e\\' -> empty)\\n        for(const auto &r : field) {\\n            ans += count(r.cbegin(), r.cend(), \\'e\\');\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569406,
                "title": "c-iterative-dfs",
                "content": "### C++ Solution:\\n```\\nclass Solution {\\n    int countGuarded(int m, int n, vector<vector<int>>& guards, set<pair<int,int>>& obstacles)\\n    {\\n        set<pair<int,int>> guardedCells;\\n        \\n        for (const auto& guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            \\n            // top\\n            x--;\\n            while (x >= 0)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                x--;\\n            }\\n            \\n            x = guard[0];\\n            \\n            // bottom\\n            x++;\\n            while (x < m)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                x++;\\n            }\\n            \\n            x = guard[0];\\n            \\n            // left\\n            y--;\\n            while (y >= 0)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                y--;\\n            }\\n            \\n            y = guard[1];\\n            \\n            // right\\n            y++;\\n            while (y < n)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                y++;\\n            }\\n            \\n            y = guard[1];\\n        }\\n        \\n        // for (auto k : guardedCells)\\n        //     cout << k.first << \" \" << k.second << endl;\\n        \\n        return guardedCells.size();\\n    }\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int totalCells = m * n;\\n        \\n        set<pair<int,int>> obstacles;\\n        \\n        for (const auto& guard : guards)\\n            obstacles.insert({guard[0],guard[1]});\\n        for (const auto& wall : walls)\\n            obstacles.insert({wall[0],wall[1]});\\n        \\n        return totalCells - countGuarded(m,n,guards,obstacles) - obstacles.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int countGuarded(int m, int n, vector<vector<int>>& guards, set<pair<int,int>>& obstacles)\\n    {\\n        set<pair<int,int>> guardedCells;\\n        \\n        for (const auto& guard : guards)\\n        {\\n            int x = guard[0], y = guard[1];\\n            \\n            // top\\n            x--;\\n            while (x >= 0)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                x--;\\n            }\\n            \\n            x = guard[0];\\n            \\n            // bottom\\n            x++;\\n            while (x < m)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                x++;\\n            }\\n            \\n            x = guard[0];\\n            \\n            // left\\n            y--;\\n            while (y >= 0)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                y--;\\n            }\\n            \\n            y = guard[1];\\n            \\n            // right\\n            y++;\\n            while (y < n)\\n            {\\n                if (obstacles.find({x,y}) == obstacles.end())\\n                    guardedCells.insert({x,y});\\n                else\\n                    break;\\n                y++;\\n            }\\n            \\n            y = guard[1];\\n        }\\n        \\n        // for (auto k : guardedCells)\\n        //     cout << k.first << \" \" << k.second << endl;\\n        \\n        return guardedCells.size();\\n    }\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        int totalCells = m * n;\\n        \\n        set<pair<int,int>> obstacles;\\n        \\n        for (const auto& guard : guards)\\n            obstacles.insert({guard[0],guard[1]});\\n        for (const auto& wall : walls)\\n            obstacles.insert({wall[0],wall[1]});\\n        \\n        return totalCells - countGuarded(m,n,guards,obstacles) - obstacles.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2563716,
                "title": "c-dfs",
                "content": "the idea is like others.\\n* we need to fill in 4 directions(`up`, `down`, `left`, `right`) while there is a guard(`2`)\\n* stop fill when there is wall (`3`)/guard(`2`) or invalid position\\n\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> graphs(m, vector<int>(n));\\n\\t\\t\\n\\t\\t// four directions\\n        vector<pair<int, int>> directions {\\n            {1, 0}, {0, 1}, {-1, 0}, {0, -1}\\n        };\\n\\t\\t\\n        for (auto& guard: guards)\\n            graphs[guard[0]][guard[1]] = 2;\\n        for (auto& wall: walls)\\n            graphs[wall[0]][wall[1]] = 3;\\n        \\n        function<void(int, int, pair<int,int>)> dfs = [&](int i, int j, pair<int, int> direction){\\n            if (i < 0 || j < 0 || i >= m || j >= n || graphs[i][j] == 3 || graphs[i][j] == 2)\\n                return;\\n            graphs[i][j] = 1;\\n            dfs(i + direction.first, j + direction.second, direction);\\n        };\\n        \\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++) {\\n                if (graphs[i][j] != 2) continue;\\n\\n                for (auto& direct: directions)\\n                    dfs(i + direct.first, j + direct.second, direct);\\n            }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (graphs[i][j] == 0)\\n                    ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> graphs(m, vector<int>(n));\\n\\t\\t\\n\\t\\t// four directions\\n        vector<pair<int, int>> directions {\\n            {1, 0}, {0, 1}, {-1, 0}, {0, -1}\\n        };\\n\\t\\t\\n        for (auto& guard: guards)\\n            graphs[guard[0]][guard[1]] = 2;\\n        for (auto& wall: walls)\\n            graphs[wall[0]][wall[1]] = 3;\\n        \\n        function<void(int, int, pair<int,int>)> dfs = [&](int i, int j, pair<int, int> direction){\\n            if (i < 0 || j < 0 || i >= m || j >= n || graphs[i][j] == 3 || graphs[i][j] == 2)\\n                return;\\n            graphs[i][j] = 1;\\n            dfs(i + direction.first, j + direction.second, direction);\\n        };\\n        \\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++) {\\n                if (graphs[i][j] != 2) continue;\\n\\n                for (auto& direct: directions)\\n                    dfs(i + direct.first, j + direct.second, direct);\\n            }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (graphs[i][j] == 0)\\n                    ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555591,
                "title": "java-simple-dfs-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tint[] dRow = new int[]{-1, 0, 1, 0};\\n\\t\\tint[] dCol = new int[]{0, 1, 0, -1};\\n\\n\\t\\tpublic int countUnguarded(int m, int n, int[][] guards, int[][] walls) {        \\n\\t\\t\\tint[][] grid = new int[m][n];\\n\\n\\t\\t\\tfor(int[] loc : guards) {\\n\\t\\t\\t\\tgrid[loc[0]][loc[1]] = 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int[] loc : walls) {\\n\\t\\t\\t\\tgrid[loc[0]][loc[1]] = 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\tboolean[][][] isVisited = new boolean[m][n][4];\\n\\n\\t\\t\\tfor(int i=0; i<m; i++) {\\n\\t\\t\\t\\tfor(int j=0; j<n; j++) {\\n\\t\\t\\t\\t\\tif(grid[i][j] == 1) {\\n\\t\\t\\t\\t\\t\\tfor(int k=0; k<4; k++) {\\n\\t\\t\\t\\t\\t\\t\\tif(!isVisited[i][j][k]) {\\n\\t\\t\\t\\t\\t\\t\\t\\tisVisited[i][j][k] = true;\\n\\t\\t\\t\\t\\t\\t\\t\\thelper(i, j, k, grid, isVisited);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int i=0; i<m; i++) {\\n\\t\\t\\t\\tfor(int j=0; j<n; j++) {\\n\\t\\t\\t\\t\\tif(grid[i][j] == 0) ans++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\n\\t\\tpublic void helper(int row, int col, int dir, int[][] grid, boolean[][][] isVisited) {\\n\\t\\t\\tint nRow = row + dRow[dir];\\n\\t\\t\\tint nCol = col + dCol[dir];\\n\\n\\t\\t\\tif(nRow < 0 || nRow >= grid.length || nCol < 0 || nCol >= grid[0].length || isVisited[nRow][nCol][dir] || grid[nRow][nCol] == 2 || grid[nRow][nCol] == 1) return;\\n\\n\\t\\t\\tgrid[nRow][nCol] = 3;\\n\\t\\t\\tisVisited[nRow][nCol][dir] = true;\\n\\t\\t\\thelper(nRow, nCol, dir, grid, isVisited);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint[] dRow = new int[]{-1, 0, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2555474,
                "title": "c-guard-path-solution-with-explanation-sep-9th-2022-100-speed-rank",
                "content": "The below is based on @votrubac solution [here](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/discuss/2001912/Bitmask-Tracing-vs.-Binary-Search), though instead of doing a bitmask we opt for a simpler scheme just count if we are about to walk through a path already traveled by another guard.\\n \\n This does a few nice things for speed and clarity relative to the original post, though could probably be improved\\n \\n1. Removes iterating over the guards original position each time in the innermost loop\\n2. Instead of using a bit mask the program checks if another guard has already traveled down that particular path or if we hit a wall\\n3. Moves the iterating of i and j out of the loop body and into the loop decleration \\n4. Uses a constexpr array for the directions\\n5. Adds a matrix class for the grid\\n\\nI couldn\\'t think of a counter example that makes the below wrong but would be very happy if someone could fine one!\\n\\nJust to clarify on the value 2 in the below. Imagine we have a guard coming from the top and the right whose paths intersect. Once we put a value of 2 at where their paths intersect, if a guard comes from the right or bottom then once they see 2 other guards have already gone down that path they know there is no need to travel any further. Similarly walls have a value of 2 since we want the guard to stop at that point.\\n\\n```cpp\\n// So that our grid is one \\n// big chunk of memory instead of a vector of vectors\\nstruct Matrix {\\n  int* arr;\\n  int rows;\\n  int cols;\\n  Matrix(const int n, const int m) noexcept\\n      : rows(n), cols(m), arr(static_cast<int*>(calloc(n * m, sizeof(int)))) {}\\n  inline int& operator()(int i, int j) noexcept { return arr[i * cols + j]; }\\n};\\n\\nclass Solution {\\n public:\\n  using array_2i = std::array<int, 2>;\\n  // up, right, down, left\\n  static constexpr std::array<array_2i, 4> directions{array_2i{0, 1}, \\n                                                      array_2i{1, 0},\\n                                                      array_2i{0, -1},\\n                                                      array_2i{-1, 0}};\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    int not_guarded = m * n - walls.size() - guards.size();\\n    Matrix grid(m, n);\\n    /*\\n     * These get set to 2 just to indicate we\\'ve traveled through them\\n     * at least once. At that point we intersect with another \\n     *  guard so no need to keep going.\\n     * NOTE: That\\'s my intuition on the above, I think it is correct?\\n     */  \\n    for (auto&& wall : walls) {\\n      grid(wall[0], wall[1]) = 2;\\n    }\\n    for (auto&& guard : guards) {\\n      grid(guard[0], guard[1]) = 2;\\n    }\\n    for (auto&& guard : guards) {\\n      for (auto&& path_direction : directions) {\\n        /**\\n         * For each guard and direction, travel until we hit:\\n         * 1. An edge (either negative values or positive oob)\\n         * 2. We come across another guards path\\n         */\\n        for (int i = guard[0] + path_direction[0],\\n                 j = guard[1] + path_direction[1];\\n              min(i, j) >= 0 && i < m && j < n && grid(i, j) < 2;\\n              i += path_direction[0],\\n              j += path_direction[1]) {\\n          if (grid(i, j) == 0) {\\n            --not_guarded;\\n            grid(i, j) += 1;\\n          }\\n        }\\n      }\\n    }\\n    return not_guarded;\\n  }\\n};\\n```\\n\\nThanks for reading! Please like this post if you use the code and feel free to comment with any improvements or questions! One thing I didn\\'t try but could be faster it to forgo using a grid and instead have an unordered map with a cheap hash function to keep track of where the guards have traveled.",
                "solutionTags": [],
                "code": "```cpp\\n// So that our grid is one \\n// big chunk of memory instead of a vector of vectors\\nstruct Matrix {\\n  int* arr;\\n  int rows;\\n  int cols;\\n  Matrix(const int n, const int m) noexcept\\n      : rows(n), cols(m), arr(static_cast<int*>(calloc(n * m, sizeof(int)))) {}\\n  inline int& operator()(int i, int j) noexcept { return arr[i * cols + j]; }\\n};\\n\\nclass Solution {\\n public:\\n  using array_2i = std::array<int, 2>;\\n  // up, right, down, left\\n  static constexpr std::array<array_2i, 4> directions{array_2i{0, 1}, \\n                                                      array_2i{1, 0},\\n                                                      array_2i{0, -1},\\n                                                      array_2i{-1, 0}};\\n  int countUnguarded(int m, int n, vector<vector<int>>& guards,\\n                     vector<vector<int>>& walls) {\\n    int not_guarded = m * n - walls.size() - guards.size();\\n    Matrix grid(m, n);\\n    /*\\n     * These get set to 2 just to indicate we\\'ve traveled through them\\n     * at least once. At that point we intersect with another \\n     *  guard so no need to keep going.\\n     * NOTE: That\\'s my intuition on the above, I think it is correct?\\n     */  \\n    for (auto&& wall : walls) {\\n      grid(wall[0], wall[1]) = 2;\\n    }\\n    for (auto&& guard : guards) {\\n      grid(guard[0], guard[1]) = 2;\\n    }\\n    for (auto&& guard : guards) {\\n      for (auto&& path_direction : directions) {\\n        /**\\n         * For each guard and direction, travel until we hit:\\n         * 1. An edge (either negative values or positive oob)\\n         * 2. We come across another guards path\\n         */\\n        for (int i = guard[0] + path_direction[0],\\n                 j = guard[1] + path_direction[1];\\n              min(i, j) >= 0 && i < m && j < n && grid(i, j) < 2;\\n              i += path_direction[0],\\n              j += path_direction[1]) {\\n          if (grid(i, j) == 0) {\\n            --not_guarded;\\n            grid(i, j) += 1;\\n          }\\n        }\\n      }\\n    }\\n    return not_guarded;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550196,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n       int s=0;\\n        \\n  void is(int m,int n,int i,int j,vector<vector<char>>& g,int r,int c)\\n    {\\n      j++;\\n      while(j<n && ((g[r][j]==\\'0\\')||(g[r][j]==\\'p\\')))\\n      {\\n       if(g[r][j]==\\'w\\')\\n        break;\\n          g[r][j]=\\'p\\';\\n          j++;\\n      }\\n  \\n      i++;\\n      while(i<m && ((g[i][c]==\\'0\\')||(g[i][c]==\\'p\\')))\\n          {\\n       if(g[i][c]==\\'w\\')\\n        break;\\n          g[i][c]=\\'p\\';\\n          i++;\\n          }\\n      \\n   \\n      j=c;\\n      i=r;\\n      j--;\\n      while(j>=0 &&  ((g[r][j]==\\'0\\')||(g[r][j]==\\'p\\')))\\n           {\\n       if(g[r][j]==\\'w\\')\\n        break;\\n          g[r][j]=\\'p\\';\\n          j--;\\n          }\\n      \\n      i--;\\n      while(i>=0 &&  ((g[i][c]==\\'0\\')||(g[i][c]==\\'p\\')))\\n           {\\n       if(g[i][c]==\\'w\\')\\n        break;\\n          g[i][c]=\\'p\\';\\n          i--;\\n          }\\n      \\n        \\n    }\\n    \\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n               \\n        vector<char> a(n,\\'0\\');\\n         \\n        vector<vector<char>> grid(m,a);\\n       \\n\\n            for(int i=0;i<guards.size();i++)\\n            {\\n                grid[guards[i][0]][guards[i][1]]=\\'g\\';\\n            }\\n        \\n        for(int i=0;i<walls.size();i++)\\n            {\\n                grid[walls[i][0]][walls[i][1]]=\\'w\\';\\n            }\\n        \\n        \\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==\\'g\\')\\n                    is(m,n,i,j,grid,i,j);\\n            }\\n            \\n        }\\n        \\n    for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               if(grid[i][j]==\\'0\\')\\n                   s++;\\n            }\\n           \\n        }\\n        \\n        \\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n       int s=0;\\n        \\n  void is(int m,int n,int i,int j,vector<vector<char>>& g,int r,int c)\\n    {\\n      j++;\\n      while(j<n && ((g[r][j]==\\'0\\')||(g[r][j]==\\'p\\')))\\n      {\\n       if(g[r][j]==\\'w\\')\\n        break;\\n          g[r][j]=\\'p\\';\\n          j++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2510379,
                "title": "python-simple-for-loops",
                "content": "```\\n def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        ggg = guards.copy()\\n        guards = set([tuple(x) for x in guards])\\n        walls = set([tuple(x) for x in walls])\\n        guardedCells = set()\\n        for gg in range(len(guards)): \\n            g = ggg[gg]\\n            for i in range(g[0]+1, m):\\n                if (i,g[1]) not in walls and (i,g[1]) not in guards :                    \\n                    guardedCells.add((i,g[1]))\\n                else:\\n                    break\\n            \\n            for i in range(g[0]-1, -1, -1):\\n                if (i, g[1]) not in walls and (i,g[1]) not in guards :                    \\n                    guardedCells.add((i,g[1]))\\n                else:\\n                    break\\n                    \\n            for j in range(g[1]+1, n):\\n                if (g[0],j) not in walls and (g[0],j) not in guards :                    \\n                    guardedCells.add((g[0],j))\\n                else:\\n                    break\\n                    \\n            for j in range(g[1]-1, -1, -1):\\n                if (g[0], j) not in walls and (g[0],j) not in guards :                    \\n                    guardedCells.add((g[0],j))\\n                else:\\n                    break\\n\\n        return m*n - len(guards) - len(walls) - len(guardedCells)\\n                        \\n                    \\n",
                "solutionTags": [],
                "code": "```\\n def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        \\n        ggg = guards.copy()\\n        guards = set([tuple(x) for x in guards])\\n        walls = set([tuple(x) for x in walls])\\n        guardedCells = set()\\n        for gg in range(len(guards)): \\n            g = ggg[gg]\\n            for i in range(g[0]+1, m):\\n                if (i,g[1]) not in walls and (i,g[1]) not in guards :                    \\n                    guardedCells.add((i,g[1]))\\n                else:\\n                    break\\n            \\n            for i in range(g[0]-1, -1, -1):\\n                if (i, g[1]) not in walls and (i,g[1]) not in guards :                    \\n                    guardedCells.add((i,g[1]))\\n                else:\\n                    break\\n                    \\n            for j in range(g[1]+1, n):\\n                if (g[0],j) not in walls and (g[0],j) not in guards :                    \\n                    guardedCells.add((g[0],j))\\n                else:\\n                    break\\n                    \\n            for j in range(g[1]-1, -1, -1):\\n                if (g[0], j) not in walls and (g[0],j) not in guards :                    \\n                    guardedCells.add((g[0],j))\\n                else:\\n                    break\\n\\n        return m*n - len(guards) - len(walls) - len(guardedCells)\\n                        \\n                    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2505149,
                "title": "python-solution-using-dfs-faster-than-80",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        grid, ans = [[\\'\\' for I in range(n)] for _ in range(m)], 0\\n        for guard in guards:\\n            grid[guard[0]][guard[1]] = \\'G\\'\\n        for wall in walls:\\n            grid[wall[0]][wall[1]] = \\'W\\'\\n            \\n        def dfs(m: int, n: int, x: int, y: int, grid: List[List[int]], idx: int) -> None:\\n            if x >= m or y >= n or x < 0 or y < 0 or grid[x][y] == \\'G\\' or grid[x][y] == \\'W\\':\\n                return\\n            \\n            grid[x][y] = \\'V\\'\\n            dfs(m, n, x + directions[idx][0], y + directions[idx][1], grid, idx)\\n            \\n        for guard in guards:\\n            grid[guard[0]][guard[1]] = \\'V\\'\\n            for idx in range(4):\\n                dfs(m, n, guard[0], guard[1], grid, idx)\\n            grid[guard[0]][guard[1]] = \\'G\\'\\n        for row in grid:\\n            ans += row.count(\\'\\')\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        grid, ans = [[\\'\\' for I in range(n)] for _ in range(m)], 0\\n        for guard in guards:\\n            grid[guard[0]][guard[1]] = \\'G\\'\\n        for wall in walls:\\n            grid[wall[0]][wall[1]] = \\'W\\'\\n            \\n        def dfs(m: int, n: int, x: int, y: int, grid: List[List[int]], idx: int) -> None:\\n            if x >= m or y >= n or x < 0 or y < 0 or grid[x][y] == \\'G\\' or grid[x][y] == \\'W\\':\\n                return\\n            \\n            grid[x][y] = \\'V\\'\\n            dfs(m, n, x + directions[idx][0], y + directions[idx][1], grid, idx)\\n            \\n        for guard in guards:\\n            grid[guard[0]][guard[1]] = \\'V\\'\\n            for idx in range(4):\\n                dfs(m, n, guard[0], guard[1], grid, idx)\\n            grid[guard[0]][guard[1]] = \\'G\\'\\n        for row in grid:\\n            ans += row.count(\\'\\')\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490195,
                "title": "one-direction-dfs-with-quick-termination",
                "content": "Can cut off some portion of work if you stop unidirectional DFS search when you reach another guard. (they\\'ll take care of the rest themselves). \\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{-1,0}, {1, 0}, {0,-1}, {0, 1}};\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> map (m, vector<char>(n, \\' \\'));\\n        for(auto& v: guards) map[v[0]][v[1]] = \\'G\\';\\n        for(auto& v: walls) map[v[0]][v[1]] = \\'W\\';\\n        for(auto& v: guards){\\n            map[v[0]][v[1]] = \\'X\\';\\n            for(int i = 0; i < 4; i++) dfs(m, n, v[0], v[1], map, i);\\n            map[v[0]][v[1]] = \\'G\\';\\n        }\\n        int cnt = 0;\\n        for(auto& v: map) cnt += count( v.begin(), v.end(), \\' \\');\\n        return cnt;\\n    }\\n    \\n    void dfs(int m, int n, int x, int y, vector<vector<char>>& map, int ind){\\n        if(x >= m || y >=n || x < 0 || y < 0 || map[x][y] == \\'G\\' || map[x][y] == \\'W\\') return;\\n        map[x][y] = \\'X\\';\\n        dfs(m, n, x + dirs[ind].first, y +  dirs[ind].second, map, ind);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> dirs = {{-1,0}, {1, 0}, {0,-1}, {0, 1}};\\n    \\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<char>> map (m, vector<char>(n, \\' \\'));\\n        for(auto& v: guards) map[v[0]][v[1]] = \\'G\\';\\n        for(auto& v: walls) map[v[0]][v[1]] = \\'W\\';\\n        for(auto& v: guards){\\n            map[v[0]][v[1]] = \\'X\\';\\n            for(int i = 0; i < 4; i++) dfs(m, n, v[0], v[1], map, i);\\n            map[v[0]][v[1]] = \\'G\\';\\n        }\\n        int cnt = 0;\\n        for(auto& v: map) cnt += count( v.begin(), v.end(), \\' \\');\\n        return cnt;\\n    }\\n    \\n    void dfs(int m, int n, int x, int y, vector<vector<char>>& map, int ind){\\n        if(x >= m || y >=n || x < 0 || y < 0 || map[x][y] == \\'G\\' || map[x][y] == \\'W\\') return;\\n        map[x][y] = \\'X\\';\\n        dfs(m, n, x + dirs[ind].first, y +  dirs[ind].second, map, ind);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455357,
                "title": "c-fast-and-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mp(m, vector<int>(n));   //Create a array of m*n with defau;t zero value..\\n        for(int i=0;i<guards.size();i++)\\n            mp[guards[i][0]][guards[i][1]]=1;\\n        for(int i=0;i<walls.size();i++)\\n            mp[walls[i][0]][walls[i][1]]=2;\\n        //For each guard in all four direction move until we reach end or end upseeing a wall updating them as no go field(-1).\\n         for(auto x: guards)\\n         {\\n             bool l=true,r=true,d=true,u=true;\\n            for(int i=1;i<max(m,n) && (l || u || d || r);i++)  // checking of all bool value is important as it reduces the visits by a huge number\\n            {\\n                if(l && x[0]-i>=0 && mp[x[0]-i][x[1]]!=2 && mp[x[0]-i][x[1]]!=1)\\n                    mp[x[0]-i][x[1]]=-1;\\n                else\\n                    l=false;             \\n                if(r && x[0]+i<m && mp[x[0]+i][x[1]]!=2 && mp[x[0]+i][x[1]]!=1)\\n                    mp[x[0]+i][x[1]]=-1;\\n                else\\n                    r=false;                \\n                if(u && x[1]-i>=0 && mp[x[0]][x[1]-i]!=2  && mp[x[0]][x[1]-i]!=1)\\n                    mp[x[0]][x[1]-i]=-1;\\n                else\\n                    u=false;\\n                if(d && x[1]+i<n && mp[x[0]][x[1]+i]!=2 && mp[x[0]][x[1]+i]!=1)\\n                    mp[x[0]][x[1]+i]=-1;\\n                else\\n                    d=false;\\n            }\\n         }        \\n        int ans=0;   // Once we mark all the guarded places we can now see how many unguarded positions are there.. \\n\\t\\t//conversly in above loop we can count the guarded and add them with number of  walls and guards and subract with m*N to get answers\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(mp[i][j]==0)\\n                    ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> mp(m, vector<int>(n));   //Create a array of m*n with defau;t zero value..\\n        for(int i=0;i<guards.size();i++)\\n            mp[guards[i][0]][guards[i][1]]=1;\\n        for(int i=0;i<walls.size();i++)\\n            mp[walls[i][0]][walls[i][1]]=2;\\n        //For each guard in all four direction move until we reach end or end upseeing a wall updating them as no go field(-1).\\n         for(auto x: guards)\\n         {\\n             bool l=true,r=true,d=true,u=true;\\n            for(int i=1;i<max(m,n) && (l || u || d || r);i++)  // checking of all bool value is important as it reduces the visits by a huge number\\n            {\\n                if(l && x[0]-i>=0 && mp[x[0]-i][x[1]]!=2 && mp[x[0]-i][x[1]]!=1)\\n                    mp[x[0]-i][x[1]]=-1;\\n                else\\n                    l=false;             \\n                if(r && x[0]+i<m && mp[x[0]+i][x[1]]!=2 && mp[x[0]+i][x[1]]!=1)\\n                    mp[x[0]+i][x[1]]=-1;\\n                else\\n                    r=false;                \\n                if(u && x[1]-i>=0 && mp[x[0]][x[1]-i]!=2  && mp[x[0]][x[1]-i]!=1)\\n                    mp[x[0]][x[1]-i]=-1;\\n                else\\n                    u=false;\\n                if(d && x[1]+i<n && mp[x[0]][x[1]+i]!=2 && mp[x[0]][x[1]+i]!=1)\\n                    mp[x[0]][x[1]+i]=-1;\\n                else\\n                    d=false;\\n            }\\n         }        \\n        int ans=0;   // Once we mark all the guarded places we can now see how many unguarded positions are there.. \\n\\t\\t//conversly in above loop we can count the guarded and add them with number of  walls and guards and subract with m*N to get answers\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(mp[i][j]==0)\\n                    ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445142,
                "title": "c-easy-tracing-in-4-directions-and-taking-the-bitwise-and-of-all-commented",
                "content": "#define ll long long\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        ll count=0;\\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        //guard=>-2\\n        //wall=>2\\n        //greens=>1\\n        //reds=>0\\n        for(auto v:guards)\\n        {\\n            grid[v[0]][v[1]]=-2;\\n        }\\n        for(auto v:walls)\\n        {\\n            grid[v[0]][v[1]]=2;\\n        }\\n        //traversing row wise\\n        for(int i=0;i<m;i++)\\n        {\\n            //traversing as the guard looks only to his right\\n            bool lastIsWall=true;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==-2)\\n                {\\n                    lastIsWall=false;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    lastIsWall=true;\\n                }\\n                else if(lastIsWall)\\n                    grid[i][j]=1;\\n                else\\n                    grid[i][j]=0;\\n            }\\n            \\n            //traversing as the guard is looking towards his left and we do (left & right)\\n            //green and red ==>red\\n            //(only) green and green==>green \\n            \\n            lastIsWall=true;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(grid[i][j]==-2)\\n                {\\n                    lastIsWall=false;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    lastIsWall=true;\\n                }\\n                else if(lastIsWall)\\n                    grid[i][j]=grid[i][j] & 1;\\n                else\\n                    grid[i][j]=0;\\n            }           \\n            \\n        }\\n        //traversing column wise\\n        for(int j=0;j<n;j++)\\n        {\\n            //traversing as if the guard can only see up and taking the and\\n            bool lastIsWall=true;\\n            for(int i=0;i<m;i++)\\n            {\\n                if(grid[i][j]==-2)\\n                {\\n                    lastIsWall=false;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    lastIsWall=true;\\n                }\\n                else if(lastIsWall)\\n                    grid[i][j]=grid[i][j] & 1;\\n                else\\n                    grid[i][j]=0;\\n            }\\n            \\n            //traversing as if the guard is looking down and keeping the answer as and of all\\n            lastIsWall=true;\\n            for(int i=m-1;i>=0;i--)\\n            {\\n                if(grid[i][j]==-2)\\n                {\\n                    lastIsWall=false;\\n                }\\n                else if(grid[i][j]==2)\\n                {\\n                    lastIsWall=true;\\n                }\\n                else if(lastIsWall)\\n                    grid[i][j]=grid[i][j] & 1;\\n                else\\n                    grid[i][j]=0;\\n            }           \\n            \\n        }\\n        //now we count the greens i.e. 1\\'s\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // cout<<grid[i][j]<<\" \";\\n                if(grid[i][j]==1)\\n                    count++;\\n            }\\n            // cout<<endl;\\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        ll count=0;\\n        vector<vector<int>>grid(m,vector<int>(n,0));\\n        //guard=>-2\\n        //wall=>2\\n        //greens=>1\\n        //reds=>0\\n        for(auto v:guards)\\n        {\\n            grid[v[0]][v[1]]=-2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2429833,
                "title": "faster-than-87",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        self.grid = [[0]*n for item in range(m)]\\n        for item in guards:\\n            self.grid[item[0]][item[1]]=\\'G\\'\\n        for item in walls:\\n            self.grid[item[0]][item[1]]=\\'W\\'\\n        for item in guards:\\n            i, j = item\\n            # print(\\'Called from this\\',i,j)\\n            self.down_break(i+1,j)\\n            self.up_break(i-1,j)\\n            self.left_break(i,j-1)\\n            self.right_break(i,j+1)\\n                    # print(self.grid)\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                if self.grid[i][j]==0:\\n                    count+=1\\n        return count\\n                    \\n                 \\n    def up_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called up\\', r,k)\\n        self.grid[r][k]=\\'X\\'\\n        self.up_break(r-1,k)\\n    \\n    \\n    def down_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called, down\\', r,k)\\n        self.grid[r][k]= \\'X\\'\\n        self.down_break(r+1, k)\\n        \\n    \\n    def left_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called left\\', r, k)\\n        self.grid[r][k]= \\'X\\'\\n        self.left_break(r, k-1)\\n        \\n        \\n    def right_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called right\\', r,k)\\n        self.grid[r][k]= \\'X\\'\\n        self.right_break(r, k+1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        self.grid = [[0]*n for item in range(m)]\\n        for item in guards:\\n            self.grid[item[0]][item[1]]=\\'G\\'\\n        for item in walls:\\n            self.grid[item[0]][item[1]]=\\'W\\'\\n        for item in guards:\\n            i, j = item\\n            # print(\\'Called from this\\',i,j)\\n            self.down_break(i+1,j)\\n            self.up_break(i-1,j)\\n            self.left_break(i,j-1)\\n            self.right_break(i,j+1)\\n                    # print(self.grid)\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                if self.grid[i][j]==0:\\n                    count+=1\\n        return count\\n                    \\n                 \\n    def up_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called up\\', r,k)\\n        self.grid[r][k]=\\'X\\'\\n        self.up_break(r-1,k)\\n    \\n    \\n    def down_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called, down\\', r,k)\\n        self.grid[r][k]= \\'X\\'\\n        self.down_break(r+1, k)\\n        \\n    \\n    def left_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called left\\', r, k)\\n        self.grid[r][k]= \\'X\\'\\n        self.left_break(r, k-1)\\n        \\n        \\n    def right_break(self,r,k):\\n        if r<0 or r>=len(self.grid) or k>=len(self.grid[0]) or k<0 or self.grid[r][k] in [\\'G\\', \\'W\\']:\\n            return\\n        # print(\\'Called right\\', r,k)\\n        self.grid[r][k]= \\'X\\'\\n        self.right_break(r, k+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429808,
                "title": "time-limit-exceeded",
                "content": "```class Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[1 for _ in range(n)] for _ in range(m)]\\n\\n        for i,j in walls:\\n            grid[i][j] = -1 #walls no passable\\n            \\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        \\n        def guardingCells(r,c):\\n            #left\\n            grid[r][c] = 0\\n            for dx, dy in directions:\\n                curr_x = r\\n                curr_y = c\\n                \\n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and grid[curr_x+dx][curr_y+dy] != -1:\\n                    curr_x += dx\\n                    curr_y += dy\\n                    grid[curr_x][curr_y] = 0\\n\\n        for i,j in guards:\\n            guardingCells(i,j)\\n\\n        return sum(1 for i in range(m) for j in range(n) if grid[i][j] == 1)\\n\\t\\t```\\n\\t\\t\\n\\t\\tNot sure why this is TLE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[1 for _ in range(n)] for _ in range(m)]\\n\\n        for i,j in walls:\\n            grid[i][j] = -1 #walls no passable\\n            \\n        directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n        \\n        def guardingCells(r,c):\\n            #left\\n            grid[r][c] = 0\\n            for dx, dy in directions:\\n                curr_x = r\\n                curr_y = c\\n                \\n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and grid[curr_x+dx][curr_y+dy] != -1:\\n                    curr_x += dx\\n                    curr_y += dy\\n                    grid[curr_x][curr_y] = 0\\n\\n        for i,j in guards:\\n            guardingCells(i,j)\\n\\n        return sum(1 for i in range(m) for j in range(n) if grid[i][j] == 1)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2397430,
                "title": "rust-solution",
                "content": "This grid size is enough small to use brute force.\\n```\\nfn helper(memo: &mut Vec<Vec<i32>>, flag: &mut bool, r:usize, c:usize) {\\n    match memo[r][c] {\\n        1 => {\\n            if *flag {\\n                memo[r][c] = 0;\\n            }\\n        },\\n        10 => {\\n            *flag = true;\\n        },\\n        20 => {\\n            *flag = false;\\n        }\\n        _ => {}\\n    }\\n} \\n\\nimpl Solution {\\n    pub fn count_unguarded(m: i32, n: i32, guards: Vec<Vec<i32>>, walls: Vec<Vec<i32>>) -> i32 {\\n        let m = m as usize;\\n        let n = n as usize;\\n        let mut memo = vec![vec![1;n];m];\\n\\n        for arr in guards {\\n            memo[arr[0] as usize][arr[1] as usize] = 10;\\n        }\\n        for arr in walls {\\n            memo[arr[0] as usize][arr[1] as usize] = 20;\\n        }\\n\\n        for i in 0..m {\\n            let mut flag = false;\\n            for j in 0..n {\\n                helper(&mut memo, &mut flag, i, j);\\n            } \\n            let mut flag = false;\\n            for j in (0..n).rev() {\\n                helper(&mut memo, &mut flag, i, j);\\n            }\\n        }\\n\\n        for i in 0..n {\\n            let mut flag = false;\\n            for j in 0..m {\\n                helper(&mut memo, &mut flag, j, i);\\n            } \\n            let mut flag = false;\\n            for j in (0..m).rev() {\\n                helper(&mut memo, &mut flag, j, i);\\n            }\\n        }\\n\\n        let mut result = 0;\\n        for i in 0..m {\\n            for j in 0..n {\\n                if memo[i][j] == 1 {\\n                    result += 1;\\n                }\\n            }\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn helper(memo: &mut Vec<Vec<i32>>, flag: &mut bool, r:usize, c:usize) {\\n    match memo[r][c] {\\n        1 => {\\n            if *flag {\\n                memo[r][c] = 0;\\n            }\\n        },\\n        10 => {\\n            *flag = true;\\n        },\\n        20 => {\\n            *flag = false;\\n        }\\n        _ => {}\\n    }\\n} \\n\\nimpl Solution {\\n    pub fn count_unguarded(m: i32, n: i32, guards: Vec<Vec<i32>>, walls: Vec<Vec<i32>>) -> i32 {\\n        let m = m as usize;\\n        let n = n as usize;\\n        let mut memo = vec![vec![1;n];m];\\n\\n        for arr in guards {\\n            memo[arr[0] as usize][arr[1] as usize] = 10;\\n        }\\n        for arr in walls {\\n            memo[arr[0] as usize][arr[1] as usize] = 20;\\n        }\\n\\n        for i in 0..m {\\n            let mut flag = false;\\n            for j in 0..n {\\n                helper(&mut memo, &mut flag, i, j);\\n            } \\n            let mut flag = false;\\n            for j in (0..n).rev() {\\n                helper(&mut memo, &mut flag, i, j);\\n            }\\n        }\\n\\n        for i in 0..n {\\n            let mut flag = false;\\n            for j in 0..m {\\n                helper(&mut memo, &mut flag, j, i);\\n            } \\n            let mut flag = false;\\n            for j in (0..m).rev() {\\n                helper(&mut memo, &mut flag, j, i);\\n            }\\n        }\\n\\n        let mut result = 0;\\n        for i in 0..m {\\n            for j in 0..n {\\n                if memo[i][j] == 1 {\\n                    result += 1;\\n                }\\n            }\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2372238,
                "title": "c-simple-c-code-o-n-m-82-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> visited(m+1, vector<int> (n+1, 0));\\n        int ans = 0;\\n        for(vector<int> &vec : walls){\\n            visited[vec[0]][vec[1]] = -1;\\n            ans++;\\n        }\\n        int dirx[4] = {-1,1,0,0};\\n        int diry[4] = {0,0,1,-1};\\n        queue<pair<pair<int, int>, int>> q;\\n        for(vector<int> &vec : guards)\\n        {\\n            visited[vec[0]][vec[1]] = 2;\\n            q.push({{vec[0], vec[1]},4});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<pair<int, int>, int> tp = q.front();\\n            q.pop();\\n            int x = tp.first.first;\\n            int y = tp.first.second;\\n            int dir = tp.second;\\n            if(visited[x][y] != -2)\\n                ans++;\\n            if(dir == 4)\\n            {\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx >= m || nxtx < 0 || nxty >= n || nxty < 0) continue;\\n                    if(visited[nxtx][nxty] == -1 || visited[nxtx][nxty] == 2) continue;\\n                    q.push({{nxtx, nxty}, i});\\n                }\\n            }\\n            else\\n            {\\n                visited[x][y] = -2;\\n                int nxtx = x + dirx[dir];\\n                int nxty = y + diry[dir];\\n                if(nxtx >= m || nxtx < 0 || nxty >= n || nxty < 0) continue;\\n                if(visited[nxtx][nxty] == -1 || visited[nxtx][nxty] == 2) continue;\\n                q.push({{nxtx, nxty}, dir});\\n            }\\n        }\\n        return (long long)(m*n) - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        vector<vector<int>> visited(m+1, vector<int> (n+1, 0));\\n        int ans = 0;\\n        for(vector<int> &vec : walls){\\n            visited[vec[0]][vec[1]] = -1;\\n            ans++;\\n        }\\n        int dirx[4] = {-1,1,0,0};\\n        int diry[4] = {0,0,1,-1};\\n        queue<pair<pair<int, int>, int>> q;\\n        for(vector<int> &vec : guards)\\n        {\\n            visited[vec[0]][vec[1]] = 2;\\n            q.push({{vec[0], vec[1]},4});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<pair<int, int>, int> tp = q.front();\\n            q.pop();\\n            int x = tp.first.first;\\n            int y = tp.first.second;\\n            int dir = tp.second;\\n            if(visited[x][y] != -2)\\n                ans++;\\n            if(dir == 4)\\n            {\\n                for(int i = 0; i < 4; i++)\\n                {\\n                    int nxtx = x + dirx[i];\\n                    int nxty = y + diry[i];\\n                    if(nxtx >= m || nxtx < 0 || nxty >= n || nxty < 0) continue;\\n                    if(visited[nxtx][nxty] == -1 || visited[nxtx][nxty] == 2) continue;\\n                    q.push({{nxtx, nxty}, i});\\n                }\\n            }\\n            else\\n            {\\n                visited[x][y] = -2;\\n                int nxtx = x + dirx[dir];\\n                int nxty = y + diry[dir];\\n                if(nxtx >= m || nxtx < 0 || nxty >= n || nxty < 0) continue;\\n                if(visited[nxtx][nxty] == -1 || visited[nxtx][nxty] == 2) continue;\\n                q.push({{nxtx, nxty}, dir});\\n            }\\n        }\\n        return (long long)(m*n) - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356533,
                "title": "java-easy-count-differently",
                "content": "```\\nclass Solution {\\n    private final char GUARD = \\'G\\';\\n    private final char RANGE = \\'R\\';\\n    private final char WALL = \\'W\\';\\n    private final int[][] dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    \\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        final char[][] mat = new char[m][n];\\n        for (final int[] wall : walls) {\\n            mat[wall[0]][wall[1]] = WALL;\\n        }\\n        \\n        for (final int[] guard : guards) {\\n            mat[guard[0]][guard[1]] = GUARD;\\n        }\\n        \\n        int count = (m*n) - guards.length - walls.length;\\n        \\n        for (final int[] guard : guards) {\\n            for (final int[] dir : dirs) {\\n                int x = dir[0] + guard[0], y = dir[1] + guard[1];\\n                while (isValid(mat, x, y)) {\\n                    if (mat[x][y] == 0) count--;\\n                    mat[x][y] = RANGE;\\n                    x += dir[0];\\n                    y += dir[1]; \\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean isValid(final char[][] mat, final int i, final int j) {\\n        return i >=0 && j >=0 && i < mat.length && j < mat[0].length && (mat[i][j] == 0 || mat[i][j] == RANGE);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private final char GUARD = \\'G\\';\\n    private final char RANGE = \\'R\\';\\n    private final char WALL = \\'W\\';\\n    private final int[][] dirs = {{0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 2338442,
                "title": "tle-why",
                "content": "class Solution(object):\\n    def countUnguarded(self, m, n, guards, walls):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type guards: List[List[int]]\\n        :type walls: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n         #nseen  = [ [ 1  for j in range(n)] for i in range(m)]\\n        \\n        grid = [ [ 0  for j in range(n)] for i in range(m)]\\n        \\n        for x in guards :\\n            \\n            grid[x[0]][x[1]] = 1\\n            \\n        for x in walls :\\n            \\n            grid[x[0]][x[1]] = -1\\n            \\n            \\n            \\n        for i , j in guards :\\n                    \\n                    \\n                    \\n                    for k in range( j , n) :\\n                        if grid[i][k] == -1 or (grid[i][k] == 1 and [i, k]!=[i, j])  :\\n                            break\\n                       \\n                        grid[i][k] = 2                           \\n                            \\n                            \\n                    for k in range(j,-1, -1) :\\n                        if grid[i][k] == -1 or (grid[i][k] == 1 and [i, k]!=[i, j] ):\\n                            break\\n                        \\n                        grid[i][k] = 2\\n                            \\n                        \\n                    for k in range( i, m ):\\n                        \\n                        if grid[k][j] == -1  or (grid[k][j] == 1 and [k, j] != [i,j]):\\n                            break\\n                 \\n                        grid[k][j] = 2\\n          \\n                        \\n                    for k in range( i, -1 ,-1) :\\n                        if grid[k][j] == -1 or (grid[k][j] == 1 and [k, j] != [i,j]):\\n                            break\\n                        \\n                            \\n                        grid[k][j] = 2\\n                            \\n            \\n                    \\n                \\n                \\n        count = 0\\n        for i in range(m) :\\n            for j in range(n) :\\n                if grid[i][j] == 0 :\\n                    count += 1\\n            \\n            \\n            \\n                  \\n      \\n        return( count)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def countUnguarded(self, m, n, guards, walls):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type guards: List[List[int]]\\n        :type walls: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n         #nseen  = [ [ 1  for j in range(n)] for i in range(m)]\\n        \\n        grid = [ [ 0  for j in range(n)] for i in range(m)]\\n        \\n        for x in guards :\\n            \\n            grid[x[0]][x[1]] = 1\\n            \\n        for x in walls :\\n            \\n            grid[x[0]][x[1]] = -1\\n            \\n            \\n            \\n        for i , j in guards :\\n                    \\n                    \\n                    \\n                    for k in range( j , n) :\\n                        if grid[i][k] == -1 or (grid[i][k] == 1 and [i, k]!=[i, j])  :\\n                            break\\n                       \\n                        grid[i][k] = 2                           \\n                            \\n                            \\n                    for k in range(j,-1, -1) :\\n                        if grid[i][k] == -1 or (grid[i][k] == 1 and [i, k]!=[i, j] ):\\n                            break\\n                        \\n                        grid[i][k] = 2\\n                            \\n                        \\n                    for k in range( i, m ):\\n                        \\n                        if grid[k][j] == -1  or (grid[k][j] == 1 and [k, j] != [i,j]):\\n                            break\\n                 \\n                        grid[k][j] = 2\\n          \\n                        \\n                    for k in range( i, -1 ,-1) :\\n                        if grid[k][j] == -1 or (grid[k][j] == 1 and [k, j] != [i,j]):\\n                            break\\n                        \\n                            \\n                        grid[k][j] = 2\\n                            \\n            \\n                    \\n                \\n                \\n        count = 0\\n        for i in range(m) :\\n            for j in range(n) :\\n                if grid[i][j] == 0 :\\n                    count += 1\\n            \\n            \\n            \\n                  \\n      \\n        return( count)",
                "codeTag": "Java"
            },
            {
                "id": 2336625,
                "title": "c-easy-solution",
                "content": "pls  upvote  if  it\\'s helpful \\n```\\n int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w)\\n    {\\n       vector<vector<int>>vi(m,vector<int>(n,0))  ;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            int x=g[i][0] ;\\n            int y=g[i][1] ;\\n            vi[x][y]=1 ;\\n        }\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int x=w[i][0] ;\\n            int y=w[i][1] ;\\n            vi[x][y]=-1 ;\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vi[i][j]==1)\\n                {  \\n                    check(vi,i,j);\\n                    vi[i][j]=-1 ;\\n                }\\n            \\n        \\n        int res=0 ;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vi[i][j]==0)\\n                res++ ;\\n            \\n        \\n        return res ;\\n    }\\n    void check(vector<vector<int>>&vi,int i,int j)\\n    {\\n        for(int p=i-1;p>=0;p--)\\n        {\\n            if(vi[p][j]==1 || vi[p][j]==-1)\\n            break ;\\n            \\n             vi[p][j]=10 ;\\n        }\\n        \\n        for(int p=j+1;p<vi[0].size();p++)\\n        {\\n            if(vi[i][p]==1 || vi[i][p]==-1)\\n                break ;\\n            vi[i][p]=10 ;\\n        }\\n        \\n        for(int p=i+1;p<vi.size();p++)\\n        {\\n            if(vi[p][j]==1 || vi[p][j]==-1)\\n                break ;\\n            \\n           vi[p][j]=10 ;\\n        }\\n       \\n        for(int p=j-1 ;p>=0;p--)\\n        {\\n            if(vi[i][p]==1 || vi[i][p]==-1)\\n                break ;\\n            vi[i][p]=10 ;\\n        }\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w)\\n    {\\n       vector<vector<int>>vi(m,vector<int>(n,0))  ;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            int x=g[i][0] ;\\n            int y=g[i][1] ;\\n            vi[x][y]=1 ;\\n        }\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int x=w[i][0] ;\\n            int y=w[i][1] ;\\n            vi[x][y]=-1 ;\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vi[i][j]==1)\\n                {  \\n                    check(vi,i,j);\\n                    vi[i][j]=-1 ;\\n                }\\n            \\n        \\n        int res=0 ;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(vi[i][j]==0)\\n                res++ ;\\n            \\n        \\n        return res ;\\n    }\\n    void check(vector<vector<int>>&vi,int i,int j)\\n    {\\n        for(int p=i-1;p>=0;p--)\\n        {\\n            if(vi[p][j]==1 || vi[p][j]==-1)\\n            break ;\\n            \\n             vi[p][j]=10 ;\\n        }\\n        \\n        for(int p=j+1;p<vi[0].size();p++)\\n        {\\n            if(vi[i][p]==1 || vi[i][p]==-1)\\n                break ;\\n            vi[i][p]=10 ;\\n        }\\n        \\n        for(int p=i+1;p<vi.size();p++)\\n        {\\n            if(vi[p][j]==1 || vi[p][j]==-1)\\n                break ;\\n            \\n           vi[p][j]=10 ;\\n        }\\n       \\n        for(int p=j-1 ;p>=0;p--)\\n        {\\n            if(vi[i][p]==1 || vi[i][p]==-1)\\n                break ;\\n            vi[i][p]=10 ;\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307488,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Brute Force***\\n\\n* ***Time Complexity :- O(N * M * N)***\\n\\n* ***Space Complexity :- O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        // initialize all the cells unvisited with \\'u\\'\\n        \\n        vector<vector<char>> grid(n, vector<char> (m, \\'u\\'));\\n        \\n        // mark the cell which contain wall with \\'w\\'\\n        \\n        for(int i = 0; i < walls.size(); i++)\\n        {\\n            grid[walls[i][0]][walls[i][1]] = \\'w\\';\\n        }\\n        \\n        // mark the cell which contain guard with \\'g\\'\\n        \\n        for(auto v : guards)\\n        {\\n            grid[v[0]][v[1]] = \\'g\\';\\n        }\\n        \\n        // iterate over guards matrix and mark the possible cell visited with \\'v\\'\\n        \\n        for(auto v : guards)\\n        {\\n            // row no. of guard cell\\n            \\n            int row = v[0];\\n            \\n            // col no. of guard cell\\n            \\n            int col = v[1];\\n            \\n            // mark visited in up side \\n            \\n            int i = row - 1;\\n            \\n            int j = col;\\n           \\n            while(i >= 0 && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                i--;\\n            }\\n            \\n            // mark visited in bottom side\\n            \\n            i = row + 1;\\n            \\n            j = col;\\n            \\n            while(i < n && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                i++;\\n            }\\n            \\n            // mark visited in left side\\n            \\n            i = row;\\n            \\n            j = col - 1;\\n            \\n            while(j >= 0 && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                j--;\\n            }\\n            \\n            // mark visited in right side\\n            \\n            i = row;\\n            \\n            j = col + 1;\\n            \\n            while(j < m && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                j++;\\n            }\\n        }\\n        \\n        // count all the unvisited cell\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] == \\'u\\')\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countUnguarded(int n, int m, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        \\n        // initialize all the cells unvisited with \\'u\\'\\n        \\n        vector<vector<char>> grid(n, vector<char> (m, \\'u\\'));\\n        \\n        // mark the cell which contain wall with \\'w\\'\\n        \\n        for(int i = 0; i < walls.size(); i++)\\n        {\\n            grid[walls[i][0]][walls[i][1]] = \\'w\\';\\n        }\\n        \\n        // mark the cell which contain guard with \\'g\\'\\n        \\n        for(auto v : guards)\\n        {\\n            grid[v[0]][v[1]] = \\'g\\';\\n        }\\n        \\n        // iterate over guards matrix and mark the possible cell visited with \\'v\\'\\n        \\n        for(auto v : guards)\\n        {\\n            // row no. of guard cell\\n            \\n            int row = v[0];\\n            \\n            // col no. of guard cell\\n            \\n            int col = v[1];\\n            \\n            // mark visited in up side \\n            \\n            int i = row - 1;\\n            \\n            int j = col;\\n           \\n            while(i >= 0 && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                i--;\\n            }\\n            \\n            // mark visited in bottom side\\n            \\n            i = row + 1;\\n            \\n            j = col;\\n            \\n            while(i < n && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                i++;\\n            }\\n            \\n            // mark visited in left side\\n            \\n            i = row;\\n            \\n            j = col - 1;\\n            \\n            while(j >= 0 && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                j--;\\n            }\\n            \\n            // mark visited in right side\\n            \\n            i = row;\\n            \\n            j = col + 1;\\n            \\n            while(j < m && grid[i][j] != \\'w\\' && grid[i][j] != \\'g\\')\\n            {\\n                grid[i][j] = \\'v\\';\\n                \\n                j++;\\n            }\\n        }\\n        \\n        // count all the unvisited cell\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] == \\'u\\')\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298098,
                "title": "best-and-easy-way-to-do-this",
                "content": "\\tclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        dp=[[-1 for x in range(n)] for y in range(m)] \\n        print(dp)\\n        for x,y in guards:\\n            print(x,y)\\n            dp[x][y]=1\\n        for x,y in walls:\\n            dp[x][y]=2\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if dp[i][j]==1:\\n                    print(i,j)\\n                    r=j+1\\n                    while r<n and dp[i][r]!=2 and dp[i][r]!=1:\\n                        dp[i][r]=0\\n                        r+=1\\n                    l=j-1\\n                    while dp[i][l]!=2 and l>=0 and dp[i][l]!=1:\\n                        dp[i][l]=0\\n                        l-=1\\n                    up=i-1\\n                    while up>=0 and dp[up][j]!=2 and dp[up][j]!=1:\\n                        dp[up][j]=0\\n                        up-=1\\n                    dw=i+1\\n                    while dw<m and dp[dw][j]!=2 and dp[dw][j]!=1:\\n                        dp[dw][j]=0\\n                        dw+=1\\n        ans=0\\n        for i in range(len(dp)):\\n            ans+=dp[i].count(-1)\\n        \\n        return ans\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        dp=[[-1 for x in range(n)] for y in range(m)] \\n        print(dp)\\n        for x,y in guards:\\n            print(x,y)\\n            dp[x][y]=1\\n        for x,y in walls:\\n            dp[x][y]=2\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if dp[i][j]==1:\\n                    print(i,j)\\n                    r=j+1\\n                    while r<n and dp[i][r]!=2 and dp[i][r]!=1:\\n                        dp[i][r]=0\\n                        r+=1\\n                    l=j-1\\n                    while dp[i][l]!=2 and l>=0 and dp[i][l]!=1:\\n                        dp[i][l]=0\\n                        l-=1\\n                    up=i-1\\n                    while up>=0 and dp[up][j]!=2 and dp[up][j]!=1:\\n                        dp[up][j]=0\\n                        up-=1\\n                    dw=i+1\\n                    while dw<m and dp[dw][j]!=2 and dp[dw][j]!=1:\\n                        dp[dw][j]=0\\n                        dw+=1\\n        ans=0\\n        for i in range(len(dp)):\\n            ans+=dp[i].count(-1)\\n        \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2274016,
                "title": "python-straight-forawrd-dfs",
                "content": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [ [0]*n for _ in range(m) ]\\n        \\n        for w_i, w_j in walls:\\n            grid[w_i][w_j] = 1\\n        \\n        for g_i, g_j in guards:\\n            grid[g_i][g_j] = 1\\n\\n        directions = [0, 1, 0, -1, 0]\\n        for g_i, g_j in guards:\\n            self.dfs(g_i, g_j, m, n, grid, directions)\\n            \\n        safe_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    safe_count += 1\\n                    \\n        return safe_count\\n    \\n    def dfs(self, g_i, g_j, m, n, grid, directions):\\n        for dir_index in range(1, 5):\\n            direction = (directions[dir_index], directions[dir_index - 1])\\n            self.goToGivenDirection(g_i, g_j, m, n, direction, grid)\\n        \\n    def goToGivenDirection(self, cur_i, cur_j, m, n, direction, grid):\\n        cur_i += direction[0]\\n        cur_j += direction[1]\\n        while self.inside(cur_i, cur_j, m, n) and (grid[cur_i][cur_j] != 1):\\n            grid[cur_i][cur_j] = -1\\n            cur_i += direction[0]\\n            cur_j += direction[1]\\n        \\n    def inside(self, i, j, m, n):\\n        if i < 0 or i >= m or j < 0 or j >= n:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [ [0]*n for _ in range(m) ]\\n        \\n        for w_i, w_j in walls:\\n            grid[w_i][w_j] = 1\\n        \\n        for g_i, g_j in guards:\\n            grid[g_i][g_j] = 1\\n\\n        directions = [0, 1, 0, -1, 0]\\n        for g_i, g_j in guards:\\n            self.dfs(g_i, g_j, m, n, grid, directions)\\n            \\n        safe_count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    safe_count += 1\\n                    \\n        return safe_count\\n    \\n    def dfs(self, g_i, g_j, m, n, grid, directions):\\n        for dir_index in range(1, 5):\\n            direction = (directions[dir_index], directions[dir_index - 1])\\n            self.goToGivenDirection(g_i, g_j, m, n, direction, grid)\\n        \\n    def goToGivenDirection(self, cur_i, cur_j, m, n, direction, grid):\\n        cur_i += direction[0]\\n        cur_j += direction[1]\\n        while self.inside(cur_i, cur_j, m, n) and (grid[cur_i][cur_j] != 1):\\n            grid[cur_i][cur_j] = -1\\n            cur_i += direction[0]\\n            cur_j += direction[1]\\n        \\n    def inside(self, i, j, m, n):\\n        if i < 0 or i >= m or j < 0 or j >= n:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272978,
                "title": "no-idea-why-this-is-tle",
                "content": "```\\nclass Solution {\\n    \\n    enum state {\\n        GUARDED,\\n        WALL,\\n        NONE\\n    };\\n    \\n    vector<vector<state>> grid_;\\n    int rows_;\\n    int cols_;\\n    \\n    void guard(int x, int y) {\\n        int cur_x = x;\\n        // grid_[x][y] = GUARDED;\\n        while (cur_x >= 0) {\\n            if (grid_[cur_x][y] == WALL)\\n                break;\\n            \\n            grid_[cur_x][y] = GUARDED;\\n            --cur_x;\\n        }\\n        \\n        cur_x = x;\\n        while (cur_x < rows_) {\\n            if (grid_[cur_x][y] == WALL)\\n                break;\\n            \\n            grid_[cur_x][y] = GUARDED;\\n            ++cur_x;\\n        }\\n        \\n        int cur_y = y;\\n        while (cur_y >= 0) {\\n            if (grid_[x][cur_y] == WALL)\\n                break;\\n            grid_[x][cur_y] = GUARDED;\\n            --cur_y;\\n        }\\n        \\n        cur_y = y;\\n        while (cur_y < cols_) {\\n            if (grid_[x][cur_y] == WALL)\\n                break;\\n            grid_[x][cur_y] = GUARDED;\\n            ++cur_y;\\n        }\\n    }\\n    \\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        grid_.assign(m, vector<state>(n, NONE));\\n        rows_ = m;\\n        cols_ = n;\\n        \\n        for (auto& w : walls) {\\n            auto x = w[0];\\n            auto y = w[1];\\n            grid_[x][y] = WALL;\\n        }\\n        \\n        for (auto& g : guards) {\\n            guard(g[0], g[1]);\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid_[i][j] == NONE)\\n                    ++res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    enum state {\\n        GUARDED,\\n        WALL,\\n        NONE\\n    };\\n    \\n    vector<vector<state>> grid_;\\n    int rows_;\\n    int cols_;\\n    \\n    void guard(int x, int y) {\\n        int cur_x = x;\\n        // grid_[x][y] = GUARDED;\\n        while (cur_x >= 0) {\\n            if (grid_[cur_x][y] == WALL)\\n                break;\\n            \\n            grid_[cur_x][y] = GUARDED;\\n            --cur_x;\\n        }\\n        \\n        cur_x = x;\\n        while (cur_x < rows_) {\\n            if (grid_[cur_x][y] == WALL)\\n                break;\\n            \\n            grid_[cur_x][y] = GUARDED;\\n            ++cur_x;\\n        }\\n        \\n        int cur_y = y;\\n        while (cur_y >= 0) {\\n            if (grid_[x][cur_y] == WALL)\\n                break;\\n            grid_[x][cur_y] = GUARDED;\\n            --cur_y;\\n        }\\n        \\n        cur_y = y;\\n        while (cur_y < cols_) {\\n            if (grid_[x][cur_y] == WALL)\\n                break;\\n            grid_[x][cur_y] = GUARDED;\\n            ++cur_y;\\n        }\\n    }\\n    \\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {\\n        grid_.assign(m, vector<state>(n, NONE));\\n        rows_ = m;\\n        cols_ = n;\\n        \\n        for (auto& w : walls) {\\n            auto x = w[0];\\n            auto y = w[1];\\n            grid_[x][y] = WALL;\\n        }\\n        \\n        for (auto& g : guards) {\\n            guard(g[0], g[1]);\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid_[i][j] == NONE)\\n                    ++res;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246001,
                "title": "python-simple-solution-o-m-n",
                "content": "```python\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[\" \"] * n for _ in range(m)]\\n        for x,y in guards:\\n            grid[x][y] = \\'g\\'\\n        for x,y in walls:\\n            grid[x][y]= \\'w\\'\\n        a = [0] * n\\n        b = [0] * n \\n        res = 0 \\n        for i in range(m):\\n            l = r = 0\\n            for j in range(n):\\n                while r < n-1 and (r < j or grid[i][r] == \" \"):\\n                    r += 1\\n                while (b[j] < i or grid[b[j]][j] == \" \") and b[j] < m-1:\\n                    b[j] += 1\\n                if grid[i][j] != \" \":\\n                    l, a[j] = j, i\\n                else:\\n                    res += \\'g\\' not in grid[i][l] + grid[i][r] + grid[a[j]][j] + grid[b[j]][j]\\n        return res \\n                       \\n\\t```",
                "solutionTags": [],
                "code": "```python\\ndef countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[\" \"] * n for _ in range(m)]\\n        for x,y in guards:\\n            grid[x][y] = \\'g\\'\\n        for x,y in walls:\\n            grid[x][y]= \\'w\\'\\n        a = [0] * n\\n        b = [0] * n \\n        res = 0 \\n        for i in range(m):\\n            l = r = 0\\n            for j in range(n):\\n                while r < n-1 and (r < j or grid[i][r] == \" \"):\\n                    r += 1\\n                while (b[j] < i or grid[b[j]][j] == \" \") and b[j] < m-1:\\n                    b[j] += 1\\n                if grid[i][j] != \" \":\\n                    l, a[j] = j, i\\n                else:\\n                    res += \\'g\\' not in grid[i][l] + grid[i][r] + grid[a[j]][j] + grid[b[j]][j]\\n        return res \\n                       \\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2237919,
                "title": "python-simple-solution",
                "content": "```python\\n# Each number in the grid will represent an object from \\n# the problem statement\\n# \\n# 0  -> Unguarded Cells\\n# 1  -> Guarded Cells\\n# 2  -> Guards\\n# 3 -> Walls\\n\\n(UNGUARDED, GUARDED, GUARD, WALL) = (0, 1, 2, 3)\\n\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[0 for _ in range(0, n)] for _ in range(0, m)]\\n        \\n        cnt = ( m * n) - len(walls) - len(guards)\\n        \\n        for (row, col) in walls:\\n            grid[row][col] = WALL\\n            \\n        for (row, col) in guards:\\n            grid[row][col] = GUARD\\n        \\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        for (row, col) in guards:\\n            \\n            for dx, dy in dirs:\\n                x = row + dx\\n                y = col + dy\\n                \\n                while ( \\n                    x>=0 and \\n                    x <m and \\n                    y >= 0 and \\n                    y< n and \\n                    grid[x][y] != WALL and \\n                    grid[x][y] != GUARD\\n                ):\\n                    if grid[x][y] == UNGUARDED:\\n                        cnt-=1\\n                    grid[x][y] = GUARDED\\n                    x = x + dx\\n                    y = y + dy\\n\\n        return cnt  \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n# Each number in the grid will represent an object from \\n# the problem statement\\n# \\n# 0  -> Unguarded Cells\\n# 1  -> Guarded Cells\\n# 2  -> Guards\\n# 3 -> Walls\\n\\n(UNGUARDED, GUARDED, GUARD, WALL) = (0, 1, 2, 3)\\n\\nclass Solution:\\n    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:\\n        grid = [[0 for _ in range(0, n)] for _ in range(0, m)]\\n        \\n        cnt = ( m * n) - len(walls) - len(guards)\\n        \\n        for (row, col) in walls:\\n            grid[row][col] = WALL\\n            \\n        for (row, col) in guards:\\n            grid[row][col] = GUARD\\n        \\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        for (row, col) in guards:\\n            \\n            for dx, dy in dirs:\\n                x = row + dx\\n                y = col + dy\\n                \\n                while ( \\n                    x>=0 and \\n                    x <m and \\n                    y >= 0 and \\n                    y< n and \\n                    grid[x][y] != WALL and \\n                    grid[x][y] != GUARD\\n                ):\\n                    if grid[x][y] == UNGUARDED:\\n                        cnt-=1\\n                    grid[x][y] = GUARDED\\n                    x = x + dx\\n                    y = y + dy\\n\\n        return cnt  \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214812,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution \\n{\\n    //0----->unvisited  //1---->visited  //2----->guard  //3----->wall\\n    int d[][]={{-1,0},{1,0},{0,1},{0,-1}};\\n    \\n    public int countUnguarded(int m, int n, int[][] g, int[][] w) \\n    {\\n        int ans=0; int visited[][]=new int[m][n];\\n        \\n        for(int i=0;i<w.length;i++)\\n        {\\n            int x=w[i][0];  int y=w[i][1]; visited[x][y]=3;\\n        }\\n        \\n        for(int i=0;i<g.length;i++)\\n        {\\n            int x=g[i][0];  int y=g[i][1];  visited[x][y]=2;\\n        }\\n        \\n        for(int i=0;i<g.length;i++)\\n        {\\n            int x=g[i][0];  int y=g[i][1];\\n            \\n            for(int j=0;j<4;j++)\\n            dfs(visited,x+d[j][0],y+d[j][1],d[j][0],d[j][1]);\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(visited[i][j]==0)\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void dfs(int visited[][],int i,int j,int x,int y)\\n    {\\n        if(i<0 || j<0 || i>=visited.length || j>=visited[0].length)\\n        return;\\n        \\n        if(visited[i][j]==3 || visited[i][j]==2)\\n        return;\\n        \\n        visited[i][j]=1;\\n        dfs(visited,i+x,j+y,x,y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    //0----->unvisited  //1---->visited  //2----->guard  //3----->wall\\n    int d[][]={{-1,0},{1,0},{0,1},{0,-1}};\\n    \\n    public int countUnguarded(int m, int n, int[][] g, int[][] w) \\n    {\\n        int ans=0; int visited[][]=new int[m][n];\\n        \\n        for(int i=0;i<w.length;i++)\\n        {\\n            int x=w[i][0];  int y=w[i][1]; visited[x][y]=3;\\n        }\\n        \\n        for(int i=0;i<g.length;i++)\\n        {\\n            int x=g[i][0];  int y=g[i][1];  visited[x][y]=2;\\n        }\\n        \\n        for(int i=0;i<g.length;i++)\\n        {\\n            int x=g[i][0];  int y=g[i][1];\\n            \\n            for(int j=0;j<4;j++)\\n            dfs(visited,x+d[j][0],y+d[j][1],d[j][0],d[j][1]);\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(visited[i][j]==0)\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void dfs(int visited[][],int i,int j,int x,int y)\\n    {\\n        if(i<0 || j<0 || i>=visited.length || j>=visited[0].length)\\n        return;\\n        \\n        if(visited[i][j]==3 || visited[i][j]==2)\\n        return;\\n        \\n        visited[i][j]=1;\\n        dfs(visited,i+x,j+y,x,y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181744,
                "title": "javascript-state-transition",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} guards\\n * @param {number[][]} walls\\n * @return {number}\\n */\\nvar countUnguarded = function(m, n, guards, walls) {\\n    const table = new Array(m)\\n    for (const i of table.keys())\\n        table[i] = new Array(n).fill(0)\\n    \\n    for (const [i, j] of guards.values()) {\\n        table[i][j] = 1\\n    }\\n    \\n    for (const [i, j] of walls.values()) {\\n        table[i][j] = 2\\n    }\\n    \\n    \\n    for (let i = 0; i < m; i++) {\\n        let isGuarding = false\\n        for (let j = 0; j < n; j++) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        let isGuarding = false\\n        for (let j = n - 1; j >= 0; j--) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        let isGuarding = false\\n        for (let i = 0; i < m; i++) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        let isGuarding = false\\n        for (let i = m - 1; i >= 0; i--) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const row of table.values())\\n        for (const val of row.values())\\n            if (val === 0)  result++\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} guards\\n * @param {number[][]} walls\\n * @return {number}\\n */\\nvar countUnguarded = function(m, n, guards, walls) {\\n    const table = new Array(m)\\n    for (const i of table.keys())\\n        table[i] = new Array(n).fill(0)\\n    \\n    for (const [i, j] of guards.values()) {\\n        table[i][j] = 1\\n    }\\n    \\n    for (const [i, j] of walls.values()) {\\n        table[i][j] = 2\\n    }\\n    \\n    \\n    for (let i = 0; i < m; i++) {\\n        let isGuarding = false\\n        for (let j = 0; j < n; j++) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        let isGuarding = false\\n        for (let j = n - 1; j >= 0; j--) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        let isGuarding = false\\n        for (let i = 0; i < m; i++) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    for (let j = 0; j < n; j++) {\\n        let isGuarding = false\\n        for (let i = m - 1; i >= 0; i--) {\\n            const val = table[i][j]\\n            if (val === 0) {\\n                if (isGuarding) {\\n                    table[i][j] = 3\\n                }\\n            } else if (val === 1) {\\n                isGuarding = true\\n            } else if (val === 2) {\\n                isGuarding = false\\n            }\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const row of table.values())\\n        for (const val of row.values())\\n            if (val === 0)  result++\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177296,
                "title": "c-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>>matrix(m, vector<int>(n));        \\n        for (auto guard: guards)\\n            matrix[guard[0]][guard[1]] = 2;\\n        for (auto wall: walls)\\n            matrix[wall[0]][wall[1]] = 2;\\n        \\n        vector<pair<int,int>>dir({{1,0},{-1,0},{0,1},{0,-1}});\\n        for (auto guard: guards)                   \\n            for (auto [dx, dy]: dir)\\n            {                \\n                int i = guard[0], j = guard[1];\\n                while (1)\\n                {\\n                    i+=dx;\\n                    j+=dy;\\n                    if (i<0||i>=m || j<0||j>=n) break;\\n                    if (matrix[i][j]==2) break;\\n                    matrix[i][j] = 1;\\n                }\\n            }\\n        \\n        int ret = 0;\\n        for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++)\\n                if (matrix[i][j]==0)\\n                    ret++;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) \\n    {\\n        vector<vector<int>>matrix(m, vector<int>(n));        \\n        for (auto guard: guards)\\n            matrix[guard[0]][guard[1]] = 2;\\n        for (auto wall: walls)\\n            matrix[wall[0]][wall[1]] = 2;\\n        \\n        vector<pair<int,int>>dir({{1,0},{-1,0},{0,1},{0,-1}});\\n        for (auto guard: guards)                   \\n            for (auto [dx, dy]: dir)\\n            {                \\n                int i = guard[0], j = guard[1];\\n                while (1)\\n                {\\n                    i+=dx;\\n                    j+=dy;\\n                    if (i<0||i>=m || j<0||j>=n) break;\\n                    if (matrix[i][j]==2) break;\\n                    matrix[i][j] = 1;\\n                }\\n            }\\n        \\n        int ret = 0;\\n        for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++)\\n                if (matrix[i][j]==0)\\n                    ret++;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158940,
                "title": "c-matrix-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    //1->no guard\\n    //0->guard can protect\\n    //3->intial guard\\n    //4->intial wall\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n       vector<vector<int>>a(m,vector<int>(n,-1)) ;\\n        for(int i=0;i<g.size();i++)\\n            a[g[i][0]][g[i][1]]=3;\\n        for(int i=0;i<w.size();i++)\\n            a[w[i][0]][w[i][1]]=4;\\n        for(int i=0;i<m;i++)\\n        {   int pr=4;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==-1&&pr==4)\\n                {\\n                    a[i][j]=1;\\n                }\\n                else if(a[i][j]==-1&&pr==3)\\n                {\\n                    a[i][j]=0;\\n                }\\n                else\\n                    pr=a[i][j];\\n            }\\n        }\\n         for(int i=0;i<m;i++)\\n        {   int pr=4;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(a[i][j]==1&&pr==3)\\n                {\\n                    a[i][j]=0;\\n                }\\n                else if(a[i][j]==3||a[i][j]==4)\\n                    pr=a[i][j];\\n            }\\n        }\\n          for(int i=0;i<n;i++)\\n        {   int pr=4;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[j][i]==1&&pr==3)\\n                {\\n                    a[j][i]=0;\\n                }\\n                else if(a[j][i]==3||a[j][i]==4)\\n                    pr=a[j][i];\\n            }\\n        }\\n          for(int i=0;i<n;i++)\\n        {   int pr=4;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(a[j][i]==1&&pr==3)\\n                {\\n                    a[j][i]=0;\\n                }\\n                else if(a[j][i]==3||a[j][i]==4)\\n                    pr=a[j][i];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==1)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //1->no guard\\n    //0->guard can protect\\n    //3->intial guard\\n    //4->intial wall\\n    int countUnguarded(int m, int n, vector<vector<int>>& g, vector<vector<int>>& w) {\\n       vector<vector<int>>a(m,vector<int>(n,-1)) ;\\n        for(int i=0;i<g.size();i++)\\n            a[g[i][0]][g[i][1]]=3;\\n        for(int i=0;i<w.size();i++)\\n            a[w[i][0]][w[i][1]]=4;\\n        for(int i=0;i<m;i++)\\n        {   int pr=4;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==-1&&pr==4)\\n                {\\n                    a[i][j]=1;\\n                }\\n                else if(a[i][j]==-1&&pr==3)\\n                {\\n                    a[i][j]=0;\\n                }\\n                else\\n                    pr=a[i][j];\\n            }\\n        }\\n         for(int i=0;i<m;i++)\\n        {   int pr=4;\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                if(a[i][j]==1&&pr==3)\\n                {\\n                    a[i][j]=0;\\n                }\\n                else if(a[i][j]==3||a[i][j]==4)\\n                    pr=a[i][j];\\n            }\\n        }\\n          for(int i=0;i<n;i++)\\n        {   int pr=4;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(a[j][i]==1&&pr==3)\\n                {\\n                    a[j][i]=0;\\n                }\\n                else if(a[j][i]==3||a[j][i]==4)\\n                    pr=a[j][i];\\n            }\\n        }\\n          for(int i=0;i<n;i++)\\n        {   int pr=4;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(a[j][i]==1&&pr==3)\\n                {\\n                    a[j][i]=0;\\n                }\\n                else if(a[j][i]==3||a[j][i]==4)\\n                    pr=a[j][i];\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j]==1)\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152858,
                "title": "simple-clear-java-simulation-solution",
                "content": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] map = new int[m][n];\\n        for (int[] g: guards) {\\n            map[g[0]][g[1]] = 2; // means guard\\n        }\\n        \\n        for (int[] w: walls) {\\n            map[w[0]][w[1]] = 3; // means wall\\n        }      \\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (map[i][j] == 2) { // search guard\\n                    dfs(map, i, j, m, n);\\n                }\\n            }\\n        }        \\n        \\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (map[i][j] == 0) // count unprotected\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(int[][] map, int x, int y, int m, int n) {\\n        for (int i = x-1; i >= 0; i--) {  // search up\\n            if (map[i][y] == 2 || map[i][y] == 3) {\\n                break;\\n            }\\n            map[i][y] = 1; // change to protected\\n        }\\n        for (int i = x+1; i < m; i++) { // search down\\n            if (map[i][y] == 2 || map[i][y] == 3) {\\n                break;\\n            }\\n            map[i][y] = 1; // change to protected\\n        }\\n        for (int j = y-1; j >= 0; j--) { // search left\\n            if (map[x][j] == 2 || map[x][j] == 3) {\\n                break;\\n            }\\n            map[x][j] = 1; // change to protected\\n        }\\n        for (int j = y+1; j < n; j++) { // search right\\n            if (map[x][j] == 2 || map[x][j] == 3) {\\n                break;\\n            }\\n            map[x][j] = 1; // change to protected\\n        }       \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] map = new int[m][n];\\n        for (int[] g: guards) {\\n            map[g[0]][g[1]] = 2; // means guard\\n        }\\n        \\n        for (int[] w: walls) {\\n            map[w[0]][w[1]] = 3; // means wall\\n        }      \\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (map[i][j] == 2) { // search guard\\n                    dfs(map, i, j, m, n);\\n                }\\n            }\\n        }        \\n        \\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (map[i][j] == 0) // count unprotected\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    void dfs(int[][] map, int x, int y, int m, int n) {\\n        for (int i = x-1; i >= 0; i--) {  // search up\\n            if (map[i][y] == 2 || map[i][y] == 3) {\\n                break;\\n            }\\n            map[i][y] = 1; // change to protected\\n        }\\n        for (int i = x+1; i < m; i++) { // search down\\n            if (map[i][y] == 2 || map[i][y] == 3) {\\n                break;\\n            }\\n            map[i][y] = 1; // change to protected\\n        }\\n        for (int j = y-1; j >= 0; j--) { // search left\\n            if (map[x][j] == 2 || map[x][j] == 3) {\\n                break;\\n            }\\n            map[x][j] = 1; // change to protected\\n        }\\n        for (int j = y+1; j < n; j++) { // search right\\n            if (map[x][j] == 2 || map[x][j] == 3) {\\n                break;\\n            }\\n            map[x][j] = 1; // change to protected\\n        }       \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1684099,
                "content": [
                    {
                        "username": "PhilipSmith",
                        "content": "This question should probably be marked medium."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) lol"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "They marked it Medium !!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Percentage of Letter in String",
        "question_content": "<p>Given a string <code>s</code> and a character <code>letter</code>, return<em> the <strong>percentage</strong> of characters in </em><code>s</code><em> that equal </em><code>letter</code><em> <strong>rounded down</strong> to the nearest whole percent.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;foobar&quot;, letter = &quot;o&quot;\n<strong>Output:</strong> 33\n<strong>Explanation:</strong>\nThe percentage of characters in s that equal the letter &#39;o&#39; is 2 / 6 * 100% = 33% when rounded down, so we return 33.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;jjjj&quot;, letter = &quot;k&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nThe percentage of characters in s that equal the letter &#39;k&#39; is 0%, so we return 0.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n\t<li><code>letter</code> is a lowercase English letter.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2061845,
                "title": "1-liner",
                "content": "**C++**\\n```cpp\\nint percentageLetter(string s, char letter) {\\n    return 100 * count(begin(s), end(s), letter) / s.size();\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint percentageLetter(string s, char letter) {\\n    return 100 * count(begin(s), end(s), letter) / s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061912,
                "title": "straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {  if(s[i]==letter)\\n            {\\n                count++;\\n            }\\n        }\\n        return (count*100)/s.length();\\n        \\n    }\\n};\\n```\\n**Like it ? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {  if(s[i]==letter)\\n            {\\n                count++;\\n            }\\n        }\\n        return (count*100)/s.length();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061802,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n=s.length();\\n        int count=0;\\n        for(char x: s){\\n            if(x==letter){\\n                count++;\\n            }\\n        }\\n        return count*100/n;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n=s.length();\\n        int count=0;\\n        for(char x: s){\\n            if(x==letter){\\n                count++;\\n            }\\n        }\\n        return count*100/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066611,
                "title": "java-clean-well-commented-explanation",
                "content": "**Approach:**\\n1. Traverse the given String \"s\", and increment the count each time the character is equal to the given \"letter\".\\n2. Find the percentage using standard percentage formula : (given*100)/total.\\n\\n***Kindly upvote if I was able to help you, this motivates me to do more for the community.***\\n\\n***Kindly look for the comments in the code below for explanation.***\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0; //count acts as a counter variabe to count the give character \"letter\" in the string \\n        \\n        //Traverse the string s and each time the character int the string is equal to \"letter\"\\n        //increment the count variable by 1.\\n        for(char ch:s.toCharArray())\\n        {\\n            if(ch==letter)\\n                count++;\\n        }\\n        \\n    //If the count is zero, then the percentage is also zero\\n        if(count==0) \\n            return 0;\\n        \\n        \\n     // to find the total characters in the strings or we can say to find the length of the string   \\n        int total=s.length(); \\n    \\n    // Calculate the total percentage using the standard percentage formula i.e (given*100)/total\\n        int per=(count*100)/total;\\n        return per;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0; //count acts as a counter variabe to count the give character \"letter\" in the string \\n        \\n        //Traverse the string s and each time the character int the string is equal to \"letter\"\\n        //increment the count variable by 1.\\n        for(char ch:s.toCharArray())\\n        {\\n            if(ch==letter)\\n                count++;\\n        }\\n        \\n    //If the count is zero, then the percentage is also zero\\n        if(count==0) \\n            return 0;\\n        \\n        \\n     // to find the total characters in the strings or we can say to find the length of the string   \\n        int total=s.length(); \\n    \\n    // Calculate the total percentage using the standard percentage formula i.e (given*100)/total\\n        int per=(count*100)/total;\\n        return per;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061931,
                "title": "python-one-line-solution-simple-counting",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return (s.count(letter)*100)//len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return (s.count(letter)*100)//len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065067,
                "title": "js-solution-fast-simple-understandable",
                "content": "**Runtime: 67 ms, faster than 85.98% of JavaScript online submissions for Percentage of Letter in String.\\nMemory Usage: 42.2 MB, less than 40.15% of JavaScript online submissions for Percentage of Letter in String.**\\n\\n```\\nvar percentageLetter = function(s, letter) {\\n    let count = 0;\\n    for (let i of s) { // count how many letters are in s\\n        if (i == letter) count++;\\n    }\\n    return (Math.floor((count*1.0) / (s.length*1.0) * 100)) // get percentage\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    let count = 0;\\n    for (let i of s) { // count how many letters are in s\\n        if (i == letter) count++;\\n    }\\n    return (Math.floor((count*1.0) / (s.length*1.0) * 100)) // get percentage\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2063318,
                "title": "3-solutions-intuitive-recursive-1-liner-easy-to-understand-c",
                "content": "**Solution 1: Intuitive approach (Count variable by checking character in the string)**\\n```\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(char ch : s)\\n            if(ch == letter)\\n                 count++;\\n        return count * 100 / s.size();\\n    }\\n```\\n\\n\\n**Solution 2: 1 liner (Using `count()` Function in C++)**\\n```\\n\\tint percentageLetter(string s, char letter) {\\n\\t\\treturn 100 * count(begin(s), end(s), letter) / s.size();\\n\\t}\\n```\\n\\n\\n**Solution 3: Using recursion to count character**\\n    \\n```\\n\\tint countinString(string s, char ch){\\n\\t\\tif (s.length() == 0)\\n\\t\\t      return 0;\\n\\t\\tint count = 0;\\n\\t\\tif (s[0] == ch)\\n\\t\\t\\t  count++;\\n\\t\\tcount += countinString(s.substr(1), ch);\\n\\t\\treturn count;\\n\\t}\\n\\n\\tint percentageLetter(string s, char letter) {\\n\\t\\treturn countinString(s, letter)*100/s.size();\\n\\t}\\n```\\n\\n**If you like it, Please Upvote!!!**",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(char ch : s)\\n            if(ch == letter)\\n                 count++;\\n        return count * 100 / s.size();\\n    }\\n```\n```\\n\\tint percentageLetter(string s, char letter) {\\n\\t\\treturn 100 * count(begin(s), end(s), letter) / s.size();\\n\\t}\\n```\n```\\n\\tint countinString(string s, char ch){\\n\\t\\tif (s.length() == 0)\\n\\t\\t      return 0;\\n\\t\\tint count = 0;\\n\\t\\tif (s[0] == ch)\\n\\t\\t\\t  count++;\\n\\t\\tcount += countinString(s.substr(1), ch);\\n\\t\\treturn count;\\n\\t}\\n\\n\\tint percentageLetter(string s, char letter) {\\n\\t\\treturn countinString(s, letter)*100/s.size();\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3003664,
                "title": "python-simple-one-liner-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return int((s.count(letter) / len(s)) * 100)\\n```\\n\\nLike it ? Please upvote !",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return int((s.count(letter) / len(s)) * 100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001148,
                "title": "java-0ms-100-faster-3-line-code",
                "content": "![percentage.PNG](https://assets.leetcode.com/users/images/642d90c2-bbbe-4cd6-a4f9-ceca41154d01_1672895995.7502918.png)\\n\\n# Code\\n```\\n**please upvote it , if you like it.**  \\n\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for (char i : s.toCharArray()) {\\n            if (i == letter) count++;\\n            else continue;\\n        }\\n        double result = (count / s.length()) * 100;\\n        return (int) result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n**please upvote it , if you like it.**  \\n\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for (char i : s.toCharArray()) {\\n            if (i == letter) count++;\\n            else continue;\\n        }\\n        double result = (count / s.length()) * 100;\\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779886,
                "title": "percentage-of-letter-in-string-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint percentageLetter(char *s, char letter){\\n    int x=strlen(s);\\n    int k=0;\\n    for(int i=0;i<x;i++)\\n     {\\n        if(s[i]==letter)\\n        {\\n            k++;\\n        }\\n       \\n      \\n    }\\n     return (100*k)/x;\\n    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint percentageLetter(char *s, char letter){\\n    int x=strlen(s);\\n    int k=0;\\n    for(int i=0;i<x;i++)\\n     {\\n        if(s[i]==letter)\\n        {\\n            k++;\\n        }\\n       \\n      \\n    }\\n     return (100*k)/x;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061847,
                "title": "c-cakewalk-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == letter) cnt++;\\n        }\\n        int ans = cnt * 100 / n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == letter) cnt++;\\n        }\\n        int ans = cnt * 100 / n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061796,
                "title": "1-liner-solution-java",
                "content": "method - 1\\n\\n```\\nreturn (int)(s.chars().filter(ch -> ch == letter).count()*100 / s.length());\\n```\\nMethod - 2\\n```\\nreturn (int)Arrays.stream(s.split(\"\")).filter(ch -> letter==ch.charAt(0)).count()*100 / s.length();\\n```\\nMethod - 3\\n\\n```\\npublic int percentageLetter(String s, char letter) {\\n     double a = 0;\\n     for(int i=0;i<s.length();i++){\\n         if(s.charAt(i)==letter) a++;\\n     }\\n     return (int)(100*a / s.length());\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nreturn (int)(s.chars().filter(ch -> ch == letter).count()*100 / s.length());\\n```\n```\\nreturn (int)Arrays.stream(s.split(\"\")).filter(ch -> letter==ch.charAt(0)).count()*100 / s.length();\\n```\n```\\npublic int percentageLetter(String s, char letter) {\\n     double a = 0;\\n     for(int i=0;i<s.length();i++){\\n         if(s.charAt(i)==letter) a++;\\n     }\\n     return (int)(100*a / s.length());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613114,
                "title": "single-line-code-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        return count(s.begin(),s.end(),letter)*100/s.length();\\n    }\\n};\\n```\\n**Please upvote if it helps**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        return count(s.begin(),s.end(),letter)*100/s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100099,
                "title": "easy-python-solution",
                "content": "```\\ndef percentageLetter(self, s: str, letter: str) -> int:\\n        return (\"%d\" %(s.count(letter)/len(s)*100))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef percentageLetter(self, s: str, letter: str) -> int:\\n        return (\"%d\" %(s.count(letter)/len(s)*100))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2066856,
                "title": "javascript-1-liner",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nconst percentageLetter = (s, letter) => Math.floor((s.length - s.replaceAll(letter, \\'\\').length) * 100 / s.length);\\n```\\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nconst percentageLetter = (s, letter) => Math.floor((s.length - s.replaceAll(letter, \\'\\').length) * 100 / s.length);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3720564,
                "title": "beats-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == letter){ \\n                count++;\\n            }\\n        }\\n        return (100 * count) / s.length();\\n        // if you like it, please upvote it.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(char c : s.toCharArray()) {\\n            if(c == letter){ \\n                count++;\\n            }\\n        }\\n        return (100 * count) / s.length();\\n        // if you like it, please upvote it.\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228343,
                "title": "6-line-100-faster-c-code",
                "content": "```\\nint percentageLetter(string s, char c) {\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        return (v[c-\\'a\\']*1.0/s.length())*100;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nint percentageLetter(string s, char c) {\\n        vector<int> v(26,0);\\n        for(auto &i: s){\\n            v[i-\\'a\\']++;\\n        }\\n        return (v[c-\\'a\\']*1.0/s.length())*100;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739747,
                "title": "java-easiest-solution-possible",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n     int count = 0;\\n     for(char c : s.toCharArray()) {\\n         if(c == letter)\\n         count ++;\\n     } \\n     return (count * 100) / s.length();  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n     int count = 0;\\n     for(char c : s.toCharArray()) {\\n         if(c == letter)\\n         count ++;\\n     } \\n     return (count * 100) / s.length();  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384120,
                "title": "0ms-java-solution-faster-than-100",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Percentage of Letter in String.\\nMemory Usage: 41.6 MB, less than 72.89% of Java online submissions for Percentage of Letter in String.**\\n\\nJava code:\\n```\\n    public int percentageLetter(String s, char letter) {\\n        var count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter) {\\n                count++;\\n            }\\n        }\\n        return (int) (((double) count / (double) s.length()) * 100);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int percentageLetter(String s, char letter) {\\n        var count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter) {\\n                count++;\\n            }\\n        }\\n        return (int) (((double) count / (double) s.length()) * 100);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067164,
                "title": "java-short-0ms-solution-faster-than-100",
                "content": "```\\npublic int percentageLetter(String s, char letter) {\\n    double count = 0.0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == letter) count++;\\n    }\\n\\n    double percentage = count / s.length();\\n    return (int) (percentage * 100);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int percentageLetter(String s, char letter) {\\n    double count = 0.0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == letter) count++;\\n    }\\n\\n    double percentage = count / s.length();\\n    return (int) (percentage * 100);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061926,
                "title": "easy-math-solution-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        long n = s.length();\\n        long cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == letter)\\n                cnt++;\\n        }\\n        \\n        long x = cnt* 100 / n;\\n        \\n        return (int)x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        long n = s.length();\\n        long cnt = 0;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == letter)\\n                cnt++;\\n        }\\n        \\n        long x = cnt* 100 / n;\\n        \\n        return (int)x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012504,
                "title": "simple-and-easy-code-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String str, char letter) {\\n        int count=0;\\n        int n=str.length();\\n        for(int i=0;i<n;i++){\\n            if(str.charAt(i)==letter){\\n\\n                count ++;\\n            }\\n        }\\n                 int per= (100*count)/n;\\n         return per;   \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String str, char letter) {\\n        int count=0;\\n        int n=str.length();\\n        for(int i=0;i<n;i++){\\n            if(str.charAt(i)==letter){\\n\\n                count ++;\\n            }\\n        }\\n                 int per= (100*count)/n;\\n         return per;   \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779033,
                "title": "one-line-solution-swift",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func percentageLetter(_ s: String, _ letter: Character) -> Int {\\n        s.filter { $0 == letter }.count * 100 / s.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func percentageLetter(_ s: String, _ letter: Character) -> Int {\\n        s.filter { $0 == letter }.count * 100 / s.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105886,
                "title": "3-lines-code-0ms-runtime-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int cnt=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==letter)cnt++;\\n        }\\n        return (cnt*100)/s.length();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int cnt=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==letter)cnt++;\\n        }\\n        return (cnt*100)/s.length();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081906,
                "title": "beats-100-code-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)== letter){\\n                count++;\\n            }\\n        }\\n        return (count *100)/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)== letter){\\n                count++;\\n            }\\n        }\\n        return (count *100)/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735156,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char ch) \\n    {\\n        double count=0;\\n        double length = s.length();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == ch)\\n            {\\n                count++;\\n            }\\n        }\\n        double x =(count / length);\\n        return x*100;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char ch) \\n    {\\n        double count=0;\\n        double length = s.length();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == ch)\\n            {\\n                count++;\\n            }\\n        }\\n        double x =(count / length);\\n        return x*100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211680,
                "title": "go-simple-one-pass-easy-to-understand",
                "content": "```\\nfunc percentageLetter(s string, letter byte) int {\\n    count := 0\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == letter {\\n            count++\\n        }\\n    }\\n    \\n    return int(float64(count)/float64(len(s)) * 100)\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Go"
                ],
                "code": "```\\nfunc percentageLetter(s string, letter byte) int {\\n    count := 0\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == letter {\\n            count++\\n        }\\n    }\\n    \\n    return int(float64(count)/float64(len(s)) * 100)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081824,
                "title": "simple-python-solution",
                "content": "```\\nimport math\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        cnt=s.count(letter)\\n        size=len(s)        \\n        ans=math.floor(cnt/size*100)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        cnt=s.count(letter)\\n        size=len(s)        \\n        ans=math.floor(cnt/size*100)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074076,
                "title": "simple-fast-java-solution-faster-than-100",
                "content": "```\\npublic int percentageLetter(String s, char letter) {\\n    var count = 0;\\n    for (int i = 0; i < s.length(); i++) { // count the occurences of letter in s\\n        if (s.charAt(i)==letter) {\\n            count++;\\n        }\\n    }\\n    return (int) (((double) count/(double) s.length())*100); // return the percentage\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int percentageLetter(String s, char letter) {\\n    var count = 0;\\n    for (int i = 0; i < s.length(); i++) { // count the occurences of letter in s\\n        if (s.charAt(i)==letter) {\\n            count++;\\n        }\\n    }\\n    return (int) (((double) count/(double) s.length())*100); // return the percentage\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065753,
                "title": "python-easy-solution-simple-fast",
                "content": "class Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return (s.count(letter)*100//len(s))",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return (s.count(letter)*100//len(s))",
                "codeTag": "Java"
            },
            {
                "id": 2064857,
                "title": "easy-solution-c-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n\\t//count the occurance of letter in string s.\\n        int val=count(s.begin(),s.end(),letter);\\n\\t//return percentage\\t\\n        return int(val*100/s.length());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n\\t//count the occurance of letter in string s.\\n        int val=count(s.begin(),s.end(),letter);\\n\\t//return percentage\\t\\n        return int(val*100/s.length());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062432,
                "title": "simple-rust-one-line",
                "content": "```rust\\nimpl Solution {\\n    pub fn percentage_letter(s: String, letter: char) -> i32 {\\n        (s.chars().filter(|c| *c == letter).count() * 100 / s.len()) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn percentage_letter(s: String, letter: char) -> i32 {\\n        (s.chars().filter(|c| *c == letter).count() * 100 / s.len()) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062414,
                "title": "two-liner-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar percentageLetter = function (s, letter) {\\n    let letterFilter = s.split(\\'\\').filter(char => char == letter)\\n\\t\\n    return Math.trunc((letterFilter.length/ s.length) * 100)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function (s, letter) {\\n    let letterFilter = s.split(\\'\\').filter(char => char == letter)\\n\\t\\n    return Math.trunc((letterFilter.length/ s.length) * 100)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062287,
                "title": "c-simple-approach-using-map-approach",
                "content": "**Time Complexity :** O(n)\\n**Space Complexity :** O(1)\\n\\n**Simple Approach** -->\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.size(); // length of string\\n        int cnt=0; // count of letter\\n        for(int i=0;i<n;i++){ // loop through string\\n            if(s[i]==letter) cnt++; // if letter found, increment count\\n        }\\n        return float(cnt*100/(float)n); // return percentage\\n    }\\n};\\n```\\n\\n**Map Approach** --> \\n```\\nint percentageLetter(string s, char letter) {\\n        map<char,int> mp; // map to store the count of each letter\\n        for(auto x : s) mp[x]++; // increment the count of each letter\\n        int cnt=0; // count of the letter\\n        if(mp.find(letter)!=mp.end()){  // if the letter is present in the string\\n            cnt=mp[letter]; // store the count of the letter\\n        }\\n        return (cnt*100/s.size()); // return the percentage of the letter\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.size(); // length of string\\n        int cnt=0; // count of letter\\n        for(int i=0;i<n;i++){ // loop through string\\n            if(s[i]==letter) cnt++; // if letter found, increment count\\n        }\\n        return float(cnt*100/(float)n); // return percentage\\n    }\\n};\\n```\n```\\nint percentageLetter(string s, char letter) {\\n        map<char,int> mp; // map to store the count of each letter\\n        for(auto x : s) mp[x]++; // increment the count of each letter\\n        int cnt=0; // count of the letter\\n        if(mp.find(letter)!=mp.end()){  // if the letter is present in the string\\n            cnt=mp[letter]; // store the count of the letter\\n        }\\n        return (cnt*100/s.size()); // return the percentage of the letter\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061960,
                "title": "percentage-of-letter-in-string-java-solution",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count=0,tot=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==letter)\\n               count++;\\n           tot++;\\n        }\\n        return (int)((count/tot)*100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count=0,tot=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           if(s.charAt(i)==letter)\\n               count++;\\n           tot++;\\n        }\\n        return (int)((count/tot)*100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061945,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        int k=0;\\n        for(char c:s.toCharArray())\\n        {\\n            if(l==c)\\n                k++;\\n        }\\n        k=Math.round((k*100)/s.length());\\n        return k;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int percentageLetter(String s, char l) {\\n        int k=0;\\n        for(char c:s.toCharArray())\\n        {\\n            if(l==c)\\n                k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061930,
                "title": "simple-python-solution-easy-to-understand-two-liner-solution-o-n-solution",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        a = s.count(letter)\\n        return (a*100)//len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        a = s.count(letter)\\n        return (a*100)//len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061921,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int a[26]={0},n=s.size();\\n        for(int i=0;i<n;i++)\\n            a[s[i]-\\'a\\']++;\\n        int x=a[letter-\\'a\\'];\\n        x*=100;\\n        x/=n;\\n        return x;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int a[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2061877,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,double> mp ; \\n        for(int i = 0 ; i < s.size(); i ++) {\\n             mp[s[i]] ++ ; \\n        }\\n        double l = s.size(); \\n        if(mp[letter] == 0 ) {\\n            return 0 ; \\n        }\\n        cout << mp[letter] << endl ; \\n         \\n        double p = (mp[letter]/l)*100;\\n        cout << p << endl ;\\n        return int(p) ; \\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,double> mp ; \\n        for(int i = 0 ; i < s.size(); i ++) {\\n             mp[s[i]] ++ ; \\n        }\\n        double l = s.size(); \\n        if(mp[letter] == 0 ) {\\n            return 0 ; \\n        }\\n        cout << mp[letter] << endl ; \\n         \\n        double p = (mp[letter]/l)*100;\\n        cout << p << endl ;\\n        return int(p) ; \\n     }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2061800,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    int percent(int number, int total){\\n        int x = (number*100)/total;\\n        return x;\\n    }\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto itr: s){\\n            if(itr==letter){ count++; }\\n        }\\n        return percent(count, s.size());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int percent(int number, int total){\\n        int x = (number*100)/total;\\n        return x;\\n    }\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto itr: s){\\n            if(itr==letter){ count++; }\\n        }\\n        return percent(count, s.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903351,
                "title": "easy-python-3-solution-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        count=0\\n        start_index=0\\n        l=len(s)\\n        for i in range(l):\\n            j = s.find(letter,start_index)\\n            if(j!=-1):\\n                start_index = j+1\\n                count+=1\\n        per = math.floor((count/l)*100)\\n        return per\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        count=0\\n        start_index=0\\n        l=len(s)\\n        for i in range(l):\\n            j = s.find(letter,start_index)\\n            if(j!=-1):\\n                start_index = j+1\\n                count+=1\\n        per = math.floor((count/l)*100)\\n        return per\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723779,
                "title": "0ms-runtime-java-python-c",
                "content": "# Code\\n```Java []\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n          int n=s.length();\\n          int count=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(s.charAt(i)==letter)\\n              \\n                  count++;\\n              \\n          }\\n          return (100*count)/n;\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        count=0\\n        for i in range(0,len(s)):\\n            if (s[i]==letter): count+=1\\n        return int((100*count)/len(s))\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            if (s[i]==letter) count++;\\n        }\\n        return (100*count)/s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n          int n=s.length();\\n          int count=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(s.charAt(i)==letter)\\n              \\n                  count++;\\n              \\n          }\\n          return (100*count)/n;\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        count=0\\n        for i in range(0,len(s)):\\n            if (s[i]==letter): count+=1\\n        return int((100*count)/len(s))\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            if (s[i]==letter) count++;\\n        }\\n        return (100*count)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723751,
                "title": "easy-0-ms-solution-in-java-c-and-python",
                "content": "```java []\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n          int n=s.length();\\n          int count=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(s.charAt(i)==letter)\\n              \\n                  count++;\\n              \\n          }\\n          return (100*count)/n;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        count=0\\n        for i in range(0,len(s)):\\n            if (s[i]==letter): count+=1\\n        return int((100*count)/len(s))\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            if (s[i]==letter) count++;\\n        }\\n        return (100*count)/s.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n          int n=s.length();\\n          int count=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(s.charAt(i)==letter)\\n              \\n                  count++;\\n              \\n          }\\n          return (100*count)/n;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        count=0\\n        for i in range(0,len(s)):\\n            if (s[i]==letter): count+=1\\n        return int((100*count)/len(s))\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++)\\n        {\\n            if (s[i]==letter) count++;\\n        }\\n        return (100*count)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704737,
                "title": "percentage-of-letter-in-string-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        return (int)(count * 100) / s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        return (int)(count * 100) / s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566667,
                "title": "percentage-of-letter-in-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c = count(s.begin(), s.end(), letter);\\n        return c*100/s.length();\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4c281000-7517-4dc6-a994-2a93c65e65e1_1685162324.053199.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c = count(s.begin(), s.end(), letter);\\n        return c*100/s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493888,
                "title": "easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        add it to the frequency map\\n\\n# Complexity\\n- Time complexity: O(s.length())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(s.length())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        HashMap<Character, Integer> map= new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(map.containsKey(c)) map.put(c, map.get(c)+1);\\n                else map.put(c,1);\\n        }\\n\\n        int percentage= (map.getOrDefault(letter,0)*100/ s.length());\\n\\n        return  percentage;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        HashMap<Character, Integer> map= new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(map.containsKey(c)) map.put(c, map.get(c)+1);\\n                else map.put(c,1);\\n        }\\n\\n        int percentage= (map.getOrDefault(letter,0)*100/ s.length());\\n\\n        return  percentage;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444622,
                "title": "most-difficult-ans-to-most-difficult-question",
                "content": "- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == letter) {\\n            \\tcount++;\\n            }\\n        }  \\n        return (count*100)/s.length();\\n    }\\n}\\n`****Kindly upvote if you like the ans****``",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == letter) {\\n            \\tcount++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3350166,
                "title": "simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int a = s.length();\\n        int count =0;\\n        for(int i =0; i<a; i++){\\n            if(s.charAt(i) == letter) count++;\\n        }\\n        //System.out.println(count);\\n        int b = (count*100)/a;\\n        return b;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int a = s.length();\\n        int count =0;\\n        for(int i =0; i<a; i++){\\n            if(s.charAt(i) == letter) count++;\\n        }\\n        //System.out.println(count);\\n        int b = (count*100)/a;\\n        return b;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241054,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        \\n    int count = 0;\\n    for (int i = 0; i < s.size(); i++)\\n        if (s[i] == letter)\\n            count++;\\n    return ((count * 100) / s.size()); \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        \\n    int count = 0;\\n    for (int i = 0; i < s.size(); i++)\\n        if (s[i] == letter)\\n            count++;\\n    return ((count * 100) / s.size()); \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218465,
                "title": "percentage-of-letter-in-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![percentageofstring.PNG](https://assets.leetcode.com/users/images/4fe252f9-a351-40a7-b646-bee2ce2d3469_1677075653.892181.png)\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        return round(math.floor((s.count(letter)/len(s))*100))     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        return round(math.floor((s.count(letter)/len(s))*100))     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201712,
                "title": "python-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        l=len(s)\\n        count=0\\n        for i in s:\\n            if i==letter:\\n                count+=1\\n            else:\\n                pass\\n        return int((count/l)*100)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        l=len(s)\\n        count=0\\n        for i in s:\\n            if i==letter:\\n                count+=1\\n            else:\\n                pass\\n        return int((count/l)*100)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181416,
                "title": "simple-easy-c-code-beats-100-in-runtime",
                "content": "Runtime : Beats 100% \\u270C\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        float c=0;\\n        float a=s.size();\\n        for(int i=0;i<a;i++){\\n            if(s[i]==letter){\\n                c++;\\n            }\\n        }\\n            float x=(c*100)/a;\\n            return x;\\n    }\\n};\\n```\\n\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        float c=0;\\n        float a=s.size();\\n        for(int i=0;i<a;i++){\\n            if(s[i]==letter){\\n                c++;\\n            }\\n        }\\n            float x=(c*100)/a;\\n            return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140654,
                "title": "java-solution-beats-100-simple-and-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int x = 0;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s.charAt(i)==letter)x++;\\n        }\\n        \\n        return x*100/s.length();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int x = 0;\\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s.charAt(i)==letter)x++;\\n        }\\n        \\n        return x*100/s.length();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054106,
                "title": "java-0-ms-beats-100-percent-easy-undersatnding-strings",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1);\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int cnt=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter) cnt++;\\n        }\\n        return Math.round((cnt*100)/s.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int cnt=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter) cnt++;\\n        }\\n        return Math.round((cnt*100)/s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053529,
                "title": "easy-c-solution-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        int l=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter)\\n            c++;\\n        }\\n        int ans = (c *100)/l;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        int l=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter)\\n            c++;\\n        }\\n        int ans = (c *100)/l;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045807,
                "title": "3-lines-approach-please-upvote-if-you-like-the-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]==letter) c++;\\n        return (c*100)/s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]==letter) c++;\\n        return (c*100)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043666,
                "title": "percentage-of-letter-in-string-easy-java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- convert string in array and put all element of string s in array ch.\\n- use for loop and check every elemt of array ch that it is matching with letter or not. If it match with letter then count will be increased by 1. \\n\\n        if(chr[i] == letter){\\n            count++;\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int ans;\\n        int count = 0;\\n        int numOfString = s.length();\\n        char[] chr = new char[numOfString];\\n        for(int i=0; i<chr.length; i++){\\n            chr[i] = s.charAt(i);\\n        }\\n        for(int i=0; i<chr.length; i++){\\n            if(chr[i] == letter){\\n                count++;\\n            }\\n        }\\n        ans = (count*100)/numOfString;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int ans;\\n        int count = 0;\\n        int numOfString = s.length();\\n        char[] chr = new char[numOfString];\\n        for(int i=0; i<chr.length; i++){\\n            chr[i] = s.charAt(i);\\n        }\\n        for(int i=0; i<chr.length; i++){\\n            if(chr[i] == letter){\\n                count++;\\n            }\\n        }\\n        ans = (count*100)/numOfString;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997896,
                "title": "simple-approach-by-using-percentage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == letter){\\n                count++;\\n            }\\n        }\\n        int ans = ((count*100)/s.length()); \\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == letter){\\n                count++;\\n            }\\n        }\\n        int ans = ((count*100)/s.length()); \\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950436,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int> mp;\\n        for(auto &i:s) mp[i]++;\\n        int ans = 0;\\n        for(auto i:mp) if(i.first==letter) ans=((double)i.second/(double)s.length())*100;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int> mp;\\n        for(auto &i:s) mp[i]++;\\n        int ans = 0;\\n        for(auto i:mp) if(i.first==letter) ans=((double)i.second/(double)s.length())*100;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792400,
                "title": "only-4-5-lines-of-code-and-gives-0-ms-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst count how many times letter is present in s string then simply find persentage\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply searching then find persentage\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n41.8 MB\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0 MS\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        // for find count\\n        int count = 0;\\n            for(int j=0; j<s.length(); j++){\\n                if(s.charAt(j) == letter){\\n                    count++;\\n                }\\n            }\\n        // print persentage\\n        return (count * 100) / s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        // for find count\\n        int count = 0;\\n            for(int j=0; j<s.length(); j++){\\n                if(s.charAt(j) == letter){\\n                    count++;\\n                }\\n            }\\n        // print persentage\\n        return (count * 100) / s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760945,
                "title": "percentage-of-letter-in-string",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)== letter){\\n                count++;\\n            }\\n        }\\n        return (count*100)/s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)== letter){\\n                count++;\\n            }\\n        }\\n        return (count*100)/s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710506,
                "title": "python-o-n-runtime-50-ms-beats-56-36-memory-13-9-mb-beats-10-66",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        for i in s:\\n            if i==letter:\\n                c+=1\\n        n=len(s)\\n        return int(c/n*100)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        for i in s:\\n            if i==letter:\\n                c+=1\\n        n=len(s)\\n        return int(c/n*100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699469,
                "title": "100-faster-c-solution",
                "content": "```\\nclass Solution {\\n   public:\\n    int percentageLetter(string s, char letter) {\\n        int len = s.length();\\n        float count = 0;\\n        for (int i = 0; i < len; i++)\\n            if (s[i] == letter) count++;\\n        return (double(count) / len ) * 100;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int percentageLetter(string s, char letter) {\\n        int len = s.length();\\n        float count = 0;\\n        for (int i = 0; i < len; i++)\\n            if (s[i] == letter) count++;\\n        return (double(count) / len ) * 100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647725,
                "title": "100-better-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char ch) \\n    {\\n        double count=0;\\n        double length = s.length();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == ch)\\n            {\\n                count++;\\n            }\\n        }\\n        double x =(count / length);\\n        return x*100;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char ch) \\n    {\\n        double count=0;\\n        double length = s.length();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i] == ch)\\n            {\\n                count++;\\n            }\\n        }\\n        double x =(count / length);\\n        return x*100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619988,
                "title": "c-easy-solution-0ms-faster-than-100",
                "content": "**Please upvote if this helps :)**\\n\\nclass Solution {\\npublic:\\n\\n    int percentageLetter(string s, char letter) {\\n        double count=0;\\n        float n=s.size();\\n        sort(s.begin(),s.end());\\n        int i=0;\\n        while(i<n){\\n            if(s[i]==letter){\\n                count++;  \\n            }\\n            i++;\\n        } \\n        return count/n*100;     \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int percentageLetter(string s, char letter) {\\n        double count=0;\\n        float n=s.size();\\n        sort(s.begin(),s.end());\\n        int i=0;\\n        while(i<n){\\n            if(s[i]==letter){\\n                count++;  \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2489349,
                "title": "java-solution-0ms-ru-time-100-faster-easy-to-understa-d",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String word, char tar) {\\n        int c = 0;\\n        for (char i : word.toCharArray()) {\\n            if (i == tar) c++;\\n        }\\n        return (int)(c * 100.0) / word.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String word, char tar) {\\n        int c = 0;\\n        for (char i : word.toCharArray()) {\\n            if (i == tar) c++;\\n        }\\n        return (int)(c * 100.0) / word.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439354,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==letter)\\n            {\\n                c++;\\n            }\\n        }\\n        c = ((c*100)/s.length());\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==letter)\\n            {\\n                c++;\\n            }\\n        }\\n        c = ((c*100)/s.length());\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428414,
                "title": "c-easy-understandable-small-solution-0ms-100",
                "content": "```\\nint percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto i : s) if(i == letter) count++;\\n        double c = ((count * 0.1)/(s.size() * 0.1)) * 100;\\n        return int(c);\\n\\t\\t}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto i : s) if(i == letter) count++;\\n        double c = ((count * 0.1)/(s.size() * 0.1)) * 100;\\n        return int(c);\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426928,
                "title": "easy-cpp-soln",
                "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0; i<n; i++){\\n            if(s[i]==letter){\\n                count++;\\n            }\\n        }\\n        int ans=(count*100)/n;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0; i<n; i++){\\n            if(s[i]==letter){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2332965,
                "title": "python3-o-n-o-n-runtime-45ms-55-96-memory-13-9mb-10-12",
                "content": "```\\nfrom collections import Counter as c\\n# O(n) || O(n)\\n# Runtime: 45ms 55.96% || Memory: 13.9mb 10.12%\\nclass Solution:\\n    def percentageLetter(self, string: str, letter: str) -> int:\\n        stringFreq = c(string)\\n        if not letter in stringFreq: return 0\\n        letterFreq = stringFreq[letter]\\n        stringSize = len(string)\\n        \\n        return letterFreq * 100 // stringSize\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as c\\n# O(n) || O(n)\\n# Runtime: 45ms 55.96% || Memory: 13.9mb 10.12%\\nclass Solution:\\n    def percentageLetter(self, string: str, letter: str) -> int:\\n        stringFreq = c(string)\\n        if not letter in stringFreq: return 0\\n        letterFreq = stringFreq[letter]\\n        stringSize = len(string)\\n        \\n        return letterFreq * 100 // stringSize\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308655,
                "title": "simple-2-line-solution-in-cpp-please-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        double c = count(s.begin() , s.end() , letter);\\n        return c/s.size()*100;\\n    }\\n};\\n```\\nPlease upvote \\nhttps://github.com/Reehan9/Leetcode-Solutions",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        double c = count(s.begin() , s.end() , letter);\\n        return c/s.size()*100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287025,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\n\\nvar percentageLetter = function(s, letter) {\\n    let count=0;\\n    \\n    if(!s.includes(letter))  return 0;\\n    \\n    for(let l of s){\\n        if(l==letter)   count +=1;\\n    }\\n    \\n    let percent=eval(count / s.length)*100;\\n    let result = Math.floor(percent);\\n    return result;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar percentageLetter = function(s, letter) {\\n    let count=0;\\n    \\n    if(!s.includes(letter))  return 0;\\n    \\n    for(let l of s){\\n        if(l==letter)   count +=1;\\n    }\\n    \\n    let percent=eval(count / s.length)*100;\\n    let result = Math.floor(percent);\\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195486,
                "title": "javascript-solution-with-indexof",
                "content": "```\\nvar percentageLetter = function(s, letter) {\\n    \\n    let pos = s.indexOf(letter);\\n    let count = 0;\\n    \\n    while(pos != -1) {\\n        count++;\\n        pos = s.indexOf(letter, pos+1);\\n    }\\n    \\n    if(count != 0) {\\n        return Math.floor((count/s.length)*100);\\n    } \\n\\t\\n    return 0;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    \\n    let pos = s.indexOf(letter);\\n    let count = 0;\\n    \\n    while(pos != -1) {\\n        count++;\\n        pos = s.indexOf(letter, pos+1);\\n    }\\n    \\n    if(count != 0) {\\n        return Math.floor((count/s.length)*100);\\n    } \\n\\t\\n    return 0;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2175333,
                "title": "simple-javascript-solution-using-for-loop",
                "content": "\\n```\\nvar percentageLetter = function(s, letter) {\\n    let count = 0;\\n    for(let i=0; i<s.length; i++){\\n        if(s.charAt(i) === letter) count++;\\n    }\\n    \\n    return Math.floor((count*100)/ s.length);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    let count = 0;\\n    for(let i=0; i<s.length; i++){\\n        if(s.charAt(i) === letter) count++;\\n    }\\n    \\n    return Math.floor((count*100)/ s.length);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171522,
                "title": "java-very-easy-solution",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==letter)\\n            {\\n                count++;\\n            }\\n        }\\n        int ans=(count*100)/n;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==letter)\\n            {\\n                count++;\\n            }\\n        }\\n        int ans=(count*100)/n;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094816,
                "title": "simple-python-solution",
                "content": "```python\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        counter = collections.Counter(s)\\n        return 100 * counter.get(letter, 0) // counter.total()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        counter = collections.Counter(s)\\n        return 100 * counter.get(letter, 0) // counter.total()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082890,
                "title": "simple-and-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n       for(auto i=0;i<s.size();++i){\\n           if(s[i]==letter){\\n               count++;\\n           }\\n       }\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n       for(auto i=0;i<s.size();++i){\\n           if(s[i]==letter){\\n               count++;\\n           }\\n       }\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077360,
                "title": "one-liner",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n         return (int) s.chars().filter(ch -> ch == letter).count() * 100 / s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n         return (int) s.chars().filter(ch -> ch == letter).count() * 100 / s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076805,
                "title": "one-liner-solution-in-python",
                "content": "```\\nimport math\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return math.floor(s.count(letter)/len(s)*100)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return math.floor(s.count(letter)/len(s)*100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076107,
                "title": "faster-than-100-c-submission-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int> map;\\n        for (auto x:s){\\n            map[x]++;\\n        }\\n        return (map[letter]*100/s.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int> map;\\n        for (auto x:s){\\n            map[x]++;\\n        }\\n        return (map[letter]*100/s.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074565,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==l)\\n                c++;\\n        }\\n        return c*100/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==l)\\n                c++;\\n        }\\n        return c*100/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074082,
                "title": "javascript-faster-than-96-06-with-comments",
                "content": "```\\nvar percentageLetter = function(s, letter) {\\n    let includedCount = 0;\\n    if (!letter.includes(s)) return 0; // check if letter does not include s at all\\n    for (let l of s) {\\n        if (l == letter) includedCount+=1; // check if \\'l\\' is the same as letter if so, add 1 to \\'includedCount\\'\\n    }\\n    let result = eval(includedCount / s.length * 100).toString() // evaluate an equation and stringify the result\\n    if (result.includes(\".\")) result = parseInt(result.split(\".\")[0]) // remove the decimal\\n    return result;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/2a1a8d35-3675-42f7-9853-610ae04d3315_1653521913.7664704.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    let includedCount = 0;\\n    if (!letter.includes(s)) return 0; // check if letter does not include s at all\\n    for (let l of s) {\\n        if (l == letter) includedCount+=1; // check if \\'l\\' is the same as letter if so, add 1 to \\'includedCount\\'\\n    }\\n    let result = eval(includedCount / s.length * 100).toString() // evaluate an equation and stringify the result\\n    if (result.includes(\".\")) result = parseInt(result.split(\".\")[0]) // remove the decimal\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071427,
                "title": "0-ms-100-faster-c-very-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint percentageLetter(string s, char letter) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfor(auto i:s){\\n\\t\\t\\t\\tif(i==letter)\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t}\\n\\t\\t\\treturn c*100/n;   \\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint percentageLetter(string s, char letter) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfor(auto i:s){\\n\\t\\t\\t\\tif(i==letter)\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2065181,
                "title": "go-golang-solution",
                "content": "```go\\nfunc percentageLetter(s string, letter byte) int {\\n    n, c := len(s), 0\\n    for i := 0; i < n; i++ { if s[i] == letter { c++ } }\\n    ans := float64(c) / float64(n)\\n    return int(ans * 100)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc percentageLetter(s string, letter byte) int {\\n    n, c := len(s), 0\\n    for i := 0; i < n; i++ { if s[i] == letter { c++ } }\\n    ans := float64(c) / float64(n)\\n    return int(ans * 100)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065089,
                "title": "javascript-easy-solution-simple-fast",
                "content": "1. **get the count of how many times letter is included in s**\\n1. **evaluate a formula using the function, \\'eval()\\'**\\n1. **check if result is an decimal, if so, get the whole number**\\n```\\nvar percentageLetter = function(s, letter) {\\n    let includedCount = 0;\\n    if (!letter.includes(s)) return 0;\\n    for (let l of s) {\\n        if (l == letter) includedCount+=1;\\n    }\\n    let result = eval(includedCount / s.length * 100).toString()\\n    if (result.includes(\".\")) result = parseInt(result.split(\".\")[0])\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar percentageLetter = function(s, letter) {\\n    let includedCount = 0;\\n    if (!letter.includes(s)) return 0;\\n    for (let l of s) {\\n        if (l == letter) includedCount+=1;\\n    }\\n    let result = eval(includedCount / s.length * 100).toString()\\n    if (result.includes(\".\")) result = parseInt(result.split(\".\")[0])\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064166,
                "title": "easy-math-solution-in-python",
                "content": "...\\n\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        y=len(s)\\n        for i in s:\\n            if i==letter:\\n                c+=1       \\n        return int((c/y)*100)\\n\\t\\t\\n\\t\\t...",
                "solutionTags": [
                    "Python"
                ],
                "code": "...\\n\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        y=len(s)\\n        for i in s:\\n            if i==letter:\\n                c+=1       \\n        return int((c/y)*100)\\n\\t\\t\\n\\t\\t...",
                "codeTag": "Java"
            },
            {
                "id": 2063877,
                "title": "java-easy-solution-o-n",
                "content": "**1)** *First count the frequency of letter in string*\\n**2)** *Then calculate percentage*\\n**Time:** O(n)\\n**Space:** O(1)\\n```\\npublic int percentageLetter(String s, char letter) {\\n        int ans = 0;\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count += 1;\\n            }\\n        }\\n        ans = (count * 100)/ s.length();\\n        return  ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int percentageLetter(String s, char letter) {\\n        int ans = 0;\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count += 1;\\n            }\\n        }\\n        ans = (count * 100)/ s.length();\\n        return  ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2063504,
                "title": "are-you-serious-is-this-a-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int l = s.length(), c=0;\\n        for(auto& i : s){\\n            if(i==letter) c++;\\n        }\\n        return 100*c/l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int l = s.length(), c=0;\\n        for(auto& i : s){\\n            if(i==letter) c++;\\n        }\\n        return 100*c/l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063138,
                "title": "c-beginner-friendly-faster-than-100",
                "content": "please upvote if you like it\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n       for(int i=0;i<s.length();i++){\\n          if(s[i]==letter){\\n              count++;\\n          }\\n       }\\n        return (count*100)/s.length();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n       for(int i=0;i<s.length();i++){\\n          if(s[i]==letter){\\n              count++;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2063117,
                "title": "c-0ms-runtime-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n        for(auto x:s){\\n            if (x==letter) count++;\\n        }\\n         int res=((count*100)/s.length());\\n        return res;\\n    }\\n};\\n```\\npls upvote if u like\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int count=0;\\n        for(auto x:s){\\n            if (x==letter) count++;\\n        }\\n         int res=((count*100)/s.length());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062998,
                "title": "easy-c-solution",
                "content": "\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto x:s){\\n            if(x == letter)count++;\\n        }\\n        return (100*count)/s.length();\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(auto x:s){\\n            if(x == letter)count++;\\n        }\\n        return (100*count)/s.length();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2062950,
                "title": "c-linq-one-line",
                "content": "```\\npublic int PercentageLetter(string s, char letter) \\n\\t=> s.Count(c => c == letter) * 100 / s.Length;\\n```",
                "solutionTags": [],
                "code": "```\\npublic int PercentageLetter(string s, char letter) \\n\\t=> s.Count(c => c == letter) * 100 / s.Length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062939,
                "title": "python3-three-solutions",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return math.floor((s.count(letter)/len(s)*100))\\n```\\n\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if letter== s[i]:\\n                c+=1\\n        return math.floor(c/len(s)*100)\\n```\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n\\t\\treturn ((s.count(letter)*100)//len(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return math.floor((s.count(letter)/len(s)*100))\\n```\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if letter== s[i]:\\n                c+=1\\n        return math.floor(c/len(s)*100)\\n```\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n\\t\\treturn ((s.count(letter)*100)//len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062821,
                "title": "c-easy-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n    int percentageLetter(string s, char letter) {\\n        int d=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==letter){\\n                d++;\\n            }\\n        }\\n        float l=(d*100)/n;\\n        //cout<<l<<endl;\\n        return l;\\n       }\\n    };",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n    public:\\n    int percentageLetter(string s, char letter) {\\n        int d=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==letter){\\n                d++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2062678,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string str, char letter) {\\n        \\n        int n = str.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == letter)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return (count * 100) / n; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string str, char letter) {\\n        \\n        int n = str.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == letter)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return (count * 100) / n; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062495,
                "title": "100-faster-o-n-simple-formula-based",
                "content": "### Simple Percentage Calculator:\\n\\nI multiplied the count with 100 in advance because otherwise when we do count / length of string it gives an answer in 0.x which gets converted to 0.\\n\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c = 0;\\n        int n = s.length();\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i) == letter)\\n                c++;\\n        }\\n        int ans = 100 * c / n;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c = 0;\\n        int n = s.length();\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i) == letter)\\n                c++;\\n        }\\n        int ans = 100 * c / n;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2062338,
                "title": "simple-approach",
                "content": "```\\nint percentageLetter(string s, char letter) {\\n        int n=s.size(),c=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(s[i]==letter) c++;\\n    }\\n        return (100*c)/n;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint percentageLetter(string s, char letter) {\\n        int n=s.size(),c=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(s[i]==letter) c++;\\n    }\\n        return (100*c)/n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2062280,
                "title": "ruby-one-line-solution",
                "content": "```\\n# @param {String} s\\n# @param {Character} letter\\n# @return {Integer}\\ndef percentage_letter(s, letter)\\n    s.count(letter) * 100 / s.length\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @param {Character} letter\\n# @return {Integer}\\ndef percentage_letter(s, letter)\\n    s.count(letter) * 100 / s.length\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2062094,
                "title": "cpp-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int cnt=0,n=s.length();\\n        for( char c:s)cnt+=c==letter;\\n        return cnt*100/(n*1.0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int cnt=0,n=s.length();\\n        for( char c:s)cnt+=c==letter;\\n        return cnt*100/(n*1.0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061989,
                "title": "simple-o-n-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char l) \\n    {\\n        int n=s.size();\\n        unordered_map<char,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n         m[s[i]]++;//counting the frequency\\n        }\\n        double p=((1.0*m[l])/n);//frequency/total number of characters\\n        int t=p*1ll*100;\\n        return t;\\n    }\\n};\\n\\'\\'\\'\\nTime Complexity->O(N)\\nSpace Complexity->O(N)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) \\n    {\\n        int n=s.size();\\n        unordered_map<char,int>m;\\n        for(int i=0;i<n;i++)\\n        {\\n         m[s[i]]++;//counting the frequency\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061984,
                "title": "c-easy-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(auto ch:s) if(ch==letter) count++;\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(auto ch:s) if(ch==letter) count++;\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061954,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        \\n        leng = len(s)\\n        ctr = 0\\n        for char in s:\\n            if char == letter:\\n                ctr += 1\\n                \\n        return math.floor((ctr / leng) * 100)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        if letter not in s:\\n            return 0\\n        \\n        leng = len(s)\\n        ctr = 0\\n        for char in s:\\n            if char == letter:\\n                ctr += 1\\n                \\n        return math.floor((ctr / leng) * 100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061915,
                "title": "java-ac-solution",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int len = s.length();\\n        int freq = 0;\\n        for(int i = 0;i<len;i++){\\n            char a = s.charAt(i);\\n            if(a == letter)\\n                freq++;\\n        }\\n        int ans = (freq * 100)/len;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int len = s.length();\\n        int freq = 0;\\n        for(int i = 0;i<len;i++){\\n            char a = s.charAt(i);\\n            if(a == letter)\\n                freq++;\\n        }\\n        int ans = (freq * 100)/len;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061914,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        cnt = 0\\n        for char in s:\\n            if char == letter:\\n                cnt += 1\\n        res = math.floor((cnt / len(s)) * 100)\\n        return res\\n```\\n\\t\\t\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        cnt = 0\\n        for char in s:\\n            if char == letter:\\n                cnt += 1\\n        res = math.floor((cnt / len(s)) * 100)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061879,
                "title": "o-n",
                "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int>m;\\n        int n=s.size(),c;\\n        for(int i=0;i<n;++i){\\n            m[s[i]]++;\\n        }\\n        \\n        for(auto i:m){\\n            if(i.first==letter){\\n                c=i.second;\\n                break;\\n            }else{\\n                c=0;\\n            }\\n        }\\n      \\n        \\n        cout<<c<<\" \"<<n<<endl;\\n        \\n        return (c*100)/n;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        map<char,int>m;\\n        int n=s.size(),c;\\n        for(int i=0;i<n;++i){\\n            m[s[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2061858,
                "title": "c-easy-solution-floor",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.length();\\n        map<char,int>m;\\n        for(auto x : s)\\n        {\\n            m[x]++;\\n        }\\n        int percentage;\\n        int count = 0;\\n        if(m.find(letter)!=m.end())\\n            count = m[letter];\\n        percentage = floor(((count*1.0)/n)*100);\\n        return percentage;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.length();\\n        map<char,int>m;\\n        for(auto x : s)\\n        {\\n            m[x]++;\\n        }\\n        int percentage;\\n        int count = 0;\\n        if(m.find(letter)!=m.end())\\n            count = m[letter];\\n        percentage = floor(((count*1.0)/n)*100);\\n        return percentage;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061848,
                "title": "most-easy-approach-simple-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        unordered_map<char,int>mpp;\\n        int per=0;\\n           \\n        for(int i=0;i<s.size();i++)\\n        {\\n           mpp[s[i]]++;\\n        }\\n        for(auto it:mpp)\\n        {\\n             int count=0;\\n            if(letter==it.first)\\n            {\\n                count=it.second;\\n                  per=floor(((count*1.0)/s.size())*100);\\n            }\\n            \\n           \\n        }\\n       return per;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        unordered_map<char,int>mpp;\\n        int per=0;\\n           \\n        for(int i=0;i<s.size();i++)\\n        {\\n           mpp[s[i]]++;\\n        }\\n        for(auto it:mpp)\\n        {\\n             int count=0;\\n            if(letter==it.first)\\n            {\\n                count=it.second;\\n                  per=floor(((count*1.0)/s.size())*100);\\n            }\\n            \\n           \\n        }\\n       return per;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061825,
                "title": "java-easy-solution-o-n-approach",
                "content": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int len=s.length();\\n        int cnt=0;\\n        for(int i=0;i<len;i++){\\n            if(s.charAt(i)==letter) cnt++;\\n        }\\n        \\n        int per=(cnt*100/len);\\n        return per;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int len=s.length();\\n        int cnt=0;\\n        for(int i=0;i<len;i++){\\n            if(s.charAt(i)==letter) cnt++;\\n        }\\n        \\n        int per=(cnt*100/len);\\n        return per;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095373,
                "title": "make-java-easy-and-simple-0ms-beats-97-18",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter)\\n                count++;\\n        }\\n        return (count)*100/s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter)\\n                count++;\\n        }\\n        return (count)*100/s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084196,
                "title": "percentage-of-letter-in-string",
                "content": "# Approach\\nI made this wayyyy more complicated than it needed to be. \\n\\nFind the number of times the letter occurs in the string by splitting the string into an array and then filtering the array for the letter. \\n\\nReturn this value as a percentage by dividing it by string length * 100. \\n\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\n\\nvar percentageLetter = function(s, letter) {\\n    const value = s.split(\\'\\').filter((x) => x === letter).length;\\n    return Math.floor((value / s.length) * 100)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Approach\\nI made this wayyyy more complicated than it needed to be. \\n\\nFind the number of times the letter occurs in the string by splitting the string into an array and then filtering the array for the letter. \\n\\nReturn this value as a percentage by dividing it by string length * 100. \\n\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\n\\nvar percentageLetter = function(s, letter) {\\n    const value = s.split(\\'\\').filter((x) => x === letter).length;\\n    return Math.floor((value / s.length) * 100)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079432,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        return 100 * (int) s.chars().filter(c -> c == letter).count() / s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        return 100 * (int) s.chars().filter(c -> c == letter).count() / s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079151,
                "title": "direct-approach-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PercentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i =0;i<s.Length;i++){\\n            if(s[i]==letter){\\n                count++;\\n            }\\n        }\\n        Console.WriteLine(count);\\n        int ans = (count*100/s.Length);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int PercentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i =0;i<s.Length;i++){\\n            if(s[i]==letter){\\n                count++;\\n            }\\n        }\\n        Console.WriteLine(count);\\n        int ans = (count*100/s.Length);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078505,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return s.count(letter)*100//len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return s.count(letter)*100//len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077641,
                "title": "beats-100-in-run-time-and-95-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        char [] array = s.toCharArray();\\n        double frequency=0;\\n        for(int i=0;i<array.length;i++){\\n            if(array[i]==letter){\\n                frequency++;\\n            }\\n        }\\n        return (int)((frequency/(double)array.length)*100);\\n    }\\n}\\n```\\n\\n![Screenshot 2023-09-22 at 7.24.53\\u202FPM.png](https://assets.leetcode.com/users/images/9aa7b34c-fd10-4fe9-8eea-125309d60980_1695403773.6144347.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        char [] array = s.toCharArray();\\n        double frequency=0;\\n        for(int i=0;i<array.length;i++){\\n            if(array[i]==letter){\\n                frequency++;\\n            }\\n        }\\n        return (int)((frequency/(double)array.length)*100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077064,
                "title": "you-know-how-to-solve-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==letter){\\n                c++;\\n            }\\n        }\\n        return (100*c)/s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==letter){\\n                c++;\\n            }\\n        }\\n        return (100*c)/s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076168,
                "title": "simple-java-solution-100-beats-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        // variable to count number of \\'letter\\' in the string.\\n        int count =0;\\n        // Itearate through the string.\\n        for(char c: s.toCharArray()){\\n            // if character match with the \\'letter\\' then increse the count.\\n            if(c == letter) count++;\\n        }\\n        // return the result multiply 100 with count then devide by the length of the string.\\n        return (count*100/s.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        // variable to count number of \\'letter\\' in the string.\\n        int count =0;\\n        // Itearate through the string.\\n        for(char c: s.toCharArray()){\\n            // if character match with the \\'letter\\' then increse the count.\\n            if(c == letter) count++;\\n        }\\n        // return the result multiply 100 with count then devide by the length of the string.\\n        return (count*100/s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072357,
                "title": "very-easy-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n    \\n    let count = 0;\\n    let n = s.length;\\n\\n    for(let i of s){\\n        if(letter === i){\\n            count++\\n        }\\n    }\\n\\n   let percentage = Math.floor((count / n ) * 100);\\n\\n   return percentage\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n    \\n    let count = 0;\\n    let n = s.length;\\n\\n    for(let i of s){\\n        if(letter === i){\\n            count++\\n        }\\n    }\\n\\n   let percentage = Math.floor((count / n ) * 100);\\n\\n   return percentage\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071001,
                "title": "1-line-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int PercentageLetter(string s, char letter)\\n    {\\n        return s.Count(c => c == letter) * 100 / s.Length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int PercentageLetter(string s, char letter)\\n    {\\n        return s.Count(c => c == letter) * 100 / s.Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069713,
                "title": "beats-100-of-solutions-beginner-friendly-using-hashmaps",
                "content": "\\n# Complexity\\n- Time complexity: 0(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n\\n        int n=s.size();\\n        int target= letter;\\n        int perc;\\n        \\n        int H[26]={0};\\n\\n        for(int i=0; i<n ; i++){\\n\\n            H[s[i]-97]+=1;\\n        }\\n\\n        perc=(H[target-97]*100)/n;\\n\\n        return perc;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n\\n        int n=s.size();\\n        int target= letter;\\n        int perc;\\n        \\n        int H[26]={0};\\n\\n        for(int i=0; i<n ; i++){\\n\\n            H[s[i]-97]+=1;\\n        }\\n\\n        perc=(H[target-97]*100)/n;\\n\\n        return perc;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068583,
                "title": "beats-100-very-easy-java-salution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == letter)\\n            count++;\\n        }\\n        return 100*count/n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            char ch = s.charAt(i);\\n            if(ch == letter)\\n            count++;\\n        }\\n        return 100*count/n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049145,
                "title": "one-line-easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n    return Math.floor(s.split(\\'\\').reduce((acc, v) => acc += v == letter ? 1 : 0, 0) * 100 / s.length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n    return Math.floor(s.split(\\'\\').reduce((acc, v) => acc += v == letter ? 1 : 0, 0) * 100 / s.length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048001,
                "title": "fast-java-solution-runtime-beginners-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        double n = (double) count / s.length();\\n        return (int) (n * 100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        double n = (double) count / s.length();\\n        return (int) (n * 100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039087,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n          if(s[i]==letter)\\n          {\\n            count++;\\n          }\\n        }\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n          if(s[i]==letter)\\n          {\\n            count++;\\n          }\\n        }\\n        return (count*100)/s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038599,
                "title": "2278-percentage-of-letter-in-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c = 0;\\n        int n = s.length(); \\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i); \\n            if (ch == letter) {\\n                c++;\\n            }\\n        }\\n\\n        if (c == 0) {\\n            return 0;\\n        } else {\\n            return (c * 100) / n;\\n        } \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c = 0;\\n        int n = s.length(); \\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i); \\n            if (ch == letter) {\\n                c++;\\n            }\\n        }\\n\\n        if (c == 0) {\\n            return 0;\\n        } else {\\n            return (c * 100) / n;\\n        } \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033643,
                "title": "python-1-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return int(s.count(letter)/len(s)*100)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        return int(s.count(letter)/len(s)*100)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027498,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int x = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter){\\n                x++; \\n                \\n            }\\n        }\\n        x = x*100;\\n        int n = s.length();\\n        int y = x/n;\\n        return y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int x = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter){\\n                x++; \\n                \\n            }\\n        }\\n        x = x*100;\\n        int n = s.length();\\n        int y = x/n;\\n        return y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022348,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        s= list(s)\\n        return math.floor((s.count(letter)/len(s)) * 100)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        s= list(s)\\n        return math.floor((s.count(letter)/len(s)) * 100)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021773,
                "title": "easiest-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {int a=0;int per=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter)a++;\\n           int b=s.length();\\n            per=(a*100)/b;\\n\\n        }\\n       // return(a/b)*100;\\n       return per;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {int a=0;int per=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter)a++;\\n           int b=s.length();\\n            per=(a*100)/b;\\n\\n        }\\n       // return(a/b)*100;\\n       return per;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018958,
                "title": "hashmap-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        Map<Character,Integer>fmap=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n                char a=s.charAt(i);\\n                if(fmap.containsKey(a)){\\n                    int f=fmap.get(a);\\n                    fmap.put(a,f+1);\\n                }\\n                else{\\n                    fmap.put(a,1);\\n                }\\n        }\\n        int v=0;\\n        \\n        if(fmap.containsKey(l)){\\n            v=fmap.get(l);\\n        }\\n        \\n        int ans=v*100/s.length();\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        Map<Character,Integer>fmap=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n                char a=s.charAt(i);\\n                if(fmap.containsKey(a)){\\n                    int f=fmap.get(a);\\n                    fmap.put(a,f+1);\\n                }\\n                else{\\n                    fmap.put(a,1);\\n                }\\n        }\\n        int v=0;\\n        \\n        if(fmap.containsKey(l)){\\n            v=fmap.get(l);\\n        }\\n        \\n        int ans=v*100/s.length();\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013820,
                "title": "best-100-in-time-0ms-beats-98-70-in-space",
                "content": "# Approach The formula is given in the description proceed step by step\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        int len = s.length();\\n        for(char ch:s.toCharArray()){\\n            if(ch == letter) count++;\\n        }\\n        double output = count/len*100;\\n        return (int)output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        double count = 0;\\n        int len = s.length();\\n        for(char ch:s.toCharArray()){\\n            if(ch == letter) count++;\\n        }\\n        double output = count/len*100;\\n        return (int)output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012547,
                "title": "simple-java-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String str, char letter) {\\n        Scanner scan=new Scanner(System.in);\\n        //String str=scan.next();\\n        int n=str.length();\\n        int count=0;\\n        for(int i=0;i<n;i++ ){\\n            if(str.charAt(i)==letter)\\n            count ++;\\n        }\\n        int per=(count*100)/n;\\n        \\n        return per;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String str, char letter) {\\n        Scanner scan=new Scanner(System.in);\\n        //String str=scan.next();\\n        int n=str.length();\\n        int count=0;\\n        for(int i=0;i<n;i++ ){\\n            if(str.charAt(i)==letter)\\n            count ++;\\n        }\\n        int per=(count*100)/n;\\n        \\n        return per;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010136,
                "title": "easy-code-string-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        int total = s.length();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == letter) {\\n                count++;\\n            }\\n        }\\n        \\n        // Calculate the percentage and round it down to the nearest whole percent\\n        int percentage = (count * 100) / total;\\n        \\n        return percentage;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        int total = s.length();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == letter) {\\n                count++;\\n            }\\n        }\\n        \\n        // Calculate the percentage and round it down to the nearest whole percent\\n        int percentage = (count * 100) / total;\\n        \\n        return percentage;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010129,
                "title": "1ms-easy-code-string",
                "content": "# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        int total = s.length();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == letter) {\\n                count++;\\n            }\\n        }\\n        \\n        // Calculate the percentage and round it down to the nearest whole percent\\n        int percentage = (count * 100) / total;\\n        \\n        return percentage;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        int total = s.length();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if (ch == letter) {\\n                count++;\\n            }\\n        }\\n        \\n        // Calculate the percentage and round it down to the nearest whole percent\\n        int percentage = (count * 100) / total;\\n        \\n        return percentage;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001187,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++){\\n            if (s[i]==letter){\\n                count++;\\n            }\\n        }\\n        int n= double(count*100/s.size());\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        for (int i=0; i<s.size(); i++){\\n            if (s[i]==letter){\\n                count++;\\n            }\\n        }\\n        int n= double(count*100/s.size());\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001018,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == letter) count++;\\n        }\\n        double res = floor(((count * 100.0) / n)); // Convert count to a double\\n\\n        return static_cast<int>(res);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int n = s.length();\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == letter) count++;\\n        }\\n        double res = floor(((count * 100.0) / n)); // Convert count to a double\\n\\n        return static_cast<int>(res);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998064,
                "title": "using-javascript-beats-91-of-the-people-shortest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n     let count = 0;\\n  let strLen = s.length;\\n  for (let i = 0; i < strLen; i++) {\\n    if (s[i] === letter) {\\n      count += 1;\\n    }\\n  }\\n  let percentage = Math.floor((count / strLen) * 100);\\n  return percentage;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} letter\\n * @return {number}\\n */\\nvar percentageLetter = function(s, letter) {\\n     let count = 0;\\n  let strLen = s.length;\\n  for (let i = 0; i < strLen; i++) {\\n    if (s[i] === letter) {\\n      count += 1;\\n    }\\n  }\\n  let percentage = Math.floor((count / strLen) * 100);\\n  return percentage;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994272,
                "title": "c-sharp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PercentageLetter(string s, char letter) {\\n        int letterCount = 0;\\n        foreach (char c in s) {\\n            if (c == letter) {\\n                letterCount++;\\n            }\\n        }\\n        int percentage = (letterCount * 100) / s.Length;\\n        return percentage;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PercentageLetter(string s, char letter) {\\n        int letterCount = 0;\\n        foreach (char c in s) {\\n            if (c == letter) {\\n                letterCount++;\\n            }\\n        }\\n        int percentage = (letterCount * 100) / s.Length;\\n        return percentage;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994192,
                "title": "easy-java-solution-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter)\\n                c++;\\n        }\\n        if(c>0)\\n            return c*100/s.length();\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter)\\n                c++;\\n        }\\n        if(c>0)\\n            return c*100/s.length();\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992744,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        ArrayList<Character> arr=new ArrayList<Character>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter){\\n            arr.add(s.charAt(i));\\n            }\\n        }\\n\\n            int res=(arr.size()*100)/s.length();\\n            return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        ArrayList<Character> arr=new ArrayList<Character>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==letter){\\n            arr.add(s.charAt(i));\\n            }\\n        }\\n\\n            int res=(arr.size()*100)/s.length();\\n            return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974465,
                "title": "easy-cpp-solution-beats-100-in-runtime-naive-approach",
                "content": "![image.png](https://assets.leetcode.com/users/images/74448e58-f0dc-4e51-9a6a-08702222e981_1693284530.2475433.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        double cnt = 0;\\n\\n        for(auto i : s)\\n            if(i == letter) cnt++;\\n\\n        return int((cnt/double(s.length())) * 100);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        double cnt = 0;\\n\\n        for(auto i : s)\\n            if(i == letter) cnt++;\\n\\n        return int((cnt/double(s.length())) * 100);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973430,
                "title": "using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n       int n=s.length();\\n       char arr[]=s.toCharArray();\\n       HashMap<Character,Integer> map=new HashMap<>();\\n       for(char x:arr){\\n           map.put(x,map.getOrDefault(x,0)+1);\\n       } \\n       int per=0;\\n       char ch=letter;\\n       for(char x:arr){\\n           if(map.containsKey(ch)){\\n               int t=map.get(ch);\\n               per=(t*100)/n;\\n           }\\n       }\\n       return per;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n       int n=s.length();\\n       char arr[]=s.toCharArray();\\n       HashMap<Character,Integer> map=new HashMap<>();\\n       for(char x:arr){\\n           map.put(x,map.getOrDefault(x,0)+1);\\n       } \\n       int per=0;\\n       char ch=letter;\\n       for(char x:arr){\\n           if(map.containsKey(ch)){\\n               int t=map.get(ch);\\n               per=(t*100)/n;\\n           }\\n       }\\n       return per;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965994,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        int c=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.charAt(i)==l){\\n                c++;\\n            }\\n        }\\n        return (c*100/n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char l) {\\n        int c=0;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.charAt(i)==l){\\n                c++;\\n            }\\n        }\\n        return (c*100/n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944482,
                "title": "best-code-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++) if(s.charAt(i) == letter) count++;\\n        return (count*100/s.length());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count=0;\\n        for(int i=0;i<s.length();i++) if(s.charAt(i) == letter) count++;\\n        return (count*100/s.length());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941765,
                "title": "easiest-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        \"\"\"\\n        :type s: str\\n        :type letter: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == letter:\\n                count += 1\\n        return int((float(count)/float(len(s))) * 100)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        \"\"\"\\n        :type s: str\\n        :type letter: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == letter:\\n                count += 1\\n        return int((float(count)/float(len(s))) * 100)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924042,
                "title": "percentage-of-a-letter-in-string-simple-easy-and-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly Take a count variable cnt initilize with zero\\ntake one loop apply on question string that is \"S\" in these case\\nand check each character with second string if it found than increse the count value by 1\\nthe multiply the count with 100 and divide by total length of string \"S\"\\nand return the percentage\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntime compelexity is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int cnt =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            if(letter==s.charAt(i))\\n            {\\n                cnt++;\\n            }\\n        }\\n        int per = (cnt*100)/s.length();\\n        return per;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int cnt =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            if(letter==s.charAt(i))\\n            {\\n                cnt++;\\n            }\\n        }\\n        int per = (cnt*100)/s.length();\\n        return per;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916800,
                "title": "100-in-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        return (count(begin(s),end(s),letter)*100)/s.size();\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        return (count(begin(s),end(s),letter)*100)/s.size();\\n         \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3916505,
                "title": "c-100-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint percentageLetter(string s, char letter) {\\n\\n\\t\\tint count = 0;\\n\\n\\t\\tint inputSize = s.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif(s[i] == letter){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (count * 100) / inputSize;\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint percentageLetter(string s, char letter) {\\n\\n\\t\\tint count = 0;\\n\\n\\t\\tint inputSize = s.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif(s[i] == letter){\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (count * 100) / inputSize;\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914762,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        return (int)((double)count / s.length() * 100);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int percentageLetter(String s, char letter) {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == letter){\\n                count++;\\n            }\\n        }\\n        return (int)((double)count / s.length() * 100);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913301,
                "title": "the-best-in-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n  int percentageLetter(String s, String letter) {\\n   int count = 0;\\n  for (int i = 0; i < s.length; i++) {\\n    if (s[i] == letter) {\\n      count++;\\n    }\\n  }\\n   return ((count/s.length)*100).floor();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int percentageLetter(String s, String letter) {\\n   int count = 0;\\n  for (int i = 0; i < s.length; i++) {\\n    if (s[i] == letter) {\\n      count++;\\n    }\\n  }\\n   return ((count/s.length)*100).floor();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909510,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int L=s.length();\\n       int p=0 ;\\n       for (char c : s){\\n           if (c==letter) \\n                p++;\\n       } \\n        \\n         return (static_cast<double> (p) / L ) * 100;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n       int L=s.length();\\n       int p=0 ;\\n       for (char c : s){\\n           if (c==letter) \\n                p++;\\n       } \\n        \\n         return (static_cast<double> (p) / L ) * 100;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1776020,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1741882,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1738078,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2014941,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1968474,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849560,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1841024,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1799266,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1756245,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1732835,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1776020,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1741882,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1738078,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2014941,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1968474,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1849560,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1841024,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1799266,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1756245,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1732835,
                "content": [
                    {
                        "username": "cjatherton19",
                        "content": "i wish every interview questions was like this "
                    },
                    {
                        "username": "Saad03",
                        "content": "When I run my code in jupyter notebook, I get correct ans whereas here I get error..can anyone tell me what the problem is?\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        sLen=len(s)\\n        nLetter=s.count(letter)\\n        ans=(nLetter/sLen)*100\\n        return int(ans)\\n\\nwhen s=\"foobar\" and letter=\"o\"....I\\'m getting 0 insted of 33"
                    },
                    {
                        "username": "viking09_",
                        "content": "Use float for calculation and after convert the answer back to int and then return the answer"
                    },
                    {
                        "username": "Saad03",
                        "content": "[@papitochi](/papitochi) yeah its workin now.. I wonder why it didn\\'t work with the above code....anyways thanks :)\\n"
                    },
                    {
                        "username": "papitochi",
                        "content": "figured it out, try nletter*100/sLen"
                    },
                    {
                        "username": "papitochi",
                        "content": "same\\n"
                    },
                    {
                        "username": "fool_100",
                        "content": "return the percentage of characters in s that equal letter **rounded down to the nearest whole percent**\\nI was using round() but it simply wants us to return previous integer !! \\nDescription is not correct !!!!!! "
                    },
                    {
                        "username": "nikhil-niks",
                        "content": "When I run the below code in Leetcode I am getting output as 0 whereas when I run this on my local I am getting output 33.Can someone help me where is the issue ?\\n\\nclass Solution(object):\\n    def percentageLetter(self, s, letter):\\n        totalLen = len(s)\\n        wordCount = 0\\n        for i in s:\\n            if i == letter:\\n                wordCount += 1\\n        return (int(wordCount)/int(totalLen))*100"
                    },
                    {
                        "username": "pranav_kumar_16",
                        "content": "(wordCount/totalLen) will give you 0  , so 0 * 100 results in 0. Instead use  (wordCount*100)/totalLen ."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "`double ans = (static_cast<double>(count) / N) * 100;`\n `return static_cast<int>(ans);`\nEXPLAIN???"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\n((double) s.chars().filter(c -> c == letter).count()/s.length())*100"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "c++:\\n\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count=0;\\n        int n=s.size();\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==letter) count++;\\n        }\\n        count*=100;\\n        \\n        return count/n;\\n    }\\n};"
                    },
                    {
                        "username": "anshumaan_1024",
                        "content": "\"cccaaa\" is not a valid value of type character\\nwhat does this mean ?"
                    },
                    {
                        "username": "Kartik_Bhasin",
                        "content": "wrong test case"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int percentageLetter(string s, char l) {\\n        int count=0;\\n        int z=s.size();\\n        for(int i=0;i<z;i++){\\n            if(s[i]==l){\\n                count++;\\n            }\\n        }\\n        count=count*100;\\n        return count/z;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Products With Three or More Orders in Two Consecutive Years",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1998198,
                "content": [
                    {
                        "username": "xjn6505",
                        "content": "This question actually asks you to identify products that have at least 3 orders per year for two consecutive years, rather than products that have at least a total of 3 orders for two consecutive years! Hope this saves your time on debugging. \\nIn short:\\ncnt >=3 and cnt>=3\\ninstead of:\\ncnt+cnt >=3\\n"
                    },
                    {
                        "username": "hjiangyeahp",
                        "content": "thanks, it helps! I encounter the same issue with you!"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "when I run it, it was accepted.  when I submit, it was wrong. why?\\n\\nselect distinct( A.product_id )\\nfrom Orders A\\nleft join Orders B\\non A.product_id=B.product_id \\nand B.purchase_date <date_add(A.purchase_date, interval 1 year)\\nhaving count(A.order_id)>=3"
                    },
                    {
                        "username": "gabrielosluz",
                        "content": "Same here. Code: with prod as (\\n    select product_id, count(product_id) as cnt from Orders t1\\n    WHERE EXISTS (\\n            SELECT 1 FROM Orders t2 WHERE product_id = t1.product_id \\n            AND YEAR(purchase_date) = YEAR(t1.purchase_date) + 1\\n            )\\n    group by product_id\\n)\\nselect product_id from prod where cnt >= 3"
                    }
                ]
            },
            {
                "id": 1798645,
                "content": [
                    {
                        "username": "xjn6505",
                        "content": "This question actually asks you to identify products that have at least 3 orders per year for two consecutive years, rather than products that have at least a total of 3 orders for two consecutive years! Hope this saves your time on debugging. \\nIn short:\\ncnt >=3 and cnt>=3\\ninstead of:\\ncnt+cnt >=3\\n"
                    },
                    {
                        "username": "hjiangyeahp",
                        "content": "thanks, it helps! I encounter the same issue with you!"
                    },
                    {
                        "username": "Yi-LingT",
                        "content": "when I run it, it was accepted.  when I submit, it was wrong. why?\\n\\nselect distinct( A.product_id )\\nfrom Orders A\\nleft join Orders B\\non A.product_id=B.product_id \\nand B.purchase_date <date_add(A.purchase_date, interval 1 year)\\nhaving count(A.order_id)>=3"
                    },
                    {
                        "username": "gabrielosluz",
                        "content": "Same here. Code: with prod as (\\n    select product_id, count(product_id) as cnt from Orders t1\\n    WHERE EXISTS (\\n            SELECT 1 FROM Orders t2 WHERE product_id = t1.product_id \\n            AND YEAR(purchase_date) = YEAR(t1.purchase_date) + 1\\n            )\\n    group by product_id\\n)\\nselect product_id from prod where cnt >= 3"
                    }
                ]
            }
        ]
    },
    {
        "title": "Calculate Amount Paid in Taxes",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>brackets</code> where <code>brackets[i] = [upper<sub>i</sub>, percent<sub>i</sub>]</code> means that the <code>i<sup>th</sup></code> tax bracket has an upper bound of <code>upper<sub>i</sub></code> and is taxed at a rate of <code>percent<sub>i</sub></code>. The brackets are <strong>sorted</strong> by upper bound (i.e. <code>upper<sub>i-1</sub> &lt; upper<sub>i</sub></code> for <code>0 &lt; i &lt; brackets.length</code>).</p>\n\n<p>Tax is calculated as follows:</p>\n\n<ul>\n\t<li>The first <code>upper<sub>0</sub></code> dollars earned are taxed at a rate of <code>percent<sub>0</sub></code>.</li>\n\t<li>The next <code>upper<sub>1</sub> - upper<sub>0</sub></code> dollars earned are taxed at a rate of <code>percent<sub>1</sub></code>.</li>\n\t<li>The next <code>upper<sub>2</sub> - upper<sub>1</sub></code> dollars earned are taxed at a rate of <code>percent<sub>2</sub></code>.</li>\n\t<li>And so on.</li>\n</ul>\n\n<p>You are given an integer <code>income</code> representing the amount of money you earned. Return <em>the amount of money that you have to pay in taxes.</em> Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> brackets = [[3,50],[7,10],[12,25]], income = 10\n<strong>Output:</strong> 2.65000\n<strong>Explanation:</strong>\nBased on your income, you have 3 dollars in the 1<sup>st</sup> tax bracket, 4 dollars in the 2<sup>nd</sup> tax bracket, and 3 dollars in the 3<sup>rd</sup> tax bracket.\nThe tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.\nIn total, you pay $3 * 50% + $4 * 10% + $3 * 25% = $2.65 in taxes.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> brackets = [[1,0],[4,25],[5,50]], income = 2\n<strong>Output:</strong> 0.25000\n<strong>Explanation:</strong>\nBased on your income, you have 1 dollar in the 1<sup>st</sup> tax bracket and 1 dollar in the 2<sup>nd</sup> tax bracket.\nThe tax rate for the two tax brackets is 0% and 25%, respectively.\nIn total, you pay $1 * 0% + $1 * 25% = $0.25 in taxes.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> brackets = [[2,50]], income = 0\n<strong>Output:</strong> 0.00000\n<strong>Explanation:</strong>\nYou have no income to tax, so you have to pay a total of $0 in taxes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= brackets.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= upper<sub>i</sub> &lt;= 1000</code></li>\n\t<li><code>0 &lt;= percent<sub>i</sub> &lt;= 100</code></li>\n\t<li><code>0 &lt;= income &lt;= 1000</code></li>\n\t<li><code>upper<sub>i</sub></code> is sorted in ascending order.</li>\n\t<li>All the values of <code>upper<sub>i</sub></code> are <strong>unique</strong>.</li>\n\t<li>The upper bound of the last tax bracket is greater than or equal to <code>income</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2141006,
                "title": "java-python-3-simple-o-n-codes",
                "content": "```java\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        int prev = 0;\\n        for (int[] bracket : brackets) {\\n            int upper = bracket[0], percent = bracket[1];\\n            if (income >= upper) {\\n                tax += (upper - prev) * percent / 100d;\\n                prev = upper;\\n            }else {\\n                tax += (income - prev) * percent / 100d;\\n                return tax;\\n            } \\n        }\\n        return tax;\\n    }\\n```\\n```python\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = prev = 0\\n        for upper, p in brackets:\\n            if income >= upper:\\n                tax += (upper - prev) * p / 100\\n                prev = upper\\n            else:\\n                tax += (income - prev) * p / 100\\n                return tax\\n        return tax    \\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        int prev = 0;\\n        for (int[] bracket : brackets) {\\n            int upper = bracket[0], percent = bracket[1];\\n            if (income >= upper) {\\n                tax += (upper - prev) * percent / 100d;\\n                prev = upper;\\n            }else {\\n                tax += (income - prev) * percent / 100d;\\n                return tax;\\n            } \\n        }\\n        return tax;\\n    }\\n```\n```python\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = prev = 0\\n        for upper, p in brackets:\\n            if income >= upper:\\n                tax += (upper - prev) * p / 100\\n                prev = upper\\n            else:\\n                tax += (income - prev) * p / 100\\n                return tax\\n        return tax    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2141128,
                "title": "no-title",
                "content": "**C++**\\n```cpp\\ndouble calculateTax(vector<vector<int>>& b, int income) {\\n    double res = 0, prev = 0;\\n    for (int i = 0; i < b.size(); prev = b[i++][0])\\n        res += max(0.0, (-prev + min(income, b[i][0])) * b[i][1] / 100);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\ndouble calculateTax(vector<vector<int>>& b, int income) {\\n    double res = 0, prev = 0;\\n    for (int i = 0; i < b.size(); prev = b[i++][0])\\n        res += max(0.0, (-prev + min(income, b[i][0])) * b[i][1] / 100);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141187,
                "title": "python3-bracket-by-bracket",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e59b5d5832483707a595ae92b9aa1fb456986009) for solutions of weekly 297\\n\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        ans = prev = 0 \\n        for hi, pct in brackets: \\n            hi = min(hi, income)\\n            ans += (hi - prev)*pct/100\\n            prev = hi \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        ans = prev = 0 \\n        for hi, pct in brackets: \\n            hi = min(hi, income)\\n            ans += (hi - prev)*pct/100\\n            prev = hi \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140963,
                "title": "c-calculate-amount-paid-in-taxes-math-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;  \\n        if(income==0){\\n            return ans;\\n        }\\n        int prev=0; \\n        for(int i=0;i<brackets.size();i++){\\n            int actual=min(brackets[i][0],income);\\n            ans+=((actual-prev)*brackets[i][1]*1.0)/100.0;\\n            if(brackets[i][0]>=income){\\n                break;\\n            }\\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;  \\n        if(income==0){\\n            return ans;\\n        }\\n        int prev=0; \\n        for(int i=0;i<brackets.size();i++){\\n            int actual=min(brackets[i][0],income);\\n            ans+=((actual-prev)*brackets[i][1]*1.0)/100.0;\\n            if(brackets[i][0]>=income){\\n                break;\\n            }\\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141274,
                "title": "c-2-approches-efficient-solution",
                "content": "**Please upvote if it helps :)**\\n**Approach-1:**\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) \\n    {    \\n        double tax = 0; \\n        \\n        if(brackets[0][0]<=income) tax=(brackets[0][0]*brackets[0][1]/100.0);         \\n        else return (income*brackets[0][1]/100.0);\\n            \\n        for(int i=1; i<brackets.size(); i++)\\n        {\\n            if(brackets[i][0]<=income)\\n                    tax += ((brackets[i][0]-brackets[i-1][0])*brackets[i][1]/100.0);\\n            \\n            else \\n            {\\n                tax += ((income-brackets[i-1][0])*brackets[i][1]/100.0);\\n                break;\\n            }\\n        }\\n        return tax;\\n        \\n    }\\n};\\n```\\n\\n**Approach-2**\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) \\n    {   \\n        if(income==0) return 0.0;\\n        \\n        double ans=0;\\n        int prev=0; \\n        \\n        for(int i=0;i<brackets.size();i++)\\n        {\\n            int curr=min(brackets[i][0],income);\\n            \\n            ans += ((curr-prev)*brackets[i][1]/100.0);\\n            \\n            if(brackets[i][0]>=income) break;\\n            \\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) \\n    {    \\n        double tax = 0; \\n        \\n        if(brackets[0][0]<=income) tax=(brackets[0][0]*brackets[0][1]/100.0);         \\n        else return (income*brackets[0][1]/100.0);\\n            \\n        for(int i=1; i<brackets.size(); i++)\\n        {\\n            if(brackets[i][0]<=income)\\n                    tax += ((brackets[i][0]-brackets[i-1][0])*brackets[i][1]/100.0);\\n            \\n            else \\n            {\\n                tax += ((income-brackets[i-1][0])*brackets[i][1]/100.0);\\n                break;\\n            }\\n        }\\n        return tax;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) \\n    {   \\n        if(income==0) return 0.0;\\n        \\n        double ans=0;\\n        int prev=0; \\n        \\n        for(int i=0;i<brackets.size();i++)\\n        {\\n            int curr=min(brackets[i][0],income);\\n            \\n            ans += ((curr-prev)*brackets[i][1]/100.0);\\n            \\n            if(brackets[i][0]>=income) break;\\n            \\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144078,
                "title": "c-efficient-solution-simple-logic",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) \\n    {\\n        // if income is nothing then tax will be 0\\n        if(income == 0) \\n            return 0.0;\\n        \\n        double ans = 0;\\n        int prev = 0;                    // for storing the previous earning\\n        \\n        for(auto x : brackets)\\n        {\\n            // take the min earning first for calculating tax charge on that\\n            int curr = min(x[0],income);\\n            \\n            // add charges in total amout\\n            ans += ((curr-prev)*x[1]/100.0);\\n            \\n            // if money exceed the income break and return tax amout\\n            if(x[0] >= income) break;\\n            \\n            // storing current money in previous\\n            prev = x[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) \\n    {\\n        // if income is nothing then tax will be 0\\n        if(income == 0) \\n            return 0.0;\\n        \\n        double ans = 0;\\n        int prev = 0;                    // for storing the previous earning\\n        \\n        for(auto x : brackets)\\n        {\\n            // take the min earning first for calculating tax charge on that\\n            int curr = min(x[0],income);\\n            \\n            // add charges in total amout\\n            ans += ((curr-prev)*x[1]/100.0);\\n            \\n            // if money exceed the income break and return tax amout\\n            if(x[0] >= income) break;\\n            \\n            // storing current money in previous\\n            prev = x[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140975,
                "title": "python-easy-understanding",
                "content": "![image](https://assets.leetcode.com/users/images/408d9653-ecf2-4ffa-bb9a-f138cbcf7d75_1655006473.2794168.jpeg)\\n\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        taxtot=0\\n        if(brackets[0][0]<income):\\n            taxtot+=brackets[0][0]*(brackets[0][1])\\n            income-=brackets[0][0]\\n        else:\\n            taxtot+=income*(brackets[0][1])\\n            return taxtot/100\\n        i=1\\n        while(income>0 and i<len(brackets)):\\n            if(income>(brackets[i][0]-brackets[i-1][0])):\\n                taxtot+=(brackets[i][0]-brackets[i-1][0])*brackets[i][1]\\n                income-=brackets[i][0]-brackets[i-1][0]\\n            else:\\n                taxtot+=income*brackets[i][1]\\n                income=0\\n            i+=1\\n        return taxtot/100\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        taxtot=0\\n        if(brackets[0][0]<income):\\n            taxtot+=brackets[0][0]*(brackets[0][1])\\n            income-=brackets[0][0]\\n        else:\\n            taxtot+=income*(brackets[0][1])\\n            return taxtot/100\\n        i=1\\n        while(income>0 and i<len(brackets)):\\n            if(income>(brackets[i][0]-brackets[i-1][0])):\\n                taxtot+=(brackets[i][0]-brackets[i-1][0])*brackets[i][1]\\n                income-=brackets[i][0]-brackets[i-1][0]\\n            else:\\n                taxtot+=income*brackets[i][1]\\n                income=0\\n            i+=1\\n        return taxtot/100\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855909,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSaving prevIncome.\\nIf diff between the prevIncome and the current upper limit is greater than income then add the value to result which is multiple of income cause income is lesser make income zero cause we have no income left.\\n\\nelse do the same thing just add value with diff multiple update income by reducing diff\\nNow update prevIncome to new income of this index;\\nif(income is zero) return result;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n            O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n            O(1)\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prevIncome = 0;\\n        double res = 0;\\n        for(int i =0; i<brackets.length; i++){\\n            double diff = brackets[i][0] - prevIncome;\\n            if(diff > income){\\n                res += (income*brackets[i][1]/100.0);\\n                income = 0;\\n            }else{\\n                res += (diff*brackets[i][1])/100;\\n                income -= diff;\\n            }\\n            prevIncome = brackets[i][0];\\n            if(income == 0) return res;\\n            //System.out.println(prevIncome+\" \"+res+ \" \"+ income +\" \"+ diff + \"  \"+(diff*brackets[i][1]/100));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prevIncome = 0;\\n        double res = 0;\\n        for(int i =0; i<brackets.length; i++){\\n            double diff = brackets[i][0] - prevIncome;\\n            if(diff > income){\\n                res += (income*brackets[i][1]/100.0);\\n                income = 0;\\n            }else{\\n                res += (diff*brackets[i][1])/100;\\n                income -= diff;\\n            }\\n            prevIncome = brackets[i][0];\\n            if(income == 0) return res;\\n            //System.out.println(prevIncome+\" \"+res+ \" \"+ income +\" \"+ diff + \"  \"+(diff*brackets[i][1]/100));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245974,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n      \\n     \\n      int i =0;\\n        \\n        int previous_income =0;\\n        double tax =0;\\n        \\n        while(i< brackets.length)\\n        {\\n            int cur_income = Math.min(brackets[i][0],income)- previous_income;\\n            tax += (cur_income * brackets[i][1])/100.0d;\\n            \\n            previous_income = brackets[i][0];\\n            \\n            if(brackets[i][0]>= income)break;\\n            i++;\\n        }\\n        return tax;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n      \\n     \\n      int i =0;\\n        \\n        int previous_income =0;\\n        double tax =0;\\n        \\n        while(i< brackets.length)\\n        {\\n            int cur_income = Math.min(brackets[i][0],income)- previous_income;\\n            tax += (cur_income * brackets[i][1])/100.0d;\\n            \\n            previous_income = brackets[i][0];\\n            \\n            if(brackets[i][0]>= income)break;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2194059,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        totaltax = prevbracket = 0\\n        for upper, percent in brackets:\\n            if income >= upper:\\n                totaltax += (upper - prevbracket)*percent/100\\n                prevbracket = upper\\n            else: \\n                totaltax += (income - prevbracket)*p/100\\n                return totaltax\\n        return totaltax\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        totaltax = prevbracket = 0\\n        for upper, percent in brackets:\\n            if income >= upper:\\n                totaltax += (upper - prevbracket)*percent/100\\n                prevbracket = upper\\n            else: \\n                totaltax += (income - prevbracket)*p/100\\n                return totaltax\\n        return totaltax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162053,
                "title": "javascript-beats-95-82",
                "content": "```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nconst calculateTax = (brackets, income) => {\\n    let paid = 0;\\n    let prev = 0;\\n    \\n    for (const [amt, percent] of brackets) {\\n        const current = Math.min(income, amt - prev);\\n        const tax = current * (percent / 100);\\n        \\n        income -= current;\\n        paid += tax;\\n        prev = amt;\\n        \\n        if (income <= 0) return paid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nconst calculateTax = (brackets, income) => {\\n    let paid = 0;\\n    let prev = 0;\\n    \\n    for (const [amt, percent] of brackets) {\\n        const current = Math.min(income, amt - prev);\\n        const tax = current * (percent / 100);\\n        \\n        income -= current;\\n        paid += tax;\\n        prev = amt;\\n        \\n        if (income <= 0) return paid;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2146218,
                "title": "c-java-simple-code-o-n",
                "content": "class Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& b, int inc) {\\n        \\n        //if income is 0, u won\\'t pay anything\\n        if(inc == 0)\\n            return 0.0;\\n        double ans = 0;\\n        \\n        //if income is less than first element price, then return (income-0)rate of tax\\n        if(inc<b[0][0])\\n             {  \\n                ans += (b[0][1]== 0)?0:((double)inc*(b[0][1]))/100.0;\\n                return ans;\\n             }\\n        else \\n            ans += (b[0][1]== 0)?0:((double)b[0][0]*(b[0][1]))/100.0;\\n        //first price has done, repeat the same process for remaining elements..\\n        for(int i = 1;i<b.size();i++){\\n            \\n            if(b[i][0]<inc){\\n                ans += (b[i][1]==0)?0:((double)(b[i][0]-b[i-1][0]))*b[i][1]/100.0; \\n            }\\n            else\\n            { \\n                ans += (b[i][1]==0)?0:((double)(inc-b[i-1][0])*(b[i][1]))/100.0;\\n                    break;\\n               }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//JAVA code\\n class Solution {\\n    public double calculateTax(int[][] b, int inc) {\\n       \\n        double ans = 0.0;\\n        if(inc<b[0][0])\\n            return (double)(inc*b[0][1])/100.0;\\n        else\\n            ans += (b[0][1] == 0)?0.0:(double)(b[0][0]*b[0][1])/100.0;\\n        \\n        for(int i = 1;i<b.length;i++){\\n            \\n            if(inc>b[i][0])\\n                ans+= (b[i][1] == 0)?0.0:(double)(b[i][0]-b[i-1][0])*b[i][1]/100.0;\\n            else\\n            {\\n                ans += (b[i][1] == 0)?0.0:(double)(inc-b[i-1][0])*b[i][1]/100.0;\\n                    break;\\n                }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& b, int inc) {\\n        \\n        //if income is 0, u won\\'t pay anything\\n        if(inc == 0)\\n            return 0.0;\\n        double ans = 0;\\n        \\n        //if income is less than first element price, then return (income-0)rate of tax\\n        if(inc<b[0][0])\\n             {  \\n                ans += (b[0][1]== 0)?0:((double)inc*(b[0][1]))/100.0;\\n                return ans;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2141437,
                "title": "java-solution-easy-to-understand-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double taxes = 0;\\n        if (income==0) return 0;//No tax for 0 income\\n\\t\\t//Now checking for the first tax bracket, the range will start from zero itself\\n        double range = brackets[0][0];\\n        if (income>=range){\\n\\t\\t//Let\\'s say that the range is 3 and income is 10, we would have to check for the next tax bracket after caculating the tax value till 3\\n            double taxPercent = range * brackets[0][1] / 100;\\n            taxes +=taxPercent;//Adding the tax of this bracket into the total tax to be paid\\n            income -= range;//Remaining income to be taxed\\n        }else if (income>0){\\n\\t\\t//Let\\'s say that the income is 2 and range is 3, so we don\\'t need any other tax bracket to be taken care of. Here, we can directly return the taxes\\n            double inc = income;\\n            double taxPercent = inc * brackets[0][1] / 100;\\n            taxes +=taxPercent;\\n            return taxes;\\n        }\\n        for (int i = 1; i < brackets.length ; i++) {\\n\\t\\t//Entering the loop when the income is greater than the first bracket\\n            range = brackets[i][0] - brackets[i-1][0];//Range of a particular bracket\\n            if (income>=range){\\n\\t\\t\\t//We would have to go to the next bracket as well (if present)\\n\\t\\t\\t//So calculating the taxes of this bracket and moving to the next bracket\\n                double taxPercent = range * brackets[i][1] / 100;\\n                taxes +=taxPercent;\\n                income -= range;\\n            }else if (income>0){\\n\\t\\t\\t//Else the income is less than the current range. So calculating the tax of this bracket and then breaking the loop\\n                double inc = income;\\n                double taxPercent = inc * brackets[i][1] / 100;\\n                taxes +=taxPercent;\\n                income=0;\\n\\t\\t\\t\\tbreak;\\n            }\\n        }\\n\\n        return taxes;//Total amount of tax to be paid is now returned\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double taxes = 0;\\n        if (income==0) return 0;//No tax for 0 income\\n\\t\\t//Now checking for the first tax bracket, the range will start from zero itself\\n        double range = brackets[0][0];\\n        if (income>=range){\\n\\t\\t//Let\\'s say that the range is 3 and income is 10, we would have to check for the next tax bracket after caculating the tax value till 3\\n            double taxPercent = range * brackets[0][1] / 100;\\n            taxes +=taxPercent;//Adding the tax of this bracket into the total tax to be paid\\n            income -= range;//Remaining income to be taxed\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141107,
                "title": "python-simple-iterative-solution",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        i=0\\n        ans = 0\\n        while True:\\n            if income > brackets[i][0]:\\n                x = 0 if i==0 else brackets[i-1][0]\\n                ans += 1.0*(brackets[i][0]-x)*brackets[i][1]/100\\n                i += 1\\n            else:\\n                x = 0 if i==0 else brackets[i-1][0]\\n                ans += 1.0*(income-x)*brackets[i][1]/100\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        i=0\\n        ans = 0\\n        while True:\\n            if income > brackets[i][0]:\\n                x = 0 if i==0 else brackets[i-1][0]\\n                ans += 1.0*(brackets[i][0]-x)*brackets[i][1]/100\\n                i += 1\\n            else:\\n                x = 0 if i==0 else brackets[i-1][0]\\n                ans += 1.0*(income-x)*brackets[i][1]/100\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140993,
                "title": "simple-and-intuitive-java-solution",
                "content": "Hi guys feel free to optimise this. \\n\\n ```\\n  public double calculateTax(int[][] brackets, int income) {\\n        if(income == 0) return (double)0;\\n        double tax = 0;\\n        for(int i = 0; i < brackets.length; i++){\\n            double tempTax = 0;\\n            int incomeQualified = 0;\\n\\n            if( i == 0 && income >= brackets[i][0]){\\n                    tempTax = (double) (brackets[i][0]) * (brackets[i][1]) / 100;\\n                    incomeQualified  += brackets[i][0];\\n            }else if( i > 0 && income >= brackets[i][0] - brackets[i - 1][0]){\\n               if(i > 0) {\\n                    tempTax = (double) (brackets[i][0] - brackets[i - 1][0]) * (brackets[i][1]) / 100;\\n                    incomeQualified += brackets[i][0] - brackets[i - 1][0];\\n                }\\n            }else if(income > 0){\\n                    tempTax = (double) (income * brackets[i][1]) / 100;\\n                    incomeQualified += income;\\n            }\\n            income -= incomeQualified;\\n            tax += tempTax;\\n        }\\n        return tax;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public double calculateTax(int[][] brackets, int income) {\\n        if(income == 0) return (double)0;\\n        double tax = 0;\\n        for(int i = 0; i < brackets.length; i++){\\n            double tempTax = 0;\\n            int incomeQualified = 0;\\n\\n            if( i == 0 && income >= brackets[i][0]){\\n                    tempTax = (double) (brackets[i][0]) * (brackets[i][1]) / 100;\\n                    incomeQualified  += brackets[i][0];\\n            }else if( i > 0 && income >= brackets[i][0] - brackets[i - 1][0]){\\n               if(i > 0) {\\n                    tempTax = (double) (brackets[i][0] - brackets[i - 1][0]) * (brackets[i][1]) / 100;\\n                    incomeQualified += brackets[i][0] - brackets[i - 1][0];\\n                }\\n            }else if(income > 0){\\n                    tempTax = (double) (income * brackets[i][1]) / 100;\\n                    incomeQualified += income;\\n            }\\n            income -= incomeQualified;\\n            tax += tempTax;\\n        }\\n        return tax;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152648,
                "title": "simple-two-pointer-approach",
                "content": "****please upvote if you like*****************************************\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t   double calculateTax(vector<vector<int>>& brackets, int income) \\n    {\\n        if(income == 0) \\n            return 0.0;\\n        \\n        double ans = 0;\\n        int pre = 0;                   \\n        for(auto x : brackets)\\n        {\\n            int curr = min(x[0],income);\\n            ans += ((curr-pre)*x[1]/100.0);\\n            if(x[0] >= income) break;\\n            \\n            pre = x[0];\\n        }\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t   double calculateTax(vector<vector<int>>& brackets, int income) \\n    {\\n        if(income == 0) \\n            return 0.0;\\n        \\n        double ans = 0;\\n        int pre = 0;                   \\n        for(auto x : brackets)\\n        {\\n            int curr = min(x[0],income);\\n            ans += ((curr-pre)*x[1]/100.0);\\n            if(x[0] >= income) break;\\n            \\n            pre = x[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2149138,
                "title": "kotlin-one-pass",
                "content": "```\\nimport kotlin.math.min\\n\\nclass Solution {\\n    fun calculateTax(brackets: Array<IntArray>, income: Int): Double {\\n        var tax = 0\\n        var pre = 0\\n        for ((upper, percent) in brackets) {\\n            if (pre > income) break\\n            tax += (min(upper, income) - pre) * percent\\n            pre = upper\\n        }\\n        return tax.toDouble() / 100\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.min\\n\\nclass Solution {\\n    fun calculateTax(brackets: Array<IntArray>, income: Int): Double {\\n        var tax = 0\\n        var pre = 0\\n        for ((upper, percent) in brackets) {\\n            if (pre > income) break\\n            tax += (min(upper, income) - pre) * percent\\n            pre = upper\\n        }\\n        return tax.toDouble() / 100\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141690,
                "title": "c-simple-arrary-100-math",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    double calculateTax(vector<vector<int>> &brackets, int income)\\n    {\\n        double tax = 0,d;\\n\\t\\t// first case\\n        if (income > brackets[0][0])\\n            tax += (brackets[0][0] * brackets[0][1]) / 100.00000;\\n        else\\n            tax += (income * brackets[0][1]) / 100.00000;\\n\\t\\t\\t// all other case\\n        for (int i = 1; i < brackets.size(); i++)\\n        {\\n            if (brackets[i][0] < income)\\n            {\\n               d = brackets[i][0] - brackets[i - 1][0];\\n                if (d < 0) d = 0;\\n                tax += (d*brackets[i][1]) / 100.00000;\\n            }\\n            else\\n            {\\n                 d = income - brackets[i - 1][0];\\n                if (d < 0) d = 0;\\n                tax += (d*brackets[i][1]) / 100.00000;\\n            }\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    double calculateTax(vector<vector<int>> &brackets, int income)\\n    {\\n        double tax = 0,d;\\n\\t\\t// first case\\n        if (income > brackets[0][0])\\n            tax += (brackets[0][0] * brackets[0][1]) / 100.00000;\\n        else\\n            tax += (income * brackets[0][1]) / 100.00000;\\n\\t\\t\\t// all other case\\n        for (int i = 1; i < brackets.size(); i++)\\n        {\\n            if (brackets[i][0] < income)\\n            {\\n               d = brackets[i][0] - brackets[i - 1][0];\\n                if (d < 0) d = 0;\\n                tax += (d*brackets[i][1]) / 100.00000;\\n            }\\n            else\\n            {\\n                 d = income - brackets[i - 1][0];\\n                if (d < 0) d = 0;\\n                tax += (d*brackets[i][1]) / 100.00000;\\n            }\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141577,
                "title": "easy-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans =0;\\n        int back=0;\\n        for(auto x:brackets){\\n            int upper = x[0], percent=x[1];\\n            if(upper>income){\\n                ans += (income-back)*percent; break;}\\n            else ans += (upper-back)*percent;\\n            back = upper;\\n        }\\n        return (ans/100);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans =0;\\n        int back=0;\\n        for(auto x:brackets){\\n            int upper = x[0], percent=x[1];\\n            if(upper>income){\\n                ans += (income-back)*percent; break;}\\n            else ans += (upper-back)*percent;\\n            back = upper;\\n        }\\n        return (ans/100);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141143,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans = 0;\\n        for(int i=0; i<brackets.size(); i++)\\n        {\\n            if(income ==0)\\n                return ans;\\n            \\n            int upper = brackets[i][0];\\n            int percent = brackets[i][1];\\n            \\n            if(i==0)\\n            {  //first dollar\\n                if(upper <= income){\\n                    // cout <<  (double) (upper*percent)/100;\\n                    \\n                    ans += (double) (upper*percent)/100; //earned at percent\\n                    income -= upper;\\n                }\\n                else if(income > 0){\\n                        ans += (double) (income*percent)/100;\\n                        income -= income;\\n                    }\\n            }  \\n                \\n            else\\n            {   //rest of the dollars\\n                int dollars = upper- brackets[i-1][0];\\n                if( dollars <= income){ \\n                    ans += (double) (dollars*percent)/100;\\n                    income -= dollars;\\n                }\\n                else{\\n                    if(income >0){\\n                        ans += (double) (income*percent)/100;\\n                        income -= income;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans = 0;\\n        for(int i=0; i<brackets.size(); i++)\\n        {\\n            if(income ==0)\\n                return ans;\\n            \\n            int upper = brackets[i][0];\\n            int percent = brackets[i][1];\\n            \\n            if(i==0)\\n            {  //first dollar\\n                if(upper <= income){\\n                    // cout <<  (double) (upper*percent)/100;\\n                    \\n                    ans += (double) (upper*percent)/100; //earned at percent\\n                    income -= upper;\\n                }\\n                else if(income > 0){\\n                        ans += (double) (income*percent)/100;\\n                        income -= income;\\n                    }\\n            }  \\n                \\n            else\\n            {   //rest of the dollars\\n                int dollars = upper- brackets[i-1][0];\\n                if( dollars <= income){ \\n                    ans += (double) (dollars*percent)/100;\\n                    income -= dollars;\\n                }\\n                else{\\n                    if(income >0){\\n                        ans += (double) (income*percent)/100;\\n                        income -= income;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2141134,
                "title": "c-simple-and-efficient-solution-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        int n = brackets.size(); \\n        double taxes = 0; \\n        int lowerbound = 0; \\n        for(int i=0; i<n; i++) {\\n            int upperbound = brackets[i][0]; \\n            int taxes_per = brackets[i][1]; \\n            \\n            // Case 1 - When income is greater than or equal upperbound \\n            // Case 2 - When income is not greater than upperbound but greater than the lowerbound \\n            if(income >= upperbound) {\\n                int taxable = upperbound - lowerbound;\\n                taxes += (taxable * taxes_per) / 100.0;\\n                lowerbound = upperbound;\\n            } else if(income < upperbound && income > lowerbound) {\\n                int taxable = income - lowerbound; \\n                taxes += (taxable * taxes_per) / 100.0; \\n                break;\\n            }\\n        }\\n        return taxes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        int n = brackets.size(); \\n        double taxes = 0; \\n        int lowerbound = 0; \\n        for(int i=0; i<n; i++) {\\n            int upperbound = brackets[i][0]; \\n            int taxes_per = brackets[i][1]; \\n            \\n            // Case 1 - When income is greater than or equal upperbound \\n            // Case 2 - When income is not greater than upperbound but greater than the lowerbound \\n            if(income >= upperbound) {\\n                int taxable = upperbound - lowerbound;\\n                taxes += (taxable * taxes_per) / 100.0;\\n                lowerbound = upperbound;\\n            } else if(income < upperbound && income > lowerbound) {\\n                int taxable = income - lowerbound; \\n                taxes += (taxable * taxes_per) / 100.0; \\n                break;\\n            }\\n        }\\n        return taxes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141098,
                "title": "short-python-solution",
                "content": "```\\nresult = 0\\npre = 0\\nfor a, b in brackets:\\n\\tif a >= income:\\n\\t\\treturn result + (income - pre) * b / 100\\n\\tresult += (a - pre) * b / 100\\n\\tpre = a\\nreturn result\\n```",
                "solutionTags": [],
                "code": "```\\nresult = 0\\npre = 0\\nfor a, b in brackets:\\n\\tif a >= income:\\n\\t\\treturn result + (income - pre) * b / 100\\n\\tresult += (a - pre) * b / 100\\n\\tpre = a\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140940,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        brackets.sort(key=lambda x: x[0])\\n        res = 0 # Total Tax \\n        prev = 0 # Prev Bracket Upperbound\\n        for u, p in brackets:\\n            if income >= u: # \\n                res += ((u-prev) * p) / 100\\n                prev = u\\n            else:\\n                res += ((income-prev) * p) / 100\\n                break # As total income has been taxed at this point.\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        brackets.sort(key=lambda x: x[0])\\n        res = 0 # Total Tax \\n        prev = 0 # Prev Bracket Upperbound\\n        for u, p in brackets:\\n            if income >= u: # \\n                res += ((u-prev) * p) / 100\\n                prev = u\\n            else:\\n                res += ((income-prev) * p) / 100\\n                break # As total income has been taxed at this point.\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918497,
                "title": "short-java-solution-and-explanation",
                "content": "# Intuition\\nAdd up taxes for each bracket.\\n\\n# Approach\\nFor each bracket, take the minimum of bracket and income. Multiply the untaxed part of income up to bracket with the percentage.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax=0;\\n        int pre=0;\\n        for(int i=0; i<brackets.length && income-pre>0; i++) {\\n            tax += (double)(Math.min(income,brackets[i][0])-pre)*brackets[i][1]/100;\\n            pre = brackets[i][0];\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax=0;\\n        int pre=0;\\n        for(int i=0; i<brackets.length && income-pre>0; i++) {\\n            tax += (double)(Math.min(income,brackets[i][0])-pre)*brackets[i][1]/100;\\n            pre = brackets[i][0];\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820381,
                "title": "java-simple-solution-100-faster-fully-explained",
                "content": "# Approach\\nApproach and Logic:\\nThe given problem requires calculating the amount of money that needs to be paid in taxes based on the income and tax brackets. To achieve this, we can follow a simple approach:\\n\\n1. Initialize a variable `tax` to keep track of the total tax amount, and `prev` to keep track of the upper bound of the previous tax bracket (initialized to 0).\\n\\n2. Iterate through each tax bracket in the `brackets` array:\\n\\n   a. If the upper bound of the current tax bracket (`bracket[0]`) is less than the given income, it means the entire bracket is within the income range. So, calculate the tax for this bracket and add it to the total `tax` amount. The tax for a bracket is calculated by taking the difference between the current upper bound and the previous upper bound (`bracket[0] - prev`) and multiplying it by the tax rate (`bracket[1] / 100`). Update the `prev` variable to the current upper bound.\\n\\n   b. If the upper bound of the current tax bracket is greater than or equal to the given income, it means only a part of this bracket is within the income range. Calculate the tax for this part and add it to the total `tax` amount. The tax for this part is calculated by taking the difference between the given income and the previous upper bound (`income - prev`) and multiplying it by the tax rate (`bracket[1] / 100`). Break the loop, as we have covered all the income.\\n\\n3. Return the `tax` amount as the final result.\\n\\nThe provided solution correctly implements the above approach. It efficiently calculates the tax based on the income and the tax brackets, considering both the entire brackets and partial brackets within the income range. It handles the case when the income exceeds the last tax bracket\\'s upper bound, ensuring that the correct tax amount is calculated.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        int prev = 0;\\n\\n        for (int[] bracket : brackets) {\\n            if (bracket[0] < income) {\\n                tax += (bracket[0] - prev) * (double) bracket[1] / 100;\\n                prev = bracket[0];\\n            } else {\\n                income -= prev;\\n                tax += (double) income * bracket[1] / 100;\\n                break;\\n            }\\n        }\\n\\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        int prev = 0;\\n\\n        for (int[] bracket : brackets) {\\n            if (bracket[0] < income) {\\n                tax += (bracket[0] - prev) * (double) bracket[1] / 100;\\n                prev = bracket[0];\\n            } else {\\n                income -= prev;\\n                tax += (double) income * bracket[1] / 100;\\n                break;\\n            }\\n        }\\n\\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779023,
                "title": "fastest-solution-100-beats-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\n    public double calculateTax(int[][] brackets, int income){\\n        double ans = 0;\\n        if(brackets[0][0]>income) return (double) income * brackets[0][1] / 100;\\n        ans += (double) brackets[0][0] * brackets[0][1] / 100;\\n        for(int i=1; i<brackets.length; i++){\\n            if(brackets[i][0]<=income) ans += (double) (brackets[i][0]-brackets[i-1][0]) * brackets[i][1] / 100;\\n            else{\\n                ans += (double) (income-brackets[i-1][0]) * brackets[i][1] / 100;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public double calculateTax(int[][] brackets, int income){\\n        double ans = 0;\\n        if(brackets[0][0]>income) return (double) income * brackets[0][1] / 100;\\n        ans += (double) brackets[0][0] * brackets[0][1] / 100;\\n        for(int i=1; i<brackets.length; i++){\\n            if(brackets[i][0]<=income) ans += (double) (brackets[i][0]-brackets[i-1][0]) * brackets[i][1] / 100;\\n            else{\\n                ans += (double) (income-brackets[i-1][0]) * brackets[i][1] / 100;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445944,
                "title": "java-easy-100-solution",
                "content": "```java\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prev = 0;\\n        double taxes = 0;\\n\\n        for(int[] bracket : brackets) {\\n            if(income <= 0)\\n                break;\\n\\n            int diff = Math.min((bracket[0] - prev), income);\\n\\n            taxes += (double) diff * ((double) bracket[1] / 100);\\n\\n            income -= diff;\\n            prev = bracket[0];\\n        }\\n\\n        return taxes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prev = 0;\\n        double taxes = 0;\\n\\n        for(int[] bracket : brackets) {\\n            if(income <= 0)\\n                break;\\n\\n            int diff = Math.min((bracket[0] - prev), income);\\n\\n            taxes += (double) diff * ((double) bracket[1] / 100);\\n\\n            income -= diff;\\n            prev = bracket[0];\\n        }\\n\\n        return taxes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361433,
                "title": "calculate-amount-paid-in-taxes-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        int i, j;\\n        double taxes;\\n        for(i=0 ; i<brackets.size() ; i++)\\n        {\\n            if(i==0)\\n            {\\n                if(income>=brackets[i][0])\\n                {\\n                    taxes += (double)brackets[i][0]*brackets[i][1]/100;\\n                    income -= brackets[i][0];\\n                }\\n                else\\n                {\\n                    taxes += (double)income*brackets[i][1]/100;\\n                    return taxes;\\n                }\\n            }\\n            else\\n            {\\n                if(income>=(brackets[i][0]-brackets[i-1][0]))\\n                {\\n                    taxes += (double)(brackets[i][0]-brackets[i-1][0])*brackets[i][1]/100;\\n                    income -= (brackets[i][0]-brackets[i-1][0]);\\n                }\\n                else\\n                {\\n                    taxes += (double)income*brackets[i][1]/100;\\n                    return taxes;\\n                }\\n            }\\n        }\\n        return taxes;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        int i, j;\\n        double taxes;\\n        for(i=0 ; i<brackets.size() ; i++)\\n        {\\n            if(i==0)\\n            {\\n                if(income>=brackets[i][0])\\n                {\\n                    taxes += (double)brackets[i][0]*brackets[i][1]/100;\\n                    income -= brackets[i][0];\\n                }\\n                else\\n                {\\n                    taxes += (double)income*brackets[i][1]/100;\\n                    return taxes;\\n                }\\n            }\\n            else\\n            {\\n                if(income>=(brackets[i][0]-brackets[i-1][0]))\\n                {\\n                    taxes += (double)(brackets[i][0]-brackets[i-1][0])*brackets[i][1]/100;\\n                    income -= (brackets[i][0]-brackets[i-1][0]);\\n                }\\n                else\\n                {\\n                    taxes += (double)income*brackets[i][1]/100;\\n                    return taxes;\\n                }\\n            }\\n        }\\n        return taxes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211355,
                "title": "best-c-detailed-explained-code-beats-100-solutions",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        // If income is zero then there will be no tax\\n        if(income==0)return 0;\\n        double tax = 0.0;\\n        // If income is greater then first dollars earned\\n        // then we will initialize tax\\n        if(income-brackets[0][0]>=0){\\n            tax = (brackets[0][0]*brackets[0][1])/100.00;\\n            income-=brackets[0][0];\\n        }else{\\n        // If income is less then first doller earned then\\n        // tax will only be applied on income ans we will return tax\\n            tax+=(income*brackets[0][1])/100.00;\\n            return tax;\\n        }\\n        for(int i=1; i<brackets.size() && income>=0; i++){\\n            if(income-(brackets[i][0]-brackets[i-1][0])>=0){\\n            // While income is greater then diffrence of\\n            // dollar earned\\n                tax+= ((brackets[i][0]-brackets[i-1][0])*brackets[i][1])/100.00;\\n                income-=(brackets[i][0]-brackets[i-1][0]);\\n            }else{\\n            // Once income is less then diffrence of dollar \\n            // earned tax will only be applied on remaining income\\n                tax+=(income*brackets[i][1])/100.00;\\n                break;\\n            }\\n        }\\n        return tax;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        // If income is zero then there will be no tax\\n        if(income==0)return 0;\\n        double tax = 0.0;\\n        // If income is greater then first dollars earned\\n        // then we will initialize tax\\n        if(income-brackets[0][0]>=0){\\n            tax = (brackets[0][0]*brackets[0][1])/100.00;\\n            income-=brackets[0][0];\\n        }else{\\n        // If income is less then first doller earned then\\n        // tax will only be applied on income ans we will return tax\\n            tax+=(income*brackets[0][1])/100.00;\\n            return tax;\\n        }\\n        for(int i=1; i<brackets.size() && income>=0; i++){\\n            if(income-(brackets[i][0]-brackets[i-1][0])>=0){\\n            // While income is greater then diffrence of\\n            // dollar earned\\n                tax+= ((brackets[i][0]-brackets[i-1][0])*brackets[i][1])/100.00;\\n                income-=(brackets[i][0]-brackets[i-1][0]);\\n            }else{\\n            // Once income is less then diffrence of dollar \\n            // earned tax will only be applied on remaining income\\n                tax+=(income*brackets[i][1])/100.00;\\n                break;\\n            }\\n        }\\n        return tax;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018926,
                "title": "python-doesn-t-get-any-easier-than-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = 0\\n        brackets.insert(0, [0,0])\\n        for i in range(1, len(brackets)):\\n            diff = brackets[i][0] - brackets[i-1][0]\\n            if income < diff: return income*(brackets[i][1]/100) + tax\\n            tax += diff*(brackets[i][1]/100)\\n            income -= diff\\n        return tax\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = 0\\n        brackets.insert(0, [0,0])\\n        for i in range(1, len(brackets)):\\n            diff = brackets[i][0] - brackets[i-1][0]\\n            if income < diff: return income*(brackets[i][1]/100) + tax\\n            tax += diff*(brackets[i][1]/100)\\n            income -= diff\\n        return tax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896039,
                "title": "java-2ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double result = 0;\\n        for (int i = 0; i < brackets.length; i++) {\\n            int[] group = brackets[i];\\n            int prevUpper = 0;\\n            if (i > 0) {\\n                prevUpper = brackets[i - 1][0];\\n            }\\n            int upper = group[0], percent = group[1];\\n            int sumToTax = upper - prevUpper;\\n            if (income - sumToTax >= 0) {\\n                income -= sumToTax;\\n                result += ((sumToTax * percent) / 100.0);\\n            } else {\\n                result += ((income * percent) / 100.0);\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double result = 0;\\n        for (int i = 0; i < brackets.length; i++) {\\n            int[] group = brackets[i];\\n            int prevUpper = 0;\\n            if (i > 0) {\\n                prevUpper = brackets[i - 1][0];\\n            }\\n            int upper = group[0], percent = group[1];\\n            int sumToTax = upper - prevUpper;\\n            if (income - sumToTax >= 0) {\\n                income -= sumToTax;\\n                result += ((sumToTax * percent) / 100.0);\\n            } else {\\n                result += ((income * percent) / 100.0);\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753640,
                "title": "c-soln-77-faster-soln-self-explanatory-method",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        \\n        vector <int> ans;\\n        \\n        if(brackets[0][0] > income)\\n            return income*(brackets[0][1]/100.0);\\n        \\n        income -= brackets[0][0];\\n        ans.push_back(brackets[0][0]);\\n        \\n        for(int i = 1 ; i < brackets.size(); i++){\\n            int dif = brackets[i][0] - brackets[i-1][0];\\n            if( dif >= income){\\n                ans.push_back(income);\\n                break;\\n            }else{\\n                income -= dif;\\n            }\\n            ans.push_back(dif);\\n        }\\n        \\n        double tax = 0;\\n        \\n        for(int i = 0; i < ans.size();i++){\\n            tax += (brackets[i][1]/100.0)*ans[i];    \\n        }\\n        \\n        return tax;\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        \\n        vector <int> ans;\\n        \\n        if(brackets[0][0] > income)\\n            return income*(brackets[0][1]/100.0);\\n        \\n        income -= brackets[0][0];\\n        ans.push_back(brackets[0][0]);\\n        \\n        for(int i = 1 ; i < brackets.size(); i++){\\n            int dif = brackets[i][0] - brackets[i-1][0];\\n            if( dif >= income){\\n                ans.push_back(income);\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2720115,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;  \\n        if(income==0){\\n            return ans;\\n        }\\n        int prev=0; \\n        for(int i=0;i<brackets.size();i++){\\n            int actual=min(brackets[i][0],income);\\n            ans+=((actual-prev)*brackets[i][1]*1.0)/100.0;\\n            if(brackets[i][0]>=income){\\n                break;\\n            }\\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;  \\n        if(income==0){\\n            return ans;\\n        }\\n        int prev=0; \\n        for(int i=0;i<brackets.size();i++){\\n            int actual=min(brackets[i][0],income);\\n            ans+=((actual-prev)*brackets[i][1]*1.0)/100.0;\\n            if(brackets[i][0]>=income){\\n                break;\\n            }\\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453572,
                "title": "java-solution-100-fast",
                "content": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0.0;\\n        double previous = 0;\\n        for(int i = 0;i<brackets.length;i++)\\n        {\\n            double upper = brackets[i][0];\\n            double percentage = brackets[i][1];\\n            if(income >= upper)\\n            {\\n                tax+=((upper-previous)*percentage)/100;\\n                previous = upper;\\n            }\\n            else\\n            {\\n                tax+=((income-previous)*percentage)/100;\\n                previous = upper;\\n                break;\\n            }\\n        }\\n        return tax;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0.0;\\n        double previous = 0;\\n        for(int i = 0;i<brackets.length;i++)\\n        {\\n            double upper = brackets[i][0];\\n            double percentage = brackets[i][1];\\n            if(income >= upper)\\n            {\\n                tax+=((upper-previous)*percentage)/100;\\n                previous = upper;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2344704,
                "title": "obvious",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        taxes = 0\\n        checked = 0\\n        for upper, percent in brackets:\\n            if upper>income:\\n                taxes+=(income-checked)*percent/100\\n                return taxes\\n            taxes+=(upper-checked)*percent/100\\n            checked=upper\\n        return taxes",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        taxes = 0\\n        checked = 0\\n        for upper, percent in brackets:\\n            if upper>income:\\n                taxes+=(income-checked)*percent/100\\n                return taxes\\n            taxes+=(upper-checked)*percent/100\\n            checked=upper\\n        return taxes",
                "codeTag": "Java"
            },
            {
                "id": 2204877,
                "title": "easy-understanding-java-solution-90-faster",
                "content": "```\\n\\tpublic double calculateTax(int[][] brackets, int income) {\\n        \\n        double tax = 0.0d;\\n        int prev = -1;\\n        \\n        for(int i = 0; i < brackets.length; i++){\\n            \\n            if(income <= 0) break;\\n            \\n            int amount = prev == -1 ? brackets[i][0] : brackets[i][0] - prev;\\n            tax += calculateTax(amount, brackets[i][1], income);\\n            \\n            income -= amount;\\n            prev = brackets[i][0];\\n        }\\n        \\n        return tax;\\n    }\\n    \\n    public double calculateTax(int amount, int per, int income){\\n        \\n        return income <= amount ? ((double) income * per/100) : ((double)amount * per/100);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic double calculateTax(int[][] brackets, int income) {\\n        \\n        double tax = 0.0d;\\n        int prev = -1;\\n        \\n        for(int i = 0; i < brackets.length; i++){\\n            \\n            if(income <= 0) break;\\n            \\n            int amount = prev == -1 ? brackets[i][0] : brackets[i][0] - prev;\\n            tax += calculateTax(amount, brackets[i][1], income);\\n            \\n            income -= amount;\\n            prev = brackets[i][0];\\n        }\\n        \\n        return tax;\\n    }\\n    \\n    public double calculateTax(int amount, int per, int income){\\n        \\n        return income <= amount ? ((double) income * per/100) : ((double)amount * per/100);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2197984,
                "title": "java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans=0;\\n        int pre=0;\\n        for(int[] arr : brackets){\\n            int val=arr[0]; arr[0]-=pre;  pre=val;\\n            ans+=(double)(Math.min(income,arr[0])*arr[1])/100;\\n            income-=arr[0];\\n            if(income<=0){ break; }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans=0;\\n        int pre=0;\\n        for(int[] arr : brackets){\\n            int val=arr[0]; arr[0]-=pre;  pre=val;\\n            ans+=(double)(Math.min(income,arr[0])*arr[1])/100;\\n            income-=arr[0];\\n            if(income<=0){ break; }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166711,
                "title": "python3-solution-easy-to-understand-concise-and-simple-code",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        lower = 0; \\n\\t\\ttax = 0; \\n\\t\\tleft = income # amount left to be taxed\\n        for i in brackets:\\n            k = i[0]-lower # amount being taxed\\n            if k<= left:\\n                tax+=k*i[1]/100;  left-=k;  lower=i[0]\\n            else:\\n                tax+= left*i[1]/100\\n                break\\n        return tax\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        lower = 0; \\n\\t\\ttax = 0; \\n\\t\\tleft = income # amount left to be taxed\\n        for i in brackets:\\n            k = i[0]-lower # amount being taxed\\n            if k<= left:\\n                tax+=k*i[1]/100;  left-=k;  lower=i[0]\\n            else:\\n                tax+= left*i[1]/100\\n                break\\n        return tax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165689,
                "title": "java-faster-than-100",
                "content": "\\n\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int count =0;\\n        int j=0;\\n        double sum=0;\\n        int k =0;\\n        \\n          while (income>brackets[j][0]){\\n             j++;\\n             count++;\\n         }\\n       \\n          for (int i=0;i<=count;i++){\\n            \\n          if (i== count)\\n              {brackets[i][0] =income-k;}\\n          else\\n              {brackets[i][0] = brackets[i][0]-k;}\\n            \\n            \\n            sum +=  (double) ( brackets[i][0] * brackets[i][1])/100; \\n             k += brackets[i][0];\\n        }\\n   \\n        return  (double)sum;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int count =0;\\n        int j=0;\\n        double sum=0;\\n        int k =0;\\n        \\n          while (income>brackets[j][0]){\\n             j++;\\n             count++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2161344,
                "title": "c-solution",
                "content": "```\\ndouble calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;\\n        for (int i=0;i<brackets.size();i++){\\n            if (i==0) ans = min(income,brackets[i][0])*brackets[i][1];\\n            else ans += (min(brackets[i][0],income)-brackets[i-1][0])*brackets[i][1];\\n            if (income <= brackets[i][0]) break;\\n        }\\n        return ans*0.01;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndouble calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;\\n        for (int i=0;i<brackets.size();i++){\\n            if (i==0) ans = min(income,brackets[i][0])*brackets[i][1];\\n            else ans += (min(brackets[i][0],income)-brackets[i-1][0])*brackets[i][1];\\n            if (income <= brackets[i][0]) break;\\n        }\\n        return ans*0.01;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2155262,
                "title": "c-detailed-explanation-o-n-complexity",
                "content": "Explanation:\\n-\\nWe check the current amount to be taxed using a min function which compares upper bound and income.\\nThen we add the tax value to final answer using formula (curr-prev) X percentage tax.\\n\\n**Quick Tip:**\\nTry to substitute values given in example 1 to understand it more clearly.\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax=0;\\n        double prev=0;\\n        for(auto const &it:brackets)\\n        {\\n            int i=it[0];\\n            int per=it[1];\\n            int curr=min(i, income);\\n            tax=tax+((curr-prev)*per)/100;\\n            prev=i;\\n            if(i>=income) break;\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax=0;\\n        double prev=0;\\n        for(auto const &it:brackets)\\n        {\\n            int i=it[0];\\n            int per=it[1];\\n            int curr=min(i, income);\\n            tax=tax+((curr-prev)*per)/100;\\n            prev=i;\\n            if(i>=income) break;\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155223,
                "title": "javascript-reduce",
                "content": "```\\nvar calculateTax = function(brackets, income) {\\n    return brackets.reduce(([tax, prev], [upper, percent]) => {\\n        let curr = Math.min(income, upper - prev);\\n        tax += curr * (percent / 100);\\n\\t\\t\\n        income -= curr;\\n        if (income <= 0) brackets.length = 0;\\n\\t\\t\\n        return [tax, upper];\\n    }, [0, 0])[0];    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calculateTax = function(brackets, income) {\\n    return brackets.reduce(([tax, prev], [upper, percent]) => {\\n        let curr = Math.min(income, upper - prev);\\n        tax += curr * (percent / 100);\\n\\t\\t\\n        income -= curr;\\n        if (income <= 0) brackets.length = 0;\\n\\t\\t\\n        return [tax, upper];\\n    }, [0, 0])[0];    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152642,
                "title": "python-5-6-lines-solution",
                "content": "A simple algorithm to compute tax:\\n```\\ndef calculateTax(self, brackets, income):\\n        \\n        tax = previous = 0\\n        \\n        for high,percent in brackets:\\n            \\n            high = min(high,income)\\n            tax += (high-previous)*percent/100.00\\n            previous = high\\n            \\n        return tax\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef calculateTax(self, brackets, income):\\n        \\n        tax = previous = 0\\n        \\n        for high,percent in brackets:\\n            \\n            high = min(high,income)\\n            tax += (high-previous)*percent/100.00\\n            previous = high\\n            \\n        return tax\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2150061,
                "title": "python-simple-6-liner",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, l: List[List[int]], k: int) -> float:\\n        prev=sol=0\\n        for x,y in l:\\n            t, prev = min(x,k)-prev, x\\n            if t<0:break\\n            sol+=t*y/100\\n        return sol\\n```\\n\\n**Happy Coding !!**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, l: List[List[int]], k: int) -> float:\\n        prev=sol=0\\n        for x,y in l:\\n            t, prev = min(x,k)-prev, x\\n            if t<0:break\\n            sol+=t*y/100\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142113,
                "title": "c-super-short-o-n-time-complexity-easy-solution-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& a, int income) {\\n        double ans = 0;\\n        int n = a.size();\\n        for(int i = 0;income > 0;i++){\\n            double curTaxEarn = min(income,a[i][0] - (i ==0 ?0:a[i - 1][0]));\\n            income -= curTaxEarn;\\n            ans += (curTaxEarn * a[i][1])/100;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n## UPVOTE IF YOU LIKE\\n![image](https://assets.leetcode.com/users/images/437f2ea2-8312-49fb-83f3-ed4328541695_1655018735.531827.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& a, int income) {\\n        double ans = 0;\\n        int n = a.size();\\n        for(int i = 0;income > 0;i++){\\n            double curTaxEarn = min(income,a[i][0] - (i ==0 ?0:a[i - 1][0]));\\n            income -= curTaxEarn;\\n            ans += (curTaxEarn * a[i][1])/100;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141995,
                "title": "go-solution",
                "content": "```\\nfunc calculateTax(brackets [][]int, income int) float64 {\\n    result := float64(0)\\n    lastTax := 0\\n    remain := income\\n    for _, bracket := range brackets {\\n        if bracket[0] < income {\\n            result += float64(bracket[0] - lastTax) * float64(bracket[1]) / float64(100)\\n            lastTax = bracket[0]\\n            remain = income - bracket[0]\\n            continue\\n        }\\n        if income > lastTax {\\n            result += float64(remain) * float64(bracket[1]) / float64(100)\\n            lastTax = bracket[0]\\n        } else {\\n            break\\n        }\\n    }\\n    return result\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc calculateTax(brackets [][]int, income int) float64 {\\n    result := float64(0)\\n    lastTax := 0\\n    remain := income\\n    for _, bracket := range brackets {\\n        if bracket[0] < income {\\n            result += float64(bracket[0] - lastTax) * float64(bracket[1]) / float64(100)\\n            lastTax = bracket[0]\\n            remain = income - bracket[0]\\n            continue\\n        }\\n        if income > lastTax {\\n            result += float64(remain) * float64(bracket[1]) / float64(100)\\n            lastTax = bracket[0]\\n        } else {\\n            break\\n        }\\n    }\\n    return result\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2141671,
                "title": "java-linear-time-explained-with-comments-100-faster-0ms",
                "content": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int len = brackets.length;  // to calculate length of given array (\\'brackets\\' here)\\n        double ans = 0;  // to keep track of final answer\\n        int past = 0;  // previous taxable value\\n    \\n        for(int i=0; i<len; i++) {\\n            int decider = Math.min(income, brackets[i][0]);  // to get minimum between income and current taxable value\\n            ans += (double)(decider-past)*(double)(brackets[i][1])/100.0; // to calculate tax and adding it to our answer\\n            past = brackets[i][0]; // to change previous taxable value\\n            if(income <= brackets[i][0]) break; // to break the loop, if our income is less than current taxable value\\n        }\\n        return ans; // finally, returning ans i.e:- total amount paid in taxes\\n    }\\n}\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int len = brackets.length;  // to calculate length of given array (\\'brackets\\' here)\\n        double ans = 0;  // to keep track of final answer\\n        int past = 0;  // previous taxable value\\n    \\n        for(int i=0; i<len; i++) {\\n            int decider = Math.min(income, brackets[i][0]);  // to get minimum between income and current taxable value\\n            ans += (double)(decider-past)*(double)(brackets[i][1])/100.0; // to calculate tax and adding it to our answer\\n            past = brackets[i][0]; // to change previous taxable value\\n            if(income <= brackets[i][0]) break; // to break the loop, if our income is less than current taxable value\\n        }\\n        return ans; // finally, returning ans i.e:- total amount paid in taxes\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141590,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& arr, int income) {\\n        \\n        int n = arr.size();\\n        \\n        int earned = arr[0][0];\\n        \\n        earned = min(earned, income);\\n        \\n        double total_tax = 0;\\n        \\n        total_tax += ((double) earned * arr[0][1]) / 100;\\n        \\n        income -= earned;\\n        \\n        if(income <= 0)\\n            return total_tax;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            earned = arr[i][0] - arr[i - 1][0];\\n            \\n            earned = min(earned, income);\\n            \\n            total_tax += ((double) earned * arr[i][1]) / 100;\\n            \\n            income -= earned;\\n            \\n            if(income <= 0)\\n                return total_tax;\\n        }\\n        \\n        return total_tax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& arr, int income) {\\n        \\n        int n = arr.size();\\n        \\n        int earned = arr[0][0];\\n        \\n        earned = min(earned, income);\\n        \\n        double total_tax = 0;\\n        \\n        total_tax += ((double) earned * arr[0][1]) / 100;\\n        \\n        income -= earned;\\n        \\n        if(income <= 0)\\n            return total_tax;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            earned = arr[i][0] - arr[i - 1][0];\\n            \\n            earned = min(earned, income);\\n            \\n            total_tax += ((double) earned * arr[i][1]) / 100;\\n            \\n            income -= earned;\\n            \\n            if(income <= 0)\\n                return total_tax;\\n        }\\n        \\n        return total_tax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141375,
                "title": "calculate-amount-paid-in-taxes",
                "content": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans = 0.0;\\n        if (income == 0) return ans;\\n        int prev = 0;\\n        for (int[] bracket : brackets) {\\n            int v = Math.min(bracket[0], income);\\n            ans += ((v - prev) * bracket[1]) / 100.0;\\n            if (bracket[0] >= income) break;\\n            prev = bracket[0];\\n        }\\n        return ans;\\n\\n    }\\n}\\n``",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans = 0.0;\\n        if (income == 0) return ans;\\n        int prev = 0;\\n        for (int[] bracket : brackets) {\\n            int v = Math.min(bracket[0], income);\\n            ans += ((v - prev) * bracket[1]) / 100.0;\\n            if (bracket[0] >= income) break;\\n            prev = bracket[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141169,
                "title": "o-n-solution-in-python",
                "content": "```\\n\\t\\tleng = len(brackets)\\n\\t\\t\\'\\'\\' if  income is 0, no tax \\'\\'\\'\\n        if income == 0:\\n            return float(0)\\n        \\n        tax = 0\\n\\t\\t\\'\\'\\' here we calculate tax for 1st bracket i.e. at index \\'\\'\\'\\n        if (income > brackets[0][0]):\\n            tax = brackets[0][0] * (brackets[0][1] * 0.01)\\n        else:\\n            tax = income * (brackets[0][1] * 0.01)\\n    \\n\\t\\t\\'\\'\\'\\n\\t\\trem_inc is for checking upto what limit we have to keep checking\\n\\t\\t(what if our income for which we # have to calculate tax is done, in this case our iteration should stop.)\\n\\t\\t\\'\\'\\'\\n        rem_inc = income - brackets[0][0]\\n        \\n        i = 1\\n        while rem_inc > 0 and i < leng:\\n\\t\\t\\t\\'\\'\\' Here we check  the bracket on which we have to calculate the tax depends on the difference of last 2 brackets\\'\\'\\'\\n            principal = (brackets[i][0] - brackets[i-1][0]) if brackets[i][0] <= income else (income - brackets[i-1][0])\\n            rem_inc -= principal\\n            tax += principal * (brackets[i][1] * 0.01)\\n            i += 1\\n            \\n        return tax\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t\\tleng = len(brackets)\\n\\t\\t\\'\\'\\' if  income is 0, no tax \\'\\'\\'\\n        if income == 0:\\n            return float(0)\\n        \\n        tax = 0\\n\\t\\t\\'\\'\\' here we calculate tax for 1st bracket i.e. at index \\'\\'\\'\\n        if (income > brackets[0][0]):\\n            tax = brackets[0][0] * (brackets[0][1] * 0.01)\\n        else:\\n            tax = income * (brackets[0][1] * 0.01)\\n    \\n\\t\\t\\'\\'\\'\\n\\t\\trem_inc is for checking upto what limit we have to keep checking\\n\\t\\t(what if our income for which we # have to calculate tax is done, in this case our iteration should stop.)\\n\\t\\t\\'\\'\\'\\n        rem_inc = income - brackets[0][0]\\n        \\n        i = 1\\n        while rem_inc > 0 and i < leng:\\n\\t\\t\\t\\'\\'\\' Here we check  the bracket on which we have to calculate the tax depends on the difference of last 2 brackets\\'\\'\\'\\n            principal = (brackets[i][0] - brackets[i-1][0]) if brackets[i][0] <= income else (income - brackets[i-1][0])\\n            rem_inc -= principal\\n            tax += principal * (brackets[i][1] * 0.01)\\n            i += 1\\n            \\n        return tax\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141157,
                "title": "java-easy-understanding-tc-o-n",
                "content": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0.0000;\\n        int prev = 0;\\n        for(int i = 0; i<brackets.length; i++){\\n            int temp = Math.min(brackets[i][0],income);\\n            if(temp-prev<0) return tax;\\n            tax += (double)(temp-prev)*brackets[i][1]/100.00;\\n            prev = brackets[i][0];\\n        }\\n        return tax;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0.0000;\\n        int prev = 0;\\n        for(int i = 0; i<brackets.length; i++){\\n            int temp = Math.min(brackets[i][0],income);\\n            if(temp-prev<0) return tax;\\n            tax += (double)(temp-prev)*brackets[i][1]/100.00;\\n            prev = brackets[i][0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141096,
                "title": "simple-java-solution",
                "content": "``` java\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double res = 0;\\n        boolean flag = false;\\n        for (int i = 0; i < brackets.length; i++) {\\n            int cur = brackets[i][0];\\n            if (income <= brackets[i][0]) {\\n                cur = income;\\n                flag = true;\\n            }\\n            if (i != 0) {\\n                cur -= brackets[i - 1][0];\\n            }\\n            res += (double) (cur) * brackets[i][1] / 100;\\n            if (flag) {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double res = 0;\\n        boolean flag = false;\\n        for (int i = 0; i < brackets.length; i++) {\\n            int cur = brackets[i][0];\\n            if (income <= brackets[i][0]) {\\n                cur = income;\\n                flag = true;\\n            }\\n            if (i != 0) {\\n                cur -= brackets[i - 1][0];\\n            }\\n            res += (double) (cur) * brackets[i][1] / 100;\\n            if (flag) {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141062,
                "title": "easy-efficient-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    double calculateTax(vector<vector<int>>& v, int n) {\\n        ld res = 0;\\n        ll i = 0;\\n        while (i < v.size() && n>0) {\\n            res += (ld(v[i][1]) / ld(100)) * ld(min(v[i][0]-(i>0?v[i-1][0]:0), n));\\n            n -= v[i][0]-(i>0?v[i-1][0]:0);\\n            n = max(n, 0);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    double calculateTax(vector<vector<int>>& v, int n) {\\n        ld res = 0;\\n        ll i = 0;\\n        while (i < v.size() && n>0) {\\n            res += (ld(v[i][1]) / ld(100)) * ld(min(v[i][0]-(i>0?v[i-1][0]:0), n));\\n            n -= v[i][0]-(i>0?v[i-1][0]:0);\\n            n = max(n, 0);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141053,
                "title": "javascript",
                "content": "```\\nvar calculateTax = function(brackets, income) {\\n  let totalTax = 0;\\n  let previous = 0;\\n  for(let [upper, percent] of brackets) {\\n    if (upper > income) {\\n      upper = income;\\n    }\\n    const taxableIncome = upper - previous;\\n    previous = upper;\\n    if (taxableIncome > 0) {\\n      const tax = (taxableIncome * (percent / 100));\\n      totalTax += tax;\\n    }\\n  }\\n  return totalTax;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar calculateTax = function(brackets, income) {\\n  let totalTax = 0;\\n  let previous = 0;\\n  for(let [upper, percent] of brackets) {\\n    if (upper > income) {\\n      upper = income;\\n    }\\n    const taxableIncome = upper - previous;\\n    previous = upper;\\n    if (taxableIncome > 0) {\\n      const tax = (taxableIncome * (percent / 100));\\n      totalTax += tax;\\n    }\\n  }\\n  return totalTax;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141039,
                "title": "c-o-n",
                "content": "```\\n    public double CalculateTax(int[][] brackets, int income) \\n    {\\n        double tax = 0;\\n        int prev = 0;\\n        for (int i = 0; i < brackets.Length && income > 0; i++)\\n        {\\n            int value = Math.Min(income, brackets[i][0] - prev);\\n            tax += (double)value * brackets[i][1];\\n            income -= value;\\n            prev = brackets[i][0];\\n        }\\n        return tax / 100;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double CalculateTax(int[][] brackets, int income) \\n    {\\n        double tax = 0;\\n        int prev = 0;\\n        for (int i = 0; i < brackets.Length && income > 0; i++)\\n        {\\n            int value = Math.Min(income, brackets[i][0] - prev);\\n            tax += (double)value * brackets[i][1];\\n            income -= value;\\n            prev = brackets[i][0];\\n        }\\n        return tax / 100;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140971,
                "title": "c-easy-solution",
                "content": "Upvote if you like\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans = 0;\\n        for(int i=0;i<brackets.size();i++)\\n        {\\n            if(i==0)\\n            {\\n                double a = (double)min(income,brackets[i][0]);\\n                double b = (brackets[i][1])/100.0;\\n                income-=a;\\n                ans+=(a*b);\\n            }\\n            else\\n            {\\n                int x = brackets[i][0]-brackets[i-1][0];\\n                double a =(double) min(income,x);\\n                double b = (brackets[i][1])/100.0;\\n                income-=a;\\n                ans+=(a*b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans = 0;\\n        for(int i=0;i<brackets.size();i++)\\n        {\\n            if(i==0)\\n            {\\n                double a = (double)min(income,brackets[i][0]);\\n                double b = (brackets[i][1])/100.0;\\n                income-=a;\\n                ans+=(a*b);\\n            }\\n            else\\n            {\\n                int x = brackets[i][0]-brackets[i-1][0];\\n                double a =(double) min(income,x);\\n                double b = (brackets[i][1])/100.0;\\n                income-=a;\\n                ans+=(a*b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140951,
                "title": "java-easy",
                "content": "class Solution {\\n    public double calculateTax(int[][] a, int income) {\\n\\t       if(income ==0)\\n\\t    \\t   return 0;\\n\\t       \\n\\t       double ans = 0;\\n\\t       int prev =0;\\n\\t       \\n\\t       for( int[] tx : a)\\n\\t       {\\n\\t    \\t   int mx = Math.min(tx[0]-prev, income);\\n\\t    \\t   income -=mx;\\n\\t    \\t   ans+= (double) mx*tx[1]/100;\\n\\t    \\t   prev=tx[0];\\n\\t    \\t   if(income==0)\\n\\t    \\t\\t   break;\\n\\t       }\\n\\t        return ans;\\n\\t    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double calculateTax(int[][] a, int income) {\\n\\t       if(income ==0)\\n\\t    \\t   return 0;\\n\\t       \\n\\t       double ans = 0;\\n\\t       int prev =0;\\n\\t       \\n\\t       for( int[] tx : a)\\n\\t       {\\n\\t    \\t   int mx = Math.min(tx[0]-prev, income);\\n\\t    \\t   income -=mx;\\n\\t    \\t   ans+= (double) mx*tx[1]/100;\\n\\t    \\t   prev=tx[0];\\n\\t    \\t   if(income==0)\\n\\t    \\t\\t   break;\\n\\t       }",
                "codeTag": "Java"
            },
            {
                "id": 4085667,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans = 0;\\n        int prev = 0;\\n\\n        for (int[] b : brackets) {\\n        final int upper = b[0];\\n        final int percent = b[1];\\n        if (income < upper)\\n            return ans + (income - prev) * percent / 100.0;\\n        ans += (upper - prev) * percent / 100.0;\\n        prev = upper;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans = 0;\\n        int prev = 0;\\n\\n        for (int[] b : brackets) {\\n        final int upper = b[0];\\n        final int percent = b[1];\\n        if (income < upper)\\n            return ans + (income - prev) * percent / 100.0;\\n        ans += (upper - prev) * percent / 100.0;\\n        prev = upper;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064023,
                "title": "easy-cpp-solution-beats-91-53-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/1e80d985-ef4b-4583-85f5-ac011df7319d_1695121260.1156278.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans = 0;\\n        int sz = brackets.size(), prev = 0;\\n        for(int i=0; i<sz; i++){\\n            if(income > prev){\\n                int val = min((brackets[i][0] - prev), income-prev);\\n                ans += double( val * brackets[i][1] ) / double(100);\\n                prev = brackets[i][0];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans = 0;\\n        int sz = brackets.size(), prev = 0;\\n        for(int i=0; i<sz; i++){\\n            if(income > prev){\\n                int val = min((brackets[i][0] - prev), income-prev);\\n                ans += double( val * brackets[i][1] ) / double(100);\\n                prev = brackets[i][0];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031270,
                "title": "c-easiest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax = 0 ;\\n        if(income==0)\\n            return tax;\\n        // int tp = 0 ;\\n        for ( int i = 0 ; i < brackets.size() ; i++){\\n            if( income >= brackets[i][0]){\\n                if(i>0)\\n                    tax += abs(brackets[i][0] - brackets[i-1][0])*((brackets[i][1] / 1.0))/100.0;\\n                else tax += (brackets[i][0])*((brackets[i][1] / 1.0))/100.0;\\n\\n                // tp+= brackets[i][0];\\n            }\\n            else if (income < brackets[i][0] ){\\n                if(i>0)\\n                    tax += abs(income-brackets[i-1][0]) * (brackets[i][1] / 100.0);\\n                else tax += (double)(income) * (brackets[i][1] / 100.0);\\n                break;\\n            }\\n\\n            cout<< i << \" \" << tax<<endl;\\n\\n        }\\n\\n\\n        return tax;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax = 0 ;\\n        if(income==0)\\n            return tax;\\n        // int tp = 0 ;\\n        for ( int i = 0 ; i < brackets.size() ; i++){\\n            if( income >= brackets[i][0]){\\n                if(i>0)\\n                    tax += abs(brackets[i][0] - brackets[i-1][0])*((brackets[i][1] / 1.0))/100.0;\\n                else tax += (brackets[i][0])*((brackets[i][1] / 1.0))/100.0;\\n\\n                // tp+= brackets[i][0];\\n            }\\n            else if (income < brackets[i][0] ){\\n                if(i>0)\\n                    tax += abs(income-brackets[i-1][0]) * (brackets[i][1] / 100.0);\\n                else tax += (double)(income) * (brackets[i][1] / 100.0);\\n                break;\\n            }\\n\\n            cout<< i << \" \" << tax<<endl;\\n\\n        }\\n\\n\\n        return tax;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4028336,
                "title": "c-easy-code-beats-91",
                "content": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax =0.0;\\n        \\n        if(income == 0) {\\n            return tax;\\n        }\\n        \\n        if(brackets[0][0] > income ) {\\n            tax = tax + income*brackets[0][1]/100.0;\\n            return tax;\\n        }\\n        \\n        tax = tax + brackets[0][0]*brackets[0][1]/100.0;\\n        income = income - brackets[0][0];\\n        \\n        for(int i=1; i<brackets.size(); i++) {\\n            if((brackets[i][0] - brackets[i-1][0]) < income ) {\\n                tax = tax + (brackets[i][0] - brackets[i-1][0])*brackets[i][1]/100.0;\\n                    income = income - ( brackets[i][0] - brackets[i-1][0]);\\n                \\n            } else {\\n                tax = tax + income*brackets[i][1]/100.0;\\n                break;\\n            }\\n            \\n        }\\n        return tax;  \\n    }\\n};\\n\\n```\\n\\nPlease Upvote , if you like my solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax =0.0;\\n        \\n        if(income == 0) {\\n            return tax;\\n        }\\n        \\n        if(brackets[0][0] > income ) {\\n            tax = tax + income*brackets[0][1]/100.0;\\n            return tax;\\n        }\\n        \\n        tax = tax + brackets[0][0]*brackets[0][1]/100.0;\\n        income = income - brackets[0][0];\\n        \\n        for(int i=1; i<brackets.size(); i++) {\\n            if((brackets[i][0] - brackets[i-1][0]) < income ) {\\n                tax = tax + (brackets[i][0] - brackets[i-1][0])*brackets[i][1]/100.0;\\n                    income = income - ( brackets[i][0] - brackets[i-1][0]);\\n                \\n            } else {\\n                tax = tax + income*brackets[i][1]/100.0;\\n                break;\\n            }\\n            \\n        }\\n        return tax;  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021242,
                "title": "easy-java-solution-beats-100-time-and-95-memory-usage",
                "content": "# Approach\\nIterative\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!--  -->\\n\\n- Space complexity: O(1)\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans = 0;\\n\\n        if(brackets[0][0]<income){\\n            income-=brackets[0][0];\\n            ans+=((brackets[0][0]*brackets[0][1])/100.0);\\n        }\\n        else{\\n            ans+=((income*brackets[0][1])/100.0);\\n            income=0;\\n        }\\n\\n        for(int i=1; i<brackets.length; i++){\\n            if(income==0){\\n                break;\\n            }\\n            int a = brackets[i][0] - brackets[i-1][0];\\n            if(a<income){\\n                income-=a;\\n                ans+=((a*brackets[i][1])/100.0);\\n            }\\n            else{\\n                ans+=((income*brackets[i][1])/100.0);\\n                income=0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans = 0;\\n\\n        if(brackets[0][0]<income){\\n            income-=brackets[0][0];\\n            ans+=((brackets[0][0]*brackets[0][1])/100.0);\\n        }\\n        else{\\n            ans+=((income*brackets[0][1])/100.0);\\n            income=0;\\n        }\\n\\n        for(int i=1; i<brackets.length; i++){\\n            if(income==0){\\n                break;\\n            }\\n            int a = brackets[i][0] - brackets[i-1][0];\\n            if(a<income){\\n                income-=a;\\n                ans+=((a*brackets[i][1])/100.0);\\n            }\\n            else{\\n                ans+=((income*brackets[i][1])/100.0);\\n                income=0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018555,
                "title": "java-100-beats",
                "content": "\\nclass Solution {\\n    public double calculateTax(int[][] arr, int income) {\\n\\n        double sum = 0.0;\\n        int n=arr.length;\\n        int x=0;\\n        boolean flag=true;\\n        \\n        for(int i=0; i<n && flag; i++){\\n\\n            int day=arr[i][0]-x;\\n\\n            if(arr[i][0]>income){\\n                day=income-x;\\n                flag=false;\\n            }\\n            \\n            double tax=day*arr[i][1]/100.0;\\n            \\n            sum+=tax;\\n            x=arr[i][0];\\n\\n        }\\n\\n        return sum;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double calculateTax(int[][] arr, int income) {\\n\\n        double sum = 0.0;\\n        int n=arr.length;\\n        int x=0;\\n        boolean flag=true;\\n        \\n        for(int i=0; i<n && flag; i++){\\n\\n            int day=arr[i][0]-x;\\n\\n            if(arr[i][0]>income){\\n                day=income-x;\\n                flag=false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4016990,
                "title": "calculate-amount-paid-in-taxes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        // int prev = 0;\\n        // int i=0;\\n        // double ans =0;\\n        // int n = income;\\n        // while(income!=0&&i<brackets.length)\\n        // {\\n        //     if(income>=brackets[i][0])\\n        //     {\\n        //         int diff = brackets[i][0]-prev;\\n        //         income = income-diff;\\n        //         ans = ans+diff*(brackets[i][1]/100.0);\\n        //         prev = brackets[i][0];\\n        //     }\\n        //     else if(income<brackets[i][0])\\n        //     {\\n        //         ans = ans+(income)*(brackets[i][1]/100.0);\\n        //         income=0;\\n        //     }\\n        //     i++;\\n        // }\\n        // return ans;\\n         double ans = 0;\\n    int prev = 0;\\n\\n    for (int[] b : brackets) {\\n      final int upper = b[0];\\n      final int percent = b[1];\\n      if (income < upper)\\n        return ans + (income - prev) * percent / 100.0;\\n      ans += (upper - prev) * percent / 100.0;\\n      prev = upper;\\n    }\\n\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        // int prev = 0;\\n        // int i=0;\\n        // double ans =0;\\n        // int n = income;\\n        // while(income!=0&&i<brackets.length)\\n        // {\\n        //     if(income>=brackets[i][0])\\n        //     {\\n        //         int diff = brackets[i][0]-prev;\\n        //         income = income-diff;\\n        //         ans = ans+diff*(brackets[i][1]/100.0);\\n        //         prev = brackets[i][0];\\n        //     }\\n        //     else if(income<brackets[i][0])\\n        //     {\\n        //         ans = ans+(income)*(brackets[i][1]/100.0);\\n        //         income=0;\\n        //     }\\n        //     i++;\\n        // }\\n        // return ans;\\n         double ans = 0;\\n    int prev = 0;\\n\\n    for (int[] b : brackets) {\\n      final int upper = b[0];\\n      final int percent = b[1];\\n      if (income < upper)\\n        return ans + (income - prev) * percent / 100.0;\\n      ans += (upper - prev) * percent / 100.0;\\n      prev = upper;\\n    }\\n\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015547,
                "title": "faster-then-78",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nhandle edge cases at top where income is zero or if income is lower than the first bracket upper bound. Then the algorithm finds the highest bracket you are completely included in and calculates taxes there and then adds in the remainder between income and the highest bracket your income is completely included in\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        if income == 0:\\n            return 0\\n        if income < brackets[0][0]:\\n            return income * (brackets[0][1] / 100)\\n\\n        idx = 0\\n        for i in range(len(brackets)):\\n            if income > brackets[i][0]:\\n                idx = i\\n\\n        taxes = 0\\n        for i in range(idx + 1):\\n            if i == 0:\\n                taxes += (brackets[i][1] / 100) * brackets[i][0]\\n            else:\\n                taxes += (brackets[i][1] / 100) * (brackets[i][0] - brackets[i - 1][0])\\n        \\n        if idx + 1 < len(brackets):\\n            taxes += (income - brackets[idx][0]) * (brackets[idx + 1][1] / 100)\\n        return taxes\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        if income == 0:\\n            return 0\\n        if income < brackets[0][0]:\\n            return income * (brackets[0][1] / 100)\\n\\n        idx = 0\\n        for i in range(len(brackets)):\\n            if income > brackets[i][0]:\\n                idx = i\\n\\n        taxes = 0\\n        for i in range(idx + 1):\\n            if i == 0:\\n                taxes += (brackets[i][1] / 100) * brackets[i][0]\\n            else:\\n                taxes += (brackets[i][1] / 100) * (brackets[i][0] - brackets[i - 1][0])\\n        \\n        if idx + 1 < len(brackets):\\n            taxes += (income - brackets[idx][0]) * (brackets[idx + 1][1] / 100)\\n        return taxes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967321,
                "title": "2303-calculate-amount-paid-in-taxes",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prev = 0;\\n        double tax = 0;\\n\\n        for(int i = 0;i<brackets.length;i++){\\n            int temp = brackets[i][0] - prev;\\n            if(temp <= income){\\n                tax += (double) ((temp)*brackets[i][1])/100;\\n                prev = brackets[i][0];\\n                income -= temp;\\n            }\\n            else{\\n                if(income == 0){\\n                    break;\\n                }\\n                else{\\n                    temp = income;\\n                    tax += (double) ((temp)*brackets[i][1])/100;\\n                    break;\\n                }\\n            }\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prev = 0;\\n        double tax = 0;\\n\\n        for(int i = 0;i<brackets.length;i++){\\n            int temp = brackets[i][0] - prev;\\n            if(temp <= income){\\n                tax += (double) ((temp)*brackets[i][1])/100;\\n                prev = brackets[i][0];\\n                income -= temp;\\n            }\\n            else{\\n                if(income == 0){\\n                    break;\\n                }\\n                else{\\n                    temp = income;\\n                    tax += (double) ((temp)*brackets[i][1])/100;\\n                    break;\\n                }\\n            }\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960601,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  double calculateTax(vector<vector<int>>& brackets, int income) {\\n    double ans = 0;\\n    int prev = 0;\\n\\n    for (const vector<int>& b : brackets) {\\n      const int upper = b[0];\\n      const int percent = b[1];\\n      if (income < upper)\\n        return ans + (income - prev) * percent / 100.0;\\n      ans += (upper - prev) * percent / 100.0;\\n      prev = upper;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  double calculateTax(vector<vector<int>>& brackets, int income) {\\n    double ans = 0;\\n    int prev = 0;\\n\\n    for (const vector<int>& b : brackets) {\\n      const int upper = b[0];\\n      const int percent = b[1];\\n      if (income < upper)\\n        return ans + (income - prev) * percent / 100.0;\\n      ans += (upper - prev) * percent / 100.0;\\n      prev = upper;\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956093,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        total = 0\\n\\n        newbrackets = [[brackets[0][0], brackets[0][1]]]\\n        for i in range(1, len(brackets)):\\n            newbrackets.append([brackets[i][0] - brackets[i-1][0] , brackets[i][1]])\\n\\n        for j in newbrackets:\\n            if income >= j[0]:\\n                total += j[0] * (j[1]/100)\\n                income -= j[0]\\n            else:\\n                total += income * (j[1]/100)\\n                break\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        total = 0\\n\\n        newbrackets = [[brackets[0][0], brackets[0][1]]]\\n        for i in range(1, len(brackets)):\\n            newbrackets.append([brackets[i][0] - brackets[i-1][0] , brackets[i][1]])\\n\\n        for j in newbrackets:\\n            if income >= j[0]:\\n                total += j[0] * (j[1]/100)\\n                income -= j[0]\\n            else:\\n                total += income * (j[1]/100)\\n                break\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918659,
                "title": "python-one-liner-pairwise",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`pairwise` of `B` gives us upper limits `j` and lower limits `i` for a tax level and percentage `p`. So, we calculate `sum` of taxes for different tax levels until reaching our income limit `I`. \\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self,B,I):\\n        return sum(p/100*(min(I,j)-i) for (i,_),(j,p) in pairwise([[0,0]]+B) if i<I)\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self,B,I):\\n        return sum(p/100*(min(I,j)-i) for (i,_),(j,p) in pairwise([[0,0]]+B) if i<I)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917217,
                "title": "easy-go-solution",
                "content": "```\\nfunc calculateTax(brackets [][]int, income int) float64 {\\n        var tax float64\\n\\n        for i := 0; i < len(brackets); i++ {\\n                if income == 0 {\\n                        break\\n                }\\n\\n                var taxBracket int\\n\\n                bracket := brackets[i]\\n\\n                if i == 0 {\\n                        taxBracket = bracket[0]\\n                } else {\\n                        prevBracket := brackets[i-1]\\n                        taxBracket = bracket[0] - prevBracket[0]\\n                }\\n\\n                if taxBracket >= income {\\n                        taxBracket = income\\n                        income = 0\\n                } else {\\n                        income -= taxBracket\\n                }\\n\\n                taxPercentage := bracket[1]\\n\\n                tax += (float64(taxBracket) * float64(taxPercentage) / 100.0)\\n        }\\n\\n        return tax\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc calculateTax(brackets [][]int, income int) float64 {\\n        var tax float64\\n\\n        for i := 0; i < len(brackets); i++ {\\n                if income == 0 {\\n                        break\\n                }\\n\\n                var taxBracket int\\n\\n                bracket := brackets[i]\\n\\n                if i == 0 {\\n                        taxBracket = bracket[0]\\n                } else {\\n                        prevBracket := brackets[i-1]\\n                        taxBracket = bracket[0] - prevBracket[0]\\n                }\\n\\n                if taxBracket >= income {\\n                        taxBracket = income\\n                        income = 0\\n                } else {\\n                        income -= taxBracket\\n                }\\n\\n                taxPercentage := bracket[1]\\n\\n                tax += (float64(taxBracket) * float64(taxPercentage) / 100.0)\\n        }\\n\\n        return tax\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910401,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax=0.0;\\n        for(int i=0;i<brackets.length;i++){\\n            if(income>brackets[i][0]){\\n                if(i==0)\\n                    tax+=brackets[i][0]*brackets[i][1];\\n                else\\n                    tax+=(brackets[i][0]-brackets[i-1][0])*brackets[i][1];\\n            }else{\\n                if(i==0)\\n                    tax+=income*brackets[i][1];\\n                else\\n                    tax+=(income-brackets[i-1][0])*brackets[i][1];\\n                break;\\n            }\\n        }\\n        return tax/100;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax=0.0;\\n        for(int i=0;i<brackets.length;i++){\\n            if(income>brackets[i][0]){\\n                if(i==0)\\n                    tax+=brackets[i][0]*brackets[i][1];\\n                else\\n                    tax+=(brackets[i][0]-brackets[i-1][0])*brackets[i][1];\\n            }else{\\n                if(i==0)\\n                    tax+=income*brackets[i][1];\\n                else\\n                    tax+=(income-brackets[i-1][0])*brackets[i][1];\\n                break;\\n            }\\n        }\\n        return tax/100;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881431,
                "title": "java-fastest-solution-2",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int current = income;\\n        double tax = 0;\\n\\n        for(int i = 0; i < brackets.length; i++){\\n            int cur = 0;\\n            cur = i == 0 ? brackets[i][0] : brackets[i][0] - brackets[i-1][0];\\n\\n             if(cur < current){\\n                 tax += cur * (0.01d * brackets[i][1]);\\n                 current -= cur;\\n             }else{\\n                 tax += current *  (0.01d * brackets[i][1]);\\n                 return tax;\\n             }\\n        }\\n\\n        return -1.0d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int current = income;\\n        double tax = 0;\\n\\n        for(int i = 0; i < brackets.length; i++){\\n            int cur = 0;\\n            cur = i == 0 ? brackets[i][0] : brackets[i][0] - brackets[i-1][0];\\n\\n             if(cur < current){\\n                 tax += cur * (0.01d * brackets[i][1]);\\n                 current -= cur;\\n             }else{\\n                 tax += current *  (0.01d * brackets[i][1]);\\n                 return tax;\\n             }\\n        }\\n\\n        return -1.0d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837252,
                "title": "beats-100-in-runtime",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int len=brackets.length;\\n        int tax=0;\\n        int sum=0;\\n        if(income<=brackets[0][0]){\\n            tax=income*brackets[0][1];\\n            return tax*.01;\\n        }\\n        for(int i=0;i<len;i++){\\n            if(income>=brackets[i][0]){\\n                tax=tax+(brackets[i][0]-sum)*brackets[i][1];\\n                sum=brackets[i][0];\\n            }\\n            else{\\n                if(income<=brackets[0][0]){\\n                tax=income*brackets[0][1];\\n                return tax*.01;}\\n                tax=tax+(income-brackets[i-1][0])*brackets[i][1];\\n                return tax*.01;\\n            }\\n        }\\n        return tax*.01;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int len=brackets.length;\\n        int tax=0;\\n        int sum=0;\\n        if(income<=brackets[0][0]){\\n            tax=income*brackets[0][1];\\n            return tax*.01;\\n        }\\n        for(int i=0;i<len;i++){\\n            if(income>=brackets[i][0]){\\n                tax=tax+(brackets[i][0]-sum)*brackets[i][1];\\n                sum=brackets[i][0];\\n            }\\n            else{\\n                if(income<=brackets[0][0]){\\n                tax=income*brackets[0][1];\\n                return tax*.01;}\\n                tax=tax+(income-brackets[i-1][0])*brackets[i][1];\\n                return tax*.01;\\n            }\\n        }\\n        return tax*.01;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833792,
                "title": "easy-to-understand-solution-100-beats",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function(brackets, income) {\\n    let result = 0;\\n    let count = 0;\\n    \\n    for(let i = 0; i < brackets.length; i++) {\\n        if(count === income) break;\\n\\n        const [dollars, tax] = brackets[i];\\n\\n        let diff = 0;\\n\\n        if(dollars > income) {\\n            diff = dollars - income;\\n        }\\n\\n        result += ((dollars - count - diff) / 100) * tax;\\n        count = dollars - diff;\\n    }\\n\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function(brackets, income) {\\n    let result = 0;\\n    let count = 0;\\n    \\n    for(let i = 0; i < brackets.length; i++) {\\n        if(count === income) break;\\n\\n        const [dollars, tax] = brackets[i];\\n\\n        let diff = 0;\\n\\n        if(dollars > income) {\\n            diff = dollars - income;\\n        }\\n\\n        result += ((dollars - count - diff) / 100) * tax;\\n        count = dollars - diff;\\n    }\\n\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827691,
                "title": "javascript-100-run-time-96-memory-very-simple-with-clear-variable-names-d",
                "content": "# Intuition\\nIts a basic math problem, so don\\'t over think it\\n\\n# Approach\\niterate through the brackets, determine how much of the total income should be applied and calculate\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function(brackets, income) {\\n    let totalTaxesPaid = 0; \\n    let taxAppliedOn = 0;\\n    brackets.forEach((bracket) => {\\n        const [limit, percentage] = bracket; \\n        const valueToUse = Math.min(income, limit - taxAppliedOn); \\n        totalTaxesPaid += valueToUse * (percentage / 100)\\n        income -= valueToUse; \\n        taxAppliedOn += valueToUse; \\n    });\\n\\n    return totalTaxesPaid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function(brackets, income) {\\n    let totalTaxesPaid = 0; \\n    let taxAppliedOn = 0;\\n    brackets.forEach((bracket) => {\\n        const [limit, percentage] = bracket; \\n        const valueToUse = Math.min(income, limit - taxAppliedOn); \\n        totalTaxesPaid += valueToUse * (percentage / 100)\\n        income -= valueToUse; \\n        taxAppliedOn += valueToUse; \\n    });\\n\\n    return totalTaxesPaid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805973,
                "title": "java-code",
                "content": "\\n# Complexity\\n- Time complexity: O(n), n is the size of the brackets array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income)\\n    {\\n        double sum=0, pdct;\\n        for(int i = brackets.length-1; i>0; i--)\\n        {\\n            brackets[i][0] = brackets[i][0] - brackets[i-1][0];   \\n        }\\n\\n        for(int j =0; j<brackets.length; j++)\\n        {\\n            if(income>=brackets[j][0])\\n            {\\n                income -= brackets[j][0];\\n                pdct = (double)brackets[j][0]*(double)brackets[j][1];\\n                sum = sum + (pdct/100);\\n                \\n            }\\n\\n            else\\n            {\\n                pdct = (double)income*(double)brackets[j][1];\\n                sum = sum + (pdct/100);\\n                income=0;\\n                \\n                break;    \\n            }\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income)\\n    {\\n        double sum=0, pdct;\\n        for(int i = brackets.length-1; i>0; i--)\\n        {\\n            brackets[i][0] = brackets[i][0] - brackets[i-1][0];   \\n        }\\n\\n        for(int j =0; j<brackets.length; j++)\\n        {\\n            if(income>=brackets[j][0])\\n            {\\n                income -= brackets[j][0];\\n                pdct = (double)brackets[j][0]*(double)brackets[j][1];\\n                sum = sum + (pdct/100);\\n                \\n            }\\n\\n            else\\n            {\\n                pdct = (double)income*(double)brackets[j][1];\\n                sum = sum + (pdct/100);\\n                income=0;\\n                \\n                break;    \\n            }\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799521,
                "title": "iterative-approach-with-for-loop",
                "content": "# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = 0\\n        brackets = [[0, 0]] + brackets\\n        for i in range(1, len(brackets)):\\n            if income <= 0:\\n                break\\n            amount = brackets[i][0] - brackets[i - 1][0]\\n            if income < amount:\\n                tax += income * brackets[i][1] / 100\\n            else:\\n                tax += amount * brackets[i][1] / 100\\n            income -= amount\\n        return tax\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = 0\\n        brackets = [[0, 0]] + brackets\\n        for i in range(1, len(brackets)):\\n            if income <= 0:\\n                break\\n            amount = brackets[i][0] - brackets[i - 1][0]\\n            if income < amount:\\n                tax += income * brackets[i][1] / 100\\n            else:\\n                tax += amount * brackets[i][1] / 100\\n            income -= amount\\n        return tax\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772986,
                "title": "python-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        taxed = 0\\n        ans = 0\\n        for item in brackets:\\n            if taxed >= income:\\n                break;\\n            tax_num = min(income, item[0]) - taxed\\n            ans += tax_num * item[1] * 0.01\\n            taxed += tax_num\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        taxed = 0\\n        ans = 0\\n        for item in brackets:\\n            if taxed >= income:\\n                break;\\n            tax_num = min(income, item[0]) - taxed\\n            ans += tax_num * item[1] * 0.01\\n            taxed += tax_num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749982,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        b=[[0,0]]+brackets\\n        tax=0\\n        for i in range(1,len(b)):\\n            a=min(income,b[i][0]-b[i-1][0])\\n            tax+=a*b[i][1]/100\\n            income-=a\\n        tax+=income*b[-1][1]/100\\n        return tax\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        b=[[0,0]]+brackets\\n        tax=0\\n        for i in range(1,len(b)):\\n            a=min(income,b[i][0]-b[i-1][0])\\n            tax+=a*b[i][1]/100\\n            income-=a\\n        tax+=income*b[-1][1]/100\\n        return tax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723644,
                "title": "easy-understandable-solution-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& b, int income) {\\n        int n=b.size();\\n        int arr[n];\\n        arr[0]=b[0][0];\\n        for(int i=1;i<n;i++){\\n            arr[i]=b[i][0]-b[i-1][0];\\n        }\\n        for(int i=1;i<n;i++){\\n            b[i][0]=arr[i];\\n        }\\n        double tax=0;\\n        if(income==0){\\n            return 0;\\n        }\\n        int i=0;\\n        while(income>0){\\n            if(income>=b[i][0]){\\n                tax+=b[i][0]*b[i][1]*0.01;\\n                income-=b[i][0];\\n            }\\n            else{\\n                tax+=income*b[i][1]*0.01;\\n                income=0;\\n            }\\n            i++;\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& b, int income) {\\n        int n=b.size();\\n        int arr[n];\\n        arr[0]=b[0][0];\\n        for(int i=1;i<n;i++){\\n            arr[i]=b[i][0]-b[i-1][0];\\n        }\\n        for(int i=1;i<n;i++){\\n            b[i][0]=arr[i];\\n        }\\n        double tax=0;\\n        if(income==0){\\n            return 0;\\n        }\\n        int i=0;\\n        while(income>0){\\n            if(income>=b[i][0]){\\n                tax+=b[i][0]*b[i][1]*0.01;\\n                income-=b[i][0];\\n            }\\n            else{\\n                tax+=income*b[i][1]*0.01;\\n                income=0;\\n            }\\n            i++;\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706193,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function(brackets, income) {\\n    let sum = 0;\\n    let prev = 0;\\n    for (const [amt, num] of brackets) {\\n        const current = Math.min(income, amt - prev);\\n        const tax = current * (num / 100);\\n        income -= current;\\n        sum += tax;\\n        prev = amt;\\n        if (income <= 0) return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function(brackets, income) {\\n    let sum = 0;\\n    let prev = 0;\\n    for (const [amt, num] of brackets) {\\n        const current = Math.min(income, amt - prev);\\n        const tax = current * (num / 100);\\n        income -= current;\\n        sum += tax;\\n        prev = amt;\\n        if (income <= 0) return sum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3682572,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans = 0;\\n        if (brackets[0][0] <= income){\\n            double percent = brackets[0][1]/100.0;\\n            ans += brackets[0][0]*percent;\\n            income -= brackets[0][0];\\n        }\\n        else if (brackets[0][0] > income){\\n            double percent = brackets[0][1]/100.0;\\n            return income*percent;\\n        }\\n\\n        for (int i=1 ; i<brackets.size() ; i++){\\n            if (brackets[i][0]-brackets[i-1][0] <= income){\\n                double percent = brackets[i][1]/100.0;\\n                ans += (brackets[i][0] - brackets[i-1][0])*percent;\\n                income -= brackets[i][0]-brackets[i-1][0];\\n            }\\n            else if (brackets[i][0]-brackets[i-1][0] > income && income > 0){\\n                double percent = brackets[i][1]/100.0;\\n                ans += income*percent;\\n                break;\\n            }\\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans = 0;\\n        if (brackets[0][0] <= income){\\n            double percent = brackets[0][1]/100.0;\\n            ans += brackets[0][0]*percent;\\n            income -= brackets[0][0];\\n        }\\n        else if (brackets[0][0] > income){\\n            double percent = brackets[0][1]/100.0;\\n            return income*percent;\\n        }\\n\\n        for (int i=1 ; i<brackets.size() ; i++){\\n            if (brackets[i][0]-brackets[i-1][0] <= income){\\n                double percent = brackets[i][1]/100.0;\\n                ans += (brackets[i][0] - brackets[i-1][0])*percent;\\n                income -= brackets[i][0]-brackets[i-1][0];\\n            }\\n            else if (brackets[i][0]-brackets[i-1][0] > income && income > 0){\\n                double percent = brackets[i][1]/100.0;\\n                ans += income*percent;\\n                break;\\n            }\\n        } \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680012,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        int prev = 0;\\n        int i =0;\\n        double tax;\\n\\n        while(i < brackets.size()){\\n            int actual = min(brackets[i][0], income);\\n            tax += ((actual - prev) * brackets[i][1]) /100.0;\\n            prev = brackets[i][0];\\n\\n            if(brackets[i][0] >= income) break;\\n            i++;\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        int prev = 0;\\n        int i =0;\\n        double tax;\\n\\n        while(i < brackets.size()){\\n            int actual = min(brackets[i][0], income);\\n            tax += ((actual - prev) * brackets[i][1]) /100.0;\\n            prev = brackets[i][0];\\n\\n            if(brackets[i][0] >= income) break;\\n            i++;\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669890,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double output = 0.0;\\n        double upper = brackets[0][0];\\n        output += Math.min(income, upper) / 100.0 * (double) brackets[0][1];\\n        income -= Math.min(income, upper);\\n        for(int i = 1; i < brackets.length; i++) {\\n            upper = (double) brackets[i][0] - brackets[i - 1][0];\\n            double pay = Math.min(income, upper) / 100.0 * brackets[i][1];\\n            output += pay;\\n            income -= Math.min(income, upper);\\n            if (income <= 0 ) {\\n                return output;\\n            }            \\n        }\\n        return output;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double output = 0.0;\\n        double upper = brackets[0][0];\\n        output += Math.min(income, upper) / 100.0 * (double) brackets[0][1];\\n        income -= Math.min(income, upper);\\n        for(int i = 1; i < brackets.length; i++) {\\n            upper = (double) brackets[i][0] - brackets[i - 1][0];\\n            double pay = Math.min(income, upper) / 100.0 * brackets[i][1];\\n            output += pay;\\n            income -= Math.min(income, upper);\\n            if (income <= 0 ) {\\n                return output;\\n            }            \\n        }\\n        return output;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659217,
                "title": "python3-easy-to-understand-o-n-runtime-o-1-space",
                "content": "# Intuition\\nLoop through brackets to calculate taxes while keeping track of the previous upper bounds to get the taxable amount.\\n\\n# Approach\\n1. Initialize variables: tax and prevUpper\\n2. Loop through brackets\\n3. Find difference between current upper bound and previous upper bound\\n4. Check if income is greater than or equal to 0\\n5. Check if income is less than the difference between the upper bound and previous bound so we can work with the income available if less.\\n6. Calculate new tax and update variable\\n7. Subtract the difference between the upper bound and previous bound from the current income\\n8. Update prevUpper variable\\n9. Once income is negative break and return the tax\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ runtime\\n\\n- Space complexity:\\nNo auxiliary data structure used O(1)\\n\\n# Code\\n```\\nclass Solution:\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = 0\\n        prevUpper = 0\\n\\n        for upper, percent in brackets:\\n            #Difference in upper bounds\\n            upperDiff = upper - prevUpper\\n            if income >= 0:\\n                #Check if income is less than upperDiff\\n                if income < upperDiff: \\n                    upperDiff = income\\n                tax += (percent / 100) * upperDiff\\n                income -= upperDiff\\n                prevUpper = upper\\n            else:\\n                break\\n        return tax\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = 0\\n        prevUpper = 0\\n\\n        for upper, percent in brackets:\\n            #Difference in upper bounds\\n            upperDiff = upper - prevUpper\\n            if income >= 0:\\n                #Check if income is less than upperDiff\\n                if income < upperDiff: \\n                    upperDiff = income\\n                tax += (percent / 100) * upperDiff\\n                income -= upperDiff\\n                prevUpper = upper\\n            else:\\n                break\\n        return tax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652290,
                "title": "easy-hi-hai",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;  \\n        if(income==0){\\n            return ans;\\n        }\\n        int prev=0; \\n        for(int i=0;i<brackets.size();i++){\\n            int actual=min(brackets[i][0],income);\\n            ans+=((actual-prev)*brackets[i][1]*1.0)/100.0;\\n            if(brackets[i][0]>=income){\\n                break;\\n            }\\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;  \\n        if(income==0){\\n            return ans;\\n        }\\n        int prev=0; \\n        for(int i=0;i<brackets.size();i++){\\n            int actual=min(brackets[i][0],income);\\n            ans+=((actual-prev)*brackets[i][1]*1.0)/100.0;\\n            if(brackets[i][0]>=income){\\n                break;\\n            }\\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647456,
                "title": "python-intuitive-beats-100-runtime",
                "content": "# Complexity\\n- Time complexity:\\n- O(n) - Need to visit each bracket at least once\\n- But no more than the income, so could be covered in less time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1) - no extra space needed, just save tax calculated\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def calculateTax(self, brackets, income):\\n        \"\"\"\\n        :type brackets: List[List[int]]\\n        :type income: int\\n        :rtype: float\\n        \"\"\"\\n        t = 0\\n        pu = 0\\n        for u,p in brackets:\\n            a = min(income, u-pu)\\n            t += (a)*(p)/(float)(100)\\n            pu = u\\n            income -= a\\n            # print(t)\\n            if income <= 0:\\n                break\\n        return t\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def calculateTax(self, brackets, income):\\n        \"\"\"\\n        :type brackets: List[List[int]]\\n        :type income: int\\n        :rtype: float\\n        \"\"\"\\n        t = 0\\n        pu = 0\\n        for u,p in brackets:\\n            a = min(income, u-pu)\\n            t += (a)*(p)/(float)(100)\\n            pu = u\\n            income -= a\\n            # print(t)\\n            if income <= 0:\\n                break\\n        return t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642662,
                "title": "simple-python-solution-with-1-pass",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        output = 0\\n        last = 0\\n        for i in brackets:\\n            if income > 0: \\n                localTemp = min(abs(i[0] - last), income)\\n                output+= ((localTemp * i[1])/100)\\n                income -= min(abs(i[0] - last), income)\\n            last = i[0]\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        output = 0\\n        last = 0\\n        for i in brackets:\\n            if income > 0: \\n                localTemp = min(abs(i[0] - last), income)\\n                output+= ((localTemp * i[1])/100)\\n                income -= min(abs(i[0] - last), income)\\n            last = i[0]\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598679,
                "title": "0-ms-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double result = 0;\\n        int previous = 0;\\n        int currentBracket = 0;\\n        while (income > 0) {\\n            previous = brackets[currentBracket][0] - previous;\\n            result += Math.min(previous, income) * brackets[currentBracket][1] / 100.0;\\n            income -= previous;\\n            previous = brackets[currentBracket][0];\\n            currentBracket++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double result = 0;\\n        int previous = 0;\\n        int currentBracket = 0;\\n        while (income > 0) {\\n            previous = brackets[currentBracket][0] - previous;\\n            result += Math.min(previous, income) * brackets[currentBracket][1] / 100.0;\\n            income -= previous;\\n            previous = brackets[currentBracket][0];\\n            currentBracket++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582294,
                "title": "c-t-c-beats-99-8-s-c-beats-99-8-using-min-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax = 0;\\n        tax += min(brackets[0][0],income)*(brackets[0][1]);\\n        int inc = income - brackets[0][0];\\n        int i=1;\\n        while(inc>0){\\n                tax += min(brackets[i][0]-brackets[i-1][0],inc)*(brackets[i][1]);\\n                inc = income - brackets[i][0];\\n                i++;\\n        }\\n\\n        return tax/100;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax = 0;\\n        tax += min(brackets[0][0],income)*(brackets[0][1]);\\n        int inc = income - brackets[0][0];\\n        int i=1;\\n        while(inc>0){\\n                tax += min(brackets[i][0]-brackets[i-1][0],inc)*(brackets[i][1]);\\n                inc = income - brackets[i][0];\\n                i++;\\n        }\\n\\n        return tax/100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559080,
                "title": "simple-and-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        int split=0;\\n        double tax=0;\\n        for(int i=0;i<brackets.size();i++){\\n            \\n                if(split<income){\\n                    if(brackets[i][0]<=income){\\n                    tax+=(brackets[i][0]-split)*(brackets[i][1]/100.0);\\n                    split=brackets[i][0];\\n                    }\\n                    else{\\n                        tax+=(income-split)*(brackets[i][1]/100.0);\\n                        split=income;;\\n                    }\\n                    cout<<split<<\" \";\\n                }\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        int split=0;\\n        double tax=0;\\n        for(int i=0;i<brackets.size();i++){\\n            \\n                if(split<income){\\n                    if(brackets[i][0]<=income){\\n                    tax+=(brackets[i][0]-split)*(brackets[i][1]/100.0);\\n                    split=brackets[i][0];\\n                    }\\n                    else{\\n                        tax+=(income-split)*(brackets[i][1]/100.0);\\n                        split=income;;\\n                    }\\n                    cout<<split<<\" \";\\n                }\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3553870,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double result = 0;\\n        int previous = 0;\\n        for (const auto& bracket : brackets) {\\n            result += min(bracket[0] - previous, income) * bracket[1] / 100.;\\n            income -= min(bracket[0] - previous, income);\\n            previous = bracket[0];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double result = 0;\\n        int previous = 0;\\n        for (const auto& bracket : brackets) {\\n            result += min(bracket[0] - previous, income) * bracket[1] / 100.;\\n            income -= min(bracket[0] - previous, income);\\n            previous = bracket[0];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526569,
                "title": "calculate-amount-paid-in-taxes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        result = prev = 0\\n        for u, p in brackets:\\n            result += max((min(u, income)-prev)*p/100.0, 0.0)\\n            prev = u\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        result = prev = 0\\n        for u, p in brackets:\\n            result += max((min(u, income)-prev)*p/100.0, 0.0)\\n            prev = u\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518154,
                "title": "easy-understandable-faster-best-solution-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;\\n        int n=brackets.size();\\n        vector<int>prev(n);\\n        int temp=min(income,brackets[0][0]);\\n        prev[0]=temp;\\n        for(int i=1;i<n;i++){\\n            \\n            prev[i]=min(income,brackets[i][0]);\\n            if(prev[i]>=brackets[i-1][0])\\n            prev[i]=prev[i]-brackets[i-1][0];\\n            else\\n            prev[i]=0;\\n\\n        }\\n        for(int i=0;i<n;i++){\\n            ans+=1.0*(prev[i]*brackets[i][1])/100;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;\\n        int n=brackets.size();\\n        vector<int>prev(n);\\n        int temp=min(income,brackets[0][0]);\\n        prev[0]=temp;\\n        for(int i=1;i<n;i++){\\n            \\n            prev[i]=min(income,brackets[i][0]);\\n            if(prev[i]>=brackets[i-1][0])\\n            prev[i]=prev[i]-brackets[i-1][0];\\n            else\\n            prev[i]=0;\\n\\n        }\\n        for(int i=0;i<n;i++){\\n            ans+=1.0*(prev[i]*brackets[i][1])/100;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490303,
                "title": "calculate-amount-paid-in-taxes",
                "content": "# Code\\n```\\nclass Solution:\\n    def calculateTax(self, b: List[List[int]], c: int) -> float:\\n        s = 0\\n        a = b[0][0] *(b[0][1]/100)\\n        d = b[0][0]\\n        if c==0:\\n            return 0\\n        elif d>c:\\n            return c*(b[0][1]/100)\\n        else:\\n            for i in range(1,len(b)):\\n                p = b[i][0] - b[i-1][0]\\n                if d+p<=c:\\n                    d+=p\\n                    a+= p*(b[i][1]/100)\\n                else:\\n                    a += (p-((d+p)-c)) *(b[i][1]/100)\\n                    break\\n            return (a)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, b: List[List[int]], c: int) -> float:\\n        s = 0\\n        a = b[0][0] *(b[0][1]/100)\\n        d = b[0][0]\\n        if c==0:\\n            return 0\\n        elif d>c:\\n            return c*(b[0][1]/100)\\n        else:\\n            for i in range(1,len(b)):\\n                p = b[i][0] - b[i-1][0]\\n                if d+p<=c:\\n                    d+=p\\n                    a+= p*(b[i][1]/100)\\n                else:\\n                    a += (p-((d+p)-c)) *(b[i][1]/100)\\n                    break\\n            return (a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481545,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double total = 0;\\n        for (int idx = 0; idx < brackets.length; idx++) {\\n            int upper = brackets[idx][0];\\n            double percent = (float)(brackets[idx][1])/100;\\n            if (idx > 0) {\\n                upper = upper - brackets[idx - 1][0];\\n            }\\n            if (income >= upper) {\\n                income = income - upper;\\n                total = total + (double)(upper * percent);\\n            } else {\\n                total = total + (double)(income * percent);\\n                income = 0;\\n            }\\n            if (income == 0) {\\n                break;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double total = 0;\\n        for (int idx = 0; idx < brackets.length; idx++) {\\n            int upper = brackets[idx][0];\\n            double percent = (float)(brackets[idx][1])/100;\\n            if (idx > 0) {\\n                upper = upper - brackets[idx - 1][0];\\n            }\\n            if (income >= upper) {\\n                income = income - upper;\\n                total = total + (double)(upper * percent);\\n            } else {\\n                total = total + (double)(income * percent);\\n                income = 0;\\n            }\\n            if (income == 0) {\\n                break;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464242,
                "title": "2303-calculate-amount-paid-in-taxes-easy-solution",
                "content": "```\\nvar calculateTax = function(brackets, income) {\\n    let tax=0;\\n    \\n    for(let i=0;i<brackets.length;i++){\\n        if(i==0){\\n           if(income<brackets[i][0]){\\n            tax+=(income)*((brackets[i][1])/100);\\n            break;\\n           }\\n           else{\\n            income=income-brackets[i][0];\\n            tax+=brackets[i][0]*((brackets[i][1])/100);\\n           }\\n        }\\n\\n         else{\\n            if((brackets[i][0]-brackets[i-1][0])<=income){\\n                income=income-(brackets[i][0]-brackets[i-1][0]);\\n                tax+=(brackets[i][0]-brackets[i-1][0])*((brackets[i][1])/100);\\n                \\n               }\\n    \\n               else if((brackets[i][0]-brackets[i-1][0])>income){\\n                tax+=(income)*((brackets[i][1])/100);\\n                break;\\n               }\\n         } \\n    }\\n    return tax.toFixed(5)\\n};",
                "solutionTags": [],
                "code": "```\\nvar calculateTax = function(brackets, income) {\\n    let tax=0;\\n    \\n    for(let i=0;i<brackets.length;i++){\\n        if(i==0){\\n           if(income<brackets[i][0]){\\n            tax+=(income)*((brackets[i][1])/100);\\n            break;\\n           }\\n           else{\\n            income=income-brackets[i][0];\\n            tax+=brackets[i][0]*((brackets[i][1])/100);\\n           }\\n        }\\n\\n         else{\\n            if((brackets[i][0]-brackets[i-1][0])<=income){\\n                income=income-(brackets[i][0]-brackets[i-1][0]);\\n                tax+=(brackets[i][0]-brackets[i-1][0])*((brackets[i][1])/100);\\n                \\n               }\\n    \\n               else if((brackets[i][0]-brackets[i-1][0])>income){\\n                tax+=(income)*((brackets[i][1])/100);\\n                break;\\n               }\\n         } \\n    }\\n    return tax.toFixed(5)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3444153,
                "title": "c-easy-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax = 0;\\n        for(int i = 0; i < brackets.size(); i++){\\n            if(income==0) break;\\n            if(i == 0){\\n                if(income >= brackets[i][0]) {\\n                    tax+=(double)brackets[i][0]*brackets[i][1]/100;\\n                    income-=brackets[i][0];\\n                }\\n                else {\\n                    tax+=(double)income*brackets[i][1]/100;\\n                    income=0;\\n                }\\n            }else{\\n                if(income >= (brackets[i][0] - brackets[i-1][0])) {\\n                    int temp = brackets[i][0] - brackets[i-1][0];\\n                    tax += (double)temp*brackets[i][1]/100;\\n                    income-=temp;\\n                } else {\\n                    tax += (double)income*brackets[i][1]/100;\\n                    income=0;\\n                }\\n            }\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double tax = 0;\\n        for(int i = 0; i < brackets.size(); i++){\\n            if(income==0) break;\\n            if(i == 0){\\n                if(income >= brackets[i][0]) {\\n                    tax+=(double)brackets[i][0]*brackets[i][1]/100;\\n                    income-=brackets[i][0];\\n                }\\n                else {\\n                    tax+=(double)income*brackets[i][1]/100;\\n                    income=0;\\n                }\\n            }else{\\n                if(income >= (brackets[i][0] - brackets[i-1][0])) {\\n                    int temp = brackets[i][0] - brackets[i-1][0];\\n                    tax += (double)temp*brackets[i][1]/100;\\n                    income-=temp;\\n                } else {\\n                    tax += (double)income*brackets[i][1]/100;\\n                    income=0;\\n                }\\n            }\\n        }\\n        return tax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432051,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function (brackets, income) {\\n    let result = 0\\n    let past = 0\\n    for (let i = 0; i < brackets.length; i++) {\\n        const bracket = brackets[i]\\n        const diff = bracket[0] - past\\n        const multiplier = bracket[1] / 100\\n        if (diff < income) {\\n            result += diff * multiplier\\n            income -= diff\\n        } else {\\n            result += income * multiplier\\n            income = 0\\n        }\\n        if (income === 0) break\\n        past = bracket[0]\\n    }\\n\\n    return result + income\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function (brackets, income) {\\n    let result = 0\\n    let past = 0\\n    for (let i = 0; i < brackets.length; i++) {\\n        const bracket = brackets[i]\\n        const diff = bracket[0] - past\\n        const multiplier = bracket[1] / 100\\n        if (diff < income) {\\n            result += diff * multiplier\\n            income -= diff\\n        } else {\\n            result += income * multiplier\\n            income = 0\\n        }\\n        if (income === 0) break\\n        past = bracket[0]\\n    }\\n\\n    return result + income\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419821,
                "title": "calculate-amount-paid-in-taxes-easiest-with-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;\\n        for(int i=0; i<brackets.size(); i++)\\n        {\\n            int dollar;\\n            if(i == 0)\\n                dollar = brackets[i][0];\\n            else\\n                dollar = brackets[i][0] - brackets[i-1][0];\\n            if(dollar > income)\\n                dollar = income;\\n            ans += dollar * brackets[i][1]/100.00;\\n            income -= dollar;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;\\n        for(int i=0; i<brackets.size(); i++)\\n        {\\n            int dollar;\\n            if(i == 0)\\n                dollar = brackets[i][0];\\n            else\\n                dollar = brackets[i][0] - brackets[i-1][0];\\n            if(dollar > income)\\n                dollar = income;\\n            ans += dollar * brackets[i][1]/100.00;\\n            income -= dollar;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367717,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def calculateTax(self, brackets, income):\\n        prevLimit = ans = 0\\n        for limit, percent  in brackets:\\n            amt = income if income < (limit - prevLimit) else (limit - prevLimit)\\n          \\n            ans += amt * percent / 100.00\\n            income -= amt\\n            prevLimit = limit\\n            \\n        return ans\\n         \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def calculateTax(self, brackets, income):\\n        prevLimit = ans = 0\\n        for limit, percent  in brackets:\\n            amt = income if income < (limit - prevLimit) else (limit - prevLimit)\\n          \\n            ans += amt * percent / 100.00\\n            income -= amt\\n            prevLimit = limit\\n            \\n        return ans\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349975,
                "title": "python-check-from-the-last-backet",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = 0\\n        idx = len(brackets) - 2\\n        while idx >= 0:\\n            upper, rate = brackets[idx]\\n            prev_upper, prev_rate = brackets[idx + 1]\\n            if income > upper:\\n                tax += (income - upper) * prev_rate / 100\\n                income = upper\\n            idx -= 1\\n        tax += income * brackets[0][1] / 100\\n        return tax\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        tax = 0\\n        idx = len(brackets) - 2\\n        while idx >= 0:\\n            upper, rate = brackets[idx]\\n            prev_upper, prev_rate = brackets[idx + 1]\\n            if income > upper:\\n                tax += (income - upper) * prev_rate / 100\\n                income = upper\\n            idx -= 1\\n        tax += income * brackets[0][1] / 100\\n        return tax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344811,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[][] $brackets\\n     * @param Integer $income\\n     * @return Float\\n     */\\n    function calculateTax($brackets, $income) {\\n        if($income == 0){\\n            return 0;\\n        }\\n        $res = [];\\n        for($i = 0; $i < count($brackets); $i++){\\n            if($i == 0){\\n                if($brackets[$i][0] > $income){\\n                        $temp = $income  * $brackets[$i][1]/100;\\n                        array_push($res, $temp);\\n                        break;\\n                    }else{\\n                        $temp = $brackets[$i][0] * $brackets[$i][1]/100;\\n                    }\\n            }else{\\n                if($i == (count($brackets) - 1)){\\n                    if($brackets[$i][0] > $income){\\n                        $temp = ($income - $brackets[$i-1][0])  * \\n                        $brackets[$i][1]/100;\\n                    }else{\\n\\n                        $temp = ($brackets[$i][0] - $brackets[$i-1][0]) * \\n                        $brackets[$i][1]/100;\\n                    }\\n\\n                }else{\\n                    if($brackets[$i][0] > $income){\\n                        $temp = ($income - $brackets[$i-1][0])  * \\n                        $brackets[$i][1]/100;\\n                        array_push($res, $temp);\\n                        break;\\n                    }else{\\n\\n                        $temp = ($brackets[$i][0] - $brackets[$i-1][0]) * \\n                        $brackets[$i][1]/100;\\n                    }\\n                        $temp = ($brackets[$i][0] - $brackets[$i-1][0]) * \\n                        $brackets[$i][1]/100;\\n                }\\n            }\\n            array_push($res, $temp);\\n        }\\n        print_r($res);\\n        return abs(array_sum($res));\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[][] $brackets\\n     * @param Integer $income\\n     * @return Float\\n     */\\n    function calculateTax($brackets, $income) {\\n        if($income == 0){\\n            return 0;\\n        }\\n        $res = [];\\n        for($i = 0; $i < count($brackets); $i++){\\n            if($i == 0){\\n                if($brackets[$i][0] > $income){\\n                        $temp = $income  * $brackets[$i][1]/100;\\n                        array_push($res, $temp);\\n                        break;\\n                    }else{\\n                        $temp = $brackets[$i][0] * $brackets[$i][1]/100;\\n                    }\\n            }else{\\n                if($i == (count($brackets) - 1)){\\n                    if($brackets[$i][0] > $income){\\n                        $temp = ($income - $brackets[$i-1][0])  * \\n                        $brackets[$i][1]/100;\\n                    }else{\\n\\n                        $temp = ($brackets[$i][0] - $brackets[$i-1][0]) * \\n                        $brackets[$i][1]/100;\\n                    }\\n\\n                }else{\\n                    if($brackets[$i][0] > $income){\\n                        $temp = ($income - $brackets[$i-1][0])  * \\n                        $brackets[$i][1]/100;\\n                        array_push($res, $temp);\\n                        break;\\n                    }else{\\n\\n                        $temp = ($brackets[$i][0] - $brackets[$i-1][0]) * \\n                        $brackets[$i][1]/100;\\n                    }\\n                        $temp = ($brackets[$i][0] - $brackets[$i-1][0]) * \\n                        $brackets[$i][1]/100;\\n                }\\n            }\\n            array_push($res, $temp);\\n        }\\n        print_r($res);\\n        return abs(array_sum($res));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340940,
                "title": "python-beats-98-beginners-pov",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        # If income is zero, the tax is zero\\n        if income == 0:\\n            return 0\\n\\n        # Initialize variables for tracking the upper limit of the current tax bracket and the total tax\\n        upperlast = 0\\n        tax = 0\\n\\n        # Iterate over each tax bracket and calculate the tax for the portion of income within that bracket\\n        for upper, percent in brackets:\\n            # If the current bracket\\'s upper limit is greater than the income, adjust it to use the income as the upper limit\\n            if income < upper:\\n                upper = income\\n\\n            # Calculate the amount of income within the current bracket\\n            uppertax = upper - upperlast\\n\\n            # Calculate the tax for the income within the current bracket and add it to the total tax\\n            tax += uppertax * (percent / 100)\\n\\n            # Update the upper limit of the previous tax bracket for use in the next iteration\\n            upperlast=upper\\n\\n        # Return the total tax\\n        return tax\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        # If income is zero, the tax is zero\\n        if income == 0:\\n            return 0\\n\\n        # Initialize variables for tracking the upper limit of the current tax bracket and the total tax\\n        upperlast = 0\\n        tax = 0\\n\\n        # Iterate over each tax bracket and calculate the tax for the portion of income within that bracket\\n        for upper, percent in brackets:\\n            # If the current bracket\\'s upper limit is greater than the income, adjust it to use the income as the upper limit\\n            if income < upper:\\n                upper = income\\n\\n            # Calculate the amount of income within the current bracket\\n            uppertax = upper - upperlast\\n\\n            # Calculate the tax for the income within the current bracket and add it to the total tax\\n            tax += uppertax * (percent / 100)\\n\\n            # Update the upper limit of the previous tax bracket for use in the next iteration\\n            upperlast=upper\\n\\n        # Return the total tax\\n        return tax\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331170,
                "title": "java-simple-solution-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        int prevIncome = 0;\\n        for (int[] bracket : brackets) {\\n            int upper = bracket[0];\\n            int percent = bracket[1];\\n            \\n            if (income >= upper) {\\n                tax += (upper - prevIncome) * percent / 100d;\\n                prevIncome = upper;\\n            } else {\\n                tax += (income - prevIncome) * percent / 100d;\\n                return tax;\\n            }\\n        }\\n        \\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        int prevIncome = 0;\\n        for (int[] bracket : brackets) {\\n            int upper = bracket[0];\\n            int percent = bracket[1];\\n            \\n            if (income >= upper) {\\n                tax += (upper - prevIncome) * percent / 100d;\\n                prevIncome = upper;\\n            } else {\\n                tax += (income - prevIncome) * percent / 100d;\\n                return tax;\\n            }\\n        }\\n        \\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301560,
                "title": "c-simple-solution-time-o-n-space-o-1",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) {\\n        double tax = 0.0;\\n        for(int i = 0, prevUpper  = 0; i < brackets.Length; i++) {\\n            int amount = Math.Min(brackets[i][0] - prevUpper, income);\\n            tax += (amount * brackets[i][1]) / 100.0;\\n\\n            income -= amount;\\n            if(income <= 0) break;\\n            prevUpper = brackets[i][0];\\n        }\\n\\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) {\\n        double tax = 0.0;\\n        for(int i = 0, prevUpper  = 0; i < brackets.Length; i++) {\\n            int amount = Math.Min(brackets[i][0] - prevUpper, income);\\n            tax += (amount * brackets[i][1]) / 100.0;\\n\\n            income -= amount;\\n            if(income <= 0) break;\\n            prevUpper = brackets[i][0];\\n        }\\n\\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292546,
                "title": "java-easiest-solution",
                "content": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n\\n        double ans = 0;\\n        double oldUpper = 0;\\n\\n        for (int[] arr : brackets){\\n\\n            double upper = arr[0];\\n            double percentage = arr[1];\\n\\n            if (income >= upper){\\n                ans = ans + (((upper - oldUpper) * percentage) / 100);\\n                if (income == upper){\\n                    break;\\n                }\\n            }\\n            else {\\n                ans = ans + (((income - oldUpper) * percentage) / 100);\\n                break;\\n            }\\n\\n            oldUpper = upper;\\n        }\\n\\n        return ans;        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n\\n        double ans = 0;\\n        double oldUpper = 0;\\n\\n        for (int[] arr : brackets){\\n\\n            double upper = arr[0];\\n            double percentage = arr[1];\\n\\n            if (income >= upper){\\n                ans = ans + (((upper - oldUpper) * percentage) / 100);\\n                if (income == upper){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3281089,
                "title": "javascript-logic",
                "content": "# Code\\n```\\n// T: O(n) | S: O(1)\\nvar calculateTax = function(brackets, income) {\\n    let tax = 0;\\n    let prev = 0;\\n    for (let [b, r] of brackets) {\\n        let inc = Math.min(income - prev, b - prev);\\n        if (inc < 0) break;\\n        tax += (inc * r / 100);\\n        prev = b;\\n    }\\n    return tax;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// T: O(n) | S: O(1)\\nvar calculateTax = function(brackets, income) {\\n    let tax = 0;\\n    let prev = 0;\\n    for (let [b, r] of brackets) {\\n        let inc = Math.min(income - prev, b - prev);\\n        if (inc < 0) break;\\n        tax += (inc * r / 100);\\n        prev = b;\\n    }\\n    return tax;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269580,
                "title": "python-one-pass-clean-code",
                "content": "# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        result = 0\\n        prev = 0\\n\\n        for upper, percent in brackets:\\n            if income > prev:\\n                amount = min(upper - prev, income - prev)\\n                result += amount * percent\\n                prev = upper\\n        \\n        return result / 100\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        result = 0\\n        prev = 0\\n\\n        for upper, percent in brackets:\\n            if income > prev:\\n                amount = min(upper - prev, income - prev)\\n                result += amount * percent\\n                prev = upper\\n        \\n        return result / 100\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269058,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double res=0;\\n        int i=0;\\n        int b=0;\\n        double ans = 0;\\n        while(income != 0 && i <  brackets.size()){\\n            int d=brackets[i][0]-b;\\n            int t=min(income,d);\\n            income-=t;\\n            res+=brackets[i][1]*t;\\n            b=brackets[i][0] ;\\n            i++;\\n        }\\n        return res/100;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double res=0;\\n        int i=0;\\n        int b=0;\\n        double ans = 0;\\n        while(income != 0 && i <  brackets.size()){\\n            int d=brackets[i][0]-b;\\n            int t=min(income,d);\\n            income-=t;\\n            res+=brackets[i][1]*t;\\n            b=brackets[i][0] ;\\n            i++;\\n        }\\n        return res/100;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268562,
                "title": "c-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double prev=0,ans=0;\\n        for(int i=0;i<brackets.size();i++)\\n        {\\n            int upper=min(brackets[i][0],income);\\n            ans+=((upper-prev)*brackets[i][1])/100;\\n            if(brackets[i][0]>=income)\\n            {\\n                break;\\n            }\\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double prev=0,ans=0;\\n        for(int i=0;i<brackets.size();i++)\\n        {\\n            int upper=min(brackets[i][0],income);\\n            ans+=((upper-prev)*brackets[i][1])/100;\\n            if(brackets[i][0]>=income)\\n            {\\n                break;\\n            }\\n            prev=brackets[i][0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268188,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        ans = 0 \\n        temp = 0\\n        for i , j in brackets:\\n            if i < income:\\n                ans += (i - temp ) * j / 100\\n                temp = i\\n            else:\\n                ans += (income - temp) * j / 100\\n                return ans\\n        return ans\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        ans = 0 \\n        temp = 0\\n        for i , j in brackets:\\n            if i < income:\\n                ans += (i - temp ) * j / 100\\n                temp = i\\n            else:\\n                ans += (income - temp) * j / 100\\n                return ans\\n        return ans\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260717,
                "title": "java-beats-100-easy-solution",
                "content": "# Complexity\\n- Time complexity:- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        if(income <= brackets[0][0]){\\n            tax += (double)income*brackets[0][1]/100;\\n            return tax;\\n        }\\n        else{\\n            income -= brackets[0][0];\\n            tax += (double)brackets[0][0]*brackets[0][1]/100;\\n        }\\n        for(int i = 1;i<brackets.length;i++){\\n            int x = brackets[i][0] - brackets[i-1][0];\\n            if(income <= x){\\n                tax += (double)income*brackets[i][1]/100;\\n                break;\\n            }\\n            else{\\n                income -= x;\\n                tax += (double)x*brackets[i][1]/100;\\n            }\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        if(income <= brackets[0][0]){\\n            tax += (double)income*brackets[0][1]/100;\\n            return tax;\\n        }\\n        else{\\n            income -= brackets[0][0];\\n            tax += (double)brackets[0][0]*brackets[0][1]/100;\\n        }\\n        for(int i = 1;i<brackets.length;i++){\\n            int x = brackets[i][0] - brackets[i-1][0];\\n            if(income <= x){\\n                tax += (double)income*brackets[i][1]/100;\\n                break;\\n            }\\n            else{\\n                income -= x;\\n                tax += (double)x*brackets[i][1]/100;\\n            }\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246141,
                "title": "sexyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double a=0;\\n        if(income==0){\\n            return a;\\n        }\\n        int prev=0;\\n        for(int i=0;i<brackets.size();i++){\\n                int b=min(income,brackets[i][0]);\\n                a+=((b-prev)*(brackets[i][1]*1.0))/100.0;\\n                // income-=brackets[i][0];\\n                if(brackets[i][0]>=income){\\n                break;\\n            }\\n            prev=brackets[i][0];}\\n    return a;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double a=0;\\n        if(income==0){\\n            return a;\\n        }\\n        int prev=0;\\n        for(int i=0;i<brackets.size();i++){\\n                int b=min(income,brackets[i][0]);\\n                a+=((b-prev)*(brackets[i][1]*1.0))/100.0;\\n                // income-=brackets[i][0];\\n                if(brackets[i][0]>=income){\\n                break;\\n            }\\n            prev=brackets[i][0];}\\n    return a;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240122,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n         double ans=0;\\n         if(income==0){\\n             return ans;\\n         } \\n         int prev=0;\\n         for(int i=0;i<brackets.size();i++){\\n             int actual=min(brackets[i][0],income);\\n             ans+=((actual-prev)*brackets[i][1]*1.0)/100.0;\\n             if(brackets[i][0]>=income){\\n                 break;\\n             }\\n             prev=brackets[i][0];\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n         double ans=0;\\n         if(income==0){\\n             return ans;\\n         } \\n         int prev=0;\\n         for(int i=0;i<brackets.size();i++){\\n             int actual=min(brackets[i][0],income);\\n             ans+=((actual-prev)*brackets[i][1]*1.0)/100.0;\\n             if(brackets[i][0]>=income){\\n                 break;\\n             }\\n             prev=brackets[i][0];\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238872,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double result = 0;\\n        int prev = 0;\\n        for (const auto& b : brackets) {\\n            result += max((min(b[0], income) - prev) * b[1] / 100.0, 0.0);\\n            prev = b[0];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double result = 0;\\n        int prev = 0;\\n        for (const auto& b : brackets) {\\n            result += max((min(b[0], income) - prev) * b[1] / 100.0, 0.0);\\n            prev = b[0];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229500,
                "title": "c-o-n-while-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe tax amount for each element in brackets can be calculated through iteration while keeping track of the income amount.  Once the remaining balance of income reaches 0, no tax is needed.  I actually was not sure how to use the income info by reading the problem alone, but after seeing failed test cases, I could deduce how the income is to be used in calculating the total tax.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Have a guard clause that if the income is 0, return 0.0.\\n2. Declare three int variables and one double - index of the brackets jagged array, prevAmount to keep track of the previous amount in the brackets, and the currentAmount, which represents the current amount of brackets[index][0].  The doulbe totalTax is the answer to return.\\n3. Have a while loop that runs if the remaining income balance is still greater than 0.\\n4. Create a helper function to check if the remaining income is >=  currentAmount - prevAmount or not.  Based on that information, calculate how much the tax amount is.  Add the tax amount for each iteration to totalTax.\\n5. Once the while loop ends, return totalTax.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) {\\n\\n        double totalTax = 0.0;\\n        if (income <= 0) return totalTax;\\n\\n        int index = 0;\\n        int prevAmount = 0;\\n        int currentAmount = 0;\\n            \\n        while (income > 0)\\n        {\\n            currentAmount = brackets[index][0];\\n            \\n            totalTax += taxAmount(currentAmount - prevAmount, index);\\n\\n            index++;\\n            prevAmount = currentAmount;\\n\\n        }\\n        return totalTax;\\n\\n        // helper function\\n        double taxAmount(int amount, int pointer)\\n        {\\n            if (income >= amount)\\n            {\\n                income -= amount;\\n                return amount * brackets[pointer][1] * 0.01;\\n            }\\n            else\\n            {\\n                int remainder = income; // a temp variable for calculation\\n                income = 0;\\n                return remainder * brackets[pointer][1] * 0.01;\\n            }\\n                \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) {\\n\\n        double totalTax = 0.0;\\n        if (income <= 0) return totalTax;\\n\\n        int index = 0;\\n        int prevAmount = 0;\\n        int currentAmount = 0;\\n            \\n        while (income > 0)\\n        {\\n            currentAmount = brackets[index][0];\\n            \\n            totalTax += taxAmount(currentAmount - prevAmount, index);\\n\\n            index++;\\n            prevAmount = currentAmount;\\n\\n        }\\n        return totalTax;\\n\\n        // helper function\\n        double taxAmount(int amount, int pointer)\\n        {\\n            if (income >= amount)\\n            {\\n                income -= amount;\\n                return amount * brackets[pointer][1] * 0.01;\\n            }\\n            else\\n            {\\n                int remainder = income; // a temp variable for calculation\\n                income = 0;\\n                return remainder * brackets[pointer][1] * 0.01;\\n            }\\n                \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221326,
                "title": "java-o-n-runtime-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double result=0;\\n        int index=0;\\n        int upperBound=0;\\n        while(income>0){\\n            int min = Math.min(income, brackets[index][0]-upperBound);\\n            result+=Double.valueOf(min*brackets[index][1])/100;\\n            income-=min;\\n            upperBound=brackets[index++][0];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double result=0;\\n        int index=0;\\n        int upperBound=0;\\n        while(income>0){\\n            int min = Math.min(income, brackets[index][0]-upperBound);\\n            result+=Double.valueOf(min*brackets[index][1])/100;\\n            income-=min;\\n            upperBound=brackets[index++][0];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183244,
                "title": "java-easy-solution-o-n-1s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prevIncome = 0;\\n        double res = 0;\\n        for(int i =0; i<brackets.length; i++){\\n            double diff = brackets[i][0] - prevIncome;\\n            if(diff > income){\\n                res += (income*brackets[i][1]/100.0);\\n                income = 0;\\n            }else{\\n                res += (diff*brackets[i][1])/100;\\n                income -= diff;\\n            }\\n            prevIncome = brackets[i][0];\\n            if(income == 0) return res;\\n            //System.out.println(prevIncome+\" \"+res+ \" \"+ income +\" \"+ diff + \"  \"+(diff*brackets[i][1]/100));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prevIncome = 0;\\n        double res = 0;\\n        for(int i =0; i<brackets.length; i++){\\n            double diff = brackets[i][0] - prevIncome;\\n            if(diff > income){\\n                res += (income*brackets[i][1]/100.0);\\n                income = 0;\\n            }else{\\n                res += (diff*brackets[i][1])/100;\\n                income -= diff;\\n            }\\n            prevIncome = brackets[i][0];\\n            if(income == 0) return res;\\n            //System.out.println(prevIncome+\" \"+res+ \" \"+ income +\" \"+ diff + \"  \"+(diff*brackets[i][1]/100));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164022,
                "title": "swift",
                "content": "# Code\\n```\\nclass Solution {\\n    func calculateTax(_ brackets: [[Int]], _ income: Int) -> Double {\\n\\n            var currentSum = income\\n            var index = 0\\n            var temp: Double = 0\\n            var previous = 0\\n\\n            while currentSum > 0 {\\n\\n                let upper = min(brackets[index][0], income)\\n                let precent = brackets[index][1]\\n\\n                var amountToTax = upper - previous\\n                temp += Double(amountToTax) * Double(Double(precent) / Double(100)) \\n\\n                previous = upper\\n                currentSum -= amountToTax\\n                index += 1\\n            }\\n\\n            return temp        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func calculateTax(_ brackets: [[Int]], _ income: Int) -> Double {\\n\\n            var currentSum = income\\n            var index = 0\\n            var temp: Double = 0\\n            var previous = 0\\n\\n            while currentSum > 0 {\\n\\n                let upper = min(brackets[index][0], income)\\n                let precent = brackets[index][1]\\n\\n                var amountToTax = upper - previous\\n                temp += Double(amountToTax) * Double(Double(precent) / Double(100)) \\n\\n                previous = upper\\n                currentSum -= amountToTax\\n                index += 1\\n            }\\n\\n            return temp        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157854,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& b, int ind) {\\n        if(ind==0) return 0;\\n        double ans = 0;\\n        for(int i=0;i<b.size();i++){\\n            if(ind<=0) break;\\n            if(i==0){\\n                if(b[i][0]>ind) {ans+=ind*b[i][1];ind=0;}\\n                else {ind-=b[i][0];ans+=b[i][0]*b[i][1];}\\n            }\\n            else{\\n                int temp = b[i][0]-b[i-1][0];\\n                if(temp>ind) {ans+=ind*b[i][1];ind=0;}\\n                else {ind-=temp;ans+=temp*b[i][1];}\\n            }\\n        }\\n        return ans*0.01;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& b, int ind) {\\n        if(ind==0) return 0;\\n        double ans = 0;\\n        for(int i=0;i<b.size();i++){\\n            if(ind<=0) break;\\n            if(i==0){\\n                if(b[i][0]>ind) {ans+=ind*b[i][1];ind=0;}\\n                else {ind-=b[i][0];ans+=b[i][0]*b[i][1];}\\n            }\\n            else{\\n                int temp = b[i][0]-b[i-1][0];\\n                if(temp>ind) {ans+=ind*b[i][1];ind=0;}\\n                else {ind-=temp;ans+=temp*b[i][1];}\\n            }\\n        }\\n        return ans*0.01;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137786,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn calculate_tax(brackets: Vec<Vec<i32>>, income: i32) -> f64 {\\n        let (mut res, mut pre) = (0,0);\\n        for br in &brackets {\\n            let (up, rate) = (br[0], br[1]);\\n            res += (up.min(income) - pre) * rate;\\n            if income <= up {break;}\\n            pre = up;\\n        }\\n        res as f64 * 0.01\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn calculate_tax(brackets: Vec<Vec<i32>>, income: i32) -> f64 {\\n        let (mut res, mut pre) = (0,0);\\n        for br in &brackets {\\n            let (up, rate) = (br[0], br[1]);\\n            res += (up.min(income) - pre) * rate;\\n            if income <= up {break;}\\n            pre = up;\\n        }\\n        res as f64 * 0.01\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3129368,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brakets, int income) {\\n        if(income==0){\\n            return (double)(0);\\n        }\\n        double ans = (double)0;\\n\\n        for(int i=0; i<brakets.length; i++){\\n            if(income==0){\\n                break;\\n            }\\n            if(i==0){\\n                if(brakets[i][0]<=income){\\n                    ans += ((double)brakets[i][0]*brakets[i][1])/100;\\n                    income -= brakets[i][0];\\n                }else{\\n                    ans += ((double)income*brakets[i][1])/100;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(brakets[i][0]-brakets[i-1][0] <=income){\\n                    ans += ((double)(brakets[i][0]-brakets[i-1][0])*brakets[i][1])/100;\\n                    income -= (brakets[i][0]-brakets[i-1][0]);\\n                }else{\\n                    ans += ((double)income*brakets[i][1])/100;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brakets, int income) {\\n        if(income==0){\\n            return (double)(0);\\n        }\\n        double ans = (double)0;\\n\\n        for(int i=0; i<brakets.length; i++){\\n            if(income==0){\\n                break;\\n            }\\n            if(i==0){\\n                if(brakets[i][0]<=income){\\n                    ans += ((double)brakets[i][0]*brakets[i][1])/100;\\n                    income -= brakets[i][0];\\n                }else{\\n                    ans += ((double)income*brakets[i][1])/100;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(brakets[i][0]-brakets[i-1][0] <=income){\\n                    ans += ((double)(brakets[i][0]-brakets[i-1][0])*brakets[i][1])/100;\\n                    income -= (brakets[i][0]-brakets[i-1][0]);\\n                }else{\\n                    ans += ((double)income*brakets[i][1])/100;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128515,
                "title": "simple-java-solution",
                "content": "\\n# Approach\\n- The method initializes a totalTaxes variable to 0.0 and checks if the income is less than or equal to 0. If so, it returns totalTaxes as 0.0. If not, the method iterates through each tax bracket specified in the brackets array.\\n\\n- For each tax bracket, the method checks if the income falls into that bracket. If so, the method calculates the tax owed for that bracket and subtracts the income that has been taxed from the income variable. If the income does not fall into the current bracket, the method exits the loop.\\n\\n- After the loop has completed, the method checks if any income remains untaxed. If so, it uses the tax rate of the last bracket in the brackets array to calculate the tax owed on the remaining income.\\n\\n- Finally, the method returns the total tax owed, which is the sum of the tax owed for each taxed bracket and the tax owed for any remaining income, multiplied by 0.01 to convert the result from a percentage to a decimal.\\n\\n\\n# Complexity\\n- Time complexity:`O(n)`, where n is the number of tax brackets specified in the brackets array.\\n\\n- Space complexity:`O(1)`, as it only uses a constant amount of additional memory throughout its execution.\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double totalTaxes = 0.00;\\n        int bracketsLength = brackets.length, i;\\n        if (income <= 0) {\\n            return totalTaxes;\\n        }\\n        for (i = 0; i < bracketsLength; i++) {\\n            if (i == 0 && brackets[i][0] <= income) {\\n                totalTaxes += (brackets[i][0] * brackets[i][1]);\\n                income -= brackets[i][0];\\n                continue;\\n            }\\n            if ((i - 1) >= 0 && (brackets[i][0] - brackets[i - 1][0]) <= income) {\\n                totalTaxes += ((brackets[i][0] - brackets[i - 1][0]) * (brackets[i][1]));\\n                income -= brackets[i][0] - brackets[i - 1][0];\\n            } else {\\n                break;\\n            }\\n        }\\n        if (income > 0) {\\n            totalTaxes += income * brackets[i >= bracketsLength ? i - 1 : i][1] * decimalMultiplier;\\n        }\\n        return totalTaxes * 0.01;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double totalTaxes = 0.00;\\n        int bracketsLength = brackets.length, i;\\n        if (income <= 0) {\\n            return totalTaxes;\\n        }\\n        for (i = 0; i < bracketsLength; i++) {\\n            if (i == 0 && brackets[i][0] <= income) {\\n                totalTaxes += (brackets[i][0] * brackets[i][1]);\\n                income -= brackets[i][0];\\n                continue;\\n            }\\n            if ((i - 1) >= 0 && (brackets[i][0] - brackets[i - 1][0]) <= income) {\\n                totalTaxes += ((brackets[i][0] - brackets[i - 1][0]) * (brackets[i][1]));\\n                income -= brackets[i][0] - brackets[i - 1][0];\\n            } else {\\n                break;\\n            }\\n        }\\n        if (income > 0) {\\n            totalTaxes += income * brackets[i >= bracketsLength ? i - 1 : i][1] * decimalMultiplier;\\n        }\\n        return totalTaxes * 0.01;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120758,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        prev = 0\\n        gross_inc = 0\\n        for tax in brackets:\\n            if income-prev<0:\\n                break\\n            money = min(income-prev, tax[0]-prev)\\n            prev = tax[0]\\n            gross_inc+= round(money * tax[1]/100, 5)\\n        return gross_inc\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        prev = 0\\n        gross_inc = 0\\n        for tax in brackets:\\n            if income-prev<0:\\n                break\\n            money = min(income-prev, tax[0]-prev)\\n            prev = tax[0]\\n            gross_inc+= round(money * tax[1]/100, 5)\\n        return gross_inc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111461,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        n=len(brackets)\\n        if income==0: return 0\\n        ans=0\\n        for i in range(0,n):\\n            if(i==0):\\n                if(income>=brackets[i][0]):\\n                    ans+=(brackets[i][0]*(brackets[i][1])*1.0)/100\\n                else:\\n                    ans+=(income * (brackets[i][1])*1.0)/100\\n                income=income-brackets[i][0]\\n            elif income>0 and i>=1:\\n                if brackets[i][0]-brackets[i-1][0]>income:\\n                    ans+=((income) * (brackets[i][1])*1.0)/100\\n                    break\\n                else:\\n                    ans+=((brackets[i][0]-brackets[i-1][0])*(brackets[i][1])*1.0)/100\\n                income=income-(brackets[i][0]-brackets[i-1][0])\\n            print(income)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        n=len(brackets)\\n        if income==0: return 0\\n        ans=0\\n        for i in range(0,n):\\n            if(i==0):\\n                if(income>=brackets[i][0]):\\n                    ans+=(brackets[i][0]*(brackets[i][1])*1.0)/100\\n                else:\\n                    ans+=(income * (brackets[i][1])*1.0)/100\\n                income=income-brackets[i][0]\\n            elif income>0 and i>=1:\\n                if brackets[i][0]-brackets[i-1][0]>income:\\n                    ans+=((income) * (brackets[i][1])*1.0)/100\\n                    break\\n                else:\\n                    ans+=((brackets[i][0]-brackets[i-1][0])*(brackets[i][1])*1.0)/100\\n                income=income-(brackets[i][0]-brackets[i-1][0])\\n            print(income)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108901,
                "title": "simple-cpp-datta-bayo",
                "content": "Simple Solution Easy to understand.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, long long income) {\\nlong double ans = 0.0;\\n        int i = 0;\\n        while (income > 0 && i < brackets.size()) {\\n            int upper = brackets[i][0];\\n            int percent = brackets[i][1];\\n            int check = upper - (i > 0 ? brackets[i-1][0] : 0);\\n            if (income > check) {\\n                ans += check * percent * 0.01;\\n                income -= check;\\n            } else {\\n                ans += income * percent * 0.01;\\n                income = 0;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, long long income) {\\nlong double ans = 0.0;\\n        int i = 0;\\n        while (income > 0 && i < brackets.size()) {\\n            int upper = brackets[i][0];\\n            int percent = brackets[i][1];\\n            int check = upper - (i > 0 ? brackets[i-1][0] : 0);\\n            if (income > check) {\\n                ans += check * percent * 0.01;\\n                income -= check;\\n            } else {\\n                ans += income * percent * 0.01;\\n                income = 0;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095023,
                "title": "linear-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on your income, you have 3 dollars in the 1st tax bracket, 4 dollars in the 2nd tax bracket, and 3 dollars in the 3rd tax bracket.\\nThe tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.\\nIn total, you pay $3 * 0.5 + $4 * 0.1 + $3 * 2.5 = $2.65 in taxes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->We will maintain three variables \"left\" to denote the remaing tax income,tax for total tax calculated and limit that has upper[i - 1]. At each bracket we will calculate the taxedIncome and left i.e income remaining after taxedIncome. To calculate taxedIncome we will take the min(left,slab[0] - limit) the later is for the incread slab amount\\n\\n# Complexity\\n- Time complexity: O(1) here number of slabs, let\\'s say  N are between 1-100. So in worst case we will loop 100 times. Time Comlexity is O(100) i.e constant  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) no extra Space used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int i = 0; //move through tax salb\\n        double left = income; // left salary\\n        double tax = 0.0;\\n        double limit = 0.0;\\n        \\n        while(left > 0){\\n            int [] slab = brackets[i];\\n            double per = slab[1];\\n            // if(slab[0] == null){\\n            //     tax = tax + left * per;\\n            //     break;\\n            // }\\n            double taxedIncome = Math.min(left,slab[0] - limit);\\n            tax = tax + taxedIncome * per;\\n            left = left - taxedIncome;\\n            limit = slab[0];\\n            i++;\\n        }\\n        return tax/100;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int i = 0; //move through tax salb\\n        double left = income; // left salary\\n        double tax = 0.0;\\n        double limit = 0.0;\\n        \\n        while(left > 0){\\n            int [] slab = brackets[i];\\n            double per = slab[1];\\n            // if(slab[0] == null){\\n            //     tax = tax + left * per;\\n            //     break;\\n            // }\\n            double taxedIncome = Math.min(left,slab[0] - limit);\\n            tax = tax + taxedIncome * per;\\n            left = left - taxedIncome;\\n            limit = slab[0];\\n            i++;\\n        }\\n        return tax/100;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090797,
                "title": "python-straightforward-solution-faster-than-36-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        if income == 0:\\n            return 0.0\\n        num_brackets = len(brackets)\\n        res = 0\\n        for i in range(num_brackets):\\n            if i==0: \\n                curr_upper = brackets[i][0]\\n                curr_rate = brackets[i][1]/100\\n                if curr_upper>=income:\\n                    res += income*curr_rate\\n                    break \\n                elif curr_upper<income:\\n                    res += curr_upper*curr_rate  \\n                    continue  \\n            elif i>=1:        \\n                curr_upper = brackets[i][0]\\n                curr_rate = brackets[i][1]/100\\n                prev_upper = brackets[i-1][0]\\n                if curr_upper>=income:\\n                    res += (income-prev_upper)*curr_rate\\n                    break \\n                elif curr_upper < income:     \\n                    res += (curr_upper-prev_upper)*curr_rate\\n                    continue \\n        return res            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        if income == 0:\\n            return 0.0\\n        num_brackets = len(brackets)\\n        res = 0\\n        for i in range(num_brackets):\\n            if i==0: \\n                curr_upper = brackets[i][0]\\n                curr_rate = brackets[i][1]/100\\n                if curr_upper>=income:\\n                    res += income*curr_rate\\n                    break \\n                elif curr_upper<income:\\n                    res += curr_upper*curr_rate  \\n                    continue  \\n            elif i>=1:        \\n                curr_upper = brackets[i][0]\\n                curr_rate = brackets[i][1]/100\\n                prev_upper = brackets[i-1][0]\\n                if curr_upper>=income:\\n                    res += (income-prev_upper)*curr_rate\\n                    break \\n                elif curr_upper < income:     \\n                    res += (curr_upper-prev_upper)*curr_rate\\n                    continue \\n        return res            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090408,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;\\n        if(income==0) return 0;\\n        for(int i=0;i<brackets.size();i++){\\n            if(i==0){\\n                if(brackets[i][0]<income){\\n                    double amount=(brackets[i][0]*brackets[i][1]);\\n                    ans+=amount/100;\\n\\n                }else{\\n                    double amount=(income*brackets[i][1]);\\n                    ans+=amount/100;\\n                    return ans;\\n                }\\n                \\n            }else{\\n                if(brackets[i][0]<income){\\n                    double amount=(brackets[i][0]-brackets[i-1][0])*brackets[i][1];\\n                    ans+=amount/100;\\n                }else{\\n                    double amount=(income-brackets[i-1][0])*brackets[i][1];\\n                    ans+=amount/100;\\n                    return ans;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double ans=0;\\n        if(income==0) return 0;\\n        for(int i=0;i<brackets.size();i++){\\n            if(i==0){\\n                if(brackets[i][0]<income){\\n                    double amount=(brackets[i][0]*brackets[i][1]);\\n                    ans+=amount/100;\\n\\n                }else{\\n                    double amount=(income*brackets[i][1]);\\n                    ans+=amount/100;\\n                    return ans;\\n                }\\n                \\n            }else{\\n                if(brackets[i][0]<income){\\n                    double amount=(brackets[i][0]-brackets[i-1][0])*brackets[i][1];\\n                    ans+=amount/100;\\n                }else{\\n                    double amount=(income-brackets[i-1][0])*brackets[i][1];\\n                    ans+=amount/100;\\n                    return ans;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082897,
                "title": "python-descriptive-solution-easy-to-understand-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Total taxes paid = sum of (taxes paid in each bracket)\\n2. Taxes paid in each bracket = taxable income of that bracket * tax rate of that bracket\\n3. Taxable income of each bucket = minimum of\\n    1. income left, i.e. income that are not taxed by prev bracket\\n    2. upper bound of current bracket - upper bound of prev bracket\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nScan through the brackets list and get the taxes paid in each bracket. Return the sum of taxes paid in each bracket.\\n\\n# Complexity\\n- Time complexity: O(n). We only scan the brackets list once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1). We only use a constant space to store the taxes paid.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        taxes = 0\\n        i = 0\\n        while income > 0 and i < len(brackets):\\n            upper, perc = brackets[i][0], brackets[i][1]\\n            if i == 0:\\n                last_bucket_upper = 0\\n            else:\\n                last_bucket_upper = brackets[i-1][0]\\n            taxable_income = min((upper - last_bucket_upper), income)\\n            taxes += taxable_income * perc / 100\\n            income -= taxable_income\\n            i += 1\\n\\n        return taxes\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        taxes = 0\\n        i = 0\\n        while income > 0 and i < len(brackets):\\n            upper, perc = brackets[i][0], brackets[i][1]\\n            if i == 0:\\n                last_bucket_upper = 0\\n            else:\\n                last_bucket_upper = brackets[i-1][0]\\n            taxable_income = min((upper - last_bucket_upper), income)\\n            taxes += taxable_income * perc / 100\\n            income -= taxable_income\\n            i += 1\\n\\n        return taxes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074930,
                "title": "c",
                "content": "```\\ndouble calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\\n    double ans ;\\n    if(income > brackets[0][0]) \\n        ans = (double)brackets[0][0] * brackets[0][1]/100  ;\\n    else{\\n        ans = (double)income * brackets[0][1]/100  ;\\n        return ans ;\\n    }\\n    for(int i = 1 ; i < bracketsSize; i++){\\n        if(income > brackets[i][0])\\n            ans += (double)(brackets[i][0] - brackets[i-1][0]) * brackets[i][1]/100  ;\\n        else{\\n            ans += (double)(income - brackets[i-1][0]) * brackets[i][1]/100  ;\\n            break ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\\n    double ans ;\\n    if(income > brackets[0][0]) \\n        ans = (double)brackets[0][0] * brackets[0][1]/100  ;\\n    else{\\n        ans = (double)income * brackets[0][1]/100  ;\\n        return ans ;\\n    }\\n    for(int i = 1 ; i < bracketsSize; i++){\\n        if(income > brackets[i][0])\\n            ans += (double)(brackets[i][0] - brackets[i-1][0]) * brackets[i][1]/100  ;\\n        else{\\n            ans += (double)(income - brackets[i-1][0]) * brackets[i][1]/100  ;\\n            break ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3072880,
                "title": "very-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        //min(income, upperi) - prev.\\n        int prv = 0;\\n        double ans = 0;\\n        for(int i=0;i<brackets.size();i++)\\n        {\\n            int upperbond = brackets[i][0];\\n            int rate = brackets[i][1];\\n            \\n            int amt = min(income , upperbond) - prv;\\n            if(amt <= 0) break;\\n            ans = ans + (amt*(rate/100.00));\\n            prv = upperbond;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        //min(income, upperi) - prev.\\n        int prv = 0;\\n        double ans = 0;\\n        for(int i=0;i<brackets.size();i++)\\n        {\\n            int upperbond = brackets[i][0];\\n            int rate = brackets[i][1];\\n            \\n            int amt = min(income , upperbond) - prv;\\n            if(amt <= 0) break;\\n            ans = ans + (amt*(rate/100.00));\\n            prv = upperbond;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067073,
                "title": "java-beat-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans = 0;\\n        int prev = 0;\\n\\n        int i = 0;\\n        while(income > prev) {\\n            ans += (double)((Math.min(brackets[i][0], income) - prev) * brackets[i][1]) / 100;\\n            prev = Math.min(brackets[i++][0], income);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double ans = 0;\\n        int prev = 0;\\n\\n        int i = 0;\\n        while(income > prev) {\\n            ans += (double)((Math.min(brackets[i][0], income) - prev) * brackets[i][1]) / 100;\\n            prev = Math.min(brackets[i++][0], income);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066046,
                "title": "c-straightward-readable-solution-84ms-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) \\n    {\\n        var tax = 0.0;\\n\\n        for(int i=0, prevUpper=0; income > 0; i++)\\n        {\\n            var (upper, percent) = (brackets[i][0], brackets[i][1]);\\n\\n            var toTax = Math.Min(income, upper - prevUpper);\\n\\n            tax += toTax * percent / 100.0;\\n\\n            income -= toTax;\\n\\n            prevUpper = upper;\\n        }\\n\\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) \\n    {\\n        var tax = 0.0;\\n\\n        for(int i=0, prevUpper=0; income > 0; i++)\\n        {\\n            var (upper, percent) = (brackets[i][0], brackets[i][1]);\\n\\n            var toTax = Math.Min(income, upper - prevUpper);\\n\\n            tax += toTax * percent / 100.0;\\n\\n            income -= toTax;\\n\\n            prevUpper = upper;\\n        }\\n\\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051465,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) {\\n        if(brackets.Length == 0) return 0;\\n        int currentRangeUpperLimit = Math.Min(income, brackets[0][0]);\\n        double tax = currentRangeUpperLimit * ((double)brackets[0][1]/100);\\n        int total = income - currentRangeUpperLimit;\\n        for(int i =1;i<brackets.Length;i++)\\n        {\\n            currentRangeUpperLimit = Math.Min(total, brackets[i][0] - brackets[i-1][0]);\\n            tax = tax + (currentRangeUpperLimit * ((double)brackets[i][1]/100));\\n            total = total - currentRangeUpperLimit;\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) {\\n        if(brackets.Length == 0) return 0;\\n        int currentRangeUpperLimit = Math.Min(income, brackets[0][0]);\\n        double tax = currentRangeUpperLimit * ((double)brackets[0][1]/100);\\n        int total = income - currentRangeUpperLimit;\\n        for(int i =1;i<brackets.Length;i++)\\n        {\\n            currentRangeUpperLimit = Math.Min(total, brackets[i][0] - brackets[i-1][0]);\\n            tax = tax + (currentRangeUpperLimit * ((double)brackets[i][1]/100));\\n            total = total - currentRangeUpperLimit;\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045709,
                "title": "runtime-beats-98-85-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double d = 0;\\n        int a = 0;\\n        for (int i = 0; i < brackets.size(); i++){\\n            if ((brackets[i][0] - a) <= income){\\n                d += ((brackets[i][0] - a) * ( (double) brackets[i][1] / 100));\\n                income -= brackets[i][0] - a;\\n                a = brackets[i][0];\\n            } else {\\n                d += (income) * ((double) brackets[i][1] / 100);\\n                break;\\n            }\\n     \\n\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double d = 0;\\n        int a = 0;\\n        for (int i = 0; i < brackets.size(); i++){\\n            if ((brackets[i][0] - a) <= income){\\n                d += ((brackets[i][0] - a) * ( (double) brackets[i][1] / 100));\\n                income -= brackets[i][0] - a;\\n                a = brackets[i][0];\\n            } else {\\n                d += (income) * ((double) brackets[i][1] / 100);\\n                break;\\n            }\\n     \\n\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035705,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:Karunya university:Accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) \\n    {\\n       double finalresult=0;\\n\\t int prev=0;\\n\\t \\n\\t for (int[] con:brackets)\\n\\t {\\n\\t     int dollar=con[0];\\n\\t     int percentage=con[1];\\n\\t     \\n\\t     if (income>=dollar)\\n\\t     {\\n\\t        finalresult+=(dollar-prev)*percentage/100d;   \\n\\t        prev=dollar;\\n\\t     }\\n\\t     else\\n\\t     {\\n\\t         finalresult+=(income-prev)*percentage/100d;\\n\\t         return finalresult;\\n\\t     }\\n\\t }\\n\\treturn finalresult; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) \\n    {\\n       double finalresult=0;\\n\\t int prev=0;\\n\\t \\n\\t for (int[] con:brackets)\\n\\t {\\n\\t     int dollar=con[0];\\n\\t     int percentage=con[1];\\n\\t     \\n\\t     if (income>=dollar)\\n\\t     {\\n\\t        finalresult+=(dollar-prev)*percentage/100d;   \\n\\t        prev=dollar;\\n\\t     }\\n\\t     else\\n\\t     {\\n\\t         finalresult+=(income-prev)*percentage/100d;\\n\\t         return finalresult;\\n\\t     }\\n\\t }\\n\\treturn finalresult; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035698,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:Karunya university||Accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) \\n    {\\n       double finalresult=0;\\n\\t int prev=0;\\n\\t \\n\\t for (int[] con:brackets)\\n\\t {\\n\\t     int dollar=con[0];\\n\\t     int percentage=con[1];\\n\\t     \\n\\t     if (income>=dollar)\\n\\t     {\\n\\t        finalresult+=(dollar-prev)*percentage/100d;   \\n\\t        prev=dollar;\\n\\t     }\\n\\t     else\\n\\t     {\\n\\t         finalresult+=(income-prev)*percentage/100d;\\n\\t         return finalresult;\\n\\t     }\\n\\t }\\n\\treturn finalresult; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) \\n    {\\n       double finalresult=0;\\n\\t int prev=0;\\n\\t \\n\\t for (int[] con:brackets)\\n\\t {\\n\\t     int dollar=con[0];\\n\\t     int percentage=con[1];\\n\\t     \\n\\t     if (income>=dollar)\\n\\t     {\\n\\t        finalresult+=(dollar-prev)*percentage/100d;   \\n\\t        prev=dollar;\\n\\t     }\\n\\t     else\\n\\t     {\\n\\t         finalresult+=(income-prev)*percentage/100d;\\n\\t         return finalresult;\\n\\t     }\\n\\t }\\n\\treturn finalresult; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024434,
                "title": "c-solution",
                "content": "```\\n#define max(a,b) (a>b?a:b)\\n#define min(a,b) (a<b?a:b)\\ndouble calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\\n\\n    int lb = 0;\\n    double r = 0;\\n    \\n    for(int i = 0; i < bracketsSize; ++i)\\n    {\\n        double val = max(0, min(income, *(*(brackets + i))) - lb);\\n        r += (*(*(brackets + i)+1) * val)/100;\\n        lb = *(*(brackets + i));\\n    }\\n    \\n    return r;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define max(a,b) (a>b?a:b)\\n#define min(a,b) (a<b?a:b)\\ndouble calculateTax(int** brackets, int bracketsSize, int* bracketsColSize, int income){\\n\\n    int lb = 0;\\n    double r = 0;\\n    \\n    for(int i = 0; i < bracketsSize; ++i)\\n    {\\n        double val = max(0, min(income, *(*(brackets + i))) - lb);\\n        r += (*(*(brackets + i)+1) * val)/100;\\n        lb = *(*(brackets + i));\\n    }\\n    \\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3022026,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prev = 0;\\n        double result = 0;\\n        for (int[] b : brackets)\\n        {\\n            int dollars = b[0] - prev;\\n            result += Math.min(income, dollars)*(b[1]/100.0);\\n            income -= dollars;\\n            if (income <= 0)\\n                break;\\n            prev = b[0];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int prev = 0;\\n        double result = 0;\\n        for (int[] b : brackets)\\n        {\\n            int dollars = b[0] - prev;\\n            result += Math.min(income, dollars)*(b[1]/100.0);\\n            income -= dollars;\\n            if (income <= 0)\\n                break;\\n            prev = b[0];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005041,
                "title": "c-easy-solution",
                "content": "\\t\\n\\t\\'\\'\\'\\n\\t\\n\\t    double calculateTax(vector<vector<int>>& brackets, int income) {\\n\\t\\t\\tdouble res = 0;\\n\\t\\t\\tdouble prev = 0;\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint original = income;\\n\\t\\t\\twhile (income > 0) {\\n\\t\\t\\t\\tif (original >= brackets[i][0]) {\\n\\t\\t\\t\\t\\tres = (double) (brackets[i][0]-prev) * brackets[i][1] / 100 + res;\\n\\t\\t\\t\\t\\tincome = income - (brackets[i][0]-prev);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tres = (double) income * brackets[i][1] / 100 + res;\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev = brackets[i][0];\\n\\t\\t\\t\\t++i;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\t\\n\\t\\'\\'\\'\\n\\t\\n\\t    double calculateTax(vector<vector<int>>& brackets, int income) {\\n\\t\\t\\tdouble res = 0;\\n\\t\\t\\tdouble prev = 0;\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint original = income;\\n\\t\\t\\twhile (income > 0) {\\n\\t\\t\\t\\tif (original >= brackets[i][0]) {\\n\\t\\t\\t\\t\\tres = (double) (brackets[i][0]-prev) * brackets[i][1] / 100 + res;\\n\\t\\t\\t\\t\\tincome = income - (brackets[i][0]-prev);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tres = (double) income * brackets[i][1] / 100 + res;\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev = brackets[i][0];\\n\\t\\t\\t\\t++i;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2987669,
                "title": "fast-straight-forward-simple-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function(brackets, income) {\\n    let tax = 0;\\n    let index = 0;\\n    let taxedAlready = 0;\\n\\n    while(taxedAlready < income) {\\n        const [upperLimitForBracket, bracketPercentage] = brackets[index];\\n        const maxTaxable = upperLimitForBracket - taxedAlready;\\n        const taxable = Math.min(maxTaxable, income - taxedAlready);\\n        const taxForBracket = taxable * (bracketPercentage / 100);\\n        tax += taxForBracket;\\n        taxedAlready += maxTaxable;\\n        index++;\\n    }\\n\\n\\n    return tax;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} brackets\\n * @param {number} income\\n * @return {number}\\n */\\nvar calculateTax = function(brackets, income) {\\n    let tax = 0;\\n    let index = 0;\\n    let taxedAlready = 0;\\n\\n    while(taxedAlready < income) {\\n        const [upperLimitForBracket, bracketPercentage] = brackets[index];\\n        const maxTaxable = upperLimitForBracket - taxedAlready;\\n        const taxable = Math.min(maxTaxable, income - taxedAlready);\\n        const taxForBracket = taxable * (bracketPercentage / 100);\\n        tax += taxForBracket;\\n        taxedAlready += maxTaxable;\\n        index++;\\n    }\\n\\n\\n    return tax;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2978738,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func calculateTax(_ brackets: [[Int]], _ income: Int) -> Double {\\n        \\n        zip([[0, 0]] + brackets.dropLast(), brackets)\\n            .map { Double(max(min(income, $1[0]) - $0[0], 0) * $1[1]) }\\n            .reduce(0) { (acc: Double, v: Double) -> Double in acc + v / 100 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func calculateTax(_ brackets: [[Int]], _ income: Int) -> Double {\\n        \\n        zip([[0, 0]] + brackets.dropLast(), brackets)\\n            .map { Double(max(min(income, $1[0]) - $0[0], 0) * $1[1]) }\\n            .reduce(0) { (acc: Double, v: Double) -> Double in acc + v / 100 }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976368,
                "title": "simple-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need calculate the income that will be deducted each time we loop through the brackets. By subtracting the current upper bound from the prev upper bound I am able to compare that value against what the current income is and select the minimum. \\n\\neg. if I only have 1 dollar left of income but up to 4 dollars can be used in this tax bracket I want to only use the income I have left.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n) Time complexity. You only loop through the brackets array once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double taxes = 0.0;\\n        int prev = 0;\\n        for(int[] bracket: brackets) {\\n            if(income != 0) {\\n                int incomeToBeDeducted = Math.min(bracket[0] - prev, income);\\n                taxes += incomeToBeDeducted * (bracket[1] / 100.0);\\n                income -= incomeToBeDeducted;\\n                prev = bracket[0];\\n            }\\n        }\\n\\n        return taxes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        double taxes = 0.0;\\n        int prev = 0;\\n        for(int[] bracket: brackets) {\\n            if(income != 0) {\\n                int incomeToBeDeducted = Math.min(bracket[0] - prev, income);\\n                taxes += incomeToBeDeducted * (bracket[1] / 100.0);\\n                income -= incomeToBeDeducted;\\n                prev = bracket[0];\\n            }\\n        }\\n\\n        return taxes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962229,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun calculateTax(brackets: Array<IntArray>, income: Int): Double {\\n        var result = 0.0\\n        if (income == 0) return result\\n        var prev = 0\\n        for (i in 0..brackets.size-1) {\\n            val upper = brackets[i][0]\\n            val perc = brackets[i][1]/100.0\\n            result += maxOf(0.0, (minOf(upper, income) - prev)*perc)\\n            prev = brackets[i][0]\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun calculateTax(brackets: Array<IntArray>, income: Int): Double {\\n        var result = 0.0\\n        if (income == 0) return result\\n        var prev = 0\\n        for (i in 0..brackets.size-1) {\\n            val upper = brackets[i][0]\\n            val perc = brackets[i][1]/100.0\\n            result += maxOf(0.0, (minOf(upper, income) - prev)*perc)\\n            prev = brackets[i][0]\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951916,
                "title": "98-faster-solution-easy-to-understend",
                "content": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        answer, n= 0, len(brackets)\\n        i=0\\n        while income and i<n:\\n            p = min(brackets[i][0]-brackets[i-1][0], income) if i!=0 else min(brackets[0][0], income)\\n            answer+=p*brackets[i][1]\\n            income = income-p if income-p>0 else 0\\n            i+=1\\n        return answer/100\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\\n        answer, n= 0, len(brackets)\\n        i=0\\n        while income and i<n:\\n            p = min(brackets[i][0]-brackets[i-1][0], income) if i!=0 else min(brackets[0][0], income)\\n            answer+=p*brackets[i][1]\\n            income = income-p if income-p>0 else 0\\n            i+=1\\n        return answer/100\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948210,
                "title": "javascript-easy-solution-beats-100-faster-easy-understanding",
                "content": "```\\nconst calculateTax = (b, inc) => {\\n    let amount = 0;\\n    let pastVal = 0;\\n\\n    for(let i=0;i<b.length;i++){\\n        if(i !== 0) pastVal = b[i-1];\\n\\n        if(inc){\\n            let money = 0;\\n            if(i === 0){\\n                money = b[i][0]\\n            }else{\\n                money = b[i][0] - pastVal[0];\\n            }\\n            \\n            let store = 0;\\n            if(inc >= money) inc = inc - money;\\n            else if(inc < money) {\\n                store = inc;\\n                inc = 0;\\n            }\\n\\n            let val = 0;\\n            if(store === 0){\\n                val = (money * (b[i][1]/100));\\n            }else{\\n                val = (store * (b[i][1]/100));\\n            }\\n            \\n            amount += val;\\n        }\\n    }\\n\\n    return amount;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nconst calculateTax = (b, inc) => {\\n    let amount = 0;\\n    let pastVal = 0;\\n\\n    for(let i=0;i<b.length;i++){\\n        if(i !== 0) pastVal = b[i-1];\\n\\n        if(inc){\\n            let money = 0;\\n            if(i === 0){\\n                money = b[i][0]\\n            }else{\\n                money = b[i][0] - pastVal[0];\\n            }\\n            \\n            let store = 0;\\n            if(inc >= money) inc = inc - money;\\n            else if(inc < money) {\\n                store = inc;\\n                inc = 0;\\n            }\\n\\n            let val = 0;\\n            if(store === 0){\\n                val = (money * (b[i][1]/100));\\n            }else{\\n                val = (store * (b[i][1]/100));\\n            }\\n            \\n            amount += val;\\n        }\\n    }\\n\\n    return amount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947357,
                "title": "c-90",
                "content": "# Code\\n```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        var total = income;\\n        if(income > brackets[0][0]){\\n            tax = brackets[0][0] * brackets[0][1] * 1.0/100;\\n            income = total - brackets[0][0];\\n        }\\n        else{\\n            return income * brackets[0][1] * 1.0/100;\\n        }\\n        \\n        for(int i=1;i<brackets.Length;i++){\\n            if(income > (brackets[i][0] - brackets[i-1][0])){\\n                tax += (brackets[i][0] - brackets[i-1][0]) * brackets[i][1] * 1.0/100;\\n                income = total - brackets[i][0];\\n            }\\n            else{\\n                tax += (total - brackets[i-1][0])*brackets[i][1] * 1.0/100;\\n                return tax;\\n            }\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double CalculateTax(int[][] brackets, int income) {\\n        double tax = 0;\\n        var total = income;\\n        if(income > brackets[0][0]){\\n            tax = brackets[0][0] * brackets[0][1] * 1.0/100;\\n            income = total - brackets[0][0];\\n        }\\n        else{\\n            return income * brackets[0][1] * 1.0/100;\\n        }\\n        \\n        for(int i=1;i<brackets.Length;i++){\\n            if(income > (brackets[i][0] - brackets[i-1][0])){\\n                tax += (brackets[i][0] - brackets[i-1][0]) * brackets[i][1] * 1.0/100;\\n                income = total - brackets[i][0];\\n            }\\n            else{\\n                tax += (total - brackets[i-1][0])*brackets[i][1] * 1.0/100;\\n                return tax;\\n            }\\n        }\\n        return tax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930542,
                "title": "c-memory-usage-beats-81-34-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double res = 0;\\n        int vecIdx = 0;\\n        int delta = 0;\\n        while(income!=0){\\n            delta = (vecIdx > 0) ? brackets[vecIdx][0]-brackets[vecIdx-1][0]: brackets[vecIdx][0];\\n            cout <<\"delta = \" << delta <<endl;\\n            if(income-delta <=0) // reaches the limit\\n            {\\n                double rate = (double)brackets[vecIdx][1];\\n                res+= (double)income*rate/100;\\n                income =0;\\n            }\\n            else // go through the bracket\\n            {\\n                double rate = (double)brackets[vecIdx][1];\\n                res+= (double)delta * rate/100;\\n                income -= delta;\\n                vecIdx++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calculateTax(vector<vector<int>>& brackets, int income) {\\n        double res = 0;\\n        int vecIdx = 0;\\n        int delta = 0;\\n        while(income!=0){\\n            delta = (vecIdx > 0) ? brackets[vecIdx][0]-brackets[vecIdx-1][0]: brackets[vecIdx][0];\\n            cout <<\"delta = \" << delta <<endl;\\n            if(income-delta <=0) // reaches the limit\\n            {\\n                double rate = (double)brackets[vecIdx][1];\\n                res+= (double)income*rate/100;\\n                income =0;\\n            }\\n            else // go through the bracket\\n            {\\n                double rate = (double)brackets[vecIdx][1];\\n                res+= (double)delta * rate/100;\\n                income -= delta;\\n                vecIdx++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1772944,
                "content": [
                    {
                        "username": "PRAYAG-PATEL-1998",
                        "content": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int i = 0; //move through tax salb\\n        double left = income; // left salary\\n        double tax = 0.0;\\n        double limit = 0.0;\\n        \\n        while(left > 0){\\n            int [] slab = brackets[i];\\n            double per = slab[1];\\n            // if(slab[0] == null){\\n            //     tax = tax + left * per;\\n            //     break;\\n            // }\\n            double taxedIncome = Math.min(left,slab[0] - limit);\\n            tax = tax + taxedIncome * per;\\n            left = left - taxedIncome;\\n            limit = slab[0];\\n            i++;\\n        }\\n        return tax/100;\\n    }\\n} "
                    },
                    {
                        "username": "manualmsdos",
                        "content": "Explanation for first example:\none:  3 - 0 = 3 dollars\ntwo:  7 - 3 = 4 dollars\nthree: 10 - 7 = 3 dollars, cause 10 less than 12."
                    }
                ]
            },
            {
                "id": 2066613,
                "content": [
                    {
                        "username": "PRAYAG-PATEL-1998",
                        "content": "class Solution {\\n    public double calculateTax(int[][] brackets, int income) {\\n        int i = 0; //move through tax salb\\n        double left = income; // left salary\\n        double tax = 0.0;\\n        double limit = 0.0;\\n        \\n        while(left > 0){\\n            int [] slab = brackets[i];\\n            double per = slab[1];\\n            // if(slab[0] == null){\\n            //     tax = tax + left * per;\\n            //     break;\\n            // }\\n            double taxedIncome = Math.min(left,slab[0] - limit);\\n            tax = tax + taxedIncome * per;\\n            left = left - taxedIncome;\\n            limit = slab[0];\\n            i++;\\n        }\\n        return tax/100;\\n    }\\n} "
                    },
                    {
                        "username": "manualmsdos",
                        "content": "Explanation for first example:\none:  3 - 0 = 3 dollars\ntwo:  7 - 3 = 4 dollars\nthree: 10 - 7 = 3 dollars, cause 10 less than 12."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Flips in Binary Tree to Get Result",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1708270,
                "content": [
                    {
                        "username": "qinzhe",
                        "content": "This problem is a great/elegant problem to practice DP. I personally love it so much. Recommend everyone to think about it first before checking the answers."
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "[solution](https://leetcode.com/problems/minimum-flips-in-binary-tree-to-get-result/submissions/869643262/)\\n\\ncan someone please tell me where am I doing wrong?"
                    }
                ]
            },
            {
                "id": 1738060,
                "content": [
                    {
                        "username": "qinzhe",
                        "content": "This problem is a great/elegant problem to practice DP. I personally love it so much. Recommend everyone to think about it first before checking the answers."
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "[solution](https://leetcode.com/problems/minimum-flips-in-binary-tree-to-get-result/submissions/869643262/)\\n\\ncan someone please tell me where am I doing wrong?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Minimum Time to Finish All Jobs II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1920506,
                "content": [
                    {
                        "username": "AndreasHzz",
                        "content": "How is this a medium? should been easy."
                    },
                    {
                        "username": "rmtaylor",
                        "content": "[@ursachu](/ursachu)  this medium made me feel good "
                    },
                    {
                        "username": "ursachu",
                        "content": "Amen to this"
                    },
                    {
                        "username": "fli033",
                        "content": "ok so i think im ready for my job at amazon lol DX"
                    }
                ]
            },
            {
                "id": 1988367,
                "content": [
                    {
                        "username": "AndreasHzz",
                        "content": "How is this a medium? should been easy."
                    },
                    {
                        "username": "rmtaylor",
                        "content": "[@ursachu](/ursachu)  this medium made me feel good "
                    },
                    {
                        "username": "ursachu",
                        "content": "Amen to this"
                    },
                    {
                        "username": "fli033",
                        "content": "ok so i think im ready for my job at amazon lol DX"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Amount of Time to Fill Cups",
        "question_content": "<p>You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up <code>2</code> cups with <strong>different</strong> types of water, or <code>1</code> cup of any type of water.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>amount</code> of length <code>3</code> where <code>amount[0]</code>, <code>amount[1]</code>, and <code>amount[2]</code> denote the number of cold, warm, and hot water cups you need to fill respectively. Return <em>the <strong>minimum</strong> number of seconds needed to fill up all the cups</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> amount = [1,4,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> amount = [5,4,4]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> amount = [5,0,0]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Every second, we fill up a cold cup.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>amount.length == 3</code></li>\n\t<li><code>0 &lt;= amount[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2261394,
                "title": "java-c-python-max-max-a-sum-a-1-2",
                "content": "# **Explanation**\\nIt\\'s a brain-teaser.\\n\\n**Necessary conditions (lower bound)**\\n1. `res >= max(A)`\\nBecause each time,\\none type can reduce at most 1 cup,\\nso the final result is bigger or equal to `max(A)`\\n\\n2. `res >= ceil(sum(A) / 2)`\\nBecause each time,\\nwe can fill up to 2 cups,\\nso the final result is bigger or equal to `ceil(sum(A) / 2)`\\n\\n**Sufficient considtion (realizeable)**\\nOne strategy is to greedily fill up 2 cups with different types of water.\\nEach step, we pick the 2 types with the most number of cups, until there is only one kind.\\n\\n**Conclusion**\\nThe lower bound is realizable,\\nso it\\'s proved as the minimum steps.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int fillCups(int[] A) {\\n        int mx = 0, sum = 0;\\n        for(int a: A) {\\n            mx = Math.max(a, mx);\\n            sum += a;\\n        }\\n        return Math.max(mx, (sum + 1) / 2);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int fillCups(vector<int>& A) {\\n        int mx = 0, sum = 0;\\n        for(int& a: A) {\\n            mx = max(a, mx);\\n            sum += a;\\n        }\\n        return max(mx, (sum + 1) / 2);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def fillCups(self, A):\\n        return max(max(A), (sum(A) + 1) // 2)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int fillCups(int[] A) {\\n        int mx = 0, sum = 0;\\n        for(int a: A) {\\n            mx = Math.max(a, mx);\\n            sum += a;\\n        }\\n        return Math.max(mx, (sum + 1) / 2);\\n    }\\n```\n```cpp\\n    int fillCups(vector<int>& A) {\\n        int mx = 0, sum = 0;\\n        for(int& a: A) {\\n            mx = max(a, mx);\\n            sum += a;\\n        }\\n        return max(mx, (sum + 1) / 2);\\n    }\\n```\n```py\\n    def fillCups(self, A):\\n        return max(max(A), (sum(A) + 1) // 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2261220,
                "title": "i-did-not-work-out-the-1st-problem-first-time",
                "content": "I did not work out the 1st problem, first time!! So Stupid!\\n\\n**Update:** **1 min after this end, I came up with this lol:**\\n\\nExplanation: We can only care about the largest 2 elements in the array and try to fill them at one time, then dynamically find the largest 2 elements in the next loops, do the same thing until we fill all the cups. \\n\\n```\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int res = 0;\\n        while (amount[2] != 0) {\\n            res++;\\n            amount[2]--;\\n            if (amount[1] > 0) {\\n                amount[1]--;\\n            }\\n            Arrays.sort(amount);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Thanks your guys\\' upvotes for making me less unhappy!**",
                "solutionTags": [],
                "code": "```\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int res = 0;\\n        while (amount[2] != 0) {\\n            res++;\\n            amount[2]--;\\n            if (amount[1] > 0) {\\n                amount[1]--;\\n            }\\n            Arrays.sort(amount);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261210,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int seconds = 0;\\n        Arrays.sort(amount);//First sorting the array.\\n        int highestNum = amount.length-1;\\n        int secondHighestNum = amount.length-2;\\n        //Now taking the two biggest numbers of the array which will be at the last and the second last index as the array is sorted.\\n        while (amount[highestNum]>0 && amount[secondHighestNum]>0){\\n            //If both these numbers are greater than 0 then we can fill two cups in one second and then decreasing their values.\\n            amount[highestNum]--;\\n            amount[secondHighestNum]--;\\n            seconds++;//This is one ans\\n            Arrays.sort(amount);//Now, again sorting using the inbuilt sort of java class so that the biggest two numbers are at the last two index of the array\\n        }\\n\\n        //The above loop will break when either of the two places becomes 0\\n        //If the number at last and secon last index were equal, then both of them will become zero\\n        //Or if it is not the case, then only one type of water is present in the dispenser\\n        while (amount[highestNum]>0){\\n            //So, decreasing it one by one till it becomes zero\\n            amount[highestNum]--;\\n            seconds++;\\n        }\\n        return seconds;//Hence, we have found our answer\\n    }\\n}\\n```\\nComment if there is any doubt.\\nIf you liked the solution or found it easy to understand, do upvote :)\\nThankyou!!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int seconds = 0;\\n        Arrays.sort(amount);//First sorting the array.\\n        int highestNum = amount.length-1;\\n        int secondHighestNum = amount.length-2;\\n        //Now taking the two biggest numbers of the array which will be at the last and the second last index as the array is sorted.\\n        while (amount[highestNum]>0 && amount[secondHighestNum]>0){\\n            //If both these numbers are greater than 0 then we can fill two cups in one second and then decreasing their values.\\n            amount[highestNum]--;\\n            amount[secondHighestNum]--;\\n            seconds++;//This is one ans\\n            Arrays.sort(amount);//Now, again sorting using the inbuilt sort of java class so that the biggest two numbers are at the last two index of the array\\n        }\\n\\n        //The above loop will break when either of the two places becomes 0\\n        //If the number at last and secon last index were equal, then both of them will become zero\\n        //Or if it is not the case, then only one type of water is present in the dispenser\\n        while (amount[highestNum]>0){\\n            //So, decreasing it one by one till it becomes zero\\n            amount[highestNum]--;\\n            seconds++;\\n        }\\n        return seconds;//Hence, we have found our answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261242,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n      sort(amount.begin(),amount.end()); \\n      int x=amount[0];\\n      int y=amount[1];\\n      int z=amount[2];\\n      int sum=x+y+z;\\n      if(x+y>z) return sum/2+sum%2;\\n      if(x==0 && y==0) return z;\\n      else return z;\\n    }\\n};\\n```\\n**Upvote if you like my approch**\\n\\n![image](https://assets.leetcode.com/users/images/fdfeb765-b800-43b8-9daa-55c63c222a51_1657448583.7556148.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n      sort(amount.begin(),amount.end()); \\n      int x=amount[0];\\n      int y=amount[1];\\n      int z=amount[2];\\n      int sum=x+y+z;\\n      if(x+y>z) return sum/2+sum%2;\\n      if(x==0 && y==0) return z;\\n      else return z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265309,
                "title": "simulation-and-formula",
                "content": "#### Simulation\\nWe pick two largest piles, and fill two cups (or one, if we have only one pile left).\\n\\n**C++**\\n```cpp\\nint fillCups(vector<int>& a) {\\n    int res = 0;\\n    for (; max({a[0], a[1], a[2]}) > 0; ++res) {\\n        sort(begin(a), end(a));\\n        --a[2];\\n        --a[1];\\n    }\\n    return res;\\n}\\n```\\n#### Formula\\nIf we have one pile much larger than the others, the number of seconds will be the same as the number of cups in that large pile.\\n\\nOr, if piles are of similar size, and we can always fill two cups, we will need `(a[0] + a[1] + a[2] + 1) / 2` seconds (we do `+ 1` in case the sum of cups is odd).\\n\\n**C++**\\n```cpp\\nint fillCups(vector<int>& a) {\\n    return max({a[0], a[1], a[2], (a[0] + a[1] + a[2] + 1) / 2});\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint fillCups(vector<int>& a) {\\n    int res = 0;\\n    for (; max({a[0], a[1], a[2]}) > 0; ++res) {\\n        sort(begin(a), end(a));\\n        --a[2];\\n        --a[1];\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint fillCups(vector<int>& a) {\\n    return max({a[0], a[1], a[2], (a[0] + a[1] + a[2] + 1) / 2});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2294206,
                "title": "rigorous-proof-of-the-correct-strategy-and-the-o-1-formula-solution",
                "content": "After reading several posts in this discussion, I wasn\\'t able\\xA0to find a formal rigorous\\xA0proof of why the O(n) sorting (or priority queue) method works or why the O(1) formula\\xA0method is correct. So, after some thought, here is a proof.\\nI don\\'t think it should\\xA0be considered an \"easy\" problem even though the actual solution is simple.\\n\\n### Problem statement\\n\\nI use a slightly\\xA0different formulation of the problem since it is more convenient.\\nWe have 3 columns of non-negative integer\\xA0height. Our goal is to reach a state where all of them are zero with two types of operations:\\n1. Decrement 1 from one of the columns.\\n2. Decrement 1 from two\\xA0different\\xA0columns.\\n\\nThe task is to calculate the minimum number of steps necessary.\\n\\n### Lower bound\\nAs others already mentioned, there are two obvious\\xA0lower bounds:\\n1. max(columns): since at each step a maximum\\xA0of 1 is decremented from a single column.\\n2. ceil(sum(columns) / 2): since at each step a maximum of 2 is decremented from the sum of the\\xA0columns.\\n\\nSo the lower bound is the maximum of the two numbers above.\\n\\n### Proof the lower bound is also reachable\\nLet\\'s denote the column values a >= b >= c >= 0.\\n\\n(1) If a >= b+c, then we use c steps to remove c from the first and last columns and reach a-c, b, 0. Then, we use b steps to remove b from the first and second to reach a-b-c, 0 ,0. Then, we remove the remaining with a-b-c steps. We used a total of exactly c\\xA0+ b\\xA0+ a - b - c = a = max(columns) steps, thus achieving our lower bound.\\n\\n(2) Now suppose that, a < b+c.\\nLet x = a-b >= 0 and y=b-c >= 0. Therefore, we have: a=x+y+c, b=y+c. At first, we use y operations (from the second type) to decrement y from the two largest columns. After that we have the values x+c, c, c where x < c.\\n\\n(2.1) If x+c is even:\\nThere exists k>0 such that x+c=2k. Note that k < c since x < c. We use k steps to remove k from the first and second columns to reach k, c-k, c. Now again use k steps to remove k from the first and third columns to reach 0, c-k, c-k. Finally, use c-k steps to zeroize the two equal remaining columns. All the steps we used were from the second type, i.e. remove 2 each time so the total number of steps was exactly sum(columns) / 2 and we again reached the lower bound.\\n\\n(2.2) If x+c is odd:\\nThere exists k>0 such that x+c=2k+1. Note that k < c since x < c. We use k steps to remove k from the first and second columns to reach k+1, c-k, c. Now again use k steps to remove k from the first and third columns to reach 1, c-k, c-k. Finally, use c-k steps to zeroize the two equal columns and one more step of the first type to zeroize the first column. All the steps except the last one were from the second type so the total number of steps was exactly\\xA0ceil(sum(columns) / 2)\\xA0and we again reached the lower bound.\\n\\nQ.E.D\\n\\nPlease note the above also proves the correctness of the sorting (or priority queue) strategy.",
                "solutionTags": [
                    "Math"
                ],
                "code": "After reading several posts in this discussion, I wasn\\'t able\\xA0to find a formal rigorous\\xA0proof of why the O(n) sorting (or priority queue) method works or why the O(1) formula\\xA0method is correct. So, after some thought, here is a proof.\\nI don\\'t think it should\\xA0be considered an \"easy\" problem even though the actual solution is simple.\\n\\n### Problem statement\\n\\nI use a slightly\\xA0different formulation of the problem since it is more convenient.\\nWe have 3 columns of non-negative integer\\xA0height. Our goal is to reach a state where all of them are zero with two types of operations:\\n1. Decrement 1 from one of the columns.\\n2. Decrement 1 from two\\xA0different\\xA0columns.\\n\\nThe task is to calculate the minimum number of steps necessary.\\n\\n### Lower bound\\nAs others already mentioned, there are two obvious\\xA0lower bounds:\\n1. max(columns): since at each step a maximum\\xA0of 1 is decremented from a single column.\\n2. ceil(sum(columns) / 2): since at each step a maximum of 2 is decremented from the sum of the\\xA0columns.\\n\\nSo the lower bound is the maximum of the two numbers above.\\n\\n### Proof the lower bound is also reachable\\nLet\\'s denote the column values a >= b >= c >= 0.\\n\\n(1) If a >= b+c, then we use c steps to remove c from the first and last columns and reach a-c, b, 0. Then, we use b steps to remove b from the first and second to reach a-b-c, 0 ,0. Then, we remove the remaining with a-b-c steps. We used a total of exactly c\\xA0+ b\\xA0+ a - b - c = a = max(columns) steps, thus achieving our lower bound.\\n\\n(2) Now suppose that, a < b+c.\\nLet x = a-b >= 0 and y=b-c >= 0. Therefore, we have: a=x+y+c, b=y+c. At first, we use y operations (from the second type) to decrement y from the two largest columns. After that we have the values x+c, c, c where x < c.\\n\\n(2.1) If x+c is even:\\nThere exists k>0 such that x+c=2k. Note that k < c since x < c. We use k steps to remove k from the first and second columns to reach k, c-k, c. Now again use k steps to remove k from the first and third columns to reach 0, c-k, c-k. Finally, use c-k steps to zeroize the two equal remaining columns. All the steps we used were from the second type, i.e. remove 2 each time so the total number of steps was exactly sum(columns) / 2 and we again reached the lower bound.\\n\\n(2.2) If x+c is odd:\\nThere exists k>0 such that x+c=2k+1. Note that k < c since x < c. We use k steps to remove k from the first and second columns to reach k+1, c-k, c. Now again use k steps to remove k from the first and third columns to reach 1, c-k, c-k. Finally, use c-k steps to zeroize the two equal columns and one more step of the first type to zeroize the first column. All the steps except the last one were from the second type so the total number of steps was exactly\\xA0ceil(sum(columns) / 2)\\xA0and we again reached the lower bound.\\n\\nQ.E.D\\n\\nPlease note the above also proves the correctness of the sorting (or priority queue) strategy.",
                "codeTag": "Unknown"
            },
            {
                "id": 2261240,
                "title": "priority-queue-ease-solu-c",
                "content": "class Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> q;\\n        \\n        // fill qunatity of cups\\n        for(int i=0; i<amount.size(); i++){\\n            if(amount[i]>0)q.push(amount[i]);\\n        }\\n        \\n        int day = 0;\\n        while(!q.empty() && q.size()>1){\\n            // check first two elements decrease them and again push to priority queue\\n            int a = q.top() - 1;\\n            q.pop();\\n            \\n            int b = q.top() - 1;\\n            q.pop();\\n            \\n            day++;\\n            if(a>0) q.push(a);\\n            if(b>0) q.push(b);\\n        }\\n        \\n        // check if any element is left\\n        if(q.size()) day+=q.top();\\n        \\n        return day;\\n\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> q;\\n        \\n        // fill qunatity of cups\\n        for(int i=0; i<amount.size(); i++){\\n            if(amount[i]>0)q.push(amount[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2265901,
                "title": "go-python-c-java-javascript-sorting-and-filling-up-2-biggest-at-same-time-w-comments",
                "content": "<iframe src=\"https://leetcode.com/playground/BZ3Fa793/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/BZ3Fa793/shared\" frameBorder=\"0\" width=\"900\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2262041,
                "title": "python-straightforward-maxheap-solution",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        pq = [-q for q in amount if q != 0]\\n        heapq.heapify(pq)\\n        ret = 0\\n        \\n        while len(pq) > 1:\\n            first = heapq.heappop(pq)\\n            second = heapq.heappop(pq)\\n            first += 1\\n            second += 1\\n            ret += 1\\n            if first:\\n                heapq.heappush(pq, first)\\n            if second:\\n                heapq.heappush(pq, second)\\n\\n        if pq:\\n            return ret - pq[0]\\n        else:\\n            return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        pq = [-q for q in amount if q != 0]\\n        heapq.heapify(pq)\\n        ret = 0\\n        \\n        while len(pq) > 1:\\n            first = heapq.heappop(pq)\\n            second = heapq.heappop(pq)\\n            first += 1\\n            second += 1\\n            ret += 1\\n            if first:\\n                heapq.heappush(pq, first)\\n            if second:\\n                heapq.heappush(pq, second)\\n\\n        if pq:\\n            return ret - pq[0]\\n        else:\\n            return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261556,
                "title": "python-sorting-based",
                "content": "Approach\\n- Continously sort and decrement the first and second value by 1 till the first value is 0. Later return the count\\n\\nCode\\n```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        \\n        count = 0\\n        amount = sorted(amount, reverse=True)\\n        while amount[0] > 0:\\n            amount[0] -= 1\\n            amount[1] -= 1\\n            count += 1\\n            amount = sorted(amount, reverse=True)\\n        return count\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        \\n        count = 0\\n        amount = sorted(amount, reverse=True)\\n        while amount[0] > 0:\\n            amount[0] -= 1\\n            amount[1] -= 1\\n            count += 1\\n            amount = sorted(amount, reverse=True)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261368,
                "title": "java-easiest-solution",
                "content": "# Please Upvote\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n         Arrays.sort(amount);\\n        int x=amount[0];\\n         int y=amount[1];\\n         int z=amount[2];\\n        int sum=x+y+z;\\n        if(x+y>z){return sum/2 +sum%2;}\\n        if(x==0&&y==0){return z;}\\n        else{return z;}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n         Arrays.sort(amount);\\n        int x=amount[0];\\n         int y=amount[1];\\n         int z=amount[2];\\n        int sum=x+y+z;\\n        if(x+y>z){return sum/2 +sum%2;}\\n        if(x==0&&y==0){return z;}\\n        else{return z;}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261275,
                "title": "easy-recursion-c",
                "content": "We have two type of moves \\n\\t1. fill 2 different cups \\n\\t2. fill 1 cup\\nObservation .. \\n\\talways decrement from 2 maximum cups\\n\\twhen 2 cups become ZERO, empty the last cup in single move\\n\\n```\\nclass Solution {  \\nprivate:\\n    // counter for Steps\\n    int count = 0;\\n    void check(vector<int>& a){\\n        // sort the array \\n        sort(a.begin(), a.end());\\n        // base case // if all elements are ZERO\\n        if (a[0] + a[1] + a[2] == 0)  return;\\n        // decrement from last to element\\n        if (a[1] and a[2]){\\n            a[1]--, a[2]--;\\n            count++;\\n        }\\n        else{\\n            // at this point only last element is non zero // so we can directly make it zero\\n            count += a[2];\\n            a[2] = 0;\\n        }\\n        // recursive call \\n        check(a);\\n    }\\npublic:\\n    int fillCups(vector<int>& a) {\\n        check(a);\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {  \\nprivate:\\n    // counter for Steps\\n    int count = 0;\\n    void check(vector<int>& a){\\n        // sort the array \\n        sort(a.begin(), a.end());\\n        // base case // if all elements are ZERO\\n        if (a[0] + a[1] + a[2] == 0)  return;\\n        // decrement from last to element\\n        if (a[1] and a[2]){\\n            a[1]--, a[2]--;\\n            count++;\\n        }\\n        else{\\n            // at this point only last element is non zero // so we can directly make it zero\\n            count += a[2];\\n            a[2] = 0;\\n        }\\n        // recursive call \\n        check(a);\\n    }\\npublic:\\n    int fillCups(vector<int>& a) {\\n        check(a);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832354,
                "title": "c-solutions",
                "content": "class Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n      sort(amount.begin(),amount.end()); \\n      int x=amount[0];\\n      int y=amount[1];\\n      int z=amount[2];\\n      int sum=x+y+z;\\n      if(x+y>z) return sum/2+sum%2;\\n      if(x==0 && y==0) return z;\\n      else return z;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n      sort(amount.begin(),amount.end()); \\n      int x=amount[0];\\n      int y=amount[1];\\n      int z=amount[2];\\n      int sum=x+y+z;\\n      if(x+y>z) return sum/2+sum%2;\\n      if(x==0 && y==0) return z;\\n      else return z;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2286594,
                "title": "c-easy-simple-solution-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        int sum = a[0]+a[1]+a[2];\\n        int maxValue = max(a[0], max(a[1], a[2]));\\n        return max(maxValue, (sum+1)/2);\\n    }\\n};\\n```\\n**Time Complexity = O(1)\\nSpace Complexity = O(1)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        int sum = a[0]+a[1]+a[2];\\n        int maxValue = max(a[0], max(a[1], a[2]));\\n        return max(maxValue, (sum+1)/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266397,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        return max(*max_element(begin(amount),end(amount)),(accumulate(begin(amount),end(amount),0)+1)/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        return max(*max_element(begin(amount),end(amount)),(accumulate(begin(amount),end(amount),0)+1)/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261221,
                "title": "minimum-amount-of-time-to-fill-cups-java-solution",
                "content": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int high = amount[2];\\n        int mid = amount[1];\\n        int low = amount[0];\\n        int tot=high+mid+low; \\n        if(low+mid>high)  \\n            return tot/2+tot%2; \\n        if(low==0 && mid==0)  \\n          return high; \\n        else  \\n            return high; \\n\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int high = amount[2];\\n        int mid = amount[1];\\n        int low = amount[0];\\n        int tot=high+mid+low; \\n        if(low+mid>high)  \\n            return tot/2+tot%2; \\n        if(low==0 && mid==0)  \\n          return high; \\n        else  \\n            return high; \\n\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265447,
                "title": "python3-one-line-w-explanation-t-m-41ms-13-5-mb",
                "content": "```\\nclass Solution:\\n                                    # Because only one of any type can be filled per second,\\n                                    # the min cannot be less than the max(amount)-- see Ex 1.\\n\\n                                    # The min also cannot be less than ceil(sum(amount)/2)--see Ex 2.\\n                                    \\n                                    # The min cannot be greater than both of these two\\n                                    # quantities, so... tada\\n\\n    def fillCups(self, amount: List[int]) -> int:\\n        return max(max(amount), ceil(sum(amount)/2))",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n                                    # Because only one of any type can be filled per second,\\n                                    # the min cannot be less than the max(amount)-- see Ex 1.\\n\\n                                    # The min also cannot be less than ceil(sum(amount)/2)--see Ex 2.\\n                                    \\n                                    # The min cannot be greater than both of these two\\n                                    # quantities, so... tada\\n\\n    def fillCups(self, amount: List[int]) -> int:\\n        return max(max(amount), ceil(sum(amount)/2))",
                "codeTag": "Java"
            },
            {
                "id": 2264245,
                "title": "c-basic-math-100-beats-both-time-and-space-complexity",
                "content": "Hi EveryOne , In this I am going to solve this question using basic mathematics.\\n**Time Complexity O(n) and Space Complexity O(1)**\\n\\n**Equation 1->**  ```Each second we fill (either different or same cup) we cannot reduce the amount of  cups(of one type) to be filled by more than 1 so we need atleast max(amount) seconds to fill all solution. Got it ? So sol>=max(amount)```\\n**Equation 2 ->**  ```what will be minimum second required if we fill 2 cups each second then we will need ceil((total amount to fill)/2) So Solution would be Sol>=((total+1)/2)```\\n\\t\\n\\tOverall solution should satisfy both equations.\\n\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int maxi=0;\\n        int total =0;\\n        for(int i=0;i<amount.size();i++){\\n            total+=amount[i];\\n            maxi=max(maxi,amount[i]);\\n        }\\n        // It is based on basic Math\\n        /** Case I EQUATION I- Each second we fill (either different or same cup) \\n\\t\\twe cannot reduce the amount of maximum cups to be filled by more than 1\\n\\t\\tso we need atleast max(amount) seconds to \\n\\t\\tfill all solution. Got it ? \\n\\t\\tSo sol>=max(amount)\\n\\t\\t\\n        Equation 2 -> what will be minimum second required \\n\\t\\tif we fill 2 cups each second then we will need ceil((total amount to fill)/2) \\n\\t\\tSo Solution would be Sol>=((total+1)/2)\\n        **/\\n        // Overall solution should satisfy both equations.\\n        return max(maxi,(total+1)/2);\\n    }\\n};\\n```\\n\\n**Please Upvote if you like it and if you have any query. comment section is all yours \\uD83D\\uDE4F**\\n\\n![image](https://assets.leetcode.com/users/images/0361682b-5ca2-4de6-a165-98a34a86ca10_1657468906.6017098.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```Each second we fill (either different or same cup) we cannot reduce the amount of  cups(of one type) to be filled by more than 1 so we need atleast max(amount) seconds to fill all solution. Got it ? So sol>=max(amount)```\n```what will be minimum second required if we fill 2 cups each second then we will need ceil((total amount to fill)/2) So Solution would be Sol>=((total+1)/2)```\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int maxi=0;\\n        int total =0;\\n        for(int i=0;i<amount.size();i++){\\n            total+=amount[i];\\n            maxi=max(maxi,amount[i]);\\n        }\\n        // It is based on basic Math\\n        /** Case I EQUATION I- Each second we fill (either different or same cup) \\n\\t\\twe cannot reduce the amount of maximum cups to be filled by more than 1\\n\\t\\tso we need atleast max(amount) seconds to \\n\\t\\tfill all solution. Got it ? \\n\\t\\tSo sol>=max(amount)\\n\\t\\t\\n        Equation 2 -> what will be minimum second required \\n\\t\\tif we fill 2 cups each second then we will need ceil((total amount to fill)/2) \\n\\t\\tSo Solution would be Sol>=((total+1)/2)\\n        **/\\n        // Overall solution should satisfy both equations.\\n        return max(maxi,(total+1)/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261670,
                "title": "c-2-method-maximum-of-max-and-sum-sorting-decreasing-order",
                "content": "But I haven\\'t solved in contest, very disappointed\\nNow i have 2 method ;\\n1 Method:\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a)\\n    {\\n        int sum=0;\\n        for(auto e:a)\\n        {\\n            sum+=e;\\n        }\\n        return max(*max_element(a.begin(),a.end()),(sum+1)/2);\\n    }\\n};\\n```\\n2 Method:\\nSorting decreasing order and check first element\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a)\\n    {\\n        sort(a.begin(),a.end(),greater<int>());\\n        int count=0;\\n        while(a[0]>0)\\n        {\\n            a[0]--;\\n            a[1]--;\\n            count++;\\n            sort(a.begin(),a.end(),greater<int>());\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a)\\n    {\\n        int sum=0;\\n        for(auto e:a)\\n        {\\n            sum+=e;\\n        }\\n        return max(*max_element(a.begin(),a.end()),(sum+1)/2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a)\\n    {\\n        sort(a.begin(),a.end(),greater<int>());\\n        int count=0;\\n        while(a[0]>0)\\n        {\\n            a[0]--;\\n            a[1]--;\\n            count++;\\n            sort(a.begin(),a.end(),greater<int>());\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261372,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        int n = a.size();\\n        \\n        priority_queue<int> pq;\\n        \\n        for(auto &x: a){\\n            if(x != 0) pq.push(x);\\n        }\\n        int ans = 0;\\n        while(pq.size() >= 2){\\n            int x = pq.top();\\n            pq.pop();\\n            int y = pq.top();\\n            pq.pop();\\n            \\n            ans++;\\n            \\n            if(x-1 != 0) pq.push(x-1);\\n            if(y-1 != 0) pq.push(y-1); \\n        }\\n        \\n        if(!pq.empty()) ans += pq.top();\\n        \\n        return ans;\\n    }\\n};\\n```\\n*note : There are only 3 elements in array*\\n\\n**M2**\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int sum=a[0]+a[1]+a[2];\\n        if(a[1]+a[0]>=a[2])sum=(sum+1)/2;\\n        else sum=a[2];return sum;\\n    }\\n};\\n```\\n\\n**M3**\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int ans=0;\\n        while(1) {\\n            sort(amount.begin(), amount.end());\\n            if (amount.back()<=0)\\n                break;\\n            \\n            amount[1]--, amount[2]--;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        int n = a.size();\\n        \\n        priority_queue<int> pq;\\n        \\n        for(auto &x: a){\\n            if(x != 0) pq.push(x);\\n        }\\n        int ans = 0;\\n        while(pq.size() >= 2){\\n            int x = pq.top();\\n            pq.pop();\\n            int y = pq.top();\\n            pq.pop();\\n            \\n            ans++;\\n            \\n            if(x-1 != 0) pq.push(x-1);\\n            if(y-1 != 0) pq.push(y-1); \\n        }\\n        \\n        if(!pq.empty()) ans += pq.top();\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int sum=a[0]+a[1]+a[2];\\n        if(a[1]+a[0]>=a[2])sum=(sum+1)/2;\\n        else sum=a[2];return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int ans=0;\\n        while(1) {\\n            sort(amount.begin(), amount.end());\\n            if (amount.back()<=0)\\n                break;\\n            \\n            amount[1]--, amount[2]--;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288700,
                "title": "java-easy-to-undersatnd-simeple-o-1-solution-without-using-extra-space-3-line-solution",
                "content": "**Approach:**\\n\\n1. First of all calculate the **sum** of all three elements and assign it to a variable (i.e sum).\\n2. Find the **max** among all three element and assign it to a variable (i.e mv).\\n3. Return the **max** of **mv** and **(sum+1)/2** using the **Math.max()** method.\\n\\n\\n**Code:**\\n\\n```\\nint sum = amount[0]+amount[1]+amount[2];\\nint mv = Math.max(amount[0],Math.max(amount[1],amount[2]));\\nreturn Math.max(mv,(sum+1)/2);\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nint sum = amount[0]+amount[1]+amount[2];\\nint mv = Math.max(amount[0],Math.max(amount[1],amount[2]));\\nreturn Math.max(mv,(sum+1)/2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278334,
                "title": "java-simple-solution-sorting-recursion",
                "content": "```\\n\\tpublic int fillCups(int[] amount) {\\n        \\n        Arrays.sort(amount);\\n\\t\\t\\n        if(amount[2] == 0) return 0;\\n\\t\\t\\n        if(amount[1] == 0) return amount[2];\\n        else {\\n\\t\\t\\n            amount[1] -= 1;\\n            amount[2] -= 1;\\n            return 1 + fillCups(amount);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic int fillCups(int[] amount) {\\n        \\n        Arrays.sort(amount);\\n\\t\\t\\n        if(amount[2] == 0) return 0;\\n\\t\\t\\n        if(amount[1] == 0) return amount[2];\\n        else {\\n\\t\\t\\n            amount[1] -= 1;\\n            amount[2] -= 1;\\n            return 1 + fillCups(amount);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264712,
                "title": "python-1-line-simplest-intuition-possible-o-n-o-1",
                "content": "There are many people still confused about this one. So I will try to explain it as easily as possible.\\nThink of it in real life. You have many cups and you have 2 taps.\\n\\n**Simple thing you will actually do**\\nUse both the taps as long as you can. Just put a cup under each tap and keep filling water Replacing one cup for another. This will take **ceil(Total cups/2)** time. As you will fill 2 cups at once.\\n\\nThis *nearly* works.\\nBut thing is, you can not use both taps for same temperature of water.\\nNow before overanalyzing the issue, simply realise that this can be a problem if there is a requirement of a specific cup(let\\'s say *hot*) more than **ceil(Total cups/2)** times. Otherwise, you will keep filling it whenever 1 tap is free.\\n\\nSo in this scenario, you will need time needed to **at least** fill those *hot* cups. As you will use one tap **only** for filling hot water. And with 1 tap you will fill the rest two types of cups. You can be sure that other two cups combined will not take more time as *one cup is more than half of requirement* (> ceil(Total cups/2) )\\n\\nSo answer is always\\nmax( max(cups),  ceil(Total cups/2)) )\\n\\nAccepted code,\\n```\\ndef fillCups(self, amount: List[int]) -> int:\\n        return max(int(math.ceil(sum(amount)/2)),max(amount))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef fillCups(self, amount: List[int]) -> int:\\n        return max(int(math.ceil(sum(amount)/2)),max(amount))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3666879,
                "title": "just-priority-heap",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n.log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n\\n        pq.push(amount[0]);\\n        pq.push(amount[1]);\\n        pq.push(amount[2]);\\n\\n\\n        int time = 0,first = 0, second = 0;\\n        while(pq.top() != 0)\\n        {\\n            time++;\\n\\n            if(pq.top() != 0){\\n                first = pq.top();\\n                pq.pop();\\n                first--;\\n            }\\n\\n            if(pq.top() != 0){\\n                second = pq.top();\\n                pq.pop();\\n                second--;\\n            }\\n\\n            pq.push(first);\\n            pq.push(second);\\n            \\n        }\\n\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return time;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/ddb58277-f81d-40f9-927f-046720177d8e_1683052648.39132.gif)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n\\n        pq.push(amount[0]);\\n        pq.push(amount[1]);\\n        pq.push(amount[2]);\\n\\n\\n        int time = 0,first = 0, second = 0;\\n        while(pq.top() != 0)\\n        {\\n            time++;\\n\\n            if(pq.top() != 0){\\n                first = pq.top();\\n                pq.pop();\\n                first--;\\n            }\\n\\n            if(pq.top() != 0){\\n                second = pq.top();\\n                pq.pop();\\n                second--;\\n            }\\n\\n            pq.push(first);\\n            pq.push(second);\\n            \\n        }\\n\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507691,
                "title": "my-dp-solution-no-maths-brute-force-approach-memoised-overkill",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have 6 choices that we can make, each recursive call takes that choice and returns the minimum number of seconds that it would take to get the cups filled from there.\\n\\nif any choice taken results in invalid quantity in any cup, which is negative quantity then we return a large value so that it wouldnt be considered in the minimum count.\\n\\nAs 3 independent states are being changed, we have used a 3D Matrix for the memoisation.\\n\\n# Complexity\\n\\nThe time complexity of the code without any memoisation would be \\n$$O(6^n)$$ where $$ n = max(cold,warm,hot) $$\\n\\nAfter the memoisation the time complexity reduces greatly to $$O(cold*warm*hot)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int cold, int warm, int hot, vector<vector<vector<int>>>& dp){\\n        if(cold<0 || warm<0 || hot<0){\\n            return INT_MAX-1000;\\n        }\\n        if(cold==0 && warm==0 && hot==0){\\n            return 0;\\n        }\\n        if(dp[cold][warm][hot] != -1){\\n            return dp[cold][warm][hot];\\n        }\\n\\n        int res1 = 1+helper(cold-1,warm-1,hot,dp);\\n        int res2 = 1+helper(cold-1,warm,hot-1,dp);\\n        int res3 = 1+helper(cold,warm-1,hot-1,dp);\\n        int res4 = 1+helper(cold-1,warm,hot,dp);\\n        int res5 = 1+helper(cold,warm-1,hot,dp);\\n        int res6 = 1+helper(cold,warm,hot-1,dp);\\n\\n        return dp[cold][warm][hot]=min({res1,res2,res3,res4,res5,res6});\\n    }\\n    int fillCups(vector<int>& amount) {\\n        vector<vector<vector<int>>> dp(amount[0]+1, vector<vector<int>>(amount[1]+1, vector<int>(amount[2]+1, -1)));\\n        return helper(amount[0],amount[1],amount[2],dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int cold, int warm, int hot, vector<vector<vector<int>>>& dp){\\n        if(cold<0 || warm<0 || hot<0){\\n            return INT_MAX-1000;\\n        }\\n        if(cold==0 && warm==0 && hot==0){\\n            return 0;\\n        }\\n        if(dp[cold][warm][hot] != -1){\\n            return dp[cold][warm][hot];\\n        }\\n\\n        int res1 = 1+helper(cold-1,warm-1,hot,dp);\\n        int res2 = 1+helper(cold-1,warm,hot-1,dp);\\n        int res3 = 1+helper(cold,warm-1,hot-1,dp);\\n        int res4 = 1+helper(cold-1,warm,hot,dp);\\n        int res5 = 1+helper(cold,warm-1,hot,dp);\\n        int res6 = 1+helper(cold,warm,hot-1,dp);\\n\\n        return dp[cold][warm][hot]=min({res1,res2,res3,res4,res5,res6});\\n    }\\n    int fillCups(vector<int>& amount) {\\n        vector<vector<vector<int>>> dp(amount[0]+1, vector<vector<int>>(amount[1]+1, vector<int>(amount[2]+1, -1)));\\n        return helper(amount[0],amount[1],amount[2],dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231107,
                "title": "c-solution-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<3;i++)\\n        {\\n            pq.push(amount[i]);\\n        }\\n        \\n        int count=0;\\n        while(pq.top()!=0)\\n        {\\n            int num1=pq.top();\\n            num1-=1;\\n            pq.pop();\\n            int num2=pq.top();\\n            num2-=1;\\n            pq.pop();\\n            \\n            pq.push(num1);\\n            pq.push(num2);\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<3;i++)\\n        {\\n            pq.push(amount[i]);\\n        }\\n        \\n        int count=0;\\n        while(pq.top()!=0)\\n        {\\n            int num1=pq.top();\\n            num1-=1;\\n            pq.pop();\\n            int num2=pq.top();\\n            num2-=1;\\n            pq.pop();\\n            \\n            pq.push(num1);\\n            pq.push(num2);\\n            \\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485594,
                "title": "java-brute-force-solution-using-sorting",
                "content": "- The observation is that we can get the minimum time needed if we always start with the maximum number of cups.\\n- Since the array has a length of 3, I figure we can just sort it everytime.\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int cnt = 0;\\n        Arrays.sort(amount);\\n        while(amount[2] != 0){\\n            cnt++;\\n            amount[2] -= 1;\\n            amount[1] -= 1;\\n            Arrays.sort(amount);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int cnt = 0;\\n        Arrays.sort(amount);\\n        while(amount[2] != 0){\\n            cnt++;\\n            amount[2] -= 1;\\n            amount[1] -= 1;\\n            Arrays.sort(amount);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296731,
                "title": "simple-math-o-1-solution",
                "content": "* It is so obvious that of max element is greater than sum of other 2 elements then it would take max element seconds. for eg 5,21, here 5>2+1, so 3 cups out of 5 cups will get filled with other 2 sets in 3 second and remaining 2 will take 2 seconds.\\n* Now for the second case, 5,4,4. the answer will be (5+4+4)/2 +1=7. here is the explanation we are cosidering 2 cups at a time, because 2 cups will take 1 seconds and hence n cups will take n/2 seconds to get filled if n is odd it will take one extra second to fill it.\\n* hope its understandable\\n* below is the code !\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int a=amount[0],b=amount[1],c=amount[2];\\n        int d=max(a,max(b,c));\\n        if(2*d>a+b+c) return d;\\n        if((a+b+c)%2==0) return (a+b+c)/2;\\n        return (a+b+c)/2 +1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int a=amount[0],b=amount[1],c=amount[2];\\n        int d=max(a,max(b,c));\\n        if(2*d>a+b+c) return d;\\n        if((a+b+c)%2==0) return (a+b+c)/2;\\n        return (a+b+c)/2 +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265291,
                "title": "c-easy-solution",
                "content": "***Upvote toh banta hai***\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        //basic cases\\n        if(amount[1]+amount[2]+amount[3]==1)return 1;\\n        if(amount[1]+amount[2]+amount[3]==0)return 0;\\n\\t\\t\\n        priority_queue<int>pq;\\n        \\n\\t\\t//pushing element in queue\\n        for(int i=0;i<3;i++)\\n        {\\n            pq.push(amount[i]);\\n        }\\n\\t\\t//initializing return variable;\\n        int count=0;\\n\\t\\t\\n        while(pq.top()!=0)\\n        {\\n               //for cases [5,4,4] then n=5 and m=4\\n                int n=pq.top();  pq.pop();  int m=pq.top();\\n\\t\\t\\t\\t//for cases [5,0,0] n=5 and m=0 so we add 5 to final answer\\n                if(m==0){   \\n                    count+=n;\\n                    break;}\\n                else{\\n                   pq.pop();\\n\\t\\t\\t\\t   //reducing each by 1 and pushing in priority queue\\n                   pq.push(n-1);\\n                   pq.push(m-1);\\n                  }\\n\\t\\t\\t\\t  //and adding the repetitions to the answer\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        //basic cases\\n        if(amount[1]+amount[2]+amount[3]==1)return 1;\\n        if(amount[1]+amount[2]+amount[3]==0)return 0;\\n\\t\\t\\n        priority_queue<int>pq;\\n        \\n\\t\\t//pushing element in queue\\n        for(int i=0;i<3;i++)\\n        {\\n            pq.push(amount[i]);\\n        }\\n\\t\\t//initializing return variable;\\n        int count=0;\\n\\t\\t\\n        while(pq.top()!=0)\\n        {\\n               //for cases [5,4,4] then n=5 and m=4\\n                int n=pq.top();  pq.pop();  int m=pq.top();\\n\\t\\t\\t\\t//for cases [5,0,0] n=5 and m=0 so we add 5 to final answer\\n                if(m==0){   \\n                    count+=n;\\n                    break;}\\n                else{\\n                   pq.pop();\\n\\t\\t\\t\\t   //reducing each by 1 and pushing in priority queue\\n                   pq.push(n-1);\\n                   pq.push(m-1);\\n                  }\\n\\t\\t\\t\\t  //and adding the repetitions to the answer\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263859,
                "title": "easy-c-maxheap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> q;\\n        for(auto i:amount)\\n            q.push(i);\\n        \\n        int ans = 0;\\n        while(q.top()!=0){\\n            int a = q.top();\\n            q.pop();\\n            int b = q.top();\\n            q.pop();\\n            if(a>0 and b>0){\\n                q.push(--a);\\n                q.push(--b);\\n                ans++;\\n            }else{\\n                q.push(--a);\\n                q.push(b);\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> q;\\n        for(auto i:amount)\\n            q.push(i);\\n        \\n        int ans = 0;\\n        while(q.top()!=0){\\n            int a = q.top();\\n            q.pop();\\n            int b = q.top();\\n            q.pop();\\n            if(a>0 and b>0){\\n                q.push(--a);\\n                q.push(--b);\\n                ans++;\\n            }else{\\n                q.push(--a);\\n                q.push(b);\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263394,
                "title": "simple-python-solution-with-explanation",
                "content": "Sort the list. Every time take two max numbers and decrement them by one. Aslo increment count by one. If only one non zero element present then add that number to count and return the count. If all are zero then return count. \\n\\n```\\nimport math\\nclass Solution:\\n    def fillCups(self, l: List[int]) -> int:\\n        l.sort()\\n        c=0\\n        while(sum(l)!=0):\\n            if(l[-1]!=0 and l[-2]!=0):\\n                l[-1]-=1\\n                l[-2]-=1\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t# If only one non zero element present then add that number to count and return the count.\\n            elif(l[-2]==0 and l[-3]==0):\\n                return c+l[-1]\\n\\t\\t\\t\\t\\n\\t\\t\\t#If all are zero then return count\\n            elif(sum(l)==0):\\n                return c\\n            \\n            l.sort()\\n        return c\\n```\\n\\nupvote if you like it",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def fillCups(self, l: List[int]) -> int:\\n        l.sort()\\n        c=0\\n        while(sum(l)!=0):\\n            if(l[-1]!=0 and l[-2]!=0):\\n                l[-1]-=1\\n                l[-2]-=1\\n                c+=1\\n\\t\\t\\t\\t\\n\\t\\t\\t# If only one non zero element present then add that number to count and return the count.\\n            elif(l[-2]==0 and l[-3]==0):\\n                return c+l[-1]\\n\\t\\t\\t\\t\\n\\t\\t\\t#If all are zero then return count\\n            elif(sum(l)==0):\\n                return c\\n            \\n            l.sort()\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261727,
                "title": "cpp",
                "content": "\\n        class Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        sort(amount.begin(),amount.end()); \\n      int x=amount[0];\\n      int y=amount[1];\\n      int z=amount[2];\\n      int sum=x+y+z;\\n      if(x+y>z) return sum/2+sum%2;\\n      if(x==0 && y==0) return z;\\n      else return z;\\n    }\\n};\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        sort(amount.begin(),amount.end()); \\n      int x=amount[0];\\n      int y=amount[1];\\n      int z=amount[2];\\n      int sum=x+y+z;\\n      if(x+y>z) return sum/2+sum%2;\\n      if(x==0 && y==0) return z;\\n      else return z;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2261588,
                "title": "greedy-with-priority-queue",
                "content": "We can approach this greedily.\\n\\nAlways try to fill up 2 different cups, if we can\\'t fill 2 different cups it means we have only 1 cup left to fill with X fills.\\n\\nWe need to fill the cups that have the most capcity greedily, this will allow us to fill 2 cups for as long as possible.\\n\\nWhen we are left with 1 cup, just add the capacity to the result since we can only fill it 1 move at a time.\\n\\n# Code\\n```\\nfrom heapq import heapify, heappop, heappush\\n\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        moves = 0\\n        max_heap = [-v for v in amount]\\n        heapify(max_heap)\\n        \\n        while max_heap:\\n            biggest = heappop(max_heap)\\n            \\n            if max_heap and max_heap[0] != 0:\\n                moves += 1\\n                second_biggest = heappop(max_heap)\\n                \\n                biggest += 1\\n                second_biggest += 1\\n                \\n                if biggest != 0: heappush(max_heap, biggest)\\n                if second_biggest != 0: heappush(max_heap, second_biggest)\\n            \\n            else:\\n                moves += (-biggest)\\n    \\n        return moves\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nfrom heapq import heapify, heappop, heappush\\n\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        moves = 0\\n        max_heap = [-v for v in amount]\\n        heapify(max_heap)\\n        \\n        while max_heap:\\n            biggest = heappop(max_heap)\\n            \\n            if max_heap and max_heap[0] != 0:\\n                moves += 1\\n                second_biggest = heappop(max_heap)\\n                \\n                biggest += 1\\n                second_biggest += 1\\n                \\n                if biggest != 0: heappush(max_heap, biggest)\\n                if second_biggest != 0: heappush(max_heap, second_biggest)\\n            \\n            else:\\n                moves += (-biggest)\\n    \\n        return moves\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261563,
                "title": "easy-simple-c-solution",
                "content": "\\n```\\nint fillCups(vector<int>& a) {\\n        int n=a.size();\\n        sort(a.begin(),a.end());\\n        if(a[0]==0 && a[1]==0 && a[2]!=0) return a[2];\\n        \\n        int ans=0;\\n        while(true){\\n            if(a[0]==0 && a[1]==0 && a[2]==0) return ans;\\n            sort(a.begin(),a.end());\\n             reverse(a.begin(),a.end());\\n            ans+=1;\\n            a[0]=a[0]-1;\\n            if(a[1]!=0) a[1]=a[1]-1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint fillCups(vector<int>& a) {\\n        int n=a.size();\\n        sort(a.begin(),a.end());\\n        if(a[0]==0 && a[1]==0 && a[2]!=0) return a[2];\\n        \\n        int ans=0;\\n        while(true){\\n            if(a[0]==0 && a[1]==0 && a[2]==0) return ans;\\n            sort(a.begin(),a.end());\\n             reverse(a.begin(),a.end());\\n            ans+=1;\\n            a[0]=a[0]-1;\\n            if(a[1]!=0) a[1]=a[1]-1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665974,
                "title": "beats-100-in-time-priority-queue-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(int i=0; i<3; i++){\\n            pq.push(amount[i]);\\n        }\\n        int time=0;\\n        while(pq.top() != 0){\\n            time += 1;\\n            int temp = pq.top()-1;\\n            pq.pop();\\n            int temp2 = pq.top()-1;\\n            pq.pop();\\n            pq.push(temp);\\n            pq.push(temp2);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(int i=0; i<3; i++){\\n            pq.push(amount[i]);\\n        }\\n        int time=0;\\n        while(pq.top() != 0){\\n            time += 1;\\n            int temp = pq.top()-1;\\n            pq.pop();\\n            int temp2 = pq.top()-1;\\n            pq.pop();\\n            pq.push(temp);\\n            pq.push(temp2);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637587,
                "title": "easy-implementation-using-priority-queue-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        for(auto i : amount){\\n            if(i > 0) pq.push(i);\\n        }\\n        int ans = 0;\\n        while(pq.size() > 1){\\n            int type1 = pq.top(); pq.pop();\\n            int type2 = pq.top(); pq.pop();\\n            type1--; type2--;\\n            if(type1 > 0) pq.push(type1);\\n            if(type2 > 0) pq.push(type2);\\n            ans++;\\n        }\\n        if(!pq.empty()) ans += pq.top();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        for(auto i : amount){\\n            if(i > 0) pq.push(i);\\n        }\\n        int ans = 0;\\n        while(pq.size() > 1){\\n            int type1 = pq.top(); pq.pop();\\n            int type2 = pq.top(); pq.pop();\\n            type1--; type2--;\\n            if(type1 > 0) pq.push(type1);\\n            if(type2 > 0) pq.push(type2);\\n            ans++;\\n        }\\n        if(!pq.empty()) ans += pq.top();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605495,
                "title": "c-simple-priority-queue",
                "content": "# Code\\n```\\n// To minimize time, choose the two largest value and decrease it by 1.\\n// Repeat this until all elements become zero.\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq(amount.begin(), amount.end()); \\n    \\n        int time = 0;\\n        while (pq.top() > 0) {\\n            int num1 = pq.top(); pq.pop();\\n            int num2 = pq.top(); pq.pop();\\n            num1--;\\n            num2--;\\n            pq.push(num1);\\n            pq.push(num2);\\n            time++;\\n        }\\n    \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// To minimize time, choose the two largest value and decrease it by 1.\\n// Repeat this until all elements become zero.\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq(amount.begin(), amount.end()); \\n    \\n        int time = 0;\\n        while (pq.top() > 0) {\\n            int num1 = pq.top(); pq.pop();\\n            int num2 = pq.top(); pq.pop();\\n            num1--;\\n            num2--;\\n            pq.push(num1);\\n            pq.push(num2);\\n            time++;\\n        }\\n    \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454061,
                "title": "minimum-amount-of-time-to-fill-cups-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int time=0;\\n        while(true)\\n        {\\n            sort(amount.begin(), amount.end());\\n            if(amount[2]>0)\\n            {\\n                amount[2]--;\\n                time++;\\n            }\\n            if(amount[1]>0)\\n            {\\n                amount[1]--;\\n            }\\n            else if(amount[2]==0)\\n            {\\n                break;\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOptimized Approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int time=0;\\n        time = max(*max_element(amount.begin(), amount.end()), (accumulate(amount.begin(), amount.end(), 0)+1)/2);\\n        return time;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/2b5ba58f-c507-452d-a47d-f722b6c7403b_1682612638.84197.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int time=0;\\n        while(true)\\n        {\\n            sort(amount.begin(), amount.end());\\n            if(amount[2]>0)\\n            {\\n                amount[2]--;\\n                time++;\\n            }\\n            if(amount[1]>0)\\n            {\\n                amount[1]--;\\n            }\\n            else if(amount[2]==0)\\n            {\\n                break;\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int time=0;\\n        time = max(*max_element(amount.begin(), amount.end()), (accumulate(amount.begin(), amount.end(), 0)+1)/2);\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818639,
                "title": "java-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to fill 2 cup at the same time so if our max cap 2 times bigger than sum we have to take it otherwise we have to remove cups 2 by 2 \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$because only 3 cup\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$because only 3 cup\\n# Code\\n```\\nclass Solution {\\n     public int fillCups(int[] amount) {\\n        int maxCup = 0, sum = 0;\\n        for(int curCup: amount) {\\n            maxCup = Math.max(curCup, maxCup);\\n            sum += curCup;\\n        }\\n        return Math.max(maxCup, (sum + 1) / 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int fillCups(int[] amount) {\\n        int maxCup = 0, sum = 0;\\n        for(int curCup: amount) {\\n            maxCup = Math.max(curCup, maxCup);\\n            sum += curCup;\\n        }\\n        return Math.max(maxCup, (sum + 1) / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744589,
                "title": "using-heap-js-solution",
                "content": "```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function (amount) {\\n  const q = new MaxPriorityQueue();\\n  for (let i = 0; i < amount.length; i++) {\\n    q.enqueue(amount[i]);\\n  }\\n\\n  let total = 0;\\n  while (true) {\\n    let a = q.dequeue().element;\\n    let b = q.dequeue().element;\\n\\n    if (a == 0 || b == 0) {\\n      total = total + (a + b);\\n          return total;\\n    } else {\\n      total++;\\n      a--;\\n      b--;\\n\\n      q.enqueue(a);\\n      q.enqueue(b);\\n    }\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function (amount) {\\n  const q = new MaxPriorityQueue();\\n  for (let i = 0; i < amount.length; i++) {\\n    q.enqueue(amount[i]);\\n  }\\n\\n  let total = 0;\\n  while (true) {\\n    let a = q.dequeue().element;\\n    let b = q.dequeue().element;\\n\\n    if (a == 0 || b == 0) {\\n      total = total + (a + b);\\n          return total;\\n    } else {\\n      total++;\\n      a--;\\n      b--;\\n\\n      q.enqueue(a);\\n      q.enqueue(b);\\n    }\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2502009,
                "title": "easy-to-understand-java-code",
                "content": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec=0;\\n        Arrays.sort(amount);\\n        while (amount[1]>0 && amount[2]>0){\\n            amount[1]--;\\n            amount[2]--;\\n        Arrays.sort(amount);    \\n            sec++;\\n        }\\n        while(amount[2]>0 ){\\n            amount[2]--;\\n            \\n            sec++;\\n        }\\n        return sec;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec=0;\\n        Arrays.sort(amount);\\n        while (amount[1]>0 && amount[2]>0){\\n            amount[1]--;\\n            amount[2]--;\\n        Arrays.sort(amount);    \\n            sec++;\\n        }\\n        while(amount[2]>0 ){\\n            amount[2]--;\\n            \\n            sec++;\\n        }\\n        return sec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489518,
                "title": "python-max-heap-greedy-solution",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        # Greedy using priority queue\\n        heap = []\\n        for a in amount:\\n            heapq.heappush(heap, -a)\\n        seconds = 0\\n        while heap[0] != 0:\\n\\t\\t    # get the max two cup\\n            max1 = heappop(heap)\\n            max2 = heappop(heap)\\n            seconds += 1\\n            heappush(heap, max1 + 1)\\n            heappush(heap, max2 + 1)\\n\\t\\t\\n        return seconds\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        # Greedy using priority queue\\n        heap = []\\n        for a in amount:\\n            heapq.heappush(heap, -a)\\n        seconds = 0\\n        while heap[0] != 0:\\n\\t\\t    # get the max two cup\\n            max1 = heappop(heap)\\n            max2 = heappop(heap)\\n            seconds += 1\\n            heappush(heap, max1 + 1)\\n            heappush(heap, max2 + 1)\\n\\t\\t\\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420959,
                "title": "java-3-liner-code-easy-understanding",
                "content": "**DON\\'T FORGET TO UPVOTE IT HELPS A LOT**\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int max = Math.max(Math.max(amount[0],amount[1]),amount[2]);\\n        int sum = amount[0] + amount[1] + amount[2];\\n        return Math.max(max , (sum+1)/2);\\n    }\\n}\\n```\\n**UPVOTE IF YOU LIKED SOLUTION**\\n# UPVOTE",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int max = Math.max(Math.max(amount[0],amount[1]),amount[2]);\\n        int sum = amount[0] + amount[1] + amount[2];\\n        return Math.max(max , (sum+1)/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372713,
                "title": "swift-one-liner-fastest-simplest-fully-explained",
                "content": "**One-Liner (accepted answer)**\\n```\\nclass Solution {\\n    func fillCups(_ amount: [Int]) -> Int {\\n        max(amount.max()!, amount.reduce(1,+)/2)\\n    }\\n}\\n```\\n\\n**SOLUTION EXPLANATION**\\n\\n**Approach**\\n1) First, imagine the three element array is separated into three sorted values: Small, Medium and Large replace Cold, Warm, Hot.\\n2) There are two cases to this problem:\\n\\t**Case 1: Largest element is at least the size of the two other elements combined.** (`Medium + Small <= Large`): \\n\\tSubtract the combined middle and smaller elements from the largest. These will pair up with the subtracted units, one per second. The remaining value of the largest will reduce by one unit every second. Since both slices of the largest element go away one unit per second, it doesn\\'t matter what size or proportion of the slices are, the largest value is the number of seconds it will take for the cups to get filled up, so return that value.\\n\\t\\n\\t**Case 2: Largest element is smaller than the other two elements combined.** (`Medium + Small > Large`)\\n\\tThe difference between `(Medium - Small) < Large` (otherwise, Medium would become Large).  We\\'ll remove one unit at a time from Large and remove a pairing unit from the largest of Medium and Small values. When Large is exhausted, the difference between Medium and Small will be zero or one. So, the total number of seconds is determined by paring up all units of the three values (plus the odd-case). We can calculate this total number by adding up the original three values, add one to expose the odd-case and divide the sum by 2 (pairs) to get the number of seconds required to fill the cups.  \\n\\n3) If we don\\'t sort the array, we don\\'t have access to Small, Medium or Large. This is OK, between the two cases, we calculate both of them and return the larger of the two values. When Case 1 is the case, the largest value in the array is at least the size of the calculation in Case 2, so return that. When Case 2 is the case, the largest value in the array doesn\\'t contribute as much as half of all three values, so we can use the `max()` operator between the two cases to determine which case is active.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func fillCups(_ amount: [Int]) -> Int {\\n        max(amount.max()!, amount.reduce(1,+)/2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349580,
                "title": "java-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        int sum = a[0] + a[1] + a[2];\\n        int max = Math.max(a[0], Math.max(a[1], a[2]));\\n        \\n        if(2*max >= sum) return max;\\n        if(sum % 2 == 0) return sum / 2;\\n        \\n        return (sum / 2) + 1;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2341546,
                "title": "java-pure-brute-force-solution",
                "content": "class Solution {\\n    public int fillCups(int[] amount) {\\n        int countSec=0;\\n        while(true){\\n         Arrays.sort(amount);\\n         if(amount[0]==0&&amount[1]==0&&amount[2]==0){\\n             break;\\n         }\\n         ++countSec;  \\n            if(amount[1]>0)\\n            {\\n                amount[1]--;\\n            }\\n            if(amount[2]>0){\\n                amount[2]--;\\n            }\\n     }   \\n        return countSec;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int fillCups(int[] amount) {\\n        int countSec=0;\\n        while(true){\\n         Arrays.sort(amount);\\n         if(amount[0]==0&&amount[1]==0&&amount[2]==0){\\n             break;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2320932,
                "title": "fastest-and-easy-to-understand-7-line-code",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        time = 0\\n        \\n        while amount!= [0,0,0]:\\n            amount.sort()\\n            if amount[-1] > 0:\\n                amount[-1] -=1\\n            if amount[-2] >0:\\n                amount[-2] -=1\\n            \\n            time+=1\\n            \\n        return(time)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        time = 0\\n        \\n        while amount!= [0,0,0]:\\n            amount.sort()\\n            if amount[-1] > 0:\\n                amount[-1] -=1\\n            if amount[-2] >0:\\n                amount[-2] -=1\\n            \\n            time+=1\\n            \\n        return(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286807,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        m,s = max(amount),sum(amount)\\n        return max(m,s//2+s%2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        m,s = max(amount),sum(amount)\\n        return max(m,s//2+s%2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277628,
                "title": "java-simple-solution",
                "content": "```class Solution {\\n    public int fillCups(int[] amount) {\\n        int cold = amount[0];\\n        int warm = amount[1];\\n        int hot = amount[2];\\n        int ans = 0 ;\\n        while(cold > 0 || warm > 0 || hot > 0){\\n            if(cold >= warm && warm >= hot){\\n                cold--;\\n                warm--;\\n                ans++;\\n            }else if(cold >= warm && hot >= warm){\\n                cold--;\\n                hot--;\\n                ans++;\\n            }else if(warm >= cold && hot >= warm){\\n                hot--;\\n                warm--;\\n                ans++;\\n            }else if(warm>= cold && warm >= hot){\\n                warm--;\\n                if(cold > hot){\\n                    cold--;\\n                }else{\\n                    hot--;\\n                }\\n                ans++;\\n            }\\n            else if(warm == hot && hot == cold ){\\n                warm--;\\n                cold--;\\n                ans++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n\\t\\t\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int fillCups(int[] amount) {\\n        int cold = amount[0];\\n        int warm = amount[1];\\n        int hot = amount[2];\\n        int ans = 0 ;\\n        while(cold > 0 || warm > 0 || hot > 0){\\n            if(cold >= warm && warm >= hot){\\n                cold--;\\n                warm--;\\n                ans++;\\n            }else if(cold >= warm && hot >= warm){\\n                cold--;\\n                hot--;\\n                ans++;\\n            }else if(warm >= cold && hot >= warm){\\n                hot--;\\n                warm--;\\n                ans++;\\n            }else if(warm>= cold && warm >= hot){\\n                warm--;\\n                if(cold > hot){\\n                    cold--;\\n                }else{\\n                    hot--;\\n                }\\n                ans++;\\n            }\\n            else if(warm == hot && hot == cold ){\\n                warm--;\\n                cold--;\\n                ans++;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n\\t\\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275166,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nint fillCups(vector<int>& amount) {\\n        int n=amount.size();\\n        sort(amount.begin(),amount.end());\\n        int cnt=0;\\n        while(amount[1]!=0){\\n            amount[1]--;\\n            amount[2]--;\\n            cnt++;\\n            sort(amount.begin(),amount.end());\\n        }\\n        cnt+=amount[2];\\n        return cnt;\\n    }\\n\\t```\\nSort the array then run the loop while the middle element of the array is not equal to 0 because then it wouldn\\'t be able to make pairs with greater elements.\\nEvery time the loop runs just subtract second highest and highest element by one when middle element becomes zero add the largest element to count variable. Don\\'t forget to sort the array after each iteration of while loop.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint fillCups(vector<int>& amount) {\\n        int n=amount.size();\\n        sort(amount.begin(),amount.end());\\n        int cnt=0;\\n        while(amount[1]!=0){\\n            amount[1]--;\\n            amount[2]--;\\n            cnt++;\\n            sort(amount.begin(),amount.end());\\n        }\\n        cnt+=amount[2];\\n        return cnt;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273298,
                "title": "javascript-solution-fast-easy-to-understand-simple",
                "content": "```\\nvar fillCups = function(amount) {\\n    var count = 0\\n    var a = amount\\n    while (eval(a.join(\"+\")) > 0) {\\n        var max = Math.max(...a)\\n        a.splice(a.indexOf(max), 1)\\n        var max2 = Math.max(...a)\\n        a.splice(a.indexOf(max2), 1)\\n        count++\\n        if(max == 0) a.push(0)\\n        else a.push(max - 1)\\n        if (max2==0) a.push(0)\\n        else a.push(max2 - 1)\\n    } return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar fillCups = function(amount) {\\n    var count = 0\\n    var a = amount\\n    while (eval(a.join(\"+\")) > 0) {\\n        var max = Math.max(...a)\\n        a.splice(a.indexOf(max), 1)\\n        var max2 = Math.max(...a)\\n        a.splice(a.indexOf(max2), 1)\\n        count++\\n        if(max == 0) a.push(0)\\n        else a.push(max - 1)\\n        if (max2==0) a.push(0)\\n        else a.push(max2 - 1)\\n    } return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271334,
                "title": "c-100-faster",
                "content": "Let\\'s take an example \\ni/p :\\namount = [2,3,9]\\nIn this example, instead of calculating all the calculations, I just took the addition of all elements if that is less than a maximum element of the amount, then return the maximum element of the amount vector.\\ni/p :\\namount = [8,9,13]\\nIn this example, the sum of the first two elements is greater than the maximum element, so I took the addition of all elements, if it is odd then just return (sum / 2) + 1, else return sum/2.\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) \\n    {\\n        sort(amount.begin(), amount.end());\\n        if(amount[0] + amount[1] <= amount[2])\\n            return amount[2];\\n        else\\n        {\\n            int cnt = amount[0] + amount[1] + amount[2];\\n            if(cnt % 2 == 1)\\n            {\\n                return (cnt/2) + 1;\\n            }\\n            else\\n            {\\n                return cnt/2;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) \\n    {\\n        sort(amount.begin(), amount.end());\\n        if(amount[0] + amount[1] <= amount[2])\\n            return amount[2];\\n        else\\n        {\\n            int cnt = amount[0] + amount[1] + amount[2];\\n            if(cnt % 2 == 1)\\n            {\\n                return (cnt/2) + 1;\\n            }\\n            else\\n            {\\n                return cnt/2;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264795,
                "title": "c-solution-priority-queue-easy-understanding",
                "content": "\\n```\\n  int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;   //  max heap\\n        \\n        for(auto amt: amount)\\n            pq.push(amt);\\n        \\n        \\n        int count=0;\\n        while(!pq.empty())\\n        {\\n            if(pq.top()==0) break;   // if all bottles are filled\\n            if(pq.size()==1)         // if only one bottle is left , fill it in one by one time, so add the needed time to count\\n            {\\n               count+= pq.top();\\n               break;\\n            }\\n            int hot= pq.top();    // maxm cap\\n            pq.pop();\\n            int warm = pq.top();  // 2nd max cap\\n            pq.pop();\\n            \\n            \\n            count++;         //pourred both max n 2nd max , so increse counter\\n            if(hot>1) pq.push(--hot);     // if left amt is less then 0 , then we have alreday filled that cup\\n            if(warm>1)pq.push(--warm);    // so wont add to the queue\\n         \\n                \\n            \\n                \\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n  int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;   //  max heap\\n        \\n        for(auto amt: amount)\\n            pq.push(amt);\\n        \\n        \\n        int count=0;\\n        while(!pq.empty())\\n        {\\n            if(pq.top()==0) break;   // if all bottles are filled\\n            if(pq.size()==1)         // if only one bottle is left , fill it in one by one time, so add the needed time to count\\n            {\\n               count+= pq.top();\\n               break;\\n            }\\n            int hot= pq.top();    // maxm cap\\n            pq.pop();\\n            int warm = pq.top();  // 2nd max cap\\n            pq.pop();\\n            \\n            \\n            count++;         //pourred both max n 2nd max , so increse counter\\n            if(hot>1) pq.push(--hot);     // if left amt is less then 0 , then we have alreday filled that cup\\n            if(warm>1)pq.push(--warm);    // so wont add to the queue\\n         \\n                \\n            \\n                \\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262115,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n  /*      [5,4,4]\\nOutput: 7\\n\\n    5    4    4\\n    c    w    h\\n    4    4    3\\n    3    3    3\\n    2    2    3\\n    2    1    2\\n    1    1    1\\n    0    0    1\\n    0    0    0 \\n    pq=   5   4   4\\n    cnt=1 pq=  4   4  3\\n    cnt=2 pq=  3   3  3 \\n    cnt=3 pq   3   2   2 \\n    cnt=4 pq=  2   2   1\\n    cnt=5 pq=  1   1   1\\n    cnt=6 pq=  1   0   0\\n    cnt=7 pq = 0   0   0\\n    \\n    \\n    */\\n\\n        // we must track of top two frequent nubmers pop them reduce them by one and push them again\\n        int cnt=0;\\n        priority_queue<int> pq;\\n        for(auto i:amount)\\n            pq.push(i);\\n        while(pq.top()>0){\\n            \\n            int x=pq.top();\\n            pq.pop();\\n            int y=pq.top();\\n            pq.pop();\\n            cnt++;\\n            pq.push(x-1);\\n           pq.push(y-1);\\n            \\n        }\\n        return cnt;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n  /*      [5,4,4]\\nOutput: 7\\n\\n    5    4    4\\n    c    w    h\\n    4    4    3\\n    3    3    3\\n    2    2    3\\n    2    1    2\\n    1    1    1\\n    0    0    1\\n    0    0    0 \\n    pq=   5   4   4\\n    cnt=1 pq=  4   4  3\\n    cnt=2 pq=  3   3  3 \\n    cnt=3 pq   3   2   2 \\n    cnt=4 pq=  2   2   1\\n    cnt=5 pq=  1   1   1\\n    cnt=6 pq=  1   0   0\\n    cnt=7 pq = 0   0   0\\n    \\n    \\n    */\\n\\n        // we must track of top two frequent nubmers pop them reduce them by one and push them again\\n        int cnt=0;\\n        priority_queue<int> pq;\\n        for(auto i:amount)\\n            pq.push(i);\\n        while(pq.top()>0){\\n            \\n            int x=pq.top();\\n            pq.pop();\\n            int y=pq.top();\\n            pq.pop();\\n            cnt++;\\n            pq.push(x-1);\\n           pq.push(y-1);\\n            \\n        }\\n        return cnt;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261703,
                "title": "efficient-java-soln-no-sort",
                "content": "first while loop:\\n\\tdetract from max number each pass \\nsecond while loop:\\n\\tfinish remainder if not already finished\\n\\n```\\npublic int fillCups(int[] amount) {\\n        int count = 0;\\n        while(amount[0] > 0)\\n        {\\n            amount[0] -= 1;\\n            if(amount[1] < amount[2])\\n                amount[2] -= 1;\\n            else\\n                amount[1] -= 1;\\n            \\n            count++;\\n        }\\n        while(amount[1] > 0 || amount[2] > 0)\\n        {\\n            amount[1] -= 1;\\n            amount[2] -= 1;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int fillCups(int[] amount) {\\n        int count = 0;\\n        while(amount[0] > 0)\\n        {\\n            amount[0] -= 1;\\n            if(amount[1] < amount[2])\\n                amount[2] -= 1;\\n            else\\n                amount[1] -= 1;\\n            \\n            count++;\\n        }\\n        while(amount[1] > 0 || amount[2] > 0)\\n        {\\n            amount[1] -= 1;\\n            amount[2] -= 1;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261646,
                "title": "javascript",
                "content": "```\\nvar fillCups = function(amount) {\\n    let total = 0;\\n    let max = 0;\\n    for (let i = 0; i < amount.length; i++) {\\n        max = Math.max(max, amount[i]);\\n        total += amount[i];\\n    }\\n\\t\\n\\t// if max cups bigger or equal to the sum of remain two smaller cups, then max cups will cover all number of cups we needed.\\n    if (max >= total - max) return max;\\n    return Math.ceil(total / 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar fillCups = function(amount) {\\n    let total = 0;\\n    let max = 0;\\n    for (let i = 0; i < amount.length; i++) {\\n        max = Math.max(max, amount[i]);\\n        total += amount[i];\\n    }\\n\\t\\n\\t// if max cups bigger or equal to the sum of remain two smaller cups, then max cups will cover all number of cups we needed.\\n    if (max >= total - max) return max;\\n    return Math.ceil(total / 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261554,
                "title": "java-solution-priorityqueue",
                "content": "* the quetion it is to find the minimum time ,and given that can fill 2 at a time or 1 \\n* to find minimum first fill how many times 2 cups can be filled using priority queue(filling last maximum 2 cups) and remaining will be a left out cup fill it directly with that value.\\n\\n```\\nclass Solution {\\n    public int fillCups(int[] nums) {\\n        int c=0,t1=0,t2=0;\\n        PriorityQueue<Integer>q=new PriorityQueue<>(Collections.reverseOrder());\\n         for(int i:nums)\\n             q.add(i);\\n        while(q.peek()!=0){\\n            t1=q.remove();\\n            t2=q.remove();\\n            if(t2!=0){\\n                q.add(t1-1);\\n                q.add(t2-1);\\n                c++;\\n            }\\n            else return c+t1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] nums) {\\n        int c=0,t1=0,t2=0;\\n        PriorityQueue<Integer>q=new PriorityQueue<>(Collections.reverseOrder());\\n         for(int i:nums)\\n             q.add(i);\\n        while(q.peek()!=0){\\n            t1=q.remove();\\n            t2=q.remove();\\n            if(t2!=0){\\n                q.add(t1-1);\\n                q.add(t2-1);\\n                c++;\\n            }\\n            else return c+t1;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261546,
                "title": "javascript-greedy-113ms",
                "content": "Main idea: each time needs to remove the max count of two color(to make as much as double color being removed per step), until there is only one color left\\n```\\nconst fillCups = (a) => {\\n    let res = 0;\\n    while (!valid(a)) {\\n        a.sort((x, y) => x - y);\\n        if (a[1] > 0) { // can make two color remove\\n            a[2]--;\\n            a[1]--;\\n            res++;\\n        } else { // only one color left\\n            res += a[2];\\n            break;\\n        }\\n    }\\n    return res;\\n};\\n\\nconst valid = (a) => a.every(x => x <= 0);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst fillCups = (a) => {\\n    let res = 0;\\n    while (!valid(a)) {\\n        a.sort((x, y) => x - y);\\n        if (a[1] > 0) { // can make two color remove\\n            a[2]--;\\n            a[1]--;\\n            res++;\\n        } else { // only one color left\\n            res += a[2];\\n            break;\\n        }\\n    }\\n    return res;\\n};\\n\\nconst valid = (a) => a.every(x => x <= 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261518,
                "title": "java-easy-solution",
                "content": "**JAVA EASY SOLUTION**\\n\\n* First find max and smax elements \\n* Reduce max and smax and increase the time\\n* Return the time\\n\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        \\n        int sec = 0;\\n    \\n        while(amount[0] > 0 || amount[1] > 0 || amount[2] > 0){\\n            \\n            int fmax = (amount[0] > amount[1]) ? (amount[0] > amount[2]) ? 0 : 2 : (amount[1] > amount[2]) ? 1 : 2; \\n            int smax = (amount[0] > amount[1]) ? (amount[0] > amount[2]) ? (amount[1] > amount[2]) ? 1 : 2 : 0 : (amount[1] > amount[2]) ? (amount[0] > amount[2]) ? 0 : 2 : 1;\\n            \\n            amount[fmax]--;\\n            amount[smax]--;\\n            \\n            sec++;\\n        }\\n        \\n        return sec;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        \\n        int sec = 0;\\n    \\n        while(amount[0] > 0 || amount[1] > 0 || amount[2] > 0){\\n            \\n            int fmax = (amount[0] > amount[1]) ? (amount[0] > amount[2]) ? 0 : 2 : (amount[1] > amount[2]) ? 1 : 2; \\n            int smax = (amount[0] > amount[1]) ? (amount[0] > amount[2]) ? (amount[1] > amount[2]) ? 1 : 2 : 0 : (amount[1] > amount[2]) ? (amount[0] > amount[2]) ? 0 : 2 : 1;\\n            \\n            amount[fmax]--;\\n            amount[smax]--;\\n            \\n            sec++;\\n        }\\n        \\n        return sec;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2261346,
                "title": "c-easy-solution-two-approaches-constant-space-and-heap",
                "content": "**Approach 1 ---> Priority Queue**\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& arr) {\\n        int count=0;        \\n        priority_queue<int>pq(arr.begin(),arr.end());\\n        while(pq.top()!=0){\\n            int t1=pq.top();\\n            pq.pop();\\n            int t2=pq.top();\\n            pq.pop();\\n            pq.push(t1-1);\\n            pq.push(t2-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Approach 2 --> Constant Space**\\n\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& arr) {\\n        sort(arr.begin(),arr.end()); \\n      int x=arr[0], y=arr[1],z=arr[2]; \\n      int sum=x+y+z; \\n      if(x+y>z)return sum/2+sum%2; \\n      if(x==0 && y==0)return z; \\n      else  return z; \\n    } \\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& arr) {\\n        int count=0;        \\n        priority_queue<int>pq(arr.begin(),arr.end());\\n        while(pq.top()!=0){\\n            int t1=pq.top();\\n            pq.pop();\\n            int t2=pq.top();\\n            pq.pop();\\n            pq.push(t1-1);\\n            pq.push(t2-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& arr) {\\n        sort(arr.begin(),arr.end()); \\n      int x=arr[0], y=arr[1],z=arr[2]; \\n      int sum=x+y+z; \\n      if(x+y>z)return sum/2+sum%2; \\n      if(x==0 && y==0)return z; \\n      else  return z; \\n    } \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835549,
                "title": "c-easy-pq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& am) \\n    {\\n        priority_queue<int> pq;\\n        for(auto i :am)\\n        {\\n            pq.push(i);\\n        }\\n        int count=0;\\n        while(pq.top()!=0)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            a--;\\n            b--;\\n            pq.push(a);\\n            pq.push(b);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& am) \\n    {\\n        priority_queue<int> pq;\\n        for(auto i :am)\\n        {\\n            pq.push(i);\\n        }\\n        int count=0;\\n        while(pq.top()!=0)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            a--;\\n            b--;\\n            pq.push(a);\\n            pq.push(b);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565531,
                "title": "simple-c-solution-well-commented-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int seconds = 0;\\n        priority_queue<int> pq;\\n        // pushing all three amount in max heap\\n        pq.push(amount[0]);\\n        pq.push(amount[1]);\\n        pq.push(amount[2]);\\n        // increase the seconds while any cup is left\\n        while(pq.top()>0){\\n            // check the 1st cup \\n            int first;\\n            first = pq.top();\\n            pq.pop();\\n            int second;\\n            // if 2nd cup is left then fill both the cup which take one second\\n            if(pq.top()>0){\\n                second = pq.top();\\n                pq.pop();\\n            }\\n            else{\\n                // if only single type of cup is left than consider one second for each cup\\n                // and add it to the seconds \\n                if(first>0)\\n                    seconds+=first;\\n                break;\\n            }\\n            pq.push(first-1);\\n            pq.push(second-1);\\n            seconds++;\\n        }\\n        return seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int seconds = 0;\\n        priority_queue<int> pq;\\n        // pushing all three amount in max heap\\n        pq.push(amount[0]);\\n        pq.push(amount[1]);\\n        pq.push(amount[2]);\\n        // increase the seconds while any cup is left\\n        while(pq.top()>0){\\n            // check the 1st cup \\n            int first;\\n            first = pq.top();\\n            pq.pop();\\n            int second;\\n            // if 2nd cup is left then fill both the cup which take one second\\n            if(pq.top()>0){\\n                second = pq.top();\\n                pq.pop();\\n            }\\n            else{\\n                // if only single type of cup is left than consider one second for each cup\\n                // and add it to the seconds \\n                if(first>0)\\n                    seconds+=first;\\n                break;\\n            }\\n            pq.push(first-1);\\n            pq.push(second-1);\\n            seconds++;\\n        }\\n        return seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535920,
                "title": "simple-approach-priority-queue-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// AT PARTICULAR INSTANCE WE  TAKE GREATEST 2 ELEMENT AND DECRESE ITS VALUE BY 1 AND AGAIN PUSHED IN THE QUEUE\\n// THEREFORE IF THE SIZE OF QUEUE IS 1 THEN WE CANT TAKE OUT TWO ELEMENT THEREFORE WE HAVE TO RUN THE LOOP TILL\\n// SIZE IS GREATER THAN 2. AFTER DECREASING IF THE VALUE IS EQUAL TO ZERO THEN WE WILL NOT PUSH IN THE QUEUE\\n// ALL THOUGH THE NUMBER OF WATER IS COMPLETED. \\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        for(int i=0;i<3;i++)\\n        {\\n            if(amount[i]!=0) // [5,0,0,] TO AVOID THIS TYPE OF CASES. IF WE DONOT DO THIS STEP THEN SIZE OF \\n            pq.push(amount[i]);// QUEUE IS 3 THEN THE LOOP HAS BEEN STARTED AND AFTER TAKING TWO VALUE AND \\n        }               // DECREASED THAT VALUE WE GET (4,-1) AND THEN INSERTED IN QUEUE THEN THE DECRESED VALUE \\n        int count=0; // WILL NEVER BE ZERO AND HENCE THE SIZE WILL NOT DECREASES ....INFINTE LOOP OCCUR\\n        while(pq.size()>1)\\n        {\\n            int top1 = pq.top();\\n            pq.pop();\\n            int top2 = pq.top();\\n            pq.pop();\\n            top1-=1;\\n            top2-=1;\\n            if(top1!=0)\\n            pq.push(top1);\\n            if(top2!=0)\\n            pq.push(top2);\\n            count++; \\n        }\\n        if(!pq.empty()) return count+pq.top();\\n        return count;\\n\\n          OR  \\n\\n        priority_queue<int>pq(amount.begin(),amount.end());\\n        int count=0;\\n        while(pq.top()!=0)\\n        {\\n            int t1=pq.top();\\n            pq.pop();\\n            int t2=pq.top();\\n            pq.pop();\\n            pq.push(t1-1);\\n            pq.push(t2-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// AT PARTICULAR INSTANCE WE  TAKE GREATEST 2 ELEMENT AND DECRESE ITS VALUE BY 1 AND AGAIN PUSHED IN THE QUEUE\\n// THEREFORE IF THE SIZE OF QUEUE IS 1 THEN WE CANT TAKE OUT TWO ELEMENT THEREFORE WE HAVE TO RUN THE LOOP TILL\\n// SIZE IS GREATER THAN 2. AFTER DECREASING IF THE VALUE IS EQUAL TO ZERO THEN WE WILL NOT PUSH IN THE QUEUE\\n// ALL THOUGH THE NUMBER OF WATER IS COMPLETED. \\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        for(int i=0;i<3;i++)\\n        {\\n            if(amount[i]!=0) // [5,0,0,] TO AVOID THIS TYPE OF CASES. IF WE DONOT DO THIS STEP THEN SIZE OF \\n            pq.push(amount[i]);// QUEUE IS 3 THEN THE LOOP HAS BEEN STARTED AND AFTER TAKING TWO VALUE AND \\n        }               // DECREASED THAT VALUE WE GET (4,-1) AND THEN INSERTED IN QUEUE THEN THE DECRESED VALUE \\n        int count=0; // WILL NEVER BE ZERO AND HENCE THE SIZE WILL NOT DECREASES ....INFINTE LOOP OCCUR\\n        while(pq.size()>1)\\n        {\\n            int top1 = pq.top();\\n            pq.pop();\\n            int top2 = pq.top();\\n            pq.pop();\\n            top1-=1;\\n            top2-=1;\\n            if(top1!=0)\\n            pq.push(top1);\\n            if(top2!=0)\\n            pq.push(top2);\\n            count++; \\n        }\\n        if(!pq.empty()) return count+pq.top();\\n        return count;\\n\\n          OR  \\n\\n        priority_queue<int>pq(amount.begin(),amount.end());\\n        int count=0;\\n        while(pq.top()!=0)\\n        {\\n            int t1=pq.top();\\n            pq.pop();\\n            int t2=pq.top();\\n            pq.pop();\\n            pq.push(t1-1);\\n            pq.push(t2-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459997,
                "title": "100-beat-runtime-easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) \\n    {\\n        priority_queue<int>q;\\n        for(int a:amount)\\n            q.push(a);\\n        bool flag=true;\\n        int sum=0;\\n        while(flag)\\n        {\\n            int a=q.top();\\n            q.pop();\\n            int b=q.top();\\n            q.pop();\\n            if(b==0)\\n            {\\n                sum=sum+a;\\n                flag=false;\\n            }\\n            else\\n            {\\n                sum++;\\n                a--;b--;\\n                q.push(a);\\n                q.push(b);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) \\n    {\\n        priority_queue<int>q;\\n        for(int a:amount)\\n            q.push(a);\\n        bool flag=true;\\n        int sum=0;\\n        while(flag)\\n        {\\n            int a=q.top();\\n            q.pop();\\n            int b=q.top();\\n            q.pop();\\n            if(b==0)\\n            {\\n                sum=sum+a;\\n                flag=false;\\n            }\\n            else\\n            {\\n                sum++;\\n                a--;b--;\\n                q.push(a);\\n                q.push(b);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283991,
                "title": "a-beginner-friendly-java-solution",
                "content": "A solution for complete beginners...\\nPlease upvote if it helps!\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] arr) {\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int i : arr) max.add(i);\\n\\n        int count = 0;\\n        while(max.peek() > 0) {\\n            int num1 = max.poll();\\n            int num2 = max.poll();\\n            max.add(--num1);\\n            max.add(--num2);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] arr) {\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int i : arr) max.add(i);\\n\\n        int count = 0;\\n        while(max.peek() > 0) {\\n            int num1 = max.poll();\\n            int num2 = max.poll();\\n            max.add(--num1);\\n            max.add(--num2);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225337,
                "title": "c-easy-to-understand-using-priority-queue-2ms-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> p;\\n        for(auto it: amount) p.push(it);\\n        int total=0;\\n        int a,b;\\n        while(1){\\n            a=p.top(); p.pop();\\n            b=p.top(); p.pop();\\n            if(a==0 || b==0){\\n                total+=(a+b);\\n                return total;\\n            }\\n            else{\\n                total++;\\n                a-- , b--;\\n                p.push(a);\\n                p.push(b);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> p;\\n        for(auto it: amount) p.push(it);\\n        int total=0;\\n        int a,b;\\n        while(1){\\n            a=p.top(); p.pop();\\n            b=p.top(); p.pop();\\n            if(a==0 || b==0){\\n                total+=(a+b);\\n                return total;\\n            }\\n            else{\\n                total++;\\n                a-- , b--;\\n                p.push(a);\\n                p.push(b);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094092,
                "title": "java-solution-with-explanation",
                "content": "# Intuition\\nJust keep filling the least and most required cups together\\n\\n# Approach\\nSort the array. Keep removing the smallest value and the largest value by 1, until the smallest one is zero, then increase the answer by the left out max value\\n\\n# Complexity\\n- Time complexity:\\nO(smallest value)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int ans = 0;\\n        int lo=0, hi=2;\\n        if(amount[0] == 0) lo++;\\n        if(lo==1 && amount[1]==0) return amount[2];\\n\\n        else if(lo==1){\\n            ans += amount[hi];\\n            return ans;\\n        }\\n        while(amount[lo] != 0){\\n            ans++;\\n            amount[lo]--;\\n            amount[hi]--;\\n            if(amount[hi-1] > amount[hi]){\\n                int temp = amount[hi-1];\\n                amount[hi-1] = amount[hi];\\n                amount[hi] = temp;\\n            }\\n        }\\n\\n        ans += amount[2];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int ans = 0;\\n        int lo=0, hi=2;\\n        if(amount[0] == 0) lo++;\\n        if(lo==1 && amount[1]==0) return amount[2];\\n\\n        else if(lo==1){\\n            ans += amount[hi];\\n            return ans;\\n        }\\n        while(amount[lo] != 0){\\n            ans++;\\n            amount[lo]--;\\n            amount[hi]--;\\n            if(amount[hi-1] > amount[hi]){\\n                int temp = amount[hi-1];\\n                amount[hi-1] = amount[hi];\\n                amount[hi] = temp;\\n            }\\n        }\\n\\n        ans += amount[2];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063210,
                "title": "c",
                "content": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)b - *(int*)a ;\\n}\\nint fillCups(int* amount, int amountSize){\\n    qsort(amount, amountSize, sizeof(int), cmp) ;\\n    if(amount[0] >= (amount[1] + amount[2]))\\n        return amount[0] ;\\n    else{\\n        return amount[0] + (amount[1] + amount[2] - amount[0] + 1) / 2 ;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)b - *(int*)a ;\\n}\\nint fillCups(int* amount, int amountSize){\\n    qsort(amount, amountSize, sizeof(int), cmp) ;\\n    if(amount[0] >= (amount[1] + amount[2]))\\n        return amount[0] ;\\n    else{\\n        return amount[0] + (amount[1] + amount[2] - amount[0] + 1) / 2 ;\\n    } \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3061791,
                "title": "c-using-max-and-sort-greater",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int ans = 0;\\n        while(amount.size() > 2) {\\n            sort(amount.begin(), amount.end(), greater<int>());\\n            if(amount[2] == 0) {\\n                amount.pop_back();\\n            } else {\\n                amount[0]--;\\n                amount[2]--;\\n                ans++;\\n            }\\n        }\\n        return ans + max(amount[0], amount[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int ans = 0;\\n        while(amount.size() > 2) {\\n            sort(amount.begin(), amount.end(), greater<int>());\\n            if(amount[2] == 0) {\\n                amount.pop_back();\\n            } else {\\n                amount[0]--;\\n                amount[2]--;\\n                ans++;\\n            }\\n        }\\n        return ans + max(amount[0], amount[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034808,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func fillCups(_ amount: [Int]) -> Int {\\n        \\n        var am = amount\\n        var res = 0\\n        \\n        while am.reduce(0, +) > 0 {\\n            am = am.sorted()\\n            am[1] = max(0, am[1] - 1)\\n            am[2] = max(0, am[2] - 1)\\n            res += 1\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func fillCups(_ amount: [Int]) -> Int {\\n        \\n        var am = amount\\n        var res = 0\\n        \\n        while am.reduce(0, +) > 0 {\\n            am = am.sorted()\\n            am[1] = max(0, am[1] - 1)\\n            am[2] = max(0, am[2] - 1)\\n            res += 1\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894459,
                "title": "c-easy-solution-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        \\n        for(int i=0;i<amount.size();i++){\\n            pq.push(amount[i]);\\n        }\\n        int ans=0;\\n        while(pq.top()!=0){\\n\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            a--;\\n            b--;\\n            pq.push(a);\\n            pq.push(b);\\n            ans++;\\n          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        \\n        for(int i=0;i<amount.size();i++){\\n            pq.push(amount[i]);\\n        }\\n        int ans=0;\\n        while(pq.top()!=0){\\n\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            a--;\\n            b--;\\n            pq.push(a);\\n            pq.push(b);\\n            ans++;\\n          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634293,
                "title": "golang-solution-based-on-sorting",
                "content": "```\\nfunc fillCups(amount []int) int {\\n    sort.Ints(amount)\\n    a, b := amount[0] + amount[1], amount[2]\\n    if a < b {\\n        return b\\n    }\\n    return b + (a - b + 1) / 2\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc fillCups(amount []int) int {\\n    sort.Ints(amount)\\n    a, b := amount[0] + amount[1], amount[2]\\n    if a < b {\\n        return b\\n    }\\n    return b + (a - b + 1) / 2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533048,
                "title": "java-most-easiest-solution-for-beginners",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n       int count=0;\\n       while(amount[0]>0||amount[1]>0||amount[2]>0)\\n       {\\n           if(amount[0]==0&&amount[1]==0)\\n               return count+amount[2];\\n           \\n           else if(amount[0]==0&&amount[2]==0)\\n               return count+amount[1];\\n           \\n           else if(amount[1]==0&&amount[2]==0)\\n               return count+amount[0];\\n           else if(amount[0]==0)\\n           {\\n               amount[1]-=1;\\n               amount[2]-=1;\\n               count++;\\n           }\\n           else if(amount[1]==0)\\n           {\\n               \\n               amount[0]-=1;\\n               amount[2]-=1;\\n               count++;\\n           }\\n           else if(amount[2]==0)\\n           {\\n               \\n               amount[1]-=1;\\n               amount[0]-=1;\\n               count++;\\n           }\\n           else \\n           {\\n               int i=maximum(amount);\\n               int j=max2(amount);\\n               amount[i]-=1;\\n               amount[j]-=1;\\n               count++;\\n           }\\n       }\\n        return count;\\n    }\\n    public int maximum(int[]array)\\n    {\\n        if(array[0]>=array[1] && array[0]>=array[2])\\n            return 0;\\n\\n        else if(array[1]>=array[0] && array[1]>=array[2])\\n            return 1;\\n\\n        else if(array[2]>=array[0] && array[2]>=array[1])\\n            return 2;\\n        return 0;\\n\\n    }\\n    public int max2(int[]array)\\n    {\\n        if(array[0]>array[1] && array[0]>array[2])\\n        {\\n            if(array[1]>array[2])\\n                return 1;\\n            else return 2;\\n        }\\n        else if(array[1]>array[0] && array[1]>array[2])\\n        {\\n            if(array[0]>array[2])\\n                return 0;\\n            else return 2;\\n        }\\n        else \\n        {\\n            if(array[0]>array[1])\\n                return 0;\\n            else return 1;\\n        }\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int fillCups(int[] amount) {\\n       int count=0;\\n       while(amount[0]>0||amount[1]>0||amount[2]>0)\\n       {\\n           if(amount[0]==0&&amount[1]==0)\\n               return count+amount[2];\\n           \\n           else if(amount[0]==0&&amount[2]==0)\\n               return count+amount[1];\\n           \\n           else if(amount[1]==0&&amount[2]==0)\\n               return count+amount[0];\\n           else if(amount[0]==0)\\n           {\\n               amount[1]-=1;\\n               amount[2]-=1;\\n               count++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2482131,
                "title": "python-easy-2-approach-max-heap-while-loop-based",
                "content": "#  Generic solution using while loop and sorting \\n    def fillCups(self, amount: List[int]) -> int:\\n        sortedAmount = sorted(amount)\\n        result = 0\\n        while max(sortedAmount) > 0:\\n            large = sortedAmount.pop()\\n            if sortedAmount:\\n                secLarge = sortedAmount.pop()                \\n            if secLarge and secLarge != 0:\\n                sortedAmount.append(secLarge-1)\\n            if large != 0:\\n                sortedAmount.append(large-1)            \\n            sortedAmount = sorted(sortedAmount)\\n            result += 1\\n        return result\\n\\t\\t\\n\\t\\t\\n\\t\\t# Priority Queue (max heap)\\n\\t\\tdef fillCups(self, amount: List[int]) -> int:\\n\\t\\t\\theap = []\\n\\t\\t\\tfor i in amount:\\n\\t\\t\\t\\tif i > 0:\\n\\t\\t\\t\\t\\theappush(heap, -i)              \\n\\t\\t\\tresult = 0\\n\\t\\t\\twhile heap:\\n            if len(heap) == 1:\\n                return result - heappop(heap) # negative mean (-*-) will be +           \\n            x = -heappop(heap)\\n            y = -heappop(heap)     \\n            if x-1 > 0:\\n                heappush(heap, -(x-1))\\n            if y-1 > 0:\\n                heappush(heap, -(y-1))           \\n            result += 1\\n        return result\\n",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "#  Generic solution using while loop and sorting \\n    def fillCups(self, amount: List[int]) -> int:\\n        sortedAmount = sorted(amount)\\n        result = 0\\n        while max(sortedAmount) > 0:\\n            large = sortedAmount.pop()\\n            if sortedAmount:\\n                secLarge = sortedAmount.pop()                \\n            if secLarge and secLarge != 0:\\n                sortedAmount.append(secLarge-1)\\n            if large != 0:\\n                sortedAmount.append(large-1)            \\n            sortedAmount = sorted(sortedAmount)\\n            result += 1\\n        return result\\n\\t\\t\\n\\t\\t\\n\\t\\t# Priority Queue (max heap)\\n\\t\\tdef fillCups(self, amount: List[int]) -> int:\\n\\t\\t\\theap = []\\n\\t\\t\\tfor i in amount:\\n\\t\\t\\t\\tif i > 0:\\n\\t\\t\\t\\t\\theappush(heap, -i)              \\n\\t\\t\\tresult = 0\\n\\t\\t\\twhile heap:\\n            if len(heap) == 1:\\n                return result - heappop(heap) # negative mean (-*-) will be +           \\n            x = -heappop(heap)\\n            y = -heappop(heap)     \\n            if x-1 > 0:\\n                heappush(heap, -(x-1))\\n            if y-1 > 0:\\n                heappush(heap, -(y-1))           \\n            result += 1\\n        return result\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2458101,
                "title": "python-maxheap-solution",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        heap=[]\\n        for i in amount:\\n            if i!=0:\\n                heappush(heap,i*-1)\\n        seconds=0\\n        while len(heap)!=0:\\n            if len(heap)>=2:\\n                seconds=seconds+1\\n                t1= (heappop(heap)*-1)-1\\n                t2= (heappop(heap)*-1)-1\\n                if t1!=0:\\n                    heappush(heap,t1*-1)\\n                if t2!=0:\\n                    heappush(heap,t2*-1)\\n            elif len(heap)==1:\\n                seconds=seconds+heappop(heap)*-1\\n        return seconds\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        heap=[]\\n        for i in amount:\\n            if i!=0:\\n                heappush(heap,i*-1)\\n        seconds=0\\n        while len(heap)!=0:\\n            if len(heap)>=2:\\n                seconds=seconds+1\\n                t1= (heappop(heap)*-1)-1\\n                t2= (heappop(heap)*-1)-1\\n                if t1!=0:\\n                    heappush(heap,t1*-1)\\n                if t2!=0:\\n                    heappush(heap,t2*-1)\\n            elif len(heap)==1:\\n                seconds=seconds+heappop(heap)*-1\\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445869,
                "title": "c-priority-queue-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        \\n        int count=0;\\n        \\n        priority_queue<int>pq;\\n        if(amount[0]!=0)\\n        pq.push(amount[0]);\\n        \\n        if(amount[1]!=0)\\n        pq.push(amount[1]);\\n        \\n        if(amount[2]!=0)\\n        pq.push(amount[2]);\\n        \\n        while(!pq.empty())\\n        {\\n            if(pq.size()>=2)\\n            {\\n                int val1=pq.top();\\n                pq.pop();\\n                \\n                int val2=pq.top();\\n                pq.pop();\\n                \\n                count++;\\n                val1--;\\n                val2--;\\n                if(val1>0)\\n                {\\n                    pq.push(val1);\\n                }\\n                if(val2>0)\\n                {\\n                    pq.push(val2);\\n                }\\n                \\n            }\\n            else if(pq.size()<=1)\\n            {\\n                int val=pq.top();\\n                pq.pop();\\n                \\n                count++;\\n                val--;\\n                \\n                if(val>0)\\n                {\\n                    pq.push(val);\\n                }\\n            }\\n        }\\n        return count;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        \\n        int count=0;\\n        \\n        priority_queue<int>pq;\\n        if(amount[0]!=0)\\n        pq.push(amount[0]);\\n        \\n        if(amount[1]!=0)\\n        pq.push(amount[1]);\\n        \\n        if(amount[2]!=0)\\n        pq.push(amount[2]);\\n        \\n        while(!pq.empty())\\n        {\\n            if(pq.size()>=2)\\n            {\\n                int val1=pq.top();\\n                pq.pop();\\n                \\n                int val2=pq.top();\\n                pq.pop();\\n                \\n                count++;\\n                val1--;\\n                val2--;\\n                if(val1>0)\\n                {\\n                    pq.push(val1);\\n                }\\n                if(val2>0)\\n                {\\n                    pq.push(val2);\\n                }\\n                \\n            }\\n            else if(pq.size()<=1)\\n            {\\n                int val=pq.top();\\n                pq.pop();\\n                \\n                count++;\\n                val--;\\n                \\n                if(val>0)\\n                {\\n                    pq.push(val);\\n                }\\n            }\\n        }\\n        return count;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427294,
                "title": "c-100-faster-priority-queue-with-explanation",
                "content": "what we are going to do is extract the two maximum number of  cups and decrement their count by 1 and increase our count by 1. And then put the decremented values again in the priority queue unless their value is 0. repeat the process untill our queue gets empty. Note that we also need to check whether the queue has two elements to extract otherwise if the queue has only one element left, then we extract one instead of two.\\n\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n\\t\\t//first of all we put the values in the priority queue if the values are not zero.\\n        for(auto i:amount){\\n            if(i!=0)\\n                pq.push(i);\\n        }\\n        int count=0;\\n\\t\\t//q1 and q2 are the two elements that we will extract\\n        int q1=0;\\n        int q2=0;\\n        while(!pq.empty()){\\n            q1=pq.top();\\n            pq.pop();\\n\\t\\t\\t//now check if after popping queue has any element to be extracted or not\\n            if(pq.size()>0){\\n                q2=pq.top();\\n                pq.pop();\\n            }\\n\\t\\t\\t// if not then we will set q2=1 so that after decrement it  will be 0 and we won\\'t insert in pq \\n            else\\n                q2=1;\\n            count++;\\n            q1--;\\n            q2--;\\n\\t\\t\\t//After decrement, we insert back q1 and q2 if they are not equal to 0;\\n            if(q1!=0)\\n                pq.push(q1);\\n            if(q2!=0)\\n                pq.push(q2);\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n\\t\\t//first of all we put the values in the priority queue if the values are not zero.\\n        for(auto i:amount){\\n            if(i!=0)\\n                pq.push(i);\\n        }\\n        int count=0;\\n\\t\\t//q1 and q2 are the two elements that we will extract\\n        int q1=0;\\n        int q2=0;\\n        while(!pq.empty()){\\n            q1=pq.top();\\n            pq.pop();\\n\\t\\t\\t//now check if after popping queue has any element to be extracted or not\\n            if(pq.size()>0){\\n                q2=pq.top();\\n                pq.pop();\\n            }\\n\\t\\t\\t// if not then we will set q2=1 so that after decrement it  will be 0 and we won\\'t insert in pq \\n            else\\n                q2=1;\\n            count++;\\n            q1--;\\n            q2--;\\n\\t\\t\\t//After decrement, we insert back q1 and q2 if they are not equal to 0;\\n            if(q1!=0)\\n                pq.push(q1);\\n            if(q2!=0)\\n                pq.push(q2);\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404066,
                "title": "c-max-heap-solution",
                "content": "```\\n int fillCups(vector<int>& nums) {\\n        priority_queue<int> max_heap;\\n        for(auto x : nums) {\\n            if(x > 0) max_heap.push(x);\\n        }\\n        int ans = 0;\\n        while(!max_heap.empty() && max_heap.size() >= 2){\\n            int val1 = max_heap.top();\\n            max_heap.pop();\\n            int val2 = max_heap.top();\\n            max_heap.pop();\\n            // 2 steps per second\\n            if(--val1 > 0) max_heap.push(val1);\\n            if(--val2 > 0) max_heap.push(val2);\\n            ans++; // add a second\\n        };\\n        ans += max_heap.empty() ? 0 : max_heap.top(); // only 1 step per second\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n int fillCups(vector<int>& nums) {\\n        priority_queue<int> max_heap;\\n        for(auto x : nums) {\\n            if(x > 0) max_heap.push(x);\\n        }\\n        int ans = 0;\\n        while(!max_heap.empty() && max_heap.size() >= 2){\\n            int val1 = max_heap.top();\\n            max_heap.pop();\\n            int val2 = max_heap.top();\\n            max_heap.pop();\\n            // 2 steps per second\\n            if(--val1 > 0) max_heap.push(val1);\\n            if(--val2 > 0) max_heap.push(val2);\\n            ans++; // add a second\\n        };\\n        ans += max_heap.empty() ? 0 : max_heap.top(); // only 1 step per second\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393567,
                "title": "easy-clear-python3-solution",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        amount.sort()\\n        res=0\\n        while amount[1]>0:\\n            x=amount[1]-amount[0]\\n            if x<1:\\n                x=1\\n            amount[2]-=x\\n            amount[1]-=x\\n            amount.sort()\\n            res+=1=x\\n        res+=amount[2]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        amount.sort()\\n        res=0\\n        while amount[1]>0:\\n            x=amount[1]-amount[0]\\n            if x<1:\\n                x=1\\n            amount[2]-=x\\n            amount[1]-=x\\n            amount.sort()\\n            res+=1=x\\n        res+=amount[2]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369618,
                "title": "c-solution-by-using-priority-queue-heap",
                "content": "```\\n  int fillCups(vector<int>& amount) {\\n        \\n        priority_queue<int> pq;\\n        int zero = 0;\\n        \\n        for(int i=0;i<3;i++){\\n            pq.push(amount[i]);\\n            \\n            if(amount[i]==0){\\n                zero++;\\n            }\\n        }\\n        \\n        if(zero>=1){\\n            return (*max_element(amount.begin(),amount.end()));\\n        }\\n        \\n        int cnt = 0;\\n        \\n        while(pq.top()!=0){\\n            \\n            int x = pq.top()-1;\\n            \\n            pq.pop();\\n            \\n            cnt++;\\n            int y = pq.top()-1;\\n            \\n            pq.pop();\\n            pq.push(y);\\n            pq.push(x);\\n            \\n            if(pq.top()==0){\\n                break;\\n            }\\n            \\n                \\n            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n  int fillCups(vector<int>& amount) {\\n        \\n        priority_queue<int> pq;\\n        int zero = 0;\\n        \\n        for(int i=0;i<3;i++){\\n            pq.push(amount[i]);\\n            \\n            if(amount[i]==0){\\n                zero++;\\n            }\\n        }\\n        \\n        if(zero>=1){\\n            return (*max_element(amount.begin(),amount.end()));\\n        }\\n        \\n        int cnt = 0;\\n        \\n        while(pq.top()!=0){\\n            \\n            int x = pq.top()-1;\\n            \\n            pq.pop();\\n            \\n            cnt++;\\n            int y = pq.top()-1;\\n            \\n            pq.pop();\\n            pq.push(y);\\n            pq.push(x);\\n            \\n            if(pq.top()==0){\\n                break;\\n            }\\n            \\n                \\n            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352234,
                "title": "c-0-ms-priority-queue",
                "content": "Approach ::**Minimise the highest amount first rather than minimising smaller amounts **\\n```\\nint fillCups(vector<int>& amount) {\\n        priority_queue<int,vector<int>> pq;\\n        for(auto i:amount) if(i>0) pq.push(i);\\n        int time=0;\\n        if(pq.size()==0) return 0;\\n        while(pq.size()>1){\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            time++;\\n            if(a-1>0) pq.push(a-1);\\n            if(b-1>0) pq.push(b-1);\\n        }\\n        if(pq.size()==1) time+=pq.top();\\n        return time;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint fillCups(vector<int>& amount) {\\n        priority_queue<int,vector<int>> pq;\\n        for(auto i:amount) if(i>0) pq.push(i);\\n        int time=0;\\n        if(pq.size()==0) return 0;\\n        while(pq.size()>1){\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            time++;\\n            if(a-1>0) pq.push(a-1);\\n            if(b-1>0) pq.push(b-1);\\n        }\\n        if(pq.size()==1) time+=pq.top();\\n        return time;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2349582,
                "title": "cups-and-time",
                "content": "```\\nPriorityQueue<Integer>cups = new PriorityQueue<>(Collections.reverseOrder());\\n        int count=0;\\n        for(int i :  amount){\\n            cups.add(i);\\n        }\\n        while(cups.peek()!=0){\\n        int first = cups.poll();\\n        int second=cups.poll();\\n        cups.add(first-1);\\n        cups.add(second-1);\\n        count++;\\n    }\\n    return count;\\n\\t\\n```\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPriorityQueue<Integer>cups = new PriorityQueue<>(Collections.reverseOrder());\\n        int count=0;\\n        for(int i :  amount){\\n            cups.add(i);\\n        }\\n        while(cups.peek()!=0){\\n        int first = cups.poll();\\n        int second=cups.poll();\\n        cups.add(first-1);\\n        cups.add(second-1);\\n        count++;\\n    }\\n    return count;\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2347194,
                "title": "c-basic-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int cnt=0;\\n        while(amount[0]>0||amount[1]>0 || amount[2]>0){\\n            sort(amount.begin(),amount.end());\\n            amount[1]--;\\n            amount[2]--;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int cnt=0;\\n        while(amount[0]>0||amount[1]>0 || amount[2]>0){\\n            sort(amount.begin(),amount.end());\\n            amount[1]--;\\n            amount[2]--;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332982,
                "title": "java-solution-using-hashmap",
                "content": "class Solution {\\n    public int fillCups(int[] amount) {\\n        \\n        int ans=0;\\n        int n=amount.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>((a,b)-> b-a);\\n        for(int i=0;i<n;i++){\\n            if(amount[i]!=0){\\n            pq.add(amount[i]);\\n            }\\n        }\\n        while(pq.size()>1){\\n            int x=pq.poll();\\n            int y=pq.poll();\\n            ans++;\\n            if(x-1!=0){\\n                pq.add(x-1);\\n            }\\n                if(y-1!=0){\\n                pq.add(y-1);\\n            }\\n        }\\n        if(pq.size()>0){\\n            ans+=pq.poll();\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int fillCups(int[] amount) {\\n        \\n        int ans=0;\\n        int n=amount.length;\\n        PriorityQueue<Integer>pq=new PriorityQueue<>((a,b)-> b-a);\\n        for(int i=0;i<n;i++){\\n            if(amount[i]!=0){\\n            pq.add(amount[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2330210,
                "title": "heap-priority-queue-easy-approach",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int fillCups(vector<int> &amount)\\n        {\\n            priority_queue<int> pq;\\n\\n            pq.push(amount[0]);\\n            pq.push(amount[1]);\\n            pq.push(amount[2]);\\n            int res = 0;\\n            while (pq.top() != 0)\\n            {\\n                int t1 = pq.top();\\n                pq.pop();\\n                int t2 = pq.top();\\n                pq.pop();\\n\\n                pq.push(t1 - 1);\\n                pq.push(t2 - 1);\\n\\n                res++;\\n            }\\n\\n            return res;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int fillCups(vector<int> &amount)\\n        {\\n            priority_queue<int> pq;\\n\\n            pq.push(amount[0]);\\n            pq.push(amount[1]);\\n            pq.push(amount[2]);\\n            int res = 0;\\n            while (pq.top() != 0)\\n            {\\n                int t1 = pq.top();\\n                pq.pop();\\n                int t2 = pq.top();\\n                pq.pop();\\n\\n                pq.push(t1 - 1);\\n                pq.push(t2 - 1);\\n\\n                res++;\\n            }\\n\\n            return res;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297648,
                "title": "c-priority-queue-simple-solution",
                "content": "**All suggestions are welcome.\\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int ans = 0,first,second;\\n        priority_queue<int> pq(amount.begin(),amount.end());\\n        \\n        while(pq.top()>0){\\n            first = pq.top();\\n            pq.pop();\\n            second=pq.top();\\n            pq.pop();\\n            \\n            if(first>0 && second>0){\\n                first--;\\n                second--;\\n            } else{\\n                first--;\\n            }\\n            pq.push(first);\\n            pq.push(second);\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int ans = 0,first,second;\\n        priority_queue<int> pq(amount.begin(),amount.end());\\n        \\n        while(pq.top()>0){\\n            first = pq.top();\\n            pq.pop();\\n            second=pq.top();\\n            pq.pop();\\n            \\n            if(first>0 && second>0){\\n                first--;\\n                second--;\\n            } else{\\n                first--;\\n            }\\n            pq.push(first);\\n            pq.push(second);\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286203,
                "title": "java-max-heap",
                "content": "If at least 2 piles have unflipped cups, then choose the option to flip 2 cups per turn, else flip 1 cup.\\nSo, we\\'re gonna use a max heap to store the piles in descending order.\\n\\n```\\n    public int fillCups(int[] amount) {\\n        Queue<Integer> heap = new PriorityQueue<>((a, b) -> b - a);\\n        for (int n : amount) {\\n            heap.offer(n);\\n        }\\n        \\n        int turns = 0;\\n        while (heap.peek() > 0) {\\n            int max = heap.poll();\\n            if (heap.peek() > 0) {\\n                int secondMax = heap.poll();\\n                heap.offer(secondMax - 1);\\n            }\\n            heap.offer(max - 1);\\n            turns++;\\n        }\\n        \\n        return turns;\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int fillCups(int[] amount) {\\n        Queue<Integer> heap = new PriorityQueue<>((a, b) -> b - a);\\n        for (int n : amount) {\\n            heap.offer(n);\\n        }\\n        \\n        int turns = 0;\\n        while (heap.peek() > 0) {\\n            int max = heap.poll();\\n            if (heap.peek() > 0) {\\n                int secondMax = heap.poll();\\n                heap.offer(secondMax - 1);\\n            }\\n            heap.offer(max - 1);\\n            turns++;\\n        }\\n        \\n        return turns;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2277625,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int s = 0;\\n        int cold = amount[0];\\n        int warm = amount[1];\\n        int hot = amount[2];\\n        while(cold > 0 || warm > 0 || hot>0){\\n            if(cold >= warm && cold >= hot){\\n                if(warm >= hot ){\\n                    warm--;\\n                    cold--;\\n                    s++;\\n                }else {\\n                \\n                    cold--;\\n                    hot--;\\n                    s++;\\n                    \\n                }\\n            }else if(warm >= cold && warm >= hot ){\\n                if(cold >= hot ){\\n                    warm--;\\n                    cold--;\\n                    s++;\\n                }else{\\n                    warm--;\\n                    hot--;\\n                    s++;\\n                    \\n                }\\n            }else if(hot >= warm && hot >= cold){\\n                if(cold >= warm ){\\n                    hot--;\\n                    cold--;\\n                    s++;\\n                }else{\\n                    \\n                    warm--;\\n                    hot--;\\n                    s++;\\n                    \\n                }\\n            }\\n            System.out.println(warm +\" \" +hot +\" \"+ cold);\\n        }\\n            \\n      \\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int s = 0;\\n        int cold = amount[0];\\n        int warm = amount[1];\\n        int hot = amount[2];\\n        while(cold > 0 || warm > 0 || hot>0){\\n            if(cold >= warm && cold >= hot){\\n                if(warm >= hot ){\\n                    warm--;\\n                    cold--;\\n                    s++;\\n                }else {\\n                \\n                    cold--;\\n                    hot--;\\n                    s++;\\n                    \\n                }\\n            }else if(warm >= cold && warm >= hot ){\\n                if(cold >= hot ){\\n                    warm--;\\n                    cold--;\\n                    s++;\\n                }else{\\n                    warm--;\\n                    hot--;\\n                    s++;\\n                    \\n                }\\n            }else if(hot >= warm && hot >= cold){\\n                if(cold >= warm ){\\n                    hot--;\\n                    cold--;\\n                    s++;\\n                }else{\\n                    \\n                    warm--;\\n                    hot--;\\n                    s++;\\n                    \\n                }\\n            }\\n            System.out.println(warm +\" \" +hot +\" \"+ cold);\\n        }\\n            \\n      \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277595,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        for(int x:amount){\\n            if(x>0)pq.push(x);\\n        }\\n        int ans=0;\\n        while(pq.size()>1){\\n            int a=pq.top();pq.pop();a--;\\n            int b=pq.top();pq.pop();b--;\\n            if(a>0)pq.push(a);\\n            if(b>0)pq.push(b);\\n            ans++;\\n        }\\n        if(pq.size())ans+=pq.top();\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        for(int x:amount){\\n            if(x>0)pq.push(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2275792,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function(amount) {\\n    const sum = amount.reduce((acc, cur) => acc + cur, 0)\\n    const maxVal = Math.max(...amount), other = sum - maxVal\\n    \\n    \\n    if (maxVal >= other) {\\n        return maxVal\\n    } else {\\n        return (sum >> 1) + (sum & 1)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function(amount) {\\n    const sum = amount.reduce((acc, cur) => acc + cur, 0)\\n    const maxVal = Math.max(...amount), other = sum - maxVal\\n    \\n    \\n    if (maxVal >= other) {\\n        return maxVal\\n    } else {\\n        return (sum >> 1) + (sum & 1)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267154,
                "title": "time-and-space-efficient-c-solution-using-repeated-sorting-of-array",
                "content": "Keep sorting the array and pick the cups that are currently maximum in no., repeat this until only  one type of cup is non zero and add that to the count.\\n\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int c=0;\\n        sort(amount.begin(),amount.end());\\n        while(amount[1]!=0){\\n            if(amount[1]!=0)\\n                c++,amount[1]--,amount[2]--;\\n            sort(amount.begin(),amount.end());\\n        }\\n        return c+amount[2];\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/226c9ed9-a3cc-4dc7-9eb1-8b8577f62936_1657527223.8253412.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int c=0;\\n        sort(amount.begin(),amount.end());\\n        while(amount[1]!=0){\\n            if(amount[1]!=0)\\n                c++,amount[1]--,amount[2]--;\\n            sort(amount.begin(),amount.end());\\n        }\\n        return c+amount[2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266706,
                "title": "java-solution",
                "content": "just did what was visible in the question noe question no extra brain i was able to apply`class Solution {\\n    public int fillCups(int[] amount) {\\n        \\n        int first=amount[0];\\n        int second=amount[1];\\n        int third=amount[2];\\n        int count=0;\\n        \\n        \\n       while(first>0 || second>0|| third>0)\\n           \\n        {\\n           \\n            if(third<=first && third<=second && first>0 && second>0)\\n            {\\n                first--;\\n                second--;\\n                count++;\\n            }\\n            \\n            else if(first<=second && first<=third && second>0 && third>0)\\n            {\\n                second--;\\n                third--;\\n                count++;\\n            }\\n           else if(second<=first && second<=third && first>0 && third>0)\\n            {\\n                first--;\\n                third--;\\n                count++;\\n            }\\n            else if(first>0 && second==0 && third==0)\\n            {\\n                count=count+first;\\n                first=0;\\n                \\n            }\\n            else if(first==0 && second>0 && third==0)\\n            {\\n                count=count+second;\\n                second=0;\\n            }\\n            else if(first==0 && second==0 && third>0)\\n            {\\n                count=count+third;\\n                third=0;\\n            }\\n            \\n          \\n        }\\n        return count;\\n    }\\n}`",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int fillCups(int[] amount) {\\n        \\n        int first=amount[0];\\n        int second=amount[1];\\n        int third=amount[2];\\n        int count=0;\\n        \\n        \\n       while(first>0 || second>0|| third>0)\\n           \\n        {\\n           \\n            if(third<=first && third<=second && first>0 && second>0)\\n            {\\n                first--;\\n                second--;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2266279,
                "title": "java-solution-using-priority-queue-with-explanation",
                "content": "**Though Process:** We can approach this problem greedily by filling two cups in one second as a priority.\\n```\\npublic int fillCups(int[] amount) {\\n\\t\\t//Initialising max heap as we will need two dispensers available with most amount of water\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        pq.add(amount[0]);\\n        pq.add(amount[1]);\\n        pq.add(amount[2]);\\n        \\n        int seconds = 0;\\n        while(pq.peek()!=0){\\n\\t\\t// taking two dispensors with most water\\n            int first = pq.poll();\\n            int second = pq.poll();\\n            seconds++;\\n\\t\\t\\t\\n\\t\\t\\t//filling the cups\\n            pq.offer(first!=0?first-1:0);\\n            pq.offer(second!=0?second-1:0);\\n        }\\n        \\n\\t\\t//handling the case if water is left in only one dispensor\\n        if(pq.peek()!=0){\\n            seconds+=pq.peek();\\n        }\\n        return seconds;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int fillCups(int[] amount) {\\n\\t\\t//Initialising max heap as we will need two dispensers available with most amount of water\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        pq.add(amount[0]);\\n        pq.add(amount[1]);\\n        pq.add(amount[2]);\\n        \\n        int seconds = 0;\\n        while(pq.peek()!=0){\\n\\t\\t// taking two dispensors with most water\\n            int first = pq.poll();\\n            int second = pq.poll();\\n            seconds++;\\n\\t\\t\\t\\n\\t\\t\\t//filling the cups\\n            pq.offer(first!=0?first-1:0);\\n            pq.offer(second!=0?second-1:0);\\n        }\\n        \\n\\t\\t//handling the case if water is left in only one dispensor\\n        if(pq.peek()!=0){\\n            seconds+=pq.peek();\\n        }\\n        return seconds;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264537,
                "title": "c-one-line-o-n",
                "content": "```\\n    public int FillCups(int[] amount)\\n    {\\n         return Math.Max(amount.Max(), (amount.Sum() + 1) / 2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int FillCups(int[] amount)\\n    {\\n         return Math.Max(amount.Max(), (amount.Sum() + 1) / 2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264186,
                "title": "java-solution-using-sorting-picking-up-the-two-max-cups",
                "content": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int count=0;\\n        Arrays.sort(amount);\\n        while(amount[2]>0)\\n        {\\n            if(amount[1]>0)\\n            {\\n                amount[1]--;\\n                amount[2]--;\\n                count++;\\n            }\\n            else\\n            {\\n                amount[2]--;\\n                count++;\\n            }\\n            Arrays.sort(amount);\\n                \\n        }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int fillCups(int[] amount) {\\n        int count=0;\\n        Arrays.sort(amount);\\n        while(amount[2]>0)\\n        {\\n            if(amount[1]>0)\\n            {\\n                amount[1]--;\\n                amount[2]--;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2263373,
                "title": "rust-o-n-solution-without-binaryheap",
                "content": "The following solution is translated from @lee215\\'s [https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/discuss/2261394] solution. Till now, i think i have only intutively understood what is going on, but I have not figure out an formal proof for it yet. \\n\\n```rust\\nimpl Solution {\\n    pub fn fill_cups(amount: Vec<i32>) -> i32 {\\n        let max: i32 = *amount.iter().max().unwrap();\\n        let sum: i32 = amount.iter().sum();\\n\\n        std::cmp::max(max, (sum + 1) / 2)\\n    }\\n}\\n```\\n\\nAlso, the following is my BinaryHeap solution that I came up with during the contest \\n\\n```rust\\n\\nimpl Solution {\\n    pub fn fill_cups(amount: Vec<i32>) -> i32 {\\n        let mut pq: BinaryHeap<i32> = amount.into_iter().filter(|x| *x > 0).collect();\\n        let mut res = 0;\\n        while !pq.is_empty() {\\n            if pq.len() >= 2 {\\n                let a = pq.pop().unwrap() - 1;\\n                let b = pq.pop().unwrap() - 1;\\n\\n                if a > 0 {\\n                    pq.push(a);\\n                }\\n                if b > 0 {\\n                    pq.push(b)\\n                }\\n            } else {\\n                let a = pq.pop().unwrap() - 1;\\n\\n                if a > 0 {\\n                    pq.push(a);\\n                }\\n            }\\n\\n            res += 1;\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn fill_cups(amount: Vec<i32>) -> i32 {\\n        let max: i32 = *amount.iter().max().unwrap();\\n        let sum: i32 = amount.iter().sum();\\n\\n        std::cmp::max(max, (sum + 1) / 2)\\n    }\\n}\\n```\n```rust\\n\\nimpl Solution {\\n    pub fn fill_cups(amount: Vec<i32>) -> i32 {\\n        let mut pq: BinaryHeap<i32> = amount.into_iter().filter(|x| *x > 0).collect();\\n        let mut res = 0;\\n        while !pq.is_empty() {\\n            if pq.len() >= 2 {\\n                let a = pq.pop().unwrap() - 1;\\n                let b = pq.pop().unwrap() - 1;\\n\\n                if a > 0 {\\n                    pq.push(a);\\n                }\\n                if b > 0 {\\n                    pq.push(b)\\n                }\\n            } else {\\n                let a = pq.pop().unwrap() - 1;\\n\\n                if a > 0 {\\n                    pq.push(a);\\n                }\\n            }\\n\\n            res += 1;\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262908,
                "title": "c-easy-just-follow-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int ans = 0;\\n        \\n        while(amount[0] > 0){\\n            ans++;\\n            amount[0]--;\\n            if(amount[1] > 0 && amount[1] >= amount[2]) amount[1]--;\\n            else if(amount[2] > 0) amount[2]--;\\n        }\\n        while(amount[1] > 0){\\n            ans++;\\n            amount[1]--;\\n            if(amount[2] > 0) amount[2]--;\\n        }\\n        while(amount[2] > 0){\\n            ans++;\\n            amount[2]--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int ans = 0;\\n        \\n        while(amount[0] > 0){\\n            ans++;\\n            amount[0]--;\\n            if(amount[1] > 0 && amount[1] >= amount[2]) amount[1]--;\\n            else if(amount[2] > 0) amount[2]--;\\n        }\\n        while(amount[1] > 0){\\n            ans++;\\n            amount[1]--;\\n            if(amount[2] > 0) amount[2]--;\\n        }\\n        while(amount[2] > 0){\\n            ans++;\\n            amount[2]--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262789,
                "title": "c-two-simple-cases",
                "content": "We have two simple cases here: for `A`, `B`, `C` being types of water if we have *triangular inequalty* met: `Max(A, B, C) <= A + B + C - Max(A, B, C)` we can allways fiil two cups until the very last one (if we have odd number of cups the last one will not have a pair):\\n\\n```\\n(amount[0] + amount[1] + amount[2]) / 2 + (amount[0] + amount[1] + amount[2]) % 2; \\n```\\n\\nHowever, if one type, say `C` *dominates*, i.e. `C > A + B` we can have pair until both `A` and `B` are exhausted: `A+B` pairs and then fe have to fill `C - A - B` cups: `A + B + C - A - B == C`:\\n\\n```\\namount[2];  \\n```\\n\\nSo far so good, we can sort our amounts and check the condition:\\n\\n```\\npublic class Solution {\\n    \\n    public int FillCups(int[] amount) {\\n        Array.Sort(amount);\\n        \\n        if (amount[2] <= amount[0] + amount[1]) \\n            return (amount[0] + amount[1] + amount[2]) / 2 + (amount[0] + amount[1] + amount[2]) % 2; \\n        \\n        return amount[2];  \\n    }\\n    \\n}\\n```\\n\\nWe can further simplify these condiotion into *oneliner*:\\n\\n```\\npublic class Solution {\\n    public int FillCups(int[] amount) => Math.Max(amount.Max(), (amount.Sum() + 1) / 2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n(amount[0] + amount[1] + amount[2]) / 2 + (amount[0] + amount[1] + amount[2]) % 2; \\n```\n```\\namount[2];  \\n```\n```\\npublic class Solution {\\n    \\n    public int FillCups(int[] amount) {\\n        Array.Sort(amount);\\n        \\n        if (amount[2] <= amount[0] + amount[1]) \\n            return (amount[0] + amount[1] + amount[2]) / 2 + (amount[0] + amount[1] + amount[2]) % 2; \\n        \\n        return amount[2];  \\n    }\\n    \\n}\\n```\n```\\npublic class Solution {\\n    public int FillCups(int[] amount) => Math.Max(amount.Max(), (amount.Sum() + 1) / 2);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262659,
                "title": "javascript-solution-easy-to-understand",
                "content": "*Time Complexity: O(1) since array length is always 3 as per constraint*\\n*Space Complexity: O(1)*\\n\\n```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function(amount) {\\n    let sum = amount[0]+amount[1]+amount[2];\\n    amount.push(Math.floor((sum + 1) / 2));\\n    return Math.max.apply(Math, amount);\\n};\\n```\\n***if we are not allowed to modify input array***\\n```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function(amount) {\\n    let sum = amount[0]+amount[1]+amount[2];\\n    return Math.max.apply(Math, [...amount, Math.floor((sum + 1) / 2)]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function(amount) {\\n    let sum = amount[0]+amount[1]+amount[2];\\n    amount.push(Math.floor((sum + 1) / 2));\\n    return Math.max.apply(Math, amount);\\n};\\n```\n```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function(amount) {\\n    let sum = amount[0]+amount[1]+amount[2];\\n    return Math.max.apply(Math, [...amount, Math.floor((sum + 1) / 2)]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262613,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        count = 0\\n        while True:\\n            amount = sorted(amount, reverse = True)\\n            if amount[0] > 0 and amount[1] > 0:\\n                amount[0] -= 1\\n                amount[1] -= 1\\n                count +=1\\n            elif amount[0] > 0 and amount[1] == 0:\\n                amount[0] -= 1\\n                count +=1\\n            if amount[0] == amount[1] == amount[2] == 0:\\n                return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        count = 0\\n        while True:\\n            amount = sorted(amount, reverse = True)\\n            if amount[0] > 0 and amount[1] > 0:\\n                amount[0] -= 1\\n                amount[1] -= 1\\n                count +=1\\n            elif amount[0] > 0 and amount[1] == 0:\\n                amount[0] -= 1\\n                count +=1\\n            if amount[0] == amount[1] == amount[2] == 0:\\n                return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262018,
                "title": "memoization-python-3",
                "content": "Idea was if any element of **amount** is **0** ,min time can be taken to fill all the container is max in `amount` .ex:  [1,4,0] first we can choose 1 ,4 for 1 second then it becomes [0,3,0] now we only need to fill 2nd container it takes 3 sec and total is 4 sec.\\n\\n\\n```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        mp={}\\n        def solve(x1,x2,x3):\\n            if x1<=0 or x2<=0 or x3<=0:\\n                return max(x1,x2,x3)\\n            if (x1,x2,x3) in mp :\\n                return mp[(x1,x2,x3)]\\n            mp[(x1,x2,x3)]=1+min(solve(x1-1,x2-1,x3),solve(x1,x2-1,x3-1),solve(x1-1,x2,x3-1))\\n            return mp[(x1,x2,x3)]\\n        return solve(amount[0],amount[1],amount[2])\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        mp={}\\n        def solve(x1,x2,x3):\\n            if x1<=0 or x2<=0 or x3<=0:\\n                return max(x1,x2,x3)\\n            if (x1,x2,x3) in mp :\\n                return mp[(x1,x2,x3)]\\n            mp[(x1,x2,x3)]=1+min(solve(x1-1,x2-1,x3),solve(x1,x2-1,x3-1),solve(x1-1,x2,x3-1))\\n            return mp[(x1,x2,x3)]\\n        return solve(amount[0],amount[1],amount[2])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261923,
                "title": "c-maxheap-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        for(auto i:amount)if(i>0)pq.push(i);\\n        int ans=0;\\n        while(pq.size()>=2)\\n        {\\n            int one =pq.top();\\n            pq.pop();\\n            int two=pq.top();pq.pop();\\n            if(one>1)pq.push(one-1);\\n            if(two>1)pq.push(two-1);\\n            ans++;\\n        }\\n        if(!pq.empty())\\n        ans+=pq.top();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq;\\n        for(auto i:amount)if(i>0)pq.push(i);\\n        int ans=0;\\n        while(pq.size()>=2)\\n        {\\n            int one =pq.top();\\n            pq.pop();\\n            int two=pq.top();pq.pop();\\n            if(one>1)pq.push(one-1);\\n            if(two>1)pq.push(two-1);\\n            ans++;\\n        }\\n        if(!pq.empty())\\n        ans+=pq.top();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261897,
                "title": "easy-understanding-c-sorting-3ms-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a){\\n        int ans=0;\\n        while(1){\\n            sort(a.begin(),a.end());\\n            if(a[0]==0 && a[1]==0) break;\\n            ans++;\\n            a[2]-=1;\\n            a[1]-=1;\\n        }\\n        ans+=a[2];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a){\\n        int ans=0;\\n        while(1){\\n            sort(a.begin(),a.end());\\n            if(a[0]==0 && a[1]==0) break;\\n            ans++;\\n            a[2]-=1;\\n            a[1]-=1;\\n        }\\n        ans+=a[2];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261814,
                "title": "1-liner-c-time-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        return max(max(a[0],max(a[1],a[2])), (a[0]+a[1]+a[2] + 1) / 2);\\n    }\\n};\\n```\\nSince ans >= max(a)\\nBecause each time, one type can reduce at most 1 cup,\\nso the final result is bigger or equal to max(a)\\nOR\\nans >= ceil(sum(a) / 2)\\nBecause each time, we can fill up to 2 cups, so the final result is bigger or equal to ceil(sum(a) / 2)\\nAt the end maximum of both.\\n**Kindly upvote, if you like the solution :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        return max(max(a[0],max(a[1],a[2])), (a[0]+a[1]+a[2] + 1) / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261780,
                "title": "c-easy-solution-using-priority-queue",
                "content": "Please upvote If u like my solution !!\\n\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int n=amount.size();             \\n        priority_queue<int> pq;\\n        for(int i=0;i<n;++i)\\n        {\\n            if(amount[i]>0)          \\n            {\\n                pq.push(amount[i]);          \\n            }\\n        }\\n        int cnt=0;\\n        while(pq.size()>1)\\n        {\\n            int num1=pq.top();\\n            pq.pop();\\n            int num2=pq.top();\\n            pq.pop();\\n            if(num1!=0 && num2!=0){\\n                num1--;\\n                num2--;\\n                cnt++;\\n                if(num1!=0)\\n                {\\n                    pq.push(num1);\\n                }\\n                if(num2!=0){\\n                    pq.push(num2);\\n                }\\n            }\\n            else if(num2==0 || num1==0)\\n            {\\n                break;\\n            }\\n        }\\n        if(pq.empty()) return cnt;\\n        else{\\n            cnt += pq.top();\\n            return cnt;\\n        }\\n        // return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int n=amount.size();             \\n        priority_queue<int> pq;\\n        for(int i=0;i<n;++i)\\n        {\\n            if(amount[i]>0)          \\n            {\\n                pq.push(amount[i]);          \\n            }\\n        }\\n        int cnt=0;\\n        while(pq.size()>1)\\n        {\\n            int num1=pq.top();\\n            pq.pop();\\n            int num2=pq.top();\\n            pq.pop();\\n            if(num1!=0 && num2!=0){\\n                num1--;\\n                num2--;\\n                cnt++;\\n                if(num1!=0)\\n                {\\n                    pq.push(num1);\\n                }\\n                if(num2!=0){\\n                    pq.push(num2);\\n                }\\n            }\\n            else if(num2==0 || num1==0)\\n            {\\n                break;\\n            }\\n        }\\n        if(pq.empty()) return cnt;\\n        else{\\n            cnt += pq.top();\\n            return cnt;\\n        }\\n        // return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261763,
                "title": "o-1-easy-solution-with-explanation-c",
                "content": "```\\n// Time and Space Complexity: O(1)\\nint fillCups(vector<int>& a) {\\n\\tsort(a.begin(), a.end());\\n\\tint ans = 0;\\n\\t// This condition means, we can use the largest value with both the smaller values to make pair.\\n\\t// Ex: [1, 4, 2]\\n\\t// 1 and 2 can make pair with 4 and the remaining 1 value (4 - (1 + 2)) can be used as a single value.\\n\\tif(a[0] + a[1] <= a[2]){\\n\\t\\tans = (a[0] + a[1]) + (a[2] - a[0] - a[1]);\\n\\t}\\n\\t// This condition arises when we can\\'t use the largest value for the other two values.\\n\\telse {\\n\\t\\tans = (a[0] + a[1] + a[2]+1)/2;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n// Time and Space Complexity: O(1)\\nint fillCups(vector<int>& a) {\\n\\tsort(a.begin(), a.end());\\n\\tint ans = 0;\\n\\t// This condition means, we can use the largest value with both the smaller values to make pair.\\n\\t// Ex: [1, 4, 2]\\n\\t// 1 and 2 can make pair with 4 and the remaining 1 value (4 - (1 + 2)) can be used as a single value.\\n\\tif(a[0] + a[1] <= a[2]){\\n\\t\\tans = (a[0] + a[1]) + (a[2] - a[0] - a[1]);\\n\\t}\\n\\t// This condition arises when we can\\'t use the largest value for the other two values.\\n\\telse {\\n\\t\\tans = (a[0] + a[1] + a[2]+1)/2;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261742,
                "title": "python3-solution-using-sort",
                "content": "```\\nclass Solution:\\n    def fillCups(self, a: List[int]) -> int:\\n        result = 0\\n        \\n\\n        while sum(a)!=0:\\n            result+=1\\n            a = sorted(a, reverse=True)\\n            if a[0] > 0:\\n                a[0] -= 1\\n                if a[1] > 0:\\n                    a[1] -=1\\n                elif a[2] > 0:\\n                    a[2] -= 1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, a: List[int]) -> int:\\n        result = 0\\n        \\n\\n        while sum(a)!=0:\\n            result+=1\\n            a = sorted(a, reverse=True)\\n            if a[0] > 0:\\n                a[0] -= 1\\n                if a[1] > 0:\\n                    a[1] -=1\\n                elif a[2] > 0:\\n                    a[2] -= 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261721,
                "title": "shortest-o-1-easy-to-understand-python-solution",
                "content": "```python\\nclass Solution(object):\\n    def fillCups(self, amount):\\n        \"\"\"\\n        :type amount: List[int]\\n        :rtype: int\\n        \"\"\"\\n        amount.sort()\\n        amount = amount[::-1]\\n       \\n        if amount[0] >= amount[1] + amount[2]:\\n            \"\"\"\\n\\t\\t\\t- In this case we will always have 1 cup from maximum type and 1 from either of the other two types so will fill these two together\\n\\t\\t\\t- The remaining cups will always come from max type and will be filled indivudually (1 at a time)\\n            - result = amount[1] + amount[2] + (amount[0]-(amount[1] + amount[2])) which is equal to amount[0]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\treturn amount[0]\\n        else:\\n\\t\\t    \"\"\"\\n\\t\\t    This is case when we have to optimally pick pairs as much as possible and since amount[0] < amount[1] + amount[2] we can say that there will be pairs between all three types and until one of them is left to be filled individually.\\n\\t\\t\\t\"\"\"\\n            return int(math.ceil(sum(amount)/2.0))\\n        return res\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def fillCups(self, amount):\\n        \"\"\"\\n        :type amount: List[int]\\n        :rtype: int\\n        \"\"\"\\n        amount.sort()\\n        amount = amount[::-1]\\n       \\n        if amount[0] >= amount[1] + amount[2]:\\n            \"\"\"\\n\\t\\t\\t- In this case we will always have 1 cup from maximum type and 1 from either of the other two types so will fill these two together\\n\\t\\t\\t- The remaining cups will always come from max type and will be filled indivudually (1 at a time)\\n            - result = amount[1] + amount[2] + (amount[0]-(amount[1] + amount[2])) which is equal to amount[0]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\treturn amount[0]\\n        else:\\n\\t\\t    \"\"\"\\n\\t\\t    This is case when we have to optimally pick pairs as much as possible and since amount[0] < amount[1] + amount[2] we can say that there will be pairs between all three types and until one of them is left to be filled individually.\\n\\t\\t\\t\"\"\"\\n            return int(math.ceil(sum(amount)/2.0))\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2261709,
                "title": "c-priority-queue-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(auto x:amount)\\n            if(x)\\n                pq.push(x);\\n        \\n        int res=0;\\n        while(!pq.empty())\\n        {\\n            int p=pq.top();\\n            pq.pop();\\n            if(pq.empty())\\n            {\\n                res+=p;\\n                break;\\n            }\\n            else\\n            {\\n                int q=pq.top();\\n                pq.pop();\\n                res++;\\n                if(q-1>0)\\n                    pq.push(q-1);\\n                if(p-1>0)\\n                    pq.push(p-1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(auto x:amount)\\n            if(x)\\n                pq.push(x);\\n        \\n        int res=0;\\n        while(!pq.empty())\\n        {\\n            int p=pq.top();\\n            pq.pop();\\n            if(pq.empty())\\n            {\\n                res+=p;\\n                break;\\n            }\\n            else\\n            {\\n                int q=pq.top();\\n                pq.pop();\\n                res++;\\n                if(q-1>0)\\n                    pq.push(q-1);\\n                if(p-1>0)\\n                    pq.push(p-1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261654,
                "title": "java-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n      PriorityQueue<Integer>pq = new PriorityQueue<>((a,v)->v-a);\\n        for(int x : amount)\\n        {\\n            pq.offer(x);\\n        }\\n        \\n        int count = 0;\\n        while(!pq.isEmpty())\\n        {\\n            int first = pq.poll();\\n            int second = pq.poll();\\n            if(first == 0)return count;\\n            else if(second == 0)\\n            {\\n                count += first;\\n                return count;\\n            }\\n            else\\n            {\\n                pq.offer(first-1);\\n                pq.offer(second - 1);\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n      PriorityQueue<Integer>pq = new PriorityQueue<>((a,v)->v-a);\\n        for(int x : amount)\\n        {\\n            pq.offer(x);\\n        }\\n        \\n        int count = 0;\\n        while(!pq.isEmpty())\\n        {\\n            int first = pq.poll();\\n            int second = pq.poll();\\n            if(first == 0)return count;\\n            else if(second == 0)\\n            {\\n                count += first;\\n                return count;\\n            }\\n            else\\n            {\\n                pq.offer(first-1);\\n                pq.offer(second - 1);\\n            }\\n            count += 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261611,
                "title": "try-all-ways-recursion-memoization",
                "content": "**During Contest, I wasted a lot of time writing priority_queue and sorting solutions, but in the end, recursion saved me.**\\n**TC: O(N * M * O)**\\n**SC: O(N * M * O)**\\n```\\nclass Solution {\\npublic:\\n    int memo[101][101][101];\\n    int rec(int first, int second, int third){\\n        if(!first && !second && !third) return 0;\\n\\n        if(memo[first][second][third] != -1) return memo[first][second][third];\\n        \\n        int miniAns = INT_MAX;\\n        if(first){\\n            int mini = INT_MAX;\\n            if(second){\\n                mini = min(1 + rec(first-1, second-1, third), mini);\\n            }\\n\\n            if(third){\\n                mini = min(1 + rec(first-1, second, third-1), mini);\\n            }\\n\\n            if(!second && !third){\\n                mini = min(1 + rec(first-1, second, third), mini);\\n            }\\n            miniAns = min(miniAns, mini);\\n        }\\n        \\n        if(second){\\n            int mini = INT_MAX;\\n            if(first){\\n                mini = min(1 + rec(first-1, second-1, third), mini);\\n            }\\n\\n            if(third){\\n                mini = min(1 + rec(first, second-1, third-1), mini);\\n            }\\n\\n            if(!first && !third){\\n                mini = min(1 + rec(first, second-1, third), mini);\\n            }\\n            miniAns = min(miniAns, mini);\\n        }\\n        \\n        if(third){\\n            int mini = INT_MAX;\\n            if(first){\\n                mini = min(1 + rec(first-1, second, third-1), mini);\\n            }\\n\\n            if(second){\\n                mini = min(1 + rec(first, second-1, third-1), mini);\\n            }\\n\\n            if(!first && !second){\\n                mini = min(1 + rec(first, second, third-1), mini);\\n            }\\n            miniAns = min(miniAns, mini);\\n        }\\n\\n        return memo[first][second][third] = miniAns;\\n    }\\n    int fillCups(vector<int>& arr){\\n        if(!arr[0] && !arr[1] && !arr[2]) return 0;\\n        memset(memo, -1, sizeof(memo));\\n        return rec(arr[0], arr[1], arr[2]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[101][101][101];\\n    int rec(int first, int second, int third){\\n        if(!first && !second && !third) return 0;\\n\\n        if(memo[first][second][third] != -1) return memo[first][second][third];\\n        \\n        int miniAns = INT_MAX;\\n        if(first){\\n            int mini = INT_MAX;\\n            if(second){\\n                mini = min(1 + rec(first-1, second-1, third), mini);\\n            }\\n\\n            if(third){\\n                mini = min(1 + rec(first-1, second, third-1), mini);\\n            }\\n\\n            if(!second && !third){\\n                mini = min(1 + rec(first-1, second, third), mini);\\n            }\\n            miniAns = min(miniAns, mini);\\n        }\\n        \\n        if(second){\\n            int mini = INT_MAX;\\n            if(first){\\n                mini = min(1 + rec(first-1, second-1, third), mini);\\n            }\\n\\n            if(third){\\n                mini = min(1 + rec(first, second-1, third-1), mini);\\n            }\\n\\n            if(!first && !third){\\n                mini = min(1 + rec(first, second-1, third), mini);\\n            }\\n            miniAns = min(miniAns, mini);\\n        }\\n        \\n        if(third){\\n            int mini = INT_MAX;\\n            if(first){\\n                mini = min(1 + rec(first-1, second, third-1), mini);\\n            }\\n\\n            if(second){\\n                mini = min(1 + rec(first, second-1, third-1), mini);\\n            }\\n\\n            if(!first && !second){\\n                mini = min(1 + rec(first, second, third-1), mini);\\n            }\\n            miniAns = min(miniAns, mini);\\n        }\\n\\n        return memo[first][second][third] = miniAns;\\n    }\\n    int fillCups(vector<int>& arr){\\n        if(!arr[0] && !arr[1] && !arr[2]) return 0;\\n        memset(memo, -1, sizeof(memo));\\n        return rec(arr[0], arr[1], arr[2]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261591,
                "title": "java-runtime-2ms",
                "content": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int result = 0 ;\\n        \\n        while (amount[0] != 0 || amount[1] != 0 || amount[2] != 0) {\\n            Arrays.sort(amount) ;\\n            result++ ;\\n            amount[2]-- ;\\n            if (amount[1] > 0) {\\n                amount[1]-- ;\\n            }\\n        }\\n        \\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int result = 0 ;\\n        \\n        while (amount[0] != 0 || amount[1] != 0 || amount[2] != 0) {\\n            Arrays.sort(amount) ;\\n            result++ ;\\n            amount[2]-- ;\\n            if (amount[1] > 0) {\\n                amount[1]-- ;\\n            }\\n        }\\n        \\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261579,
                "title": "java-simple-solution",
                "content": "There are two possibilities:\\n1. The largest one is smaller than or equal to the sum of the other two.\\nFor example, 4 4 5\\nThen the total count is ` (i + j + k + 1) / 2`\\nIn this case `(4 + 4 + 5 + 1) / 2 = 7`\\n2. Else, the count is the number of the largest one.\\nFor example, 1 2 4 => 4, 0 0 5 => 5.\\n\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int count = 0;\\n        int i = amount[0];\\n        int j = amount[1];\\n        int k = amount[2];\\n        if (k <= i + j) {\\n            count = (i + j + k + 1) / 2;\\n        } else {\\n            count = k;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int count = 0;\\n        int i = amount[0];\\n        int j = amount[1];\\n        int k = amount[2];\\n        if (k <= i + j) {\\n            count = (i + j + k + 1) / 2;\\n        } else {\\n            count = k;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261521,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(int i = 0; i < amount.size(); i++) {\\n            pq.push(amount[i]);\\n        }\\n        int count = 0;\\n        while(pq.size() >= 2 and pq.top() >= 1) {\\n            int temp1 = pq.top();\\n            pq.pop();\\n            int temp2 = pq.top();\\n            pq.pop();\\n            cout << temp1 << \" \" << temp2 << endl;\\n            if(temp1 >= 1) {\\n                pq.push(temp1 - 1);\\n            }\\n            if(temp2 >= 1) {\\n                pq.push(temp2 - 1);\\n            }\\n            count++;\\n        }\\n        return pq.top() + count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(int i = 0; i < amount.size(); i++) {\\n            pq.push(amount[i]);\\n        }\\n        int count = 0;\\n        while(pq.size() >= 2 and pq.top() >= 1) {\\n            int temp1 = pq.top();\\n            pq.pop();\\n            int temp2 = pq.top();\\n            pq.pop();\\n            cout << temp1 << \" \" << temp2 << endl;\\n            if(temp1 >= 1) {\\n                pq.push(temp1 - 1);\\n            }\\n            if(temp2 >= 1) {\\n                pq.push(temp2 - 1);\\n            }\\n            count++;\\n        }\\n        return pq.top() + count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2261428,
                "title": "easy-c-comments-included-2-line-code",
                "content": "Upvote if you like the solution\\n```\\nint fillCups(vector<int>& amount) {\\n        sort(amount.begin(),amount.end());//sort the array\\n\\t\\t//if the maximum amount is greater than the sum of other 2 then we will generate all the pairs as one with the maximum type and the other from rest 2, so total time will be amount[2](maximum of all). Else we will return ceil of sum of all 3 divided by 2, here the pairs can be any 2.\\n        return amount[2]>=amount[1]+amount[0]?amount[2]:(amount[0]+amount[1]+amount[2]+1)/2;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint fillCups(vector<int>& amount) {\\n        sort(amount.begin(),amount.end());//sort the array\\n\\t\\t//if the maximum amount is greater than the sum of other 2 then we will generate all the pairs as one with the maximum type and the other from rest 2, so total time will be amount[2](maximum of all). Else we will return ceil of sum of all 3 divided by 2, here the pairs can be any 2.\\n        return amount[2]>=amount[1]+amount[0]?amount[2]:(amount[0]+amount[1]+amount[2]+1)/2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261405,
                "title": "rust-brutal-force-with-a-heap",
                "content": "The key point is to evenly distribute the fills, so that <i>to fill two at once</i> can be exploited.\\n\\nSolution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl1/lc2335)\\n\\n<b>Problem List</b>\\n#Heap - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/heap)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/\\n/// Time Complexity:    O(max(`nums`) *  lg(`len_ns`))\\n/// Space Complexity:   O(`len_ns`) ~ O(1)\\nuse std::collections::BinaryHeap;\\nimpl Solution {\\n    pub fn fill_cups(nums: Vec<i32>) -> i32 {\\n        let len_ns: usize = nums.len(); // 3\\n        let mut heap: BinaryHeap<i32> = {\\n            let mut heap = BinaryHeap::with_capacity(len_ns);\\n            for num in nums{\\n                if num != 0{\\n                    heap.push(num);\\n                }\\n            }\\n            heap\\n        };\\n        let mut cnt: i32 = 0;\\n        while let Some(top) = heap.pop(){\\n            if let Some(sec_top) = heap.pop(){\\n                if sec_top > 1{\\n                    heap.push(sec_top - 1);\\n                }\\n            }else{\\n                return cnt + top;\\n            }\\n            if top > 1{\\n                heap.push(top - 1);\\n            }\\n            cnt += 1;\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/\\n/// Time Complexity:    O(max(`nums`) *  lg(`len_ns`))\\n/// Space Complexity:   O(`len_ns`) ~ O(1)\\nuse std::collections::BinaryHeap;\\nimpl Solution {\\n    pub fn fill_cups(nums: Vec<i32>) -> i32 {\\n        let len_ns: usize = nums.len(); // 3\\n        let mut heap: BinaryHeap<i32> = {\\n            let mut heap = BinaryHeap::with_capacity(len_ns);\\n            for num in nums{\\n                if num != 0{\\n                    heap.push(num);\\n                }\\n            }\\n            heap\\n        };\\n        let mut cnt: i32 = 0;\\n        while let Some(top) = heap.pop(){\\n            if let Some(sec_top) = heap.pop(){\\n                if sec_top > 1{\\n                    heap.push(sec_top - 1);\\n                }\\n            }else{\\n                return cnt + top;\\n            }\\n            if top > 1{\\n                heap.push(top - 1);\\n            }\\n            cnt += 1;\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261403,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: list[int]) -> int:\\n        amount.sort()\\n        ans = 0\\n        while sum(amount) != 0:\\n\\t\\t#always choose the max and mid cup\\n\\t\\t#choose the max amount of cup\\n            amount[2] -= 1\\n\\t\\t\\t#choose the mid cup; \\n            if amount[1] != 0:\\n                amount[1] -= 1\\n            ans += 1\\n            amount.sort()\\n        return ans\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: list[int]) -> int:\\n        amount.sort()\\n        ans = 0\\n        while sum(amount) != 0:\\n\\t\\t#always choose the max and mid cup\\n\\t\\t#choose the max amount of cup\\n            amount[2] -= 1\\n\\t\\t\\t#choose the mid cup; \\n            if amount[1] != 0:\\n                amount[1] -= 1\\n            ans += 1\\n            amount.sort()\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2261385,
                "title": "c-faster-than-100-with-explanation",
                "content": "**Explanation:**\\nWe need to deduct from the 2 types of cups that are highest in number, so we sort the array in descending order each time after deduction and count the number of times we had to deduct.\\nSince the array has only 3 elements, sorting will take negligible time.\\n\\n**Code:**\\n```\\nint fillCups(vector<int>& amount) {\\n        int counter=0;\\n        sort(amount.rbegin(), amount.rend());\\n        if(amount[0]==0)\\n            return 0;\\n        while(amount[0]>0){\\n            amount[0]-=1;\\n            amount[1]-=1;\\n            counter++;\\n            sort(amount.rbegin(), amount.rend());\\n        }\\n        return counter;\\n    }\\n```\\n\\n**Please upvote if it helps!!**\\n\\n**Faster Than 100%:**\\n![image](https://assets.leetcode.com/users/images/50d9dcae-39d9-4076-a46c-8c9d443ce14b_1657426804.270957.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint fillCups(vector<int>& amount) {\\n        int counter=0;\\n        sort(amount.rbegin(), amount.rend());\\n        if(amount[0]==0)\\n            return 0;\\n        while(amount[0]>0){\\n            amount[0]-=1;\\n            amount[1]-=1;\\n            counter++;\\n            sort(amount.rbegin(), amount.rend());\\n        }\\n        return counter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261380,
                "title": "python3-priority-queue",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f00c06cefbc1b2305f127a8cde7ff9b010197930) for solutions of weekly 301. \\n\\n```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        pq = [-x for x in amount]\\n        heapify(pq)\\n        ans = 0 \\n        while pq[0]: \\n            x = heappop(pq)\\n            if pq[0]: heapreplace(pq, pq[0]+1)\\n            heappush(pq, x+1)\\n            ans += 1\\n        return ans \\n```\\n\\nPer @lee215, a easier solution is \\n```\\nclass Solution: \\n    def fillCups(self, amount: List[int]) -> int:\\n        return max(max(amount), (sum(amount)+1)//2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        pq = [-x for x in amount]\\n        heapify(pq)\\n        ans = 0 \\n        while pq[0]: \\n            x = heappop(pq)\\n            if pq[0]: heapreplace(pq, pq[0]+1)\\n            heappush(pq, x+1)\\n            ans += 1\\n        return ans \\n```\n```\\nclass Solution: \\n    def fillCups(self, amount: List[int]) -> int:\\n        return max(max(amount), (sum(amount)+1)//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261379,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        \\n        sort(a.begin(),a.end());\\n        \\n        int ans =0;\\n        \\n        while(a[2]!=0)\\n        {\\n            a[2]--;\\n            if(a[1]>0)\\n            a[1]--;\\n            \\n            sort(a.begin(),a.end());\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int fillCups(vector<int>& a) {\\n        \\n        sort(a.begin(),a.end());\\n        \\n        int ans =0;\\n        \\n        while(a[2]!=0)\\n        {\\n            a[2]--;\\n            if(a[1]>0)\\n            a[1]--;\\n            \\n            sort(a.begin(),a.end());\\n            ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2261362,
                "title": "c-easy-o-nlogn-time-complexity",
                "content": "\\n                                \\n          int fillCups(vector<int>& a) {\\n\\t\\tint c=0;\\n        while((a[0]||a[1]||a[2])>0)\\n        {\\n            sort(a.begin(),a.end(),greater<int>());\\n            a[0]=a[0]-1;\\n            if(a[1]!=0 )\\n            {\\n            a[1]=a[1]-1;\\n            }c++;\\n            // cout<<a[0]<<\" \"<<a[1]<<\" \"<<a[2];\\n            \\n        }\\n        // cout<<endl;\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "\\n                                \\n          int fillCups(vector<int>& a) {\\n\\t\\tint c=0;\\n        while((a[0]||a[1]||a[2])>0)\\n        {\\n            sort(a.begin(),a.end(),greater<int>());\\n            a[0]=a[0]-1;\\n            if(a[1]!=0 )\\n            {\\n            a[1]=a[1]-1;\\n            }c++;\\n            // cout<<a[0]<<\" \"<<a[1]<<\" \"<<a[2];\\n            \\n        }\\n        // cout<<endl;\\n        return c;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2261317,
                "title": "greedy",
                "content": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        a = sum(amount)\\n        b = a//2 + a%2\\n        c = max(amount)\\n        return max(b,c)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        a = sum(amount)\\n        b = a//2 + a%2\\n        c = max(amount)\\n        return max(b,c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261307,
                "title": "java-greedy-solution",
                "content": "```\\nclass Solution {\\n  public int fillCups(int[] amount) {\\n    int count = 0;\\n    while (!(amount[0] == 0 && amount[1] == 0 && amount[2] == 0)) {\\n      Arrays.sort(amount);\\n      if (amount[2] > 0) {\\n        amount[2]--;\\n      }\\n      if (amount[1] > 0) {\\n        amount[1]--;\\n      }\\n      count++;\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public int fillCups(int[] amount) {\\n    int count = 0;\\n    while (!(amount[0] == 0 && amount[1] == 0 && amount[2] == 0)) {\\n      Arrays.sort(amount);\\n      if (amount[2] > 0) {\\n        amount[2]--;\\n      }\\n      if (amount[1] > 0) {\\n        amount[1]--;\\n      }\\n      count++;\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261291,
                "title": "c-simple-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int n=amount.size();\\n        priority_queue<int> pq;\\n        for(auto &x:amount)\\n        {\\n            if(x>0)\\n            pq.push(x);\\n        }\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            if(pq.size()!=1)\\n            {\\n                int ff,ss;\\n                ff=pq.top();\\n                pq.pop();\\n                ss=pq.top();\\n                pq.pop();\\n                --ss;\\n                --ff;\\n                ans++;\\n                if(ss!=0)\\n                {\\n                    pq.push(ss);\\n                }\\n                if(ff!=0)\\n                {\\n                    pq.push(ff);\\n                }   \\n            }\\n            else\\n            {\\n                ans+=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int n=amount.size();\\n        priority_queue<int> pq;\\n        for(auto &x:amount)\\n        {\\n            if(x>0)\\n            pq.push(x);\\n        }\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            if(pq.size()!=1)\\n            {\\n                int ff,ss;\\n                ff=pq.top();\\n                pq.pop();\\n                ss=pq.top();\\n                pq.pop();\\n                --ss;\\n                --ff;\\n                ans++;\\n                if(ss!=0)\\n                {\\n                    pq.push(ss);\\n                }\\n                if(ff!=0)\\n                {\\n                    pq.push(ff);\\n                }   \\n            }\\n            else\\n            {\\n                ans+=pq.top();\\n                pq.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091919,
                "title": "prority-queue-c-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nonce you create the max heap you take top 2 elements and reduce them and then find the count. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq; \\n\\n        for(auto val: amount) pq.push(val);\\n\\n        int count=0; \\n        while(pq.top()!=0){\\n            int a=pq.top(); pq.pop();\\n            int b=pq.top(); pq.pop();\\n            a--; b--; \\n            pq.push(a); pq.push(b);\\n            count++;\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq; \\n\\n        for(auto val: amount) pq.push(val);\\n\\n        int count=0; \\n        while(pq.top()!=0){\\n            int a=pq.top(); pq.pop();\\n            int b=pq.top(); pq.pop();\\n            a--; b--; \\n            pq.push(a); pq.push(b);\\n            count++;\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085839,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        final int max = Arrays.stream(amount).max().getAsInt();\\n        final int sum = Arrays.stream(amount).sum();\\n        return Math.max(max, (sum + 1) / 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        final int max = Arrays.stream(amount).max().getAsInt();\\n        final int sum = Arrays.stream(amount).sum();\\n        return Math.max(max, (sum + 1) / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080570,
                "title": "priorityqueue-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n   PriorityQueue<Integer> pq=new PriorityQueue<>((o1,o2)->o2-o1);\\n   for(int a:amount) if(a!=0) pq.offer(a);\\n   int steps=0;\\n   while(!pq.isEmpty()){\\n     int size=pq.size();\\n     if(size==1)return steps+pq.remove();\\n       int max=pq.remove();\\n       int min=pq.remove();\\n       steps+=1;\\n       max-=1;\\n       min-=1;\\n       if(max!=0) pq.offer(max);\\n       if(min!=0) pq.offer(min);\\n   }\\n   return steps;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n   PriorityQueue<Integer> pq=new PriorityQueue<>((o1,o2)->o2-o1);\\n   for(int a:amount) if(a!=0) pq.offer(a);\\n   int steps=0;\\n   while(!pq.isEmpty()){\\n     int size=pq.size();\\n     if(size==1)return steps+pq.remove();\\n       int max=pq.remove();\\n       int min=pq.remove();\\n       steps+=1;\\n       max-=1;\\n       min-=1;\\n       if(max!=0) pq.offer(max);\\n       if(min!=0) pq.offer(min);\\n   }\\n   return steps;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072493,
                "title": "c-solution",
                "content": "# Intuition\\nused pq for fast maximum retrival.\\npushed the elements first.\\nrun a loop till the pq doesn\\'t have any elements.\\nif one cup -> look it(top) -> pop -> decrement -> push it again\\nif size >= 3 -> some the same with 2 tops.\\n\\nadd a counter inside the loop and return the loop\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) \\n    {\\n        if(amount.size() > 3)\\n        {\\n            return 0;\\n        }\\n        if(amount[0] == 0 and amount[1] == 0 and amount[2] == 0)\\n        {\\n            return 0;\\n        }\\n        priority_queue<int> pq(amount.begin() , amount.end());\\n        int count = 0;\\n\\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n            {\\n                int top = pq.top();\\n                pq.pop();\\n                if(top == 0)\\n                {\\n                    continue;\\n                }\\n                top--;\\n                if(top > 0)\\n                {\\n                    pq.push(top);\\n                }\\n                count++;\\n            }\\n            else if(pq.size() >= 2)\\n            {\\n                int top1 = pq.top();\\n                pq.pop();\\n                int top2 = pq.top();\\n                pq.pop();\\n                top1--;\\n                top2--;\\n                if(top1 > 0)\\n                {\\n                    pq.push(top1);\\n                }\\n                if(top2 > 0)\\n                {\\n                    pq.push(top2);\\n                }\\n                count++;\\n            }\\n            \\n            if(pq.size() == 0)\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) \\n    {\\n        if(amount.size() > 3)\\n        {\\n            return 0;\\n        }\\n        if(amount[0] == 0 and amount[1] == 0 and amount[2] == 0)\\n        {\\n            return 0;\\n        }\\n        priority_queue<int> pq(amount.begin() , amount.end());\\n        int count = 0;\\n\\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n            {\\n                int top = pq.top();\\n                pq.pop();\\n                if(top == 0)\\n                {\\n                    continue;\\n                }\\n                top--;\\n                if(top > 0)\\n                {\\n                    pq.push(top);\\n                }\\n                count++;\\n            }\\n            else if(pq.size() >= 2)\\n            {\\n                int top1 = pq.top();\\n                pq.pop();\\n                int top2 = pq.top();\\n                pq.pop();\\n                top1--;\\n                top2--;\\n                if(top1 > 0)\\n                {\\n                    pq.push(top1);\\n                }\\n                if(top2 > 0)\\n                {\\n                    pq.push(top2);\\n                }\\n                count++;\\n            }\\n            \\n            if(pq.size() == 0)\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072492,
                "title": "c-solution",
                "content": "# Intuition\\nused pq for fast maximum retrival.\\npushed the elements first.\\nrun a loop till the pq doesn\\'t have any elements.\\nif one cup -> look it(top) -> pop -> decrement -> push it again\\nif size >= 3 -> some the same with 2 tops.\\n\\nadd a counter inside the loop and return the loop\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) \\n    {\\n        if(amount.size() > 3)\\n        {\\n            return 0;\\n        }\\n        if(amount[0] == 0 and amount[1] == 0 and amount[2] == 0)\\n        {\\n            return 0;\\n        }\\n        priority_queue<int> pq(amount.begin() , amount.end());\\n        int count = 0;\\n\\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n            {\\n                int top = pq.top();\\n                pq.pop();\\n                if(top == 0)\\n                {\\n                    continue;\\n                }\\n                top--;\\n                if(top > 0)\\n                {\\n                    pq.push(top);\\n                }\\n                count++;\\n            }\\n            else if(pq.size() >= 2)\\n            {\\n                int top1 = pq.top();\\n                pq.pop();\\n                int top2 = pq.top();\\n                pq.pop();\\n                top1--;\\n                top2--;\\n                if(top1 > 0)\\n                {\\n                    pq.push(top1);\\n                }\\n                if(top2 > 0)\\n                {\\n                    pq.push(top2);\\n                }\\n                count++;\\n            }\\n            \\n            if(pq.size() == 0)\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) \\n    {\\n        if(amount.size() > 3)\\n        {\\n            return 0;\\n        }\\n        if(amount[0] == 0 and amount[1] == 0 and amount[2] == 0)\\n        {\\n            return 0;\\n        }\\n        priority_queue<int> pq(amount.begin() , amount.end());\\n        int count = 0;\\n\\n        while(!pq.empty())\\n        {\\n            if(pq.size() == 1)\\n            {\\n                int top = pq.top();\\n                pq.pop();\\n                if(top == 0)\\n                {\\n                    continue;\\n                }\\n                top--;\\n                if(top > 0)\\n                {\\n                    pq.push(top);\\n                }\\n                count++;\\n            }\\n            else if(pq.size() >= 2)\\n            {\\n                int top1 = pq.top();\\n                pq.pop();\\n                int top2 = pq.top();\\n                pq.pop();\\n                top1--;\\n                top2--;\\n                if(top1 > 0)\\n                {\\n                    pq.push(top1);\\n                }\\n                if(top2 > 0)\\n                {\\n                    pq.push(top2);\\n                }\\n                count++;\\n            }\\n            \\n            if(pq.size() == 0)\\n            {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072144,
                "title": "easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> q;\\n\\n            // fill qunatity of cups\\n    for(int i=0; i<amount.size(); i++){\\n        if(amount[i]>0)q.push(amount[i]);\\n    }\\n    \\n    int day = 0;\\n    while(!q.empty() && q.size()>1){\\n        // check first two elements decrease them and again push to priority queue\\n        int a = q.top() - 1;\\n        q.pop();\\n        \\n        int b = q.top() - 1;\\n        q.pop();\\n        \\n        day++;\\n        if(a>0) q.push(a);\\n        if(b>0) q.push(b);\\n    }\\n    \\n    // check if any element is left\\n    if(q.size()) day+=q.top();\\n    \\n    return day;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> q;\\n\\n            // fill qunatity of cups\\n    for(int i=0; i<amount.size(); i++){\\n        if(amount[i]>0)q.push(amount[i]);\\n    }\\n    \\n    int day = 0;\\n    while(!q.empty() && q.size()>1){\\n        // check first two elements decrease them and again push to priority queue\\n        int a = q.top() - 1;\\n        q.pop();\\n        \\n        int b = q.top() - 1;\\n        q.pop();\\n        \\n        day++;\\n        if(a>0) q.push(a);\\n        if(b>0) q.push(b);\\n    }\\n    \\n    // check if any element is left\\n    if(q.size()) day+=q.top();\\n    \\n    return day;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066427,
                "title": "simple-java-solution",
                "content": "# Intuition\\nPriorityQueue\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        Arrays.stream(amount).filter((val)->val!=0).forEach(queue::add);\\n        int seconds = 0;\\n        while(!queue.isEmpty()){\\n            if(queue.size() >= 2){\\n                int a = queue.poll() - 1;\\n                int b = queue.poll() - 1;\\n                if(a > 0){\\n                    queue.add(a);\\n                }\\n                if(b > 0){\\n                    queue.add(b);\\n                }\\n            }else{\\n                int a = queue.poll() - 1;\\n                if(a > 0){\\n                    queue.add(a);\\n                }\\n            }\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n        Arrays.stream(amount).filter((val)->val!=0).forEach(queue::add);\\n        int seconds = 0;\\n        while(!queue.isEmpty()){\\n            if(queue.size() >= 2){\\n                int a = queue.poll() - 1;\\n                int b = queue.poll() - 1;\\n                if(a > 0){\\n                    queue.add(a);\\n                }\\n                if(b > 0){\\n                    queue.add(b);\\n                }\\n            }else{\\n                int a = queue.poll() - 1;\\n                if(a > 0){\\n                    queue.add(a);\\n                }\\n            }\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051977,
                "title": "time-to-fill-cups-js-iterative-solution",
                "content": "```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function(amount) {\\n    count = 0\\n\\n    while (true) {\\n        amount.sort((a, b) => b - a)\\n\\n        if (amount[0] > 0 && amount[1] > 0) {\\n            amount[0] --\\n            amount[1] --\\n            count ++\\n            continue\\n        }\\n\\n        if (amount[0] > 0) {\\n            amount[0] --\\n            count ++\\n            continue\\n        }\\n\\n        break\\n    }\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} amount\\n * @return {number}\\n */\\nvar fillCups = function(amount) {\\n    count = 0\\n\\n    while (true) {\\n        amount.sort((a, b) => b - a)\\n\\n        if (amount[0] > 0 && amount[1] > 0) {\\n            amount[0] --\\n            amount[1] --\\n            count ++\\n            continue\\n        }\\n\\n        if (amount[0] > 0) {\\n            amount[0] --\\n            count ++\\n            continue\\n        }\\n\\n        break\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047942,
                "title": "beats-100-simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        sort(amount.begin(),amount.end());\\n        int s2 = amount[0]+amount[1];\\n        int s3=s2+amount[2];\\n        return s2<=amount[2]?amount[2]:s3%2?(s3+1)/2:s3/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        sort(amount.begin(),amount.end());\\n        int s2 = amount[0]+amount[1];\\n        int s3=s2+amount[2];\\n        return s2<=amount[2]?amount[2]:s3%2?(s3+1)/2:s3/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047285,
                "title": "c-beat-100-only-three-sentences",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought I could solve this problem by priority que. But I also thought I could solve this problrem by using math.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a setting : \\n\\u30FBtemp1 = biggest number\\n\\u30FBtemp2 = middle number\\n\\u30FBtemp3 = smallest number\\n\\nif temp1 is bigger than temp2+temp3 , I need to choice the temp1 all time.So, the answer is temp1 !\\nas an other case, if temp1 is **not** bigger than temp2+temp3 (temp1 - temp3 < temp2 ), we need to choice the number collectlly.The point is that we select bigger one between temp1 and temp2 while temp3 become 0.We can express by (temp1+temp2+1)/2 that is the number after temp3 become 0.Then answer is temp3 + (temp1+temp2+1)/2.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        sort(amount.begin(),amount.end());\\n        if(amount[2]-amount[0]<amount[1]) return amount[0]+(amount[2]-amount[0]+amount[1]+1)/2;\\n        else return amount[2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        sort(amount.begin(),amount.end());\\n        if(amount[2]-amount[0]<amount[1]) return amount[0]+(amount[2]-amount[0]+amount[1]+1)/2;\\n        else return amount[2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043981,
                "title": "easy-c-commented-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq(amount.begin(),amount.end()); //creat max heap\\n        int ans=0;\\n         while(pq.top() != 0) //untill element of heap are 0 \\n        {\\n            int x=pq.top(); //top element stored in x\\n            pq.pop(); //that elem is removed\\n            int y=pq.top(); //next top element stored in y\\n            pq.pop(); //it is also removed\\n            pq.push(x-1); //reduce value by 1\\n            pq.push(y-1);//reduce value by 1\\n            ans++; //increment time\\n        }\\n        return ans; //return time\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int>pq(amount.begin(),amount.end()); //creat max heap\\n        int ans=0;\\n         while(pq.top() != 0) //untill element of heap are 0 \\n        {\\n            int x=pq.top(); //top element stored in x\\n            pq.pop(); //that elem is removed\\n            int y=pq.top(); //next top element stored in y\\n            pq.pop(); //it is also removed\\n            pq.push(x-1); //reduce value by 1\\n            pq.push(y-1);//reduce value by 1\\n            ans++; //increment time\\n        }\\n        return ans; //return time\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041751,
                "title": "c-beat-100-with-2-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt will take minimum time of the largest cup to fill. \\n\\nTo fill the other cups it takes the sum subtracting the amount of the largest cup (since you can fill 1 cup of when filling up the larges cup) divided by 2.\\n\\nWe can do it, because while filling up the largest cup, we ensure to always fill up the second largest at that moment. If the sum of the smaller ones are even then we only need the amount in the cup and if they are not even then there is one step where only 1 cup gets filled.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        sort(amount.begin(), amount.end(), std::greater<>());\\n\\n\\n        return amount[0] + max(0, amount[1] + amount[2] + 1 - amount[0])/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        sort(amount.begin(), amount.end(), std::greater<>());\\n\\n\\n        return amount[0] + max(0, amount[1] + amount[2] + 1 - amount[0])/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023985,
                "title": "o-1-100-java-clearly-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is an apparently recursive O(n) solution beside this. But we can actually derive solution O(1) from given three numbers.\\n\\nHere I re-present an equivalent problem of dumping waters off each cup, instead of filling water.\\n\\nTo minimize number of operation, we want to perform two-cup operations as many as possible.\\n\\nFor simplicity, we denote those cups $L, M$ and $H$.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe assume the number of cups in 3 cups are $0 \\\\le l \\\\le m \\\\le h$. Sorting this takes O(1) but it doesn\\'t matter, sorting is not necessary.\\n\\n1. Clearly, if $h > l + m$, we have to perform at least $h$ operations to be able to dump all water from cup with $h$ cups of water. Additionally, there is a clear strategy that we can dump waters from all cups by $h$ operations: we perform $l$ operations dumpping water from cup with $l$ cups of water, along with cup with $h$ cups of water; then we perform $m$ operations dumping water from cup with $m$ cups of water, aloong with cup with (originally) $h$ cups of water. Then we perform $h - l -m$ operations dumping the rest of water from the cup that originally had $h$ cups of water. In this case, the result is $h$.\\n\\n2. If $h \\\\le l + m$, we show that we have a strategy to always dump $2$ cups of water for each operation, until the all cups are dumped, or with a single cup remaining $1$ cup left in it while the other two cups are all dumped.\\n\\n2.1 First dump $m - l$ cups from $M$ and $H$, the remaining waters in $L, M, H = l, l, h - (m - l)$.\\n\\n2.2 We perform $2k$ operations on $H$, along with whichever other cup has more water of $L$ or $M$. Since water from $L, M$ are dumpped at $1/2$ speed of the $H$. After $k$ steps, all three cups have same # of cups of water. This leads to equation\\n$l - k = h - (m - l) - 2k$, which gives $k = h - m$. So after $2(h-m)$ operations, the water left in all three cups are equal, $l - k = l + m - h\\\\ge0$.\\n\\n2.3 When all three cups have same amount of water, the # of operations to dump them all is $(l + m - h) \\\\cdot {3\\\\over2}$ if $l + m - h$ is even, $(l + m - h - 1)\\\\cdot {3\\\\over2} + 2$ if $l + m - h$ is odd.\\n\\n3. Therefore, adding up all those steps gives $(m - l) + 2(h-m) + (l + m - h)\\\\cdot{3\\\\over2} = \\\\frac{l + m + h}{2}$ if $l + m - h$ is even; $(m - l) + 2(h-m) + (l + m - h - 1)\\\\cdot{3\\\\over2} + 2 = \\\\frac{l + m + h + 1}{2}$ if $l + m - h$ is odd.\\n\\n4. Why is this minimal number of operations? Since there are $l + m + h$ cups of water, and we can dump $2$ cups at most once, therefore this result is indeed lower bound for the number of operations.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        // Beside recursion, this is O(1) solution\\n        int l = 0;\\n        int h = 0;\\n        int total = 0;\\n        for(int i = 0; i < 3; i++){\\n            l = Math.min(amount[i], l);\\n            h = Math.max(amount[i], h);\\n            total += amount[i];\\n        }\\n        // imabalanced, h way higher\\n        // balanced case, if h < l + m, to minimize amount of time,\\n        // we can always do 2 cups a time, except for the last. This\\n        // is because if we reverse the problem as dump water from cups, we\\n        // can \"always dump two higest cups\" each time. Why?\\n        //  first dump highest two m - l times to {l, l, h - (m - l)}, let f = f(l, m, h), then f = m - l + f(l, l, h - (m - l))\\n        // after 2k times of alternating, we have\\n        // f = m - l + 2k + f(l - k, l - k, h -(m-l) - 2k) such that l - k = h - (m-l) - 2k, thus k = h - (m-l) - l = h - m,\\n        // thus after 2k = 2(h-m) times of alternating, we have\\n        // f = m - l + 2(h-m) + f(l - h + m, l -h + m, h - m + l - 2(h -m)) = m - l + 2(h - m) + f(l + m - h, l + m - h, l + m - h)\\n        // = 2h - m - l + (l + m - h) * 3 / 2 = h + (l + m - h) / 2 = (l + m + h) / 2\\n        if(h >= total - h) return h;\\n        // balanced\\n        return (total + 1) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        // Beside recursion, this is O(1) solution\\n        int l = 0;\\n        int h = 0;\\n        int total = 0;\\n        for(int i = 0; i < 3; i++){\\n            l = Math.min(amount[i], l);\\n            h = Math.max(amount[i], h);\\n            total += amount[i];\\n        }\\n        // imabalanced, h way higher\\n        // balanced case, if h < l + m, to minimize amount of time,\\n        // we can always do 2 cups a time, except for the last. This\\n        // is because if we reverse the problem as dump water from cups, we\\n        // can \"always dump two higest cups\" each time. Why?\\n        //  first dump highest two m - l times to {l, l, h - (m - l)}, let f = f(l, m, h), then f = m - l + f(l, l, h - (m - l))\\n        // after 2k times of alternating, we have\\n        // f = m - l + 2k + f(l - k, l - k, h -(m-l) - 2k) such that l - k = h - (m-l) - 2k, thus k = h - (m-l) - l = h - m,\\n        // thus after 2k = 2(h-m) times of alternating, we have\\n        // f = m - l + 2(h-m) + f(l - h + m, l -h + m, h - m + l - 2(h -m)) = m - l + 2(h - m) + f(l + m - h, l + m - h, l + m - h)\\n        // = 2h - m - l + (l + m - h) * 3 / 2 = h + (l + m - h) / 2 = (l + m + h) / 2\\n        if(h >= total - h) return h;\\n        // balanced\\n        return (total + 1) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011025,
                "title": "0-ms-c-simple-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> q;\\n\\n        for(auto a:amount)\\n            q.push(a);\\n\\n        int count=0;\\n        while(q.top() != 0) {\\n            int t1 = q.top();\\n            q.pop();\\n            int t2 = q.top();\\n            q.pop();\\n            t1--;\\n            t2--;\\n            count++;\\n            q.push(t1);\\n            q.push(t2);\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> q;\\n\\n        for(auto a:amount)\\n            q.push(a);\\n\\n        int count=0;\\n        while(q.top() != 0) {\\n            int t1 = q.top();\\n            q.pop();\\n            int t2 = q.top();\\n            q.pop();\\n            t1--;\\n            t2--;\\n            count++;\\n            q.push(t1);\\n            q.push(t2);\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010490,
                "title": "easy-solution-with-iterative-sorting-and-cheking-which-beats-96-67-65-41-of-users-with-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort the amounts list and use two types if its possible.else use the existing type\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nset the second = 0\\nwhile there are two elements in the amounts that are greaetr than zero(0).decreament the elements by 1 and increment the second  by 1\\nif there is no two elements that have values greater than 0,break out of the while loop.and add the sum(of elements in the amounts array) and the second and return it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        second = 0\\n        while True:\\n            amount = sorted(amount,reverse = True)\\n            if amount[0]>0 and amount[1]>0:\\n                amount[0]-=1\\n                amount[1]-=1\\n                second+=1\\n            elif amount[0]>0 and amount[2]>0:\\n                amount[0]-=1\\n                amount[2]-=1\\n                second+=1\\n            elif amount[1]>0 and amount[2]>0:\\n                amount[1]-=1\\n                amount[2]-=1\\n                second+=1\\n            else:\\n                break\\n        return second+sum(amount)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        second = 0\\n        while True:\\n            amount = sorted(amount,reverse = True)\\n            if amount[0]>0 and amount[1]>0:\\n                amount[0]-=1\\n                amount[1]-=1\\n                second+=1\\n            elif amount[0]>0 and amount[2]>0:\\n                amount[0]-=1\\n                amount[2]-=1\\n                second+=1\\n            elif amount[1]>0 and amount[2]>0:\\n                amount[1]-=1\\n                amount[2]-=1\\n                second+=1\\n            else:\\n                break\\n        return second+sum(amount)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999091,
                "title": "beginner-s-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Here if you see the examples we will observe that in each step we are trying to reduce the largest element in the array along with any other element if present because the most amount of time will be taken by the greatest element .So here we will use sorting to find the greatest element after every step and reducing it by one .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int i=0;\\n        int n=amount.size();\\n        //This loop acts as a counter and i is the answer that is the reason why it is declared outside the loop.\\n        for(;i<INT_MAX;i++){\\n            //We are sorting at every step in order to find the greatest element.\\n            sort(amount.begin(),amount.end());\\n\\n            //IF our greatest element is 0 that means our whole array is zero which is an indicator to break.\\n            if(amount[n-1]==0){\\n                break;\\n            }\\n            amount[n-1]=amount[n-1]-1;\\n\\n            //Since we can delete one more cup so before deleting we check whether it is zero or not in order to avoid the negative numbers\\n            if(amount[n-2]!=0){\\n                amount[n-2]=amount[n-2]-1;\\n            }\\n        }\\n        return i;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int i=0;\\n        int n=amount.size();\\n        //This loop acts as a counter and i is the answer that is the reason why it is declared outside the loop.\\n        for(;i<INT_MAX;i++){\\n            //We are sorting at every step in order to find the greatest element.\\n            sort(amount.begin(),amount.end());\\n\\n            //IF our greatest element is 0 that means our whole array is zero which is an indicator to break.\\n            if(amount[n-1]==0){\\n                break;\\n            }\\n            amount[n-1]=amount[n-1]-1;\\n\\n            //Since we can delete one more cup so before deleting we check whether it is zero or not in order to avoid the negative numbers\\n            if(amount[n-2]!=0){\\n                amount[n-2]=amount[n-2]-1;\\n            }\\n        }\\n        return i;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994046,
                "title": "easy-solution-o-1-java-solution",
                "content": "# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int fillCups(int[] amount) {\\n        int maxCup = 0, sum = 0;\\n        for(int curCup: amount) {\\n            maxCup = Math.max(curCup, maxCup);\\n            sum += curCup;\\n        }\\n        return Math.max(maxCup, (sum + 1) / 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n     public int fillCups(int[] amount) {\\n        int maxCup = 0, sum = 0;\\n        for(int curCup: amount) {\\n            maxCup = Math.max(curCup, maxCup);\\n            sum += curCup;\\n        }\\n        return Math.max(maxCup, (sum + 1) / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988392,
                "title": "filling-cups-with-water-simple-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: I\\'m not sure, but according to fixed size of array it must be O(1) in average\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n\\n        int answer = 0;\\n\\n        //give preference to the most numerous \\u0441ups;\\n        sort(amount.rbegin(), amount.rend());\\n\\n        while (amount[0] && amount[1]) {\\n            answer++; \\n            amount[0]--, amount[1]--;\\n            sort(amount.rbegin(), amount.rend());\\n        }\\n\\n        //if single bottle is left;\\n        answer += amount[0];\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n\\n        int answer = 0;\\n\\n        //give preference to the most numerous \\u0441ups;\\n        sort(amount.rbegin(), amount.rend());\\n\\n        while (amount[0] && amount[1]) {\\n            answer++; \\n            amount[0]--, amount[1]--;\\n            sort(amount.rbegin(), amount.rend());\\n        }\\n\\n        //if single bottle is left;\\n        answer += amount[0];\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981729,
                "title": "c-simple-solution-greedy-heap",
                "content": "# Intuition\\nYou need to maximize the time you spend filling multiple cups simultaneously. To accomplish this, always fill the two largest sets of unfilled cups.\\n\\n# Approach\\n1. Create a max heap with the elements in amount. In C#, the closest thing to a heap is a priority queue.\\n2. Until you have 1 element in the heap, dequeue the 2 largest values in the heap. Decrement both values and requeue them if they are not 0.\\n3. Repeat.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FillCups(int[] amount) {\\n        int seconds = 0;\\n\\n        //max heap\\n        PriorityQueue<int, int> pq = new();\\n        \\n        //populate heap\\n        foreach (int i in amount) {\\n            if (i > 0) {\\n                pq.Enqueue(i, -1 * i);\\n            }\\n        }\\n        \\n        while (pq.Count != 0) {\\n            if (pq.Count == 1) {\\n                //you can no longer fill 2 cups simultaneously.\\n                int x = pq.Dequeue();\\n\\n                seconds += x;\\n            } else {\\n                //fill 2 largest cups.\\n                int a = pq.Dequeue() - 1;\\n                int b = pq.Dequeue() - 1;\\n\\n                if (a > 0)\\n                    pq.Enqueue(a, -1*a);\\n\\n                if (b > 0)\\n                    pq.Enqueue(b, -1*b);\\n\\n                seconds++;\\n            }\\n        }\\n\\n        return seconds;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FillCups(int[] amount) {\\n        int seconds = 0;\\n\\n        //max heap\\n        PriorityQueue<int, int> pq = new();\\n        \\n        //populate heap\\n        foreach (int i in amount) {\\n            if (i > 0) {\\n                pq.Enqueue(i, -1 * i);\\n            }\\n        }\\n        \\n        while (pq.Count != 0) {\\n            if (pq.Count == 1) {\\n                //you can no longer fill 2 cups simultaneously.\\n                int x = pq.Dequeue();\\n\\n                seconds += x;\\n            } else {\\n                //fill 2 largest cups.\\n                int a = pq.Dequeue() - 1;\\n                int b = pq.Dequeue() - 1;\\n\\n                if (a > 0)\\n                    pq.Enqueue(a, -1*a);\\n\\n                if (b > 0)\\n                    pq.Enqueue(b, -1*b);\\n\\n                seconds++;\\n            }\\n        }\\n\\n        return seconds;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977476,
                "title": "beats-100",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n       priority_queue<int> pq(amount.begin(),amount.end());\\n        int cnt=0;\\n        while(pq.top()!=0)\\n        {\\n           cnt++;\\n           int num1 = pq.top(); pq.pop();\\n           int num2 = pq.top(); pq.pop();\\n            pq.push(num1-1);\\n            pq.push(num2-1);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n       priority_queue<int> pq(amount.begin(),amount.end());\\n        int cnt=0;\\n        while(pq.top()!=0)\\n        {\\n           cnt++;\\n           int num1 = pq.top(); pq.pop();\\n           int num2 = pq.top(); pq.pop();\\n            pq.push(num1-1);\\n            pq.push(num2-1);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976683,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        seconds = 0\\n\\n        while True:\\n            amount.sort()\\n            l, r = 0, len(amount) - 1\\n\\n            while r >= 0 and amount[r] == 0:\\n                r -= 1\\n            while l < len(amount) and amount[l] == 0:\\n                l += 1\\n            \\n            if l >= len(amount) or r < 0:\\n                break\\n            \\n            if l != r:\\n                amount[r] -= 1\\n                amount[l] -= 1\\n                seconds += 1\\n            else:\\n                seconds += amount[l]\\n                break\\n\\n        return seconds\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        seconds = 0\\n\\n        while True:\\n            amount.sort()\\n            l, r = 0, len(amount) - 1\\n\\n            while r >= 0 and amount[r] == 0:\\n                r -= 1\\n            while l < len(amount) and amount[l] == 0:\\n                l += 1\\n            \\n            if l >= len(amount) or r < 0:\\n                break\\n            \\n            if l != r:\\n                amount[r] -= 1\\n                amount[l] -= 1\\n                seconds += 1\\n            else:\\n                seconds += amount[l]\\n                break\\n\\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967715,
                "title": "java-easy-solution-using-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int i=amount.length -1;\\n        int j = amount.length -2;\\n        int sec = 0;\\n        while(amount[0] != 0 || amount[1] != 0 || amount[2] != 0){\\n            Arrays.sort(amount);\\n            \\n            if(amount[i] !=0 && amount[j] != 0){\\n               amount[i] = amount[i] - 1;\\n               amount[j] = amount[j] - 1;\\n            }else{\\n               amount[i] = amount[i] - 1;\\n            }\\n\\n            sec++;\\n        }\\n\\n        return sec;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int i=amount.length -1;\\n        int j = amount.length -2;\\n        int sec = 0;\\n        while(amount[0] != 0 || amount[1] != 0 || amount[2] != 0){\\n            Arrays.sort(amount);\\n            \\n            if(amount[i] !=0 && amount[j] != 0){\\n               amount[i] = amount[i] - 1;\\n               amount[j] = amount[j] - 1;\\n            }else{\\n               amount[i] = amount[i] - 1;\\n            }\\n\\n            sec++;\\n        }\\n\\n        return sec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928333,
                "title": "easy-java-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] arr) {\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int i : arr) max.add(i);\\n\\n        int count = 0;\\n        while(max.peek() > 0) {\\n            int num1 = max.poll();\\n            int num2 = max.poll();\\n            max.add(--num1);\\n            max.add(--num2);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int fillCups(int[] arr) {\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int i : arr) max.add(i);\\n\\n        int count = 0;\\n        while(max.peek() > 0) {\\n            int num1 = max.poll();\\n            int num2 = max.poll();\\n            max.add(--num1);\\n            max.add(--num2);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928067,
                "title": "python-3-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        amount.sort(reverse=True)\\n        c=0\\n        if amount[0]==0 or amount[1]==0 or amount[2]==0:\\n            return max(amount)\\n        else:\\n            while(sum(amount)>0):\\n                amount[0]=amount[0]-1\\n                amount[1]=amount[1]-1\\n                for i in range(0,len(amount)):\\n                    if amount[i]<0:\\n                        amount[i]=0\\n                        print(i)\\n                amount.sort(reverse=True)\\n                print(amount)\\n                c+=1\\n            return(c)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def fillCups(self, amount: List[int]) -> int:\\n        amount.sort(reverse=True)\\n        c=0\\n        if amount[0]==0 or amount[1]==0 or amount[2]==0:\\n            return max(amount)\\n        else:\\n            while(sum(amount)>0):\\n                amount[0]=amount[0]-1\\n                amount[1]=amount[1]-1\\n                for i in range(0,len(amount)):\\n                    if amount[i]<0:\\n                        amount[i]=0\\n                        print(i)\\n                amount.sort(reverse=True)\\n                print(amount)\\n                c+=1\\n            return(c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903434,
                "title": "c-solution-priorityqueue-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$ O(max(Amount), (sum(Amount) + 1)/2) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(n) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FillCups(int[] amount) {\\n        int count = 0;\\n        PriorityQueue<int, int> pq = new();\\n\\n        foreach(var a in amount){\\n            if(a > 0){\\n                pq.Enqueue(a, -a);\\n            }\\n        }\\n\\n        while(pq.Count > 1){\\n            count++;\\n            int num1 = pq.Dequeue() - 1;\\n            int num2 = pq.Dequeue() - 1;\\n\\n            if(num1 > 0){\\n                pq.Enqueue(num1, -num1);\\n            }\\n\\n            if(num2 > 0){\\n                pq.Enqueue(num2, -num2);\\n            }\\n        }\\n\\n        return count + (pq.Count > 0 ? pq.Dequeue() : 0);\\n    }\\n}\\n\\n/*\\n5,4,4\\n4,4,3\\n3,3,3\\n3,2,2\\n2,2,1\\n1,1,1\\n1,0,0\\n0,0,0\\n*/\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int FillCups(int[] amount) {\\n        int count = 0;\\n        PriorityQueue<int, int> pq = new();\\n\\n        foreach(var a in amount){\\n            if(a > 0){\\n                pq.Enqueue(a, -a);\\n            }\\n        }\\n\\n        while(pq.Count > 1){\\n            count++;\\n            int num1 = pq.Dequeue() - 1;\\n            int num2 = pq.Dequeue() - 1;\\n\\n            if(num1 > 0){\\n                pq.Enqueue(num1, -num1);\\n            }\\n\\n            if(num2 > 0){\\n                pq.Enqueue(num2, -num2);\\n            }\\n        }\\n\\n        return count + (pq.Count > 0 ? pq.Dequeue() : 0);\\n    }\\n}\\n\\n/*\\n5,4,4\\n4,4,3\\n3,3,3\\n3,2,2\\n2,2,1\\n1,1,1\\n1,0,0\\n0,0,0\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897672,
                "title": "easy-c-solution-using-pq-100-beats-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int s=0;\\n        int k=0,p=0;\\n      priority_queue<int>m={amount.begin(),amount.end()};\\n      while(m.top()!=0)\\n      {     s++;\\n           k=m.top();\\n           m.pop();\\n           k=k-1;\\n         p=m.top();\\n         m.pop();\\n         p=p-1;\\n         m.push(p);\\n         m.push(k);\\n      }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        int s=0;\\n        int k=0,p=0;\\n      priority_queue<int>m={amount.begin(),amount.end()};\\n      while(m.top()!=0)\\n      {     s++;\\n           k=m.top();\\n           m.pop();\\n           k=k-1;\\n         p=m.top();\\n         m.pop();\\n         p=p-1;\\n         m.push(p);\\n         m.push(k);\\n      }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1714925,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            },
            {
                "id": 1871812,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            },
            {
                "id": 1795861,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            },
            {
                "id": 1719700,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            },
            {
                "id": 1863068,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            },
            {
                "id": 1849580,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            },
            {
                "id": 1807982,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            },
            {
                "id": 1713633,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            },
            {
                "id": 1699507,
                "content": [
                    {
                        "username": "nitinbokde8",
                        "content": "[5,4,4] why this test case lead to answer 7 instead of 8 \\nseconds = 0;\\nsort [4,4,5]\\nseconds += amount[1] = 4;\\namount[2] = amount[2]-amount[1] = 1;\\namount[1] = 0;\\nsort [0,1,4]\\nseconds = seconds + amount[1] = 4 +1 = 5\\namount[2]=amount[2]-amount[1]=4-1=3\\namount[1]=0;\\nreturn (seconds+amount[2]) = 5+3 = 8;"
                    },
                    {
                        "username": "mukeshk92578",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int idx = 0; idx < amount.length; idx++){\\n            pq.add(amount[idx]);\\n        }\\n        int step = 0;\\n\\n        while(pq.peek() != 0){\\n            int p1 = pq.poll();\\n            int p2 = pq.poll();\\n            pq.add(--p1);\\n            pq.add(--p2);\\n            step++;\\n        }\\n        return step;\\n    }\\n}"
                    },
                    {
                        "username": "anjith",
                        "content": "Why would you give your solution in discussions especially when the rules says otherwise?"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy and simple Problem <br>\\nHint Use Max Heap<br>\\nMy solution Link : -> https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3169341/c-easy-and-simple-solution/"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "Very easy step-\\nChoose the two largest value and decrease it by 1.\\nRepeat this untill all elements become zero."
                    },
                    {
                        "username": "Stasinos",
                        "content": "That\\'s not optimal"
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "[@ayushh2023](/ayushh2023) Thank you so much buddy \\nI solved the problem... :)"
                    },
                    {
                        "username": "ayushh2023",
                        "content": "[@nitinbokde8](/nitinbokde8) \\nStep 1:take two largest element that is 5 and 4 and decrease them so array becomes{4,3,4}\\nStep 2:take two largest element that is 3 and 3 and decrease them so array becomes{3,3,3}\\nStep 3:take two largest element that is 3 and 3 and decrease them so array becomes{2,3,2}\\nStep 4:take two largest element that is 3 and 2 and decrease them so array becomes{1,2,2}\\nStep 5:take two largest element that is 2 and 2 and decrease them so array becomes{1,1,1}\\nStep 6:take two largest element that is 1 and 1 and decrease them so array becomes{0,0,1}\\nStep 7:take largest element that is 1 and decrease it so array becomes{0,0,0}\\nso answer is 7."
                    },
                    {
                        "username": "nitinbokde8",
                        "content": "I am still confused for the test case [5,4,4]\\n"
                    },
                    {
                        "username": "Stasinos",
                        "content": "I don\\'t get why most solution use brute force... It\\'s 2 simple steps. Here\\'s mine, beating 100% in time and memory (O(1) in both). Leave a star if it\\'s helpful.\\nhttps://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/solutions/3416051/fully-explained-o-1-o-1-beats-100/"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont be fooled by related topics ... this is purely a math problem "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2335.%20Minimum%20Amount%20of%20Time%20to%20Fill%20Cups.cpp\\n\\nAll LEETCODE SOLUTION IN C++\\nPLEASE LEAVE A STAR if you find it helpful."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Is there Any way to solve this in O(n) time?\\nCan\\'t find any."
                    },
                    {
                        "username": "prathmeshdeshpande101",
                        "content": "Whats wrong with this solution ?\\nCant get minimum seconds.\\n\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        int sec =0;\\n        Arrays.sort(amount);\\n        int l=0;\\n        int r=amount.length-1;\\n        while(l<r){\\n            if(amount[l] == 0){\\n                l++;\\n            }if(amount[r] == 0){\\n                r--;\\n            }\\n            if(l==r) break;\\n            amount[l] -= 1;\\n            amount[r] -= 1;\\n            sec++;\\n        }\\n        sec += amount[l];\\n        return sec;\\n    }\\n}"
                    },
                    {
                        "username": "ILIHAS",
                        "content": "you are trying to fill the min amount and maximum amount cup in one second but the optimal solution will be find out by filling the two maximum amount cup in one second\\n\\nso at  second i  if you have more than 1 cups that are to be filled the select the 2 maximum amount cups and fill them\\nelse just fill the 1 cup that is empty\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Finding the Number of Visible Mountains",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1648588,
                "content": [
                    {
                        "username": "aalmos",
                        "content": "Why the solution for `[[1,3],[1,3]]` is `0` and not `1`?"
                    },
                    {
                        "username": "cool_heisenberg",
                        "content": "makes problem unncessarily complicated"
                    },
                    {
                        "username": "pelinsezgin",
                        "content": "Anyone who solved this question at the first sight without checking other solutions? (Please say no :) ) "
                    },
                    {
                        "username": "Spaulding_",
                        "content": "![Untitled 2.jpg](https://assets.leetcode.com/users/images/bc33d66b-5a9a-453d-879c-580dd09e74be_1670529102.1909685.jpeg)\n\n“The secret of being a bore is to tell everything.” ― Voltaire"
                    },
                    {
                        "username": "user6901z",
                        "content": "Why the solution for [[1,3],[1,3]] is 0 and not 1?"
                    },
                    {
                        "username": "gobblin_insights",
                        "content": "peaks can not be equal!"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "Hello All,\\n\\nFor the below input\\n[[3,19],[39,7],[15,39],[23,13],[8,28],[2,26],[38,15],[38,7],[16,17]]\\n\\nthe sorted values will look like \\n\\n"
                    }
                ]
            },
            {
                "id": 1947102,
                "content": [
                    {
                        "username": "aalmos",
                        "content": "Why the solution for `[[1,3],[1,3]]` is `0` and not `1`?"
                    },
                    {
                        "username": "cool_heisenberg",
                        "content": "makes problem unncessarily complicated"
                    },
                    {
                        "username": "pelinsezgin",
                        "content": "Anyone who solved this question at the first sight without checking other solutions? (Please say no :) ) "
                    },
                    {
                        "username": "Spaulding_",
                        "content": "![Untitled 2.jpg](https://assets.leetcode.com/users/images/bc33d66b-5a9a-453d-879c-580dd09e74be_1670529102.1909685.jpeg)\n\n“The secret of being a bore is to tell everything.” ― Voltaire"
                    },
                    {
                        "username": "user6901z",
                        "content": "Why the solution for [[1,3],[1,3]] is 0 and not 1?"
                    },
                    {
                        "username": "gobblin_insights",
                        "content": "peaks can not be equal!"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "Hello All,\\n\\nFor the below input\\n[[3,19],[39,7],[15,39],[23,13],[8,28],[2,26],[38,15],[38,7],[16,17]]\\n\\nthe sorted values will look like \\n\\n"
                    }
                ]
            },
            {
                "id": 1710218,
                "content": [
                    {
                        "username": "aalmos",
                        "content": "Why the solution for `[[1,3],[1,3]]` is `0` and not `1`?"
                    },
                    {
                        "username": "cool_heisenberg",
                        "content": "makes problem unncessarily complicated"
                    },
                    {
                        "username": "pelinsezgin",
                        "content": "Anyone who solved this question at the first sight without checking other solutions? (Please say no :) ) "
                    },
                    {
                        "username": "Spaulding_",
                        "content": "![Untitled 2.jpg](https://assets.leetcode.com/users/images/bc33d66b-5a9a-453d-879c-580dd09e74be_1670529102.1909685.jpeg)\n\n“The secret of being a bore is to tell everything.” ― Voltaire"
                    },
                    {
                        "username": "user6901z",
                        "content": "Why the solution for [[1,3],[1,3]] is 0 and not 1?"
                    },
                    {
                        "username": "gobblin_insights",
                        "content": "peaks can not be equal!"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "Hello All,\\n\\nFor the below input\\n[[3,19],[39,7],[15,39],[23,13],[8,28],[2,26],[38,15],[38,7],[16,17]]\\n\\nthe sorted values will look like \\n\\n"
                    }
                ]
            },
            {
                "id": 1909393,
                "content": [
                    {
                        "username": "aalmos",
                        "content": "Why the solution for `[[1,3],[1,3]]` is `0` and not `1`?"
                    },
                    {
                        "username": "cool_heisenberg",
                        "content": "makes problem unncessarily complicated"
                    },
                    {
                        "username": "pelinsezgin",
                        "content": "Anyone who solved this question at the first sight without checking other solutions? (Please say no :) ) "
                    },
                    {
                        "username": "Spaulding_",
                        "content": "![Untitled 2.jpg](https://assets.leetcode.com/users/images/bc33d66b-5a9a-453d-879c-580dd09e74be_1670529102.1909685.jpeg)\n\n“The secret of being a bore is to tell everything.” ― Voltaire"
                    },
                    {
                        "username": "user6901z",
                        "content": "Why the solution for [[1,3],[1,3]] is 0 and not 1?"
                    },
                    {
                        "username": "gobblin_insights",
                        "content": "peaks can not be equal!"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "Hello All,\\n\\nFor the below input\\n[[3,19],[39,7],[15,39],[23,13],[8,28],[2,26],[38,15],[38,7],[16,17]]\\n\\nthe sorted values will look like \\n\\n"
                    }
                ]
            },
            {
                "id": 1832098,
                "content": [
                    {
                        "username": "aalmos",
                        "content": "Why the solution for `[[1,3],[1,3]]` is `0` and not `1`?"
                    },
                    {
                        "username": "cool_heisenberg",
                        "content": "makes problem unncessarily complicated"
                    },
                    {
                        "username": "pelinsezgin",
                        "content": "Anyone who solved this question at the first sight without checking other solutions? (Please say no :) ) "
                    },
                    {
                        "username": "Spaulding_",
                        "content": "![Untitled 2.jpg](https://assets.leetcode.com/users/images/bc33d66b-5a9a-453d-879c-580dd09e74be_1670529102.1909685.jpeg)\n\n“The secret of being a bore is to tell everything.” ― Voltaire"
                    },
                    {
                        "username": "user6901z",
                        "content": "Why the solution for [[1,3],[1,3]] is 0 and not 1?"
                    },
                    {
                        "username": "gobblin_insights",
                        "content": "peaks can not be equal!"
                    },
                    {
                        "username": "vishyarjun1991",
                        "content": "Hello All,\\n\\nFor the below input\\n[[3,19],[39,7],[15,39],[23,13],[8,28],[2,26],[38,15],[38,7],[16,17]]\\n\\nthe sorted values will look like \\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Generate the Invoice",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Calculate the Influence of Each Salesperson",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1679895,
                "content": [
                    {
                        "username": "CarterMacLennan",
                        "content": "Couple Ideas to help!\\n- How will we handle sales people with no customers? \\n- Don\\'t accidentally filter out a Sales Person!\\n- Make sure you don\\'t output a NULL :)"
                    }
                ]
            }
        ]
    }
]