[
    {
        "title": "Can Convert String in K Moves",
        "question_content": "Given two strings&nbsp;s&nbsp;and&nbsp;t, your goal is to convert&nbsp;s&nbsp;into&nbsp;t&nbsp;in&nbsp;k&nbsp;moves or less.\nDuring the&nbsp;ith&nbsp;(1 <= i <= k)&nbsp;move you can:\n\n\tChoose any index&nbsp;j&nbsp;(1-indexed) from&nbsp;s, such that&nbsp;1 <= j <= s.length&nbsp;and j&nbsp;has not been chosen in any previous move,&nbsp;and shift the character at that index&nbsp;i&nbsp;times.\n\tDo nothing.\n\nShifting a character means replacing it by the next letter in the alphabet&nbsp;(wrapping around so that&nbsp;'z'&nbsp;becomes&nbsp;'a'). Shifting a character by&nbsp;i&nbsp;means applying the shift operations&nbsp;i&nbsp;times.\nRemember that any index&nbsp;j&nbsp;can be picked at most once.\nReturn&nbsp;true&nbsp;if it's possible to convert&nbsp;s&nbsp;into&nbsp;t&nbsp;in no more than&nbsp;k&nbsp;moves, otherwise return&nbsp;false.\n&nbsp;\nExample 1:\n\nInput: s = \"input\", t = \"ouput\", k = 9\nOutput: true\nExplanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.\n\nExample 2:\n\nInput: s = \"abc\", t = \"bcd\", k = 10\nOutput: false\nExplanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\n\nExample 3:\n\nInput: s = \"aab\", t = \"bbb\", k = 27\nOutput: true\nExplanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length, t.length <= 10^5\n\t0 <= k <= 10^9\n\ts, t contain&nbsp;only lowercase English letters.",
        "solutions": [
            {
                "id": 779903,
                "title": "java-python-3-o-n-count-the-shift-displacement-w-brief-explanation-and-analysis",
                "content": "**Q & A:**\\nQ1: Where in the problem do you derive to get the following step `3`?\\nA1: From the following description:\\n\" ...\\nDuring the ith (1 <= i <= k) move you can:\\n\\n1. Choose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.\\n2. Do nothing.\\n\\n...\"\\n\\n**End of Q & A**\\n\\n----\\n\\n# Brief Explanation:\\n\\n\\n1. Check if the 2 strings `s` and `t` have same length, if not, return `false`; \\n2. Loop through the input strings and count the shift displacement, in case negative, plus 26 to make it positive;\\n3. If same displacement appears multiple times, the 1st time use the displacement itself, the 2nd time add `26 `to it, the 3rd time add `26 * (3 - 1) = 52 `, the 4th time add `26 * (4 - 1) = 78`, etc.; if after adding the result is greater than `k`, return `false`;\\n4. If never encounter `false` in the above 3, return `true`.\\n\\n```java\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n            if (diff > 0 && diff + count[diff] * 26 > k) {\\n                return false;\\n            }\\n            ++count[diff];\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        cnt = [0] * 26\\n        for cs, ct in zip(s, t):\\n            diff = (ord(ct) - ord(cs)) % 26\\n            if diff > 0 and cnt[diff] * 26 + diff > k:\\n                return False\\n            cnt[diff] += 1\\n        return True\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = s.length().",
                "solutionTags": [],
                "code": "```java\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int diff = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n            if (diff > 0 && diff + count[diff] * 26 > k) {\\n                return false;\\n            }\\n            ++count[diff];\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        cnt = [0] * 26\\n        for cs, ct in zip(s, t):\\n            diff = (ord(ct) - ord(cs)) % 26\\n            if diff > 0 and cnt[diff] * 26 + diff > k:\\n                return False\\n            cnt[diff] += 1\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779908,
                "title": "c-o-n-track-multiplier",
                "content": "#### Intuition\\nYou can only shift a letter once, and you cannot change more than once letter by the same number of shifts (`i`). In other words, if you shift one letter by `1`, no other letters can be shifted by `1`. If you need to shift by `1` again, you need to use \"wrapping\" and shift by `27` (which is `1 + 26`).\\n\\nTherefore, if our strings are `\"aaa\"` and `\"bbb\"`, we need to shift the first letter by `1`, the second by `27` (`1 + 26`), and the third - by `53` (`1 + 2 * 26`). So, you  can accomplish the task if `k` is equal or greater than `53`.\\n\\n#### Algorithm\\nGo through the strings and determine `shift` for each letter. If letter in `t` is smaller, we need to \"wrap\" it by adding 26 (e.g. changing `b` into `a` needs 25 shifts).\\n\\nAfter we use a certain number of shifts, we need to add 26, 52, and so on if we need to use it again. So we track the multiplier for each number of shifts in `mul`. If, at any time, the needed number of shifts exceeds `k`, we return `false`.\\n\\n```cpp\\nbool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779932,
                "title": "o-n-c-simple-solution-with-explanation",
                "content": "Basic idea is to convert str1 to str2 using less or equal to k iterations where in ith iteration you can choose **atmost** one character to shift **exactly** i places.\\n\\nIntuition :\\n1. if string size is not equal, return false;\\n2. use a hashmap to check how many times the diff is same and keep using the iteration with the formula (26 *(num of occurreces of same diff) + diff;\\n\\nFor eg. \"abc\" -> \"bcd\", diff for a -> b is 1 and we can check hashmap for occurences of diff as following:\\n\\n\\n```hashMap = {....... {1 = 0}....}```\\nWe can use iteration 1 in this case and we update the hashmap to the following to denote that 1 iteration has already been used.\\n```hashMap = {....... {1 = 1}....}```\\n\\nNow to shift b -> c also we need 1 Iteration,which is already being used.\\n```hashMap = {....... {1 = 1}....}```\\n\\nSince 1 iteration is already being used, we can use 26 + 1, and update hash map :\\n```hashMap = {....... {1 = 2}....}```\\nand we also keep track of the maximum iteration found so far.\\n...\\n...\\nand so on.\\n\\nFinally if max iteration <= k return true.\\n\\nNote: Please upvote if you find this useful, this motivates me to write more descriptive solutions\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            if (mp.find(diff) == mp.end()) {\\n                count = max(count, diff);\\n            } else {\\n                count = max(count, (mp[diff] * 26) + diff);\\n            }\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n}; \\n```\\n\\nMore Concise solution\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            count = max(count, (mp[diff] * 26) + diff);\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```hashMap = {....... {1 = 0}....}```\n```hashMap = {....... {1 = 1}....}```\n```hashMap = {....... {1 = 1}....}```\n```hashMap = {....... {1 = 2}....}```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int m = s.length(), n = t.length(), count = 0;\\n        if (m != n) return false;\\n        unordered_map<int, int> mp;\\n        for (int i = 0; i < m; i++) {\\n            if (t[i] == s[i]) continue;\\n            int diff = t[i] - s[i] < 0 ? 26 + t[i] - s[i] : t[i] - s[i];\\n            if (mp.find(diff) == mp.end()) {\\n                count = max(count, diff);\\n            } else {\\n                count = max(count, (mp[diff] * 26) + diff);\\n            }\\n            mp[diff]++;\\n            if (count > k) return false;\\n        }\\n        return count <= k;\\n    }\\n    \\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779938,
                "title": "python-o-n-explained",
                "content": "The logic is as follows:\\nFirst we need to calculate the difference of the conversion. for example conversion from a to be will have difference of 1.\\nThen we hold a hash map ```diff``` to see how many times we want to convert each difference.\\nFor example to go from \"aa\" to \"bb\" we want to go ```difference 1``` for 2 times.\\nThis is possible only if we will have k of 27 or above, because to go from ```a``` to ```b``` we need 1, and each loop starts at 26 (alphabet count).\\n\\nQuick way to check that is: ``` ((diff[d] - 1) * 26) + d > k ```\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        # We calculate the differences\\n        diff = defaultdict(int)\\n        for sc, tc in zip(s, t):\\n            d = (ord(tc) - ord(sc)) % 26\\n            if d == 0: continue\\n            if d > k: return False\\n            diff[d] += 1\\n            if ((diff[d] - 1) * 26) + d > k:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```diff```\n```difference 1```\n```a```\n```b```\n``` ((diff[d] - 1) * 26) + d > k ```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        # We calculate the differences\\n        diff = defaultdict(int)\\n        for sc, tc in zip(s, t):\\n            d = (ord(tc) - ord(sc)) % 26\\n            if d == 0: continue\\n            if d > k: return False\\n            diff[d] += 1\\n            if ((diff[d] - 1) * 26) + d > k:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780012,
                "title": "can-anyone-explain",
                "content": "I didnt understand the second test case\\n\\n```\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n```\\n\\nWhy is the answer false? Shouldnt this be possible in three moves?",
                "solutionTags": [],
                "code": "```\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 782335,
                "title": "python-simple-array-lookup-o-n-time-o-1-space",
                "content": "**Idea:**\\n\\nTest Cases:\\n* Check if length of strings are equal \\n\\nLogic\\n* Check the distance between between the s[i] and t[i] using the ord()\\n* Record the distance in an array which tracks used shifts\\n* Check the array to see if shift has been used\\n* If shift has been used take the number of times it has been used and multiply by 26\\n* If shift > k return False \\n\\n**Tricks**\\n* Use mod 26 when taking the ord() difference between the chars\\n* Example: s[i] = \\'b\\' and t[i] = \\'a\\' which requires 25 shifts\\n* ord(s[i]) - ord(t[i]) = -1\\n* (-1) % 26 = 25 \\n*  Makes logic simpler \\n\\n**Code:**\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        # Check uneven lengths \\n        if len(s) != len(t):\\n            return False \\n        \\n\\t\\t# Track used shifts\\n        shifts = [0 for x in range(1,27)]\\n      \\n        for i in range(len(s)):\\n            \\n\\t\\t\\t# No shift required\\n            if t[i] == s[i]:\\n                continue\\n\\t\\t\\t\\n\\t\\t\\t# Number of shifts calculation\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n\\t\\t\\t\\n\\t\\t\\t# Check if number of shift is permitted \\n            if ((shifts[diff]) *26 + diff) > k:\\n                return False\\n            shifts[diff] += 1\\n\\n        return True\\n```\\n\\nLike if this helped!\\nCheers,\\nArgent",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        # Check uneven lengths \\n        if len(s) != len(t):\\n            return False \\n        \\n\\t\\t# Track used shifts\\n        shifts = [0 for x in range(1,27)]\\n      \\n        for i in range(len(s)):\\n            \\n\\t\\t\\t# No shift required\\n            if t[i] == s[i]:\\n                continue\\n\\t\\t\\t\\n\\t\\t\\t# Number of shifts calculation\\n            diff = (ord(t[i]) - ord(s[i])) % 26\\n\\t\\t\\t\\n\\t\\t\\t# Check if number of shift is permitted \\n            if ((shifts[diff]) *26 + diff) > k:\\n                return False\\n            shifts[diff] += 1\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780269,
                "title": "java-simple-hashmap",
                "content": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int m = s.length(), n = t.length(), prev = 0;\\n        if (m != n) return false;\\n        for (int i = 0; i < m; i++) {\\n            int dist = getDist(s.charAt(i), t.charAt(i)), prevCnt = map.getOrDefault(dist, 0);\\n            if (dist > 0) map.put(dist, prevCnt + 1);\\n            if (prevCnt * 26 + dist > k) return false;  // find next available move\\n        }\\n        return true;\\n    }\\n    \\n    private int getDist(char a, char b) {\\n        int dist = b - a;\\n        return (dist + 26) % 26;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int m = s.length(), n = t.length(), prev = 0;\\n        if (m != n) return false;\\n        for (int i = 0; i < m; i++) {\\n            int dist = getDist(s.charAt(i), t.charAt(i)), prevCnt = map.getOrDefault(dist, 0);\\n            if (dist > 0) map.put(dist, prevCnt + 1);\\n            if (prevCnt * 26 + dist > k) return false;  // find next available move\\n        }\\n        return true;\\n    }\\n    \\n    private int getDist(char a, char b) {\\n        int dist = b - a;\\n        return (dist + 26) % 26;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779955,
                "title": "simple-c-solution-with-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.size() != t.size()) return false;\\n        \\n        int n = s.size();\\n        vector<int> v(n,0);\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i < n;i++){\\n            int x = t[i] - s[i];\\n            if(x < 0) x = 26 + x;   // s[i] > t[i] then we have to roll back\\n            if(x != 0)\\n                v[i] = mp[x]*26 + x;    //if same x comes then we can roll for another 26 times if we have moves\\n            else v[i] = x;\\n            if(v[i] > k) return false;  // if moves are more then limit then return false\\n            mp[x]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.size() != t.size()) return false;\\n        \\n        int n = s.size();\\n        vector<int> v(n,0);\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i < n;i++){\\n            int x = t[i] - s[i];\\n            if(x < 0) x = 26 + x;   // s[i] > t[i] then we have to roll back\\n            if(x != 0)\\n                v[i] = mp[x]*26 + x;    //if same x comes then we can roll for another 26 times if we have moves\\n            else v[i] = x;\\n            if(v[i] > k) return false;  // if moves are more then limit then return false\\n            mp[x]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779906,
                "title": "transform-to-math-question",
                "content": "imagine the first round we can do x steps, x is min(26, k)\\nfor each different char, we can change it to the destination char in the first round, after that, we have to always wait for another 26 times\\n\\nfor example, \"ab\" -> \"cd\"\\n\\n\\'a\\' to \\'c\\' needs 2 steps;\\n\\'b\\' to \\'d\\' needs 2 steps;\\n\\nbut we can only do ONE replacing with 2 steps to make \\'a\\' to \\'c\\'\\nto make \\'b\\' to \\'d\\' happen, we will need to wait for next round, which is 2+26 = 28. \\n\\nso simply check how many cases(C) exist for a N steps operation.\\nif N + (c-1)*26 > K then we can\\'t make it happen. \\n\\n```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false;\\n        if(s == t)\\n            return true;\\n        vector<int> times(26);\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            int ti = (t[i] - s[i] + 26) % 26;\\n            ++times[ti];\\n        }\\n        \\n        for(int i = 1; i < 26; ++i) {\\n            if(i + (times[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false;\\n        if(s == t)\\n            return true;\\n        vector<int> times(26);\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i) {\\n            int ti = (t[i] - s[i] + 26) % 26;\\n            ++times[ti];\\n        }\\n        \\n        for(int i = 1; i < 26; ++i) {\\n            if(i + (times[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189629,
                "title": "simple-c-solution-8-lines",
                "content": "Here we simply calculate the shift required for each character of ```s``` and and store it in an array of size 26. Then check if those many shift are possible or not within the given value of ```k```.\\n* ```ar[i] = x``` implies that there are x characters in ```string s``` that need a shift of i to match the charcters in ```string t```.\\n* Now it is given in the question that each shift can be used only once. \\n* So if two charcters need a shift of 1, only one of them will be allowed.\\n* The next charcter will get a shift of 1 + 26 which makes the efective shift to be 1. \\nEg: lets say ```s = \"aa\"``` and ```t = \"cc\"```\\nThen ```ar[2] = 2```\\nSo two characters need a net shift of 2. So the possible shifts are 2, 28, 54, .....\\nSince we need only two, so 2 and 28 are enough. Therefore our value of k should be atleast 28 .If not then return false immediately.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```s```\n```k```\n```ar[i] = x```\n```string s```\n```string t```\n```s = \"aa\"```\n```t = \"cc\"```\n```ar[2] = 2```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881255,
                "title": "python-3-3-lines-counter-w-example-t-m-93-19",
                "content": "Here\\'s the plan:\\n* We construct a `Counter` to keep track of the shifts.\\n\\n* We check whether `k` is sufficient to accomodate the shifts for each position of like difference. For example, if `c[2] = 3` (that is, three positions each have a difference of 2)  the third char is shifted `2+26+26 = 54`, so it must be that `k >= 54`.\\n* If so, we return `True`; if not `False`.\\n\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n        if len(s) != len(t): return False               # Example: s = \"aacdd\" , t = \"bbcdf\" , k = 30\\n\\n        c = Counter([(ord(t[i]) - ord(s[i])) % 26       # Counter([1,  1,  0,  0,  2]) = {1: 2, 0: 2, 2: 1} \\n                            for i in range(len(s))])    #          |   |   |   |   |\\n                                                        #         a:b a:b c:c d:d d:f \\n\\n        return all((c[i]-1)*26 + i <= k                 #  all( (1-1)*26 + 1 <= 30, (1-1)*26 + 1 <= 30, (2-1)*26 + 1 <= 30)\\n                            for i in c if i)            #  all(True,True,True)\\n                                                        #  return True \\n```\\n[https://leetcode.com/submissions/detail/855147141/](http://)\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n        if len(s) != len(t): return False               # Example: s = \"aacdd\" , t = \"bbcdf\" , k = 30\\n\\n        c = Counter([(ord(t[i]) - ord(s[i])) % 26       # Counter([1,  1,  0,  0,  2]) = {1: 2, 0: 2, 2: 1} \\n                            for i in range(len(s))])    #          |   |   |   |   |\\n                                                        #         a:b a:b c:c d:d d:f \\n\\n        return all((c[i]-1)*26 + i <= k                 #  all( (1-1)*26 + 1 <= 30, (1-1)*26 + 1 <= 30, (2-1)*26 + 1 <= 30)\\n                            for i in c if i)            #  all(True,True,True)\\n                                                        #  return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657022,
                "title": "detailed-explanation-well-coded-92-faster",
                "content": "## IDEA :\\n* First we need to calculate the difference of the conversion. for example conversion from `a to b` will have difference of 1.\\n* Then we hold a dictiomary (hash map) diff to see how many times we want to convert each difference.\\n\\n* For example to go from `\"aa\" to \"bb\"` we want to go difference 1 for 2 times.\\n* This is possible only if we will have k of 27 or above, because to go from a to b we need 1, and each loop starts at 26 (alphabet count).\\n\\n****\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tdic = defaultdict(int)\\n\\t\\t\\tfor a,b in zip(s,t):\\n\\t\\t\\t\\tif a!=b:\\n\\t\\t\\t\\t\\tif ord(b)>ord(a):\\n\\t\\t\\t\\t\\t\\tdiff = ord(b)-ord(a)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = (26-ord(a)+ord(b))\\n\\n\\t\\t\\t\\t\\tn = dic[diff]*26 + diff\\n\\t\\t\\t\\t\\tif n>k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdic[diff]+=1\\n\\n\\t\\t\\treturn True\\n\\n### Explanation :\\n\\n**Dict Storing Difference as key and value as frequency of that shift require to convert all char with same difference to respective char in \\'t\\'.**\\nExample \\n\\'\\'\\'\\n\\n\\ts=abc t=bcd , we require 1 shift three times.So key=1 val=3.\\n\\n\\n**Now for a particular key, we require maximum `26*(val)+diff` number if we want to convert all char with same difference(key) to valid char in \\'t\\'.**\\nExample :\\n\\'\\'\\'\\n\\n\\ts = abc t =bcd we require number 1,27,53 to convert s to t.\\n\\n\\n\\t\\t\\t\\n**Thanks and Upvote if you got any help or like the Idea !!** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA :\\n* First we need to calculate the difference of the conversion. for example conversion from `a to b` will have difference of 1.\\n* Then we hold a dictiomary (hash map) diff to see how many times we want to convert each difference.\\n\\n* For example to go from `\"aa\" to \"bb\"` we want to go difference 1 for 2 times.\\n* This is possible only if we will have k of 27 or above, because to go from a to b we need 1, and each loop starts at 26 (alphabet count).\\n\\n****\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tdic = defaultdict(int)\\n\\t\\t\\tfor a,b in zip(s,t):\\n\\t\\t\\t\\tif a!=b:\\n\\t\\t\\t\\t\\tif ord(b)>ord(a):\\n\\t\\t\\t\\t\\t\\tdiff = ord(b)-ord(a)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = (26-ord(a)+ord(b))\\n\\n\\t\\t\\t\\t\\tn = dic[diff]*26 + diff\\n\\t\\t\\t\\t\\tif n>k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tdic[diff]+=1\\n\\n\\t\\t\\treturn True\\n\\n### Explanation :\\n\\n**Dict Storing Difference as key and value as frequency of that shift require to convert all char with same difference to respective char in \\'t\\'.**\\nExample \\n\\'\\'\\'\\n\\n\\ts=abc t=bcd , we require 1 shift three times.So key=1 val=3.\\n\\n\\n**Now for a particular key, we require maximum `26*(val)+diff` number if we want to convert all char with same difference(key) to valid char in \\'t\\'.**\\nExample :\\n\\'\\'\\'\\n\\n\\ts = abc t =bcd we require number 1,27,53 to convert s to t.\\n\\n\\n\\t\\t\\t\\n**Thanks and Upvote if you got any help or like the Idea !!** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1268156,
                "title": "easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        map<int,int>mp;\\n        int n=s.length(),m=t.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff=int(t[i])-int(s[i]);\\n            if(diff<0)\\n                diff=26-abs(diff);\\n            if(diff>0)\\n                mp[diff]+=1;\\n        }\\n        bool ans=true;\\n        for(auto i:mp)\\n        {\\n            if(k<26*(i.second-1)+i.first)\\n                ans=false;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        map<int,int>mp;\\n        int n=s.length(),m=t.length();\\n        if(n!=m)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff=int(t[i])-int(s[i]);\\n            if(diff<0)\\n                diff=26-abs(diff);\\n            if(diff>0)\\n                mp[diff]+=1;\\n        }\\n        bool ans=true;\\n        for(auto i:mp)\\n        {\\n            if(k<26*(i.second-1)+i.first)\\n                ans=false;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779987,
                "title": "java-hashmap-o-n",
                "content": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        Map<Integer,Integer> seen=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            int d=(t.charAt(i)-\\'a\\')-(s.charAt(i)-\\'a\\');\\n            if(d==0)\\n                continue;\\n            if(d<0)\\n                d+=26;\\n            if(d>k)\\n                return false;\\n            if(seen.containsKey(d)){\\n                int lastShift=seen.get(d);\\n                if(26+lastShift<=k)\\n                    seen.put(d,lastShift+26);\\n                else\\n                    return false;\\n            } else\\n                seen.put(d,d);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        Map<Integer,Integer> seen=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            int d=(t.charAt(i)-\\'a\\')-(s.charAt(i)-\\'a\\');\\n            if(d==0)\\n                continue;\\n            if(d<0)\\n                d+=26;\\n            if(d>k)\\n                return false;\\n            if(seen.containsKey(d)){\\n                int lastShift=seen.get(d);\\n                if(26+lastShift<=k)\\n                    seen.put(d,lastShift+26);\\n                else\\n                    return false;\\n            } else\\n                seen.put(d,d);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779911,
                "title": "simple-c-o-n-solution-no-hashmap-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        // Array to store the next usable difference \\n        long long int diffArr[27] = { 0 };\\n\\n        char sChar, tChar;\\n        int diff;\\n        for (int i=0; i<s.length(); i++) {\\n            sChar = s[i];\\n            tChar = t[i];\\n            if (sChar == tChar) {\\n                continue;\\n            }\\n            \\n            diff = (tChar - sChar);\\n            diff += ((diff < 0) ? 26 : 0); // If we go from \\'z\\' to \\'a\\', diff is negative, so we add 26 to make it positive (circular)\\n\\n            if (diff + diffArr[diff] > k) {\\n                return false;\\n            }\\n            \\n            // Increase the diff value by 26 if we happen to find it again with some other character\\n            diffArr[diff] += 26;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\n        // Array to store the next usable difference \\n        long long int diffArr[27] = { 0 };\\n\\n        char sChar, tChar;\\n        int diff;\\n        for (int i=0; i<s.length(); i++) {\\n            sChar = s[i];\\n            tChar = t[i];\\n            if (sChar == tChar) {\\n                continue;\\n            }\\n            \\n            diff = (tChar - sChar);\\n            diff += ((diff < 0) ? 26 : 0); // If we go from \\'z\\' to \\'a\\', diff is negative, so we add 26 to make it positive (circular)\\n\\n            if (diff + diffArr[diff] > k) {\\n                return false;\\n            }\\n            \\n            // Increase the diff value by 26 if we happen to find it again with some other character\\n            diffArr[diff] += 26;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286937,
                "title": "java-string-greedy-10ms-beats-90-t-c-o-n-s-c-o-n",
                "content": "\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int len1 = s.length(), len2 = t.length();\\n        if(len1 != len2)\\n            return false;\\n        \\n        int[] next = new int[26];\\n        \\n        for(int i=0;i<26;i++)\\n            next[i] = i;\\n        \\n        for(int i = 0 ; i < len1 ; i++){\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            if(diff == 0)\\n                continue;\\n            \\n            if(diff < 0)\\n                diff += 26;\\n            \\n            int move = next[diff];\\n            next[diff] += 26;\\n            \\n            if(move > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int len1 = s.length(), len2 = t.length();\\n        if(len1 != len2)\\n            return false;\\n        \\n        int[] next = new int[26];\\n        \\n        for(int i=0;i<26;i++)\\n            next[i] = i;\\n        \\n        for(int i = 0 ; i < len1 ; i++){\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            if(diff == 0)\\n                continue;\\n            \\n            if(diff < 0)\\n                diff += 26;\\n            \\n            int move = next[diff];\\n            next[diff] += 26;\\n            \\n            if(move > k)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 981234,
                "title": "python-3-beats-91-with-explanation",
                "content": "For example, we want to transform \"ad\" to \"be\".\\nApparently, we can shift \"a\" by 1 move, to \"b\", however, in order to shift \"d\" to \"e\", we can no longer shift \"d\" by 1 move since we have already done it before, so we have to find the next smallest number which residue is 1, which is 27. So once we shift \"a\" by 1 move, we can wait for 25 following steps with 0 move, then, we shift d by 27 moves to get \"e\"\\nTherefore it is pretty clear that we just need to sort the characters pairs in s and t, by the residue of ord different after mod 26.\\nSo the dictionary for our example is d={1:2}, which means the char pairs have 2 residue of 1. Then the smallest K should be 1+(2-1)* 26.\\n\\nDo not forget to pick the alphabitically largest character if multiple characters have same values.\\n\\n```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t):\\n            return False\\n        d=collections.defaultdict(int)\\n        for x,y in zip(s,t):\\n            d[(ord(y)-ord(x))%26]+=1\\n        ans=sorted(d.items(), key=lambda x: [-x[1],-x[0]])[0]        \\n        return True if ans[0]==0 else ans[0]+26*(ans[1]-1)<=k\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t):\\n            return False\\n        d=collections.defaultdict(int)\\n        for x,y in zip(s,t):\\n            d[(ord(y)-ord(x))%26]+=1\\n        ans=sorted(d.items(), key=lambda x: [-x[1],-x[0]])[0]        \\n        return True if ans[0]==0 else ans[0]+26*(ans[1]-1)<=k\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 895168,
                "title": "python-sol-explained-in-great-detail",
                "content": "\\tclass Solution(object):\\n\\t\\tdef canConvertString(self, s, t, k):\\n\\t\\t\\tif s==t:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tshift_require_dict = collections.defaultdict(int) \\n\\t\\t\\t\\'\\'\\'Dict Storing Difference/shift as key and value as frequency \\n\\t\\t\\tof that shift require to convert all char with same shift/difference \\n\\t\\t\\tto respective char in \\'t\\'. Example s=abc t=bcd , we require 1 shift three times.So key=1 val=3\\'\\'\\'\\n\\t\\t\\tfor i,j in zip(s,t):\\n\\t\\t\\t\\tif i!=j:\\n\\t\\t\\t\\t\\tif j<i:\\n\\t\\t\\t\\t\\t\\ta = (122-ord(i)) + (ord(j)-96) # if char[s] > char[t], then we may go till z and again come char[t]\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] +=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = ord(j)-ord(i)\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] += 1\\n\\n\\t\\'\\'\\'Now for a particular key, we require maximum\\n\\t26*(val-1)+key number if we want to convert all \\n\\tchar with same shift(key) to valid char in \\'t\\'.\\n\\tExample s = abc t =bcd we require number 1,27,53 to convert s to t.\\'\\'\\'\\n\\n\\t# So MAX_Val required will be max_freq with largest shift\\n\\t\\t\\tmax_f = shift_require_dict[max(shift_require_dict,key=shift_require_dict.get)]\\n\\t\\t\\tmax_diff =0\\n\\t\\t\\tfor key,val in shift_require_dict.items():\\n\\t\\t\\t\\tif val ==max_f:\\n\\t\\t\\t\\t\\tmax_diff = max(max_diff,key)\\n\\n\\t\\t\\tif (26*(max_f-1) + max_diff) <=k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef canConvertString(self, s, t, k):\\n\\t\\t\\tif s==t:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif len(s)!=len(t):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tshift_require_dict = collections.defaultdict(int) \\n\\t\\t\\t\\'\\'\\'Dict Storing Difference/shift as key and value as frequency \\n\\t\\t\\tof that shift require to convert all char with same shift/difference \\n\\t\\t\\tto respective char in \\'t\\'. Example s=abc t=bcd , we require 1 shift three times.So key=1 val=3\\'\\'\\'\\n\\t\\t\\tfor i,j in zip(s,t):\\n\\t\\t\\t\\tif i!=j:\\n\\t\\t\\t\\t\\tif j<i:\\n\\t\\t\\t\\t\\t\\ta = (122-ord(i)) + (ord(j)-96) # if char[s] > char[t], then we may go till z and again come char[t]\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] +=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ta = ord(j)-ord(i)\\n\\t\\t\\t\\t\\t\\tshift_require_dict[a] += 1\\n\\n\\t\\'\\'\\'Now for a particular key, we require maximum\\n\\t26*(val-1)+key number if we want to convert all \\n\\tchar with same shift(key) to valid char in \\'t\\'.\\n\\tExample s = abc t =bcd we require number 1,27,53 to convert s to t.\\'\\'\\'\\n\\n\\t# So MAX_Val required will be max_freq with largest shift\\n\\t\\t\\tmax_f = shift_require_dict[max(shift_require_dict,key=shift_require_dict.get)]\\n\\t\\t\\tmax_diff =0\\n\\t\\t\\tfor key,val in shift_require_dict.items():\\n\\t\\t\\t\\tif val ==max_f:\\n\\t\\t\\t\\t\\tmax_diff = max(max_diff,key)\\n\\n\\t\\t\\tif (26*(max_f-1) + max_diff) <=k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 858863,
                "title": "python-breifly-explained-remember-the-recent-longest-shift-o-n",
                "content": "Each character at index j in both source and target string have some expected shifts. For example,\\n```\\ns[j] = \"a\"\\nt[j] = \"e\" \\n```\\nAlgorithm:\\n1.  Expected shifts are ```(ord(\"e\") - ord(\"a\"))%26```, since alphabets arranged in cycle. Here, ```shifts = 4```\\n\\n2.  Maintain a hashmap for used i number of shifts. Ask hashmap whether 4 shifts are available. If yes update the ```eyesUsed[4] = 4```\\n\\n3.  if any other pair of chars in s and t also asking for 4 shifts which are occupied, then previously saved hashmap[4] can lead us where to look next, which is  ```26 + eyesUsed[4]```  because next valid way to reach target char is to shift through all alphabets once.\\n\\n4.  Repeat **step 2** and **step3** untill vacant shifts found if number of shifts exceeded the K value then abort the loop and return False\\n\\n5.  After successfully shifting all the characters return True\\n\\n```\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\tif len(s) != len(t): return False\\n\\n\\t\\t\\teyesUsed = dict()\\n\\t\\t\\tfor ch1,ch2 in zip(map(ord,s),map(ord,t)):\\n\\n\\t\\t\\t\\tif ch1 == ch2: continue\\n\\t\\t\\t\\tshift = (ch2 - ch1)%26\\n\\n\\t\\t\\t\\tinitShift = shift\\n\\t\\t\\t\\twhile 1 <= shift <= k:\\n\\n\\t\\t\\t\\t\\tif shift not in eyesUsed:\\n\\t\\t\\t\\t\\t\\teyesUsed[initShift] = shift\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tshift = eyesUsed[initShift]+26\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n        \\n```\\n\\n**Base cases:** \\n* ```If source s[i]  == target t[j] then skip shifting```\\n* ```if lengths of source != target then return False```\\n\\nUnderStood? Any Improvements?",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ns[j] = \"a\"\\nt[j] = \"e\" \\n```\n```(ord(\"e\") - ord(\"a\"))%26```\n```shifts = 4```\n```eyesUsed[4] = 4```\n```26 + eyesUsed[4]```\n```\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\n\\t\\tif len(s) != len(t): return False\\n\\n\\t\\t\\teyesUsed = dict()\\n\\t\\t\\tfor ch1,ch2 in zip(map(ord,s),map(ord,t)):\\n\\n\\t\\t\\t\\tif ch1 == ch2: continue\\n\\t\\t\\t\\tshift = (ch2 - ch1)%26\\n\\n\\t\\t\\t\\tinitShift = shift\\n\\t\\t\\t\\twhile 1 <= shift <= k:\\n\\n\\t\\t\\t\\t\\tif shift not in eyesUsed:\\n\\t\\t\\t\\t\\t\\teyesUsed[initShift] = shift\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\tshift = eyesUsed[initShift]+26\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True\\n        \\n```\n```If source s[i]  == target t[j] then skip shifting```\n```if lengths of source != target then return False```",
                "codeTag": "Python3"
            },
            {
                "id": 836489,
                "title": "java-o-n-method",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] shiftCounts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) {\\n                continue;\\n            }\\n            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));\\n            int val = shiftCounts[shift] * 26 + shift;\\n            if (val > k) {\\n                return false;\\n            }\\n            shiftCounts[shift]++;\\n        }\\n        return true;\\n    }\\n    \\n    private final int getNumOfShifts(char a, char b) {\\n        return (b - a + 26) % 26;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] shiftCounts = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == t.charAt(i)) {\\n                continue;\\n            }\\n            int shift = getNumOfShifts(s.charAt(i), t.charAt(i));\\n            int val = shiftCounts[shift] * 26 + shift;\\n            if (val > k) {\\n                return false;\\n            }\\n            shiftCounts[shift]++;\\n        }\\n        return true;\\n    }\\n    \\n    private final int getNumOfShifts(char a, char b) {\\n        return (b - a + 26) % 26;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781884,
                "title": "c-o-n-beat-100",
                "content": "Got TLE using set, so i use a int array to store the numbers of move. 100% time\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int used[26] = {0};\\n        int diff = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(t[i] - s[i] > 0) diff = t[i] - s[i];\\n            else if(t[i] - s[i] < 0) diff = 26 - s[i] + t[i];\\n            else continue;\\n            \\n            if( (used[diff]) * 26 + diff > k) return false;\\n            used[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int used[26] = {0};\\n        int diff = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(t[i] - s[i] > 0) diff = t[i] - s[i];\\n            else if(t[i] - s[i] < 0) diff = 26 - s[i] + t[i];\\n            else continue;\\n            \\n            if( (used[diff]) * 26 + diff > k) return false;\\n            used[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780437,
                "title": "python-o-n-solution-with-explanation",
                "content": "**Technique:**\\n\\n1. Create a `diffArr` (Difference Array) which will store the ascii difference between the characters in the string `t` & `s`. Since we can only increment & not reduce, for all the negative values(When we sustract `a` with `z`) we have to subtract it with 26 & store the difference. \\n2. Next step is to crate a set (`diffSet`) to keep track of the shifts which we have already used between `1-k`. \\n3. As we iterate through the `diffArr` we have to check if we already have the `ith` step in set, if not we\\'ll add it to the set since that is the first time we\\'re using it. And if it is already present - here\\'s where the real logic is. We have to keep incrementing the number of shifts by 26 as that would result in the same character. We have to increment it until we get the number of moves which have not been used until now (which is what the while loop within else statement is responsible for). \\n\\ni.e., difference 1 can take values 1, 27, 53, 79... & so on\\n\\nMeanwhile while moving itself, we can check if the number of shifts is going to exceed k or not, if yes return False\\n\\n**TLE Issue Code**\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        diffArr = []\\n        if s == t:\\n            return True\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff < 0:\\n                diff = 26+diff\\n            diffArr.append(diff)\\n        diffSet = set()\\n        for i in diffArr:\\n            if i == 0:\\n                continue\\n            if i not in diffSet:\\n                diffSet.add(i)\\n            else:\\n                while i in diffSet:\\n                    if i > k:\\n                        return False\\n                    i += 26\\n                diffSet.add(i)\\n        return max(diffSet) <= k\\n```\\n\\n**Whats the problem with this approach?**\\n\\nSince we\\'re having a while loop which starts from i (which is less than 26) and loop until we find the next number of shifts for every value in `diffArr` we will end up in ***`TLE`***\\n\\n**How to solve this?**\\n\\nHere\\'s where memoization comes into picture. Instead of looping through by incrementing values by 26, we can store what is the value for the original `i` which will store the most recently used value for `i`\\n\\nFor eg., \\nif i = 1, we can have the number of shifts as 1,27,53,79... and so on.\\nInstead of calculating this from 1 upto... the limit k or next free value, mem[1] will store the most recently used value which will fit it. \\n\\nFor 1st iteration\\n```mem[1] = 1```\\n2nd\\n```mem[1] = 27```\\n3rd\\n```mem[1] = 53```\\n& so on\\n\\n**Working code with Single Loop**\\n\\nWe don\\'t have to store and then iterate the `diffArr`, we can perform the memoization & checks while iterating through the strings itself.\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        mem = {}\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff == 0:\\n                continue\\n            if diff < 0:\\n                diff += 26\\n            if diff in mem:\\n                mem[diff] += 26\\n            else:\\n                mem[diff] = diff\\n            if mem[diff] > k:\\n                return False\\n        return True\\n```\\n\\nJust checking for the base conditions if both strings are same, we return `True`. And if the lengths don\\'t match, we return `False`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        diffArr = []\\n        if s == t:\\n            return True\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff < 0:\\n                diff = 26+diff\\n            diffArr.append(diff)\\n        diffSet = set()\\n        for i in diffArr:\\n            if i == 0:\\n                continue\\n            if i not in diffSet:\\n                diffSet.add(i)\\n            else:\\n                while i in diffSet:\\n                    if i > k:\\n                        return False\\n                    i += 26\\n                diffSet.add(i)\\n        return max(diffSet) <= k\\n```\n```mem[1] = 1```\n```mem[1] = 27```\n```mem[1] = 53```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        n = len(s)\\n        n2 = len(t)\\n        if n != n2:\\n            return False\\n        mem = {}\\n        for i in range(n):\\n            diff = ord(t[i])-ord(s[i])\\n            if diff == 0:\\n                continue\\n            if diff < 0:\\n                diff += 26\\n            if diff in mem:\\n                mem[diff] += 26\\n            else:\\n                mem[diff] = diff\\n            if mem[diff] > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780066,
                "title": "java-6-lines-o-n-time-o-1-space",
                "content": "Just compute required swaps for each position modulo 26, and confirm that k is large enough to satisfy all required swappings.\\n\\n```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) counts[Math.floorMod(t.charAt(i) - s.charAt(i), 26)]++;\\n        for (int i = 1; i < 26; i++)\\n            if (counts[i] > 0 && i + (counts[i]-1)*26 > k) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        int[] counts = new int[26];\\n        for (int i = 0; i < s.length(); i++) counts[Math.floorMod(t.charAt(i) - s.charAt(i), 26)]++;\\n        for (int i = 1; i < 26; i++)\\n            if (counts[i] > 0 && i + (counts[i]-1)*26 > k) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3039833,
                "title": "can-convert-string-in-k-moves",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, it checks if the length of two strings are not equal, it returns false\\nIt calculates the number of shift required for each character to convert the first string to the second one.\\nThen it iterates over the number of shift required and for each shift, it checks if the number of shift * 26 + the current shift greater than k, if so it returns false.\\nIf all the indexes can be shifted in k moves or less, it returns true.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n) where n is the length of the string.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is O(1) since we are using a fixed size array of size 26 to store the shift count.\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        // Edge case: if the length of the two strings are not equal, return false\\n        if (s.length() != t.length()) return false;\\n        int n = s.length();\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            if (diff[i] == 0) continue;\\n            if (count[diff[i]] * 26 + diff[i] > k) return false;\\n            count[diff[i]]++;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        // Edge case: if the length of the two strings are not equal, return false\\n        if (s.length() != t.length()) return false;\\n        int n = s.length();\\n        int[] diff = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            diff[i] = (t.charAt(i) - s.charAt(i) + 26) % 26;\\n        }\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            if (diff[i] == 0) continue;\\n            if (count[diff[i]] * 26 + diff[i] > k) return false;\\n            count[diff[i]]++;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963839,
                "title": "python3-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666958,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool canConvertString(string s, string t, int k) {\\n    if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915299,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int round = k / 26;\\n        int remaining = k % 26;\\n        int[] record = new int[26];\\n        for (int i = 0; i < 26; i++) {\\n            if (i < remaining) {\\n                record[i] += 1;\\n            }\\n            record[i] += round;\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = t.charAt(i);\\n            if (c1 == c2) continue;\\n            int index = (c2 - c1 + 26) % 26 - 1;\\n            if (record[index] > 0) {\\n                record[index] -= 1;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1409548,
                "title": "c-easy",
                "content": "```\\n\\n```public:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        vector<vector<int>>v(26);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff<0)\\n            {\\n                diff=diff+26;\\n            }\\n            if(diff!=0)\\n            {\\n                if(v[diff].size()==0)\\n                {\\n                    v[diff].push_back(diff);\\n                }\\n                else\\n                {\\n                    v[diff].push_back(v[diff].back()+26);\\n                    diff=v[diff].back();\\n                }\\n            }\\n            if(diff>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315618,
                "title": "first-pass-with-len-s-second-pass-with-len-26-100-speed",
                "content": "Runtime: 260 ms, faster than 100.00% of Python3 online submissions for Can Convert String in K Moves.\\nMemory Usage: 15.7 MB, less than 16.67% of Python3 online submissions for Can Convert String in K Moves.\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        shifts = [0] * 26\\n        for a, b in zip(s, t):\\n            shifts[(ord(b) - ord(a)) % 26] += 1\\n        for j, n in enumerate(shifts):\\n            if j > 0 and n > 0 and j + (n - 1) * 26 > k:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        shifts = [0] * 26\\n        for a, b in zip(s, t):\\n            shifts[(ord(b) - ord(a)) % 26] += 1\\n        for j, n in enumerate(shifts):\\n            if j > 0 and n > 0 and j + (n - 1) * 26 > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092769,
                "title": "c-easy-solution",
                "content": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[i]-s[i]<0)\\n                mp[t[i]-s[i]+26]++;\\n            else if(t[i]-s[i]>0)\\n                mp[t[i]-s[i]]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second-1)*26+it->first>k)\\n                return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(t[i]-s[i]<0)\\n                mp[t[i]-s[i]+26]++;\\n            else if(t[i]-s[i]>0)\\n                mp[t[i]-s[i]]++;\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second-1)*26+it->first>k)\\n                return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1059413,
                "title": "java-faster-than-100-o-n-time-complexity",
                "content": "\\n\\nclass Solution {\\n#####  public boolean canConvertString(String s, String t, int k) {\\n        char[] sref=s.toCharArray();            //Converting string to char Array\\n        char[] tref=t.toCharArray();            //Converting string to char Array\\n         int len=sref.length;\\n        if(len!=tref.length) return false;     //Base case\\n        int[] count=new int[26];                //Maximum difference we can get is 26\\n\\t\\tfor(int i=0;i<len;i++){\\n            if(tref[i]==sref[i]) continue;\\n            int temp=tref[i]-sref[i];\\n            if(temp<0) temp=temp+26;\\n            count[temp]++;                                  // Increment the count\\n            temp=temp+(26*(count[temp]-1));                 //value which it needs\\n            if(temp>k) return false;                         //compare with the k value\\n        }\\n        return true;\\n       \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n#####  public boolean canConvertString(String s, String t, int k) {\\n        char[] sref=s.toCharArray();            //Converting string to char Array\\n        char[] tref=t.toCharArray();            //Converting string to char Array\\n         int len=sref.length;\\n        if(len!=tref.length) return false;     //Base case\\n        int[] count=new int[26];                //Maximum difference we can get is 26\\n\\t\\tfor(int i=0;i<len;i++){\\n            if(tref[i]==sref[i]) continue;\\n            int temp=tref[i]-sref[i];\\n            if(temp<0) temp=temp+26;\\n            count[temp]++;                                  // Increment the count\\n            temp=temp+(26*(count[temp]-1));                 //value which it needs\\n            if(temp>k) return false;                         //compare with the k value\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 988808,
                "title": "c-60-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(const string& s, const string& t, int k) {\\n        \\n        if(s.size()!=t.size()) return false;\\n        \\n        int shift=0;\\n        vector<int> v(26);\\n        for(int i=0; i<s.size(); ++i) {\\n            if(s[i]!=t[i]) {\\n                shift=s[i]<t[i]?t[i]-s[i]:t[i]-s[i]+26;\\n                shift+=26*v[shift]++;\\n                if(k-shift<0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(const string& s, const string& t, int k) {\\n        \\n        if(s.size()!=t.size()) return false;\\n        \\n        int shift=0;\\n        vector<int> v(26);\\n        for(int i=0; i<s.size(); ++i) {\\n            if(s[i]!=t[i]) {\\n                shift=s[i]<t[i]?t[i]-s[i]:t[i]-s[i]+26;\\n                shift+=26*v[shift]++;\\n                if(k-shift<0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888012,
                "title": "python3-o-n-solution-beats-99",
                "content": "```py\\nimport collections\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        # check lengths\\n        n1 = len(s)\\n        n2 = len(t)\\n        if n1 != n2:\\n            return False\\n        n = n1\\n        \\n        # find diffArray\\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\\n       \\n        # frequency of difference\\n        cda = collections.Counter(diffArray)\\n        \\n        # delete 0\\n        del cda[0]\\n        \\n        minK = 0\\n        if len(cda) > 0 :\\n            key = max([(i[1], i[0])for i in cda.items()])\\n            minK = (key[0] - 1) *26 + key[1]\\n        \\n        return k >= minK\\n```",
                "solutionTags": [],
                "code": "```py\\nimport collections\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        # check lengths\\n        n1 = len(s)\\n        n2 = len(t)\\n        if n1 != n2:\\n            return False\\n        n = n1\\n        \\n        # find diffArray\\n        diffArray = [(ord(t[i])-ord(s[i]))%26 for i in range(n)]\\n       \\n        # frequency of difference\\n        cda = collections.Counter(diffArray)\\n        \\n        # delete 0\\n        del cda[0]\\n        \\n        minK = 0\\n        if len(cda) > 0 :\\n            key = max([(i[1], i[0])for i in cda.items()])\\n            minK = (key[0] - 1) *26 + key[1]\\n        \\n        return k >= minK\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887066,
                "title": "python3-o-n-solution-can-convert-string-in-k-moves",
                "content": "Find the largest character among those who have the highest frequency. The min steps required is the `(freq - 1) * 26 + ord(char)`.\\n\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\\n        maxf = [-1, -1]\\n        for c, f in distance.items():\\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\\n                maxf[0] = c\\n                maxf[1] = f\\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        distance = Counter((ord(b) - ord(a)) % 26 for a, b in zip(s, t) if a != b)\\n        maxf = [-1, -1]\\n        for c, f in distance.items():\\n            if f > maxf[1] or f == maxf[1] and c > maxf[0]:\\n                maxf[0] = c\\n                maxf[1] = f\\n        return not distance or ((maxf[1] - 1) * 26 + maxf[0]) <= k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881844,
                "title": "c-99-faster-simple-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        vector<int> changes(26, 0);\\n        for(int i=0;i<s.size();i++){\\n            if(t[i]!=s[i])\\n            changes[ (t[i]-s[i]+26)%26]++;\\n        }\\n        \\n        for(int i=1; i<changes.size(); i++){\\n            int diff = i + (26 * (changes[i]-1));\\n            if(diff > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        vector<int> changes(26, 0);\\n        for(int i=0;i<s.size();i++){\\n            if(t[i]!=s[i])\\n            changes[ (t[i]-s[i]+26)%26]++;\\n        }\\n        \\n        for(int i=1; i<changes.size(); i++){\\n            int diff = i + (26 * (changes[i]-1));\\n            if(diff > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822842,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) return false;\\n        vector<int> vi(27, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (t[i] > s[i]) vi[t[i] - s[i]]++;\\n            else vi[t[i] - s[i] + 26]++;\\n        }\\n        for (int i = 1; i < 26; ++i) {\\n            if (i + (vi[i] - 1) * 26 > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length()) return false;\\n        vector<int> vi(27, 0);\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (t[i] > s[i]) vi[t[i] - s[i]]++;\\n            else vi[t[i] - s[i] + 26]++;\\n        }\\n        for (int i = 1; i < 26; ++i) {\\n            if (i + (vi[i] - 1) * 26 > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814681,
                "title": "very-eazy-and-clear-python-3-solution-o-n",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n\\t\\t# checking edge cases\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return True\\n        \\n\\t\\t\\n        s = list(s)\\n        t = list(t)\\n        \\n        used = {} # creating dictionary or ditances which were used\\n        for i in range(len(s)):\\n            if s[i] != t[i]:  # if these letter are the same we don\\'t care about them\\n                diff = (ord(t[i]) - ord(s[i]))%26  \\n\\n                if diff > k:\\n                    return False\\n                \\n                if diff not in used:\\n                    used[diff] = 1    \\n                else:\\n                    if diff + 26*used[diff] <= k:  # we can wrap around adding 26 steps\\n                        used[diff] += 1\\n                    else:\\n                        return False   # if we don\\'t have what we need \\n        \\n        return True   # we went through strings and everything is OK\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n\\t\\t# checking edge cases\\n        if len(s) != len(t):\\n            return False\\n        if s == t:\\n            return True\\n        \\n\\t\\t\\n        s = list(s)\\n        t = list(t)\\n        \\n        used = {} # creating dictionary or ditances which were used\\n        for i in range(len(s)):\\n            if s[i] != t[i]:  # if these letter are the same we don\\'t care about them\\n                diff = (ord(t[i]) - ord(s[i]))%26  \\n\\n                if diff > k:\\n                    return False\\n                \\n                if diff not in used:\\n                    used[diff] = 1    \\n                else:\\n                    if diff + 26*used[diff] <= k:  # we can wrap around adding 26 steps\\n                        used[diff] += 1\\n                    else:\\n                        return False   # if we don\\'t have what we need \\n        \\n        return True   # we went through strings and everything is OK\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 800729,
                "title": "java-hashmap-solution",
                "content": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            int d = getOp(s.charAt(i),t.charAt(i));\\n            if(d == 0) continue;\\n            int op = map.getOrDefault(d,0)*26 + d;\\n            if(op > k) return false;\\n            map.put(d,map.getOrDefault(d,0) + 1);\\n        }\\n        return true;\\n    }\\n    public int getOp(char in,char out){\\n        if(in <= out){\\n            return out - in;\\n        }else{\\n            return (\\'z\\' - in + (out - \\'a\\' + 1));\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0;i < s.length();i++){\\n            int d = getOp(s.charAt(i),t.charAt(i));\\n            if(d == 0) continue;\\n            int op = map.getOrDefault(d,0)*26 + d;\\n            if(op > k) return false;\\n            map.put(d,map.getOrDefault(d,0) + 1);\\n        }\\n        return true;\\n    }\\n    public int getOp(char in,char out){\\n        if(in <= out){\\n            return out - in;\\n        }else{\\n            return (\\'z\\' - in + (out - \\'a\\' + 1));\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 800282,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        unordered_map<int,int>mp;\\n        int left=k%26;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==t[i]) continue;\\n            int req;\\n            if(s[i]<t[i]){\\n                req=t[i]-s[i];\\n            }else{\\n                req=t[i]-\\'a\\'+(\\'z\\'-s[i])+1;\\n            }\\n            if(req>k) return false;\\n            mp[req]++;\\n            int max=k/26;\\n            if(req<=left) max++;\\n            if(mp[req]>max) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        unordered_map<int,int>mp;\\n        int left=k%26;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==t[i]) continue;\\n            int req;\\n            if(s[i]<t[i]){\\n                req=t[i]-s[i];\\n            }else{\\n                req=t[i]-\\'a\\'+(\\'z\\'-s[i])+1;\\n            }\\n            if(req>k) return false;\\n            mp[req]++;\\n            int max=k/26;\\n            if(req<=left) max++;\\n            if(mp[req]>max) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793074,
                "title": "simple-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length())   return false;\\n        map<int, int> vmap;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != t[i]) {\\n                int diff;\\n                if (t[i] > s[i]) diff = t[i] - s[i];\\n                else diff = t[i] - s[i] + 26;\\n                vmap[diff]++;\\n            }\\n        }\\n        if (vmap.empty())   return true;\\n        for (map<int, int> :: iterator it = vmap.begin(); it != vmap.end(); it++) {\\n            \\n            if (((it->second - 1) * 26) + it->first > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.length() != t.length())   return false;\\n        map<int, int> vmap;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] != t[i]) {\\n                int diff;\\n                if (t[i] > s[i]) diff = t[i] - s[i];\\n                else diff = t[i] - s[i] + 26;\\n                vmap[diff]++;\\n            }\\n        }\\n        if (vmap.empty())   return true;\\n        for (map<int, int> :: iterator it = vmap.begin(); it != vmap.end(); it++) {\\n            \\n            if (((it->second - 1) * 26) + it->first > k) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784683,
                "title": "python-3-explained",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"\"\"\\n        This program determines whether string can be converted\\n        to string t within k moves.\\n\\n        :param s: string to be converted\\n        :type s: str\\n        :param t: target string\\n        :type t: str\\n        :param k: maximum number of moves allowed\\n        :type k: int\\n        :return: True if conversion possible within k moves,\\n                 else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Case:\\n        - If strings s and t are different lengths, return False.\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n\\n        \"\"\"\\n        Determine whether conversion from s to t is possible\\n        within k moves:\\n        - The shift map (shift_map) maps a shift count to the\\n          maximum number of moves needed to complete all moves\\n          with this shift count. If there are multiple moves\\n          with the same shift count, the first shift is executed\\n          at move \"shift count\". The second shift is executed 26\\n          moves, the third one 26 moves after the second, and so\\n          on.\\n        - If the maximum number of moves for a shift count exceeds\\n          k, return False.\\n        - If the analysis of strings s and t is completed without\\n          exceeding k moves, return True.\\n        \"\"\"\\n        shift_map = {}\\n        for j, s_chr in enumerate(s):\\n            if s_chr != t[j]:\\n                shift = ord(t[j]) - ord(s_chr)\\n                if shift < 0:\\n                    shift += 26\\n                if shift:\\n                    if shift in shift_map:\\n                        shift_map[shift] += 26\\n                    else:\\n                        shift_map[shift] = shift\\n                    if shift_map[shift] > k:\\n                        return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"\"\"\\n        This program determines whether string can be converted\\n        to string t within k moves.\\n\\n        :param s: string to be converted\\n        :type s: str\\n        :param t: target string\\n        :type t: str\\n        :param k: maximum number of moves allowed\\n        :type k: int\\n        :return: True if conversion possible within k moves,\\n                 else False\\n        :rtype: bool\\n        \"\"\"\\n\\n        \"\"\"\\n        Base Case:\\n        - If strings s and t are different lengths, return False.\\n        \"\"\"\\n        if len(s) != len(t):\\n            return False\\n\\n        \"\"\"\\n        Determine whether conversion from s to t is possible\\n        within k moves:\\n        - The shift map (shift_map) maps a shift count to the\\n          maximum number of moves needed to complete all moves\\n          with this shift count. If there are multiple moves\\n          with the same shift count, the first shift is executed\\n          at move \"shift count\". The second shift is executed 26\\n          moves, the third one 26 moves after the second, and so\\n          on.\\n        - If the maximum number of moves for a shift count exceeds\\n          k, return False.\\n        - If the analysis of strings s and t is completed without\\n          exceeding k moves, return True.\\n        \"\"\"\\n        shift_map = {}\\n        for j, s_chr in enumerate(s):\\n            if s_chr != t[j]:\\n                shift = ord(t[j]) - ord(s_chr)\\n                if shift < 0:\\n                    shift += 26\\n                if shift:\\n                    if shift in shift_map:\\n                        shift_map[shift] += 26\\n                    else:\\n                        shift_map[shift] = shift\\n                    if shift_map[shift] > k:\\n                        return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782490,
                "title": "java-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        List<Integer> li=new ArrayList<>();\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int diff=t.charAt(i)-s.charAt(i);\\n                // System.out.println(t.charAt(i)+\" \"+diff+\" \"+s.charAt(i));\\n                if(diff<0){\\n                    diff=diff+26;\\n                }\\n                int a=diff;\\n                int v=0;\\n                if(li.contains(diff)){\\n                    v=map.get(a);\\n                    diff=v+26;\\n                }\\n                map.put(a,diff);\\n                if(k>=diff){\\n                \\n                    li.add(diff);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 781657,
                "title": "java-simple-o-n-time-constant-space-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int[] arr=new int[26];\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=get(s.charAt(i),t.charAt(i));\\n            if(a!=0)\\n            {\\n                arr[a]++;\\n                a=(arr[a]-1)*26+a;\\n            }\\n            if(a>k)return false;\\n        }\\n        return true;\\n    }\\n    public int get(char a,char b)\\n    {   if(a==b)return 0;\\n        if(b>a)return b-a;\\n        return b+26-a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int[] arr=new int[26];\\n        if(s.length()!=t.length())\\n        {\\n            return false;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int a=get(s.charAt(i),t.charAt(i));\\n            if(a!=0)\\n            {\\n                arr[a]++;\\n                a=(arr[a]-1)*26+a;\\n            }\\n            if(a>k)return false;\\n        }\\n        return true;\\n    }\\n    public int get(char a,char b)\\n    {   if(a==b)return 0;\\n        if(b>a)return b-a;\\n        return b+26-a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780785,
                "title": "easy-c-solution-using-hashmap-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<long long int,long long int>mp;\\n        vector<long long int>ans;\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\t\\t\\t\\t if(s[i]!=t[i])\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t  long long int req = s[i]<t[i] ? t[i]-s[i] : 26+t[i]-s[i];\\n\\t\\t\\t\\t  if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  if(mp.find(req)!=mp.end()) {\\n\\t\\t\\t\\t\\t\\t   mp[req]+=26;\\n\\t\\t\\t\\t\\t\\t   if(mp[req]>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[req]=req;\\n\\t\\t\\t\\t\\t\\t\\t   if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<long long int,long long int>mp;\\n        vector<long long int>ans;\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\t\\t\\t\\t if(s[i]!=t[i])\\n\\t\\t\\t\\t {\\n\\t\\t\\t\\t  long long int req = s[i]<t[i] ? t[i]-s[i] : 26+t[i]-s[i];\\n\\t\\t\\t\\t  if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  if(mp.find(req)!=mp.end()) {\\n\\t\\t\\t\\t\\t\\t   mp[req]+=26;\\n\\t\\t\\t\\t\\t\\t   if(mp[req]>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t\\t\\t  else{\\n\\t\\t\\t\\t\\t\\t\\t\\tmp[req]=req;\\n\\t\\t\\t\\t\\t\\t\\t   if(req>k)return false;\\n\\t\\t\\t\\t\\t\\t  }\\n\\t\\t\\t\\t }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780454,
                "title": "javascript-python3-c-add-del-needs",
                "content": "**Synopsis:**\\n\\nUse a hash table to track `needs`.  Return `true` if and only if there are no `needs`.  There are three use cases to consider when calculating `needs` by comparing the difference (ie. `k`) between each i-th character\\'s ordinal value in `s` and `t`:\\n\\n* **Case 1:** the difference is 0, then there\\'s no need to perform any rotation, since the characters are the same\\n* **Case 2:** the difference is a positive value `x`, this means that the character `s[i]` occurs *before* the character `t[i]` lexicographically in the english latin alphabet, and so we can safely add 26 onto `x` because when we mod by 26, we end up with the same value, ie `x == (x + 26) % 26`.  (Try plugging in some positive values for `x` if you don\\'t believe me.)  Since adding 26 then mod\\'ing by 26 is a no-op for case 2, one may wonder \"what\\'s the point?\"  The purpose of adding by 26 is for case 3, the \"wrap-around\" case.\\n* **Case 3:** the difference is a negative value, this means that the character `s[i]` occurs *after* the character `t[i]` lexicographically in the english latin alphabet, per the problem statement, when we rotate this character, it \"wraps-around\" upon reaching `z` back to `a`.  So the \"wrap-around\" length is taken into account by adding 26 onto the negative value.  The result is a positive value `y` which is less than 26, and so we can safely mod `y` by 26 because any value less than 26 mod by 26 is that same value, ie. if `0 < y < 26`, then `y == y % 26`\\n\\nIn general, we can think of the difference (ie. `k`) as buckets between 1..25 inclusive which track the count of each i-th character rotation needed to transform `s` to `t` per the rules of the problem statement.\\n\\n---\\n\\n**Screenshare:** https://www.youtube.com/watch?v=xuyvk8ycHFs\\n\\n---\\n\\n**Verbose Solutions:**\\n\\n*Javascript*\\n```\\nlet canConvertString = (s, t, K, need = {}, needs = 0) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let diff = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (diff)\\n            need[diff] = need[diff] ? 1 + need[diff] : 1, ++needs;\\n    }\\n    // \\uD83D\\uDEAB del needs\\n    for (let i = 1; i <= K && needs; ++i) {\\n        let diff = i % 26;\\n        if (need[diff])\\n            --need[diff], --needs;\\n    }\\n    return !needs; // \\uD83C\\uDFAF no needs\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, K: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need, needs = {}, 0\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\\n            if diff:\\n                if not diff in need:\\n                    need[diff] = 0\\n                need[diff] += 1\\n                needs += 1\\n        # \\uD83D\\uDEAB del needs\\n        for i in range(1, K + 1):\\n            if not needs:\\n                break\\n            diff = i % 26\\n            if diff in need and need[diff]:\\n                need[diff] -= 1\\n                needs -= 1\\n        return not needs # \\uD83C\\uDFAF no needs\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int K, Map need = {}, int needs = 0) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto diff = (t[i] - s[i] + 26) % 26;\\n            if (diff)\\n                ++need[diff], ++needs;\\n        }\\n        // \\uD83D\\uDEAB del needs\\n        for (auto i{ 1 }; i <= K && needs; ++i) {\\n            auto diff = i % 26;\\n            if (need[diff])\\n                --need[diff], --needs;\\n        }\\n        return !needs; // \\uD83C\\uDFAF no needs\\n    }\\n};\\n```\\n\\n---\\n\\n**Concise Solutions:** it is naive to continually iterate i to find needs to delete because we know we need to rotate each k-th need bucket by 26 (ie. the cardinality of the latin alphabet) for each bucket count greater than 1.  For example to transform `aa` to `bb`, we need 1 rotation for the first difference in this bucket, plus (1 * 26) rotations for the remaining differences in this bucket for a total of 27 rotations.  Similiarly to transform `aaa` to `bbb`, we need 1 rotation for the first difference in this bucket, plus (2 * 26) rotations for the remaining differences in this bucket for a total of 53 rotations, etc, etc...\\n\\n*Javascript*\\n```\\nlet canConvertString = (s, t, T, need = {}) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let k = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (k)\\n            need[k] = need[k] ? 1 + need[k] : 1;\\n    }\\n    // check if T is \\uD83D\\uDEAB insufficient for the needs\\n    for (let [k, cnt] of Object.entries(need))\\n        if (T < Number(k) + (cnt - 1) * 26)\\n            return false;\\n    return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, T: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need = {}\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            k = (ord(t[i]) - ord(s[i])) % 26\\n            if k:\\n                if not k in need:\\n                    need[k] = 0\\n                need[k] += 1\\n        # check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for k, cnt in need.items():\\n            if T < k + (cnt - 1) * 26:\\n                return False\\n        return True # \\uD83C\\uDFAF T is sufficient for the needs\\n```\\n\\n*C++*\\n```\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int T, Map need = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto k = (t[i] - s[i] + 26) % 26;\\n            if (k)\\n                ++need[k];\\n        }\\n        // check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for (auto [k, cnt]: need)\\n            if (T < k + (cnt - 1) * 26)\\n                return false;\\n        return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet canConvertString = (s, t, K, need = {}, needs = 0) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let diff = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (diff)\\n            need[diff] = need[diff] ? 1 + need[diff] : 1, ++needs;\\n    }\\n    // \\uD83D\\uDEAB del needs\\n    for (let i = 1; i <= K && needs; ++i) {\\n        let diff = i % 26;\\n        if (need[diff])\\n            --need[diff], --needs;\\n    }\\n    return !needs; // \\uD83C\\uDFAF no needs\\n};\\n```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, K: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need, needs = {}, 0\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            diff = (ord(t[i]) - ord(s[i]) + 26) % 26\\n            if diff:\\n                if not diff in need:\\n                    need[diff] = 0\\n                need[diff] += 1\\n                needs += 1\\n        # \\uD83D\\uDEAB del needs\\n        for i in range(1, K + 1):\\n            if not needs:\\n                break\\n            diff = i % 26\\n            if diff in need and need[diff]:\\n                need[diff] -= 1\\n                needs -= 1\\n        return not needs # \\uD83C\\uDFAF no needs\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int K, Map need = {}, int needs = 0) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto diff = (t[i] - s[i] + 26) % 26;\\n            if (diff)\\n                ++need[diff], ++needs;\\n        }\\n        // \\uD83D\\uDEAB del needs\\n        for (auto i{ 1 }; i <= K && needs; ++i) {\\n            auto diff = i % 26;\\n            if (need[diff])\\n                --need[diff], --needs;\\n        }\\n        return !needs; // \\uD83C\\uDFAF no needs\\n    }\\n};\\n```\n```\\nlet canConvertString = (s, t, T, need = {}) => {\\n    if (s.length != t.length)\\n        return false;\\n    // \\u2705 add needs\\n    for (let i = 0; i < s.length; ++i) {\\n        let k = (t[i].charCodeAt(0) - s[i].charCodeAt(0) + 26) % 26;\\n        if (k)\\n            need[k] = need[k] ? 1 + need[k] : 1;\\n    }\\n    // check if T is \\uD83D\\uDEAB insufficient for the needs\\n    for (let [k, cnt] of Object.entries(need))\\n        if (T < Number(k) + (cnt - 1) * 26)\\n            return false;\\n    return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n};\\n```\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, T: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        need = {}\\n        # \\u2705 add needs \\n        for i in range(len(s)):\\n            k = (ord(t[i]) - ord(s[i])) % 26\\n            if k:\\n                if not k in need:\\n                    need[k] = 0\\n                need[k] += 1\\n        # check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for k, cnt in need.items():\\n            if T < k + (cnt - 1) * 26:\\n                return False\\n        return True # \\uD83C\\uDFAF T is sufficient for the needs\\n```\n```\\npublic:\\n    using Map = unordered_map<int, int>;\\n    bool canConvertString(string s, string t, int T, Map need = {}) {\\n        if (s.size() != t.size())\\n            return false;\\n        // \\u2705 add needs\\n        for (auto i{ 0 }; i < s.size(); ++i) {\\n            auto k = (t[i] - s[i] + 26) % 26;\\n            if (k)\\n                ++need[k];\\n        }\\n        // check if T is \\uD83D\\uDEAB insufficient for the needs\\n        for (auto [k, cnt]: need)\\n            if (T < k + (cnt - 1) * 26)\\n                return false;\\n        return true; // \\uD83C\\uDFAF T is sufficient for the needs\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780288,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "**\\nIt\\'s just iterate over the length of the strings....\\nfirst case : if length of both the strings are not same simply return false ;\\nSecond case : if both char are different take the differnce of the ASCII values of the char and if it less than 0 so you need to add the differnce(i.e is diff) to 26 + diff ....as we need to see clockwise rotation from a to z.\\nand the main part comes when it asks you about if differnce is repeated then what ? Then you just need to mantain a map or set something to keep frequency of the differnce how many times it is appearing ... and formula will be like diff = 26 * m[diff] + diff ..... see the code which will help you to understand more...and make a dry run which will help you more better\\n**\\n\\n*if liked my solution please upvote :D*\\n```\\nclass Solution {\\npublic:\\nbool canConvertString(string s, string t, int k)\\n{\\n\\tint n = s.length();\\n\\tint l = t.length();\\n\\n\\tif (n != l)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmap<int, int> m;\\n\\t\\tint diff = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] != t[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff = t[i] - s[i];\\n\\t\\t\\t\\tif (diff < 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdiff = 26 + diff;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (m.find(diff) == m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm.insert({diff, 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint ans = 26 * m[diff] + diff;\\n\\t\\t\\t\\t\\tif (ans <= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[diff]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nbool canConvertString(string s, string t, int k)\\n{\\n\\tint n = s.length();\\n\\tint l = t.length();\\n\\n\\tif (n != l)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tmap<int, int> m;\\n\\t\\tint diff = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] != t[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdiff = t[i] - s[i];\\n\\t\\t\\t\\tif (diff < 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdiff = 26 + diff;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (m.find(diff) == m.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tm.insert({diff, 1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint ans = 26 * m[diff] + diff;\\n\\t\\t\\t\\t\\tif (ans <= k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[diff]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780084,
                "title": "c-o-n-time-o-1-space-explained",
                "content": "If length are not same return false.\\notherwise\\nThere are 3 possible cases for each chars at same index\\n1. if s[i] == t[i] then continue;\\n2. else find difference (if -ve add 26) which will be in range [0,25], for this we take 26 size array **step** to remember the which moves we have already taken, and update **step** for next possible move we can take.\\n**example:**\\ndiff = t[i]-s[i];\\nFor diff = 1, possible moves are 1, 27, 53 ...\\nFor diff = 2, possible moves are 2, 28, 54 ...\\nFor diff = 3, possible moves are 3, 29, 55 ... \\n.\\n.\\n.\\nFor diff = 25, possible moves are 25, 51, 77 ... \\n\\n3. Whenever we found the move we need for this is greater K return false. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        vector<int> step(27, 0);\\n        for(int i=1; i<27; ++i){\\n            step[i] = i;\\n        }\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(s[i] == t[i]) continue;\\n            \\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(step[diff] <= k){\\n                step[diff] += 26;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        vector<int> step(27, 0);\\n        for(int i=1; i<27; ++i){\\n            step[i] = i;\\n        }\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            if(s[i] == t[i]) continue;\\n            \\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(step[diff] <= k){\\n                step[diff] += 26;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780078,
                "title": "python-dictionary-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\t\\t\\tif len(s) != len(t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\td = {}\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif t[i] != s[i]:\\n\\t\\t\\t\\t\\tif t[i] > s[i]:\\n\\t\\t\\t\\t\\t\\tdiff = ord(t[i]) - ord(s[i])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdiff = ord(t[i]) + 26 - ord(s[i])\\n\\t\\t\\t\\t\\tif diff > k:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tif diff not in d:\\n\\t\\t\\t\\t\\t\\t\\td[diff] = diff\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tif d[diff] + 26 > k:\\n\\t\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\t\\td[diff] += 26\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\t\\t\\tif len(s) != len(t):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\td = {}",
                "codeTag": "Java"
            },
            {
                "id": 779965,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int[] hash = new int[26];\\n        Arrays.fill(hash,k / 26);\\n        int offset = k % 26;\\n        for(int i=0;i<=offset;++i) hash[i]++;\\n        for(int i=0;i<s.length();++i){\\n            if(s.charAt(i) != t.charAt(i)){\\n                int c1 = s.charAt(i) - \\'a\\' + 1;\\n                int c2 = t.charAt(i) - \\'a\\' + 1;\\n                int m = 0;\\n                if(c1 <= c2){\\n                    m = c2 - c1;\\n                }else{\\n                    m = 26 - c1 + c2;\\n                }\\n                \\n                if(hash[m]-- <= 0) return false;        \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int[] hash = new int[26];\\n        Arrays.fill(hash,k / 26);\\n        int offset = k % 26;\\n        for(int i=0;i<=offset;++i) hash[i]++;\\n        for(int i=0;i<s.length();++i){\\n            if(s.charAt(i) != t.charAt(i)){\\n                int c1 = s.charAt(i) - \\'a\\' + 1;\\n                int c2 = t.charAt(i) - \\'a\\' + 1;\\n                int m = 0;\\n                if(c1 <= c2){\\n                    m = c2 - c1;\\n                }else{\\n                    m = 26 - c1 + c2;\\n                }\\n                \\n                if(hash[m]-- <= 0) return false;        \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779961,
                "title": "c-dictionary",
                "content": "Runtime: 224 ms\\nMemory Usage: 40.2 MB\\n\\n```\\n\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length) { return false; }\\n        \\n        int alphaLength = \\'z\\'-\\'a\\'+1;\\n        \\n        Dictionary<int, int> distance = new Dictionary<int, int>();\\n        int moves;\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if (s[i] == t[i]) { continue; }\\n            \\n            if (s[i] < t[i]) \\n            {  \\n                moves = t[i] - s[i]; \\n            }\\n            else\\n            {\\n                moves = alphaLength - (s[i] - t[i]); \\n            }\\n           \\n            if (moves > k) { return false; }\\n            \\n            if (!distance.ContainsKey(moves)) { distance[moves] = 0; }\\n            distance[moves]++;\\n        }\\n        \\n        foreach(int key in distance.Keys)\\n        {\\n            if (distance[key] == 1) { continue; }\\n            if (key + ((distance[key]-1) * alphaLength) > k) { return false; }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 224 ms\\nMemory Usage: 40.2 MB\\n\\n```\\n\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length) { return false; }\\n        \\n        int alphaLength = \\'z\\'-\\'a\\'+1;\\n        \\n        Dictionary<int, int> distance = new Dictionary<int, int>();\\n        int moves;\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if (s[i] == t[i]) { continue; }\\n            \\n            if (s[i] < t[i]) \\n            {  \\n                moves = t[i] - s[i]; \\n            }\\n            else\\n            {\\n                moves = alphaLength - (s[i] - t[i]); \\n            }\\n           \\n            if (moves > k) { return false; }\\n            \\n            if (!distance.ContainsKey(moves)) { distance[moves] = 0; }\\n            distance[moves]++;\\n        }\\n        \\n        foreach(int key in distance.Keys)\\n        {\\n            if (distance[key] == 1) { continue; }\\n            if (key + ((distance[key]-1) * alphaLength) > k) { return false; }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4091920,
                "title": "simple-c-solution-o-n-time-and-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diff(26,0);\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=t[i]){\\n                int d = (t[i] - s[i] + 26)%26;\\n                int n1 = 26*diff[d] + d;\\n                if(n1<=k){\\n                    diff[d]++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diff(26,0);\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=t[i]){\\n                int d = (t[i] - s[i] + 26)%26;\\n                int n1 = 26*diff[d] + d;\\n                if(n1<=k){\\n                    diff[d]++;\\n                }\\n                else return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084270,
                "title": "simple-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n\\n        int n = s.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=t[i]){\\n                int x = (int)(t[i])-(int)(s[i]);\\n                if(x<0) x+=26;\\n                int m=26*mp[x];\\n                if(x+m>k) return 0;\\n                else{\\n                    mp[x]++;\\n                }\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n\\n        int n = s.size();\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=t[i]){\\n                int x = (int)(t[i])-(int)(s[i]);\\n                if(x<0) x+=26;\\n                int m=26*mp[x];\\n                if(x+m>k) return 0;\\n                else{\\n                    mp[x]++;\\n                }\\n            }\\n        }\\n\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010225,
                "title": "c-hash-table-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        return false;\\n        if(s==t)\\n        return true;\\n        if(k==0)\\n        return false;\\n        int n = s.size();\\n        vector<int> diff(n);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i] = (t[i]-s[i]+26)%26;\\n            if(m.find(diff[i])!=m.end() && diff[i]!=0)\\n            {\\n                m[diff[i]]+=26;\\n                diff[i] = m[diff[i]];\\n            }\\n            else\\n            m[diff[i]] = diff[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int mov = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(diff[i]==0)\\n            continue;\\n            if(mov<diff[i] && diff[i]<=k)\\n            {\\n                mov = diff[i];\\n            }\\n            else if(diff[i]+26>mov && diff[i]+26<=k)\\n            {\\n                mov = diff[i]+26;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        return false;\\n        if(s==t)\\n        return true;\\n        if(k==0)\\n        return false;\\n        int n = s.size();\\n        vector<int> diff(n);\\n        unordered_map<int,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i] = (t[i]-s[i]+26)%26;\\n            if(m.find(diff[i])!=m.end() && diff[i]!=0)\\n            {\\n                m[diff[i]]+=26;\\n                diff[i] = m[diff[i]];\\n            }\\n            else\\n            m[diff[i]] = diff[i];\\n        }\\n        sort(diff.begin(),diff.end());\\n        int mov = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(diff[i]==0)\\n            continue;\\n            if(mov<diff[i] && diff[i]<=k)\\n            {\\n                mov = diff[i];\\n            }\\n            else if(diff[i]+26>mov && diff[i]+26<=k)\\n            {\\n                mov = diff[i]+26;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002892,
                "title": "java-modulo-and-clean-code",
                "content": "# Approach\\n1. The key is to count how many group of modulos you have for the given k.\\n    - EG: 27: [1,2,3...26,27]. All of these % 26 would result [1,2,...1]. Two elements (1 and 27) % 26 = 1. So modulo[1] = 2.\\n2. For given k calculate the groups of modulos\\n3. Traverse s and t and for each index, if the chars are disting, calculate their distance.\\n    - a -> c = 2 ; y -> b = 3. \\n4. For each such distinct pair, deduct 1 from their modulo groups. If the modulo groups goes below 0, it means you do not have enough numbers to cover their modulos. \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(26)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        } else if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] modulos = getModulos(k);\\n        return canConvert(s, t, modulos);\\n    }\\n\\n    private boolean canConvert(String s, String t, int[] modulos) {\\n        char first, second;\\n        int distance;\\n        for (int i = 0; i < s.length(); i++) {\\n            first = s.charAt(i);\\n            second = t.charAt(i);\\n            if (first != second) {\\n                distance = first < second ? second - first : (26 - first) + second;\\n                if (--modulos[distance] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getModulos(int k) {\\n        int[] modulos = new int[26];\\n        int div = k / 26;\\n        Arrays.fill(modulos, div);\\n        k = k % 26;\\n        while (k >= 0) {\\n            modulos[k--]++;\\n        }\\n        return modulos;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if (k == 0) {\\n            return s.equals(t);\\n        } else if (s.length() != t.length()) {\\n            return false;\\n        }\\n        int[] modulos = getModulos(k);\\n        return canConvert(s, t, modulos);\\n    }\\n\\n    private boolean canConvert(String s, String t, int[] modulos) {\\n        char first, second;\\n        int distance;\\n        for (int i = 0; i < s.length(); i++) {\\n            first = s.charAt(i);\\n            second = t.charAt(i);\\n            if (first != second) {\\n                distance = first < second ? second - first : (26 - first) + second;\\n                if (--modulos[distance] < 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getModulos(int k) {\\n        int[] modulos = new int[26];\\n        int div = k / 26;\\n        Arrays.fill(modulos, div);\\n        k = k % 26;\\n        while (k >= 0) {\\n            modulos[k--]++;\\n        }\\n        return modulos;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999274,
                "title": "c-8-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we simply calculate the shift required for each character of s and and store it in an array of size 26. Then check if those many shift are possible or not within the given value of k.\\n\\nar[i] = x implies that there are x characters in string s that need a shift of i to match the charcters in string t.\\nNow it is given in the question that each shift can be used only once.\\nSo if two charcters need a shift of 1, only one of them will be allowed.\\nThe next charcter will get a shift of 1 + 26 which makes the efective shift to be 1.\\nEg: lets say s = \"aa\" and t = \"cc\"\\nThen ar[2] = 2\\nSo two characters need a net shift of 2. So the possible shifts are 2, 28, 54, .....\\nSince we need only two, so 2 and 28 are enough. Therefore our value of k should be atleast 28 .If not then return false immediately\\n\\n# Complexity\\n- Time complexity:O(s.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length()) return false;\\n        int ar[26] = {0};       \\n        for(int i = 0;i < s.length();i++){\\n            int shift = (t[i] - s[i] + 26) % 26;            \\n            ar[shift]++;\\n        }\\n        for(int i = 1;i <= 25;i++)\\n            if(i + (ar[i] - 1)*26 > k)\\n                return false;\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956395,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool canConvertString(string s, string t, int k) {\\n    if (s.length() != t.length())\\n      return false;\\n\\n    // E.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\\n    // For a -> b, need 1 move\\n    //     a -> b, need 1 + 26 moves\\n    //     b -> c, need 1 + 26 * 2 moves\\n    vector<int> shiftCount(26);\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ++shiftCount[(t[i] - s[i] + 26) % 26];\\n\\n    for (int shift = 1; shift < 26; ++shift)\\n      if (shift + 26 * (shiftCount[shift] - 1) > k)\\n        return false;\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool canConvertString(string s, string t, int k) {\\n    if (s.length() != t.length())\\n      return false;\\n\\n    // E.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\\n    // For a -> b, need 1 move\\n    //     a -> b, need 1 + 26 moves\\n    //     b -> c, need 1 + 26 * 2 moves\\n    vector<int> shiftCount(26);\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ++shiftCount[(t[i] - s[i] + 26) % 26];\\n\\n    for (int shift = 1; shift < 26; ++shift)\\n      if (shift + 26 * (shiftCount[shift] - 1) > k)\\n        return false;\\n\\n    return true;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903100,
                "title": "easy-to-understand-javascript-solution-hash-table",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(26)$$\\n\\n# Code\\n```\\nvar canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function(s, t, k) {\\n    if (s.length !== t.length) return false;\\n    const convertCounts = Array(26).fill(0);\\n\\n    for (let index = 0; index < s.length; index++) {\\n        const diff = (t.charCodeAt(index) - s.charCodeAt(index) + 26) % 26;\\n        \\n        if (!diff) continue;\\n        if (diff + convertCounts[diff] * 26 > k) return false;\\n        convertCounts[diff] += 1;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842294,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size()!=t.size()) return false;\\n        int n=s.size();\\n        int div=k/26;\\n        vector<int>temp(26,div);\\n        int rem=k%26;\\n        for (int i=0;i<=rem;i++) temp[i]++;   \\n        for (int i=0;i<n;i++)\\n        {\\n            if (s[i]!=t[i])\\n            {\\n                int diff=(t[i]-s[i]+26)%26;\\n                if (temp[diff]==0) return false;\\n                temp[diff]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size()!=t.size()) return false;\\n        int n=s.size();\\n        int div=k/26;\\n        vector<int>temp(26,div);\\n        int rem=k%26;\\n        for (int i=0;i<=rem;i++) temp[i]++;   \\n        for (int i=0;i<n;i++)\\n        {\\n            if (s[i]!=t[i])\\n            {\\n                int diff=(t[i]-s[i]+26)%26;\\n                if (temp[diff]==0) return false;\\n                temp[diff]--;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725131,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diffs(26,0);\\n        for(int i=0;i<26;i++){\\n            diffs[i]=i;\\n        }\\n        int n = s.size();\\n        int m = t.size();\\n        if(m!=n) return false;\\n        for(int i=0;i<n;i++){\\n            int diff = ((int)t[i] - (int)s[i]);\\n            if(diff==0) continue;\\n            else if(diff<0) diff+=26;\\n            if(diffs[diff]>k) return false;\\n            diffs[diff]+=26;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        vector<int> diffs(26,0);\\n        for(int i=0;i<26;i++){\\n            diffs[i]=i;\\n        }\\n        int n = s.size();\\n        int m = t.size();\\n        if(m!=n) return false;\\n        for(int i=0;i<n;i++){\\n            int diff = ((int)t[i] - (int)s[i]);\\n            if(diff==0) continue;\\n            else if(diff<0) diff+=26;\\n            if(diffs[diff]>k) return false;\\n            diffs[diff]+=26;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663184,
                "title": "python-check-max-counter-of-diff-o-n",
                "content": "```\\n\"\"\"\\nHere we just count of same diff, and then\\ncheck if the max difference*26 larger than k.\\n\\nBecause of each new +1 of same diff increases\\nour move by 26.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        count = Counter()\\n        for a, b in zip(s, t):\\n            if a != b:\\n                count[(ord(b) - ord(a)) % 26] += 1\\n            \\n        m = 0\\n        for d, v in count.items():\\n            m = max(m, d + (v - 1)*26)\\n            if m > k:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nHere we just count of same diff, and then\\ncheck if the max difference*26 larger than k.\\n\\nBecause of each new +1 of same diff increases\\nour move by 26.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n\\n        count = Counter()\\n        for a, b in zip(s, t):\\n            if a != b:\\n                count[(ord(b) - ord(a)) % 26] += 1\\n            \\n        m = 0\\n        for d, v in count.items():\\n            m = max(m, d + (v - 1)*26)\\n            if m > k:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598436,
                "title": "small-c-solution-100-runtime-and-100-memory",
                "content": "# Code\\n```\\n#pragma GCC optimize (\"-O3\", \"-march=native\")\\nbool canConvertString(char *s, char *t, int k) {\\n    int needed_shifts[26] = {};\\n    for (; *s && *t; ++s, ++t) ++needed_shifts[(*t - *s + 26) % 26];\\n    if (*s || *t) return false;\\n    for (int i = 1; i < 26; ++i) {\\n        if (i + (needed_shifts[i] - 1) * 26 > k) return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#pragma GCC optimize (\"-O3\", \"-march=native\")\\nbool canConvertString(char *s, char *t, int k) {\\n    int needed_shifts[26] = {};\\n    for (; *s && *t; ++s, ++t) ++needed_shifts[(*t - *s + 26) % 26];\\n    if (*s || *t) return false;\\n    for (int i = 1; i < 26; ++i) {\\n        if (i + (needed_shifts[i] - 1) * 26 > k) return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552972,
                "title": "beats-100-must-see-approach-t-c-o-n-and-o-26-or-constant-space",
                "content": "# Intuition\\nto make a freq array and then look for value of k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- O(n) -->\\n\\n- Space complexity:  O(26) \\n<!-- O(26) or basically it is constant -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n       <!-- for fast I/O -->\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n = s.length(), m = t.length();\\n        <!-- edge case -->\\n        if(n!=m) return false;\\n        vector<int > mp(27,0);\\n        <!-- if we got diff as 1 (increase freq of 1 at this point)then if we get another 1 then we look for k=27 i.e diff(1)+mp[diff](1)  then we take action according to value of k--> \\n\\n        for(int i =0;i<n;i++){\\n            int diff= (t[i]-s[i]+26)%26;\\n            if(diff!=0){\\n                if(diff+mp[diff]*26<=k){\\n                    mp[diff]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n       <!-- for fast I/O -->\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n\\n        int n = s.length(), m = t.length();\\n        <!-- edge case -->\\n        if(n!=m) return false;\\n        vector<int > mp(27,0);\\n        <!-- if we got diff as 1 (increase freq of 1 at this point)then if we get another 1 then we look for k=27 i.e diff(1)+mp[diff](1)  then we take action according to value of k--> \\n\\n        for(int i =0;i<n;i++){\\n            int diff= (t[i]-s[i]+26)%26;\\n            if(diff!=0){\\n                if(diff+mp[diff]*26<=k){\\n                    mp[diff]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549991,
                "title": "find-the-residue-of-modulo",
                "content": "# Approach\\nif two strings have different length, can\\'t convert s to t for all k.\\nFind the modulo number of shifts by i and its upper bound for i = 1,2,...,25, meaning that do nothing for the residue\\'s. \\n\\n# Complexity\\n- Time complexity: O(n), n:length of s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n            \\n        k += 1\\n        L = [0] * 26\\n        T = [k // 26] * 26\\n        k %= 26\\n\\n        for i in range(len(s)):\\n            L[ord(t[i])-ord(s[i])] += 1\\n        \\n        for i in range(k):\\n            T[i] += 1\\n\\n        for i in range(1, 26):\\n            if L[i] > T[i]:\\n                return False\\n        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n            \\n        k += 1\\n        L = [0] * 26\\n        T = [k // 26] * 26\\n        k %= 26\\n\\n        for i in range(len(s)):\\n            L[ord(t[i])-ord(s[i])] += 1\\n        \\n        for i in range(k):\\n            T[i] += 1\\n\\n        for i in range(1, 26):\\n            if L[i] > T[i]:\\n                return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534281,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n    if s.len() != t.len() {\\n      return false\\n    }\\n    let s = s.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let t = t.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let k = k as usize;\\n    let mut memo = (0..26).into_iter().collect::<Vec<usize>>();\\n\\n    for i in 0..n {\\n      if s[i] < t[i] {\\n        let ti = t[i] - s[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      } else if s[i] > t[i] {\\n        let ti = 26 - s[i] + t[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      }\\n    }\\n    true\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n    if s.len() != t.len() {\\n      return false\\n    }\\n    let s = s.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let t = t.chars().into_iter().map(|v| v as usize - \\'a\\' as usize).collect::<Vec<usize>>();\\n    let n = s.len();\\n    let k = k as usize;\\n    let mut memo = (0..26).into_iter().collect::<Vec<usize>>();\\n\\n    for i in 0..n {\\n      if s[i] < t[i] {\\n        let ti = t[i] - s[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      } else if s[i] > t[i] {\\n        let ti = 26 - s[i] + t[i];\\n        if memo[ti] > k {\\n          return false\\n        }\\n        memo[ti] += 26;\\n      }\\n    }\\n    true\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524005,
                "title": "simple-c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int l = s.length();\\n     int qwe = t.length();\\n\\n     if(l!=qwe){\\n         return 0;\\n     }\\n\\n    vector<int> alpha(27);\\n    vector<int> match(27);\\n    match[0] = INT_MAX;\\n    int n = k/26;\\n    int r = k%26;\\n\\n\\n    for(int i = 0; i<=26; i++){\\n         alpha[i] = 0;\\n     } \\n\\n     for(int i = 0; i<l; i++){\\n         if(t[i] - s[i] >= 0){\\n             int k = t[i] - s[i];\\n             alpha[k]++;\\n         }\\n         else{\\n             int k = t[i] - s[i] + 26;\\n             alpha[k]++;\\n         }\\n     }\\n\\n     \\n\\n     \\n     for(int i = 1; i<=26; i++){\\n         if(r>0){\\n             match[i] = n+1;\\n             r--;\\n         }\\n         else{\\n             match[i] = n;\\n         }\\n     }\\n\\n     for(int i = 1; i<=26; i++){\\n         if(match[i] - alpha[i]<0){\\n             return false;\\n         }\\n     }\\n     return true;\\n     \\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int l = s.length();\\n     int qwe = t.length();\\n\\n     if(l!=qwe){\\n         return 0;\\n     }\\n\\n    vector<int> alpha(27);\\n    vector<int> match(27);\\n    match[0] = INT_MAX;\\n    int n = k/26;\\n    int r = k%26;\\n\\n\\n    for(int i = 0; i<=26; i++){\\n         alpha[i] = 0;\\n     } \\n\\n     for(int i = 0; i<l; i++){\\n         if(t[i] - s[i] >= 0){\\n             int k = t[i] - s[i];\\n             alpha[k]++;\\n         }\\n         else{\\n             int k = t[i] - s[i] + 26;\\n             alpha[k]++;\\n         }\\n     }\\n\\n     \\n\\n     \\n     for(int i = 1; i<=26; i++){\\n         if(r>0){\\n             match[i] = n+1;\\n             r--;\\n         }\\n         else{\\n             match[i] = n;\\n         }\\n     }\\n\\n     for(int i = 1; i<=26; i++){\\n         if(match[i] - alpha[i]<0){\\n             return false;\\n         }\\n     }\\n     return true;\\n     \\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438162,
                "title": "fast-and-simple-solution-with-explanation-c",
                "content": "# Intuition\\nWe can convert *s* to *t* only if for every position *i* (*0 <= i < s.size()*) where *s[i] != t[i]* we can find a unique number *1 <= n <= k* such that *s[i] + (n % 26)  == t[i]*. (26 is the number of characters in english alphabet).\\n\\n# Approach\\nFirst we check sizes of the two strings. When they differ, we return false immidiately. Next, we iterate over the strings and count only chars that do differ. When difference is negative, we add 26 to it.\\n\\nIn the last step, we iterate over the summery map and check every position, where difference greater than 0. For example, when we have a difference 2 in 3 positions, we have to use numbers 2, 28 and 54 to close gaps in all three positions (2, 2 + 1 x 26, 2 + 2 x 26). When the maximal number do not exceeds k, we return true, otherwise false. \\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tconst int alphabet_size = 26;\\n\\npublic:\\n\\tbool canConvertString(string s, string t, int k) {\\n\\t\\tif (s.size() != t.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> movesMap(127, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint diff = t[i] - s[i];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tmovesMap[diff]++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (diff < 0) {\\n\\t\\t\\t\\tmovesMap[alphabet_size + diff]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (movesMap.empty()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < movesMap.size(); i++) {\\n\\t\\t\\tif ((movesMap[i] > 0) && (i + (movesMap[i] - 1) * alphabet_size > k)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\tconst int alphabet_size = 26;\\n\\npublic:\\n\\tbool canConvertString(string s, string t, int k) {\\n\\t\\tif (s.size() != t.size()) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<int> movesMap(127, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint diff = t[i] - s[i];\\n\\t\\t\\tif (diff > 0) {\\n\\t\\t\\t\\tmovesMap[diff]++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (diff < 0) {\\n\\t\\t\\t\\tmovesMap[alphabet_size + diff]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (movesMap.empty()) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < movesMap.size(); i++) {\\n\\t\\t\\tif ((movesMap[i] > 0) && (i + (movesMap[i] - 1) * alphabet_size > k)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314788,
                "title": "and-c",
                "content": "C solution:\\n```\\nbool canConvertString(char * s, char * t, int k){\\n    if(strlen(s) != strlen(t))\\n        return false ;\\n    int n = strlen(s) ;\\n    int* count = calloc(26, sizeof(int)) ;\\n    for(int i = 0; i < n; i++){\\n        int d = (t[i] - s[i] + 26) % 26 ;\\n        count[d]++ ;\\n    }\\n    bool ret = true ;\\n    for(int i = 1; i < 26; i++){\\n        if(count[i] > 0){\\n            int max = i + (count[i]-1)*26 ;\\n            if(max > k){\\n                ret = false ;\\n                break ;\\n            }\\n        }\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```\\n\\nC++ solution \\uFF1A\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false ;\\n        int n = s.size() ;\\n        vector<int>count(26) ;\\n        for(int i = 0; i < n; i++){\\n            int d = (t[i] - s[i] + 26) % 26 ;\\n            count[d]++ ;\\n        }\\n        for(int i = 1 ; i < 26; i++){\\n            if(count[i] > 0){\\n                int max = i + 26 *(count[i] -1) ;\\n                if(max > k)\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(char * s, char * t, int k){\\n    if(strlen(s) != strlen(t))\\n        return false ;\\n    int n = strlen(s) ;\\n    int* count = calloc(26, sizeof(int)) ;\\n    for(int i = 0; i < n; i++){\\n        int d = (t[i] - s[i] + 26) % 26 ;\\n        count[d]++ ;\\n    }\\n    bool ret = true ;\\n    for(int i = 1; i < 26; i++){\\n        if(count[i] > 0){\\n            int max = i + (count[i]-1)*26 ;\\n            if(max > k){\\n                ret = false ;\\n                break ;\\n            }\\n        }\\n    }\\n    free(count) ;\\n    return ret ;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size())\\n            return false ;\\n        int n = s.size() ;\\n        vector<int>count(26) ;\\n        for(int i = 0; i < n; i++){\\n            int d = (t[i] - s[i] + 26) % 26 ;\\n            count[d]++ ;\\n        }\\n        for(int i = 1 ; i < 26; i++){\\n            if(count[i] > 0){\\n                int max = i + 26 *(count[i] -1) ;\\n                if(max > k)\\n                    return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283787,
                "title": "short-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int>mp;\\n        if(s.size()!=t.size()) return false;\\n        for(int i=0;i<s.size();i++){\\n           int x=(t[i]-s[i]+26)%26;\\n           if(x!=0){\\n               int v=mp[x];\\n               int ve=x+26*v;\\n               if(ve<=k){\\n                   mp[x]++;\\n               }\\n               else{\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int>mp;\\n        if(s.size()!=t.size()) return false;\\n        for(int i=0;i<s.size();i++){\\n           int x=(t[i]-s[i]+26)%26;\\n           if(x!=0){\\n               int v=mp[x];\\n               int ve=x+26*v;\\n               if(ve<=k){\\n                   mp[x]++;\\n               }\\n               else{\\n                   return false;\\n               }\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270070,
                "title": "o-n-constant-space-solution-in-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(26) ~ constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        vector<int> tracker(26, 0);\\n        for(int i=0;i<s.length();i++){\\n            int diff;\\n            if(t[i]>s[i]){\\n                diff = (t[i]-\\'a\\')-(s[i]-\\'a\\');\\n            }\\n            else{\\n                diff = (\\'z\\'-s[i]) + (t[i]-\\'a\\') + 1;\\n            }\\n            if(diff==0 || diff==26){\\n                continue;\\n            }\\n            if(diff>k){\\n                return false;\\n            }\\n            if(tracker[diff]!=0){\\n                tracker[diff]+=26;\\n                if(tracker[diff]>k){\\n                    return false;\\n                }\\n            }\\n            else{\\n                tracker[diff] += diff;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n\\n        vector<int> tracker(26, 0);\\n        for(int i=0;i<s.length();i++){\\n            int diff;\\n            if(t[i]>s[i]){\\n                diff = (t[i]-\\'a\\')-(s[i]-\\'a\\');\\n            }\\n            else{\\n                diff = (\\'z\\'-s[i]) + (t[i]-\\'a\\') + 1;\\n            }\\n            if(diff==0 || diff==26){\\n                continue;\\n            }\\n            if(diff>k){\\n                return false;\\n            }\\n            if(tracker[diff]!=0){\\n                tracker[diff]+=26;\\n                if(tracker[diff]>k){\\n                    return false;\\n                }\\n            }\\n            else{\\n                tracker[diff] += diff;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269343,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length() != t.length()) return false;\\n        \\n        int[] count = new int[26];\\n        for(int i =0; i< s.length(); i++){\\n            int diff = (int)(t.charAt(i) - s.charAt(i));\\n            if(diff < 0 ) diff = diff + 26;\\n\\n            if(diff > 0 && diff + count[diff]*26 > k ) return false;\\n            count[diff]++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266162,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n       if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n       if (s.size() != t.size())\\n        return false;\\n    int mul[26] = {};\\n    for (int i = 0; i < s.size(); ++i) {\\n        int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n        if (shift != 0 && shift + mul[shift] * 26 > k)\\n            return false;\\n        ++mul[shift];\\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265958,
                "title": "c-o-n-o-1-frequency-array",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int sl = s.length(), tl = t.length();\\n        if(sl != tl) return false;\\n\\n        vector<int> m(27, k/26);\\n        for(int i = 1; i < 27; i++) {\\n            if(k%26 >= i) m[i]++;\\n        }\\n\\n        for(int i = 0; i < sl; i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(diff > k || m[diff] <= 0) return false;\\n            m[diff]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int sl = s.length(), tl = t.length();\\n        if(sl != tl) return false;\\n\\n        vector<int> m(27, k/26);\\n        for(int i = 1; i < 27; i++) {\\n            if(k%26 >= i) m[i]++;\\n        }\\n\\n        for(int i = 0; i < sl; i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = t[i]-s[i];\\n            if(diff < 0) diff += 26;\\n            if(diff > k || m[diff] <= 0) return false;\\n            m[diff]--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262977,
                "title": "simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince for every move we can go for i steps forward, we need to track for steps..\\nAlso every j will be unique as we are traversing the string..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a map where we store the i values along with the no of times we used it.\\nIt we would like to convert a to c , we need to look for 2nd move, suppose for another j again we get a to c, then we can\\'t use 2nd move but we can use 2+26 the move. again if we get same conversion use 2+26*2... so on..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)  as map keys are from 1 to 26 only..\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        for(int j=0;j<s.length();i++){\\n            char c1 = s[j];\\n            char c2 = t[j];\\n            int val = t[j]-s[j];\\n            if(val!=0){\\n                if(val<0){\\n                    val+=26;\\n                }\\n                //cout<<\"Val is \"<<val+mp[val]*26<<\"for converting \"<<s[i]<<\" to \"<<t[i]<<endl;\\n                if(val+mp[val]*26<=k){\\n                    mp[val]++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        map<int,int> mp;\\n        for(int j=0;j<s.length();i++){\\n            char c1 = s[j];\\n            char c2 = t[j];\\n            int val = t[j]-s[j];\\n            if(val!=0){\\n                if(val<0){\\n                    val+=26;\\n                }\\n                //cout<<\"Val is \"<<val+mp[val]*26<<\"for converting \"<<s[i]<<\" to \"<<t[i]<<endl;\\n                if(val+mp[val]*26<=k){\\n                    mp[val]++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3262137,
                "title": "258-ms",
                "content": "```ruby\\ndef can_convert_string s, t, k\\n    return false if s.size != t.size\\n    s, t = *[s, t].map!(&:bytes)\\n    h = (0...s.size).map do\\n        x, y = s[_1], t[_1]\\n        y + (y < x ? 26 : 0) - x \\n    end .tally\\n    h.delete 0\\n    h.empty? || begin\\n        x, y = *h.max_by { [_2, _1] }\\n        (y - 1) * 26 + x <= k\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef can_convert_string s, t, k\\n    return false if s.size != t.size\\n    s, t = *[s, t].map!(&:bytes)\\n    h = (0...s.size).map do\\n        x, y = s[_1], t[_1]\\n        y + (y < x ? 26 : 0) - x \\n    end .tally\\n    h.delete 0\\n    h.empty? || begin\\n        x, y = *h.max_by { [_2, _1] }\\n        (y - 1) * 26 + x <= k\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3223328,
                "title": "java-using-modulo-operation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        int[] arr=new int[27];\\n        int div=k/26,rem=k%26;\\n        for (int i=1;i<arr.length;i++){\\n            arr[i]=div;\\n        }\\n        for (int i=1;i<=rem;i++){\\n            arr[i]++;\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int val=(t.charAt(i)-s.charAt(i)+26)%26;\\n                if(arr[val]>0){\\n                    arr[val]--;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n     public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()){\\n            return false;\\n        }\\n        int[] arr=new int[27];\\n        int div=k/26,rem=k%26;\\n        for (int i=1;i<arr.length;i++){\\n            arr[i]=div;\\n        }\\n        for (int i=1;i<=rem;i++){\\n            arr[i]++;\\n        }\\n        for (int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=t.charAt(i)){\\n                int val=(t.charAt(i)-s.charAt(i)+26)%26;\\n                if(arr[val]>0){\\n                    arr[val]--;\\n                }else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169455,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // calculates distance between char a and b through shifting right\\n    int dist(char a, char b){\\n        int moves = 0;\\n        while (a != b){\\n            ++moves;\\n            if (a == \\'z\\') a = \\'a\\';\\n            else ++a;\\n        }\\n        return moves;\\n    }\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<int,int> m;\\n        int remainder = k % 26;\\n        for (int i = 1; i <= 26; ++i){\\n            m[i] += k / 26;\\n            if (remainder-- > 0) m[i] += 1;\\n        }\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] != t[i]){\\n                int d = dist(s[i], t[i]);\\n                if (--m[d] == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // calculates distance between char a and b through shifting right\\n    int dist(char a, char b){\\n        int moves = 0;\\n        while (a != b){\\n            ++moves;\\n            if (a == \\'z\\') a = \\'a\\';\\n            else ++a;\\n        }\\n        return moves;\\n    }\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        unordered_map<int,int> m;\\n        int remainder = k % 26;\\n        for (int i = 1; i <= 26; ++i){\\n            m[i] += k / 26;\\n            if (remainder-- > 0) m[i] += 1;\\n        }\\n        for (int i = 0; i < s.size(); ++i){\\n            if (s[i] != t[i]){\\n                int d = dist(s[i], t[i]);\\n                if (--m[d] == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167267,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n        use std::collections::HashMap;\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        let diffs = s.bytes().zip(t.bytes()).map(|(x, y)| (y as i32 - x as i32 + 26) % 26);\\n        let diffs = diffs.into_iter().filter(|&x| x != 0);\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        for diff in diffs {\\n            let multiplier = *map.entry(diff).or_insert(0);\\n            if diff + (26 * multiplier) > k {\\n                return false;\\n            }\\n            *map.entry(diff).or_insert(0) += 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_convert_string(s: String, t: String, k: i32) -> bool {\\n        use std::collections::HashMap;\\n        if s.len() != t.len() {\\n            return false;\\n        }\\n        let diffs = s.bytes().zip(t.bytes()).map(|(x, y)| (y as i32 - x as i32 + 26) % 26);\\n        let diffs = diffs.into_iter().filter(|&x| x != 0);\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        for diff in diffs {\\n            let multiplier = *map.entry(diff).or_insert(0);\\n            if diff + (26 * multiplier) > k {\\n                return false;\\n            }\\n            *map.entry(diff).or_insert(0) += 1;\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164248,
                "title": "c-o-n-easy-solution-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length())\\n            return 0;\\n        vector<int> vacant(26, 0);\\n        for(int i=0;i<26;i++)\\n            vacant[i] = i;\\n        int x, p;\\n        for(int i=0;i<s.length();i++){\\n            if(t[i] - \\'a\\'- (s[i] - \\'a\\') != 0)\\n            {\\n             x = t[i] - \\'a\\'- (s[i] - \\'a\\');\\n            if(x < 0)\\n                x += 26;\\n             p = vacant[x%26];\\n            vacant[x%26] += 26;\\n            if(p > k)\\n                return 0;         \\n            s[i] = t[i];\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length() != t.length())\\n            return 0;\\n        vector<int> vacant(26, 0);\\n        for(int i=0;i<26;i++)\\n            vacant[i] = i;\\n        int x, p;\\n        for(int i=0;i<s.length();i++){\\n            if(t[i] - \\'a\\'- (s[i] - \\'a\\') != 0)\\n            {\\n             x = t[i] - \\'a\\'- (s[i] - \\'a\\');\\n            if(x < 0)\\n                x += 26;\\n             p = vacant[x%26];\\n            vacant[x%26] += 26;\\n            if(p > k)\\n                return 0;         \\n            s[i] = t[i];\\n            }\\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035460,
                "title": "hashing-o-n",
                "content": "used hashmap to store previous min value of difference of two alphabets in both s and t respectively \\nfirst i was using hashset which was not effeceint because that checks everytime if the number is present or not \\n\\nso i used hashmap and everything solved \\n\\n```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()) return false ; \\n        HashMap<Long,Long> hm = new HashMap<>();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            Long a = (long)(t.charAt(i)-\\'a\\')-(long)(s.charAt(i)-\\'a\\');\\n            if(a>0) {\\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26)>k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n            else if(a<0){\\n                a += 26 ; \\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26) > k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        if(s.length()!=t.length()) return false ; \\n        HashMap<Long,Long> hm = new HashMap<>();\\n        for(int i = 0 ; i < s.length() ; i++){\\n            Long a = (long)(t.charAt(i)-\\'a\\')-(long)(s.charAt(i)-\\'a\\');\\n            if(a>0) {\\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26)>k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n            else if(a<0){\\n                a += 26 ; \\n                if(hm.containsKey(a)){\\n                    if((hm.get(a)+26) > k) return false ; \\n                    else hm.put(a,hm.get(a)+26);\\n                }\\n                else {\\n                    if(a>k) return false ; \\n                    hm.put(a,a);\\n                }\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928266,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        int cnt[26]{}, round = k/26, remainer = k%26;\\n        for(int i = 0; i < s.size(); i++) cnt[(t[i]-s[i]+26)%26]++;\\n        for(int i = 1; i <= 25; i++) if(round + (i <= remainer ? 1 : 0) < cnt[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()) return false;\\n        int cnt[26]{}, round = k/26, remainer = k%26;\\n        for(int i = 0; i < s.size(); i++) cnt[(t[i]-s[i]+26)%26]++;\\n        for(int i = 1; i <= 25; i++) if(round + (i <= remainer ? 1 : 0) < cnt[i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927948,
                "title": "c-simple-solution-worst-question",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int end= s.size()-1, start = 0;\\n        map<int,int> mp;\\n        while(start<=end){\\n            int diff = (t[start]-s[start]+26)%26; //for negative difference\\n            if(diff!=0){\\n                int mul = mp[diff];\\n                long long val = diff+ (26*mul);\\n                if(val<=k) mp[diff]++; \\n                else return false;\\n            }\\n            start++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int end= s.size()-1, start = 0;\\n        map<int,int> mp;\\n        while(start<=end){\\n            int diff = (t[start]-s[start]+26)%26; //for negative difference\\n            if(diff!=0){\\n                int mul = mp[diff];\\n                long long val = diff+ (26*mul);\\n                if(val<=k) mp[diff]++; \\n                else return false;\\n            }\\n            start++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842168,
                "title": "python-hashmap-faster-than-100",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:    \\n        m, n = len(s), len(t)\\n        if m != n: return False\\n        cnt1 = Counter((ord(t[i]) - ord(s[i])) % 26 for i in range(m))\\n        del(cnt1[0])\\n        q, r = divmod(k, 26)\\n        cnt2 = Counter({i: q for i in range(1, 26)}) + Counter({i: 1 for i in range(1, r + 1)})\\n        return cnt1 <= cnt2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:    \\n        m, n = len(s), len(t)\\n        if m != n: return False\\n        cnt1 = Counter((ord(t[i]) - ord(s[i])) % 26 for i in range(m))\\n        del(cnt1[0])\\n        q, r = divmod(k, 26)\\n        cnt2 = Counter({i: q for i in range(1, 26)}) + Counter({i: 1 for i in range(1, r + 1)})\\n        return cnt1 <= cnt2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683473,
                "title": "c-count-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ -> `n` is the length os string `s`.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool canConvertString(const string& s, const string& t, int k) {\\n        const int n = size(s);\\n        if (n != size(t))\\n            return false;\\n        array<int, 26> count{};\\n        for (int i = 0; i < n; ++i)\\n            if (int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n                shift && shift + count[shift]++ * 26 > k)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool canConvertString(const string& s, const string& t, int k) {\\n        const int n = size(s);\\n        if (n != size(t))\\n            return false;\\n        array<int, 26> count{};\\n        for (int i = 0; i < n; ++i)\\n            if (int shift = t[i] - s[i] + (t[i] < s[i] ? 26 : 0);\\n                shift && shift + count[shift]++ * 26 > k)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628773,
                "title": "c-o-n-simple",
                "content": "I found that many solutions check the possibility at the end of every round of the loop, but I do it later instead.\\nI wonder which one would be faster.\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()){\\n            return false;\\n        }\\n        const int n = s.size();\\n        const int M = 26;\\n        int count[M];\\n        memset(count, 0, sizeof(count));\\n        for(int i = 0; i < n; ++i){\\n            count[t[i] - s[i] + (t[i] < s[i] ? M : 0)]++;\\n        }\\n        for(int i = 1; i < M; ++i){\\n            if((count[i] - 1) * M + i > k){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size() != t.size()){\\n            return false;\\n        }\\n        const int n = s.size();\\n        const int M = 26;\\n        int count[M];\\n        memset(count, 0, sizeof(count));\\n        for(int i = 0; i < n; ++i){\\n            count[t[i] - s[i] + (t[i] < s[i] ? M : 0)]++;\\n        }\\n        for(int i = 1; i < M; ++i){\\n            if((count[i] - 1) * M + i > k){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593356,
                "title": "can-convert-string-in-k-moves",
                "content": "bool canConvertString(string s, string t, int k) {\\n          if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n       for(int i=0;i<s.size();i++)\\n      {\\n           if(s[i]==t[i])\\n           {\\n               continue;\\n           }\\n           if(t[i]-s[i]>k)\\n           {\\n               return false;\\n           }\\n           if(t[i]-s[i]<0){\\n           if(t[i]-s[i]+26>k)\\n           {\\n               return false;\\n           }\\n           }\\n           if(t[i]-s[i]>0)\\n           mp[t[i]-s[i]]++;\\n           if(t[i]-s[i]<0)\\n           mp[t[i]-s[i]+26]++;\\n           \\n    \\n       }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(t[i]-s[i]>0)\\n            {\\n                if(mp[t[i]-s[i]]>1)\\n                {\\n                    if(26*(mp[t[i]-s[i]]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                \\n            }\\n            if(t[i]-s[i]<0)\\n            {\\n                 if(mp[t[i]-s[i]+26]>1)\\n                {\\n                    if(26+26*(mp[t[i]-s[i]+26]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;",
                "solutionTags": [],
                "code": "bool canConvertString(string s, string t, int k) {\\n          if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n       for(int i=0;i<s.size();i++)\\n      {\\n           if(s[i]==t[i])\\n           {\\n               continue;\\n           }\\n           if(t[i]-s[i]>k)\\n           {\\n               return false;\\n           }\\n           if(t[i]-s[i]<0){\\n           if(t[i]-s[i]+26>k)\\n           {\\n               return false;\\n           }\\n           }\\n           if(t[i]-s[i]>0)\\n           mp[t[i]-s[i]]++;\\n           if(t[i]-s[i]<0)\\n           mp[t[i]-s[i]+26]++;\\n           \\n    \\n       }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(t[i]-s[i]>0)\\n            {\\n                if(mp[t[i]-s[i]]>1)\\n                {\\n                    if(26*(mp[t[i]-s[i]]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n                \\n            }\\n            if(t[i]-s[i]<0)\\n            {\\n                 if(mp[t[i]-s[i]+26]>1)\\n                {\\n                    if(26+26*(mp[t[i]-s[i]+26]-1)+t[i]-s[i]>k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;",
                "codeTag": "Unknown"
            },
            {
                "id": 2542449,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length();\\n        int len2 = t.length();\\n        if (len1 != len2) {\\n            return false;\\n        }\\n        if (s.equals(t)) {\\n            return true;\\n        }\\n        int[] freq = new int[26];\\n        int multiple = k / 26;\\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = multiple;\\n        }\\n        int rem = k % 26;\\n        for (int i = 1; i <= rem; i++) {\\n            freq[i]++;\\n        }\\n        int movesRemaining = k;\\n        for (int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            if (ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            int diff = (ch2 - ch1 + 26) % 26;\\n            if (freq[diff] > 0) {\\n                freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length();\\n        int len2 = t.length();\\n        if (len1 != len2) {\\n            return false;\\n        }\\n        if (s.equals(t)) {\\n            return true;\\n        }\\n        int[] freq = new int[26];\\n        int multiple = k / 26;\\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = multiple;\\n        }\\n        int rem = k % 26;\\n        for (int i = 1; i <= rem; i++) {\\n            freq[i]++;\\n        }\\n        int movesRemaining = k;\\n        for (int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            if (ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            int diff = (ch2 - ch1 + 26) % 26;\\n            if (freq[diff] > 0) {\\n                freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467091,
                "title": "an-easy-o-26-space-solution-learn-new-tricks",
                "content": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int ns=s.length(), nt=t.length();\\n        \\n        if(ns!=nt) \\n            return false;\\n        \\n        unordered_map<int,int> un;\\n        int num = k/26, rem=k%26;\\n        \\n        for(int i=1;i<=26;i++) {\\n            un[i]+=num;\\n            if(rem>=i)\\n                un[i]++;\\n        }\\n        \\n        for(int i=0;i<ns;i++) {\\n            int diff = 0;\\n            if(s[i] > t[i]) {\\n                diff = 26+(t[i]-s[i]);\\n            }\\n            else if(s[i] < t[i]) {\\n                diff = t[i]-s[i];\\n            }\\n            if(diff!=0) {\\n                if(un[diff]>0) un[diff]--;\\n                else return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int ns=s.length(), nt=t.length();\\n        \\n        if(ns!=nt) \\n            return false;\\n        \\n        unordered_map<int,int> un;\\n        int num = k/26, rem=k%26;\\n        \\n        for(int i=1;i<=26;i++) {\\n            un[i]+=num;\\n            if(rem>=i)\\n                un[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464132,
                "title": "crisp-n-clear-o-n-javascript-runtime-100-00-meaningful-vars",
                "content": "Runtime: 85 ms, faster than 100.00% of JavaScript online submissions for Can Convert String in K Moves.\\nMemory Usage: 47.5 MB, less than 57.14% of JavaScript online submissions for Can Convert String in K Moves.\\n\\n```\\nvar canConvertString = function (str = \\'\\', target = \\'\\', k) {\\n  if (str.length !== target.length) {\\n    return false;\\n  }\\n  const config = {};\\n  for (let index = 0; index < str.length; index++) {\\n    const diff = target.charCodeAt(index) - str.charCodeAt(index);\\n\\n    if (diff === 0) {\\n      continue;\\n    }\\n    if (diff > k) {\\n      return false;\\n    }\\n    if (diff < 0) {\\n      const temp = 26 + diff;\\n      if (temp > k) {\\n        return false;\\n      }\\n      if (!config[temp]) {\\n        config[temp] = 0;\\n      }\\n      config[temp] += 1;\\n    } else {\\n      if (!config[diff]) {\\n        config[diff] = 0;\\n      }\\n      config[diff] += 1;\\n    }\\n  }\\n  for (const key in config) {\\n    if (config[key] > 1) {\\n      const temp = (config[key] - 1) * 26 + Number(key);\\n      if (k < temp) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function (str = \\'\\', target = \\'\\', k) {\\n  if (str.length !== target.length) {\\n    return false;\\n  }\\n  const config = {};\\n  for (let index = 0; index < str.length; index++) {\\n    const diff = target.charCodeAt(index) - str.charCodeAt(index);\\n\\n    if (diff === 0) {\\n      continue;\\n    }\\n    if (diff > k) {\\n      return false;\\n    }\\n    if (diff < 0) {\\n      const temp = 26 + diff;\\n      if (temp > k) {\\n        return false;\\n      }\\n      if (!config[temp]) {\\n        config[temp] = 0;\\n      }\\n      config[temp] += 1;\\n    } else {\\n      if (!config[diff]) {\\n        config[diff] = 0;\\n      }\\n      config[diff] += 1;\\n    }\\n  }\\n  for (const key in config) {\\n    if (config[key] > 1) {\\n      const temp = (config[key] - 1) * 26 + Number(key);\\n      if (k < temp) {\\n        return false;\\n      }\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431379,
                "title": "c-o-n-time-o-26-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())  return false;\\n        \\n        vector<int> moves( 27, k/26);\\n        for( int i=1; i<=k%26; i++)\\n            moves[i]+=1;\\n        \\n        for( int i=0; i<s.size(); i++){\\n            int d=(26+t[i]-s[i])%26;\\n            if(d==0)    continue;\\n            if(moves[d]==0)\\n                return false;\\n            else\\n                moves[d]-=1;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())  return false;\\n        \\n        vector<int> moves( 27, k/26);\\n        for( int i=1; i<=k%26; i++)\\n            moves[i]+=1;\\n        \\n        for( int i=0; i<s.size(); i++){\\n            int d=(26+t[i]-s[i])%26;\\n            if(d==0)    continue;\\n            if(moves[d]==0)\\n                return false;\\n            else\\n                moves[d]-=1;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430909,
                "title": "c-modulo-arithmetics",
                "content": "We compute how many times me can and we should use `(t[i] - k[i])` shift:\\n\\n```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length)\\n            return false;\\n        \\n        int[] moves = Enumerable\\n            .Range(0, 26)\\n            .Select(i => k / 26 + (i <= k % 26 ? 1 : 0))\\n            .ToArray();\\n        \\n        moves[0] = int.MaxValue;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (--moves[(t[i] - s[i] + 26) % 26] < 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if (s.Length != t.Length)\\n            return false;\\n        \\n        int[] moves = Enumerable\\n            .Range(0, 26)\\n            .Select(i => k / 26 + (i <= k % 26 ? 1 : 0))\\n            .ToArray();\\n        \\n        moves[0] = int.MaxValue;\\n        \\n        for (int i = s.Length - 1; i >= 0; --i) \\n            if (--moves[(t[i] - s[i] + 26) % 26] < 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400825,
                "title": "c-easy-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string tr, int k) {\\n        int n=s.size();\\n        if(n!=tr.size())\\n            return 0;\\n        vector<int> t(26);\\n        for(int i=0;i<26;i++)\\n            t[i]=k/26;\\n        for(int i=k%26;i>=1;i--)\\n            t[i]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tr[i]==s[i])continue;\\n            int a=(tr[i]>s[i]?tr[i]-s[i]:26-s[i]+tr[i]);\\n            if(!t[a])return 0;\\n            t[a]--;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string tr, int k) {\\n        int n=s.size();\\n        if(n!=tr.size())\\n            return 0;\\n        vector<int> t(26);\\n        for(int i=0;i<26;i++)\\n            t[i]=k/26;\\n        for(int i=k%26;i>=1;i--)\\n            t[i]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(tr[i]==s[i])continue;\\n            int a=(tr[i]>s[i]?tr[i]-s[i]:26-s[i]+tr[i]);\\n            if(!t[a])return 0;\\n            t[a]--;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343164,
                "title": "c",
                "content": "```\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        \\n        int ans = 0;\\n        vector<int> bucket(26);\\n        for (int i = 0; i < s.size(); ++ i){\\n            if (s[i] == t[i]) continue;\\n            int temp = (-s[i] + t[i]) > 0 ? (-s[i] + t[i]) : (-s[i] + t[i]) + 26;\\n            ans = max(ans, (bucket[temp]) * 26 + temp);\\n            bucket[temp] ++;\\n        }\\n        \\n        return ans <= k;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) return false;\\n        \\n        int ans = 0;\\n        vector<int> bucket(26);\\n        for (int i = 0; i < s.size(); ++ i){\\n            if (s[i] == t[i]) continue;\\n            int temp = (-s[i] + t[i]) > 0 ? (-s[i] + t[i]) : (-s[i] + t[i]) + 26;\\n            ans = max(ans, (bucket[temp]) * 26 + temp);\\n            bucket[temp] ++;\\n        }\\n        \\n        return ans <= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2341667,
                "title": "intuitive-do-as-hints-say-corner-cases",
                "content": "```\\nclass Solution {\\n    \\n    int dis(char s, char t) {\\n        return (t - s + 26) % 26;\\n    }\\n    \\n    vector<int> get_dis(const string& s, const string& t) {\\n        int len = s.size();\\n        vector<int> res(26);\\n        for (int i = 0; i < len; ++i) {\\n            res[dis(s[i], t[i])]++;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if (s.size() != t.size()) return false;\\n        \\n        auto distances = get_dis(s, t);\\n        for (int i = 1; i < distances.size(); ++i) {\\n            if (i + (distances[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dis(char s, char t) {\\n        return (t - s + 26) % 26;\\n    }\\n    \\n    vector<int> get_dis(const string& s, const string& t) {\\n        int len = s.size();\\n        vector<int> res(26);\\n        for (int i = 0; i < len; ++i) {\\n            res[dis(s[i], t[i])]++;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if (s.size() != t.size()) return false;\\n        \\n        auto distances = get_dis(s, t);\\n        for (int i = 1; i < distances.size(); ++i) {\\n            if (i + (distances[i] - 1) * 26 > k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331947,
                "title": "c-98-optimised-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int n=s.size();\\n        vector<int>v(26);\\n        int diff;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<t[i]-s[i]\\n            if(s[i]!=t[i])\\n            {\\n                diff=t[i]-s[i];\\n                // cout<<\"i , diff : \"<<i<<\" \"<<diff<<endl;\\n                if(diff>0)\\n                {\\n                    v[diff]=v[diff]+1;\\n                }\\n                else \\n                {\\n                    v[26+diff]=v[26+diff]+1;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<26;i++) cout<<i<<\" \"<<v[i]<<endl;\\n        int maxi=-1;\\n        for(int i=1;i<=25;i++)\\n        {\\n            if(v[i]>0)\\n            {\\n                // cout<<\"v[i] : \"<<v[i]<<endl;\\n                int step=((v[i]-1)*26)+i;\\n                // cout<<\"step : \"<<step<<endl;\\n                maxi=max(maxi,step);\\n            }\\n        }\\n        if(maxi<=k) return true;\\n        else return false;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        int n=s.size();\\n        vector<int>v(26);\\n        int diff;\\n        for(int i=0;i<n;i++)\\n        {\\n            // cout<<t[i]-s[i]\\n            if(s[i]!=t[i])\\n            {\\n                diff=t[i]-s[i];\\n                // cout<<\"i , diff : \"<<i<<\" \"<<diff<<endl;\\n                if(diff>0)\\n                {\\n                    v[diff]=v[diff]+1;\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 2302803,
                "title": "c-solution-with-explanation",
                "content": "```\\n/*\\n\\n    actually here, the k value represents the maximum difference we can use\\n    to go from a to b - we can start from a and reach b in one step \\n                      - we can start from a, complete a full circle, and come back to a, then take 1 step to reach b (1 + 26 steps)\\n                      - we can start from a, complete 2 full circles, and come back to a, then take 1 step to reach b (1 + 2*26 steps)\\n                      - if we take m circles then, we will take 1 + m*26 steps\\n                      \\n   notice that to transform s[i] to t[i], the number of circles, we will have to take is the number of occurrences of the difference \\n   (t[i] - s[i] + 26) % 26 [this is actually the circular difference between s[i] and t[i] (angular displacement*r)] \\n   like if we want to convert x to a, then the shortest path in ciruclar fashion will be (a - x + 26) % 26 = (-23 + 26) % 26 = 3\\n   \\n   \\n   for example \\n   a a b\\n   b b b\\n   \\n   for converting the first a to b, we used 1 step\\n   now for converting the second a to b, we will have to use the next available option : that is [1 + 1*26] = 27\\n   so at each point, check if diff + cnt[diff]*26 <= k, if it is you can change it to t[i] else not\\n                      \\n\\n*/\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n            \\n        if(s.length() != t.length()) return false;\\n        \\n        int cnt[26]{0};\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = (t[i] - s[i] + 26) % 26;\\n            if(diff + cnt[diff]*26 > k) return false;\\n            cnt[diff]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\n    actually here, the k value represents the maximum difference we can use\\n    to go from a to b - we can start from a and reach b in one step \\n                      - we can start from a, complete a full circle, and come back to a, then take 1 step to reach b (1 + 26 steps)\\n                      - we can start from a, complete 2 full circles, and come back to a, then take 1 step to reach b (1 + 2*26 steps)\\n                      - if we take m circles then, we will take 1 + m*26 steps\\n                      \\n   notice that to transform s[i] to t[i], the number of circles, we will have to take is the number of occurrences of the difference \\n   (t[i] - s[i] + 26) % 26 [this is actually the circular difference between s[i] and t[i] (angular displacement*r)] \\n   like if we want to convert x to a, then the shortest path in ciruclar fashion will be (a - x + 26) % 26 = (-23 + 26) % 26 = 3\\n   \\n   \\n   for example \\n   a a b\\n   b b b\\n   \\n   for converting the first a to b, we used 1 step\\n   now for converting the second a to b, we will have to use the next available option : that is [1 + 1*26] = 27\\n   so at each point, check if diff + cnt[diff]*26 <= k, if it is you can change it to t[i] else not\\n                      \\n\\n*/\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n            \\n        if(s.length() != t.length()) return false;\\n        \\n        int cnt[26]{0};\\n        for(int i = 0; i < s.length(); i++) {\\n            if(s[i] == t[i]) continue;\\n            int diff = (t[i] - s[i] + 26) % 26;\\n            if(diff + cnt[diff]*26 > k) return false;\\n            cnt[diff]++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268872,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int val=0;\\n        if(s.size()!=t.size())return false;\\n        unordered_map<int,int>m;//it contains the number of times diff appeared\\n        for(int i=0;i<s.size();i++){\\n            int diff=t[i]-s[i];\\n            if(diff==0)continue;\\n            if(diff<0)diff+=26;\\n            if(m[diff]*26+diff>k)return false;\\n            m[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int val=0;\\n        if(s.size()!=t.size())return false;\\n        unordered_map<int,int>m;//it contains the number of times diff appeared\\n        for(int i=0;i<s.size();i++){\\n            int diff=t[i]-s[i];\\n            if(diff==0)continue;\\n            if(diff<0)diff+=26;\\n            if(m[diff]*26+diff>k)return false;\\n            m[diff]++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260349,
                "title": "easy-to-understand-o-n-c",
                "content": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        \\n        if(s.Length!=t.Length) return false;\\n        var map = new int[27];\\n        \\n        var whole = k/26;\\n        var partial = k%26;\\n        \\n        //Fill values with available replaces\\n        // a => b can happen with 1 or 27 so we can count 27 as 1\\n        for(int i=1; i<=26; i++)\\n        {\\n            map[i] = whole;\\n            if(i<=partial) map[i]++;\\n        }\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            //(t[i] - s[i]) =>  a->z. => 26-1 => 25\\n            //(t[i] - s[i] + 26) => z -> a  => 1 - 26 + 26 => 1\\n            var diff = (t[i] - s[i]) >= 0 ? (t[i] - s[i]) : (t[i] - s[i] + 26);\\n            \\n            //If difference is 0 then we don\\'t need to do anything\\n            if(diff== 0) continue;\\n            \\n            //If we don\\'t have any replace available\\n            if(map[diff] <= 0) return false;\\n            map[diff]--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        \\n        if(s.Length!=t.Length) return false;\\n        var map = new int[27];\\n        \\n        var whole = k/26;\\n        var partial = k%26;\\n        \\n        //Fill values with available replaces\\n        // a => b can happen with 1 or 27 so we can count 27 as 1\\n        for(int i=1; i<=26; i++)\\n        {\\n            map[i] = whole;\\n            if(i<=partial) map[i]++;\\n        }\\n        \\n        for(int i=0; i<s.Length; i++)\\n        {\\n            //(t[i] - s[i]) =>  a->z. => 26-1 => 25\\n            //(t[i] - s[i] + 26) => z -> a  => 1 - 26 + 26 => 1\\n            var diff = (t[i] - s[i]) >= 0 ? (t[i] - s[i]) : (t[i] - s[i] + 26);\\n            \\n            //If difference is 0 then we don\\'t need to do anything\\n            if(diff== 0) continue;\\n            \\n            //If we don\\'t have any replace available\\n            if(map[diff] <= 0) return false;\\n            map[diff]--;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238035,
                "title": "can-convert-string-in-k-moves",
                "content": "### \\tC++ \\n\\t\\n\\tbool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()){\\n            return false;\\n        }\\n        \\n        int n = s.length();\\n    \\n        int arr[26]={};\\n        \\n        for(int i = 0;i<n;i++){\\n            int diff = t[i]-s[i] + (t[i]>=s[i] ? 0 : 26);\\n            if(diff==0) {\\n                continue;\\n            }    \\n            if(arr[diff]*26 + diff >k){\\n                return false;\\n            }\\n            ++arr[diff];\\n        }\\n        return true;\\n        \\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "### \\tC++ \\n\\t\\n\\tbool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()){\\n            return false;\\n        }\\n        \\n        int n = s.length();\\n    \\n        int arr[26]={};\\n        \\n        for(int i = 0;i<n;i++){\\n            int diff = t[i]-s[i] + (t[i]>=s[i] ? 0 : 26);\\n            if(diff==0) {\\n                continue;\\n            }    \\n            if(arr[diff]*26 + diff >k){\\n                return false;\\n            }\\n            ++arr[diff];\\n        }\\n        return true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2222696,
                "title": "c-compare-moves-needed-to-available-moves",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        \\n        vector<int> diffCount(26,0);\\n        for(int i=0;i<s.size();++i) diffCount[(t[i]-s[i]+26)%26]++;\\n        \\n        int repeat = k/26, remain = k%26;\\n        vector<int> diffCountAvailable(26,repeat);\\n        for(int i=1;i<=remain;++i) diffCountAvailable[i]++;\\n        \\n        for(int i=1;i<diffCount.size();++i) \\n            if(diffCount[i]>diffCountAvailable[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return false;\\n        \\n        vector<int> diffCount(26,0);\\n        for(int i=0;i<s.size();++i) diffCount[(t[i]-s[i]+26)%26]++;\\n        \\n        int repeat = k/26, remain = k%26;\\n        vector<int> diffCountAvailable(26,repeat);\\n        for(int i=1;i<=remain;++i) diffCountAvailable[i]++;\\n        \\n        for(int i=1;i<diffCount.size();++i) \\n            if(diffCount[i]>diffCountAvailable[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155709,
                "title": "python-3-simple-o-n-o-1-solution",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        cycles, extra = divmod(k, 26)\\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\\n\\n        for cs, ct in zip(s, t):\\n            shift = (ord(ct) - ord(cs)) % 26\\n            if shift == 0:\\n                continue\\n            if not shifts[shift]:\\n                return False\\n            shifts[shift] -= 1\\n        \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        cycles, extra = divmod(k, 26)\\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\\n\\n        for cs, ct in zip(s, t):\\n            shift = (ord(ct) - ord(cs)) % 26\\n            if shift == 0:\\n                continue\\n            if not shifts[shift]:\\n                return False\\n            shifts[shift] -= 1\\n        \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2131454,
                "title": "interesting-trick-for-an-interesting-question",
                "content": "```cpp\\nif (s.size() != t.size())\\n\\treturn false;\\n\\n// count the quota of every possible shift 1 ~ 25 given by k wrapping around 26.\\nint q = k / 26;\\nint r = k % 26;\\n\\nvector<int> quota(26, q);\\n\\nfor (int i = 0; i <= r; ++i)\\n\\t++ quota[i];\\n\\n// compare each char\\nfor (int i = 0; i < s.size(); ++i)\\n{\\n\\t// find the difference\\n\\tint d = (t[i] - s[i] + 26) % 26;\\n\\t\\n\\t// skip when d == 0\\n\\t// if run out of quota of any d, sad, can not convert.\\n\\tif (d && -- quota[d] < 0)\\n\\t\\treturn false;\\n}\\n\\nreturn true;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nif (s.size() != t.size())\\n\\treturn false;\\n\\n// count the quota of every possible shift 1 ~ 25 given by k wrapping around 26.\\nint q = k / 26;\\nint r = k % 26;\\n\\nvector<int> quota(26, q);\\n\\nfor (int i = 0; i <= r; ++i)\\n\\t++ quota[i];\\n\\n// compare each char\\nfor (int i = 0; i < s.size(); ++i)\\n{\\n\\t// find the difference\\n\\tint d = (t[i] - s[i] + 26) % 26;\\n\\t\\n\\t// skip when d == 0\\n\\t// if run out of quota of any d, sad, can not convert.\\n\\tif (d && -- quota[d] < 0)\\n\\t\\treturn false;\\n}\\n\\nreturn true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106259,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} k\\n * @return {boolean}\\n */\\n var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            // exclude special case 0\\n            if(r > 0){\\n                // Considering repeated letters, the unrepeated move should change to r + 26*n (n>=0)\\n                // use hash table to count the same letter\\n                if(!countMap.has(r)){\\n\\t\\t\\t\\t    // first time to move\\n                    countMap.set(r, 1);\\n                    tmp.push(r);\\n                }else{\\n\\t\\t\\t\\t    // n time to move, n means the count of the same letter\\n                    let c = countMap.get(r);\\n                    tmp.push(r + c * 26);\\n\\t\\t\\t\\t\\t// update count\\n                    countMap.set(r, c+1);\\n                }\\n            }\\n        }\\n        // check all possible move in range\\n        for(let i=0; i<tmp.length; i++){\\n            let t = tmp[i];\\n            if(t > k){\\n                res = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        res = false;\\n    }\\n    \\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @param {number} k\\n * @return {boolean}\\n */\\n var canConvertString = function(s, t, k) {\\n    let res = true;\\n    if(s.length === t.length){\\n        let tmp = [];\\n        let countMap = new Map();\\n        for(let i=0; i<s.length; i++){\\n            let n1 = s[i].charCodeAt();\\n            let n2 = t[i].charCodeAt();\\n            let r = n2 - n1;\\n            if(r < 0){\\n                r += 26;\\n            }\\n            // exclude special case 0\\n            if(r > 0){\\n                // Considering repeated letters, the unrepeated move should change to r + 26*n (n>=0)\\n                // use hash table to count the same letter\\n                if(!countMap.has(r)){\\n\\t\\t\\t\\t    // first time to move\\n                    countMap.set(r, 1);\\n                    tmp.push(r);\\n                }else{\\n\\t\\t\\t\\t    // n time to move, n means the count of the same letter\\n                    let c = countMap.get(r);\\n                    tmp.push(r + c * 26);\\n\\t\\t\\t\\t\\t// update count\\n                    countMap.set(r, c+1);\\n                }\\n            }\\n        }\\n        // check all possible move in range\\n        for(let i=0; i<tmp.length; i++){\\n            let t = tmp[i];\\n            if(t > k){\\n                res = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        res = false;\\n    }\\n    \\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2103358,
                "title": "check-is-the-shift-possible-within-k-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        vector<int> vec(26, 0); // distance between characters is in  [0,25]\\n        for(int i=0; i<s.size(); i++){\\n            int d= (int)t[i]- (int)s[i]; // distance between ith characters in strings  s, t\\n            if(d<0){\\n                d+=26; // as  d cannot be negative\\n            }\\n            if(d!=0){\\n                if(vec[d]*26+d<=k){ // d+ 26*n is the move required where n can be 0, 1, 2...\\n\\t\\t\\t\\t//we keep track of n for given \\'d\\' in vec[d] when ever this vec[d]*26+d<=k  condition fails we \\n\\t\\t\\t\\t//output false as we cannot find a move that can shift our character our character by d!\\n                    vec[d]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        vector<int> vec(26, 0); // distance between characters is in  [0,25]\\n        for(int i=0; i<s.size(); i++){\\n            int d= (int)t[i]- (int)s[i]; // distance between ith characters in strings  s, t\\n            if(d<0){\\n                d+=26; // as  d cannot be negative\\n            }\\n            if(d!=0){\\n                if(vec[d]*26+d<=k){ // d+ 26*n is the move required where n can be 0, 1, 2...\\n\\t\\t\\t\\t//we keep track of n for given \\'d\\' in vec[d] when ever this vec[d]*26+d<=k  condition fails we \\n\\t\\t\\t\\t//output false as we cannot find a move that can shift our character our character by d!\\n                    vec[d]++;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081314,
                "title": "javascript-step-check-176ms",
                "content": "```\\nconst ord = (c) => c.charCodeAt();\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst canConvertString = (s, t, k) => {\\n    if (s.length != t.length) return false;\\n    let n = s.length, step = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) { // calculate each step move\\n        if (s[i] <= t[i]) {\\n            step[i] = ord(t[i]) - ord(s[i]);\\n        } else {\\n            step[i] = 122 - ord(s[i]) + 1 + ord(t[i]) - 97;  // s[i] -> \\'z\\' -> \\'a\\' -> t[i]\\n        }\\n    }\\n    let m = counter(step);\\n    for (const [x, occ] of m) {\\n        if (x == 0) continue;\\n        if (x > k) return false; // over k cannot move\\n        let can = parseInt((k - x) / 26) + 1; // possible all different moves  x + 26 * (1, 2, 3 ......)\\n        if (occ > can) return false; // under k, but can doesn\\'t enough for occurrence\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst ord = (c) => c.charCodeAt();\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst canConvertString = (s, t, k) => {\\n    if (s.length != t.length) return false;\\n    let n = s.length, step = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) { // calculate each step move\\n        if (s[i] <= t[i]) {\\n            step[i] = ord(t[i]) - ord(s[i]);\\n        } else {\\n            step[i] = 122 - ord(s[i]) + 1 + ord(t[i]) - 97;  // s[i] -> \\'z\\' -> \\'a\\' -> t[i]\\n        }\\n    }\\n    let m = counter(step);\\n    for (const [x, occ] of m) {\\n        if (x == 0) continue;\\n        if (x > k) return false; // over k cannot move\\n        let can = parseInt((k - x) / 26) + 1; // possible all different moves  x + 26 * (1, 2, 3 ......)\\n        if (occ > can) return false; // under k, but can doesn\\'t enough for occurrence\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2069898,
                "title": "simple-python-solution-space-o-1-time-o-n",
                "content": "**Steps:**\\n1. Check if the length for strings are equal. If not, then return False.\\n2. Store the counts of difference from s[i] to t[i].\\n3. Multiply the count by 26 and add the difference if s[i] != t[i]. This is done because for the first occurence of the difference, we need to add it. And for extra occurences of the difference, we need to add 26 to it each time so that i(mentioned in the question) would be unique for each occurrence.\\n4. If the above value is more than k then return False.\\n5. If the whole string gets parsed, return True.\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        #If length of strings are different return False\\n        if len(s) != len(t):\\n            return False\\n        \\n        check = [0]*26  #List which stores counts of t[i] - s[i]\\n        \\n        #Storing counts of t[i] - s[i] for 0 <= i < len(s)\\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                temp = ( ord(t[i]) - ord(s[i]) ) % 26\\n                big = temp + 26*check[temp]\\n                check[temp] += 1\\n                if big > k:\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \\n        #If length of strings are different return False\\n        if len(s) != len(t):\\n            return False\\n        \\n        check = [0]*26  #List which stores counts of t[i] - s[i]\\n        \\n        #Storing counts of t[i] - s[i] for 0 <= i < len(s)\\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                temp = ( ord(t[i]) - ord(s[i]) ) % 26\\n                big = temp + 26*check[temp]\\n                check[temp] += 1\\n                if big > k:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069204,
                "title": "easy-o-n-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer, Integer> mp=new HashMap();\\n        if(s.length()!=t.length())return false;\\n        for(int i=0;i<s.length();i++){\\n            int temp = 0;\\n            if((int)(s.charAt(i))<(int)(t.charAt(i))){\\n                temp = (int)(t.charAt(i))-(int)(s.charAt(i));\\n                if(!mp.containsKey(temp))mp.put(temp,1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else if((int)(s.charAt(i))>(int)(t.charAt(i))){\\n                temp = 26 - s.charAt(i) + t.charAt(i);\\n                if(!mp.containsKey(temp))mp.put(temp, 1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else continue;\\n        }\\n        for(int i:mp.keySet()){\\n            int fre = mp.get(i);\\n            int temp = i + (fre-1)*26;\\n            if(temp>k)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer, Integer> mp=new HashMap();\\n        if(s.length()!=t.length())return false;\\n        for(int i=0;i<s.length();i++){\\n            int temp = 0;\\n            if((int)(s.charAt(i))<(int)(t.charAt(i))){\\n                temp = (int)(t.charAt(i))-(int)(s.charAt(i));\\n                if(!mp.containsKey(temp))mp.put(temp,1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else if((int)(s.charAt(i))>(int)(t.charAt(i))){\\n                temp = 26 - s.charAt(i) + t.charAt(i);\\n                if(!mp.containsKey(temp))mp.put(temp, 1);\\n                else mp.put(temp,mp.get(temp)+1);\\n            }\\n            else continue;\\n        }\\n        for(int i:mp.keySet()){\\n            int fre = mp.get(i);\\n            int temp = i + (fre-1)*26;\\n            if(temp>k)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037161,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.length()!=t.length()) return false;\\n        \\n        vector<pair<int,int>> v(27, {0,0});\\n        \\n        long long maxK = -1;\\n        for(int i=0; i<s.length(); i++) {\\n            long long diff;\\n            if(s[i] == t[i]) {\\n                continue;\\n            } else if(s[i] < t[i]) {\\n                diff = t[i] - s[i];\\n            } else {\\n                diff = 26 - (s[i] - t[i]);\\n            }\\n            \\n            if(v[diff].first == 0) {\\n                v[diff].first = 1;\\n                maxK = max(maxK, diff);\\n            } else {\\n                v[diff].second += 1;\\n                diff = 26*v[diff].second + diff;\\n                maxK = max(maxK, diff);\\n            }\\n        }\\n        return (maxK>k)?false:true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        \\n        if(s.length()!=t.length()) return false;\\n        \\n        vector<pair<int,int>> v(27, {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2008682,
                "title": "declarative-ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {String} s\\n# @param {String} t\\n# @param {Integer} k\\n# @return {Boolean}\\ndef can_convert_string(s, t, k)\\n  s.size == t.size && t.bytes.zip(s.bytes).map { (_1 - _2) % 26 }.tally.all? { _1 == 0 || _2 <= (k - _1) / 26 + 1 }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @param {String} t\\n# @param {Integer} k\\n# @return {Boolean}\\ndef can_convert_string(s, t, k)\\n  s.size == t.size && t.bytes.zip(s.bytes).map { (_1 - _2) % 26 }.tally.all? { _1 == 0 || _2 <= (k - _1) / 26 + 1 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1925423,
                "title": "c-very-fast-and-memory-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        int n = s.length();\\n        vector<int> v(26);\\n        for(int i=0;i<n;i++){\\n            if(s[i]<=t[i]) v[t[i]-s[i]]++;\\n            else{\\n                int d1 = \\'z\\' - s[i];\\n                int d2 = t[i] -\\'a\\' + 1;\\n                v[d1+d2]++;\\n            }\\n        }\\n        for(int i=1;i<26;i++){\\n            if(v[i]){\\n                int q = k/26;\\n                int r = k%26;\\n                if(r>=i) q += 1;\\n                if(v[i]>q) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length()) return false;\\n        int n = s.length();\\n        vector<int> v(26);\\n        for(int i=0;i<n;i++){\\n            if(s[i]<=t[i]) v[t[i]-s[i]]++;\\n            else{\\n                int d1 = \\'z\\' - s[i];\\n                int d2 = t[i] -\\'a\\' + 1;\\n                v[d1+d2]++;\\n            }\\n        }\\n        for(int i=1;i<26;i++){\\n            if(v[i]){\\n                int q = k/26;\\n                int r = k%26;\\n                if(r>=i) q += 1;\\n                if(v[i]>q) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892437,
                "title": "python3-o-n-simple-to-understand",
                "content": "* just get an array of the shift values and if the shift value has been seen \\'n\\' times, the largest move we need is:\\n\\t* shift value + \\'n\\' * 26\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t): return False\\n        arr=[ord(b)-ord(a) if b>a else 26-(ord(a)-ord(b)) for a,b in zip(s,t) if a!=b]\\n        dct=collections.Counter()\\n        for el in arr:\\n            if el+dct[el]*26>k: return False\\n            dct[el]+=1\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s)!=len(t): return False\\n        arr=[ord(b)-ord(a) if b>a else 26-(ord(a)-ord(b)) for a,b in zip(s,t) if a!=b]\\n        dct=collections.Counter()\\n        for el in arr:\\n            if el+dct[el]*26>k: return False\\n            dct[el]+=1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889772,
                "title": "hashmap",
                "content": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (t.charAt(i) == s.charAt(i)) continue;\\n            else if (t.charAt(i) - s.charAt(i) > 0) {\\n                var c = t.charAt(i) - s.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            } else {\\n                var c = 26 - s.charAt(i) + t.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        \\n        var used = new HashSet<Integer>();\\n        for (var it : map.entrySet()) {\\n            var next = it.getKey();\\n            \\n            for (int i = it.getValue(); i > 0; i--) {\\n                while(used.contains(next)) next += 26;\\n                \\n                if (next > k) return false;\\n                else used.add(next);\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canConvertString(String s, String t, int k) {\\n        if (s.length() != t.length()) return false;\\n        \\n        var map = new HashMap<Integer, Integer>();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            if (t.charAt(i) == s.charAt(i)) continue;\\n            else if (t.charAt(i) - s.charAt(i) > 0) {\\n                var c = t.charAt(i) - s.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            } else {\\n                var c = 26 - s.charAt(i) + t.charAt(i);\\n                map.put(c, map.getOrDefault(c, 0) + 1);\\n            }\\n        }\\n        \\n        var used = new HashSet<Integer>();\\n        for (var it : map.entrySet()) {\\n            var next = it.getKey();\\n            \\n            for (int i = it.getValue(); i > 0; i--) {\\n                while(used.contains(next)) next += 26;\\n                \\n                if (next > k) return false;\\n                else used.add(next);\\n            }   \\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870337,
                "title": "c-freq",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) {\\n            return false;\\n        }\\n        \\n        int shifts[26] = {0};\\n        for (int i = 1; i < 26; ++i) {\\n            shifts[i] = k / 26 + (i <= (k % 26));\\n        }\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n\\t\\t    auto idx = t[i] - s[i] + (s[i] < t[i] ? 0 : 26);\\n            if (s[i] != t[i] && --shifts[idx] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if (s.size() != t.size()) {\\n            return false;\\n        }\\n        \\n        int shifts[26] = {0};\\n        for (int i = 1; i < 26; ++i) {\\n            shifts[i] = k / 26 + (i <= (k % 26));\\n        }\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n\\t\\t    auto idx = t[i] - s[i] + (s[i] < t[i] ? 0 : 26);\\n            if (s[i] != t[i] && --shifts[idx] < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774010,
                "title": "java-sharing-code",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        if(s.length()!=t.length())\\n            return false;\\n        int[] arr = new int [26];\\n        int mini = k/26;\\n        int limit = k%26;\\n        for(int i=0;i<26;i++){\\n            arr[i]=mini;\\n            if(limit>=i)\\n                arr[i]++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt = ((t.charAt(i)-s.charAt(i))+26)%26;\\n            if(cnt==0)\\n                continue;\\n            arr[cnt]--;\\n            if(arr[cnt]<0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        if(s.length()!=t.length())\\n            return false;\\n        int[] arr = new int [26];\\n        int mini = k/26;\\n        int limit = k%26;\\n        for(int i=0;i<26;i++){\\n            arr[i]=mini;\\n            if(limit>=i)\\n                arr[i]++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int cnt = ((t.charAt(i)-s.charAt(i))+26)%26;\\n            if(cnt==0)\\n                continue;\\n            arr[cnt]--;\\n            if(arr[cnt]<0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711905,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int size=s.size(),n=t.size();\\n        if(size!=n)\\n            return false;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<size;i++){\\n            int dist=t[i]-s[i];\\n            dist+=(dist<0)?26:0;\\n            if(dist==0)\\n                continue;\\n            cnt[dist]++;\\n        }\\n        for(auto & p:cnt){\\n           int maxi=26*(p.second-1)+p.first; \\n            if(maxi>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n     int size=s.size(),n=t.size();\\n        if(size!=n)\\n            return false;\\n        unordered_map<int,int>cnt;\\n        for(int i=0;i<size;i++){\\n            int dist=t[i]-s[i];\\n            dist+=(dist<0)?26:0;\\n            if(dist==0)\\n                continue;\\n            cnt[dist]++;\\n        }\\n        for(auto & p:cnt){\\n           int maxi=26*(p.second-1)+p.first; \\n            if(maxi>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707045,
                "title": "easy-explained-solution-using-map",
                "content": "1. If length( s ) and length( t ) are not equal, then it\\'ll never be possible to convert, because we are not allowed to add or remove character from the strings. Hence ans = false.\\n\\nWe want to store remainder, as well as frequency into the map.\\nEx.1. For \\'a\\' to \\'z\\' conversion, \\'z\\' - \\'a\\' = 25, Added with 26 and take mod 26, rem = (25+26)%26 = 25.\\nEx.2. For \\'z\\' to \\'a\\' conversion, \\'a\\' - \\'z\\' = -25, added 26 and take mod 26, rem = (-25+26)%26 = 1.\\nSo 26 is added to avoid negative remainder, as we are only allowed to move forword.\\n\\n2. Ex.3. For s = \\'aaab\\' to t = \\'bbbb\\' conversion, we want three \\'a\\' to \\'b\\' conversion.\\nSo, rem = (\\'b\\'-\\'a\\'+26)%26 = 1, frequency = 3.\\nfor s[0] = \\'a\\' to t[0] = \\'b\\', we need 1st move, we use 1st move,\\nfor s[1] = \\'a\\' to t[1] = \\'b\\', we need 1st move too, we use (1+(26\\\\*1) ) = 27th move,\\nfor s[2] = \\'a\\' to t[2] = \\'b\\', we need 1st move too, we use (1+(26\\\\*2) ) = 53rd move,\\nHence, if for a particular remainder frequency = \\'x\\', we\\'re gonna check, if \\'(x-1)\\\\*26 + rem\\' belongs to the range [0, k] or not.\\nSo, we directly check for 53 <= k, if not, then ans = false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int> mp;\\n        int n = s.size(), i, rem, freq;\\n        if( t.size() != n )return false;\\n        for( i = 0; i < n; i++ ){\\n            if( s[i] == t[i] )continue;\\n            rem = ( t[i] - s[i] + 26)%26;\\n            mp[rem]++;\\n        }\\n        for( auto& x : mp ){\\n            rem = x.first;\\n            freq = x.second;\\n            if( ( freq-1 )*26 + rem > k )return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nFeel free to comment and upvote ;)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int> mp;\\n        int n = s.size(), i, rem, freq;\\n        if( t.size() != n )return false;\\n        for( i = 0; i < n; i++ ){\\n            if( s[i] == t[i] )continue;\\n            rem = ( t[i] - s[i] + 26)%26;\\n            mp[rem]++;\\n        }\\n        for( auto& x : mp ){\\n            rem = x.first;\\n            freq = x.second;\\n            if( ( freq-1 )*26 + rem > k )return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701407,
                "title": "easy-map-set-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int>hash;\\n        unordered_set<int>umap;\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == t[i]){\\n                continue;\\n            }\\n            int a = ((t[i]-\\'a\\')-(s[i]-\\'a\\') + 26)%26;\\n            hash[a]++;\\n        }\\n       \\n        for(auto x : hash){\\n            int move = (k/26);\\n            if(k%26 and x.first<=k%26){\\n                move++;\\n            }\\n            cout << move << endl;\\n            if(move < x.second or umap.count(x.first)){\\n                return false;\\n            }\\n            umap.insert(x.first);\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int, int>hash;\\n        unordered_set<int>umap;\\n        if(s.length() != t.length()){\\n            return false;\\n        }\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == t[i]){\\n                continue;\\n            }\\n            int a = ((t[i]-\\'a\\')-(s[i]-\\'a\\') + 26)%26;\\n            hash[a]++;\\n        }\\n       \\n        for(auto x : hash){\\n            int move = (k/26);\\n            if(k%26 and x.first<=k%26){\\n                move++;\\n            }\\n            cout << move << endl;\\n            if(move < x.second or umap.count(x.first)){\\n                return false;\\n            }\\n            umap.insert(x.first);\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1668896,
                "title": "c-linq-one-liner-o-n-time",
                "content": "```\\npublic class Solution \\n{\\n    public bool CanConvertString(string s, string t, int k) \\n        => s.Length == t.Length && \\n           s.Zip(t, (c1, c2) => (26 + c2 - c1) % 26)\\n            .GroupBy(x => x)\\n            .All(g => g.Key == 0 || (g.Count() - 1) * 26 + g.Key <= k);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool CanConvertString(string s, string t, int k) \\n        => s.Length == t.Length && \\n           s.Zip(t, (c1, c2) => (26 + c2 - c1) % 26)\\n            .GroupBy(x => x)\\n            .All(g => g.Key == 0 || (g.Count() - 1) * 26 + g.Key <= k);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667151,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer,Character> set=new HashMap<>();\\n        int n=s.length();\\n        int m=t.length();\\n        if(m!=n)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            char x=s.charAt(i);\\n            char y=t.charAt(i);\\n            int key=(y-x);\\n            if(key<0)\\n            {\\n                key=key+26;\\n            }\\n            else if(key==0)\\n                continue;\\n            if(key>k)\\n                return false;\\n            else if(set.containsKey(key))\\n            {\\n                while(set.containsKey(key))\\n                {\\n                    key=getNum(key);\\n                    if(key>k)\\n                        return false;\\n                }\\n                set.put(key,x);\\n            }\\n            else if(!set.containsKey(key))\\n            {\\n                set.put(key,x);\\n            }\\n            \\n            \\n        }\\n        return true;\\n        \\n        \\n    }\\n    public int getNum(int m)\\n    {\\n        return (26+m);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        HashMap<Integer,Character> set=new HashMap<>();\\n        int n=s.length();\\n        int m=t.length();\\n        if(m!=n)\\n            return false;\\n        for(int i=0;i<n;i++)\\n        {\\n            char x=s.charAt(i);\\n            char y=t.charAt(i);\\n            int key=(y-x);\\n            if(key<0)\\n            {\\n                key=key+26;\\n            }\\n            else if(key==0)\\n                continue;\\n            if(key>k)\\n                return false;\\n            else if(set.containsKey(key))\\n            {\\n                while(set.containsKey(key))\\n                {\\n                    key=getNum(key);\\n                    if(key>k)\\n                        return false;\\n                }\\n                set.put(key,x);\\n            }\\n            else if(!set.containsKey(key))\\n            {\\n                set.put(key,x);\\n            }\\n            \\n            \\n        }\\n        return true;\\n        \\n        \\n    }\\n    public int getNum(int m)\\n    {\\n        return (26+m);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666195,
                "title": "golang-o-n-count-group-by-shift-move",
                "content": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    count := make([]int, 26)\\n    for i := range s {\\n        var d byte\\n        if s[i] <= t[i] {\\n            d = t[i] - s[i]\\n        } else {\\n            d = t[i] + 26 - s[i]\\n        }\\n        \\n        if int(d) > k {\\n            return false\\n        }\\n        \\n        count[d]++\\n    }\\n    \\n    for i := 1; i < 26; i++ {\\n        if count[i] > 0 {\\n            if max := i + int(count[i] - 1) * 26; max > k {\\n                return false\\n            }\\n        }\\n    } \\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    count := make([]int, 26)\\n    for i := range s {\\n        var d byte\\n        if s[i] <= t[i] {\\n            d = t[i] - s[i]\\n        } else {\\n            d = t[i] + 26 - s[i]\\n        }\\n        \\n        if int(d) > k {\\n            return false\\n        }\\n        \\n        count[d]++\\n    }\\n    \\n    for i := 1; i < 26; i++ {\\n        if count[i] > 0 {\\n            if max := i + int(count[i] - 1) * 26; max > k {\\n                return false\\n            }\\n        }\\n    } \\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660061,
                "title": "count-req-and-available-operations",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        \\n        vector<int> req(26,0);\\n        for(int i=0;i<s.size();i++){\\n            req[(t[i]-s[i]+26)%26]++;\\n        }\\n        vector<int> avail(26,(k+1)/26);\\n        int temp=k%26;\\n        \\n        for(int j=1;j<=temp;j++) avail[j]++;\\n        \\n        for(int i=1;i<26;i++){\\n            if(req[i]>avail[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size()) return 0;\\n        \\n        vector<int> req(26,0);\\n        for(int i=0;i<s.size();i++){\\n            req[(t[i]-s[i]+26)%26]++;\\n        }\\n        vector<int> avail(26,(k+1)/26);\\n        int temp=k%26;\\n        \\n        for(int j=1;j<=temp;j++) avail[j]++;\\n        \\n        for(int i=1;i<26;i++){\\n            if(req[i]>avail[i]) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654414,
                "title": "golang",
                "content": "some examples to calc char offset:\\n\\ns[i] -> t[i]\\n\\n\\'a\\' -> \\'c\\' = 2 - 0 = 2 moves\\n\\n\\'c\\' -> \\'a\\' = 0 + 26 - 2 = 24 moves\\n\\n\\n\\n\\'a\\' -> \\'z\\' = 25 - 0 = 25 moves\\n\\n\\'z\\' -> \\'a\\' = 0 + 26 - 25 = 1 move\\n\\n```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    cache := make([]int, 26) // how many ops needed\\n    for i := range s {\\n        if s[i] != t[i] {  // needs shifting\\n            opsNeeded := int(t[i] + 26 - s[i]) % 26\\n            turn := opsNeeded + 26 * cache[opsNeeded]\\n            cache[opsNeeded]++\\n            \\n            if turn > k {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s) != len(t) {\\n        return false\\n    }\\n    \\n    cache := make([]int, 26) // how many ops needed\\n    for i := range s {\\n        if s[i] != t[i] {  // needs shifting\\n            opsNeeded := int(t[i] + 26 - s[i]) % 26\\n            turn := opsNeeded + 26 * cache[opsNeeded]\\n            cache[opsNeeded]++\\n            \\n            if turn > k {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605985,
                "title": "c-52ms-99-45-simple-easy-small-time-on-space-o1-operators-only-and",
                "content": "Runtime: 52 ms, faster than 99.45% of C++ online submissions for Can Convert String in K Moves.\\nMemory Usage: 17.7 MB, less than 77.35% of C++ online submissions for Can Convert String in K Moves.\\n\\n```\\nclass Solution {\\npublic:\\n  bool canConvertString(string s, string t, int k) {\\n    if(s.size() != t.size()) return false;\\n    int table[26];\\n    for(int i = 0; i != 26; i++) table[i] = i - 26;\\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(int def = t[i] - s[i])\\n        if((table[def > 0 ? def : def += 26] += 26) > k) return false;      \\n    \\n    return true;      \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool canConvertString(string s, string t, int k) {\\n    if(s.size() != t.size()) return false;\\n    int table[26];\\n    for(int i = 0; i != 26; i++) table[i] = i - 26;\\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(int def = t[i] - s[i])\\n        if((table[def > 0 ? def : def += 26] += 26) > k) return false;      \\n    \\n    return true;      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588760,
                "title": "clearly-explained-python3-faster-than-91",
                "content": "```\\n#Faster than 91% of submissions\\n\\ndef rightmost_argmax(l):\\n    #Return the index and element of the largest element in l that\\'s furthest to the right\\n    i,e=max(enumerate(l),key=lambda x:x[::-1])\\n    return i,e\\n\\ndef min_k(s,t):\\n    \\n    #Assert s and t are two lower-case alphabetical strings of the same length\\n    assert len(s)==len(t) and isinstance(s,str) and isinstance(t,str)\\n    assert s.isalpha() and t.isalpha()\\n    assert s==s.lower() and t==t.lower()\\n\\n    #If s and t are the same string, we don\\'t need any shifts\\n    if s==t:\\n        return 0\\n    \\n    #The rest of this code assumes we need at least one shift\\n    \\n    #Calculate required shifts between letters (d=deltas)\\n    d=[(ord(y)-ord(x))%26 for x,y in zip(s,t)]\\n    \\n    #All elements in d should be integers between 0 and 25 because of the modulo\\n    assert max(d)<=25\\n    \\n    #Calculate a histogram of the elements in d\\n    h=[0]*26 \\n    for x in d:\\n        h[x]+=1\\n        \\n    #Ignore the times we didn\\'t need to change anything\\n    h[0]=0\\n    \\n    #At least one element needs to be changed, because we know if we\\'ve reached this line s!=t\\n    assert not all(x==0 for x in d)\\n    \\n    #This is the main solution here: Whatever shift we need more than once needs to wrap around the 26 letters that many times (the 26*(e-1)), then shift a little more (the +i term)\\n    i,e=rightmost_argmax(h)\\n    return 26*(e-1)+i\\n\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        try:\\n            return k>=min_k(s,t)\\n        except AssertionError:\\n            return False\\n        ```",
                "solutionTags": [],
                "code": "```\\n#Faster than 91% of submissions\\n\\ndef rightmost_argmax(l):\\n    #Return the index and element of the largest element in l that\\'s furthest to the right\\n    i,e=max(enumerate(l),key=lambda x:x[::-1])\\n    return i,e\\n\\ndef min_k(s,t):\\n    \\n    #Assert s and t are two lower-case alphabetical strings of the same length\\n    assert len(s)==len(t) and isinstance(s,str) and isinstance(t,str)\\n    assert s.isalpha() and t.isalpha()\\n    assert s==s.lower() and t==t.lower()\\n\\n    #If s and t are the same string, we don\\'t need any shifts\\n    if s==t:\\n        return 0\\n    \\n    #The rest of this code assumes we need at least one shift\\n    \\n    #Calculate required shifts between letters (d=deltas)\\n    d=[(ord(y)-ord(x))%26 for x,y in zip(s,t)]\\n    \\n    #All elements in d should be integers between 0 and 25 because of the modulo\\n    assert max(d)<=25\\n    \\n    #Calculate a histogram of the elements in d\\n    h=[0]*26 \\n    for x in d:\\n        h[x]+=1\\n        \\n    #Ignore the times we didn\\'t need to change anything\\n    h[0]=0\\n    \\n    #At least one element needs to be changed, because we know if we\\'ve reached this line s!=t\\n    assert not all(x==0 for x in d)\\n    \\n    #This is the main solution here: Whatever shift we need more than once needs to wrap around the 26 letters that many times (the 26*(e-1)), then shift a little more (the +i term)\\n    i,e=rightmost_argmax(h)\\n    return 26*(e-1)+i\\n\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        try:\\n            return k>=min_k(s,t)\\n        except AssertionError:\\n            return False\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 1574043,
                "title": "10-line-of-code-simple-o-n-solution-and-o-1-space-solution-easy-and-cake-walk",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size() or k==0) return false;\\n        vector<int>vec;\\n        int mp[26]; memset(mp,0,sizeof(mp));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff = t[i]-s[i];\\n            if(diff<0) diff+=26;\\n            \\n            if(diff>0)\\n            {\\n                vec.push_back(mp[diff]*26 + diff);\\n                mp[diff]++;\\n            }\\n        }\\n        \\n        \\n        return (*max_element(vec.begin(),vec.end())<=k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size() or k==0) return false;\\n        vector<int>vec;\\n        int mp[26]; memset(mp,0,sizeof(mp));\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff = t[i]-s[i];\\n            if(diff<0) diff+=26;\\n            \\n            if(diff>0)\\n            {\\n                vec.push_back(mp[diff]*26 + diff);\\n                mp[diff]++;\\n            }\\n        }\\n        \\n        \\n        return (*max_element(vec.begin(),vec.end())<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528283,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n = s.size(), nn = t.size();\\n        if(n != nn) {\\n            return false;\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == t[i]) {\\n                continue;\\n            }\\n            int a = t[i] - \\'a\\';\\n            int b = s[i] - \\'a\\';\\n            int k;\\n            if(a > b) {\\n                k = a-b;\\n            } else {\\n                k = 26 - (b-a);\\n            }\\n            m[k]++;\\n        }\\n        for(auto x: m) {\\n            int a = x.first;\\n            int b = x.second;\\n            while(b--) {\\n                if(a > k) {\\n                    return false;\\n                }\\n                a += 26;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n = s.size(), nn = t.size();\\n        if(n != nn) {\\n            return false;\\n        }\\n        unordered_map<int,int> m;\\n        for(int i=0; i<n; i++) {\\n            if(s[i] == t[i]) {\\n                continue;\\n            }\\n            int a = t[i] - \\'a\\';\\n            int b = s[i] - \\'a\\';\\n            int k;\\n            if(a > b) {\\n                k = a-b;\\n            } else {\\n                k = 26 - (b-a);\\n            }\\n            m[k]++;\\n        }\\n        for(auto x: m) {\\n            int a = x.first;\\n            int b = x.second;\\n            while(b--) {\\n                if(a > k) {\\n                    return false;\\n                }\\n                a += 26;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527738,
                "title": "java-14ms-t-c-o-n-s-c-o-26-easy",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length(), len2 = t.length();\\n        \\n        if(len1 != len2)\\n            return false;\\n        \\n        if(s.equals(t))\\n            return true;\\n        \\n        int[] Freq = new int[26];\\n        \\n        int multiple = k / 26;\\n        for(int i = 0; i < 26; i++) {\\n            Freq[i] = multiple;\\n        }\\n        \\n        int rem = k % 26;\\n        for(int i = 1; i <= rem; i++)\\n            Freq[i]++;\\n        \\n        int movesRemaining = k;\\n        \\n        for(int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            \\n            if(ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            \\n            int diff = (ch2 - ch1 + 26) % 26;\\n            \\n            if(Freq[diff] > 0) {\\n                Freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        int len1 = s.length(), len2 = t.length();\\n        \\n        if(len1 != len2)\\n            return false;\\n        \\n        if(s.equals(t))\\n            return true;\\n        \\n        int[] Freq = new int[26];\\n        \\n        int multiple = k / 26;\\n        for(int i = 0; i < 26; i++) {\\n            Freq[i] = multiple;\\n        }\\n        \\n        int rem = k % 26;\\n        for(int i = 1; i <= rem; i++)\\n            Freq[i]++;\\n        \\n        int movesRemaining = k;\\n        \\n        for(int i = 0; i < len1; i++) {\\n            char ch1 = s.charAt(i);\\n            char ch2 = t.charAt(i);\\n            \\n            if(ch1 == ch2) {\\n                movesRemaining--;\\n                continue;\\n            }\\n            \\n            int diff = (ch2 - ch1 + 26) % 26;\\n            \\n            if(Freq[diff] > 0) {\\n                Freq[diff]--;\\n                movesRemaining--;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return movesRemaining >= 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446966,
                "title": "go-o-n-time-o-1-space-1-pass",
                "content": "```go\\nfunc canConvertString(s string, t string, k int) bool {\\n\\tif len(s) != len(t) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tvar shifts [26]int // how many times we need to shift n steps?\\n\\n\\tfor i, c := range s {\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\ty := int(t[i] - \\'a\\')\\n\\n\\t\\tif x != y {\\n\\t\\t\\tstep := (y - x + 26) % 26\\n\\t\\t\\tshifts[step]++\\n\\t\\t\\tif step + (shifts[step]-1)*26 >k {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canConvertString(s string, t string, k int) bool {\\n\\tif len(s) != len(t) {\\n\\t\\treturn false\\n\\t}\\n\\n\\tvar shifts [26]int // how many times we need to shift n steps?\\n\\n\\tfor i, c := range s {\\n\\t\\tx := int(c - \\'a\\')\\n\\t\\ty := int(t[i] - \\'a\\')\\n\\n\\t\\tif x != y {\\n\\t\\t\\tstep := (y - x + 26) % 26\\n\\t\\t\\tshifts[step]++\\n\\t\\t\\tif step + (shifts[step]-1)*26 >k {\\n\\t\\t\\t\\treturn false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428497,
                "title": "easy-c-map-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        int n=s.length();\\n        if(s.length()!=t.length())\\n            return false;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=t[i])\\n            {\\n                int z=t[i]-s[i];\\n                if(z<0)\\n                    z+=26;\\n                mp[z]++;\\n            }\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.first>k)\\n                return false;\\n            if(it.second>1)\\n            {\\n                mp[it.first+26]+=it.second-1;\\n            }\\n        }\\n        return true;\\n    }\\n};``\\nUpvote if you like :)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1423160,
                "title": "python-3-using-hashmap",
                "content": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\tls, lt = len(s), len(t)\\n\\tif ls!=lt:\\n\\t\\treturn False\\n\\n\\tdone = {}\\n\\n\\tfor i in range(0, ls):\\n\\t\\tif s[i]==t[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]<t[i]:\\n\\t\\t\\tmove = ord(t[i])-ord(s[i])\\n\\t\\telse:\\n\\t\\t\\tmove = 26-(ord(s[i])-96)+(ord(t[i])-96)\\n\\n\\t\\tif move in done:\\n\\t\\t\\tdone[move]+=1\\n\\t\\t\\tmove+=(done[move]-1)*26\\n\\t\\telse:\\n\\t\\t\\tdone[move] = 1\\n\\n\\t\\tif move>k:\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef canConvertString(self, s: str, t: str, k: int) -> bool:\\n\\tls, lt = len(s), len(t)\\n\\tif ls!=lt:\\n\\t\\treturn False\\n\\n\\tdone = {}\\n\\n\\tfor i in range(0, ls):\\n\\t\\tif s[i]==t[i]:\\n\\t\\t\\tcontinue\\n\\t\\tif s[i]<t[i]:\\n\\t\\t\\tmove = ord(t[i])-ord(s[i])\\n\\t\\telse:\\n\\t\\t\\tmove = 26-(ord(s[i])-96)+(ord(t[i])-96)\\n\\n\\t\\tif move in done:\\n\\t\\t\\tdone[move]+=1\\n\\t\\t\\tmove+=(done[move]-1)*26\\n\\t\\telse:\\n\\t\\t\\tdone[move] = 1\\n\\n\\t\\tif move>k:\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1366245,
                "title": "c-easy-multiplier-tracker",
                "content": "```\\npublic bool CanConvertString(string s, string t, int k) {\\n\\t//TAKING care of base case\\n\\n\\tif(s.Length != t.Length) return false;\\n\\t //Keep track of counter of multiplier\\n\\tint [] mul = new int[26];\\n\\n\\tfor(int i = 0 ; i < s.Length ; i++)\\n\\t{\\n\\t\\t//here we wre finding the shift\\n\\t\\tint shift = t[i] - s[i] + (s[i] > t[i] ? 26 :0);\\n\\n\\t\\t//now check the moves should not greater then k\\n\\n\\t\\tif(shift !=0 && shift + mul[shift] *26 >k)\\n\\t\\t\\treturn false;\\n\\n\\t\\tmul[shift]++;\\n\\t}\\n\\n\\treturn true;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool CanConvertString(string s, string t, int k) {\\n\\t//TAKING care of base case\\n\\n\\tif(s.Length != t.Length) return false;\\n\\t //Keep track of counter of multiplier\\n\\tint [] mul = new int[26];\\n\\n\\tfor(int i = 0 ; i < s.Length ; i++)\\n\\t{\\n\\t\\t//here we wre finding the shift\\n\\t\\tint shift = t[i] - s[i] + (s[i] > t[i] ? 26 :0);\\n\\n\\t\\t//now check the moves should not greater then k\\n\\n\\t\\tif(shift !=0 && shift + mul[shift] *26 >k)\\n\\t\\t\\treturn false;\\n\\n\\t\\tmul[shift]++;\\n\\t}\\n\\n\\treturn true;\\n}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312263,
                "title": "c-solution-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int> m;\\n        if(s.length()!=t.length())\\n            return(false);\\n        int q=k/26,o=k%26;\\n        for(int l=0;l<=25;l++)\\n        {\\n            if(l<=o)\\n                m[l]++;\\n            m[l]+=q;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int p=t[i]-s[i];\\n            if(p<0)\\n            {\\n                p=(\\'z\\'-s[i])+1+(t[i]-\\'a\\');\\n            }\\n            if(p>0)\\n            {\\n                if(m[p]==0)\\n                {\\n                    return(false);\\n                }\\n                m[p]--;\\n            }\\n        }\\n        return(true);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        unordered_map<int,int> m;\\n        if(s.length()!=t.length())\\n            return(false);\\n        int q=k/26,o=k%26;\\n        for(int l=0;l<=25;l++)\\n        {\\n            if(l<=o)\\n                m[l]++;\\n            m[l]+=q;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int p=t[i]-s[i];\\n            if(p<0)\\n            {\\n                p=(\\'z\\'-s[i])+1+(t[i]-\\'a\\');\\n            }\\n            if(p>0)\\n            {\\n                if(m[p]==0)\\n                {\\n                    return(false);\\n                }\\n                m[p]--;\\n            }\\n        }\\n        return(true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309687,
                "title": "go-solution",
                "content": "//credits: https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1268156/Easy-C%2B%2B-solution-using-Map\\n```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s)!=len(t) {\\n        return false\\n    }\\n    val:=0\\n    m:=make(map[int]int)\\n    for i, _ := range s {\\n        val = int(t[i])-int(s[i])\\n        if val < 0  {\\n            val = 26-abs(val)\\n        }  \\n        if val >0 {\\n            m[val]+=1\\n        }  \\n    }\\n    for key, v := range m {\\n        if k<(26*(v-1)+key) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc abs(n int) int {\\n    if n<0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canConvertString(s string, t string, k int) bool {\\n    if len(s)!=len(t) {\\n        return false\\n    }\\n    val:=0\\n    m:=make(map[int]int)\\n    for i, _ := range s {\\n        val = int(t[i])-int(s[i])\\n        if val < 0  {\\n            val = 26-abs(val)\\n        }  \\n        if val >0 {\\n            m[val]+=1\\n        }  \\n    }\\n    for key, v := range m {\\n        if k<(26*(v-1)+key) {\\n            return false\\n        }\\n    }\\n    return true\\n}\\nfunc abs(n int) int {\\n    if n<0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256317,
                "title": "c-100-100",
                "content": "```\\nbool canConvertString(char * s, char * t, int k){\\n    int seen[26]={-26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26};\\n    while (*s != 0 && *t != 0) {\\n        int d;\\n        if ((d = *t++ - *s++)==0) {\\n            continue;\\n        } else if (d < 0) {\\n            d += 26;\\n        }\\n        if ((d += seen[d] += 26) > k) {\\n            return false;\\n        }\\n    }\\n    return (*t == 0 && *s == 0);\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(char * s, char * t, int k){\\n    int seen[26]={-26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26, -26,\\n                  -26, -26, -26, -26, -26, -26, -26, -26};\\n    while (*s != 0 && *t != 0) {\\n        int d;\\n        if ((d = *t++ - *s++)==0) {\\n            continue;\\n        } else if (d < 0) {\\n            d += 26;\\n        }\\n        if ((d += seen[d] += 26) > k) {\\n            return false;\\n        }\\n    }\\n    return (*t == 0 && *s == 0);\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256309,
                "title": "python-highly-optimized",
                "content": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        seen = [-26] * 26\\n        for sc, tc in zip(s, t):\\n            d = ord(tc) - ord(sc)\\n            if d == 0:\\n                continue\\n            elif d < 0:\\n                d += 26\\n            seen[d] += 26\\n            d += seen[d]\\n            if d > k:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        seen = [-26] * 26\\n        for sc, tc in zip(s, t):\\n            d = ord(tc) - ord(sc)\\n            if d == 0:\\n                continue\\n            elif d < 0:\\n                d += 26\\n            seen[d] += 26\\n            d += seen[d]\\n            if d > k:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253830,
                "title": "easy-c-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        vector<int>diff(26,0);\\n        //cout<<(int)\\'z\\' - (int)\\'source\\' + (int)\\'tar\\' - (int)\\'a\\' + 1<<endl;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==t[i]){\\n                continue;\\n            }\\n            if(t[i] > s[i]){\\n                int id = t[i] - s[i];\\n                diff[id]++;\\n            }\\n            else{\\n                int d =( (int)\\'z\\' - (int)s[i] + (int)t[i] - (int)\\'a\\' + 1);\\n                diff[d]++;\\n            }\\n        }\\n        for(int i = 1;i<26;i++){\\n            int tar = i + (26 * (diff[i] - 1));\\n            if(tar > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s==t) return true;\\n        if(s.size()!=t.size()) return false;\\n        vector<int>diff(26,0);\\n        //cout<<(int)\\'z\\' - (int)\\'source\\' + (int)\\'tar\\' - (int)\\'a\\' + 1<<endl;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==t[i]){\\n                continue;\\n            }\\n            if(t[i] > s[i]){\\n                int id = t[i] - s[i];\\n                diff[id]++;\\n            }\\n            else{\\n                int d =( (int)\\'z\\' - (int)s[i] + (int)t[i] - (int)\\'a\\' + 1);\\n                diff[d]++;\\n            }\\n        }\\n        for(int i = 1;i<26;i++){\\n            int tar = i + (26 * (diff[i] - 1));\\n            if(tar > k) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1248115,
                "title": "js-easy-to-follow-time-o-n-space-o-1",
                "content": "```\\nvar canConvertString = function(s, t, k) {\\n    let numMoves = 0;\\n    let shiftCountMap = {};\\n    let leastNumMoves = 0;\\n    let getMoves = function(from, to) {\\n      let result = to.charCodeAt(0) - from.charCodeAt(0);\\n      return result < 0 ? 26 + result : result;\\n    }\\n\\n    if(s.length !== t.length) {\\n      return false;\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n      numMoves = getMoves(s.charAt(i), t.charAt(i));\\n      shiftCountMap[numMoves] = !!shiftCountMap[numMoves] ? shiftCountMap[numMoves] + 1 : 1;\\n      let temp = (26 * (shiftCountMap[numMoves] - 1)) + numMoves;\\n      if(leastNumMoves < temp && numMoves !== 0){\\n        leastNumMoves = temp;\\n      }\\n    }\\n    return k >= leastNumMoves;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canConvertString = function(s, t, k) {\\n    let numMoves = 0;\\n    let shiftCountMap = {};\\n    let leastNumMoves = 0;\\n    let getMoves = function(from, to) {\\n      let result = to.charCodeAt(0) - from.charCodeAt(0);\\n      return result < 0 ? 26 + result : result;\\n    }\\n\\n    if(s.length !== t.length) {\\n      return false;\\n    }\\n\\n    for(let i = 0; i < s.length; i++) {\\n      numMoves = getMoves(s.charAt(i), t.charAt(i));\\n      shiftCountMap[numMoves] = !!shiftCountMap[numMoves] ? shiftCountMap[numMoves] + 1 : 1;\\n      let temp = (26 * (shiftCountMap[numMoves] - 1)) + numMoves;\\n      if(leastNumMoves < temp && numMoves !== 0){\\n        leastNumMoves = temp;\\n      }\\n    }\\n    return k >= leastNumMoves;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240148,
                "title": "c-count",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if(s.size()!=t.size())\\n            return false;\\n        vector<int>m(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff==0)\\n                continue;\\n            if(diff<0)\\n                diff+=26;\\n            m[diff]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m[i]==0)\\n                continue;\\n            int req=(26*(m[i]-1))+i;\\n            if(req>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if(s.size()!=t.size())\\n            return false;\\n        vector<int>m(26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int diff=t[i]-s[i];\\n            if(diff==0)\\n                continue;\\n            if(diff<0)\\n                diff+=26;\\n            m[diff]++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(m[i]==0)\\n                continue;\\n            int req=(26*(m[i]-1))+i;\\n            if(req>k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234636,
                "title": "swift-solution",
                "content": "Obviously if `s.count != t.count`, then the answer is `false`. Let\\'s add that check at the beginning.\\n\\nIt makes sense to perform shifts in the range from 1 to 25. We can perform each shift `k / 26 + (k % 26 >= shift ? 1 : 0)` times. Let\\'s fill the `shifts` array with the number of available shifts.\\n\\nConsider all indexes `i` in range `0 <= i < s.count` where `s[i] != t[i]` and calculate the `shift` to get `t[i]` from `s[i]`. If `shifts[shift] == 0` then the answer is `false`, else decrement `shifts[shift]` by 1.\\n```\\nclass Solution {\\n    func s2i(_ s: String) -> [Int] {\\n        return s.map({ Int($0.asciiValue ?? 97) - 97 })\\n    }\\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\\n        guard s.count == t.count else { return false }\\n        let alphabet = 26, s = s2i(s), t = s2i(t), n = s.count\\n        var shifts = [Int](repeating: k / alphabet, count: alphabet)\\n        for i in stride(from: 1, through: k % alphabet, by: 1) {\\n            shifts[i] += 1\\n        }\\n        for i in 0..<n where s[i] != t[i] {\\n            let shift = t[i] - s[i] + (t[i] > s[i] ? 0 : alphabet)\\n            shifts[shift] -= 1\\n            if shifts[shift] < 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func s2i(_ s: String) -> [Int] {\\n        return s.map({ Int($0.asciiValue ?? 97) - 97 })\\n    }\\n    func canConvertString(_ s: String, _ t: String, _ k: Int) -> Bool {\\n        guard s.count == t.count else { return false }\\n        let alphabet = 26, s = s2i(s), t = s2i(t), n = s.count\\n        var shifts = [Int](repeating: k / alphabet, count: alphabet)\\n        for i in stride(from: 1, through: k % alphabet, by: 1) {\\n            shifts[i] += 1\\n        }\\n        for i in 0..<n where s[i] != t[i] {\\n            let shift = t[i] - s[i] + (t[i] > s[i] ? 0 : alphabet)\\n            shifts[shift] -= 1\\n            if shifts[shift] < 0 {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226937,
                "title": "python-o-n-with-constant-memory-storage",
                "content": "```Python\\n\"Medium 1540. Can Convert String in K Moves\"\\n# https://leetcode.com/problems/can-convert-string-in-k-moves/\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"Method 0 47.34%, self done, should be constant memory and time.\"\\n        # Posted to https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1226937/python-O(n)-with-constant-memory-storage.\\n        if len(s) != len(t): return False\\n        calDiff = lambda l, r: (ord(r) - ord(l)) % 26\\n        gaps = [calDiff(l, r) for l, r in zip(s, t)]\\n        base, remainder = k // 26, k%26\\n        choices = [base for _ in range(26)]\\n        for i in range(remainder + 1):\\n            choices[i] += 1\\n        for gap in gaps:\\n            if gap == 0: continue\\n            choices[gap] -= 1\\n            if choices[gap] == -1: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```Python\\n\"Medium 1540. Can Convert String in K Moves\"\\n# https://leetcode.com/problems/can-convert-string-in-k-moves/\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        \"Method 0 47.34%, self done, should be constant memory and time.\"\\n        # Posted to https://leetcode.com/problems/can-convert-string-in-k-moves/discuss/1226937/python-O(n)-with-constant-memory-storage.\\n        if len(s) != len(t): return False\\n        calDiff = lambda l, r: (ord(r) - ord(l)) % 26\\n        gaps = [calDiff(l, r) for l, r in zip(s, t)]\\n        base, remainder = k // 26, k%26\\n        choices = [base for _ in range(26)]\\n        for i in range(remainder + 1):\\n            choices[i] += 1\\n        for gap in gaps:\\n            if gap == 0: continue\\n            choices[gap] -= 1\\n            if choices[gap] == -1: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223574,
                "title": "map",
                "content": "bool canConvertString(string s, string t, int k) {\\n        \\n        \\n        int n=t.length();\\n        int count=0,i=0;\\n        unordered_map<int,int> m;\\n        \\n      while(i<n && count <=k){\\n            \\n          if(s[i]!=t[i]){\\n            \\n                count=t[i]-s[i];\\n                if(count<0)\\n                    count+=26;\\n        \\n                if(m.find(count)!=m.end()){ \\n                   m[count]++;\\n                   count+=(m[count]-1)*26;\\n                }\\n                m[count]++;\\n               if(count<=k)       \\n                 s[i]=t[i];\\n          }\\n            \\n            i++;\\n        }\\n      \\n    return s==t;       \\n     }\\n        };",
                "solutionTags": [],
                "code": "bool canConvertString(string s, string t, int k) {\\n        \\n        \\n        int n=t.length();\\n        int count=0,i=0;\\n        unordered_map<int,int> m;\\n        \\n      while(i<n && count <=k){\\n            \\n          if(s[i]!=t[i]){\\n            \\n                count=t[i]-s[i];\\n                if(count<0)\\n                    count+=26;\\n        \\n                if(m.find(count)!=m.end()){ \\n                   m[count]++;\\n                   count+=(m[count]-1)*26;\\n                }\\n                m[count]++;\\n               if(count<=k)       \\n                 s[i]=t[i];\\n          }\\n            \\n            i++;\\n        }\\n      \\n    return s==t;       \\n     }\\n        };",
                "codeTag": "Unknown"
            },
            {
                "id": 1214680,
                "title": "simple-to-understand-java-soln",
                "content": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int mp[] = new int[100001];\\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            \\n            if(diff == 0)\\n                continue;\\n            if(diff > 0) {                      \\n                int z = mp[diff] * 26 + diff;\\n                if(z > k)\\n                    return false;                \\n                mp[diff]++;                \\n            }\\n            else {               \\n                int z =  mp[diff + 26] * 26 + diff + 26;\\n                if(z > k)\\n                    return false;                \\n                mp[diff + 26]++;               \\n            }           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canConvertString(String s, String t, int k) {\\n        \\n        int mp[] = new int[100001];\\n        if(s.length() != t.length())\\n            return false;\\n        \\n        int n = s.length();\\n        \\n        for(int i=0;i<n;i++) {\\n            \\n            int diff = t.charAt(i) - s.charAt(i);\\n            \\n            if(diff == 0)\\n                continue;\\n            if(diff > 0) {                      \\n                int z = mp[diff] * 26 + diff;\\n                if(z > k)\\n                    return false;                \\n                mp[diff]++;                \\n            }\\n            else {               \\n                int z =  mp[diff + 26] * 26 + diff + 26;\\n                if(z > k)\\n                    return false;                \\n                mp[diff + 26]++;               \\n            }           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185999,
                "title": "c-histogram-beats-100-of-submissions",
                "content": "## The Problem\\n\\nWhen we have to shift a letter by i spaces, we want to record that shift in some container. At some point we want to check that this shift is less or equal to k.\\n\\nOur problem is in checking if there is an existing shift of the same distance. Each time there is a letter attempting the same distance of shift, we need one of those letters to be shifted by an additional 26 spaces. The second time we find this occurance we need to shift by 2x26, and so on.\\n\\nThe insight is that we can store a count of the number of letters that shift by the same amount, then we can calculate the number of additional shifts that the final letter needs to be shifted to abide by the unique i restriction in the question.\\n\\n## The Solution\\n\\nWe can create a histogram of distances by using an array of integers initialized at zero. We then iterate over both strings, find the character distance, and then increase the histogram value at that distance location as long as the distance is not zero. \\n\\n### Histogram Checks\\n\\nThe check against K can be performed either in-loop or on its own after the main while-loop. The code below shows the in-loop solution. \\n\\nThe in-loop method allows us to quit early if we find that a histogram value is violating our K requirement. However, the in-loop solutions adds a constant-time overhead for every operation. \\n\\nChecking the histogram values after the main while-loop requires far fewer (25) checks, but we have to compare entire strings and cannot exit early.\\n\\nI have found similar performance (24ms and 28ms) submitting both solutions. This seems to be similar within the variance that leetcode has for submissions.\\n\\n### Perform fewer K checks\\n\\nWe do not need to check against K for every single item we place into the histogram. We can keep track of the max number of duplicate distances in the histogram (largest value in the histogram), and only check against K if we just increased a histogram value to an equal or greater value.\\n\\nThe reason we can avoid these checks is that if the histogram value we just placed is smaller than the max previously seen histogram value, then we cannot have just placed a value greater than K, otherwise we would have exited when we had seen that max previously seen histogram value.\\n\\n### io tricks\\n\\nLeetcode appears to include the io time in the submission benchmarking time. In C++ we can reduce that overhead by including the two lines at the top of the code. The first line removes the synchronization between C and C++ standard streams, and the second line unties cin from cout. \\n\\nThese lines reduce the runtime by about half. I\\'m not sure I like that io tricks can decrease runtime more than my other optimizations, but this is the world that we live in.\\n\\n\\n\\n```\\n    bool canConvertString(string s, string t, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        if (s.size() != t.size())\\n        {\\n            return false;\\n        }\\n        auto it_s = s.begin();\\n        auto it_t = t.begin();\\n        int histogram[25] = {};\\n        int current_max_steps = 0;\\n        int ch_diff, max_steps;\\n        while(it_s != s.end()){\\n             ch_diff = (*it_t - *it_s + 26) % 26;\\n            if(ch_diff != 0){\\n                histogram[ch_diff-1] ++;\\n                if (current_max_steps <= histogram[ch_diff-1])\\n                {\\n                    current_max_steps = histogram[ch_diff-1];\\n                    max_steps = ch_diff + 26 * (histogram[ch_diff-1] - 1);\\n                    if (max_steps > k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            it_s++; it_t++;\\n        }\\n        return true;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    bool canConvertString(string s, string t, int k) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        if (s.size() != t.size())\\n        {\\n            return false;\\n        }\\n        auto it_s = s.begin();\\n        auto it_t = t.begin();\\n        int histogram[25] = {};\\n        int current_max_steps = 0;\\n        int ch_diff, max_steps;\\n        while(it_s != s.end()){\\n             ch_diff = (*it_t - *it_s + 26) % 26;\\n            if(ch_diff != 0){\\n                histogram[ch_diff-1] ++;\\n                if (current_max_steps <= histogram[ch_diff-1])\\n                {\\n                    current_max_steps = histogram[ch_diff-1];\\n                    max_steps = ch_diff + 26 * (histogram[ch_diff-1] - 1);\\n                    if (max_steps > k)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n            it_s++; it_t++;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171843,
                "title": "easy-c-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<int,int> vis;\\n        priority_queue<long long> que;\\n        for(int i=0;i<s.length();i++){\\n            int shft=t[i]-s[i];\\n            if(shft==0)continue;\\n            shft=shft<0?shft+26:shft;\\n            long long x=shft+26*vis[shft]; //is same rotn is there we have to move it to next cycle\\n            vis[shft]++;\\n            que.push(x);\\n        }\\n        if(!que.empty()&&que.top()>k)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.length()!=t.length())return false;\\n        unordered_map<int,int> vis;\\n        priority_queue<long long> que;\\n        for(int i=0;i<s.length();i++){\\n            int shft=t[i]-s[i];\\n            if(shft==0)continue;\\n            shft=shft<0?shft+26:shft;\\n            long long x=shft+26*vis[shft]; //is same rotn is there we have to move it to next cycle\\n            vis[shft]++;\\n            que.push(x);\\n        }\\n        if(!que.empty()&&que.top()>k)return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169219,
                "title": "detailed-o-n-time-o-1-space-solution",
                "content": "\\t// time complexity : O(n), space complexity : O(1)\\n\\t/*\\n\\t\\tapproach :\\n\\t\\t--> find the least amount of shift we need to do, to convert s[i] to t[i].\\n\\t\\t--> if that was done, then add 26 to it(As a shift amount can not be done more than once).\\n\\t\\t--> If that was also done add 26*2 to the least shift amount and so on.\\n\\t\\t--> Well the question is how to know the # of time we need to add 26.\\n\\t\\t--> For this we create a map of size 26. Cuz least shift can be upto 25, when \\'a\\' -> \\'z\\'.\\n\\t\\t--> map[i] = j means we added 26 upto j times for a shift by i.\\n\\t\\t--> But how to ensure that a particular value of shifting is not used more than once.\\n\\t\\t--> This is beacuse a * 26 + i != b * 26 + j for any value of a and b and i!=j and 1<=i,j<=25.\\n\\t*/\\n\\tclass Solution {\\n\\t\\tpublic boolean canConvertString(String s, String t, int k) {\\n\\t\\t\\tif(s.length()!=t.length())return false;\\n\\t\\t\\tint[] map = new int[26];\\n\\t\\t\\tfor(var i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar c1 = s.charAt(i);\\n\\t\\t\\t\\tchar c2 = t.charAt(i);\\n\\t\\t\\t\\tif(c1==c2)continue;\\n\\t\\t\\t\\tint shifts  = 0;\\n\\t\\t\\t\\tif(c2>c1) shifts = c2-c1;\\n\\t\\t\\t\\telse shifts = \\'z\\'- c1 + 1 + c2-\\'a\\';\\n\\t\\t\\t\\tint totalShifts = 26*map[shifts] + shifts;\\n\\t\\t\\t\\tmap[shifts]++;\\n\\t\\t\\t\\tif(totalShifts>k)return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean canConvertString(String s, String t, int k) {\\n\\t\\t\\tif(s.length()!=t.length())return false;\\n\\t\\t\\tint[] map = new int[26];\\n\\t\\t\\tfor(var i=0;i<s.length();i++){\\n\\t\\t\\t\\tchar c1 = s.charAt(i);\\n\\t\\t\\t\\tchar c2 = t.charAt(i);\\n\\t\\t\\t\\tif(c1==c2)continue;\\n\\t\\t\\t\\tint shifts  = 0;\\n\\t\\t\\t\\tif(c2>c1) shifts = c2-c1;\\n\\t\\t\\t\\telse shifts = \\'z\\'- c1 + 1 + c2-\\'a\\';\\n\\t\\t\\t\\tint totalShifts = 26*map[shifts] + shifts;\\n\\t\\t\\t\\tmap[shifts]++;\\n\\t\\t\\t\\tif(totalShifts>k)return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1167215,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if (s.length() != t.length()) return false;\\n        \\n        int diff[26];\\n        for (int i = 0; i<26; i++) diff[i] = i;\\n        for (int i = 0; i<s.length(); i++)\\n        {\\n            if (s[i] == t[i]) continue;\\n            int j = t[i]-s[i];\\n            if (j<0) j+= 26;\\n            if (diff[j] > k)\\n                return false;\\n            \\n            diff[j] += 26;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) \\n    {\\n        if (s.length() != t.length()) return false;\\n        \\n        int diff[26];\\n        for (int i = 0; i<26; i++) diff[i] = i;\\n        for (int i = 0; i<s.length(); i++)\\n        {\\n            if (s[i] == t[i]) continue;\\n            int j = t[i]-s[i];\\n            if (j<0) j+= 26;\\n            if (diff[j] > k)\\n                return false;\\n            \\n            diff[j] += 26;\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159917,
                "title": "java-hashmap-o-n",
                "content": "```\\n\\tpublic boolean canConvertString(String s, String t, int k){\\n        if(s.length()!=t.length()) return false;\\n        Map<Integer,Integer> map= new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==t.charAt(i)) continue;\\n            int moves= 0;\\n            if(t.charAt(i)>s.charAt(i)) moves= t.charAt(i)-s.charAt(i);\\n            else{\\n                moves= \\'z\\'-s.charAt(i)+t.charAt(i)-\\'a\\'+1;\\n            }\\n            if(map.containsKey(moves)){\\n                int less26= moves;\\n                moves= map.get(moves)+26;\\n                map.replace(less26,moves);\\n            }else{\\n                map.put(moves,moves);\\n            } \\n            if(moves>k) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean canConvertString(String s, String t, int k){\\n        if(s.length()!=t.length()) return false;\\n        Map<Integer,Integer> map= new HashMap<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==t.charAt(i)) continue;\\n            int moves= 0;\\n            if(t.charAt(i)>s.charAt(i)) moves= t.charAt(i)-s.charAt(i);\\n            else{\\n                moves= \\'z\\'-s.charAt(i)+t.charAt(i)-\\'a\\'+1;\\n            }\\n            if(map.containsKey(moves)){\\n                int less26= moves;\\n                moves= map.get(moves)+26;\\n                map.replace(less26,moves);\\n            }else{\\n                map.put(moves,moves);\\n            } \\n            if(moves>k) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1145426,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-1-space",
                "content": "**Explanation**\\nThe idea is to use a hashtable for the required shifts to transform one letter into another. It provides the next free number of shifts which is the initial number of shifts plus a multiple of `26`. Every time we access such a free number of shifts, we check if it is greater than `k`. If it is, `false` will be returned. In any other case, the next free number of shifts will be the current one plus `26`.\\n\\nExample: To transform `a` into `b` we need `1` shift. The next free number of shifts for this initial number of shifts will be `27`. If we now are asked to transform `b` into `c`, for instance, the required shifts will be `27` and the next free number of shifts `27 + 26 = 53` and so on.\\n________________________\\n**Definitions**\\n`n`: Size of `s` and `t` if `s = t`.\\n________________________\\n**Runtime Complexity**\\n`O(n)`\\n_______________________\\n**Space Complexity**\\n`O(1)`\\n_______________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        shifts_to_next_shift = list(range(26))\\n        \\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                shifts = ord(t[i]) - ord(s[i]) if s[i] < t[i] else ord(\"z\") - ord(s[i]) + 1 + ord(t[i]) - ord(\"a\")\\n                \\n                if shifts_to_next_shift[shifts] > k:\\n                    return False\\n                \\n                shifts_to_next_shift[shifts] += 26\\n                \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canConvertString(self, s: str, t: str, k: int) -> bool:\\n        if len(s) != len(t):\\n            return False\\n        \\n        shifts_to_next_shift = list(range(26))\\n        \\n        for i in range(len(s)):\\n            if s[i] != t[i]:\\n                shifts = ord(t[i]) - ord(s[i]) if s[i] < t[i] else ord(\"z\") - ord(s[i]) + 1 + ord(t[i]) - ord(\"a\")\\n                \\n                if shifts_to_next_shift[shifts] > k:\\n                    return False\\n                \\n                shifts_to_next_shift[shifts] += 26\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143035,
                "title": "c-solution-beats-80-o-n-time-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[i])\\n            {\\n                continue;\\n            }\\n            int diff=t[i]-s[i];\\n            if(t[i]<s[i])\\n            {\\n                diff+=26;\\n            }\\n            mp[diff]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            int vg=itr->first;\\n            int yu=itr->second;\\n            int ans= vg + (26*(yu-1));\\n            if(ans>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canConvertString(string s, string t, int k) {\\n        if(s.size()!=t.size())\\n        {\\n            return false;\\n        }\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==t[i])\\n            {\\n                continue;\\n            }\\n            int diff=t[i]-s[i];\\n            if(t[i]<s[i])\\n            {\\n                diff+=26;\\n            }\\n            mp[diff]++;\\n        }\\n        unordered_map<int,int>::iterator itr;\\n        for(itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            int vg=itr->first;\\n            int yu=itr->second;\\n            int ans= vg + (26*(yu-1));\\n            if(ans>k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107285,
                "title": "c-solution-using-dictionary",
                "content": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if(s.Length != t.Length) return false;\\n        int times = k/26;\\n        k %= 26;\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if(s[i] == t[i]) continue;\\n            int shift = s[i]-t[i]>0? 26-s[i]+t[i] : t[i]-s[i];\\n            if(dict.ContainsKey(shift))\\n            {\\n                dict[shift]++;\\n            }\\n            else\\n            {\\n                dict.Add(shift, 1);\\n            }\\n            \\n            if(dict[shift] > times)\\n            {\\n                if(shift > k || dict[shift] - times > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanConvertString(string s, string t, int k) {\\n        if(s.Length != t.Length) return false;\\n        int times = k/26;\\n        k %= 26;\\n        Dictionary<int, int> dict = new Dictionary<int, int>();\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            if(s[i] == t[i]) continue;\\n            int shift = s[i]-t[i]>0? 26-s[i]+t[i] : t[i]-s[i];\\n            if(dict.ContainsKey(shift))\\n            {\\n                dict[shift]++;\\n            }\\n            else\\n            {\\n                dict.Add(shift, 1);\\n            }\\n            \\n            if(dict[shift] > times)\\n            {\\n                if(shift > k || dict[shift] - times > 1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102036,
                "title": "c-o-n-solution-maintain-counts-of-number-of-ways-to-make-1-25-steps",
                "content": "```\\nbool canConvertString(string s, string t, int k) {\\n\\tif (s.size() != t.size()) return false;\\n\\n\\t// Maintain a count of the number of times we can make\\n\\t// X number of shifts. X ranges from 1-25.\\n\\tint count[26] = {};\\n\\tfor (int i = 1; i < 26; i++) {\\n\\t\\tcount[i] = (k+26-i)/26;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == t[i]) continue;\\n\\n\\t\\tint shift = (t[i] + 26 - s[i]) % 26;\\n\\t\\t// If we have already used up all possible ways to\\n\\t\\t// make \\'shift\\' number of steps, string can\\'t be\\n\\t\\t// converted.\\n\\t\\tif (count[shift]-- == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canConvertString(string s, string t, int k) {\\n\\tif (s.size() != t.size()) return false;\\n\\n\\t// Maintain a count of the number of times we can make\\n\\t// X number of shifts. X ranges from 1-25.\\n\\tint count[26] = {};\\n\\tfor (int i = 1; i < 26; i++) {\\n\\t\\tcount[i] = (k+26-i)/26;\\n\\t}\\n\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == t[i]) continue;\\n\\n\\t\\tint shift = (t[i] + 26 - s[i]) % 26;\\n\\t\\t// If we have already used up all possible ways to\\n\\t\\t// make \\'shift\\' number of steps, string can\\'t be\\n\\t\\t// converted.\\n\\t\\tif (count[shift]-- == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570107,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1824479,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1570421,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 1574182,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 2044343,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            },
            {
                "id": 2007883,
                "content": [
                    {
                        "username": "NaoJoeMiao",
                        "content": "Input: s = \"input\", t = \"ouput\", k = 9\\nOutput: true\\nExplanation: In the 6th move, we shift \\'i\\' 6 times to get \\'o\\'. And in the 7th move we shift \\'n\\' to get \\'u\\'.\\n\\n**Move from n to u needs 7 moves and 6+7>9, right? Why True.**\\n\\nInput: s = \"abc\", t = \"bcd\", k = 10\\nOutput: false\\nExplanation: We need to shift each character in s one time to convert it into t. We can shift \\'a\\' to \\'b\\' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\\n\\n**a->b 1 move, b->c 1 move, c->d 1move, 3 moves total? Why False.**\\n\\nInput: s = \"aab\", t = \"bbb\", k = 27\\nOutput: true\\nExplanation: In the 1st move, we shift the first \\'a\\' 1 time to get \\'b\\'. In the 27th move, we shift the second \\'a\\' 27 times to get \\'b\\'.\\n\\n**Why second a->b is on the 27 move?**\\n\\n\\nCan someone point out how I should understand this question?\\n"
                    },
                    {
                        "username": "TheFlyIsASpy",
                        "content": "Clarifying the problem for people:\nOn the ith move, you must shift the chosen character i times.\n\nThat means you must shift 1 position on move 1 (if you shift at all) EX: a -> b\nShift 2 positions on move 2 (if you shift at all) EX: a -> c\nShift 7 positions on move 7 (if at all) EX: a -> h\n\nETC...\n\nFor example 2:\nWe can shift a -> b on move 1 since it is shifting 1 place.\nBut now, for b -> c we have to wait until move 27 since we already did a->b on move 1 we cannot shift 1 time again, so we have to wait until move 27 so that we can shift 27 times to get c. This is already more than k = 10 and therefore the answer is false."
                    },
                    {
                        "username": "danielkua",
                        "content": "The truth is k is reset back to its original value everytime after you did the shifting.\\nMeaning: We can use k multiple times for shifting each letter, (s[i] to t[i]) as long as the number of shifts perform in each letter (s[i] to t[i]) is not greater than k. WE DO NOT NEED TO SUBTRACT THE NUMBER OF SHIFTS FROM K.\\n\\nThis is from the question:\\n\"Return true if it\\'s possible to convert s into t in no more than k moves, otherwise return false.\"\\n\\nIt doesn\\'t even say that k can be used multiple times. At first, my thought process was you need to subtract k from the number of shifts everytime you shift a letter from s[i] to t[i]."
                    },
                    {
                        "username": "tekichan",
                        "content": "One of test case is to run canConvertString(\"mpzzwh\", \"kaeblv\", 24). The expected answer is True while the first pair m --> k should be able to happen in the 28th move only, thus False. Shifiting to the next (going forward) is not backward, is it?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "Tip:\\n- The explanations are not very clear, but the problem says you have a set of moves (move 1..move k). Once you have picked and done a move, you cannot do that move again.\\n- EG: k = 4. So you have moves[1,2,3,4]. \"abcd\", \"bccd\". \\n- index 0: a -> b. It needs 1 shifting, so we use move[1].\\n- index 1: b -> c. It needs 1 shift, but we have already used [1]. The next candidate would be 27, but our max is 4. Thus we return false.\\n- As you have observed, it\\'s not about the number, but their modulo % 26. 1 and 27 % 26 = 1. So modulo[1] = 2. It means you can use a shifting of 1 twice."
                    },
                    {
                        "username": "sbera717",
                        "content": "s =\\n\"atmtxzjkz\"\\nt =\\n\"tvbtjhvjd\"\\nk =\\n35\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse  \\ncan anyone explain why this is false it should be true "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Insertions to Balance a Parentheses String",
        "question_content": "<p>Given a parentheses string <code>s</code> containing only the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. A parentheses string is <strong>balanced</strong> if:</p>\n\n<ul>\n\t<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding two consecutive right parenthesis <code>&#39;))&#39;</code>.</li>\n\t<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding two consecutive right parenthesis <code>&#39;))&#39;</code>.</li>\n</ul>\n\n<p>In other words, we treat <code>&#39;(&#39;</code> as an opening parenthesis and <code>&#39;))&#39;</code> as a closing parenthesis.</p>\n\n<ul>\n\t<li>For example, <code>&quot;())&quot;</code>, <code>&quot;())(())))&quot;</code> and <code>&quot;(())())))&quot;</code> are balanced, <code>&quot;)()&quot;</code>, <code>&quot;()))&quot;</code> and <code>&quot;(()))&quot;</code> are not balanced.</li>\n</ul>\n\n<p>You can insert the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> at any position of the string to balance it if needed.</p>\n\n<p>Return <em>the minimum number of insertions</em> needed to make <code>s</code> balanced.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(()))&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The second &#39;(&#39; has two matching &#39;))&#39;, but the first &#39;(&#39; has only &#39;)&#39; matching. We need to add one more &#39;)&#39; at the end of the string to be &quot;(())))&quot; which is balanced.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;())&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The string is already balanced.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;))())(&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Add &#39;(&#39; to match the first &#39;))&#39;, Add &#39;))&#39; to match the last &#39;(&#39;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 780199,
                "title": "java-c-python-straight-forward-one-pass",
                "content": "# **Intuition**\\nSimilar to [921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/181132/C++JavaPython-Straight-Forward-One-Pass).\\nJust need to pay attention:\\nleft parenthesis \\'(\\' must have a corresponding two **consecutive** right parenthesis \\'))\\'.\\n<br>\\n\\n# **Explanation**\\n`res` represents the number of left/right parentheses already added.\\n`right` represents the number of right parentheses needed.\\n\\n**1) case `)`**\\nIf we meet a right parentheses , `right--`.\\nIf `right < 0`, we need to add a left parentheses before it.\\nThen we update `right += 2` and `res++`\\nThis part is easy and normal.\\n\\n**2) case `(`**\\nIf we meet a left parentheses,\\nwe check if we have odd number `\\')\\'` before.\\nIf we `right`, we have odd `\\')\\'` before,\\nbut we want right parentheses in paires.\\nSo add one `\\')\\'` here, then update `right--; res++;`.\\nNote that this part is not necessary if two **consecutive** right parenthesis not required.\\n\\nBecause we have `)`, we update `right += 2`.\\n<br>\\n\\n# **Dry run**\\nAll by @himanshusingh11:\\n\\n**Example 1: Consider ((()(,n= 5 ,i=0,1...4**\\ni=0, we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =2\\ni=1, again we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =4\\ni=2, again we have ( it means we need two right parenthesis (they are in pair) so.. right+=2 => res =0, right =6\\ni=3, we have ) we subtract one from right. so.. right-- => res =0, right =5\\ni=4, we have ( but here right is odd so we need to make it even with right-- and increment res++ => res =1, right =4. Also, as we have got a left parenthesis then we need two right parenthesis (they are in pair) so.. right+=2 => res =1, right =6\\n\\nfinally ans is res + right => 1 +6 == 7\\n\\n**Example 2: ((()**\\nSimilarly, we can see when we have right<0 then we increment res by one & add 2 to right as they should be in pairs..\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int minInsertions(String s) {\\n        int res = 0, right = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    int minInsertions(string s) {\\n        int res = 0, right = 0;\\n        for (char &c: s) {\\n            if (c == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\\n**Python:**\\n```py\\n    def minInsertions(self, s):\\n        res = right = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if right % 2:\\n                    right -= 1\\n                    res += 1\\n                right += 2\\n            if c == \\')\\':\\n                right -= 1\\n                if right < 0:\\n                    right += 2\\n                    res += 1\\n        return right + res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minInsertions(String s) {\\n        int res = 0, right = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\n```cpp\\n    int minInsertions(string s) {\\n        int res = 0, right = 0;\\n        for (char &c: s) {\\n            if (c == \\'(\\') {\\n                if (right % 2 > 0) {\\n                    right--;\\n                    res++;\\n                }\\n                right += 2;\\n            } else {\\n                right--;\\n                if (right < 0) {\\n                    right += 2;\\n                    res++;\\n                }\\n            }\\n        }\\n        return right + res;\\n    }\\n```\n```py\\n    def minInsertions(self, s):\\n        res = right = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if right % 2:\\n                    right -= 1\\n                    res += 1\\n                right += 2\\n            if c == \\')\\':\\n                right -= 1\\n                if right < 0:\\n                    right += 2\\n                    res += 1\\n        return right + res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779928,
                "title": "simple-o-n-stack-solution-with-detailed-explanation",
                "content": "**Brief Idea**: Maintain a stack. Every time we see a ```(``` we need to have 2 ```)``` to balance. So we would push 2 to the stack. Then when we see ```)``` we would check the top of the stack. If the top is 2, that means this is the first ```)``` that will match the previous ```(```. So we would change the top to 1. In case the top of stack had 1 it means we are seeing the second ```)``` for some ```(``` and so we just pop this 1 from the stack. \\n\\n**Details of transition**:\\n1. When we see ```(```:\\n* And the stack is empty or has a 2 at the top: we just push another 2.\\n * And the stack had 1 at the top: This means we have just seen ```()``` and now we are seeing ```(```. In this case, we need to first provide a ```)``` to the previous ```(``` and then we can process the current ```(```. So increment the answer, pop the 1 (which was for last ```(```) and push a 2 (for current ```(```).\\n2. When we see ```)```:\\n * And the stack is empty: We have encountered a lone ```)```. We would need to add ```(``` to the sequence to balance, which would match one of its ```)``` with the current ```)```. So we increment the answer.  Moreover, it would also need another ```)``` to match. So we push 1 to the top. This is like saying we have seen ```()``` (of which ```(``` was inserted by us).\\n* And the stack had 1 at the top: This the second ```)``` for some ```(```. We just pop from the stack.\\n* And the stack had 2 at the top: This the first ```)``` for some ```(```. We just pop 2 from the stack and push 1.\\nAt the end of going through the string we just add up all the numbers in stack, which represents the number of ```)``` we need to balance.\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans = 0;\\n        stack<int> t;\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                if (t.empty() || t.top() == 2) t.push(2);\\n                else {\\n                    t.pop();\\n                    t.push(2);\\n                    ans++;\\n                }\\n            }\\n            else {\\n                if (t.empty()) {\\n                    t.push(1); ans++;\\n                } else if (t.top() == 1) {\\n                    t.pop();\\n                } else if (t.top() == 2) {\\n                    t.pop(); t.push(1);\\n                }\\n            }\\n        }\\n        while (!t.empty()) {\\n            ans += t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(```\n```)```\n```)```\n```)```\n```(```\n```)```\n```(```\n```(```\n```()```\n```(```\n```)```\n```(```\n```(```\n```(```\n```(```\n```)```\n```)```\n```(```\n```)```\n```)```\n```)```\n```()```\n```(```\n```)```\n```(```\n```)```\n```(```\n```)```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans = 0;\\n        stack<int> t;\\n        for (char c : s) {\\n            if (c == \\'(\\') {\\n                if (t.empty() || t.top() == 2) t.push(2);\\n                else {\\n                    t.pop();\\n                    t.push(2);\\n                    ans++;\\n                }\\n            }\\n            else {\\n                if (t.empty()) {\\n                    t.push(1); ans++;\\n                } else if (t.top() == 1) {\\n                    t.pop();\\n                } else if (t.top() == 2) {\\n                    t.pop(); t.push(1);\\n                }\\n            }\\n        }\\n        while (!t.empty()) {\\n            ans += t.top();\\n            t.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780221,
                "title": "python-simple-and-fast-time-o-n-space-o-1",
                "content": "# \\uD83D\\uDCA1 Idea\\n\\n* Record the number of \\'(\\' in an open bracket count int. \\n* If there is a \\'))\\' or a \\') \\'then open bracket count -= 1\\n* If there is a \\'))\\' or a \\') and open bracket count = 0 an \\'(\\' must be inserted\\n* If there is a single \\')\\' another \\')\\' must be inserted\\n* At the end of the program and if open bracket count >0 then an \\'))\\' must be added for each unmatched \\'(\\'\\n\\n---\\n\\n# \\uD83D\\uDCD1Overview\\n* Solution 1: Time O(n), Space O(n) - String Replace <code style=\"background-color: Green; color: white;\">Easy</code>\\n* Solution 2: Time O(n), Space O(1) - Case by Case <code style=\"background-color: OrangeRed; color: white;\">Medium</code>\\n\\n\\n---\\n\\n\\n# \\uD83C\\uDFAFSolution 1: Simple String Replace <code style=\"background-color: Green; color: white;\">Easy</code>\\n\\n\\n## Tricks\\n\\n* Go through string replacing \\'))\\' with \\'}\\'\\n* This allows for easy differentiation between \\')\\'  \\'))\\' when iterating through the input string\\n* This makes checking the above conditions a breeze \\n\\n## Examples\\n**Example 1:**\\n```\\nInput: s = \"(()))\"\\nUsing \\'{\\' trick\\nInput: s = \"((})\"\\n\\nVery easy to see the problem running through the string one character at a time\\nCase 1: Starting \\'(\\' has only one \\')\\'       --> add 1\\nOutput:                                             1\\n```\\n\\n**Example 2:**\\n```\\nInput: s = \"))())(\"\\nUsing \\'{\\' trick\\nInput: s = \"}(}(\"\\n\\nCase 2: Starting \\'}\\' with no matching \\'(\\'  --> add 1\\nCase 3: Ending \\'(\\' with no maching \\'}\\'     --> add 2\\nOutput:                                            3\\n```\\n\\n**Example 3:**\\n```\\nInput: s = \")))))))\"\\nUsing \\'{\\' trick\\nInput: s= \"}}} )\"\\n\\nCase 2:  \\'}\\' with no matching \\'(\\'                             --> add 1 x (3 times) \\nCase 3:  \\')\\' with no matching \\'(\\' or trailing \\')\\'             --> add 2\\n\\nOutput:                                                               5\\n\\n* Case 2 happens 3 times since there are three \"}}}\"\\n* Case 3: we automatically know there is not trailing a \\')\\' becuase if there were the character would be a \\'}\\' instead\\n```\\n\\nExamples 1-3 cover all the cases of mismatching brackets there are! You should be ready to try coding a solution :) \\n\\n## Code\\n\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n                required_closed += 2\\n              \\n            # Closed Bracket Condition  \\n            else:\\n\\t\\t\\t\\n                # Case: \\')\\' \\n                # Requires additional \\')\\' \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n\\n                # Case: Matching ( for ) or ))\\n                if required_closed:\\n                    required_closed -= 2\\n\\n\\n                # Case: Unmatched ) or ))\\n                # Need to insert ( to balance string\\n                else:\\n                    missing_brackets += 1\\n\\n        return missing_brackets + required_closed\\n```\\n\\n---\\n\\n# \\uD83C\\uDFAF Solution 2: Case by Case <code style=\"background-color: OrangeRed; color: white;\">Medium</code>\\n\\n## Implementation\\n\\n* Implement a boolean that can track \\'))\\' in O(1) space\\n* Update logic from Solution 1 \\n\\n## Code \\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        # Missing \\')\\' to make valid pair\\n        missing_closed = 0 \\n\\n        # Required \\'(\\' to make valid pair\\n        required_open = 0\\n\\n        # Required \\')\\' to make valid pair\\n        required_closed = 0\\n\\n        # Track \\'))\\' cases \\n        prev_closed = 0\\n\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n\\n                # Failed to make valid pair \\n                #\\')\\' Brackets are considered missing and cannot be made valid by subsequent brackets\\n                # Case: () (\\n                if required_closed % 2 == 1: \\n                    missing_closed += 1  \\n                    required_closed -= 1\\n\\n                required_closed += 2\\n                prev_closed = False\\n                \\n            # Closed Bracket Condition \\n            else:\\n\\n                # Match ( with )\\n                if required_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched ))\\n                elif prev_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched )\\n                else:\\n                    required_open += 1\\n                    required_closed += 1\\n\\n                # Bool to track \\'))\\' \\n                prev_closed = not prev_closed\\n\\n        return required_open + required_closed + missing_closed\\n```\\n\\nLike if this helped!\\nCheers,\\nArgent \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nInput: s = \"(()))\"\\nUsing \\'{\\' trick\\nInput: s = \"((})\"\\n\\nVery easy to see the problem running through the string one character at a time\\nCase 1: Starting \\'(\\' has only one \\')\\'       --> add 1\\nOutput:                                             1\\n```\n```\\nInput: s = \"))())(\"\\nUsing \\'{\\' trick\\nInput: s = \"}(}(\"\\n\\nCase 2: Starting \\'}\\' with no matching \\'(\\'  --> add 1\\nCase 3: Ending \\'(\\' with no maching \\'}\\'     --> add 2\\nOutput:                                            3\\n```\n```\\nInput: s = \")))))))\"\\nUsing \\'{\\' trick\\nInput: s= \"}}} )\"\\n\\nCase 2:  \\'}\\' with no matching \\'(\\'                             --> add 1 x (3 times) \\nCase 3:  \\')\\' with no matching \\'(\\' or trailing \\')\\'             --> add 2\\n\\nOutput:                                                               5\\n\\n* Case 2 happens 3 times since there are three \"}}}\"\\n* Case 3: we automatically know there is not trailing a \\')\\' becuase if there were the character would be a \\'}\\' instead\\n```\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n                required_closed += 2\\n              \\n            # Closed Bracket Condition  \\n            else:\\n\\t\\t\\t\\n                # Case: \\')\\' \\n                # Requires additional \\')\\' \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n\\n                # Case: Matching ( for ) or ))\\n                if required_closed:\\n                    required_closed -= 2\\n\\n\\n                # Case: Unmatched ) or ))\\n                # Need to insert ( to balance string\\n                else:\\n                    missing_brackets += 1\\n\\n        return missing_brackets + required_closed\\n```\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        # Missing \\')\\' to make valid pair\\n        missing_closed = 0 \\n\\n        # Required \\'(\\' to make valid pair\\n        required_open = 0\\n\\n        # Required \\')\\' to make valid pair\\n        required_closed = 0\\n\\n        # Track \\'))\\' cases \\n        prev_closed = 0\\n\\n\\n        for c in s:\\n\\n            # Open Bracket Condition\\n            if c == \\'(\\':\\n\\n                # Failed to make valid pair \\n                #\\')\\' Brackets are considered missing and cannot be made valid by subsequent brackets\\n                # Case: () (\\n                if required_closed % 2 == 1: \\n                    missing_closed += 1  \\n                    required_closed -= 1\\n\\n                required_closed += 2\\n                prev_closed = False\\n                \\n            # Closed Bracket Condition \\n            else:\\n\\n                # Match ( with )\\n                if required_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched ))\\n                elif prev_closed:\\n                    required_closed -= 1\\n\\n                # Unmatched )\\n                else:\\n                    required_open += 1\\n                    required_closed += 1\\n\\n                # Bool to track \\'))\\' \\n                prev_closed = not prev_closed\\n\\n        return required_open + required_closed + missing_closed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394902,
                "title": "c-with-without-stack-clear-detailed-step-by-step-explanation",
                "content": "\\n#### **Intution:**\\nThis problem is similar to [921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/).  Note that here, for every open parantheses, there must be 2 consecutive close parantheses. \\n\\nSeeing any question involving parenthesis balancing, it becomes quite intutive to use stacks. \\nHowever, for problems involving only a single type of parenthesis (open, curly or square), we can generally (but not always) solve them without stack in the same time complexity.But as an advantage, this could solve the problem in constant space.\\n\\nIn this post, I am adding two approaches - one using stack and another without stack.\\nThe codes are well commented for your better understanding.\\n\\n##### 1. Using stack:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack <char> st;\\n        \\n        // open & close denote number of open and close brackets needed respectively\\n        int open = 0, close = 0;\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            // Push all open brackets\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            \\n            // For close brackets\\n            else if(s[i]==\\')\\') {\\n                // if consecutive close brackets appear, remove one open bracket from stack which would balance the two close brackets.  \\n\\t\\t\\t\\t// If however stack is empty, an open bracket is needed. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(!st.empty()) st.pop();\\n                    else open++;\\n                    i++; //Remember to increment the ith pointer!!\\n                }\\n                \\n                // if the next element is not a closing bracket- 2 cases: stack is empty or not\\n                else{\\n                    // for an empty stack ->    \\')\\' bracket needs an \\'(\\' and a \\')\\' to make \\'( ) )\\' \\n                    if(st.empty()){\\n                        open++;\\n                        close++; \\n                    }\\n                    \\n                    //for a filled stack ->     \\')\\' bracket and atleast 1 \\'(\\' in stack would need 1 \\')\\' to make \\'( )) \\' \\n                    else{\\n                        close++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        /* After traversing the complete string, the minimum brackets needed include:\\n        1. st.size() indicates the \\'(\\' which never had the required number of \\')\\' found in the string.\\n        2. close indicates number of close bracketes needed\\n        3. open indicates number of open brackets needed. Note that these are the need of \\'(\\' brackets encountered when stack was empty. \\n        */\\n        int total = st.size() * 2 + close + open;\\n        return total; \\n\\t\\t}\\n};\\n```\\n\\n**Complexity Analysis:** Time Complexity - O(n) , since the entire string of length n is traversed once, and for each character we perform the operations in constant time. \\nSpace Complexity - O(n) becuase of stack\\n\\n\\n##### 2. Without  using stack : \\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        //Let open be the number of open brackets in the stack which did not get equivalent close brackets to balance.\\n        // openneeded be the number of ( needed (Found when stack was empty)\\n        // closeneeded be the number of ) needed \\n        int open = 0; \\n        int openneeded = 0;\\n        int closeneeded = 0;\\n        \\n        for(int i = 0; i<s.size(); i++){\\n            \\n            //For open brackets\\n            if(s[i]==\\'(\\')\\n                open++;\\n            \\n            //For close brackets\\n            else if(s[i]==\\')\\') {\\n                \\n                //If next char is also a \\')\\' , check if an open bracket was encountered before and has not yet been balanced or not. If yes, decrement the number of open brackets. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(open==0) openneeded++;\\n                    else open--;\\n                    i++;\\n                }\\n                // If next char is a (\\n                else{\\n                    if(open==0){\\n                        openneeded++;\\n                        closeneeded++;\\n                    }\\n                    else {\\n                        open--;\\n                        closeneeded++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int total = 2*open + openneeded + closeneeded;\\n        return total; \\n\\t\\t}\\n};\\n```\\n\\n**Complexity Analysis:** Time Complexity - O(n) , since the entire string of length n is traversed once, and for each character we perform the operations in constant time. \\nSpace Complexity - O(1) constant space \\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack <char> st;\\n        \\n        // open & close denote number of open and close brackets needed respectively\\n        int open = 0, close = 0;\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            // Push all open brackets\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            \\n            // For close brackets\\n            else if(s[i]==\\')\\') {\\n                // if consecutive close brackets appear, remove one open bracket from stack which would balance the two close brackets.  \\n\\t\\t\\t\\t// If however stack is empty, an open bracket is needed. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(!st.empty()) st.pop();\\n                    else open++;\\n                    i++; //Remember to increment the ith pointer!!\\n                }\\n                \\n                // if the next element is not a closing bracket- 2 cases: stack is empty or not\\n                else{\\n                    // for an empty stack ->    \\')\\' bracket needs an \\'(\\' and a \\')\\' to make \\'( ) )\\' \\n                    if(st.empty()){\\n                        open++;\\n                        close++; \\n                    }\\n                    \\n                    //for a filled stack ->     \\')\\' bracket and atleast 1 \\'(\\' in stack would need 1 \\')\\' to make \\'( )) \\' \\n                    else{\\n                        close++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        /* After traversing the complete string, the minimum brackets needed include:\\n        1. st.size() indicates the \\'(\\' which never had the required number of \\')\\' found in the string.\\n        2. close indicates number of close bracketes needed\\n        3. open indicates number of open brackets needed. Note that these are the need of \\'(\\' brackets encountered when stack was empty. \\n        */\\n        int total = st.size() * 2 + close + open;\\n        return total; \\n\\t\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        //Let open be the number of open brackets in the stack which did not get equivalent close brackets to balance.\\n        // openneeded be the number of ( needed (Found when stack was empty)\\n        // closeneeded be the number of ) needed \\n        int open = 0; \\n        int openneeded = 0;\\n        int closeneeded = 0;\\n        \\n        for(int i = 0; i<s.size(); i++){\\n            \\n            //For open brackets\\n            if(s[i]==\\'(\\')\\n                open++;\\n            \\n            //For close brackets\\n            else if(s[i]==\\')\\') {\\n                \\n                //If next char is also a \\')\\' , check if an open bracket was encountered before and has not yet been balanced or not. If yes, decrement the number of open brackets. \\n                if(  i<s.length()-1 && s[i+1]==\\')\\'){\\n                    if(open==0) openneeded++;\\n                    else open--;\\n                    i++;\\n                }\\n                // If next char is a (\\n                else{\\n                    if(open==0){\\n                        openneeded++;\\n                        closeneeded++;\\n                    }\\n                    else {\\n                        open--;\\n                        closeneeded++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int total = 2*open + openneeded + closeneeded;\\n        return total; \\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780366,
                "title": "c-o-n-proper-explaination-without-stack",
                "content": "We keep 2 variables, **ans** ``A counter for manual addition brackets`` and **req** ``Number of closing brackets that we need`` .\\nWe start iterating over the string elements one by one. Now:-\\n**1. We get an open bracket**\\nIn this, we have 2 things to understand\\n* For every open bracket, we need 2 closed brackets.\\n ``req += 2``\\n* Now if I have an odd number of closed brackets, this means that we have one ``)`` for one of the ``(``, and now we have another open bracket. As the question says ``Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))``, so we need to give a ``)`` to the existing open bracket, and then process the new one.\\n``ans++   => We added a new closed bracket\\nreq--   =>  the existing lonely ) is paired and not needed now`` \\n\\n**2. We encounter a closed bracket**\\nIn this, we again have two things to understand: \\n* If we encounter a lone warrior, basically a ``) when req = 0``, this means we can manually add a ``(`` and then say that we encountered ``()``.\\n``ans++    => We added a new open bracket``\\n``req++    => Another closed bracket is required as we have ()``\\n* Otherwise, we directly reduce the number of required closed brackets.\\n ``req--``\\n \\n Code: - (C++ O(n))\\n \\n ```\\n class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int manual_add = 0;\\n        int req_close = 0;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            // we see an opening bracket\\n            if (s[i] == \\'(\\') {\\n                // increment closed req by 2\\n                req_close += 2;\\n                if (req_close%2 != 0) {\\n                    // if total is odd, we do the steps as explained above.\\n                    manual_add++;\\n                    req_close--;\\n                }\\n            } else {\\n                // we see a closing bracket\\n                \\n                if (req_close == 0) {\\n                    // lone warrior \\\\*o*/\\n                    manual_add++;\\n                    req_close++;\\n                } else  {\\n                    req_close--;\\n                }\\n            }\\n        }\\n        return manual_add + req_close;\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int manual_add = 0;\\n        int req_close = 0;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            // we see an opening bracket\\n            if (s[i] == \\'(\\') {\\n                // increment closed req by 2\\n                req_close += 2;\\n                if (req_close%2 != 0) {\\n                    // if total is odd, we do the steps as explained above.\\n                    manual_add++;\\n                    req_close--;\\n                }\\n            } else {\\n                // we see a closing bracket\\n                \\n                if (req_close == 0) {\\n                    // lone warrior \\\\*o*/\\n                    manual_add++;\\n                    req_close++;\\n                } else  {\\n                    req_close--;\\n                }\\n            }\\n        }\\n        return manual_add + req_close;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 780029,
                "title": "java-solusion-count-the-left-and-right-parenthese",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int ans=0;       \\n        int cnt=0;\\n        for(char ch:s.toCharArray()){     \\n            if(ch==\\'(\\') {\\n                cnt+=2;  \\n                if(cnt%2!=0){\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else{       \\n                cnt-=1;\\n                if(cnt<0){\\n                    ans++;\\n                    cnt+=2;\\n                } \\n            }           \\n        }\\n\\n        return ans+cnt;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int ans=0;       \\n        int cnt=0;\\n        for(char ch:s.toCharArray()){     \\n            if(ch==\\'(\\') {\\n                cnt+=2;  \\n                if(cnt%2!=0){\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else{       \\n                cnt-=1;\\n                if(cnt<0){\\n                    ans++;\\n                    cnt+=2;\\n                } \\n            }           \\n        }\\n\\n        return ans+cnt;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780409,
                "title": "python-simple-solution-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. Only 3 conditions, open brace -> push to stack\\n        ## 2. 2 close braces -> pop from stack, if you donot have enough open braces before increment count(indicates one open required)\\n        ## 3. Only 1 close brace found --> count + 1, to make it 2 close braces, if stack then just pop, if stack is empty then increment count by 2 (one for close brace, one for open brace)\\n        ## 4. If stack is still left with open braces, we require close braces = twice of that open braces in stack\\n        \\n        ## You can even optimize it, without using stack, just counting the left braces.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        s += \"$\"  # appending dummy character at the end, to make things simpler\\n        left_braces, count, i = 0, 0, 0\\n        while( i < len(s)-1 ):\\n            if s[i] == \"(\":\\n                left_braces, i = left_braces + 1, i + 1\\n            elif s[i] == \")\" and s[i+1] == \")\":\\n                if left_braces:\\n                    left_braces -= 1\\n                else:\\n                    count += 1                  # one open brace required\\n                i += 2\\n            elif s[i] == \")\" and s[i+1] != \")\":\\n                if left_braces:\\n                    count += 1                  # one close brace required\\n                    left_braces -= 1\\n                else:\\n                    count += 2                  # one open and one close brace required\\n                i += 1\\n        return count + (left_braces * 2)        # close braces required at the end for all the remaining left braces\\n```\\nPlease upvote if you liked my solution.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. Only 3 conditions, open brace -> push to stack\\n        ## 2. 2 close braces -> pop from stack, if you donot have enough open braces before increment count(indicates one open required)\\n        ## 3. Only 1 close brace found --> count + 1, to make it 2 close braces, if stack then just pop, if stack is empty then increment count by 2 (one for close brace, one for open brace)\\n        ## 4. If stack is still left with open braces, we require close braces = twice of that open braces in stack\\n        \\n        ## You can even optimize it, without using stack, just counting the left braces.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        s += \"$\"  # appending dummy character at the end, to make things simpler\\n        left_braces, count, i = 0, 0, 0\\n        while( i < len(s)-1 ):\\n            if s[i] == \"(\":\\n                left_braces, i = left_braces + 1, i + 1\\n            elif s[i] == \")\" and s[i+1] == \")\":\\n                if left_braces:\\n                    left_braces -= 1\\n                else:\\n                    count += 1                  # one open brace required\\n                i += 2\\n            elif s[i] == \")\" and s[i+1] != \")\":\\n                if left_braces:\\n                    count += 1                  # one close brace required\\n                    left_braces -= 1\\n                else:\\n                    count += 2                  # one open and one close brace required\\n                i += 1\\n        return count + (left_braces * 2)        # close braces required at the end for all the remaining left braces\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780291,
                "title": "java-linear-loop-and-o-1-space",
                "content": "```\\n    public int minInsertions(String s) {\\n        int st = 0, l = s.length(), res = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'(\\') st++;  // found a \\'(\\', push\\n            else {\\n                if (st == 0) {\\n                    res++;  // need insert a \\'(\\';\\n                    st++;\\n                }\\n                if (i + 1 < l && s.charAt(i + 1) == \\')\\') i++; //next loop start from i + 2;\\n                else res++;   // need insert a \\')\\'\\n                st--;  // found a match, pop;\\n            }\\n        }\\n        return res + st * 2;   // every unmatched \\'(\\', need two \\')\\';\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minInsertions(String s) {\\n        int st = 0, l = s.length(), res = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'(\\') st++;  // found a \\'(\\', push\\n            else {\\n                if (st == 0) {\\n                    res++;  // need insert a \\'(\\';\\n                    st++;\\n                }\\n                if (i + 1 < l && s.charAt(i + 1) == \\')\\') i++; //next loop start from i + 2;\\n                else res++;   // need insert a \\')\\'\\n                st--;  // found a match, pop;\\n            }\\n        }\\n        return res + st * 2;   // every unmatched \\'(\\', need two \\')\\';\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779917,
                "title": "c-o-n-o-1-track-left-and-right",
                "content": "```cpp\\nint minInsertions(string s) {\\n    int l = 0, r = 0, res = 0;\\n    for (auto ch : s) {\\n        if (ch == \\'(\\') {\\n            if (r != 0) {\\n                res += l > 0 ? 1 : 2;\\n                l = max(0, l - 1);\\n                r = 0;\\n            }\\n            ++l;\\n        } else if (++r == 2) {\\n            r = 0;\\n            if (l > 0)\\n                --l;\\n            else\\n                ++res;\\n        }\\n    }\\n    if (l > 0)\\n        return res + 2 * l - r;\\n    return res + (r == 1 ? 2 : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minInsertions(string s) {\\n    int l = 0, r = 0, res = 0;\\n    for (auto ch : s) {\\n        if (ch == \\'(\\') {\\n            if (r != 0) {\\n                res += l > 0 ? 1 : 2;\\n                l = max(0, l - 1);\\n                r = 0;\\n            }\\n            ++l;\\n        } else if (++r == 2) {\\n            r = 0;\\n            if (l > 0)\\n                --l;\\n            else\\n                ++res;\\n        }\\n    }\\n    if (l > 0)\\n        return res + 2 * l - r;\\n    return res + (r == 1 ? 2 : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779986,
                "title": "java-stack-solution-easy-to-understand",
                "content": "Idea:\\n\\n1. if the character is closing `)` \\n\\t* stack is not empty\\n\\t\\t if last character in stack is also `)` then just pop two characters from stack `())`\\n\\t\\t else add character in stack\\n\\t* to make balance we need to insert `(` before so increment count and add `(` in stack along with `)`\\n2. if the character is closing `(` \\n\\t* stack is not empty\\n\\t\\tif stack peek is also `(` just add into stakc\\n\\t\\telse count++ and pop from stack \\n\\t*  add into stack\\n\\t\\n3. loop until stack is not empty and check \\n\\t* if peek character `(` count += 2 and pop from stack once\\n\\t* else for `)` count++ and pop from stack twice\\n\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\')\\') {\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                } else {\\n                    count++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                }\\n            } else {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\'(\\') {\\n                        stack.add(c);\\n                    } else {\\n                        count++;\\n                        stack.pop();\\n                    }\\n                } else {\\n                    stack.add(c);\\n                }\\n            }\\n        }\\n\\n        while (!stack.isEmpty()) {\\n            if (stack.peek() == \\'(\\') {\\n                count += 2;\\n                stack.pop();\\n            } else {\\n                count++;\\n                stack.pop();\\n                stack.pop();\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\')\\') {\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                } else {\\n                    count++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                }\\n            } else {\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek() == \\'(\\') {\\n                        stack.add(c);\\n                    } else {\\n                        count++;\\n                        stack.pop();\\n                    }\\n                } else {\\n                    stack.add(c);\\n                }\\n            }\\n        }\\n\\n        while (!stack.isEmpty()) {\\n            if (stack.peek() == \\'(\\') {\\n                count += 2;\\n                stack.pop();\\n            } else {\\n                count++;\\n                stack.pop();\\n                stack.pop();\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779956,
                "title": "java-solution-without-using-stack-just-with-counter",
                "content": "The idea is to save down the count of left parenthesis, then match it with double \\')\\'.\\nIf case of single \\')\\' or end of String happened, we did special handling as shown below.\\n\\n```\\npublic int minInsertions(String s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') { // when (\\n                left++;\\n            } else if (i == s.length() - 1 || s.charAt(i + 1) == \\'(\\') { // when single )\\n                if (left > 0) {\\n                    res++;\\n                    left--;\\n                } else {\\n                    res += 2;\\n                }\\n            } else { // when double )\\n                if (left > 0) left--;\\n                else res++;\\n                i++; // advance pointer since we have process double ) in a time\\n            }\\n        }\\n        res += left * 2;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minInsertions(String s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') { // when (\\n                left++;\\n            } else if (i == s.length() - 1 || s.charAt(i + 1) == \\'(\\') { // when single )\\n                if (left > 0) {\\n                    res++;\\n                    left--;\\n                } else {\\n                    res += 2;\\n                }\\n            } else { // when double )\\n                if (left > 0) left--;\\n                else res++;\\n                i++; // advance pointer since we have process double ) in a time\\n            }\\n        }\\n        res += left * 2;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779974,
                "title": "c-solution-using-stack-and-conditions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> v;\\n        int ans = 0;\\n        for(int i = 0;i < s.size();i++){\\n            if(s[i] == \\'(\\') v.push(s[i]);\\n            else{\\n                if(s[i] == \\')\\' && i < s.size() && s[i + 1] == \\')\\') {\\n                    if(!v.empty())\\n                        v.pop();\\n                    else ans++;\\n                    i++;       // because we considered i+1 in this case\\n                }\\n                else if(s[i] == \\')\\' && i < s.size() && s[i + 1] != \\')\\'){\\n                    if(!v.empty()){\\n                        v.pop();\\n                        ans++;\\n                    }\\n                    else ans += 2;\\n                }\\n            }\\n        }\\n        if(v.empty()) return ans;\\n        return v.size()*2 + ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> v;\\n        int ans = 0;\\n        for(int i = 0;i < s.size();i++){\\n            if(s[i] == \\'(\\') v.push(s[i]);\\n            else{\\n                if(s[i] == \\')\\' && i < s.size() && s[i + 1] == \\')\\') {\\n                    if(!v.empty())\\n                        v.pop();\\n                    else ans++;\\n                    i++;       // because we considered i+1 in this case\\n                }\\n                else if(s[i] == \\')\\' && i < s.size() && s[i + 1] != \\')\\'){\\n                    if(!v.empty()){\\n                        v.pop();\\n                        ans++;\\n                    }\\n                    else ans += 2;\\n                }\\n            }\\n        }\\n        if(v.empty()) return ans;\\n        return v.size()*2 + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780161,
                "title": "simple-java-solution-using-stack",
                "content": "Also viewable on [Github here](https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/_1541.java).\\n```\\n public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int insertionsNeeded = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                if (stack.isEmpty()) {\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we need to add one more \\')\\' to get two consecutive right paren, then we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        insertionsNeeded++;\\n                        stack.pop();\\n                        stack.pop();\\n                        stack.add(c);\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    //in this case, we need to add one \\'(\\' before we add this \\')\\' onto this stack\\n                    insertionsNeeded++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            }\\n        }\\n        if (stack.isEmpty()) {\\n            return insertionsNeeded;\\n        } else {\\n            while (!stack.isEmpty()) {\\n                char pop = stack.pop();\\n                if (pop == \\'(\\') {\\n                    insertionsNeeded += 2;\\n                } else {\\n                    insertionsNeeded++;\\n                    stack.pop();\\n                }\\n            }\\n            return insertionsNeeded;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int insertionsNeeded = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'(\\') {\\n                if (stack.isEmpty()) {\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we need to add one more \\')\\' to get two consecutive right paren, then we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        insertionsNeeded++;\\n                        stack.pop();\\n                        stack.pop();\\n                        stack.add(c);\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            } else if (c == \\')\\') {\\n                if (stack.isEmpty()) {\\n                    //in this case, we need to add one \\'(\\' before we add this \\')\\' onto this stack\\n                    insertionsNeeded++;\\n                    stack.add(\\'(\\');\\n                    stack.add(c);\\n                } else {\\n                    if (stack.peek() == \\')\\') {\\n                        //in this case, we could pop the one \\')\\' and one \\'(\\' off the stack\\n                        stack.pop();\\n                        stack.pop();\\n                    } else {\\n                        stack.add(c);\\n                    }\\n                }\\n            }\\n        }\\n        if (stack.isEmpty()) {\\n            return insertionsNeeded;\\n        } else {\\n            while (!stack.isEmpty()) {\\n                char pop = stack.pop();\\n                if (pop == \\'(\\') {\\n                    insertionsNeeded += 2;\\n                } else {\\n                    insertionsNeeded++;\\n                    stack.pop();\\n                }\\n            }\\n            return insertionsNeeded;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797128,
                "title": "c-o-n-step-by-step-from-space-o-n-to-o-1",
                "content": "1. Naive Implementation [Time O(n) Space O(n)]\\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(s.empty()){\\n                    if(i+1<n && t[i+1]==\\')\\')\\n                        ans++,i++;\\n                    else\\n                        ans+=2;\\n                }\\n                else{\\n\\t\\t\\t\\t\\ts.pop();\\n                    if(i+1<n && t[i+1]==\\')\\') i++;\\n                    else ans++;\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\\n2. Concise Implementation [Time O(n) Space O(n)]\\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(s.empty()) ans++;\\n                else s.pop();\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\\n3. Final Code  [Time O(n) Space O(1)]\\n```\\n    int minInsertions(string t) {\\n        \\n        int top=0,ans=0;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                top++;\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(top==0) ans++;\\n                else top--;\\n            }\\n        }\\n\\n        return ans+2*top;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(s.empty()){\\n                    if(i+1<n && t[i+1]==\\')\\')\\n                        ans++,i++;\\n                    else\\n                        ans+=2;\\n                }\\n                else{\\n\\t\\t\\t\\t\\ts.pop();\\n                    if(i+1<n && t[i+1]==\\')\\') i++;\\n                    else ans++;\\t\\t\\t\\t\\t\\n                }\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\n```\\n    int minInsertions(string t) {\\n        int ans=0;\\n        stack<char> s;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                s.push(\\'(\\');\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(s.empty()) ans++;\\n                else s.pop();\\n            }\\n        }\\n        \\n        while(!s.empty()){\\n            s.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n```\n```\\n    int minInsertions(string t) {\\n        \\n        int top=0,ans=0;\\n        int n = t.length();\\n        for(int i=0;i<n;i++){\\n            char c = t[i];\\n            if(c==\\'(\\')\\n                top++;\\n            else{\\n                if(i+1<n && t[i+1]==\\')\\') i++;\\n                else ans++;\\n                \\n                if(top==0) ans++;\\n                else top--;\\n            }\\n        }\\n\\n        return ans+2*top;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779978,
                "title": "simple-solution-in-o-n-intuitive-beats-100-python-explanation",
                "content": "1- First we replace all double closed brackets with a single squared closed bracket as that is what they behave like.\\n2- Then we find all alone closed brackets. Since they are useless alone we add one more closed bracket to all of them and again replace them with a single squared closed bracket.\\n3- Then do simple balancing\\n\\n```Python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ret=0\\n        s = s.replace(\\'))\\', \\']\\')\\n        ret+=s.count(\\')\\')\\n        s = s.replace(\\')\\', \\']\\')\\n        bal = 0\\n        for i,v in enumerate(s):\\n            if v == \\'(\\':\\n                bal+=1\\n            elif v==\\']\\':\\n                bal-=1\\n            if bal==-1:\\n                ret+=1\\n                bal+=1\\n        return ret + 2*bal\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ret=0\\n        s = s.replace(\\'))\\', \\']\\')\\n        ret+=s.count(\\')\\')\\n        s = s.replace(\\')\\', \\']\\')\\n        bal = 0\\n        for i,v in enumerate(s):\\n            if v == \\'(\\':\\n                bal+=1\\n            elif v==\\']\\':\\n                bal-=1\\n            if bal==-1:\\n                ret+=1\\n                bal+=1\\n        return ret + 2*bal\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779885,
                "title": "stack-like-operation-but-don-t-need-a-stack",
                "content": "```\\nint minInsertions(string s) {\\n        int res = 0; //operations we added\\n        int n = s.size();\\n        int left = 0; //how many \\'(\\'\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if(left == 0) {\\n                    ++res; //add \\'(\\'\\n                    ++left; //we actually manually added a \\'(\\'\\n                }\\n                \\n                //if we happen to have \"))\", we simply pop a \\'(\\'\\n                if(i < n-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                    --left;\\n                \\n                } else {\\n                    //otherwise, we add a \\')\\' and pop a \\'(\\'\\n                    --left;\\n                    ++res; //add \\')\\'\\'\\n                }\\n            }\\n        }\\n        return res + 2*left;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n        int res = 0; //operations we added\\n        int n = s.size();\\n        int left = 0; //how many \\'(\\'\\n        \\n        for(int i = 0; i < n; ++i) {\\n            if(s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if(left == 0) {\\n                    ++res; //add \\'(\\'\\n                    ++left; //we actually manually added a \\'(\\'\\n                }\\n                \\n                //if we happen to have \"))\", we simply pop a \\'(\\'\\n                if(i < n-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                    --left;\\n                \\n                } else {\\n                    //otherwise, we add a \\')\\' and pop a \\'(\\'\\n                    --left;\\n                    ++res; //add \\')\\'\\'\\n                }\\n            }\\n        }\\n        return res + 2*left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1214894,
                "title": "java-constant-space-solution-one-pass",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                if(i+1<s.length() && s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(open>0){\\n                        open--;\\n                    }\\n                    else{\\n                        ans++;\\n                    }\\n                }\\n                else{\\n                    if(open>0){\\n                        open--;\\n                        ans++;\\n                    }\\n                    else{\\n                        ans+=2;\\n                    }\\n                }\\n            }\\n        }\\n        ans+=2*open;\\n        return ans;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open=0;\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                if(i+1<s.length() && s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(open>0){\\n                        open--;\\n                    }\\n                    else{\\n                        ans++;\\n                    }\\n                }\\n                else{\\n                    if(open>0){\\n                        open--;\\n                        ans++;\\n                    }\\n                    else{\\n                        ans+=2;\\n                    }\\n                }\\n            }\\n        }\\n        ans+=2*open;\\n        return ans;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574980,
                "title": "java-solution-o-1-space-explained-in-comments",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int countBraces = 0;\\n        int ans = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                countBraces += 1;\\n            }\\n            else{\\n                //Case 1-> Whenever a closing bracket is encountered, one case can be it is followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    if(countBraces > 0){\\n                        countBraces--; // It\\'s balanced only.. Just decrement the opening bracket\\n                    }\\n                    else{\\n                        //This is the case for --> \"))\" It means we need to add 1 opening bracket --> \"(\"\\n                        ans += 1;\\n                    }\\n                    i++;\\n                }\\n                else{\\n                    //Case 2 -> Whenever a closing bracket is encountered, another case can be it is not followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                    if(countBraces > 0){\\n                        countBraces--;\\n                        ans += 1;//Add the last closing bracket to balance\\n                    }\\n                    else{\\n                        \\n                        ans += 2;//Add the last closing bracket and first opening bracket(eg.test case-> \")\")\\n                    }\\n                }\\n                //Finally we should return the 2times the number of countBraces(opening brackets remaining in excess)\\n            }\\n        }\\n        return ans+countBraces*2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int countBraces = 0;\\n        int ans = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                countBraces += 1;\\n            }\\n            else{\\n                //Case 1-> Whenever a closing bracket is encountered, one case can be it is followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    if(countBraces > 0){\\n                        countBraces--; // It\\'s balanced only.. Just decrement the opening bracket\\n                    }\\n                    else{\\n                        //This is the case for --> \"))\" It means we need to add 1 opening bracket --> \"(\"\\n                        ans += 1;\\n                    }\\n                    i++;\\n                }\\n                else{\\n                    //Case 2 -> Whenever a closing bracket is encountered, another case can be it is not followed by another closing bracket and preceeded/not preceeded by an opening bracket(handled in this following if block)\\n                    if(countBraces > 0){\\n                        countBraces--;\\n                        ans += 1;//Add the last closing bracket to balance\\n                    }\\n                    else{\\n                        \\n                        ans += 2;//Add the last closing bracket and first opening bracket(eg.test case-> \")\")\\n                    }\\n                }\\n                //Finally we should return the 2times the number of countBraces(opening brackets remaining in excess)\\n            }\\n        }\\n        return ans+countBraces*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488865,
                "title": "simple-soln-using-stack",
                "content": "```\\n  int minInsertions(string s) {\\n        int n=s.size();\\n        stack<char>stk;\\n        int minInsert=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else \\n            {\\n                if( s[i] == \\')\\' && i < n && s[i + 1] == \\')\\')\\n                {\\n                    if(!stk.empty())\\n                    {\\n                       stk.pop();\\n                    }\\n                    else\\n                    {\\n                        minInsert++;\\n                    }\\n                    \\n                    i++;\\n                }\\n                \\n                else if(s[i] == \\')\\' && i < n && s[i + 1] != \\')\\' ) {\\n                    if(!stk.empty()){\\n                        stk.pop();\\n                        minInsert++;\\n                    }\\n                    else minInsert += 2;\\n                \\n            }\\n        }\\n        \\n    }\\n         \\n        if(stk.empty())\\n        {return minInsert;}\\n        else\\n        {return minInsert+2*stk.size();}\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n  int minInsertions(string s) {\\n        int n=s.size();\\n        stack<char>stk;\\n        int minInsert=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(s[i]);\\n            }\\n            else \\n            {\\n                if( s[i] == \\')\\' && i < n && s[i + 1] == \\')\\')\\n                {\\n                    if(!stk.empty())\\n                    {\\n                       stk.pop();\\n                    }\\n                    else\\n                    {\\n                        minInsert++;\\n                    }\\n                    \\n                    i++;\\n                }\\n                \\n                else if(s[i] == \\')\\' && i < n && s[i + 1] != \\')\\' ) {\\n                    if(!stk.empty()){\\n                        stk.pop();\\n                        minInsert++;\\n                    }\\n                    else minInsert += 2;\\n                \\n            }\\n        }\\n        \\n    }\\n         \\n        if(stk.empty())\\n        {return minInsert;}\\n        else\\n        {return minInsert+2*stk.size();}\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778621,
                "title": "c-100-faster-solution-o-n",
                "content": "****Please upvote me :)****\\n```\\nint minInsertions(string s) {\\n\\n        int add = 0, bal = 0;\\n        for (const auto& c: s) {\\n            if (c == \\'(\\') {\\n                if (bal % 2 > 0) {\\n                    ++add;  // add \\')\\' to make sure consecutive \\')\\'\\n                    --bal;\\n                }\\n                bal += 2;\\n            } else {\\n                --bal;\\n                if (bal < 0) {\\n                    ++add;  // add \\'(\\'\\n                    bal += 2;\\n                }\\n            }\\n        }\\n        return add + bal;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minInsertions(string s) {\\n\\n        int add = 0, bal = 0;\\n        for (const auto& c: s) {\\n            if (c == \\'(\\') {\\n                if (bal % 2 > 0) {\\n                    ++add;  // add \\')\\' to make sure consecutive \\')\\'\\n                    --bal;\\n                }\\n                bal += 2;\\n            } else {\\n                --bal;\\n                if (bal < 0) {\\n                    ++add;  // add \\'(\\'\\n                    bal += 2;\\n                }\\n            }\\n        }\\n        return add + bal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391464,
                "title": "clear-explanation-c-one-pass-greedy",
                "content": "**Intution :**\\n\\nFor such kind of balancing parenthesis first thing should strike is Greedy along with Stack to balance. \\nLets see how to solve these kind of problems.\\n\\n* Idea is simple, at every index in string we need to keep the balance of opening and closing brackets i.e.\\n\\t\\n\\tcount of \\'(\\' >= count of \\')\\'  -> for all index i from 0 to n\\n\\t\\n* And to track balance at *every index i* we have two conditions : \\n\\t\\n\\t1. if element at current index i is \\'(\\' \\n\\t\\t-> do balance + 2 , since for two \\') )\\' we have one \\'(\\' \\n\\t\\t\\n\\t2. else if element is \\')\\', then do [balance - 2]\\n\\t\\t -> if next is also \\')\\' then increment i as we got two consecutive \\'))\\'\\n\\t\\t -> else we need to insert one \\')\\' next to this. So increment number of insertions counter.\\n\\n* Also, if at any point this inequality fails i.e. \\n\\t* balance become negative or \\n\\n\\t\\t*\\t\\tcount of \\'(\\' < count of \\')\\'\\n\\t\\n\\t* We need to balance that by inserting (actually increamenting count) counter bracket .\\n\\t\\n\\t\\t\\tif balance < 0, we have two cases either balance = -1 or -2\\n\\t\\t\\t\\n\\t\\t\\t\\t-> When balance = -1, this means we have only \\'(\\'\\n\\t\\t\\t\\t\\tand we need to insert one \\'(\\' and one \\')\\'.\\n\\t\\t\\t\\t\\tSo incease the counter of number of insertions by 2.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t-> When balance = -2, this means we have two consecutive \\')\\' i.e \\') ) \\'\\n\\t\\t\\t\\t\\t and we just need single \\'(\\' to balance it.\\n\\t\\t\\t\\t\\t Thus increase counter only by 1. \\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\tIn the end, we also need to reset balance to 0 as we have \\'( ) )\\' -> valid string\\n\\n* Now, there may be some case when balance > 0. This means we have some extra \\'(\\' which do not have their counter parts. \\n* So, we have to insert those many \\')\\' to make balance=0. Thus, increament remaining to counter.\\n\\t\\n\\t\\n# Code : \\t\\n \\t\\n```\\nint minInsertions(string s) {\\n        \\n\\tint n = s.size();\\n\\tint cntInsertions = 0, balance = 0;\\n\\n\\tfor(int i=0; i<n; )\\n\\t{\\n\\tif(s[i] == \\'(\\') balance += 2;\\n\\telse if(s[i] == \\')\\')\\n\\t{\\n\\t\\tbalance -= 2;\\n\\t\\tif(i+1<n && s[i+1] == \\')\\')\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tcntInsertions++;\\n\\t\\t}\\n\\t}\\n\\tif(balance < 0)\\n\\t{\\n\\t\\tif(balance == -2) cntInsertions++;\\n\\t\\telse cntInsertions += 2;\\n\\t\\tbalance = 0;\\n\\t}\\n\\ti++;\\n\\n\\t// cout << balance << \" \" << cntInsertions << endl;\\n\\t}\\n\\tcntInsertions += balance;\\n\\treturn cntInsertions;\\n}\\n```\\n\\n**Time : O(N) Single pass**\\n**Space : O(1)**\\n\\nAlso do try similar problems for better grip over such problems. \\n\\n**Hope this explanation was crystal clear, and in case of any query let me know.... :)**\\n***If you understood do upvote post !!!***",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minInsertions(string s) {\\n        \\n\\tint n = s.size();\\n\\tint cntInsertions = 0, balance = 0;\\n\\n\\tfor(int i=0; i<n; )\\n\\t{\\n\\tif(s[i] == \\'(\\') balance += 2;\\n\\telse if(s[i] == \\')\\')\\n\\t{\\n\\t\\tbalance -= 2;\\n\\t\\tif(i+1<n && s[i+1] == \\')\\')\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\telse \\n\\t\\t{\\n\\t\\t\\tcntInsertions++;\\n\\t\\t}\\n\\t}\\n\\tif(balance < 0)\\n\\t{\\n\\t\\tif(balance == -2) cntInsertions++;\\n\\t\\telse cntInsertions += 2;\\n\\t\\tbalance = 0;\\n\\t}\\n\\ti++;\\n\\n\\t// cout << balance << \" \" << cntInsertions << endl;\\n\\t}\\n\\tcntInsertions += balance;\\n\\treturn cntInsertions;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1146014,
                "title": "single-pass-without-extra-space",
                "content": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        int count=0,open=0,n=s.size();\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'(\\') open+=1;\\n            else if(s[i]==\\')\\' && i+1<n && s[i+1]==\\')\\'){\\n                \\n                if(open==0) count+=1;\\n                else open--;\\n                i++;\\n           }\\n            \\n         else if(s[i]==\\')\\' && i+1<n && s[i+1]!=\\')\\'){\\n             \\n             if(open==0) count+=2;\\n             else {\\n                 count+=1;\\n                 open--;\\n             }\\n        }\\n       \\n        else if(s[i]==\\')\\' && i+1==n){\\n            if(open==0) count+=2;\\n            else{\\n                open--;\\n                count+=1;\\n            }\\n         }\\n            \\n        }\\n        \\n        count+=(open*2);\\n        return count;\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        int count=0,open=0,n=s.size();\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'(\\') open+=1;\\n            else if(s[i]==\\')\\' && i+1<n && s[i+1]==\\')\\'){\\n                \\n                if(open==0) count+=1;\\n                else open--;\\n                i++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2666960,
                "title": "c-80-faster-than-all-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minInsertions(string s) {\\n        if(s.size() == 0) return 0;\\n        int stack = 0;\\n        int invalidRight = 0;\\n        \\n        for(int i =0;i<s.size();i++){\\n            char ch = s[i];\\n            \\n            if(ch == \\'(\\') stack++;\\n            else {\\n                if(i+1 == s.size() || s[i+1]!= \\')\\') invalidRight++;\\n                else {i++;} \\n                \\n                if(stack == 0) invalidRight++;\\n                else stack--;\\n            }\\n        }\\n        return invalidRight + 2*stack;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minInsertions(string s) {\\n        if(s.size() == 0) return 0;\\n        int stack = 0;\\n        int invalidRight = 0;\\n        \\n        for(int i =0;i<s.size();i++){\\n            char ch = s[i];\\n            \\n            if(ch == \\'(\\') stack++;\\n            else {\\n                if(i+1 == s.size() || s[i+1]!= \\')\\') invalidRight++;\\n                else {i++;} \\n                \\n                if(stack == 0) invalidRight++;\\n                else stack--;\\n            }\\n        }\\n        return invalidRight + 2*stack;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034943,
                "title": "java-o-n-time-and-o-1-space-with-explanation",
                "content": "According to the description, we can have:\\n1. for any `(`, there must have a corresponding `))` in the remaining string\\n2. for any `)`, there must have a corresponding `(` in the previous string and a successive `)` \\n\\nWe can summarize that there are totally 4 cases for a given string:\\n1. `(` and `))`, which is a vaild case\\n2. `(` and `)`, which means we must add a `)`\\n3. only `)`, which meast we must add a `)` and a `(`\\n4. only `))`, which means we must add a `(`\\n5. only `(`, which means we mustt add a `))`\\n\\nwe only care about whether we can make every `(` has a corresonding `))`, no matter what sequence it is, then we can use greedy algorithm.\\n\\n**Algorithm**\\n\\n    public int minInsertions(String s) {\\n\\t    // record the \\'(\\' number we meet so far\\n        int left = 0;\\n        int res = 0;\\n        int right = 0;\\n        while (right < s.length()) {\\n            char curr = s.charAt(right);\\n            if (curr == \\'(\\') {\\n                left++;\\n            } else {\\n                if (right + 1 == s.length() || s.charAt(right + 1) != \\')\\') {\\n\\t\\t\\t\\t    // get only one \\')\\', which means we must insert another \\')\\', so add 1 to result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // get \\'))\\', no need to insert, move pointer to the next\\n                    right++;\\n                }\\n\\t\\t\\t\\t// after above operation, we get \\'))\\', then we need to check \\'(\\'\\n                if (left == 0) {\\n\\t\\t\\t\\t    // no \\'(\\' for \\'))\\', which means we must insert a \\'(\\', add 1 to the result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // we meet a valid \\'())\\', delete a \\'(\\' from the \\'(\\' number\\n                    left--;\\n                }\\n            }\\n            right++;\\n        }\\n\\t\\t// if still remain \\'(\\', insert \\'))\\' for each \\'(\\'\\n        return res + left * 2;\\n    }",
                "solutionTags": [],
                "code": "According to the description, we can have:\\n1. for any `(`, there must have a corresponding `))` in the remaining string\\n2. for any `)`, there must have a corresponding `(` in the previous string and a successive `)` \\n\\nWe can summarize that there are totally 4 cases for a given string:\\n1. `(` and `))`, which is a vaild case\\n2. `(` and `)`, which means we must add a `)`\\n3. only `)`, which meast we must add a `)` and a `(`\\n4. only `))`, which means we must add a `(`\\n5. only `(`, which means we mustt add a `))`\\n\\nwe only care about whether we can make every `(` has a corresonding `))`, no matter what sequence it is, then we can use greedy algorithm.\\n\\n**Algorithm**\\n\\n    public int minInsertions(String s) {\\n\\t    // record the \\'(\\' number we meet so far\\n        int left = 0;\\n        int res = 0;\\n        int right = 0;\\n        while (right < s.length()) {\\n            char curr = s.charAt(right);\\n            if (curr == \\'(\\') {\\n                left++;\\n            } else {\\n                if (right + 1 == s.length() || s.charAt(right + 1) != \\')\\') {\\n\\t\\t\\t\\t    // get only one \\')\\', which means we must insert another \\')\\', so add 1 to result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // get \\'))\\', no need to insert, move pointer to the next\\n                    right++;\\n                }\\n\\t\\t\\t\\t// after above operation, we get \\'))\\', then we need to check \\'(\\'\\n                if (left == 0) {\\n\\t\\t\\t\\t    // no \\'(\\' for \\'))\\', which means we must insert a \\'(\\', add 1 to the result\\n                    res++;\\n                } else {\\n\\t\\t\\t\\t    // we meet a valid \\'())\\', delete a \\'(\\' from the \\'(\\' number\\n                    left--;\\n                }\\n            }\\n            right++;\\n        }\\n\\t\\t// if still remain \\'(\\', insert \\'))\\' for each \\'(\\'\\n        return res + left * 2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2028472,
                "title": "javascript-o-1-space",
                "content": "``` \\nvar minInsertions = function(s) {\\n    let rightNeeded = 0;\\n    let leftNeeded = 0;\\n    for (const char of s) {\\n        if (char === \"(\") {\\n            if (rightNeeded % 2 === 0) {\\n                rightNeeded += 2;  \\n            } else {                \\n                rightNeeded++;\\n                leftNeeded++;\\n            }\\n        } else {\\n            rightNeeded--;\\n            if (rightNeeded === -1 ){\\n                leftNeeded++;\\n                rightNeeded = 1;\\n            }\\n        }\\n    }\\n    return leftNeeded + rightNeeded;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar minInsertions = function(s) {\\n    let rightNeeded = 0;\\n    let leftNeeded = 0;\\n    for (const char of s) {\\n        if (char === \"(\") {\\n            if (rightNeeded % 2 === 0) {\\n                rightNeeded += 2;  \\n            } else {                \\n                rightNeeded++;\\n                leftNeeded++;\\n            }\\n        } else {\\n            rightNeeded--;\\n            if (rightNeeded === -1 ){\\n                leftNeeded++;\\n                rightNeeded = 1;\\n            }\\n        }\\n    }\\n    return leftNeeded + rightNeeded;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736069,
                "title": "java-one-pass-o-1-space-with-explanation",
                "content": "```\\n// Define balance such that \\'(\\' increments it by 2, and \\')\\' decrements it by 1. 0 balance is expected at the end.\\n// if \\'(\\' comes, make sure balance is not an odd number, because then one opening parenthesis has only been partially closed. If balance is odd, we need to add ), and modify balance accordingly.\\n// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n```\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count = 0; // tracks the extra additions we have made\\n        int balance = 0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n\\t\\t\\t\\n\\t\\t\\t    // if \\'(\\' comes, make sure balance is not an odd number, \\n\\t\\t\\t\\t// because then one opening parenthesis has only been partially closed. \\n\\t\\t\\t\\tif(balance%2==1){\\n                    count ++;    // we need to add )\\n                    balance--;    // modify balance accordingly.\\n                }\\n\\t\\t\\t\\t// Since we added a \\'(\\'\\n                balance+=2;\\n            }else if(c == \\')\\'){\\n                balance --;\\n            }\\n            \\n\\t\\t\\t// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n            if(balance<0){\\n                count++;\\n                balance+=2;\\n            }\\n        }\\n        \\n\\t\\t// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n        return count + balance;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Define balance such that \\'(\\' increments it by 2, and \\')\\' decrements it by 1. 0 balance is expected at the end.\\n// if \\'(\\' comes, make sure balance is not an odd number, because then one opening parenthesis has only been partially closed. If balance is odd, we need to add ), and modify balance accordingly.\\n// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count = 0; // tracks the extra additions we have made\\n        int balance = 0;\\n        \\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n\\t\\t\\t\\n\\t\\t\\t    // if \\'(\\' comes, make sure balance is not an odd number, \\n\\t\\t\\t\\t// because then one opening parenthesis has only been partially closed. \\n\\t\\t\\t\\tif(balance%2==1){\\n                    count ++;    // we need to add )\\n                    balance--;    // modify balance accordingly.\\n                }\\n\\t\\t\\t\\t// Since we added a \\'(\\'\\n                balance+=2;\\n            }else if(c == \\')\\'){\\n                balance --;\\n            }\\n            \\n\\t\\t\\t// if balance going negative, we have extra closing parenthesis. Add \\'(\\' and inc by bal by 2. \\n            if(balance<0){\\n                count++;\\n                balance+=2;\\n            }\\n        }\\n        \\n\\t\\t// At the end, if balance>0, we need to add extra \\')\\' to make balance=0.\\n        return count + balance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730396,
                "title": "python-simplest-one-pass",
                "content": "O(N) time complexity, O(1) space complexity\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        leftbrackets = insertions = 0\\n        i, n = 0, len(s)\\n\\n        while i < n:\\n            if s[i] == \\'(\\':\\n                leftbrackets += 1\\n            elif s[i] == \\')\\':\\n                if i == n-1 or s[i+1] != \\')\\': insertions += 1\\n                else: i += 1\\n                    \\n                if not leftbrackets: insertions += 1\\n                else: leftbrackets -= 1\\n                    \\n            i += 1\\n        \\n        return leftbrackets * 2 + insertions",
                "solutionTags": [
                    "Python"
                ],
                "code": "O(N) time complexity, O(1) space complexity\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        leftbrackets = insertions = 0\\n        i, n = 0, len(s)\\n\\n        while i < n:\\n            if s[i] == \\'(\\':\\n                leftbrackets += 1\\n            elif s[i] == \\')\\':\\n                if i == n-1 or s[i+1] != \\')\\': insertions += 1\\n                else: i += 1\\n                    \\n                if not leftbrackets: insertions += 1\\n                else: leftbrackets -= 1\\n                    \\n            i += 1\\n        \\n        return leftbrackets * 2 + insertions",
                "codeTag": "Java"
            },
            {
                "id": 1650461,
                "title": "c-left-to-right-right-to-left-most-intuitive-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        \\n        int minInsert = 0; // final answer \\n        \\n        vector<char> ss; // is the equivalent string wherein \\'))\\' is denoted by a single \\')\\'\\n        \\n        \\n       //1. Find the number of inserts to make consecutive \\'))\\'---\\n        for(int i=0;i<n;i++){\\n            ss.push_back(s[i]);\\n            \\n            if(s[i] == \\')\\'){\\n                if(i == n-1 || s[i+1] != \\')\\')\\n                    minInsert++;\\n                else\\n                    i++;\\n            }\\n        }\\n        //---------------------------------------------------------\\n        \\n        \\n        //2. Now, just usual minimum inserts to balance where \\'ss\\' is the new string we will use\\n        n = ss.size();\\n        \\n        \\n        //2.1: left-to-right -> to balance unpaired \\')\\' \\n        int balance = 0;\\n        for(int i=0;i<n;i++){\\n            balance += (ss[i]==\\'(\\') - (ss[i]==\\')\\');\\n            if(balance == -1){\\n                minInsert+=1; // we need 1 extra \\'(\\' to balance one unpaired \\')\\' {wherein \\')\\' == \\'))\\' as per problem}\\n                balance= 0;\\n            }\\n        }\\n        \\n        \\n        //2.2: right-to-left -> to balance unpaired \\'(\\'\\n        balance = 0;\\n        for(int i=n-1;i>=0;i--){\\n            balance += (ss[i]==\\')\\') - (ss[i]==\\'(\\');\\n            if(balance == -1){\\n                minInsert+=2; // NOTE: we need \\'))\\' to balance one unpaired \\'(\\', hence +=2\\n                balance = 0;\\n            }\\n        }\\n        \\n        \\n        return minInsert; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        \\n        int minInsert = 0; // final answer \\n        \\n        vector<char> ss; // is the equivalent string wherein \\'))\\' is denoted by a single \\')\\'\\n        \\n        \\n       //1. Find the number of inserts to make consecutive \\'))\\'---\\n        for(int i=0;i<n;i++){\\n            ss.push_back(s[i]);\\n            \\n            if(s[i] == \\')\\'){\\n                if(i == n-1 || s[i+1] != \\')\\')\\n                    minInsert++;\\n                else\\n                    i++;\\n            }\\n        }\\n        //---------------------------------------------------------\\n        \\n        \\n        //2. Now, just usual minimum inserts to balance where \\'ss\\' is the new string we will use\\n        n = ss.size();\\n        \\n        \\n        //2.1: left-to-right -> to balance unpaired \\')\\' \\n        int balance = 0;\\n        for(int i=0;i<n;i++){\\n            balance += (ss[i]==\\'(\\') - (ss[i]==\\')\\');\\n            if(balance == -1){\\n                minInsert+=1; // we need 1 extra \\'(\\' to balance one unpaired \\')\\' {wherein \\')\\' == \\'))\\' as per problem}\\n                balance= 0;\\n            }\\n        }\\n        \\n        \\n        //2.2: right-to-left -> to balance unpaired \\'(\\'\\n        balance = 0;\\n        for(int i=n-1;i>=0;i--){\\n            balance += (ss[i]==\\')\\') - (ss[i]==\\'(\\');\\n            if(balance == -1){\\n                minInsert+=2; // NOTE: we need \\'))\\' to balance one unpaired \\'(\\', hence +=2\\n                balance = 0;\\n            }\\n        }\\n        \\n        \\n        return minInsert; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779952,
                "title": "python-using-stack-o-n-100-time",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = []\\n        cur_closed = 0\\n        modifications_needed = 0\\n        \\n        for char in s:\\n            if char == \\'(\\':\\n                if cur_closed == 1:\\n                    modifications_needed += 1\\n                    cur_closed = 0\\n                    stack.pop()\\n                    \\n                stack.append(\\'(\\')\\n            \\n            else:\\n                if not stack:\\n                    stack.append(\\'(\\')\\n                    modifications_needed += 1\\n                    cur_closed += 1\\n                    \\n                elif cur_closed == 1:\\n                    cur_closed = 0\\n                    stack.pop()\\n                else:\\n                    cur_closed += 1\\n                    \\n        if stack:\\n            modifications_needed += (len(stack) * 2) - cur_closed\\n            \\n        return modifications_needed\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = []\\n        cur_closed = 0\\n        modifications_needed = 0\\n        \\n        for char in s:\\n            if char == \\'(\\':\\n                if cur_closed == 1:\\n                    modifications_needed += 1\\n                    cur_closed = 0\\n                    stack.pop()\\n                    \\n                stack.append(\\'(\\')\\n            \\n            else:\\n                if not stack:\\n                    stack.append(\\'(\\')\\n                    modifications_needed += 1\\n                    cur_closed += 1\\n                    \\n                elif cur_closed == 1:\\n                    cur_closed = 0\\n                    stack.pop()\\n                else:\\n                    cur_closed += 1\\n                    \\n        if stack:\\n            modifications_needed += (len(stack) * 2) - cur_closed\\n            \\n        return modifications_needed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779910,
                "title": "c-easy-to-understand-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.length();\\n        stack<char> st;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'(\\') st.push(s[i]);\\n            else {\\n                // If we have both )) in the string, increment i and if we have a single ) increase count\\n                if (i + 1 < n && s[i] == s[i + 1]) i++;\\n                else count++;\\n                \\n                // If we have ( for corresponding )), pop otherwise increase the count.\\n                if (!st.empty()) st.pop();\\n                else count++;\\n            }\\n        }\\n        \\n        return count + st.size() * 2;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.length();\\n        stack<char> st;\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == \\'(\\') st.push(s[i]);\\n            else {\\n                // If we have both )) in the string, increment i and if we have a single ) increase count\\n                if (i + 1 < n && s[i] == s[i + 1]) i++;\\n                else count++;\\n                \\n                // If we have ( for corresponding )), pop otherwise increase the count.\\n                if (!st.empty()) st.pop();\\n                else count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2424596,
                "title": "c-stack-t-o-n-s-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/6d646c38-5b86-4ab9-ae05-e4a82476d06c_1660481979.6475577.png)\\n\\n**n==s.size()\\nT->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'(\\') st.push(\\'(\\');\\n\\t\\t\\t\\telse if(s[i]==\\')\\' && s[i+1]==\\')\\'){\\n\\t\\t\\t\\t\\tif(st.empty())count++;\\n\\t\\t\\t\\t\\telse st.pop();\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(!st.empty()){\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse count+=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(!st.empty()) count+=2*st.size();\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'(\\') st.push(\\'(\\');\\n\\t\\t\\t\\telse if(s[i]==\\')\\' && s[i+1]==\\')\\'){\\n\\t\\t\\t\\t\\tif(st.empty())count++;\\n\\t\\t\\t\\t\\telse st.pop();\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2090219,
                "title": "python",
                "content": "\\n    def minInsertions(self, s):\\n        total1, total2 = 0, 0\\n        \\n        s = s.replace(\"))\",\"]\")\\n        total1 += s.count(\")\")\\n        s = s.replace(\")\",\"]\")\\n        \\n        for i, v in enumerate(s):\\n            if v == \"(\":\\n                total2 += 1\\n            elif v == \"]\":\\n                total2 -= 1\\n            \\n            if total2 == -1:\\n                total1 += 1\\n                total2 += 1\\n                \\n        return total1 + 2*total2",
                "solutionTags": [],
                "code": "\\n    def minInsertions(self, s):\\n        total1, total2 = 0, 0\\n        \\n        s = s.replace(\"))\",\"]\")\\n        total1 += s.count(\")\")\\n        s = s.replace(\")\",\"]\")\\n        \\n        for i, v in enumerate(s):\\n            if v == \"(\":\\n                total2 += 1\\n            elif v == \"]\":\\n                total2 -= 1\\n            \\n            if total2 == -1:\\n                total1 += 1\\n                total2 += 1\\n                \\n        return total1 + 2*total2",
                "codeTag": "Python3"
            },
            {
                "id": 1429325,
                "title": "c-stack",
                "content": "```\\n```\\n\\n```\\n```public:\\n    int minInsertions(string s) {\\n        long long int t,count=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(st.size()==0)\\n            {\\n                if(i<s.length()-1&&s[i+1]==\\')\\')\\n                {\\n                    i++;\\n                    count++;\\n                }\\n                else\\n                {\\n                    count=count+2;\\n                }\\n            }\\n            else\\n            {\\n                if(i<s.length()-1&&s[i+1]==\\')\\')\\n                {\\n                  i++;   \\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return count+(st.size()*2);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225658,
                "title": "python-92",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        count = 0\\n        o = 0\\n        s = s.replace(\\'))\\',\\']\\')\\n        for c in s:\\n            if c == \\'(\\':\\n                o+=1\\n            else:\\n                if c == \\')\\':\\n                    count+=1\\n                if o==0:\\n                    count+=1\\n                else:\\n                    o-=1\\n                    \\n        return count+(2*o)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        count = 0\\n        o = 0\\n        s = s.replace(\\'))\\',\\']\\')\\n        for c in s:\\n            if c == \\'(\\':\\n                o+=1\\n            else:\\n                if c == \\')\\':\\n                    count+=1\\n                if o==0:\\n                    count+=1\\n                else:\\n                    o-=1\\n                    \\n        return count+(2*o)",
                "codeTag": "Java"
            },
            {
                "id": 1223865,
                "title": "c-fully-commented",
                "content": "**please upvote it this helps :)**\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int len=s.length();\\n        int res=0;\\n        int i=0;\\n        int open=0;\\n        //open stores the number of opening brackets\\n        while(i<len){\\n            if(s[i]==\\'(\\')\\n            {\\n                //increment number of opening brackets\\n                open++;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                //check if next char is also a \\')\\'\\n                if(i+1<len && s[i+1]==\\')\\')\\n                {\\n                    if(open>0){\\n                        //decrement open as we use it for two \\')\\'\\n                        open--;\\n                    }\\n                    else{\\n                        //no opening bracket for two closing \\')\\'\\n                        res+=1;\\n                    }\\n                    i+=2;\\n                }\\n                else{\\n                    //found single  \\')\\'\\n                    if(open>0)\\n                    {\\n                        //we have one \\'(\\' and need only one \\')\\'\\n                        open--;\\n                        res+=1;\\n                    }\\n                    else{\\n                    //need one \\'(\\' and one closing \\')\\'\\n                        res+=2;\\n                    }\\n                i++;\\n                }\\n            }\\n        }\\n        if(open>0)\\n            res+=(2*open);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int len=s.length();\\n        int res=0;\\n        int i=0;\\n        int open=0;\\n        //open stores the number of opening brackets\\n        while(i<len){\\n            if(s[i]==\\'(\\')\\n            {\\n                //increment number of opening brackets\\n                open++;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                //check if next char is also a \\')\\'\\n                if(i+1<len && s[i+1]==\\')\\')\\n                {\\n                    if(open>0){\\n                        //decrement open as we use it for two \\')\\'\\n                        open--;\\n                    }\\n                    else{\\n                        //no opening bracket for two closing \\')\\'\\n                        res+=1;\\n                    }\\n                    i+=2;\\n                }\\n                else{\\n                    //found single  \\')\\'\\n                    if(open>0)\\n                    {\\n                        //we have one \\'(\\' and need only one \\')\\'\\n                        open--;\\n                        res+=1;\\n                    }\\n                    else{\\n                    //need one \\'(\\' and one closing \\')\\'\\n                        res+=2;\\n                    }\\n                i++;\\n                }\\n            }\\n        }\\n        if(open>0)\\n            res+=(2*open);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208565,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stk=new Stack<Character>();\\n        int bal=0;\\n        for(int i=0;i<s.length();)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n                stk.push(s.charAt(i));\\n                i++;\\n            }\\n            else \\n            {\\n                //if incase stack is empty,check next character\\n                if(stk.empty())\\n                {\\n                    //if next character is ),then you need to add one ( for balancing,so bal++\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        bal++;\\n                        i+=2;\\n                    }\\n                    //if next character is not ),then you need to add one ( and one ) for balancing,so bal+=2\\n                    else\\n                    {\\n                        bal+=2;\\n                        i++;\\n                    }\\n                }\\n                //if stack is not empty,the it means,it contains a (,so check next character\\n                else\\n                {\\n                    //if next character is also ) the it is already balanced\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        i+=2;\\n                    }\\n                    //else one ) should be added so bal++\\n                    else\\n                    {\\n                        bal++;\\n                        i++;\\n                    }\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        //if the string contains all character as ),then for each ( bal+=2\\n        while(!stk.empty())\\n        {\\n            stk.pop();\\n            bal+=2;\\n        }\\n        return bal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stk=new Stack<Character>();\\n        int bal=0;\\n        for(int i=0;i<s.length();)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n            {\\n                stk.push(s.charAt(i));\\n                i++;\\n            }\\n            else \\n            {\\n                //if incase stack is empty,check next character\\n                if(stk.empty())\\n                {\\n                    //if next character is ),then you need to add one ( for balancing,so bal++\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        bal++;\\n                        i+=2;\\n                    }\\n                    //if next character is not ),then you need to add one ( and one ) for balancing,so bal+=2\\n                    else\\n                    {\\n                        bal+=2;\\n                        i++;\\n                    }\\n                }\\n                //if stack is not empty,the it means,it contains a (,so check next character\\n                else\\n                {\\n                    //if next character is also ) the it is already balanced\\n                    if(i+1<s.length() && s.charAt(i+1)==\\')\\')\\n                    {\\n                        i+=2;\\n                    }\\n                    //else one ) should be added so bal++\\n                    else\\n                    {\\n                        bal++;\\n                        i++;\\n                    }\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        //if the string contains all character as ),then for each ( bal+=2\\n        while(!stk.empty())\\n        {\\n            stk.pop();\\n            bal+=2;\\n        }\\n        return bal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155606,
                "title": "java-stack-o-n",
                "content": "class Solution {\\n    public int minInsertions(String s) {\\n\\t\\n        int count=0;\\n        Stack<Character> stk=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\')\\')\\n            {\\n                 // If there is no two consicutive \\')\\' , we need to insert it too , so count++\\n                \\n                if(i==s.length()-1 || s.charAt(i+1)!=\\')\\')\\n                    count++;\\n                \\n                // if there is consicutive \\')\\'...so we will move i to next \\')\\' as it has been counted.\\n                else            \\n                    i++;\\n                \\n             //if any \\')\\'encountered...so surely there will be \\'(\\'       ..so we will pop it\\n                 if(stk.size()>0)\\n                     stk.pop();\\n                \\n                // As if \\')\\' arrives then its counter which is \\'(\\' should be in stack..if it is not then we need to insert it ..so count++;\\n                 else\\n                     count++;\\n            }\\n            else\\n                stk.push(c);\\n        }\\n        \\n        while(stk.size()>0)\\n        {\\n            stk.pop();\\n            count+=2;\\n        }\\n     return count;   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n\\t\\n        int count=0;\\n        Stack<Character> stk=new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\')\\')\\n            {\\n                 // If there is no two consicutive \\')\\' , we need to insert it too , so count++\\n                \\n                if(i==s.length()-1 || s.charAt(i+1)!=\\')\\')\\n                    count++;\\n                \\n                // if there is consicutive \\')\\'...so we will move i to next \\')\\' as it has been counted.\\n                else            \\n                    i++;\\n                \\n             //if any \\')\\'encountered...so surely there will be \\'(\\'       ..so we will pop it\\n                 if(stk.size()>0)\\n                     stk.pop();\\n                \\n                // As if \\')\\' arrives then its counter which is \\'(\\' should be in stack..if it is not then we need to insert it ..so count++;\\n                 else\\n                     count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1018761,
                "title": "o-n-solution-in-python-with-and-without-stack",
                "content": "* `O(n)` space with stack\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution with stack\\n        \\'\\'\\'\\n        N = len(s)\\n        \\n        # traverse the string\\n        toadd = 0\\n        stack = []\\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                stack.append(s[i])\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if len(stack)>0:\\n                        stack.pop()\\n                    else:\\n                        toadd += 1\\n                    i += 2\\n                else:\\n                    if len(stack)>0:\\n                        stack.pop()\\n                        toadd += 1\\n                    else:\\n                        toadd += 2\\n                    i += 1\\n        # check the length of stack\\n        if len(stack)>0:\\n            toadd += len(stack)*2\\n        \\n        return toadd\\n```\\n\\n* `O(1)` space without stack\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution without stack\\n        \\'\\'\\'\\n        N = len(s)\\n        # traverse the string\\n        lcounter = 0\\n        toadd = 0\\n        \\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                lcounter += 1\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if lcounter>0:\\n                        lcounter -= 1\\n                        i += 2\\n                    else:\\n                        toadd += 1\\n                        i += 2\\n                else:\\n                    if lcounter>0:\\n                        toadd += 1\\n                        lcounter -= 1\\n                        i += 1\\n                    else:\\n                        toadd += 2\\n                        i += 1\\n        return toadd + lcounter*2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution with stack\\n        \\'\\'\\'\\n        N = len(s)\\n        \\n        # traverse the string\\n        toadd = 0\\n        stack = []\\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                stack.append(s[i])\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if len(stack)>0:\\n                        stack.pop()\\n                    else:\\n                        toadd += 1\\n                    i += 2\\n                else:\\n                    if len(stack)>0:\\n                        stack.pop()\\n                        toadd += 1\\n                    else:\\n                        toadd += 2\\n                    i += 1\\n        # check the length of stack\\n        if len(stack)>0:\\n            toadd += len(stack)*2\\n        \\n        return toadd\\n```\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\'\\'\\'\\n        O(n) solution without stack\\n        \\'\\'\\'\\n        N = len(s)\\n        # traverse the string\\n        lcounter = 0\\n        toadd = 0\\n        \\n        i = 0\\n        while i<N:\\n            if s[i]==\\'(\\':\\n                lcounter += 1\\n                i += 1\\n            else:\\n                if s[i:i+2]==\\'))\\':\\n                    if lcounter>0:\\n                        lcounter -= 1\\n                        i += 2\\n                    else:\\n                        toadd += 1\\n                        i += 2\\n                else:\\n                    if lcounter>0:\\n                        toadd += 1\\n                        lcounter -= 1\\n                        i += 1\\n                    else:\\n                        toadd += 2\\n                        i += 1\\n        return toadd + lcounter*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899734,
                "title": "c-easy-to-understand-o-n-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                st.push(ch);\\n            }else{\\n                if(i+1 < s.size() && s[i+1] == \\')\\'){\\n                    i++;\\n                    if(st.size() == 0){\\n                        cnt++;\\n                    }else{\\n                        st.pop();\\n                    }\\n                }else{\\n                    if(st.size() == 0){\\n                        cnt+=2;\\n                    }else{\\n                        st.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt += st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                st.push(ch);\\n            }else{\\n                if(i+1 < s.size() && s[i+1] == \\')\\'){\\n                    i++;\\n                    if(st.size() == 0){\\n                        cnt++;\\n                    }else{\\n                        st.pop();\\n                    }\\n                }else{\\n                    if(st.size() == 0){\\n                        cnt+=2;\\n                    }else{\\n                        st.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt += st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829421,
                "title": "simplest-solution-one-pass-o-n-time-o-1-space-with-only-1-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n     \\n        int ans=0;\\n        int o=0;  // open brackets not matched till now  \\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==\\'(\\') o++;             // add open bracketa to not matched count\\n                else if(s[i]==\\')\\'){\\n                    if(i+1==s.size() || s[i+1]!=\\')\\')  // look if only 1 closeing bracket encountered, we need 1 more closing bracket\\n                        ans++;\\n                    else i++;  // skip the next closing bracket\\n                    if(o>0) o--;      // their are availbale open brackets\\n                    else ans++;   // open bracket required to be inserted\\n                }\\n            }\\n        return ans+ o*2; //o*2 is the final no of open brackets remaining which needs twice closing braces.\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n     \\n        int ans=0;\\n        int o=0;  // open brackets not matched till now  \\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==\\'(\\') o++;             // add open bracketa to not matched count\\n                else if(s[i]==\\')\\'){\\n                    if(i+1==s.size() || s[i+1]!=\\')\\')  // look if only 1 closeing bracket encountered, we need 1 more closing bracket\\n                        ans++;\\n                    else i++;  // skip the next closing bracket\\n                    if(o>0) o--;      // their are availbale open brackets\\n                    else ans++;   // open bracket required to be inserted\\n                }\\n            }\\n        return ans+ o*2; //o*2 is the final no of open brackets remaining which needs twice closing braces.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805133,
                "title": "simple-o-n-c-solution-without-stack-w-comments",
                "content": "I previously used stack and enum to represent the current stack status and it turned out to be a disaster because there are too many cases that have to take into consider.\\nI then saw the solution from @mohitbhateja and realized that the cases can be classified (and simplied) to only a few cases. Refer to the code and comments below.\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left_count = 0;\\n        int insertions = 0;\\n        // ) is completely different from ))\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') left_count++;\\n            else {                                      // s[i] == \\')\\'\\n                if (left_count == 0) insertions++;      // need a \\'(\\' for this \\')\\'\\n                else left_count--;                      // consume a \\'(\\' for a \\')\\'\\n                if (i == s.size()-1 || s[i+1] == \\'(\\')\\n                    insertions++;                       // need another contiguous \\')\\'\\n                else i++;                               // made a )), we already checked if \\'(\\' exists before\\n            }\\n        }\\n        return insertions + left_count * 2;             // every \\'(\\' not matched needs two \\')\\' \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left_count = 0;\\n        int insertions = 0;\\n        // ) is completely different from ))\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'(\\') left_count++;\\n            else {                                      // s[i] == \\')\\'\\n                if (left_count == 0) insertions++;      // need a \\'(\\' for this \\')\\'\\n                else left_count--;                      // consume a \\'(\\' for a \\')\\'\\n                if (i == s.size()-1 || s[i+1] == \\'(\\')\\n                    insertions++;                       // need another contiguous \\')\\'\\n                else i++;                               // made a )), we already checked if \\'(\\' exists before\\n            }\\n        }\\n        return insertions + left_count * 2;             // every \\'(\\' not matched needs two \\')\\' \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802715,
                "title": "simple-c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(st.empty()) ans++;\\n                if(i+1>=s.length()) ans++;\\n                if(i+1<s.length() && s[i+1] == \\'(\\') ans++;\\n                else if(i+1<s.length() && s[i+1] == \\')\\') i++;\\n                if(!st.empty())\\n                st.pop();\\n            }\\n        }\\n        return ans += st.size()*2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(st.empty()) ans++;\\n                if(i+1>=s.length()) ans++;\\n                if(i+1<s.length() && s[i+1] == \\'(\\') ans++;\\n                else if(i+1<s.length() && s[i+1] == \\')\\') i++;\\n                if(!st.empty())\\n                st.pop();\\n            }\\n        }\\n        return ans += st.size()*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781543,
                "title": "c-100-faster-fully-explained",
                "content": "What we have done is:  we will use three numbers:(-1,0,1)\\n1. 1 number states that \"))\" substring is present.\\n2. 0 number states that only \")\" substring is present and we need one more \\')\\'.  \\n3. -1 number states that \"(\" is present.\\n4. Last we will have a variable \"count\" wich will store no of insertions.\\n*  If we encounter -1 \"(\", we will push it to the stack.\\n*  If we encounter 0 \")\", this means we need to insert \")\" so we will count++. But we will check if stack is empty, this means we need  to insert \"(\" also and we will again count++ and pop.\\n*  If we encounter 1\"))\", this means pop from the stack [or remove \"(\"].\\n\\nFor eg [\" ( )) ( )\"]:- In this our array will be [-1,1,-1,0].\\narray[0]:First we will push -1 to stack.\\narray[1]:Then we will pop.\\narray[2]:Then we will push -1 to stack.\\narray[3]:Then we will count++ and pop.\\nAnswer is 1.\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        if(s.size()<3)\\n            return 3-s.size();\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                v.push_back(-1);\\n            else\\n            {\\n                if(i!=s.size()-1)\\n                {if(s[i+1]==\\')\\')\\n                    v.push_back(1),i++;\\n                else\\n                    v.push_back(0);}\\n                else v.push_back(0);\\n                    \\n            }\\n        }\\n        for(auto num:v) cout<<num<<\" \";\\n        int count=0;\\n        stack<int> S;\\n        for(auto num:v)\\n        {\\n            if(num==-1)\\n                S.push(num);\\n            else if(num==0)\\n            {\\n                 if(S.empty())\\n                     count+=2;\\n                else\\n                    count++,S.pop();\\n            } else{\\n                     if(S.empty())\\n                         count++;\\n                      else S.pop();\\n            }   \\n        }\\n        if(!S.empty())\\n            count+=S.size()*2;\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        if(s.size()<3)\\n            return 3-s.size();\\n        vector<int> v;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                v.push_back(-1);\\n            else\\n            {\\n                if(i!=s.size()-1)\\n                {if(s[i+1]==\\')\\')\\n                    v.push_back(1),i++;\\n                else\\n                    v.push_back(0);}",
                "codeTag": "Java"
            },
            {
                "id": 780024,
                "title": "help-needed-confusing-testcase",
                "content": "Can anyone please explain why ```4``` is expected output for this input\\n\\n```\"(()))(()))()())))\"```\\n\\nShouldn\\'t it be just ```1``` ?",
                "solutionTags": [],
                "code": "```4```\n```\"(()))(()))()())))\"```\n```1```",
                "codeTag": "Unknown"
            },
            {
                "id": 779966,
                "title": "java-stack-solution-o-n-one-pass-solution-with-explanation-and-comments",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character>stk=new Stack<>();\\n        int cnt=0;\\n        char c;\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n            if(c==\\'(\\') // if we get one \\'(\\' we simply insert it into the stack.\\n                stk.push(c);\\n            else{\\n                // if we get a \\')\\',\\n                if(i<s.length()-1&&s.charAt(i+1)==\\')\\'){ // we check if the next(if present) character is also a \\')\\'. \\n                    \\n                    // if stack is empty then one \\'(\\' will be required for the found \\'))\\', else we just matched a \\'(\\' with \\'))\\'.\\n                    if(stk.empty()) \\n                        cnt++;\\n                    else    \\n                        stk.pop();\\n                    \\n                    i++; // since we accessed the next element as well.\\n                }\\n                else{\\n                    // if the next element is not present or the next element is not a \\')\\', then we obviously need a \\')\\'. \\n                    // Then if stack is empty, one \\'(\\' will be required to balance \\'))\\', else we got a \\'(\\' for \\'))\\'.                    \\n                    if(stk.empty()) \\n                        cnt+=2; \\n                    else{\\n                        stk.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt+=stk.size()*2; // for each remaining \\'(\\', we require two \\'))\\'.\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character>stk=new Stack<>();\\n        int cnt=0;\\n        char c;\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n            if(c==\\'(\\') // if we get one \\'(\\' we simply insert it into the stack.\\n                stk.push(c);\\n            else{\\n                // if we get a \\')\\',\\n                if(i<s.length()-1&&s.charAt(i+1)==\\')\\'){ // we check if the next(if present) character is also a \\')\\'. \\n                    \\n                    // if stack is empty then one \\'(\\' will be required for the found \\'))\\', else we just matched a \\'(\\' with \\'))\\'.\\n                    if(stk.empty()) \\n                        cnt++;\\n                    else    \\n                        stk.pop();\\n                    \\n                    i++; // since we accessed the next element as well.\\n                }\\n                else{\\n                    // if the next element is not present or the next element is not a \\')\\', then we obviously need a \\')\\'. \\n                    // Then if stack is empty, one \\'(\\' will be required to balance \\'))\\', else we got a \\'(\\' for \\'))\\'.                    \\n                    if(stk.empty()) \\n                        cnt+=2; \\n                    else{\\n                        stk.pop();\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        cnt+=stk.size()*2; // for each remaining \\'(\\', we require two \\'))\\'.\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779954,
                "title": "c-o-n-o-1-intuitive-if-else",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int c = 0; // ans\\n        int op = 0; // Open Parantheses\\n        for(int i=0;i<n;i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                op++;\\n            }\\n            else{\\n                if(i+1<n && s[i+1]==\\')\\'){\\n                    i++; // two times \\')\\' present for one \\'(\\' move forward\\n                }\\n                else{\\n                    c++; // only one \\')\\' , so insert one more \\')\\'\\n                }\\n                if(op==0){\\n                    c++; // if no corresponding opening para then add one by insertion\\n                }\\n                else op--; // else \\'(\\' has corresponding two \\')\\'\\n            }\\n        }\\n        if(op>0) c+= op*2; // for all \\'(\\' left insert corresponding \\'))\\'\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int c = 0; // ans\\n        int op = 0; // Open Parantheses\\n        for(int i=0;i<n;i++){\\n            char ch = s[i];\\n            if(ch == \\'(\\'){\\n                op++;\\n            }\\n            else{\\n                if(i+1<n && s[i+1]==\\')\\'){\\n                    i++; // two times \\')\\' present for one \\'(\\' move forward\\n                }\\n                else{\\n                    c++; // only one \\')\\' , so insert one more \\')\\'\\n                }\\n                if(op==0){\\n                    c++; // if no corresponding opening para then add one by insertion\\n                }\\n                else op--; // else \\'(\\' has corresponding two \\')\\'\\n            }\\n        }\\n        if(op>0) c+= op*2; // for all \\'(\\' left insert corresponding \\'))\\'\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321179,
                "title": "java-stack-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf **left bracket we need twice on right**, if **right bracket present we need just half on left**.\\nRefer Commnets, Dry Run for better understanding !! \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n// -Keep adding left barckets\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                if(i+1<s.length()&& s.charAt(i+1)==\\')\\'){\\n                    // -Skip it as two consecutives are present\\n                    i++;\\n                }else count++;\\n                \\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }else count++ ;\\n            }\\n        }\\n        count+=2*stack.size();\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n// -Keep adding left barckets\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(s.charAt(i));\\n            }else{\\n                if(i+1<s.length()&& s.charAt(i+1)==\\')\\'){\\n                    // -Skip it as two consecutives are present\\n                    i++;\\n                }else count++;\\n                \\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                }else count++ ;\\n            }\\n        }\\n        count+=2*stack.size();\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295720,
                "title": "java-100-easy-to-understand",
                "content": "\\n\\n# Approach\\nUse stack to store the number of insertions, not the string itself.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\')\\n            {\\n                if(stack.isEmpty() || stack.peek() == 2)\\n                stack.push(2);\\n                else{\\n                    stack.pop();\\n                    stack.push(2);\\n                    ans++;\\n                }\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    stack.push(1);\\n                    ans++;\\n                }\\n                else if (stack.peek()==1)\\n                stack.pop();\\n                else if (stack.peek()==2)\\n                {\\n                    stack.pop();\\n                    stack.push(1);\\n                }\\n            }\\n           \\n        }\\n        while(!stack.isEmpty())\\n        {\\n            ans = ans + stack.peek();\\n            stack.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int ans =0;\\n        for(int i =0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\')\\n            {\\n                if(stack.isEmpty() || stack.peek() == 2)\\n                stack.push(2);\\n                else{\\n                    stack.pop();\\n                    stack.push(2);\\n                    ans++;\\n                }\\n            }\\n            else if(ch == \\')\\')\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    stack.push(1);\\n                    ans++;\\n                }\\n                else if (stack.peek()==1)\\n                stack.pop();\\n                else if (stack.peek()==2)\\n                {\\n                    stack.pop();\\n                    stack.push(1);\\n                }\\n            }\\n           \\n        }\\n        while(!stack.isEmpty())\\n        {\\n            ans = ans + stack.peek();\\n            stack.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047629,
                "title": "kotlin-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    fun minInsertions(s: String): Int {\\n        var q = ArrayDeque<Char>()\\n        var i = 0\\n        var res = 0\\n        while (true) {\\n            if (i >= s.length) break\\n            var c = s[i]\\n            \\n            if (c == \\')\\') {\\n                if (q.size > 0) q.pop() else res++\\n                if (i < s.length - 1 && s[i + 1] == \\')\\') {\\n                    i += 2\\n                } else {\\n                    res++\\n                    i++\\n                }\\n            } else {\\n                q.push(c)\\n                i++\\n            }\\n        }\\n        if (q.size != 0) res += 2 * q.size\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    fun minInsertions(s: String): Int {\\n        var q = ArrayDeque<Char>()\\n        var i = 0\\n        var res = 0\\n        while (true) {\\n            if (i >= s.length) break\\n            var c = s[i]\\n            \\n            if (c == \\')\\') {\\n                if (q.size > 0) q.pop() else res++\\n                if (i < s.length - 1 && s[i + 1] == \\')\\') {\\n                    i += 2\\n                } else {\\n                    res++\\n                    i++\\n                }\\n            } else {\\n                q.push(c)\\n                i++\\n            }\\n        }\\n        if (q.size != 0) res += 2 * q.size\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686697,
                "title": "python-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile seeing parentheses problem, using stack is my intuition.\\nres: record the number of times making insertion\\nidx: pointer on s\\nstk: store left parenthese\\n\\nIn this case, if we meet \\'(\\', just append left parenthese into stack.\\nIf we meet one \\')\\', there is three cases:\\n1. nothing in stack. So we need to insert one left parenthese into stack, in order to match right parenthese. So res += 1\\n2. \\'(\\' in stack, also, the next char in s is also a \\')\\'. Thus, now we have a valid right parenthese. We just need to update the index pointer, and pop the topmost left paren from stack\\n3. \\'(\\' in stack, also, the next char in s is not a \\')\\'. So we need to add one more \\')\\' to construct a valid right parenthese. After adding right paren, now we can pop left paren from stack\\n\\nwhy res += len(stk) * 2?\\nAfter traversing s completely, if there are remaining left parentheses, it means there are left parenthese having no matching right parenthese. So we have to add len(stk) * 2 to res.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else: # \\u5982\\u679C\\u662Fright paren\\n                # Fill in left parenthesis\\n                if (not stk): # \\u5982\\u679C\\u6CA1\\u6709left paren\\u5728stack\\n                    res += 1 \\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n        \\n        # # res \\u8BB0\\u5F55\\u63D2\\u5165\\u6B21\\u6570\\n        # # need \\u53D8\\u91CF\\u8BB0\\u5F55\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\n        # need, res = 0, 0\\n\\n        # for i in range(len(s)):\\n        #     if s[i] == \\'(\\':\\n        #         need += 2\\n        #         # \\u5F53\\u9047\\u5230\\u5DE6\\u62EC\\u53F7\\u65F6\\uFF0C\\u82E5\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\u4E3A\\u5947\\u6570\\uFF0C\\u9700\\u8981\\u63D2\\u5165 1 \\u4E2A\\u53F3\\u62EC\\u53F7\\u3002\\n        #         # \\u56E0\\u4E3A\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\u9700\\u8981\\u4E24\\u4E2A\\u53F3\\u62EC\\u53F7\\u561B\\uFF0C\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u5FC5\\u987B\\u662F\\u5076\\u6570\\n        #         if need %2 == 1:\\n        #             # \\u63D2\\u5165\\u4E00\\u4E2A\\u53F3\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u51CF\\u4E00\\n        #             need -= 1\\n\\n        #     elif s[i] == \\')\\':\\n        #         need -= 1\\n        #         # \\u8BF4\\u660E\\u53F3\\u62EC\\u53F7\\u592A\\u591A\\u4E86\\n        #         if need == -1:\\n        #             # \\u9700\\u8981\\u63D2\\u5165\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u540C\\u65F6\\uFF0C\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u53D8\\u4E3A 1\\n        #             # -1 -> 1 # \\u76F8\\u5F53\\u4E8E\\u662Fadd 2 to need\\n        #             need = 1\\n        # return need + res\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else: # \\u5982\\u679C\\u662Fright paren\\n                # Fill in left parenthesis\\n                if (not stk): # \\u5982\\u679C\\u6CA1\\u6709left paren\\u5728stack\\n                    res += 1 \\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n        \\n        # # res \\u8BB0\\u5F55\\u63D2\\u5165\\u6B21\\u6570\\n        # # need \\u53D8\\u91CF\\u8BB0\\u5F55\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\n        # need, res = 0, 0\\n\\n        # for i in range(len(s)):\\n        #     if s[i] == \\'(\\':\\n        #         need += 2\\n        #         # \\u5F53\\u9047\\u5230\\u5DE6\\u62EC\\u53F7\\u65F6\\uFF0C\\u82E5\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u91CF\\u4E3A\\u5947\\u6570\\uFF0C\\u9700\\u8981\\u63D2\\u5165 1 \\u4E2A\\u53F3\\u62EC\\u53F7\\u3002\\n        #         # \\u56E0\\u4E3A\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\u9700\\u8981\\u4E24\\u4E2A\\u53F3\\u62EC\\u53F7\\u561B\\uFF0C\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u5FC5\\u987B\\u662F\\u5076\\u6570\\n        #         if need %2 == 1:\\n        #             # \\u63D2\\u5165\\u4E00\\u4E2A\\u53F3\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u51CF\\u4E00\\n        #             need -= 1\\n\\n        #     elif s[i] == \\')\\':\\n        #         need -= 1\\n        #         # \\u8BF4\\u660E\\u53F3\\u62EC\\u53F7\\u592A\\u591A\\u4E86\\n        #         if need == -1:\\n        #             # \\u9700\\u8981\\u63D2\\u5165\\u4E00\\u4E2A\\u5DE6\\u62EC\\u53F7\\n        #             res += 1\\n        #             # \\u540C\\u65F6\\uFF0C\\u5BF9\\u53F3\\u62EC\\u53F7\\u7684\\u9700\\u6C42\\u53D8\\u4E3A 1\\n        #             # -1 -> 1 # \\u76F8\\u5F53\\u4E8E\\u662Fadd 2 to need\\n        #             need = 1\\n        # return need + res\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303596,
                "title": "c-easy-to-understand-stack-single-pass-o-n",
                "content": "class Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'(\\')\\n                st.push(s[i]);\\n            else{\\n                 if(st.size()>0){\\n                     if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ) ){\\n                     st.pop();\\n                     i++;   \\n                     }\\n                     else{\\n                         st.pop();\\n                         ans++;\\n                     }\\n                     \\n                 }\\n                 else if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ))\\n                 {\\n                     ans++;\\n                     i++;\\n                 }\\n                 else\\n                 {\\n                   ans+=2;    \\n                 }\\n            }\\n        }\\n        while(st.size()){\\n            st.pop();\\n            ans+=2;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        stack<char>st;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'(\\')\\n                st.push(s[i]);\\n            else{\\n                 if(st.size()>0){\\n                     if(i+1<n && ( s[i] == \\')\\' && s[i+1] == \\')\\' ) ){\\n                     st.pop();\\n                     i++;   \\n                     }",
                "codeTag": "Java"
            },
            {
                "id": 2255977,
                "title": "c-o-n-one-pass-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        stack<char> s; \\n        int ans = 0; \\n        for(int x = 0; x<s1.length(); x++){\\n            if(s1[x]==\\'(\\')\\n                s.push(s1[x]);\\n            else{\\n                if(x+1<s1.length()){\\n                    if(s1[x+1]==\\')\\')\\n                        x++;\\n                    else{\\n                      ans++;  \\n                    }\\n                }\\n                else\\n                    ans++;\\n                if(!s.empty())\\n                    s.pop();\\n                else\\n                    ans++;\\n            }     \\n        }\\n        return ans + s.size()*2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        stack<char> s; \\n        int ans = 0; \\n        for(int x = 0; x<s1.length(); x++){\\n            if(s1[x]==\\'(\\')\\n                s.push(s1[x]);\\n            else{\\n                if(x+1<s1.length()){\\n                    if(s1[x+1]==\\')\\')\\n                        x++;\\n                    else{\\n                      ans++;  \\n                    }\\n                }\\n                else\\n                    ans++;\\n                if(!s.empty())\\n                    s.pop();\\n                else\\n                    ans++;\\n            }     \\n        }\\n        return ans + s.size()*2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218237,
                "title": "simplest-java-solution-2-pass",
                "content": "```\\n/**\\nNot the fastest but arguably simplest. Replacing )) with ] reduces this problem to a simpler balancing problem\\n**/\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        s = s.replace(\"))\", \"]\");\\n        System.out.print(s);\\n        int count = 0, leftCount =0;\\n        for (int i = 0; i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') leftCount++;\\n            else{\\n                if (leftCount > 0) {\\n                    leftCount--;\\n                    count += ch == \\']\\' ? 0 : 1;\\n                }\\n                else count += ch == \\']\\' ? 1 : 2;\\n            }\\n        }\\n        return count+leftCount*2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        s = s.replace(\"))\", \"]\");\\n        System.out.print(s);\\n        int count = 0, leftCount =0;\\n        for (int i = 0; i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') leftCount++;\\n            else{\\n                if (leftCount > 0) {\\n                    leftCount--;\\n                    count += ch == \\']\\' ? 0 : 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2215666,
                "title": "python-solution-with-explantions",
                "content": "\\'\\'\\'\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        #res: # of extra insertion to balance \\n        # need: # of needed right parenthesis\\n        \\n        res, need  = 0,0\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                \\n                # (( ))) need = 4 -3 = 1\\n                \\n                if need % 2 == 1:\\n                    \\n                    # need another ) insertion to balance \\n                    res += 1 \\n                    \\n                    # need for ) decrease by 1 \\n                    need -= 1 \\n            if s[i] == \\')\\':\\n                \\n                need -= 1\\n                if need == -1:\\n                    res +=1 \\n                    need = 1\\n\\n        return res + need \\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        #res: # of extra insertion to balance \\n        # need: # of needed right parenthesis\\n        \\n        res, need  = 0,0\\n        \\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                \\n                # (( ))) need = 4 -3 = 1\\n                \\n                if need % 2 == 1:\\n                    \\n                    # need another ) insertion to balance \\n                    res += 1 \\n                    \\n                    # need for ) decrease by 1 \\n                    need -= 1 \\n            if s[i] == \\')\\':\\n                \\n                need -= 1\\n                if need == -1:\\n                    res +=1 \\n                    need = 1\\n\\n        return res + need \\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 2084857,
                "title": "c-easy-to-understand-simple-code-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int x=0,n=s.length();\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(1);\\n            }\\n            else if(i<n-1&&s[i]==\\')\\'&&s[i+1]==\\')\\')\\n            {\\n                v.push_back(2);\\n                i++;\\n            }\\n            else\\n            {\\n                v.push_back(2);\\n                x++;\\n            }\\n        }\\n        stack<int> st;\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty()&&st.top()==1&&v[i]==2)\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(v[i]);\\n            }\\n        }\\n        int count=0;\\n        n=st.size();\\n        while(!st.empty())\\n        {\\n            if(st.top()==1)\\n            count++;\\n            st.pop();\\n        }\\n        return x+2*count+(n-count);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int x=0,n=s.length();\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                v.push_back(1);\\n            }\\n            else if(i<n-1&&s[i]==\\')\\'&&s[i+1]==\\')\\')\\n            {\\n                v.push_back(2);\\n                i++;\\n            }\\n            else\\n            {\\n                v.push_back(2);\\n                x++;\\n            }\\n        }\\n        stack<int> st;\\n        n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!st.empty()&&st.top()==1&&v[i]==2)\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(v[i]);\\n            }\\n        }\\n        int count=0;\\n        n=st.size();\\n        while(!st.empty())\\n        {\\n            if(st.top()==1)\\n            count++;\\n            st.pop();\\n        }\\n        return x+2*count+(n-count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848462,
                "title": "simplest-solution-easiest-to-understand",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        char[] ar= s.toCharArray();\\n        Stack<Character> stack= new Stack<>();\\n        int insertions=0;\\n        \\n        for(int i=0;i<ar.length;i++)\\n        {\\n            char ch= ar[i];\\n            \\n            if(ch==\\'(\\')\\n            {\\n                if(stack.isEmpty())\\n                    stack.push(ch);\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    insertions++;\\n                    stack.pop();\\n                    stack.pop();\\n                    stack.push(ch);\\n                }\\n            }\\n            else\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    insertions++;\\n                    stack.push(\\'(\\');\\n                    stack.push(ch);\\n                }\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    stack.pop();\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty())\\n        {\\n            if(stack.pop()==\\'(\\')\\n                insertions = insertions+2;\\n            else\\n            {\\n                insertions++;\\n                stack.pop();\\n            }\\n        }\\n        \\n        return insertions;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        char[] ar= s.toCharArray();\\n        Stack<Character> stack= new Stack<>();\\n        int insertions=0;\\n        \\n        for(int i=0;i<ar.length;i++)\\n        {\\n            char ch= ar[i];\\n            \\n            if(ch==\\'(\\')\\n            {\\n                if(stack.isEmpty())\\n                    stack.push(ch);\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    insertions++;\\n                    stack.pop();\\n                    stack.pop();\\n                    stack.push(ch);\\n                }\\n            }\\n            else\\n            {\\n                if(stack.isEmpty())\\n                {\\n                    insertions++;\\n                    stack.push(\\'(\\');\\n                    stack.push(ch);\\n                }\\n                else if(stack.peek()==\\'(\\')\\n                    stack.push(ch);\\n                else if(stack.peek()==\\')\\')\\n                {\\n                    stack.pop();\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty())\\n        {\\n            if(stack.pop()==\\'(\\')\\n                insertions = insertions+2;\\n            else\\n            {\\n                insertions++;\\n                stack.pop();\\n            }\\n        }\\n        \\n        return insertions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772757,
                "title": "c-stack-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        int count = 0;\\n        stack<char>S;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!S.empty())\\n            {\\n                if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                else\\n                {\\n                    if(i < n - 1 and s[i + 1] == \\')\\')\\n                    {\\n                        S.pop();\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        S.pop();\\n                        count++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                 if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                 else\\n                 {\\n                     count++;\\n                    if( !(i < n - 1 and s[i + 1] == \\')\\') )\\n                    {\\n                        count++;\\n                    }\\n                    else\\n                        i++;\\n                 }\\n            }\\n        }\\n        if(!S.empty())\\n            count += (S.size() * 2);\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        int count = 0;\\n        stack<char>S;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!S.empty())\\n            {\\n                if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                else\\n                {\\n                    if(i < n - 1 and s[i + 1] == \\')\\')\\n                    {\\n                        S.pop();\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        S.pop();\\n                        count++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                 if(s[i] == \\'(\\')\\n                    S.push(\\'(\\');\\n                 else\\n                 {\\n                     count++;\\n                    if( !(i < n - 1 and s[i + 1] == \\')\\') )\\n                    {\\n                        count++;\\n                    }\\n                    else\\n                        i++;\\n                 }\\n            }\\n        }\\n        if(!S.empty())\\n            count += (S.size() * 2);\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694649,
                "title": "c-using-stack-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        stack<char>st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                if(st.empty())\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\'(\\')\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                    ans++;\\n                    st.push(\\'(\\');\\n                }\\n            }\\n            \\n            if(c==\\')\\'){\\n                if(st.empty()){\\n                    st.push(\\'(\\');\\n                    st.push(c);\\n                    ans++;\\n                }\\n                \\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                }\\n                \\n                else if(st.top()==\\'(\\')\\n                    st.push(c);\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            if(st.top()==\\'(\\'){\\n                ans+=2;\\n                st.pop();\\n            }\\n                \\n            else if(st.top()==\\')\\'){\\n                ans++;\\n                st.pop();\\n                st.pop();\\n            }\\n                \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) {\\n        \\n        stack<char>st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                if(st.empty())\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\'(\\')\\n                    st.push(\\'(\\');\\n                else if(st.top()==\\')\\'){\\n                    st.pop();\\n                    st.pop();\\n                    ans++;\\n                    st.push(\\'(\\');\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1687981,
                "title": "java-o-1-space-solution",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int ans=0,open=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                ++open;\\n            }\\n            else\\n            {\\n                if(i+1<n&&s.charAt(i+1)==\\')\\')\\n                {\\n                    if(open==0)\\n                    {\\n                        ++ans;\\n                    }\\n                    else\\n                    {\\n                        --open;\\n                    }\\n                    ++i;\\n                }\\n                else\\n                {\\n                    if(open==0)\\n                    {\\n                        ans+=2;\\n                    }\\n                    else\\n                    {\\n                        ++ans;\\n                        --open;\\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return ans+2*open;\\n        \\n        \\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int ans=0,open=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                ++open;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1621255,
                "title": "c-easy-to-understand-stack-solution",
                "content": "# class Solution {\\n# public:\\n    int minInsertions(string s) {\\n        int n=s.size(),ans=0;\\n        stack<char> st;\\n        for(int i=0; i<n;){\\n            cout<<i<<endl;\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]); i++;\\n            }\\n            else{\\n                if(i+1<n){\\n                    if(s[i+1]==\\')\\'){\\n                        if(st.size()>0){st.pop(); i+=2;}\\n                        else{ans++; i+=2;}\\n                    }\\n                    else{\\n                        if(st.size()>0){\\n                            st.pop(); ans++; i++;\\n                        }\\n                        else{\\n                            ans+=2; i++;\\n                        }\\n                    }\\n                }\\n                else{\\n                    if(st.size()>0){\\n                        st.pop(); ans++;\\n                        break;\\n                    }\\n                    else{\\n                        ans+=2; break;\\n                    }\\n                }\\n            }\\n        }\\n        if(st.size()>0){\\n            ans+=st.size()*2;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n# public:\\n    int minInsertions(string s) {\\n        int n=s.size(),ans=0;\\n        stack<char> st;\\n        for(int i=0; i<n;){\\n            cout<<i<<endl;\\n            if(s[i]==\\'(\\'){\\n                st.push(s[i]); i++;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1597083,
                "title": "java-count-parenthesis-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int ans = 0;\\n        int cnt = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'(\\')\\n            {\\n                cnt+=2;\\n                if(cnt%2==1)\\n                {\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else\\n            {\\n                cnt--;\\n                if(cnt < 0)\\n                {\\n                    cnt+=2;\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans + cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int ans = 0;\\n        int cnt = 0;\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'(\\')\\n            {\\n                cnt+=2;\\n                if(cnt%2==1)\\n                {\\n                    ans++;\\n                    cnt--;\\n                }\\n            }\\n            else\\n            {\\n                cnt--;\\n                if(cnt < 0)\\n                {\\n                    cnt+=2;\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans + cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582020,
                "title": "python-o-n-time-o-n-space-solution-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        strlen=len(s)\\n        i=0\\n        answer=0\\n        stack=[]\\n        \\n        while i<strlen:\\n            \\n            if s[i]==\\'(\\':stack.append(\\'(\\')\\n                \\n            else:\\n                if i+1<strlen and s[i+1]==\\')\\':\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else:answer+=1\\n                    i+=1\\n                else:\\n                    answer+=1 # going to need a closing brace\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else: answer+=1\\n            i+=1\\n                    \\n                \\n        while len(stack)>0:\\n            answer+=2\\n            stack.pop(-1)\\n            \\n        return answer\\n                \\n                \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        strlen=len(s)\\n        i=0\\n        answer=0\\n        stack=[]\\n        \\n        while i<strlen:\\n            \\n            if s[i]==\\'(\\':stack.append(\\'(\\')\\n                \\n            else:\\n                if i+1<strlen and s[i+1]==\\')\\':\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else:answer+=1\\n                    i+=1\\n                else:\\n                    answer+=1 # going to need a closing brace\\n                    if len(stack)>0:stack.pop()\\n                    # going to need an opening brace\\n                    else: answer+=1\\n            i+=1\\n                    \\n                \\n        while len(stack)>0:\\n            answer+=2\\n            stack.pop(-1)\\n            \\n        return answer\\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1552910,
                "title": "c-28ms-98-3-line-math",
                "content": "Runtime: 28 ms, faster than 97.91% of C++ online submissions for Minimum Insertions to Balance a Parentheses String.\\nMemory Usage: 12.3 MB, less than 93.09% of C++ online submissions for Minimum Insertions to Balance a Parentheses String.\\n```\\nclass Solution {\\npublic:\\n  int minInsertions(string s) {\\n    int n = 0, answer = 0;\\n    for(auto &ch: s) ch == \\'(\\' ? (n&1 ? n++, answer++ : n += 2) : (n == 0 ? n++, answer++ : n--); \\n    return answer + n;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int minInsertions(string s) {\\n    int n = 0, answer = 0;\\n    for(auto &ch: s) ch == \\'(\\' ? (n&1 ? n++, answer++ : n += 2) : (n == 0 ? n++, answer++ : n--); \\n    return answer + n;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543379,
                "title": "o-n-time-and-o-1-space-solution-10-line-of-code-simple-cake-walk-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,close=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\')\\n            {\\n                if(i+1<s.size() and s[i+1]==\\')\\')\\n                {\\n                    if(open>0) open--;  // it become cancel with each other.\\n                    else\\n                        ans++;  // for one open bracket\\n                    i++;\\n                }\\n                else\\n                {\\n                    // Example -> (  ) , if open is there then need only for one close bracket\\n                    if(open>0)\\n                    {\\n                        open--;\\n                        ans++;\\n                    }\\n                    else\\n                        ans+=2;  //Example -> ), it means need 1 for open & 1 for close bracket.\\n                }\\n            }\\n            \\n        }\\n        \\n        ans+=open*2; // it means at the if some ((( left then we need 2 close for each open\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,close=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') open++;\\n            else if(s[i]==\\')\\')\\n            {\\n                if(i+1<s.size() and s[i+1]==\\')\\')\\n                {\\n                    if(open>0) open--;  // it become cancel with each other.\\n                    else\\n                        ans++;  // for one open bracket\\n                    i++;\\n                }\\n                else\\n                {\\n                    // Example -> (  ) , if open is there then need only for one close bracket\\n                    if(open>0)\\n                    {\\n                        open--;\\n                        ans++;\\n                    }\\n                    else\\n                        ans+=2;  //Example -> ), it means need 1 for open & 1 for close bracket.\\n                }\\n            }\\n            \\n        }\\n        \\n        ans+=open*2; // it means at the if some ((( left then we need 2 close for each open\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535577,
                "title": "python-beat-100-time-complexity-with-comments-o-n-tc-and-o-1-sc",
                "content": "```class Solution:\\n    ### similar to https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n    def minInsertions(self, s: str) -> int:\\n        bal=0\\n        ans=0\\n        s = s.replace(\"))\",\"}\")\\n        for c in s:\\n            if c ==\"(\":\\n                bal+=1\\n            elif c == \"}\":\\n                if bal == 0: ans+=1\\n                else:   bal-=1\\n            else: #####c == \\')\\'\\n                if bal == 0: ##it should be ()) wesaw 1 close we need 1 open and another close\\n                    ans+=2\\n                else:  #####() \\n                    bal-=1\\n                    ans+=1   ##()) we saw () so we need one close so ans+=1 and we saw one open so bal-=1\\n        return ans+bal*2",
                "solutionTags": [],
                "code": "class Solution:\\n    ### similar to https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n    def minInsertions(self, s: str) -> int:\\n        bal=0\\n        ans=0\\n        s = s.replace(\"))\",\"}",
                "codeTag": "Java"
            },
            {
                "id": 1531211,
                "title": "c-simple-one-pass-solution-explained-using-comments-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int i = 0; // Index to iterate the string\\n        int counter = 0; // Count the number of open brackets for which we are to find corresponding closing brackets\\n        int ans = 0; // Number of insertions made till end of string\\n        \\n        while (i < s.size()) { // Iterate over the string\\n            if (s[i] == \\'(\\') { // If there is an open bracket, we increase the counter and move forward by 1\\n                counter++;\\n                i++;\\n            } else if (s[i] == \\')\\') {\\n\\t\\t\\t\\t// If it is a closing bracket, there are two possibilities:\\n\\t\\t\\t\\t// 1. It is followed by another closing bracket\\n\\t\\t\\t\\t// 2. It is followed by another open bracket.\\n                if (i + 1 < s.size()) {\\n\\t\\t\\t\\t\\t// Check if we are not crossing string length\\n                    if (s[i + 1] != \\')\\') {\\n\\t\\t\\t\\t\\t// Case 2: If there is no closing bracket, then we insert 1 closing bracket for completion,\\n\\t\\t\\t\\t\\t// increase answer by 1 and move\\n                        ans++;\\n                        i++;\\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Case 1: If there is a closing bracket, then we jump 2 indexes and repeat\\n                        i += 2;\\n                    }\\n                    // In either case, we complete a closing double brackets,\\n\\t\\t\\t\\t\\t// so we decrease counter by 1 as we have completed it.\\n\\t\\t\\t\\t\\tcounter--; \\n                } else {\\n\\t\\t\\t\\t\\t// If i was the last index, we don\\'t have anything following it,\\n\\t\\t\\t\\t\\t// so we need to add another closing bracket to make a pair,\\n\\t\\t\\t\\t\\t// decrease counter by 1 and increase ans by 1\\n                    counter--;\\n                    ans++;\\n                    i++;\\n                }\\n            }\\n            \\n            if (counter == -1) {\\n\\t\\t\\t\\t// If at any point, the counter equals -1, this means that closing brackets are more than opening brackets,\\n\\t\\t\\t\\t// so we increase counter by 1 ie, it becomes equal to 0 and\\n\\t\\t\\t\\t// increase ans by 1 because we add an opening bracket for the lonely closing brackets.\\n                ans++;\\n                counter = 0;\\n            }\\n        }\\n        // Why we add 2 * counter to final ans?\\n\\t\\t// There can be a case where we have more opening brackets than closing brackets.\\n\\t\\t// We would need to add 2 closing brackets for every opening bracket.\\n\\t\\t// So we add 2 * counter to the ans.\\n        return ans + 2 * counter;\\n    }\\n};\\n// fin.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int i = 0; // Index to iterate the string\\n        int counter = 0; // Count the number of open brackets for which we are to find corresponding closing brackets\\n        int ans = 0; // Number of insertions made till end of string\\n        \\n        while (i < s.size()) { // Iterate over the string\\n            if (s[i] == \\'(\\') { // If there is an open bracket, we increase the counter and move forward by 1\\n                counter++;\\n                i++;\\n            } else if (s[i] == \\')\\') {\\n\\t\\t\\t\\t// If it is a closing bracket, there are two possibilities:\\n\\t\\t\\t\\t// 1. It is followed by another closing bracket\\n\\t\\t\\t\\t// 2. It is followed by another open bracket.\\n                if (i + 1 < s.size()) {\\n\\t\\t\\t\\t\\t// Check if we are not crossing string length\\n                    if (s[i + 1] != \\')\\') {\\n\\t\\t\\t\\t\\t// Case 2: If there is no closing bracket, then we insert 1 closing bracket for completion,\\n\\t\\t\\t\\t\\t// increase answer by 1 and move\\n                        ans++;\\n                        i++;\\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Case 1: If there is a closing bracket, then we jump 2 indexes and repeat\\n                        i += 2;\\n                    }\\n                    // In either case, we complete a closing double brackets,\\n\\t\\t\\t\\t\\t// so we decrease counter by 1 as we have completed it.\\n\\t\\t\\t\\t\\tcounter--; \\n                } else {\\n\\t\\t\\t\\t\\t// If i was the last index, we don\\'t have anything following it,\\n\\t\\t\\t\\t\\t// so we need to add another closing bracket to make a pair,\\n\\t\\t\\t\\t\\t// decrease counter by 1 and increase ans by 1\\n                    counter--;\\n                    ans++;\\n                    i++;\\n                }\\n            }\\n            \\n            if (counter == -1) {\\n\\t\\t\\t\\t// If at any point, the counter equals -1, this means that closing brackets are more than opening brackets,\\n\\t\\t\\t\\t// so we increase counter by 1 ie, it becomes equal to 0 and\\n\\t\\t\\t\\t// increase ans by 1 because we add an opening bracket for the lonely closing brackets.\\n                ans++;\\n                counter = 0;\\n            }\\n        }\\n        // Why we add 2 * counter to final ans?\\n\\t\\t// There can be a case where we have more opening brackets than closing brackets.\\n\\t\\t// We would need to add 2 closing brackets for every opening bracket.\\n\\t\\t// So we add 2 * counter to the ans.\\n        return ans + 2 * counter;\\n    }\\n};\\n// fin.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523232,
                "title": "python-straight-forward-one-pass-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # Keep track of how many closing brackets we need as we iterate through s.\\n        # These are the invalid states where we need to insert brackets:\\n        # 1. Odd number of closing brackets required. Requires inserting 1 more close bracket.\\n        # 2. Negative number of closing brackets required (i.e excess closing brackets). Requires inserting 1 more close bracket if odd. Insert (closing brackets required // 2) opening brackets\\n        # Handle excess close required brackets at the end of s as well.\\n        \\n        closeRequired = 0\\n        count = 0\\n        a  = 0\\n        \\n        while a < len(s):\\n            if s[a] == \"(\":\\n                closeRequired += 2\\n                a += 1\\n            else:\\n                while a < len(s) and s[a] == \\')\\':\\n                    closeRequired -= 1\\n                    a += 1\\n                                    \\n                # 1. Positive closeRequired\\n                # Even closeRequired -> do nothing\\n                # Odd closeRequired -> insert 1 more close bracket, subtract 2 closeRequired -> insert = 1\\n                \\n                # 2. Negative closeRequired \\n                # Even closeRequired -> Add closeRequired // 2 open brackets -> closeRequired = 0\\n                # Odd closeRequired -> Add 1 extra closeRequired and insert [closeRequired //2] open brackets -> closeRequired = 0\\n                \\n                if closeRequired > 0:\\n                    if closeRequired % 2 == 0:\\n                        continue\\n                    closeRequired -= 1\\n                    count += 1\\n                else:\\n                    if abs(closeRequired) % 2 == 1:\\n                        closeRequired -= 1\\n                        count += 1\\n                        \\n                    count += abs(closeRequired) // 2\\n                    closeRequired = 0\\n        \\n        return count + closeRequired\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # Keep track of how many closing brackets we need as we iterate through s.\\n        # These are the invalid states where we need to insert brackets:\\n        # 1. Odd number of closing brackets required. Requires inserting 1 more close bracket.\\n        # 2. Negative number of closing brackets required (i.e excess closing brackets). Requires inserting 1 more close bracket if odd. Insert (closing brackets required // 2) opening brackets\\n        # Handle excess close required brackets at the end of s as well.\\n        \\n        closeRequired = 0\\n        count = 0\\n        a  = 0\\n        \\n        while a < len(s):\\n            if s[a] == \"(\":\\n                closeRequired += 2\\n                a += 1\\n            else:\\n                while a < len(s) and s[a] == \\')\\':\\n                    closeRequired -= 1\\n                    a += 1\\n                                    \\n                # 1. Positive closeRequired\\n                # Even closeRequired -> do nothing\\n                # Odd closeRequired -> insert 1 more close bracket, subtract 2 closeRequired -> insert = 1\\n                \\n                # 2. Negative closeRequired \\n                # Even closeRequired -> Add closeRequired // 2 open brackets -> closeRequired = 0\\n                # Odd closeRequired -> Add 1 extra closeRequired and insert [closeRequired //2] open brackets -> closeRequired = 0\\n                \\n                if closeRequired > 0:\\n                    if closeRequired % 2 == 0:\\n                        continue\\n                    closeRequired -= 1\\n                    count += 1\\n                else:\\n                    if abs(closeRequired) % 2 == 1:\\n                        closeRequired -= 1\\n                        count += 1\\n                        \\n                    count += abs(closeRequired) // 2\\n                    closeRequired = 0\\n        \\n        return count + closeRequired\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434641,
                "title": "c-easiest-time-o-n-space-o-1",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, open = 0, n = s.size(), i = 0; \\n        \\n        while(i<n){\\n            if(s[i] == \\'(\\') open ++, i++; \\n            else if(open>0){\\n                if(i == n-1|| s[i+1] != \\')\\') res ++, open --, i++; \\n                else open --, i+=2;\\n            }\\n            else {\\n                open ++, res++; \\n            }\\n        };\\n        res += 2*open; \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, open = 0, n = s.size(), i = 0; \\n        \\n        while(i<n){\\n            if(s[i] == \\'(\\') open ++, i++; \\n            else if(open>0){\\n                if(i == n-1|| s[i+1] != \\')\\') res ++, open --, i++; \\n                else open --, i+=2;\\n            }\\n            else {\\n                open ++, res++; \\n            }\\n        };\\n        res += 2*open; \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433841,
                "title": "python-min-insertions-to-balance-weird-string",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/discuss/779928/Simple-O(n)-stack-solution-with-detailed-explanation\\n\\n        stack = []\\n        pair = 0\\n        for c in s:\\n            if c == \"(\": \\n                if stack and stack[-1] == 1: pair += stack.pop()\\n                stack.append(2)\\n                \\n            if c == \")\":\\n                if not stack: \\n                    stack.append(1)\\n                    pair += 1\\n                elif stack[-1] == 1: stack.pop()\\n                elif stack[-1] == 2: stack[-1] -= 1\\n\\n        \\n        return pair + sum(stack)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        # https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/discuss/779928/Simple-O(n)-stack-solution-with-detailed-explanation\\n\\n        stack = []\\n        pair = 0\\n        for c in s:\\n            if c == \"(\": \\n                if stack and stack[-1] == 1: pair += stack.pop()\\n                stack.append(2)\\n                \\n            if c == \")\":\\n                if not stack: \\n                    stack.append(1)\\n                    pair += 1\\n                elif stack[-1] == 1: stack.pop()\\n                elif stack[-1] == 2: stack[-1] -= 1\\n\\n        \\n        return pair + sum(stack)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384784,
                "title": "c-solution-fully-explained-o-n-solution-one-pass",
                "content": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\nIf u havent solve above given problem yet, i really recommend u solve that problem first.\\n\\nThe only difference between above given problem and this problem is, in above problem a \"()\" this is valid parentheses string and this \"())\" this is valid parentheses string, here 2 consecutive \"))\" closing bracket needed for one \"(\" opening bracket.\\n\\nwe will use same approach like valid parentheses,\\nwe will push \"(\" opening bracket in stack and whenever we find \")\" closing bracket in string\\nnow we will have 4 cases\\n\\n1. cases (when string is valid, like \"())\" )\\n2. when string is like(\"))\"): mean no opening bracket\\n3. when we have string like this(\"()\") no consecutive closing bracket\\n4. when we have only one \")\" no opening no consecutive closing.\\n\\n````\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int l=s.length();\\n        stack<char> st;\\n        int count=0;int flag=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(i==l-1)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n                \\n                if(!st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    i++; st.pop();\\n                }\\n                else if(st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                else if(!st.empty() and i+1<l and s[i+1]!=\\')\\')\\n                {\\n                    count++;\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    count+=2;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1)\\n        {\\n            if(!st.empty())\\n            {\\n                st.pop();\\n                count++;\\n            }\\n            else\\n            {\\n                count+=2;\\n            }\\n        }\\n        \\n        count+=st.size()*2;\\n        \\n        return count;\\n    }\\n};\\n\\n````\\n\\nif u have any query regarding coding above approach just ask me in comments.",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int l=s.length();\\n        stack<char> st;\\n        int count=0;int flag=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(\\'(\\');\\n            }\\n            else\\n            {\\n                if(i==l-1)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n                \\n                if(!st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    i++; st.pop();\\n                }\\n                else if(st.empty() and i+1<l and s[i+1]==\\')\\')\\n                {\\n                    count++;\\n                    i++;\\n                }\\n                else if(!st.empty() and i+1<l and s[i+1]!=\\')\\')\\n                {\\n                    count++;\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    count+=2;\\n                }\\n            }\\n        }\\n        \\n        if(flag==1)\\n        {\\n            if(!st.empty())\\n            {\\n                st.pop();\\n                count++;\\n            }\\n            else\\n            {\\n                count+=2;\\n            }\\n        }\\n        \\n        count+=st.size()*2;\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341051,
                "title": "easy-to-understand-java-solution",
                "content": "Solve this problem first before going through my code : https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/\\n\\nNow the code should be easy to understand , if you have any doubts do comment down below and I will try to help you out \\n\\n```\\n// intuition is same as leetcode 921 , so solve that first \\n// and then this solution should be a cakewalk to understand \\n\\n// TC : O(n) where n is the length of s\\n// SC : O(1)\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int openCount = 0; // count of \\'(\\'\\n        int closeCount = 0; // count of \\')\\'\\n        for(int i =0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                openCount++;\\n            }else{\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ // case : \"())\"\\n                    if(openCount>0) openCount--; // balance opening and \\n                    // closing if possible\\n                    else closeCount++; // if not possible\\n                    // then increment closeCount\\n                    // example : \"))\"\\n                    i++; // increment i because (i+1)th character\\n\\t\\t\\t\\t\\t// has been dealt with\\n                }else{ // case : \")\" or case : \"()(\"\\n                    if(openCount>0){ // consider case :\"()(\" , \\n                        // here you basically balance \"()\" part\\n                        // by adding \\')\\' at the end\\n                        // now part becomes \"())\"\\n                        // so this is balanced \\n                        // so decrement openCount\\n                       \\n                        openCount--;\\n                        closeCount++;\\n                    }else closeCount+=2; // consider case : \")\"\\n                    // you need to add one opening bracket and \\n                    // one closing bracket to balance the expression\\n                    // so the expression becomes \"())\" which is balanced\\n                    // now you added two brackets , so increment\\n                    // closeCount by 2 \\n                }\\n            }\\n        }\\n        // since 1 opening bracket requires 2 closing \\n        // brackets to balance , and closing brackets only \\n        // require one opening bracket to balance \\n        // so we return 2*openCount + closeCount\\n        return 2*openCount+closeCount;\\n    }\\n}\\n```\\n\\nYou can also solve this using stack , how ? solve leetcode 921 using stack and submit it  , and then try to solve this problem by making changes to the code you submitted for leetcode 921 , but since that takes linear space I did not code it up \\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// intuition is same as leetcode 921 , so solve that first \\n// and then this solution should be a cakewalk to understand \\n\\n// TC : O(n) where n is the length of s\\n// SC : O(1)\\n\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int openCount = 0; // count of \\'(\\'\\n        int closeCount = 0; // count of \\')\\'\\n        for(int i =0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                openCount++;\\n            }else{\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ // case : \"())\"\\n                    if(openCount>0) openCount--; // balance opening and \\n                    // closing if possible\\n                    else closeCount++; // if not possible\\n                    // then increment closeCount\\n                    // example : \"))\"\\n                    i++; // increment i because (i+1)th character\\n\\t\\t\\t\\t\\t// has been dealt with\\n                }else{ // case : \")\" or case : \"()(\"\\n                    if(openCount>0){ // consider case :\"()(\" , \\n                        // here you basically balance \"()\" part\\n                        // by adding \\')\\' at the end\\n                        // now part becomes \"())\"\\n                        // so this is balanced \\n                        // so decrement openCount\\n                       \\n                        openCount--;\\n                        closeCount++;\\n                    }else closeCount+=2; // consider case : \")\"\\n                    // you need to add one opening bracket and \\n                    // one closing bracket to balance the expression\\n                    // so the expression becomes \"())\" which is balanced\\n                    // now you added two brackets , so increment\\n                    // closeCount by 2 \\n                }\\n            }\\n        }\\n        // since 1 opening bracket requires 2 closing \\n        // brackets to balance , and closing brackets only \\n        // require one opening bracket to balance \\n        // so we return 2*openCount + closeCount\\n        return 2*openCount+closeCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295068,
                "title": "stack-solution-one-pass",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int count = 0;\\n        Deque<Character> stack = new ArrayDeque<>();\\n        \\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.offerFirst(arr[i]);\\n            } else if (arr[i] == \\')\\') {\\n                if (i < arr.length - 1 && arr[i + 1] == \\')\\') {\\n                    if (stack.isEmpty()) {\\n                        count += 1;\\n                    } else {\\n                        stack.pollFirst();\\n                    }\\n                    i += 1;\\n                } else {\\n                    if (stack.isEmpty()) {\\n                        count += 2;\\n                    } else {\\n                        count += 1;\\n                        stack.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count + stack.size() * 2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int count = 0;\\n        Deque<Character> stack = new ArrayDeque<>();\\n        \\n        char[] arr = s.toCharArray();\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == \\'(\\') {\\n                stack.offerFirst(arr[i]);\\n            } else if (arr[i] == \\')\\') {\\n                if (i < arr.length - 1 && arr[i + 1] == \\')\\') {\\n                    if (stack.isEmpty()) {\\n                        count += 1;\\n                    } else {\\n                        stack.pollFirst();\\n                    }\\n                    i += 1;\\n                } else {\\n                    if (stack.isEmpty()) {\\n                        count += 2;\\n                    } else {\\n                        count += 1;\\n                        stack.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count + stack.size() * 2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238392,
                "title": "one-pass-using-stack-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution() \\n    { \\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL); \\n    }\\n    \\n    int minInsertions(string s) \\n    {\\n        int ct = 0 , bt=0;\\n        vector<char> st;\\n        for(int i=0;i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push_back(s[i]);\\n            else if(st.size()>0)\\n               {\\n                   if(i+1 < s.length())\\n                       {\\n                           if(s[i+1]==\\')\\')\\n                             { st.pop_back(); i++; }\\n                           else\\n                                { ct++; st.pop_back(); }  \\n                       }\\n                   else\\n                       { ct++; st.pop_back(); }           \\n               } \\n            else\\n            {\\n                if((i+1 < s.length()))\\n                    if(s[i+1]==\\')\\') { bt++; i++; }\\n                    else bt+=2;\\n                else\\n                    bt+=2;\\n            }     \\n        }\\n        int res = 2*st.size();\\n        res += ct + bt;\\n     return res;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution() \\n    { \\n        ios_base::sync_with_stdio(0);\\n        cin.tie(NULL); \\n    }\\n    \\n    int minInsertions(string s) \\n    {\\n        int ct = 0 , bt=0;\\n        vector<char> st;\\n        for(int i=0;i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push_back(s[i]);\\n            else if(st.size()>0)\\n               {\\n                   if(i+1 < s.length())\\n                       {\\n                           if(s[i+1]==\\')\\')\\n                             { st.pop_back(); i++; }\\n                           else\\n                                { ct++; st.pop_back(); }  \\n                       }\\n                   else\\n                       { ct++; st.pop_back(); }           \\n               } \\n            else\\n            {\\n                if((i+1 < s.length()))\\n                    if(s[i+1]==\\')\\') { bt++; i++; }\\n                    else bt+=2;\\n                else\\n                    bt+=2;\\n            }     \\n        }\\n        int res = 2*st.size();\\n        res += ct + bt;\\n     return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222152,
                "title": "python-solution",
                "content": "```python\\nresult = l = r = 0\\nfor c in s:\\n\\tif c == \"(\":\\n\\t\\tif r == 1:\\n\\t\\t\\tresult += 1\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\n\\t\\tl += 1\\n\\telse:\\n\\t\\tr += 1\\n\\t\\tif r == 2:\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\nif l < r:\\n\\treturn result + 2\\nelse:\\n\\treturn result + 2 * l - r\\n```",
                "solutionTags": [],
                "code": "```python\\nresult = l = r = 0\\nfor c in s:\\n\\tif c == \"(\":\\n\\t\\tif r == 1:\\n\\t\\t\\tresult += 1\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\n\\t\\tl += 1\\n\\telse:\\n\\t\\tr += 1\\n\\t\\tif r == 2:\\n\\t\\t\\tif l > 0:\\n\\t\\t\\t\\tl -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tresult += 1\\n\\t\\t\\tr = 0\\nif l < r:\\n\\treturn result + 2\\nelse:\\n\\treturn result + 2 * l - r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200203,
                "title": "python-replace-and-count",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        l,r,h =0,0,0\\n        cnt=0\\n        t = s.replace(\\'))\\',\\'#\\')\\n        for i in range(len(t)):\\n            if t[i]==\\'(\\':\\n                l+=1\\n            elif  t[i]==\\')\\':\\n                if l>0:\\n                    l-=1\\n                    cnt+=1\\n                else:\\n                    r+=1\\n            else:\\n                if l>0:\\n                    l-=1\\n                else:\\n                    h+=1\\n        cnt+= l*2 + r*2 + h\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        l,r,h =0,0,0\\n        cnt=0\\n        t = s.replace(\\'))\\',\\'#\\')\\n        for i in range(len(t)):\\n            if t[i]==\\'(\\':\\n                l+=1\\n            elif  t[i]==\\')\\':\\n                if l>0:\\n                    l-=1\\n                    cnt+=1\\n                else:\\n                    r+=1\\n            else:\\n                if l>0:\\n                    l-=1\\n                else:\\n                    h+=1\\n        cnt+= l*2 + r*2 + h\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151300,
                "title": "no-extra-space",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s=s.replace(\"))\",\"|\");st=0;c=0\\n        for i in range(len(s)):\\n            if s[i]==\"|\":\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\")\":\\n                c+=1\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\"(\":\\n                st+=1\\n                st+=1\\n        return st+c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s=s.replace(\"))\",\"|\");st=0;c=0\\n        for i in range(len(s)):\\n            if s[i]==\"|\":\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\")\":\\n                c+=1\\n                if st>0:st-=1\\n                else:c+=1\\n                if st>0:st-=1\\n            elif s[i]==\"(\":\\n                st+=1\\n                st+=1\\n        return st+c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138473,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,insert=0;\\n        int i=0,n=s.length();\\n        \\n        while(i<n) {\\n            if(s[i]==\\'(\\') \\n                open++;\\n            else {\\n                if(i+1<n && s[i+1]==\\')\\')    //there are 2 consecutive \\')\\'\\n                    i++;                    //so skip checking for the 2nd \\'\\')\\'\\n                else \\n                    insert++;\\n                if(open == 0)   //if any close bracket does not have a corresponding open bracket. \\n                    insert++;\\n                else \\n                    open--;     //there is atleast one \\')\\' for an \\'(\\' then we need not add anymore \\'(\\'. Note in case there is only \\')\\', for the second \\')\\' insert in incremented in the previous else block.\\n            }\\n            i++;\\n        }\\n        if(open>0) \\n            insert += 2*open;  //these open do not have any matching \\')\\'\\n        return insert;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int open=0,insert=0;\\n        int i=0,n=s.length();\\n        \\n        while(i<n) {\\n            if(s[i]==\\'(\\') \\n                open++;\\n            else {\\n                if(i+1<n && s[i+1]==\\')\\')    //there are 2 consecutive \\')\\'\\n                    i++;                    //so skip checking for the 2nd \\'\\')\\'\\n                else \\n                    insert++;\\n                if(open == 0)   //if any close bracket does not have a corresponding open bracket. \\n                    insert++;\\n                else \\n                    open--;     //there is atleast one \\')\\' for an \\'(\\' then we need not add anymore \\'(\\'. Note in case there is only \\')\\', for the second \\')\\' insert in incremented in the previous else block.\\n            }\\n            i++;\\n        }\\n        if(open>0) \\n            insert += 2*open;  //these open do not have any matching \\')\\'\\n        return insert;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134665,
                "title": "c-concise-o-n-solution-using-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        s.push_back(\\'.\\'); //Adding a dummy char at the end to ease the task in loops.\\n        stack<char> st;\\n        int cnt=0;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            // if(!st.empty())\\n                // cout<<st.top()<<endl;\\n            \\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else\\n                    cnt+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty())\\n                {\\n                    st.pop();\\n                    cnt++;\\n                }\\n                else\\n                    cnt+=2;\\n            }\\n        }\\n        //Now if the stack is not empty means \\'(\\' are present so we need to add more \\'))\\'\\n        if(!st.empty())\\n            cnt+=st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        s.push_back(\\'.\\'); //Adding a dummy char at the end to ease the task in loops.\\n        stack<char> st;\\n        int cnt=0;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            // if(!st.empty())\\n                // cout<<st.top()<<endl;\\n            \\n            if(s[i]==\\'(\\')\\n                st.push(s[i]);\\n            \\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(!st.empty())\\n                    st.pop();\\n                else\\n                    cnt+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                if(!st.empty())\\n                {\\n                    st.pop();\\n                    cnt++;\\n                }\\n                else\\n                    cnt+=2;\\n            }\\n        }\\n        //Now if the stack is not empty means \\'(\\' are present so we need to add more \\'))\\'\\n        if(!st.empty())\\n            cnt+=st.size()*2;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1113079,
                "title": "python-replacement-trick",
                "content": "```html5\\n<b>Time complexity: O(n)</b> &becaus; replacement and the for-loop both require visiting all n characters in s\\n<b>Space complexity: O(n)</b> &becaus; strings are immutable, the replacement operation creates a new string at a new memory address\\n```\\n\\n**Approach:**\\n\\nReplacing all `\\'))\\'` with `\\']\\'` pairs up all of the closed brackets into groups of 2.\\nReplacing all `\\'(\\'` with `\\'[\\'` does nothing, but it makes it easier to visualize which brackets pairs are complete.\\n\\nIterate over each character in `s` and talley the \\ntotal open / closed parentheses where `\\'[\\' = +2` and `\\']\\' = -2`.\\n\\nWhile iterating over `s` we need to make sure the count never drops below zero.\\nThis would indicate the string is unbalanced.\\n\\nThere are a few possible scenarios:\\n1. For `\\'[\\'` just add 2 to the count, no changes necessary.\\n2. For `\\']\\'` subtract 2 from the count.\\nIf `count < 2` then we must add 1 `[` to keep the string balanced. (`res += 1 ; count += 2`)\\n3. For `\\')\\'` then there are two possibilities.\\nIf `count >= 2` then we have extra `\\'[\\'` and just need to add one `\\')\\'` to keep the string balanced. (`res += 1 ; count -= 2`)\\nOtherwise we need to add one `\\'[\\'` and one `\\')\\'` (`res += 2 ; count += 0`).\\n\\nAfter iterating over `s` if `count` is `0` then the string is balanced.  \\nHowever, in cases like examples 3 and 4, where `count` &ne; `0` then `count` `\\')\\'` must be added to balance the string.\\n\\nThis brings the total insertions up to `res + count` where `res` parentheses were inserted during the traversal\\nand `count` parenetheses were inserted at the end to balance the string.\\n\\n<hr>\\n\\n**Example Replacements:**\\n\\n| Example | Before | After | res | count | answer |\\n|:---:|:---:|:---:|:---:|:---:|:---:|\\n| 1 |(())) |  [[])|1 |  0 | 1|\\n| 2 |()) |  []|0 |  0 | 0|\\n| 3 |))())( |  ][][|1 |  2 | 3|\\n| 4 |(((((( |  [[[[[[|0 |  12 | 12|\\n| 5 |))))))) |  ]]])|5 |  0 | 5|\\n\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s = s.replace(\\'))\\', \\']\\')\\n        s = s.replace(\\'(\\', \\'[\\')\\n        count = res = 0\\n        \\n        for char in s:\\n            # Scenario 1\\n            if char == \\'[\\':\\n                count += 2\\n                \\n            # Scenario 2\\n            elif char == \\']\\':\\n                if count < 2:\\n                    count += 2\\n                    res += 1\\n                count -= 2\\n            \\n            # Scenario 3\\n            else:\\n                if count >= 2:\\n                    res += 1\\n                else:\\n                    res += 2\\n                    count += 2\\n                count -= 2\\n        \\n        return res + count\\n```",
                "solutionTags": [],
                "code": "```html5\\n<b>Time complexity: O(n)</b> &becaus; replacement and the for-loop both require visiting all n characters in s\\n<b>Space complexity: O(n)</b> &becaus; strings are immutable, the replacement operation creates a new string at a new memory address\\n```\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s = s.replace(\\'))\\', \\']\\')\\n        s = s.replace(\\'(\\', \\'[\\')\\n        count = res = 0\\n        \\n        for char in s:\\n            # Scenario 1\\n            if char == \\'[\\':\\n                count += 2\\n                \\n            # Scenario 2\\n            elif char == \\']\\':\\n                if count < 2:\\n                    count += 2\\n                    res += 1\\n                count -= 2\\n            \\n            # Scenario 3\\n            else:\\n                if count >= 2:\\n                    res += 1\\n                else:\\n                    res += 2\\n                    count += 2\\n                count -= 2\\n        \\n        return res + count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107138,
                "title": "simple-and-short-solution-without-using-stacks-time-o-n-and-space-o-1-faster-than-90",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n       int open=0;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\')\\n                open++;\\n            else\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ i++;\\n                    if(open>0)   open--;\\n                    else  count++;\\n                }\\n                else{  count++;\\n                    if(open>0)   open--;\\n                    else   count++;\\n                }\\n        }\\n        return count+open*2;\\n    }\\n}\\n```\\nTIME : O(n)\\nSPACE : O(1) NO EXTRA SPACE USED\\n***PLEASE,UPVOTE IF THIS IS HELPFUL ***\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n       int open=0;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\')\\n                open++;\\n            else\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){ i++;\\n                    if(open>0)   open--;\\n                    else  count++;\\n                }\\n                else{  count++;\\n                    if(open>0)   open--;\\n                    else   count++;\\n                }\\n        }\\n        return count+open*2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080384,
                "title": "c-one-pass-runtime-86-memory-92",
                "content": "```\\nint minInsertions(string s) {\\n\\tint res = 0;\\n\\tint nopen = 0; // unmatched opens\\n\\n\\tfor (int i = 0; i < s.size(); i++){\\n\\t\\tif (s[i] == \\'(\\') {\\n\\t\\t\\tnopen++;\\n\\t\\t} else {\\n\\t\\t\\t// If there is unmatched open use it.\\n\\t\\t\\t// Otherwise, insert an open parenthesis.\\n\\t\\t\\tif (nopen > 0) {\\n\\t\\t\\t\\tnopen--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we don\\'t have 2 closing parenthesis, insert \\n\\t\\t\\t// one closing parenthesis.\\n\\t\\t\\tif (i+1 < s.size() && s[i+1] == \\')\\') {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Every unmatched open will require 2 closing parenthesis\\n\\tres += nopen*2;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n\\tint res = 0;\\n\\tint nopen = 0; // unmatched opens\\n\\n\\tfor (int i = 0; i < s.size(); i++){\\n\\t\\tif (s[i] == \\'(\\') {\\n\\t\\t\\tnopen++;\\n\\t\\t} else {\\n\\t\\t\\t// If there is unmatched open use it.\\n\\t\\t\\t// Otherwise, insert an open parenthesis.\\n\\t\\t\\tif (nopen > 0) {\\n\\t\\t\\t\\tnopen--;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we don\\'t have 2 closing parenthesis, insert \\n\\t\\t\\t// one closing parenthesis.\\n\\t\\t\\tif (i+1 < s.size() && s[i+1] == \\')\\') {\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// Every unmatched open will require 2 closing parenthesis\\n\\tres += nopen*2;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055510,
                "title": "c-one-pass-count-simple-solution-with-explanation",
                "content": "* when s[i] == \\')\\' && (s[i+1] == \\'(\\' or i == s.size()-1), we need to insert one \\')\\'; Otherwise, there are two consecutive \\')\\', and we skip the next one: i++\\n* when every time we face two \\')\\', subtract one \\'(\\' and check if it is < 0. If yes, we need to insert one \\'(\\' and reset left to 0.\\n* after one time pass. res += left\\\\*2 to make sure if there are not enough \\')\\'.\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if (i < s.size()-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                } else {\\n                    ++res;\\n                }\\n                if (--left < 0) {\\n                    ++res;\\n                    left = 0;\\n                }\\n            }\\n        }\\n        return res + left*2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int res = 0, left = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'(\\') {\\n                ++left;\\n            } else {\\n                if (i < s.size()-1 && s[i+1] == \\')\\') {\\n                    ++i;\\n                } else {\\n                    ++res;\\n                }\\n                if (--left < 0) {\\n                    ++res;\\n                    left = 0;\\n                }\\n            }\\n        }\\n        return res + left*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976074,
                "title": "c-easy-to-understand-ask-doubts-in-the-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.size();\\n        stack<char> d;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                d.push(s[i]);\\n            }\\n            else{\\n                if(i+1 >= n || s[i+1] != \\')\\' ){\\n                    count++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(d.size() == 0){\\n                    count++;\\n                }\\n                else{\\n                    d.pop();\\n                }\\n            }\\n        }\\n        return count + 2 * d.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0, n = s.size();\\n        stack<char> d;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\'){\\n                d.push(s[i]);\\n            }\\n            else{\\n                if(i+1 >= n || s[i+1] != \\')\\' ){\\n                    count++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(d.size() == 0){\\n                    count++;\\n                }\\n                else{\\n                    d.pop();\\n                }\\n            }\\n        }\\n        return count + 2 * d.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938626,
                "title": "java-one-pass-with-code-comments",
                "content": "```\\npublic int minInsertions(String s) {\\n        //count the number of ( paranthesis without closed.\\n        int count = 0, minInsertions=0;\\n        char[] arr = s.toCharArray();\\n        \\n        //iterate through array, ensure at each point all given either increase count or add paranthesis.\\n        for(int i=0; i<arr.length; i++) {\\n            \\n            if(arr[i]==\\'(\\') count++;\\n            else {\\n                //if current count is positive reduce count otherwise incur one insertion for open.\\n                if(count>0) count--;\\n                else minInsertions++;\\n                \\n                //handling the last element\\n                char next = (i==arr.length-1)? \\'X\\': arr[i+1]; \\n                \\n                //if the next element is not closed, incur another insertion like ()(. Else omit the next element to avoid recalculation\\n                if(next!=\\')\\')  minInsertions++;\\n                else i++;\\n            }\\n        }\\n        \\n        //Add missing end paranthesis.\\n        minInsertions += count*2;\\n        return minInsertions;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minInsertions(String s) {\\n        //count the number of ( paranthesis without closed.\\n        int count = 0, minInsertions=0;\\n        char[] arr = s.toCharArray();\\n        \\n        //iterate through array, ensure at each point all given either increase count or add paranthesis.\\n        for(int i=0; i<arr.length; i++) {\\n            \\n            if(arr[i]==\\'(\\') count++;\\n            else {\\n                //if current count is positive reduce count otherwise incur one insertion for open.\\n                if(count>0) count--;\\n                else minInsertions++;\\n                \\n                //handling the last element\\n                char next = (i==arr.length-1)? \\'X\\': arr[i+1]; \\n                \\n                //if the next element is not closed, incur another insertion like ()(. Else omit the next element to avoid recalculation\\n                if(next!=\\')\\')  minInsertions++;\\n                else i++;\\n            }\\n        }\\n        \\n        //Add missing end paranthesis.\\n        minInsertions += count*2;\\n        return minInsertions;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936597,
                "title": "one-pass-solution-with-o-1-space",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int count = 0, ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i) == \\'(\\') count++;\\n            else{\\n                if(i+1 < n && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                    if(count > 0) count--;\\n                    else ans++;\\n                }\\n                else{\\n                    if(count > 0){\\n                        count--;\\n                        ans++;\\n                    }\\n                    else ans+=2;\\n                }\\n            }\\n        }\\n        ans+=(count*2);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int count = 0, ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i) == \\'(\\') count++;\\n            else{\\n                if(i+1 < n && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                    if(count > 0) count--;\\n                    else ans++;\\n                }\\n                else{\\n                    if(count > 0){\\n                        count--;\\n                        ans++;\\n                    }\\n                    else ans+=2;\\n                }\\n            }\\n        }\\n        ans+=(count*2);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923816,
                "title": "python-use-count-to-simulate-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res = 0\\n        cnt = 0  #  num of \\'(\\'\\n        for c in s:\\n            if c == \\'(\\':\\n                cnt += 2\\n                if cnt&1:      # only a previous single \\')\\' can cause cnt to be odd\\n                    cnt -= 1\\n                    res += 1\\n            elif c == \\')\\':\\n                if cnt == 0:\\n                    cnt += 1\\n                    res += 1\\n                else:\\n                    cnt -= 1\\n\\n        return res + cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res = 0\\n        cnt = 0  #  num of \\'(\\'\\n        for c in s:\\n            if c == \\'(\\':\\n                cnt += 2\\n                if cnt&1:      # only a previous single \\')\\' can cause cnt to be odd\\n                    cnt -= 1\\n                    res += 1\\n            elif c == \\')\\':\\n                if cnt == 0:\\n                    cnt += 1\\n                    res += 1\\n                else:\\n                    cnt -= 1\\n\\n        return res + cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917613,
                "title": "c-intuitive-solution-with-explanation",
                "content": "```\\n// Explanation:\\n// view \\'(\\' as push one element in the stack\\n// view \"))\" as pop one elment in the stack\\n// after a sequence of action, if the stack size is empty -> it is balanced\\n\\n// Implmentation:\\n// simply use a interger to represent size of stack, don\\'t really need to use a stack object\\n// how to make it balanced:\\n// if we need pop, but stack is empty -> add a \\'(\\'\\n// if we encounter a single \\')\\' -> add another \\')\\' to complete pop command\\n// if the stack is not empty in the end -> just add stack_size * \"))\" to pop out all elements\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int size = s.size();\\n        int answer = 0;\\n        int stackSize = 0;\\n        for(int i=0; i<size; i++){\\n        \\tif(s[i] == \\'(\\'){\\n        \\t\\tstackSize++; // push one element in the stack\\n        \\t}else{\\n        \\t\\t// check if pop command complete\\n        \\t\\tif(i+1<size && s[i+1] == \\')\\'){\\n        \\t\\t\\ti += 1;\\n        \\t\\t}else{ // not a complete pop command, add a \\')\\'\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}\\n        \\t\\t// update stackSize\\n        \\t\\tif(stackSize == 0){\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}else{\\n        \\t\\t\\tstackSize--;\\n        \\t\\t}\\n        \\t}\\n        }\\n        answer += stackSize*2; // if not empty, pop out all elements\\n        return answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Explanation:\\n// view \\'(\\' as push one element in the stack\\n// view \"))\" as pop one elment in the stack\\n// after a sequence of action, if the stack size is empty -> it is balanced\\n\\n// Implmentation:\\n// simply use a interger to represent size of stack, don\\'t really need to use a stack object\\n// how to make it balanced:\\n// if we need pop, but stack is empty -> add a \\'(\\'\\n// if we encounter a single \\')\\' -> add another \\')\\' to complete pop command\\n// if the stack is not empty in the end -> just add stack_size * \"))\" to pop out all elements\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int size = s.size();\\n        int answer = 0;\\n        int stackSize = 0;\\n        for(int i=0; i<size; i++){\\n        \\tif(s[i] == \\'(\\'){\\n        \\t\\tstackSize++; // push one element in the stack\\n        \\t}else{\\n        \\t\\t// check if pop command complete\\n        \\t\\tif(i+1<size && s[i+1] == \\')\\'){\\n        \\t\\t\\ti += 1;\\n        \\t\\t}else{ // not a complete pop command, add a \\')\\'\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}\\n        \\t\\t// update stackSize\\n        \\t\\tif(stackSize == 0){\\n        \\t\\t\\tanswer+=1;\\n        \\t\\t}else{\\n        \\t\\t\\tstackSize--;\\n        \\t\\t}\\n        \\t}\\n        }\\n        answer += stackSize*2; // if not empty, pop out all elements\\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885922,
                "title": "python-counting-solution",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                if need % 2 == 1:\\n                    res += 1\\n                    need -= 1\\n\\n            if s[i] == \\')\\':\\n                need -= 1\\n                if need == -1:\\n                    res += 1\\n                    need = 1\\n\\n        return res + need\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0, 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                need += 2\\n                if need % 2 == 1:\\n                    res += 1\\n                    need -= 1\\n\\n            if s[i] == \\')\\':\\n                need -= 1\\n                if need == -1:\\n                    res += 1\\n                    need = 1\\n\\n        return res + need\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879669,
                "title": "cpp-o-n-tc-and-o-1-sc-faster-than-99-97-solution",
                "content": "```class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int n=s.length();\\n        int ans=0;\\n        int i=0;\\n        int op=0,cl=0;;\\n        while(i < n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                op++;\\n                i++;\\n            }\\n            else\\n            {\\n                cl=0;\\n                while(i < n&&s[i]==\\')\\')\\n                {\\n                    cl++;\\n                    i++;\\n                }\\n                if(cl%2!=0)\\n                {\\n                    cl++;\\n                    ans++;\\n                }\\n                if((cl/2)>op)\\n                {\\n                    ans+=(cl/2-op);\\n                    op=cl=0;\\n                }\\n                else\\n                {\\n                    op-=(cl/2);\\n                    cl=0;\\n                }\\n            }\\n        }\\n        if(cl%2!=0)\\n        {\\n            cl++;\\n            ans++;\\n        }\\n        if((cl/2)>op)\\n        {\\n            ans+=(cl/2-op);\\n        }\\n        else\\n        {\\n            op-=(cl/2);\\n            ans+=(2*op);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int n=s.length();\\n        int ans=0;\\n        int i=0;\\n        int op=0,cl=0;;\\n        while(i < n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                op++;\\n                i++;\\n            }\\n            else\\n            {\\n                cl=0;\\n                while(i < n&&s[i]==\\')\\')\\n                {\\n                    cl++;\\n                    i++;\\n                }\\n                if(cl%2!=0)\\n                {\\n                    cl++;\\n                    ans++;\\n                }\\n                if((cl/2)>op)\\n                {\\n                    ans+=(cl/2-op);\\n                    op=cl=0;\\n                }\\n                else\\n                {\\n                    op-=(cl/2);\\n                    cl=0;\\n                }\\n            }\\n        }\\n        if(cl%2!=0)\\n        {\\n            cl++;\\n            ans++;\\n        }\\n        if((cl/2)>op)\\n        {\\n            ans+=(cl/2-op);\\n        }\\n        else\\n        {\\n            op-=(cl/2);\\n            ans+=(2*op);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870862,
                "title": "c-just-do-what-is-asked",
                "content": "```\\n int minInsertions(string s) {\\n        int i=0;\\n        stack<char> st; \\n        int count = 0;\\n        while(i < s.length()){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'(\\');\\n                i++;\\n            }\\n            else{\\n                if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && !st.empty()){\\n                    st.pop();\\n                    i+=2;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && st.empty()){\\n                    i+=2;\\n                    count++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int minInsertions(string s) {\\n        int i=0;\\n        stack<char> st; \\n        int count = 0;\\n        while(i < s.length()){\\n            if(s[i] == \\'(\\'){\\n                st.push(\\'(\\');\\n                i++;\\n            }\\n            else{\\n                if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && !st.empty()){\\n                    st.pop();\\n                    i+=2;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1] == \\')\\' && st.empty()){\\n                    i+=2;\\n                    count++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 < s.length() && s[i+1]!= \\')\\' && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && !st.empty()){\\n                    count++;\\n                    i++;\\n                    st.pop();\\n                }\\n                else if(s[i] == \\')\\' && i+1 == s.length() && st.empty()){\\n                    count+=2;\\n                    i++;\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 847974,
                "title": "my-java-solutions-with-my-thought-process",
                "content": "```\\n/* My though process:\\nSince for most of the paranthesis matching problem, we make use of stack, so here also a stack is used inorder to store some string.\\n\\nFirst of all I simply check whether the string given is empty, if empty then we dont have any insertions to perform, so just return 0.\\nNow I traverse through the string given, when I see a ( then I just push its corresponding )) on to the stack.\\nIf we dont encounter a (, then it means we have ) paranthesis, so we need to take care of certain things\\n-> We check whether we are not having another ) at the last, so if we dont have one, we have to insert one, so increment our count + 1\\n-> else we just increment our iterating variable\\n-> Another case to consider is that, whether we are not have a ( as the first character, so this can be checked by just checking whether our stack is empty or not, if its empty means we have not seen any (, so incrment our count + 1\\n-> Else we pop from the stack and outside the condition, we increment the iterarting variable.\\n\\nNow there is a tricky with the result we have to return. We just didn\\'t return our result, rather we need to take the double of the size of stack because for a single ( we require, 2 ) so we have to multiply by 2 for this mathching.\\nSo we have to return count + size(stack) * 2\\n*/\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        Stack<String> stack = new Stack<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(\"))\");\\n                i ++;\\n            }\\n            else {\\n                if (i == s.length()-1 || s.charAt(i+1) != \\')\\') {// not another ) \\n                    count += 1;\\n                }\\n                else {\\n                    i += 1;\\n                }\\n                if (stack.isEmpty()) \\n                    count += 1;\\n                else\\n                    stack.pop();\\n                i += 1;\\n            }\\n        }\\n        return count + stack.size() * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/* My though process:\\nSince for most of the paranthesis matching problem, we make use of stack, so here also a stack is used inorder to store some string.\\n\\nFirst of all I simply check whether the string given is empty, if empty then we dont have any insertions to perform, so just return 0.\\nNow I traverse through the string given, when I see a ( then I just push its corresponding )) on to the stack.\\nIf we dont encounter a (, then it means we have ) paranthesis, so we need to take care of certain things\\n-> We check whether we are not having another ) at the last, so if we dont have one, we have to insert one, so increment our count + 1\\n-> else we just increment our iterating variable\\n-> Another case to consider is that, whether we are not have a ( as the first character, so this can be checked by just checking whether our stack is empty or not, if its empty means we have not seen any (, so incrment our count + 1\\n-> Else we pop from the stack and outside the condition, we increment the iterarting variable.\\n\\nNow there is a tricky with the result we have to return. We just didn\\'t return our result, rather we need to take the double of the size of stack because for a single ( we require, 2 ) so we have to multiply by 2 for this mathching.\\nSo we have to return count + size(stack) * 2\\n*/\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s.length() == 0)\\n            return 0;\\n        int count = 0;\\n        Stack<String> stack = new Stack<>();\\n        int i = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(\"))\");\\n                i ++;\\n            }\\n            else {\\n                if (i == s.length()-1 || s.charAt(i+1) != \\')\\') {// not another ) \\n                    count += 1;\\n                }\\n                else {\\n                    i += 1;\\n                }\\n                if (stack.isEmpty()) \\n                    count += 1;\\n                else\\n                    stack.pop();\\n                i += 1;\\n            }\\n        }\\n        return count + stack.size() * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832536,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        miss = rm = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if rm % 2:\\n                    rm -= 1\\n                    miss += 1\\n                rm += 2\\n            else:\\n                rm -= 1\\n                if rm < 0:\\n                    rm = 1\\n                    miss += 1\\n        return miss + rm\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        miss = rm = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                if rm % 2:\\n                    rm -= 1\\n                    miss += 1\\n                rm += 2\\n            else:\\n                rm -= 1\\n                if rm < 0:\\n                    rm = 1\\n                    miss += 1\\n        return miss + rm\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 793890,
                "title": "python-o-n-time-o-1-space-with-concise-explanation",
                "content": "At first I figured we could do this with a stack. Then I realized, we don\\'t actually need a stack because the value we push in the stack doesn\\'t matter.. all we really care about is if there are any ( remaining when I see a ). So a counter will suffice.\\n\\nbasically keep a counter of open parenthesis. If i see a ), then i check if i have any ( left. If i dont, i know i need at least one insertion. Then check if there is another ) after the current ). If there isn\\'t, that also will cost another insertion. Then at the end if there are any remaining ( that i never found a corresponding ) for, i know each of those require 2 insertions, so multiply the remaining ( count by 2.\\n\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        open_cnt = 0\\n        insert = 0\\n        \\n        i = 0\\n        while i < len(s):\\n            char = s[i]\\n            \\n            if char == \\'(\\':\\n                open_cnt += 1\\n                i += 1\\n            else:\\n                if open_cnt > 0:\\n                    open_cnt -= 1\\n                else:\\n                    insert += 1\\n                    \\n                if i + 1 < len(s) and s[i + 1] == \\')\\':\\n                    i += 2\\n                else:\\n                    insert += 1\\n                    i += 1\\n                        \\n        return insert + 2*open_cnt",
                "solutionTags": [],
                "code": "At first I figured we could do this with a stack. Then I realized, we don\\'t actually need a stack because the value we push in the stack doesn\\'t matter.. all we really care about is if there are any ( remaining when I see a ). So a counter will suffice.\\n\\nbasically keep a counter of open parenthesis. If i see a ), then i check if i have any ( left. If i dont, i know i need at least one insertion. Then check if there is another ) after the current ). If there isn\\'t, that also will cost another insertion. Then at the end if there are any remaining ( that i never found a corresponding ) for, i know each of those require 2 insertions, so multiply the remaining ( count by 2.\\n\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        open_cnt = 0\\n        insert = 0\\n        \\n        i = 0\\n        while i < len(s):\\n            char = s[i]\\n            \\n            if char == \\'(\\':\\n                open_cnt += 1\\n                i += 1\\n            else:\\n                if open_cnt > 0:\\n                    open_cnt -= 1\\n                else:\\n                    insert += 1\\n                    \\n                if i + 1 < len(s) and s[i + 1] == \\')\\':\\n                    i += 2\\n                else:\\n                    insert += 1\\n                    i += 1\\n                        \\n        return insert + 2*open_cnt",
                "codeTag": "Java"
            },
            {
                "id": 789594,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc minInsertions(s string) int {\\n\\tcounter := 0\\n\\tinsertion := 0\\n\\tfor _, r := range s {\\n\\t\\tif r == \\'(\\' {\\n\\t\\t\\tif counter % 2 == 1 {\\n\\t\\t\\t\\t// insert a \\')\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t}\\n\\t\\t\\tcounter += 2\\n\\t\\t} else {\\n\\t\\t\\tif counter > 0 {\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// insert a \\'(\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter = 1\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn insertion + counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minInsertions(s string) int {\\n\\tcounter := 0\\n\\tinsertion := 0\\n\\tfor _, r := range s {\\n\\t\\tif r == \\'(\\' {\\n\\t\\t\\tif counter % 2 == 1 {\\n\\t\\t\\t\\t// insert a \\')\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t}\\n\\t\\t\\tcounter += 2\\n\\t\\t} else {\\n\\t\\t\\tif counter > 0 {\\n\\t\\t\\t\\tcounter--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// insert a \\'(\\'\\n\\t\\t\\t\\tinsertion++\\n\\t\\t\\t\\tcounter = 1\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn insertion + counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789453,
                "title": "c-simple-o-n-solution",
                "content": "Here we are maintaining a stack of `\\')\\'`. But for that the size of stack is enough. We start from the end of the string.\\nIf we encounter a `\\'(\\'`, then we must subtract 2 from the stack. If less than 2 `\\')\\'` are available in the stack then we add the number of `\\')\\'` required to make it balanced i.e. `2 - (stack size)`.\\nIf we encounter a `\\')\\'`, then we check if we have 2 consecutive `\\')\\'`. If yes, then we add 2 to the stack else we add 1 more to the result and 2 to the stack.\\nIn returning the result we have,\\n`res` = computed answer\\n`stack/2` = In case we have a residue of `\\')\\'` left over in stack, so we add 1 for every 2 in the result.\\n** `stack%2?2:0` = In case we have an odd number of residue, then we add 2 to the result, 1 `\\'(\\'` and 1 `\\')\\'`.\\nThis last condition is not required because we are adding `\\')\\'` into the stack in sets of 2. So we wont have any odd number of parenthesis in the stack.\\n```\\nint minInsertions(string s) {\\n        int res = 0, stack = 0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                if(stack<2)\\n                    res += 2-stack;\\n                stack = max(stack-2,0);\\n            }\\n            else{\\n                if(i>0 && s[i-1]==\\')\\'){\\n                    stack += 2;\\n                    i--;\\n                }\\n                else{\\n                    res += 1;\\n                    stack += 2;\\n                }\\n            }\\n        }\\n        return res + (stack/2); // + (stack%2?2:0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(string s) {\\n        int res = 0, stack = 0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                if(stack<2)\\n                    res += 2-stack;\\n                stack = max(stack-2,0);\\n            }\\n            else{\\n                if(i>0 && s[i-1]==\\')\\'){\\n                    stack += 2;\\n                    i--;\\n                }\\n                else{\\n                    res += 1;\\n                    stack += 2;\\n                }\\n            }\\n        }\\n        return res + (stack/2); // + (stack%2?2:0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785031,
                "title": "python-3-explained-using-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \"\"\"\\n        This program determines the minimum number of parentheses\\n        that need to be added to s to balance the sequence of\\n        open and close parentheses.\\n\\n        :param s: input string of open and close parentheses\\n        :type s: str\\n        :return: minimum number of parentheses needed to balance\\n                 the parentheses in s\\n        :rtype: int\\n        \"\"\"\\n        len_s = len(s)\\n        added_count = 0\\n        stack_count = 0\\n        k = 0\\n        while k < len_s:\\n            chr = s[k]\\n            k += 1\\n            if chr == \\'(\\':\\n                \"\"\"\\n                Place \\'(\\' on stack\\n                \"\"\"\\n                stack_count += 1\\n            elif chr == \\')\\':\\n                \"\"\"\\n                Have one \\')\\', need second one\\n                \"\"\"\\n                if k == len_s or s[k] == \\'(\\':\\n                    \"\"\"\\n                    End of string or \\'(\\' - add second \\')\\'\\n                    \"\"\"\\n                    added_count += 1\\n                else:\\n                    \"\"\"\\n                    Got second \\')\\' from string\\n                    \"\"\"\\n                    k += 1\\n                \"\"\"\\n                Remove matching \\'(\\' from stack or add one to\\n                remove if stack empty.\\n                \"\"\"\\n                if stack_count:\\n                    stack_count -= 1\\n                else:\\n                    added_count += 1\\n        \"\"\"\\n        After string processed, add \\'))\\' for each \\'(\\' remaining\\n        in the stack.\\n        \"\"\"\\n        added_count += 2 * stack_count\\n        return added_count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \"\"\"\\n        This program determines the minimum number of parentheses\\n        that need to be added to s to balance the sequence of\\n        open and close parentheses.\\n\\n        :param s: input string of open and close parentheses\\n        :type s: str\\n        :return: minimum number of parentheses needed to balance\\n                 the parentheses in s\\n        :rtype: int\\n        \"\"\"\\n        len_s = len(s)\\n        added_count = 0\\n        stack_count = 0\\n        k = 0\\n        while k < len_s:\\n            chr = s[k]\\n            k += 1\\n            if chr == \\'(\\':\\n                \"\"\"\\n                Place \\'(\\' on stack\\n                \"\"\"\\n                stack_count += 1\\n            elif chr == \\')\\':\\n                \"\"\"\\n                Have one \\')\\', need second one\\n                \"\"\"\\n                if k == len_s or s[k] == \\'(\\':\\n                    \"\"\"\\n                    End of string or \\'(\\' - add second \\')\\'\\n                    \"\"\"\\n                    added_count += 1\\n                else:\\n                    \"\"\"\\n                    Got second \\')\\' from string\\n                    \"\"\"\\n                    k += 1\\n                \"\"\"\\n                Remove matching \\'(\\' from stack or add one to\\n                remove if stack empty.\\n                \"\"\"\\n                if stack_count:\\n                    stack_count -= 1\\n                else:\\n                    added_count += 1\\n        \"\"\"\\n        After string processed, add \\'))\\' for each \\'(\\' remaining\\n        in the stack.\\n        \"\"\"\\n        added_count += 2 * stack_count\\n        return added_count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784566,
                "title": "javascript-extremely-simple-4-line-solution-w-explanation",
                "content": "First, we initialize a counter for the open parentheses and our answer variable.\\n\\nIterating through the string, if we find a \\'(\\', increment the counter.\\n\\nIf it\\'s not a \\'(\\', then it must be a \\')\\'. If we have a stored \\'(\\', then \\'use\\' it and decrement the counter, otherwise we\\'d need to insert a \\'(\\' here, so increment the answer. Also, if the next character is a \\')\\', then jump ahead one step by incrementing the interval, or else we\\'ll need to insert a \\')\\' here, so again increment the answer.\\n\\nFinally, any remaining stored \\'(\\'s left at the end will need to be closed off with two \\')\\'s each.\\n\\n```\\nvar minInsertions = function(s, open=0, ans=0) {\\n    for (let i = 0; i < s.length; i++)\\n        if (s[i] === \\'(\\') open++\\n        else open > 0 ? open-- : ans++, s[i+1] === \\')\\' ? i++ : ans++\\n    return ans + open * 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInsertions = function(s, open=0, ans=0) {\\n    for (let i = 0; i < s.length; i++)\\n        if (s[i] === \\'(\\') open++\\n        else open > 0 ? open-- : ans++, s[i+1] === \\')\\' ? i++ : ans++\\n    return ans + open * 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780287,
                "title": "o-n-solution-in-c-using-a-temporary-string",
                "content": "#### Converting a hard question into something simpler\\n\\nIf I had a simple string that required one \\'(\\' and \\')\\', the it would have been easier right? \\nSo, why not convert to a simpler one. Start with creating a new temporary string where we have single \\')\\' for every opening \\'(\\'. But do remember, while converting to simpler one, count number of missing \\')\\', where we were supposed to have \\'))\\'.\\n```\\n\\t\\tstring temp = \"\";\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'(\\') temp += \\'(\\';\\n            else{\\n                if(i + 1 < n){\\n                    if(s[i+1] == \\')\\') i++;\\n                    else cnt++;\\n                }\\n                else{ cnt++;}       // handling case with string ending with single \\')\\'\\n                temp+= \\')\\';\\n            }\\n        }\\n\\t\\t\\n```\\n\\nNow since this problem has been converted into a simpler problem, it can be done easily.\\nFor this  problem we need to calculate difference of \\'(\\' and \\')\\'. If anytime this difference becomes less than 0, add a \\'(\\'. And, if diff is positive, we must add a \\')\\'. \\nAnd while adding diff to total count, add twice of diff as in the original question we were supposed to add \\'))\\' for every \\'(\\'.\\n\\n\\n```\\n\\tint diff = 0, ans = 0;\\n    for (int i = 0; i < tempp.length(); ++i) { \\n  \\n        if(temp[i] == \\'(\\') diff++; \\n        else diff--; \\n  \\n        if (diff == -1) { \\n            ans++; diff++; \\n\\t\\t}\\n    } \\n  \\n    int total =  diff*2 + ans + cnt; \\n\\t\\n```\\n\\nTime Complexity : O(N)\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\n\\t\\tstring temp = \"\";\\n        int cnt = 0;\\n        for(int i = 0;i<n;i++){\\n            if(s[i] == \\'(\\') temp += \\'(\\';\\n            else{\\n                if(i + 1 < n){\\n                    if(s[i+1] == \\')\\') i++;\\n                    else cnt++;\\n                }\\n                else{ cnt++;}       // handling case with string ending with single \\')\\'\\n                temp+= \\')\\';\\n            }\\n        }\\n\\t\\t\\n```\n```\\n\\tint diff = 0, ans = 0;\\n    for (int i = 0; i < tempp.length(); ++i) { \\n  \\n        if(temp[i] == \\'(\\') diff++; \\n        else diff--; \\n  \\n        if (diff == -1) { \\n            ans++; diff++; \\n\\t\\t}\\n    } \\n  \\n    int total =  diff*2 + ans + cnt; \\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780195,
                "title": "easy-understanding-c-python-stack-solution",
                "content": "We can use stack to imitate left parenthesis.\\nWhenever we met a left parenthesis, place it into stack.\\nOtherwise, fill in left parenthesis, and pop out stack as needed.\\n\\nC++ version:\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> stk;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                stk.push(c);\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (stk.empty()) {\\n                    ++res;\\n                    stk.push(\\'(\\');\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    stk.pop();\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        \\n        res += 2 * stk.size();\\n        return res;\\n    }\\n};\\n```\\n\\nPython version:\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```\\n\\nAfter you\\'ve understood this method, we could easily replace stack with left counter.\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left = 0;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                ++left;\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (left == 0) {\\n                    ++res;\\n                    ++left;\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    --left;\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    --left;\\n                }\\n            }\\n        }\\n        \\n        res += 2 * left;\\n        return res;\\n    }\\n};\\n```\\n\\npython:\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> stk;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                stk.push(c);\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (stk.empty()) {\\n                    ++res;\\n                    stk.push(\\'(\\');\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    stk.pop();\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        \\n        res += 2 * stk.size();\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int left = 0;\\n        int res = 0;\\n        for (int idx = 0; idx < s.length(); ++idx) {\\n            char c = s[idx];\\n            if (c == \\'(\\') {\\n                ++left;\\n            } else if (c == \\')\\') {\\n                // Fill in missing left parenthesis.\\n                if (left == 0) {\\n                    ++res;\\n                    ++left;\\n                }\\n                \\n                // Paired right parenthesis.\\n                if (idx < s.length() - 1 && s[idx + 1] == \\')\\') {\\n                    ++idx;\\n                    --left;\\n                }\\n                \\n                // Unpaired right parenthesis.\\n                else if (idx == s.length() - 1 || (idx < s.length() - 1 && s[idx + 1] != \\')\\')) {\\n                    ++res;\\n                    --left;\\n                }\\n            }\\n        }\\n        \\n        res += 2 * left;\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stk = list()\\n        res = 0\\n        idx = 0\\n        while (idx < len(s)):\\n            c = s[idx]\\n            if (c == \\'(\\'):\\n                stk.append(c)\\n            else:\\n                # Fill in left parenthesis\\n                if (not stk):\\n                    res += 1\\n                    stk.append(\\'(\\')\\n                \\n                # Paired right parenthesis.\\n                if (idx < len(s) - 1 and s[idx + 1] == \\')\\'):\\n                    idx += 1\\n                    stk.pop()\\n                \\n                # Unpaired right parenthesis.\\n                else:\\n                    res += 1\\n                    stk.pop()\\n            \\n            idx += 1\\n        \\n        # Calculate unpaired left parenthesis.\\n        res += len(stk) * 2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779962,
                "title": "c-only-count-left-parentheses-o-n-o-1-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tint left=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\tif(left>0 && i<s.size()-1 && s[i+1]==\\')\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tleft--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(left>0  && ((i<s.size()-1 && s[i+1]!=\\')\\') || i==s.size()-1))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tleft--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(left==0 && i<s.size()-1 && s[i+1]==\\')\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse if(left==0 && ((i<s.size()-1 && s[i+1]!=\\')\\') || i==s.size()-1 ))\\n\\t\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\t\\tans+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans+=left*2;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tint left=0;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 779934,
                "title": "python-using-stack",
                "content": "As we need two clossing brackets for one opening bracket we pop a oppening bracket from the stack when we have two clossing bracket adjecent to each other, and rest is very similar to simple valid parenthesis problem.\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack=[]\\n        number=0\\n        ans=0\\n        i=0\\n        while(i<len(s)):\\n            if s[i]==\"(\":\\n                stack.append(s[i])\\n                i+=1\\n            else:\\n                if i==len(s)-1 or s[i+1]==\"(\":\\n                    ans+=1\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=1\\n                else:\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=2\\n        \\n        ans+=len(stack)*2\\n        return ans\\n",
                "solutionTags": [],
                "code": "As we need two clossing brackets for one opening bracket we pop a oppening bracket from the stack when we have two clossing bracket adjecent to each other, and rest is very similar to simple valid parenthesis problem.\\n```\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack=[]\\n        number=0\\n        ans=0\\n        i=0\\n        while(i<len(s)):\\n            if s[i]==\"(\":\\n                stack.append(s[i])\\n                i+=1\\n            else:\\n                if i==len(s)-1 or s[i+1]==\"(\":\\n                    ans+=1\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=1\\n                else:\\n                    if len(stack)!=0:\\n                        stack.pop()\\n                    else:\\n                        ans+=1\\n                    i+=2\\n        \\n        ans+=len(stack)*2\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 779897,
                "title": "java-using-stack",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0, curr = 0;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') {\\n                if(curr == 1) {\\n                    count++;\\n                    if(stack.size() > 0) stack.pop();\\n                    else count++;\\n                    curr = 0;\\n                }\\n                stack.push(ch);\\n            } else {\\n                if(curr == 0) {\\n                    if(stack.size() == 0) {\\n                        stack.push(\\'(\\');\\n                        count++;\\n                    }\\n                    curr = 1;\\n                } else {\\n                    if(stack.size() == 0) count++;\\n                    else stack.pop();\\n                    curr = 0;\\n                }\\n            }\\n        }\\n        while(stack.size() > 0) {\\n            if(curr == 1) {\\n                curr = 0;\\n                count++;\\n            } else count += 2;\\n            stack.pop();\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        int count = 0, curr = 0;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\') {\\n                if(curr == 1) {\\n                    count++;\\n                    if(stack.size() > 0) stack.pop();\\n                    else count++;\\n                    curr = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4084421,
                "title": "java-intuitive-easy-constant-space-complexity-missing-test-case-description-explanation",
                "content": "# Missing Data\\nthe opening bracket can only be balanced by pair of consecutive closing brackets. \\nFor example in the following case: \\n(()))(()))()())))\\nSee the following screenshot how the brackets are balanced with each other. Same color opening brackets will be balanced with first occurence of same color closing bracket towards it right.\\n \\n![bracketsBalanced.png](https://assets.leetcode.com/users/images/ce86266a-410c-4a01-872b-d3ebce631140_1695553126.7488647.png)\\n\\n\\nThe answer should be 4\\nExplanation: \\nThe first red brackets need 1 closing bracket to balance. \\nSimilarly the next Green Brackets need one 1 closing bracket\\nBlue Brackets need 1 closing bracket \\nBrown Brackets need 1 opening bracket\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep count of opening bracket encountered so far, \\nIf the current bracket is an closing bracket, balance it with one of the opening bracket, if there is any otherwise, we just have to insert one opening bracket. \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open, close, index ;\\n        open = close  = index = 0;\\n        while ( index < s.length()){\\n            char ch = s.charAt(index++);\\n            if ( ch == \\'(\\'){\\n                open++;\\n            }\\n            else{\\n                // this is an closing bracket.\\n                if ( index >= s.length() || s.charAt(index) != \\')\\'){\\n                    close ++;\\n                }\\n                else{\\n                    index++;\\n                }\\n                if ( open > 0){\\n                    open--;\\n                }\\n                else{\\n                    close++;\\n                }\\n\\n            }\\n        }\\n        return close + open*2;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int open, close, index ;\\n        open = close  = index = 0;\\n        while ( index < s.length()){\\n            char ch = s.charAt(index++);\\n            if ( ch == \\'(\\'){\\n                open++;\\n            }\\n            else{\\n                // this is an closing bracket.\\n                if ( index >= s.length() || s.charAt(index) != \\')\\'){\\n                    close ++;\\n                }\\n                else{\\n                    index++;\\n                }\\n                if ( open > 0){\\n                    open--;\\n                }\\n                else{\\n                    close++;\\n                }\\n\\n            }\\n        }\\n        return close + open*2;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057125,
                "title": "java-solution",
                "content": "S# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        //count is for counting the number of right parenthese\\n        int count=0;\\n        int result=0;\\n        for (char x:s.toCharArray()) {\\n            if (x == \\'(\\') {\\n                count+=2;\\n                if(count%2!=0){\\n                    result++;\\n                    count--;\\n                }\\n            }\\n            else{\\n                //we have encountered right paranthese\\n                count-=1;\\n                if(count<0){\\n                    count+=2;\\n                    result++;\\n                }\\n            }\\n        }\\n        return result+count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        //count is for counting the number of right parenthese\\n        int count=0;\\n        int result=0;\\n        for (char x:s.toCharArray()) {\\n            if (x == \\'(\\') {\\n                count+=2;\\n                if(count%2!=0){\\n                    result++;\\n                    count--;\\n                }\\n            }\\n            else{\\n                //we have encountered right paranthese\\n                count-=1;\\n                if(count<0){\\n                    count+=2;\\n                    result++;\\n                }\\n            }\\n        }\\n        return result+count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054767,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int lcount = 0;\\n        int res = 0;\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(s.charAt(i) == \\'(\\') {\\n                lcount++;\\n            }\\n            if(s.charAt(i) == \\')\\') {\\n                \\n                if(i < n-1 && s.charAt(i+1) == \\')\\') {\\n                    i++;\\n                    \\n                    if(lcount > 0) {\\n                        lcount--;\\n                    } else {\\n                        res++;\\n                    }\\n                } else {\\n                    if(lcount > 0) {\\n                        lcount--;\\n                        res++;\\n                    } else {\\n                        res += 2;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        res += lcount*2;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        \\n        int lcount = 0;\\n        int res = 0;\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(s.charAt(i) == \\'(\\') {\\n                lcount++;\\n            }\\n            if(s.charAt(i) == \\')\\') {\\n                \\n                if(i < n-1 && s.charAt(i+1) == \\')\\') {\\n                    i++;\\n                    \\n                    if(lcount > 0) {\\n                        lcount--;\\n                    } else {\\n                        res++;\\n                    }\\n                } else {\\n                    if(lcount > 0) {\\n                        lcount--;\\n                        res++;\\n                    } else {\\n                        res += 2;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        res += lcount*2;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038546,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\nBasically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\t\\tint countBrackets = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(s.charAt(i));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (i + 1 < s.length() && s.charAt(i + 1) == \\')\\') {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (!stack.isEmpty()) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t}\\n        }\\n\\t\\t}\\n\\t\\tcountBrackets += 2 * stack.size();\\n\\t\\treturn countBrackets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\t\\tint countBrackets = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tif (s.charAt(i) == \\'(\\') {\\n\\t\\t\\t\\tstack.push(s.charAt(i));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (i + 1 < s.length() && s.charAt(i + 1) == \\')\\') {\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tif (!stack.isEmpty()) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcountBrackets++;\\n\\t\\t\\t}\\n        }\\n\\t\\t}\\n\\t\\tcountBrackets += 2 * stack.size();\\n\\t\\treturn countBrackets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034396,
                "title": "go-greedy-100-less-memory-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minInsertions(s string) int {\\n\\n\\tc_needed := 0\\n\\to_needed := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"(\" {\\n\\t\\t\\tc_needed += 2\\n\\n\\t\\t\\tif c_needed%2 == 1 {\\n\\t\\t\\t\\tc_needed--\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tc_needed -= 1\\n\\n\\t\\t\\tif c_needed == -1 {\\n\\t\\t\\t\\tc_needed = 1\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c_needed + o_needed\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nfunc minInsertions(s string) int {\\n\\n\\tc_needed := 0\\n\\to_needed := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"(\" {\\n\\t\\t\\tc_needed += 2\\n\\n\\t\\t\\tif c_needed%2 == 1 {\\n\\t\\t\\t\\tc_needed--\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tc_needed -= 1\\n\\n\\t\\t\\tif c_needed == -1 {\\n\\t\\t\\t\\tc_needed = 1\\n\\t\\t\\t\\to_needed++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c_needed + o_needed\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957611,
                "title": "c-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minInsertions(string s) {\\n    int neededRight = 0;   // Increment by 2 for each \\'(\\'.\\n    int missingLeft = 0;   // Increment by 1 for each missing \\'(\\'.\\n    int missingRight = 0;  // Increment by 1 for each missing \\')\\'.\\n\\n    for (const char c : s)\\n      if (c == \\'(\\') {\\n        if (neededRight % 2 == 1) {\\n          // E.g. \"()(...\"\\n          ++missingRight;\\n          --neededRight;\\n        }\\n        neededRight += 2;\\n      } else if (--neededRight < 0) {  // c == \\')\\'\\n        // E.g. \"()))...\"\\n        ++missingLeft;\\n        neededRight += 2;\\n      }\\n\\n    return neededRight + missingLeft + missingRight;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minInsertions(string s) {\\n    int neededRight = 0;   // Increment by 2 for each \\'(\\'.\\n    int missingLeft = 0;   // Increment by 1 for each missing \\'(\\'.\\n    int missingRight = 0;  // Increment by 1 for each missing \\')\\'.\\n\\n    for (const char c : s)\\n      if (c == \\'(\\') {\\n        if (neededRight % 2 == 1) {\\n          // E.g. \"()(...\"\\n          ++missingRight;\\n          --neededRight;\\n        }\\n        neededRight += 2;\\n      } else if (--neededRight < 0) {  // c == \\')\\'\\n        // E.g. \"()))...\"\\n        ++missingLeft;\\n        neededRight += 2;\\n      }\\n\\n    return neededRight + missingLeft + missingRight;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956017,
                "title": "100-useful-minimum-number-of-swaps-to-make-the-string-balanced",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    \\n   let left = 0;\\n   let right = 0;\\n   for(i=0; i<s.length;i++) {\\n       if (s[i]===\"(\") {\\n           right += 2;\\n            if(right % 2 === 1) {\\n                left++;\\n                right--;\\n            }\\n       } \\n       if (s[i]===\")\") {\\n           right--;\\n            if (right ===-1) {\\n                left++;\\n                right = 1;\\n            \\n           }\\n       }\\n   } \\n return left+right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    \\n   let left = 0;\\n   let right = 0;\\n   for(i=0; i<s.length;i++) {\\n       if (s[i]===\"(\") {\\n           right += 2;\\n            if(right % 2 === 1) {\\n                left++;\\n                right--;\\n            }\\n       } \\n       if (s[i]===\")\") {\\n           right--;\\n            if (right ===-1) {\\n                left++;\\n                right = 1;\\n            \\n           }\\n       }\\n   } \\n return left+right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929808,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minInsertions = function(s) {\\n    let left = result = 0;\\n\\n    for (let index = 0; index < s.length; index++) {\\n        if (s[index] === \\'(\\') left += 1;\\n        else if (s[index + 1] === \\')\\') {\\n            left > 0 ? left -= 1 : result += 1;\\n            index += 1;\\n        } else {\\n            if (left > 0) {\\n                left -= 1;\\n                result += 1;\\n            } else {\\n                result += 2;\\n            }\\n        }\\n    }\\n    return result += left * 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInsertions = function(s) {\\n    let left = result = 0;\\n\\n    for (let index = 0; index < s.length; index++) {\\n        if (s[index] === \\'(\\') left += 1;\\n        else if (s[index + 1] === \\')\\') {\\n            left > 0 ? left -= 1 : result += 1;\\n            index += 1;\\n        } else {\\n            if (left > 0) {\\n                left -= 1;\\n                result += 1;\\n            } else {\\n                result += 2;\\n            }\\n        }\\n    }\\n    return result += left * 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915268,
                "title": "python-o-n-time-and-o-1-space-beats-100",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        insertion = 0\\n        left = 0 # track imbalanced opens\\n        right = False # track if there is a single closing bracket\\n        for v in s:\\n            if v == \\'(\\':\\n                # we\\'ve closed a single bracket, so either have () or just ), inserting 1 or 2 respectively\\n                if right:\\n                    right = False\\n                    if left:\\n                        insertion += 1\\n                        left -= 1\\n                    else:\\n                        insertion += 2\\n                left += 1\\n            else:\\n                # flip whether we have a single trailing ) and evaluate insertions needed if we have a new ))\\n                if not right:\\n                    right = True\\n                else:\\n                    right = False\\n                    if left:\\n                        left -= 1\\n                    else:\\n                        insertion += 1\\n                        \\n        if left:\\n            return insertion + 2  * left - right\\n        \\n        if right:\\n            return insertion + 2\\n                        \\n        return insertion\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \\n        insertion = 0\\n        left = 0 # track imbalanced opens\\n        right = False # track if there is a single closing bracket\\n        for v in s:\\n            if v == \\'(\\':\\n                # we\\'ve closed a single bracket, so either have () or just ), inserting 1 or 2 respectively\\n                if right:\\n                    right = False\\n                    if left:\\n                        insertion += 1\\n                        left -= 1\\n                    else:\\n                        insertion += 2\\n                left += 1\\n            else:\\n                # flip whether we have a single trailing ) and evaluate insertions needed if we have a new ))\\n                if not right:\\n                    right = True\\n                else:\\n                    right = False\\n                    if left:\\n                        left -= 1\\n                    else:\\n                        insertion += 1\\n                        \\n        if left:\\n            return insertion + 2  * left - right\\n        \\n        if right:\\n            return insertion + 2\\n                        \\n        return insertion\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914863,
                "title": "java-no-stack-used-easy-to-follow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int minInsertions(String s) {\\n    int n = s.length();\\n    int count = 0;\\n    int ans = 0;\\n    \\n    for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            count++;\\n        } else {\\n            if (i + 1 < n && s.charAt(i + 1) == \\')\\') {\\n                i++;\\n                if (count > 0) {\\n                    count--;\\n                } else {\\n                    ans++;\\n                }\\n            } else {\\n                if (count > 0) {\\n                    count--;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                }\\n            }\\n        }\\n    }\\n    \\n    ans = ans + (count * 2);\\n    return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int minInsertions(String s) {\\n    int n = s.length();\\n    int count = 0;\\n    int ans = 0;\\n    \\n    for (int i = 0; i < n; i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            count++;\\n        } else {\\n            if (i + 1 < n && s.charAt(i + 1) == \\')\\') {\\n                i++;\\n                if (count > 0) {\\n                    count--;\\n                } else {\\n                    ans++;\\n                }\\n            } else {\\n                if (count > 0) {\\n                    count--;\\n                    ans++;\\n                } else {\\n                    ans += 2;\\n                }\\n            }\\n        }\\n    }\\n    \\n    ans = ans + (count * 2);\\n    return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914813,
                "title": "c-no-stack-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // n equal to the size of the array\\n        int n = s.length();\\n        // 2 variables count & ans\\n        int count = 0;\\n        int ans = 0;\\n        // Traverse the array\\n        for (int i = 0; i < n; i++) {\\n            // if we found \\'(\\' in array we\\'ll increase the count\\n            if (s[i] == \\'(\\') {\\n                count++;\\n            } else { // s[i] == \\')\\'\\n                // check if the next is also \\')\\'\\n                if (i + 1 < n && s[i + 1] == \\')\\') {\\n                    // move i ahead\\n                    i++;\\n                    // if there\\'s \\'(\\' present i.e count > 0 : ( ))\\n                    if (count > 0) {\\n                        count--;\\n                    } else {\\n                        // \\'(\\' is not present we\\'ll add 1 to the ans\\n                        ans++;\\n                    }\\n                } else { // This tells us that there\\'s a \" ) ( \" closing & opening\\n                    if (count > 0) {\\n                        // check if there\\'s is a opening or not i.e ( )(\\n                        count--;\\n                        ans++;\\n                    } else {\\n                        // there\\'s is not opening i.e )(\\n                        ans += 2;\\n                    }\\n                }\\n            }\\n        }\\n        // why we;re doing x2 because for every ( we need )) to balance\\n        ans = ans + (count * 2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // n equal to the size of the array\\n        int n = s.length();\\n        // 2 variables count & ans\\n        int count = 0;\\n        int ans = 0;\\n        // Traverse the array\\n        for (int i = 0; i < n; i++) {\\n            // if we found \\'(\\' in array we\\'ll increase the count\\n            if (s[i] == \\'(\\') {\\n                count++;\\n            } else { // s[i] == \\')\\'\\n                // check if the next is also \\')\\'\\n                if (i + 1 < n && s[i + 1] == \\')\\') {\\n                    // move i ahead\\n                    i++;\\n                    // if there\\'s \\'(\\' present i.e count > 0 : ( ))\\n                    if (count > 0) {\\n                        count--;\\n                    } else {\\n                        // \\'(\\' is not present we\\'ll add 1 to the ans\\n                        ans++;\\n                    }\\n                } else { // This tells us that there\\'s a \" ) ( \" closing & opening\\n                    if (count > 0) {\\n                        // check if there\\'s is a opening or not i.e ( )(\\n                        count--;\\n                        ans++;\\n                    } else {\\n                        // there\\'s is not opening i.e )(\\n                        ans += 2;\\n                    }\\n                }\\n            }\\n        }\\n        // why we;re doing x2 because for every ( we need )) to balance\\n        ans = ans + (count * 2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908008,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve the problem using only Stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n     public int minInsertions(String s) { Stack<Character> stack = new Stack<>();\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                    }else{\\n                        ans++;\\n                    }\\n                    }else{\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                        ans++;\\n                    }else{// it means that the first element is ) and then the elements ar ()())\\n                        ans+=2;\\n                    }\\n                }\\n                }else{\\n                stack.push(s.charAt(i));\\n            }\\n            }\\n        return ans+=(2*stack.size());\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int minInsertions(String s) { Stack<Character> stack = new Stack<>();\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\')\\'){\\n                if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n                    i++;\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                    }else{\\n                        ans++;\\n                    }\\n                    }else{\\n                    if(!stack.isEmpty()){\\n                        stack.pop();\\n                        ans++;\\n                    }else{// it means that the first element is ) and then the elements ar ()())\\n                        ans+=2;\\n                    }\\n                }\\n                }else{\\n                stack.push(s.charAt(i));\\n            }\\n            }\\n        return ans+=(2*stack.size());\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906554,
                "title": "c-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string modified = \"\";\\n        int count = 0;\\n        int n = s.length();\\n        int i = 0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                modified.push_back(\\'(\\');\\n                i++;\\n            }\\n            else\\n            {\\n                if(i+1<n && s[i+1]==\\')\\')\\n                {\\n                    modified.push_back(\\')\\');\\n                    i = i+2;\\n                }\\n                else\\n                {\\n                    modified.push_back(\\')\\');\\n                    count++;\\n                    i = i+1;\\n                }\\n            }\\n        }\\n        priority_queue<int> st;\\n        for(int j=0;j<modified.length();j++)\\n        {\\n            if(modified[j]==\\'(\\')\\n            {\\n                st.push(j);\\n            }\\n            else\\n            {\\n               if(!st.empty())\\n               {\\n                   st.pop();\\n               }\\n               else\\n               {\\n                   count++;\\n               }\\n            }\\n        }\\n\\n        if(st.size()>0)\\n        count+=2*st.size();\\n\\n        return  count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string modified = \"\";\\n        int count = 0;\\n        int n = s.length();\\n        int i = 0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                modified.push_back(\\'(\\');\\n                i++;\\n            }\\n            else\\n            {\\n                if(i+1<n && s[i+1]==\\')\\')\\n                {\\n                    modified.push_back(\\')\\');\\n                    i = i+2;\\n                }\\n                else\\n                {\\n                    modified.push_back(\\')\\');\\n                    count++;\\n                    i = i+1;\\n                }\\n            }\\n        }\\n        priority_queue<int> st;\\n        for(int j=0;j<modified.length();j++)\\n        {\\n            if(modified[j]==\\'(\\')\\n            {\\n                st.push(j);\\n            }\\n            else\\n            {\\n               if(!st.empty())\\n               {\\n                   st.pop();\\n               }\\n               else\\n               {\\n                   count++;\\n               }\\n            }\\n        }\\n\\n        if(st.size()>0)\\n        count+=2*st.size();\\n\\n        return  count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880202,
                "title": "simple-stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) \\n    {\\n       Stack<Character> ss=new Stack<>();\\n       int co=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           char c=s.charAt(i);\\n           if(c==\\'(\\')\\n           {\\n             ss.push(c);\\n           }\\n           else\\n           {\\n             if(ss.size() > 0 && ss.peek() == \\'(\\')\\n             {\\n                 if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  i++;\\n                  ss.pop();\\n                }\\n                else\\n                {\\n                  co++;\\n                  ss.pop();\\n                }\\n             }\\n             else\\n             {\\n                if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  co++;\\n                  i++;\\n                }\\n                else\\n                {\\n                  co+=2;\\n                }\\n             }\\n           }\\n       }\\n       return co+(ss.size()*2); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) \\n    {\\n       Stack<Character> ss=new Stack<>();\\n       int co=0;\\n       for(int i=0;i<s.length();i++)\\n       {\\n           char c=s.charAt(i);\\n           if(c==\\'(\\')\\n           {\\n             ss.push(c);\\n           }\\n           else\\n           {\\n             if(ss.size() > 0 && ss.peek() == \\'(\\')\\n             {\\n                 if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  i++;\\n                  ss.pop();\\n                }\\n                else\\n                {\\n                  co++;\\n                  ss.pop();\\n                }\\n             }\\n             else\\n             {\\n                if(i < s.length()-1 && s.charAt(i+1) == \\')\\')\\n                {\\n                  co++;\\n                  i++;\\n                }\\n                else\\n                {\\n                  co+=2;\\n                }\\n             }\\n           }\\n       }\\n       return co+(ss.size()*2); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863528,
                "title": "java-solution-using-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int k = 0;\\n\\n        for(int i=0; i<n-1; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'(\\') st.push(ch);\\n            else{\\n                char x = s.charAt(i+1);\\n                if(x==\\')\\'){\\n                    if(st.size()==0) ans++;\\n                        else st.pop();\\n                        i++;\\n                        if(i==n-1) k=1;\\n                    }else{\\n                        if(st.size()==0) ans+=2;\\n                    else{\\n                        ans++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n\\n        int a = st.size();\\n        char x = s.charAt(n-1);\\n\\n        if(k==0){\\n            if(x==\\'(\\') ans=ans+2;\\n        else{\\n            if(a!=0){\\n                ans++;\\n                a--;\\n            }else{\\n                ans+=2;\\n            }\\n        }\\n        }\\n        \\n        ans=ans+2*a;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n\\n        int ans = 0;\\n        int k = 0;\\n\\n        for(int i=0; i<n-1; i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'(\\') st.push(ch);\\n            else{\\n                char x = s.charAt(i+1);\\n                if(x==\\')\\'){\\n                    if(st.size()==0) ans++;\\n                        else st.pop();\\n                        i++;\\n                        if(i==n-1) k=1;\\n                    }else{\\n                        if(st.size()==0) ans+=2;\\n                    else{\\n                        ans++;\\n                        st.pop();\\n                    }\\n                }\\n            }\\n        }\\n\\n        int a = st.size();\\n        char x = s.charAt(n-1);\\n\\n        if(k==0){\\n            if(x==\\'(\\') ans=ans+2;\\n        else{\\n            if(a!=0){\\n                ans++;\\n                a--;\\n            }else{\\n                ans+=2;\\n            }\\n        }\\n        }\\n        \\n        ans=ans+2*a;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853124,
                "title": "python-beats-98-one-pass-stack",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        closingPCount = 0\\n        stack = deque()\\n        insertions = 0\\n        for c in s:\\n            if c == \"(\":\\n                if closingPCount == 1:\\n                    insertions += 1\\n                    closingPCount = 0\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                stack.append(c)\\n            else:\\n                if closingPCount == 0:\\n                    closingPCount += 1\\n                else:\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                    closingPCount = 0\\n        \\n        if closingPCount == 1:\\n            insertions += 1\\n            if stack:\\n                stack.pop()\\n            else:\\n                insertions += 1\\n        \\n        return insertions + len(stack)*2\\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        closingPCount = 0\\n        stack = deque()\\n        insertions = 0\\n        for c in s:\\n            if c == \"(\":\\n                if closingPCount == 1:\\n                    insertions += 1\\n                    closingPCount = 0\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                stack.append(c)\\n            else:\\n                if closingPCount == 0:\\n                    closingPCount += 1\\n                else:\\n                    if stack:\\n                        stack.pop()\\n                    else:\\n                        insertions += 1\\n                    closingPCount = 0\\n        \\n        if closingPCount == 1:\\n            insertions += 1\\n            if stack:\\n                stack.pop()\\n            else:\\n                insertions += 1\\n        \\n        return insertions + len(stack)*2\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 3805390,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:      \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                required_closed += 2 \\n            else: \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n                if required_closed:\\n                    required_closed -= 2\\n                else:\\n                    missing_brackets += 1\\n        return missing_brackets + required_closed\\n\\n\\n        # o=0\\n        # c=0\\n        # for i in s:\\n        #     if(i==\"(\"):\\n        #         o+=1\\n        #     else:\\n        #         if(o):\\n        #             o-=1\\n        #         else:\\n        #             c+=1\\n        # return(o+c)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:      \\n        s = s.replace(\\'))\\', \\'}\\')\\n        missing_brackets = 0\\n        required_closed = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                required_closed += 2 \\n            else: \\n                if c == \\')\\': \\n                    missing_brackets += 1\\n                if required_closed:\\n                    required_closed -= 2\\n                else:\\n                    missing_brackets += 1\\n        return missing_brackets + required_closed\\n\\n\\n        # o=0\\n        # c=0\\n        # for i in s:\\n        #     if(i==\"(\"):\\n        #         o+=1\\n        #     else:\\n        #         if(o):\\n        #             o-=1\\n        #         else:\\n        #             c+=1\\n        # return(o+c)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769398,
                "title": "dart-solution",
                "content": "# Intuition\\n\\n1. Consecutive `)` must be even count.\\n2. When it\\'s imbalanced, add `(`.\\n3. If there are outstanding `(`, add `))` at the end.\\n\\n# Code\\n```\\nclass StrCount {\\n  final String letter;\\n  final int count;\\n  const StrCount(this.letter, this.count);\\n}\\nclass Solution {\\n  int minInsertions(String s) {\\n    List<StrCount> counts = [];\\n    for (int i = 0; i < s.length; i++) {\\n      final begin = i;\\n      while (i + 1 < s.length && s[i + 1] == s[begin]) i++;\\n      counts.add(StrCount(s[begin], i + 1 - begin));\\n    }\\n    var sum = 0;\\n    var res = 0;\\n    for (final sc in counts) {\\n      if (sc.letter == \\'(\\') {\\n        sum += sc.count;\\n      } else {\\n        if (sc.count % 2 == 1)\\n          res++;\\n        final closers = (sc.count + 1) ~/ 2;\\n        sum -= closers;\\n        if (sum < 0) {\\n          res -= sum;\\n          sum = 0;\\n        }\\n      }\\n    }\\n    if (sum > 0) res += 2 * sum;\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass StrCount {\\n  final String letter;\\n  final int count;\\n  const StrCount(this.letter, this.count);\\n}\\nclass Solution {\\n  int minInsertions(String s) {\\n    List<StrCount> counts = [];\\n    for (int i = 0; i < s.length; i++) {\\n      final begin = i;\\n      while (i + 1 < s.length && s[i + 1] == s[begin]) i++;\\n      counts.add(StrCount(s[begin], i + 1 - begin));\\n    }\\n    var sum = 0;\\n    var res = 0;\\n    for (final sc in counts) {\\n      if (sc.letter == \\'(\\') {\\n        sum += sc.count;\\n      } else {\\n        if (sc.count % 2 == 1)\\n          res++;\\n        final closers = (sc.count + 1) ~/ 2;\\n        sum -= closers;\\n        if (sum < 0) {\\n          res -= sum;\\n          sum = 0;\\n        }\\n      }\\n    }\\n    if (sum > 0) res += 2 * sum;\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756296,
                "title": "easy-python3-solution-with-an-explanation",
                "content": "\\n# Approach\\nHere is an approach to understand how the code works:\\n\\n1. Iterate through the characters of the string using a while loop until i reaches the end of the string.\\n\\n2. If openBrackets is greater than 0 and ch is equal to \\')\\', it means there are open parentheses that need to be closed.\\n\\n    - If the next character s[i+1] is also \\')\\', it means there is a pair of closing parentheses. In this case, decrease minimumInsertions by 2 to account for the pair and increment i by 2 to skip the next character.\\n    - Otherwise, there is a single closing parenthesis. Increment i by 1 and decrease minimumInsertions by 1 to account for the single closing parenthesis.\\n    - Decrement openBrackets by 1 since a closing parenthesis has been balanced.\\n3. If ch is equal to \\')\\', but the above condition is not met, it means there is an unbalanced closing parenthesis.\\n\\n    - If the next character s[i+1] is also \\')\\', it means there is a pair of closing parentheses. In this case, increment minimumInsertions by 1 to account for adding an opening parenthesis, and increment i by 2 to skip the next character.\\n    - Otherwise, there is a single closing parenthesis. Increment minimumInsertions by 2 to account for adding an opening and closing parenthesis, and increment i by 1.\\n4. If ch is equal to \\'(\\', it means there is an opening parenthesis that needs to be closed.\\n\\n    - Increment openBrackets by 1 to keep track of the open parentheses.\\n    - Increment minimumInsertions by 2 to account for adding a closing parenthesis.\\n    - Increment i by 1.\\n5. After the loop ends, return the value of minimumInsertions, which represents the minimum number of insertions required to balance the parentheses in the string.\\n\\nThis approach ensures that the parentheses are balanced by inserting the minimum number of additional parentheses. The algorithm scans the string from left to right and maintains a count of open parentheses encountered. It adjusts the count and the number of insertions based on the encountered characters.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        openBrackets = 0\\n        minimumInsertions = 0\\n        i = 0\\n        n = len(s)\\n\\n        while i < n:\\n            ch = s[i]\\n\\n            if openBrackets > 0 and ch == \\')\\': \\n                if i + 1 < n and s[i + 1] == \\')\\':                    \\n                    minimumInsertions -= 2\\n                    i += 2\\n                else:\\n                    i += 1\\n                    minimumInsertions -= 1\\n                openBrackets -= 1\\n            elif ch == \\')\\':\\n                if i + 1 < n and s[i + 1] == \\')\\':\\n                    minimumInsertions += 1\\n                    i += 2\\n                else:\\n                    minimumInsertions += 2\\n                    i += 1\\n            elif ch == \\'(\\':\\n                openBrackets += 1\\n                minimumInsertions += 2\\n                i += 1\\n\\n        return minimumInsertions\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        openBrackets = 0\\n        minimumInsertions = 0\\n        i = 0\\n        n = len(s)\\n\\n        while i < n:\\n            ch = s[i]\\n\\n            if openBrackets > 0 and ch == \\')\\': \\n                if i + 1 < n and s[i + 1] == \\')\\':                    \\n                    minimumInsertions -= 2\\n                    i += 2\\n                else:\\n                    i += 1\\n                    minimumInsertions -= 1\\n                openBrackets -= 1\\n            elif ch == \\')\\':\\n                if i + 1 < n and s[i + 1] == \\')\\':\\n                    minimumInsertions += 1\\n                    i += 2\\n                else:\\n                    minimumInsertions += 2\\n                    i += 1\\n            elif ch == \\'(\\':\\n                openBrackets += 1\\n                minimumInsertions += 2\\n                i += 1\\n\\n        return minimumInsertions\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659026,
                "title": "python3-following-the-hints",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ans = 0\\n        st = []\\n        leftCnt = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i]==\\'(\\':\\n                leftCnt += 1\\n            else:\\n                if i+1 < len(s) and s[i+1]==\\')\\':\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n                    i += 2\\n                    continue\\n                else:\\n                    ans += 1\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n            i += 1\\n\\n        ans += leftCnt*2\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        ans = 0\\n        st = []\\n        leftCnt = 0\\n        i = 0\\n        while i < len(s):\\n            if s[i]==\\'(\\':\\n                leftCnt += 1\\n            else:\\n                if i+1 < len(s) and s[i+1]==\\')\\':\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n                    i += 2\\n                    continue\\n                else:\\n                    ans += 1\\n                    if leftCnt > 0:\\n                        leftCnt -= 1\\n                    else:\\n                        ans += 1\\n            i += 1\\n\\n        ans += leftCnt*2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614434,
                "title": "easy-c-with-or-without-stack-beats-100",
                "content": "\\n1.  Using stack\\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        stack<char>st;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                st.push(c);\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(st.empty() || st.top()!=\\'(\\') cnt++;\\n                else st.pop();\\n            }\\n        }\\n        \\n        return cnt+ 2*st.size();\\n    }\\n};\\n\\n```\\n2. No stack , keep count of unbalanced open brackets \\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        int open=0;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                open++;\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(open==0) cnt++;\\n                else open--;\\n            }\\n        }\\n        \\n        return cnt+ 2*open;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        stack<char>st;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                st.push(c);\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(st.empty() || st.top()!=\\'(\\') cnt++;\\n                else st.pop();\\n            }\\n        }\\n        \\n        return cnt+ 2*st.size();\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minInsertions(string s) \\n    {\\n        int open=0;\\n        int cnt=0, n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char c=s[i];\\n            if(c==\\'(\\')\\n                open++;\\n            else\\n            {\\n                if(i==n-1 || s[i+1]!=\\')\\') cnt++;\\n                else i++;\\n                \\n                if(open==0) cnt++;\\n                else open--;\\n            }\\n        }\\n        \\n        return cnt+ 2*open;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608373,
                "title": "1541-my-java-solution-with-comments",
                "content": "This is an extension quesion of LeetCode 921\\n\\n# Code\\n```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int needP = 0, putP = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char p = s.charAt(i);\\n            if (p == \\'(\\') {\\n                // if we see a left p\\n                // expect 2 right p in the future string\\n                needP += 2;\\n                if (needP %2 == 1) {\\n                // needP must be even, because for a left p, it must come with 2 consecutive right p\\n                // so we should PUT a right P in this case\\n                // since we put a right p, we need one less right p\\n                    needP--;\\n                    putP++;\\n                }\\n            } else {\\n                // p == \\')\\', consume needRight if we still have it >0\\n                if(needP > 0) {\\n                    needP--;\\n                } else {\\n                // needP==0, but we see a right p here,\\n                // so we need a pair of ()\\n                // we firstly PUT a left p, and we expect a right p in the future\\n                // the key idea shows again, we always expect a right p will appear in the future char\\n                // that\\'s why for right p, we make it in needP variable, while for left p, we make it in putP variable\\n                    putP++;\\n                    needP = 1;\\n                }\\n\\n            }\\n        }\\n        return needP+putP;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int needP = 0, putP = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char p = s.charAt(i);\\n            if (p == \\'(\\') {\\n                // if we see a left p\\n                // expect 2 right p in the future string\\n                needP += 2;\\n                if (needP %2 == 1) {\\n                // needP must be even, because for a left p, it must come with 2 consecutive right p\\n                // so we should PUT a right P in this case\\n                // since we put a right p, we need one less right p\\n                    needP--;\\n                    putP++;\\n                }\\n            } else {\\n                // p == \\')\\', consume needRight if we still have it >0\\n                if(needP > 0) {\\n                    needP--;\\n                } else {\\n                // needP==0, but we see a right p here,\\n                // so we need a pair of ()\\n                // we firstly PUT a left p, and we expect a right p in the future\\n                // the key idea shows again, we always expect a right p will appear in the future char\\n                // that\\'s why for right p, we make it in needP variable, while for left p, we make it in putP variable\\n                    putP++;\\n                    needP = 1;\\n                }\\n\\n            }\\n        }\\n        return needP+putP;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590920,
                "title": "c-easy-approach-simple-if-else-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int c=0;\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && !st.empty())\\n            {\\n                st.pop();\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && st.empty())\\n            {\\n                c+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && (s[i+1]==\\'(\\' || i==s.size()-1))\\n            {\\n                if(st.empty()) c+=2;\\n                else\\n                {\\n                    st.pop();\\n                    c+=1;\\n                }\\n            }\\n        }\\n        if(!st.empty()) c+=2*st.size();\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int c=0;\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\') st.push(s[i]);\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && !st.empty())\\n            {\\n                st.pop();\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && s[i+1]==\\')\\' && st.empty())\\n            {\\n                c+=1;\\n                i++;\\n            }\\n            else if(s[i]==\\')\\' && (s[i+1]==\\'(\\' || i==s.size()-1))\\n            {\\n                if(st.empty()) c+=2;\\n                else\\n                {\\n                    st.pop();\\n                    c+=1;\\n                }\\n            }\\n        }\\n        if(!st.empty()) c+=2*st.size();\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568091,
                "title": "easy-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npush \"(\" unitl \"))\" found, then pop. if not able to pop according to rule increase the count.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            else{\\n                if(st.empty()){\\n                    if(i+1 < s.length() && s[i+1]==\\')\\')\\n                        {\\n                            count = count+1;\\n                            i = i+2;\\n                        }\\n                        else{\\n                            count = count+2;\\n                            i += 1;\\n                        }\\n                }\\n                else{\\n                    if(i+1 < s.length() && s[i+1] == \\')\\')\\n                        {\\n                            st.pop();\\n                            i += 2;\\n                        }\\n                    else{\\n                        st.pop();\\n                        count+=1;\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        for(int i = 0; i < s.length();){\\n            if(s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            else{\\n                if(st.empty()){\\n                    if(i+1 < s.length() && s[i+1]==\\')\\')\\n                        {\\n                            count = count+1;\\n                            i = i+2;\\n                        }\\n                        else{\\n                            count = count+2;\\n                            i += 1;\\n                        }\\n                }\\n                else{\\n                    if(i+1 < s.length() && s[i+1] == \\')\\')\\n                        {\\n                            st.pop();\\n                            i += 2;\\n                        }\\n                    else{\\n                        st.pop();\\n                        count+=1;\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            count+=2;\\n            st.pop();\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554070,
                "title": "simple-implementation-without-stack-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinInsertions(string s) {\\n        int openCount = 0;\\n        int minInsertion = 0;\\n        int n = s.Length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'(\\'){\\n                ++openCount;\\n                continue;\\n            }\\n\\n            if(openCount == 0)\\n                ++minInsertion;\\n            else\\n                --openCount;\\n\\n            if(i == n-1){\\n                ++minInsertion;\\n            }\\n            else{\\n                if(s[i+1] != \\')\\')\\n                    ++minInsertion;\\n                else\\n                    ++i;\\n            }  \\n        }\\n\\n        return minInsertion + (2 * openCount);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinInsertions(string s) {\\n        int openCount = 0;\\n        int minInsertion = 0;\\n        int n = s.Length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'(\\'){\\n                ++openCount;\\n                continue;\\n            }\\n\\n            if(openCount == 0)\\n                ++minInsertion;\\n            else\\n                --openCount;\\n\\n            if(i == n-1){\\n                ++minInsertion;\\n            }\\n            else{\\n                if(s[i+1] != \\')\\')\\n                    ++minInsertion;\\n                else\\n                    ++i;\\n            }  \\n        }\\n\\n        return minInsertion + (2 * openCount);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538705,
                "title": "easy-to-understand-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0,0\\n        for i in s:\\n            if i==\\'(\\':\\n                need+=2\\n                if need%2==1:\\n                    res+=1\\n                    need-=1\\n            if i == \\')\\':\\n                need-=1\\n                if need==-1:\\n                    res+=1\\n                    need=1\\n\\n        return res+need\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        res, need = 0,0\\n        for i in s:\\n            if i==\\'(\\':\\n                need+=2\\n                if need%2==1:\\n                    res+=1\\n                    need-=1\\n            if i == \\')\\':\\n                need-=1\\n                if need==-1:\\n                    res+=1\\n                    need=1\\n\\n        return res+need\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527872,
                "title": "java-simple-solution-greedy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int pCount = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s.charAt(i) == \\'(\\')\\n                pCount++;\\n            else {\\n                if(pCount > 0) {\\n                    pCount--;\\n                    if(i+1<n && s.charAt(i+1) == \\')\\')\\n                        i++;\\n                    else\\n                        ans++;\\n                }\\n                else {\\n                    ans++;\\n                    if(i+1>=n || s.charAt(i+1) != \\')\\')\\n                        ans++;\\n                    else\\n                        i++;\\n                }\\n            }\\n        }\\n        \\n        if(pCount > 0)\\n            ans += 2*pCount;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int pCount = 0;\\n        for(int i=0;i<n;i++) {\\n            if(s.charAt(i) == \\'(\\')\\n                pCount++;\\n            else {\\n                if(pCount > 0) {\\n                    pCount--;\\n                    if(i+1<n && s.charAt(i+1) == \\')\\')\\n                        i++;\\n                    else\\n                        ans++;\\n                }\\n                else {\\n                    ans++;\\n                    if(i+1>=n || s.charAt(i+1) != \\')\\')\\n                        ans++;\\n                    else\\n                        i++;\\n                }\\n            }\\n        }\\n        \\n        if(pCount > 0)\\n            ans += 2*pCount;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502132,
                "title": "one-pass-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n    Stack<Character>st=new Stack<>();\\n    int count=0;\\n    for(int i=0;i<s.length();){\\n    if(s.charAt(i)==\\')\\'&&st.isEmpty()){\\n        if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n            count+=1;\\n            i+=2;\\n        }\\n        else{\\n            count+=2;\\n            i+=1;\\n        }\\n    }\\n    else if(s.charAt(i)==\\'(\\'){\\n        st.add(s.charAt(i));\\n        i++;\\n    }\\n    else{\\n    if(i+1>=s.length()||s.charAt(i+1)!=\\')\\'){\\n            count+=1;\\n            if(i+1<s.length())i+=1;\\n            else \\n            {\\n            st.pop();\\n            break;\\n            }\\n    }\\n    else{\\n        i+=2;\\n    }\\n    st.pop();\\n    }\\n    \\n    }\\n\\n    count=count+(st.size()*2);\\n\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n    Stack<Character>st=new Stack<>();\\n    int count=0;\\n    for(int i=0;i<s.length();){\\n    if(s.charAt(i)==\\')\\'&&st.isEmpty()){\\n        if(i+1<s.length()&&s.charAt(i+1)==\\')\\'){\\n            count+=1;\\n            i+=2;\\n        }\\n        else{\\n            count+=2;\\n            i+=1;\\n        }\\n    }\\n    else if(s.charAt(i)==\\'(\\'){\\n        st.add(s.charAt(i));\\n        i++;\\n    }\\n    else{\\n    if(i+1>=s.length()||s.charAt(i+1)!=\\')\\'){\\n            count+=1;\\n            if(i+1<s.length())i+=1;\\n            else \\n            {\\n            st.pop();\\n            break;\\n            }\\n    }\\n    else{\\n        i+=2;\\n    }\\n    st.pop();\\n    }\\n    \\n    }\\n\\n    count=count+(st.size()*2);\\n\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496694,
                "title": "without-stack-c-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int a = 0;\\n        int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                a++;\\n            }\\n            else{\\n                if(a>0 && s[i]==\\')\\' && s[i+1]==\\')\\'){\\n                    a--;\\n                    i++;\\n                }\\n                else if(a>0 && s[i+1]!=\\')\\'){\\n                    ans++;\\n                    a--;\\n                }\\n                else if(a==0 && s[i+1]==\\')\\'){\\n                    i++;\\n                    ans++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return 2*a + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int a = 0;\\n        int ans = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                a++;\\n            }\\n            else{\\n                if(a>0 && s[i]==\\')\\' && s[i+1]==\\')\\'){\\n                    a--;\\n                    i++;\\n                }\\n                else if(a>0 && s[i+1]!=\\')\\'){\\n                    ans++;\\n                    a--;\\n                }\\n                else if(a==0 && s[i+1]==\\')\\'){\\n                    i++;\\n                    ans++;\\n                }\\n                else{\\n                    ans+=2;\\n                }\\n            }\\n        }\\n        return 2*a + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483963,
                "title": "no-need-of-stack-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n      int count=0;\\n\\tint ans=0;\\n\\t\\n\\t\\n\\tfor(int i=0; i< s.length(); i++) {\\n\\t\\t\\t\\n\\t\\tif(s.charAt(i)== \\'(\\') {  // if any opening brace is found, push it in the stack\\n\\t\\t\\tcount++; }\\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tif(i+1<s.length() && s.charAt(i+1) ==\\')\\') {\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans++;}\\n\\t                i++;}\\n\\t\\t\\t\\n\\t\\t\\telse {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\tans++; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans+=2;}    }}}\\n\\t\\t\\t\\n\\t\\n\\treturn ans+ count*2;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n\\n      int count=0;\\n\\tint ans=0;\\n\\t\\n\\t\\n\\tfor(int i=0; i< s.length(); i++) {\\n\\t\\t\\t\\n\\t\\tif(s.charAt(i)== \\'(\\') {  // if any opening brace is found, push it in the stack\\n\\t\\t\\tcount++; }\\n\\t\\t\\n\\t\\telse {\\n\\t\\t\\tif(i+1<s.length() && s.charAt(i+1) ==\\')\\') {\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans++;}\\n\\t                i++;}\\n\\t\\t\\t\\n\\t\\t\\telse {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(count>0) {\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t\\t\\tans++; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tans+=2;}    }}}\\n\\t\\t\\t\\n\\t\\n\\treturn ans+ count*2;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447656,
                "title": "c-stack-easy-o-n-o-n",
                "content": "# Intuition - Idea is every \\')\\' should be enclosed by \\'(\\' and \\')\\'\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach - \\n    1. Use a stack to store every \\'(\\'\\n    2. On \\')\\', initially consider no \\'(\\' and \\')\\' enclosing it, hence ops = 2, if there is \\'(\\' on top of stack, ops = 1 and also if there is \\')\\' after current char, ops = 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> st;\\n        int ans = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(s[i]);\\n            } else {\\n                // initially consider no \\'(\\' and \\')\\' enclosing a \\')\\', ops = 2\\n                int currInc = 2;\\n                if(i+1 < s.size() && s[i+1] == \\')\\') {\\n                    currInc--;\\n                    i++;\\n                }\\n                if(st.size() > 0 && st.top() == \\'(\\') {\\n                    st.pop(); currInc--;\\n                }\\n                ans += currInc;\\n            }\\n        }\\n\\n        return ans + 2 * st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> st;\\n        int ans = 0;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(s[i]);\\n            } else {\\n                // initially consider no \\'(\\' and \\')\\' enclosing a \\')\\', ops = 2\\n                int currInc = 2;\\n                if(i+1 < s.size() && s[i+1] == \\')\\') {\\n                    currInc--;\\n                    i++;\\n                }\\n                if(st.size() > 0 && st.top() == \\'(\\') {\\n                    st.pop(); currInc--;\\n                }\\n                ans += currInc;\\n            }\\n        }\\n\\n        return ans + 2 * st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422363,
                "title": "java-3-approaches",
                "content": "# Intuition\\nFirst I thought tocode like this but somewhere I was getting lost in handling \\')\\'.\\n\\n```class Solution {\\n    public int minInsertions(String s) {\\n        String s1 = s.replace(\"))\", \"}\");\\n        System.out.println(s1);\\n        \\n        Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0; i<s1.length(); i++){\\n            if(s1.charAt(i) == \\'}\\'){\\n                if(!stk.empty() && stk.peek() ==\\'(\\'){\\n                    stk.pop();\\n                }else{\\n                    stk.push(s1.charAt(i));\\n                }\\n            }else{\\n                stk.push(s1.charAt(i));\\n            }\\n        }\\n        System.out.println(stk);\\n        int count =0;\\n        while(!stk.empty()){\\n            System.out.println(stk.peek());\\n            if(stk.peek() == \\'(\\'){\\n                count += 2;\\n                stk.pop();\\n                System.out.println(count);\\n            }else if(stk.peek() == \\'}\\'){\\n                count +=1;\\n                stk.pop();\\n                System.out.println(count);\\n            }else{\\n                count --;\\n            }\\n            stk.pop();\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Approach\\n( -> ))\\na single opening bracket requires two closing brackets\\n\\n# Complexity\\n- Time complexity:O(n)\\n \\n# Code\\n\\n- <h5>Least efficient (using stack):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count =0;\\n        Stack<Character> stack = new Stack<>();\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(!stack.empty() && stack.peek() == \\'(\\'){\\n                    stack.pop();\\n                }else{\\n                    count ++;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    count ++;\\n                }\\n            }else{\\n                stack.push(ch);\\n            }\\n        }\\n        //System.out.print(stack);\\n        return count + stack.size()*2;        \\n    }\\n}\\n```\\n\\n- <h5>Better (using string):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }else{\\n                left++;\\n            }\\n        }\\n        return right + left*2;        \\n    }\\n}\\n```\\n\\n- <h5>Better (1ms difference by just exchanging if and else condition):</h5>\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```\\n\\n- <h5>Best (Using char array):</h5>\\n\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        char[] ch = s.toCharArray();\\n        for(int i =0; i<s.length(); i++){\\n            if(ch[i] == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && ch[i+1] == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "String",
                    "Stack"
                ],
                "code": "```class Solution {\\n    public int minInsertions(String s) {\\n        String s1 = s.replace(\"))\", \"}\");\\n        System.out.println(s1);\\n        \\n        Stack<Character> stk = new Stack<>();\\n\\n        for(int i=0; i<s1.length(); i++){\\n            if(s1.charAt(i) == \\'}\\'){\\n                if(!stk.empty() && stk.peek() ==\\'(\\'){\\n                    stk.pop();\\n                }else{\\n                    stk.push(s1.charAt(i));\\n                }\\n            }else{\\n                stk.push(s1.charAt(i));\\n            }\\n        }\\n        System.out.println(stk);\\n        int count =0;\\n        while(!stk.empty()){\\n            System.out.println(stk.peek());\\n            if(stk.peek() == \\'(\\'){\\n                count += 2;\\n                stk.pop();\\n                System.out.println(count);\\n            }else if(stk.peek() == \\'}\\'){\\n                count +=1;\\n                stk.pop();\\n                System.out.println(count);\\n            }else{\\n                count --;\\n            }\\n            stk.pop();\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int count =0;\\n        Stack<Character> stack = new Stack<>();\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(!stack.empty() && stack.peek() == \\'(\\'){\\n                    stack.pop();\\n                }else{\\n                    count ++;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    count ++;\\n                }\\n            }else{\\n                stack.push(ch);\\n            }\\n        }\\n        //System.out.print(stack);\\n        return count + stack.size()*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\')\\'){\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }else{\\n                left++;\\n            }\\n        }\\n        return right + left*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        for(int i =0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && s.charAt(i+1) == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int right =0;\\n        int left =0;\\n        char[] ch = s.toCharArray();\\n        for(int i =0; i<s.length(); i++){\\n            if(ch[i] == \\'(\\'){\\n                left++;\\n            }else{\\n                if(left ==0){\\n                    right++;\\n                }else{\\n                    left--;\\n                }\\n                if(i+1<s.length() && ch[i+1] == \\')\\'){\\n                    i++;\\n                }else{\\n                    right++;\\n                }\\n            }\\n        }\\n            \\n        return right + left*2;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385628,
                "title": "stack-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int i=0, n=s.size();\\n        stack<char> st;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(i+1>=n || s[i+1]!=\\')\\') ans++;\\n                else i++;\\n                if(!st.empty() && st.top()==\\'(\\') st.pop();\\n                else ans++;\\n            }\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        while(!st.empty())\\n        {\\n            if(st.top()==\\'(\\') ans+=2;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minInsertions(string s) \\n    {\\n        int i=0, n=s.size();\\n        stack<char> st;\\n        int ans=0;\\n        while(i<n)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(i+1>=n || s[i+1]!=\\')\\') ans++;\\n                else i++;\\n                if(!st.empty() && st.top()==\\'(\\') st.pop();\\n                else ans++;\\n            }\\n            else st.push(s[i]);\\n            i++;\\n        }\\n        while(!st.empty())\\n        {\\n            if(st.top()==\\'(\\') ans+=2;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380979,
                "title": "c-use-int-as-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int curStack = 0, ans = 0;\\n        for (int i = 0; i < s.size(); ++i)\\n            if (s[i] == \\'(\\') ++curStack;\\n            else {\\n                if (i == s.size() - 1 || s[i + 1] != \\')\\') ++ans;\\n                else ++i;\\n                if (--curStack == -1)\\n                    ++ans, curStack = 0;\\n            }\\n        return ans + curStack * 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int curStack = 0, ans = 0;\\n        for (int i = 0; i < s.size(); ++i)\\n            if (s[i] == \\'(\\') ++curStack;\\n            else {\\n                if (i == s.size() - 1 || s[i + 1] != \\')\\') ++ans;\\n                else ++i;\\n                if (--curStack == -1)\\n                    ++ans, curStack = 0;\\n            }\\n        return ans + curStack * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356684,
                "title": "ok",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nint minInsertions(string s) \\n{\\n\\tint out{}, n{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t++n;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti+1==size(s) or s[i+1]!=\\')\\' ? ++out : ++i;\\n\\t\\t\\tn ? --n : ++out;\\n\\t\\t}\\n\\treturn out+2*n;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minInsertions(string s) \\n{\\n\\tint out{}, n{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\t++n;\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti+1==size(s) or s[i+1]!=\\')\\' ? ++out : ++i;\\n\\t\\t\\tn ? --n : ++out;\\n\\t\\t}\\n\\treturn out+2*n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356058,
                "title": "i-ruby",
                "content": "```ruby\\ndef min_insertions s\\n    o, c = 0, 0\\n    s.gsub /\\\\(+|\\\\)+/ do\\n        z = _1.size\\n        _1[?(] ? o += z : begin\\n            c += 1 if z.odd?\\n            o -= z.succ / 2\\n            c, o = c - o, 0 if o < 0\\n        end\\n    end\\n    o * 2 + c\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_insertions s\\n    o, c = 0, 0\\n    s.gsub /\\\\(+|\\\\)+/ do\\n        z = _1.size\\n        _1[?(] ? o += z : begin\\n            c += 1 if z.odd?\\n            o -= z.succ / 2\\n            c, o = c - o, 0 if o < 0\\n        end\\n    end\\n    o * 2 + c\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3313348,
                "title": "java-simple-solution-beginners-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int invalidCount = 0, stack = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                stack++;\\n            }\\n            else{\\n                if(i+1 == s.length() || s.charAt(i + 1) != \\')\\'){\\n                    invalidCount++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(stack == 0){\\n                    invalidCount++;\\n                }\\n                else{\\n                    stack--;\\n                }\\n            }\\n        }\\n        return invalidCount + 2 * stack;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int invalidCount = 0, stack = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                stack++;\\n            }\\n            else{\\n                if(i+1 == s.length() || s.charAt(i + 1) != \\')\\'){\\n                    invalidCount++;\\n                }\\n                else{\\n                    i++;\\n                }\\n                if(stack == 0){\\n                    invalidCount++;\\n                }\\n                else{\\n                    stack--;\\n                }\\n            }\\n        }\\n        return invalidCount + 2 * stack;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295878,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n         int c=0;\\n         int cp=0;\\n         for(int i=0;i<s.length();++i)\\n         {\\n             if(s[i]==\\'(\\')\\n             {\\n                 ++c;\\n             }\\n             else\\n             {\\n                 if(i+1<s.length())\\n                 {\\n                     if(s[i+1]==\\')\\')\\n                     {\\n                         if(c>0)\\n                         {\\n                             --c;\\n                             ++i;\\n                         }\\n                         else\\n                         {\\n                             cp+=1;\\n                             ++i;\\n                         }\\n                     }\\n                     else\\n                     {\\n                         if(c>0)\\n                         {\\n                             --c;\\n                              cp+=1;\\n                         }\\n                         else\\n                         {\\n                             cp+=2;\\n                         }\\n                     }\\n                 }\\n                 else\\n                 {\\n                     if(c>0)\\n                     {\\n                         cp+=1;\\n                         --c;\\n                     }\\n                     else\\n                     {\\n                         cp+=2;\\n                     }\\n                 }\\n             }\\n         }\\n        while(c>0)\\n        {\\n            cp+=2;\\n            --c;\\n        }\\n        return cp;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n         int c=0;\\n         int cp=0;\\n         for(int i=0;i<s.length();++i)\\n         {\\n             if(s[i]==\\'(\\')\\n             {\\n                 ++c;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3289051,
                "title": "python-one-pass-solution-time-o-n-and-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        count = 0\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\" and count % 2 == 0):\\n                count += 2\\n            elif((ch == \"(\" and count % 2 == 1) or (ch == \")\" and count == 0)):\\n                count += 1\\n                insertion_count += 1\\n            else:\\n                count -= 1\\n\\n        return insertion_count + count           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        count = 0\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\" and count % 2 == 0):\\n                count += 2\\n            elif((ch == \"(\" and count % 2 == 1) or (ch == \")\" and count == 0)):\\n                count += 1\\n                insertion_count += 1\\n            else:\\n                count -= 1\\n\\n        return insertion_count + count           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288675,
                "title": "single-pass-with-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n      int ans = 0;\\n      int ctn = 0;\\n      for (char ch: s.toCharArray()) {\\n        if (ch == \\'(\\' && ctn % 2 == 0) ctn += 2;\\n        else if ((ch == \\'(\\' && ctn % 2 == 1) || (ch == \\')\\' && ctn == 0)) {\\n          ctn++;\\n          ans++;\\n        }\\n        else ctn--;\\n      }\\n      return ans + ctn;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n      int ans = 0;\\n      int ctn = 0;\\n      for (char ch: s.toCharArray()) {\\n        if (ch == \\'(\\' && ctn % 2 == 0) ctn += 2;\\n        else if ((ch == \\'(\\' && ctn % 2 == 1) || (ch == \\')\\' && ctn == 0)) {\\n          ctn++;\\n          ans++;\\n        }\\n        else ctn--;\\n      }\\n      return ans + ctn;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288583,
                "title": "o-n-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = deque()\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\"):\\n                if(stack and stack[-1] != \"(\"):\\n                    insertion_count += 1\\n                    stack.pop()\\n                    stack.pop()\\n                stack.append(ch)\\n            else:\\n                if(not stack):\\n                    insertion_count += 1\\n                    stack.append(\"(\")\\n                    stack.append(ch)\\n                else:\\n                    if(stack[-1] == \"(\"):\\n                        stack.append(ch)\\n                    else:\\n                        stack.pop()\\n                        stack.pop()\\n\\n        while(stack):\\n            if(stack[-1] == \"(\"):\\n                insertion_count += 2\\n                stack.pop()\\n            else:\\n                insertion_count += 1\\n                stack.pop()\\n                stack.pop()\\n\\n        return insertion_count\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        stack = deque()\\n        insertion_count = 0\\n\\n        for ch in s:\\n            if(ch == \"(\"):\\n                if(stack and stack[-1] != \"(\"):\\n                    insertion_count += 1\\n                    stack.pop()\\n                    stack.pop()\\n                stack.append(ch)\\n            else:\\n                if(not stack):\\n                    insertion_count += 1\\n                    stack.append(\"(\")\\n                    stack.append(ch)\\n                else:\\n                    if(stack[-1] == \"(\"):\\n                        stack.append(ch)\\n                    else:\\n                        stack.pop()\\n                        stack.pop()\\n\\n        while(stack):\\n            if(stack[-1] == \"(\"):\\n                insertion_count += 2\\n                stack.pop()\\n            else:\\n                insertion_count += 1\\n                stack.pop()\\n                stack.pop()\\n\\n        return insertion_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214154,
                "title": "c",
                "content": "```\\nint minInsertions(char * s){\\n    int n = strlen(s) ;\\n    int left = 0 ;\\n    int ret = 0 ;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'(\\'){\\n            left++ ;\\n        }\\n        else{\\n            if((i+1) < n && s[i+1] == \\')\\'){\\n                if(left == 0)\\n                    ret++ ;\\n                else\\n                    left-- ;\\n                i++ ;\\n            }\\n            else{\\n                if(left == 0)\\n                    ret += 2 ;\\n                else{\\n                    ret++ ;\\n                    left-- ;\\n                }\\n            }            \\n        }\\n    }\\n \\n    ret += left*2 ;\\n    \\n    return ret ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minInsertions(char * s){\\n    int n = strlen(s) ;\\n    int left = 0 ;\\n    int ret = 0 ;\\n    for(int i = 0; i < n; i++){\\n        if(s[i] == \\'(\\'){\\n            left++ ;\\n        }\\n        else{\\n            if((i+1) < n && s[i+1] == \\')\\'){\\n                if(left == 0)\\n                    ret++ ;\\n                else\\n                    left-- ;\\n                i++ ;\\n            }\\n            else{\\n                if(left == 0)\\n                    ret += 2 ;\\n                else{\\n                    ret++ ;\\n                    left-- ;\\n                }\\n            }            \\n        }\\n    }\\n \\n    ret += left*2 ;\\n    \\n    return ret ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212415,
                "title": "easy-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        int l=0;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                l++;\\n                continue;\\n            }\\n            if(i<n-1 && s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(l>0)\\n                l--;\\n                else\\n                cnt++;\\n                i++;\\n                continue;\\n            }\\n            else\\n            {\\n                if(l>0)\\n                {\\n                    cnt++;\\n                    l--;\\n                }\\n                else\\n                cnt+=2;\\n            }\\n        }\\n        return cnt+(2*l);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        int l=0;\\n        int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                l++;\\n                continue;\\n            }\\n            if(i<n-1 && s[i]==\\')\\' && s[i+1]==\\')\\')\\n            {\\n                if(l>0)\\n                l--;\\n                else\\n                cnt++;\\n                i++;\\n                continue;\\n            }\\n            else\\n            {\\n                if(l>0)\\n                {\\n                    cnt++;\\n                    l--;\\n                }\\n                else\\n                cnt+=2;\\n            }\\n        }\\n        return cnt+(2*l);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3212043,
                "title": "easy-to-understand-solution-in-java-using-greedy-approach-with-stack",
                "content": "\\n# Approach\\ndeclare two variables res(extra characters added) and stack(to keep track of open paranteses)\\nif we encounter a ( just add it to the stack.\\nif you encounter a )\\n\\n\\nthen check the character after that there are three cases possible.\\n1. )  -two cases possible\\n    1.  empty stack first add a opening bracket  \\n    2. filled stack just reduce the stack by 1\\n2. (  -two cases possible\\n    1. empty stack add opening first then closing \\n    2. add only closing and increase the stack by one\\n3. string get out of bounds- two cases possible similar to one just add extra )\\n    1.  empty stack first add a opening bracket  \\n    2. filled stack just reduce the stack by 1\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int res=0;\\n        int stack=0;\\n        int n =s.length();\\n        int i=0;\\n        while(i<n)\\n        {    char c = s.charAt(i);\\n\\n            if(c==\\'(\\')\\n            {\\n                stack++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(i<n-1 && s.charAt(i+1)==\\')\\')\\n                {\\n                    if(stack>0)\\n                    {\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        stack--;\\n                    }\\n                }\\n                else if(i<n-1 && s.charAt(i+1)==\\'(\\')\\n                {\\n                    if(stack>0)\\n                    {\\n\\n                        res++;\\n                        stack--;\\n                        // adding \\'(\\' to stack\\n                        stack++;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        res++;\\n                        stack++;\\n                        stack--;\\n                        stack++;\\n                        \\n                    }\\n                \\n                }\\n                else \\n                {\\n                    if(stack>0)\\n                    {\\n                        res++;\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        // since no second character is present adding one more \\')\\'\\n                        res++;\\n                        stack--;\\n                    }\\n                }\\n                i=i+2;\\n               \\n            }\\n           \\n        }\\n         return 2*stack+res;\\n    }\\n}\\n```\\n\\nSimilar Question:\\n \\nhttps://leetcode.com/problems/minimum-add-to-make-parentheses-valid/solutions/3207628/easy-to-understand-solution-in-java-using-stacks-and-greedy-approach/?orderBy=hot",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int res=0;\\n        int stack=0;\\n        int n =s.length();\\n        int i=0;\\n        while(i<n)\\n        {    char c = s.charAt(i);\\n\\n            if(c==\\'(\\')\\n            {\\n                stack++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(i<n-1 && s.charAt(i+1)==\\')\\')\\n                {\\n                    if(stack>0)\\n                    {\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        stack--;\\n                    }\\n                }\\n                else if(i<n-1 && s.charAt(i+1)==\\'(\\')\\n                {\\n                    if(stack>0)\\n                    {\\n\\n                        res++;\\n                        stack--;\\n                        // adding \\'(\\' to stack\\n                        stack++;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        res++;\\n                        stack++;\\n                        stack--;\\n                        stack++;\\n                        \\n                    }\\n                \\n                }\\n                else \\n                {\\n                    if(stack>0)\\n                    {\\n                        res++;\\n                        stack--;\\n                    }\\n                    else\\n                    {\\n                        // since no opening present add one \\n                        res++;\\n                        stack++;\\n                        // since the second digit is \\')\\' hence we will consume one opening bracket\\n                        // since no second character is present adding one more \\')\\'\\n                        res++;\\n                        stack--;\\n                    }\\n                }\\n                i=i+2;\\n               \\n            }\\n           \\n        }\\n         return 2*stack+res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168450,
                "title": "stack-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//stack : )(\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n         if(s[i]==\\'(\\')\\n         {\\n             if(st.empty())\\n             {\\n                 st.push(s[i]);\\n             }\\n             else{\\n                 if(st.top()==\\'(\\')\\n                 {\\n                     st.push(s[i]);\\n                 }\\n                 else{\\n                    count++;\\n                    st.pop();\\n                    st.pop();\\n                    st.push(s[i]);\\n                 }\\n             }\\n         }\\n         else{\\n             if(st.empty())\\n             {  \\n                 count++;\\n                 st.push(\\'(\\');\\n                 st.push(s[i]);\\n             }\\n             else\\n             {\\n                 if(st.top()==\\'(\\'){\\n               st.push(s[i]);\\n                 }\\n                 else{\\n                   st.pop();\\n                   st.pop();\\n                 }\\n             }\\n         }\\n        }\\n\\n        if(st.empty())return count;\\n        else {\\n            while(!st.empty()){\\n                char temp=st.top();\\n                st.pop();\\n                if(temp==\\'(\\')\\n                {\\n                    count=count+2;\\n                  \\n                }\\n                else{\\n                    count++;\\n                    st.pop();\\n                }\\n            }\\n            return count;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//stack : )(\\n    int minInsertions(string s) {\\n        stack<char>st;\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n         if(s[i]==\\'(\\')\\n         {\\n             if(st.empty())\\n             {\\n                 st.push(s[i]);\\n             }\\n             else{\\n                 if(st.top()==\\'(\\')\\n                 {\\n                     st.push(s[i]);\\n                 }\\n                 else{\\n                    count++;\\n                    st.pop();\\n                    st.pop();\\n                    st.push(s[i]);\\n                 }\\n             }\\n         }\\n         else{\\n             if(st.empty())\\n             {  \\n                 count++;\\n                 st.push(\\'(\\');\\n                 st.push(s[i]);\\n             }\\n             else\\n             {\\n                 if(st.top()==\\'(\\'){\\n               st.push(s[i]);\\n                 }\\n                 else{\\n                   st.pop();\\n                   st.pop();\\n                 }\\n             }\\n         }\\n        }\\n\\n        if(st.empty())return count;\\n        else {\\n            while(!st.empty()){\\n                char temp=st.top();\\n                st.pop();\\n                if(temp==\\'(\\')\\n                {\\n                    count=count+2;\\n                  \\n                }\\n                else{\\n                    count++;\\n                    st.pop();\\n                }\\n            }\\n            return count;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167287,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_insertions(s: String) -> i32 {\\n        let (mut res, mut right) = (0, 0);\\n        let s = s.as_bytes();\\n        for &c in s.iter() {\\n            if c == b\\'(\\' {\\n                if right % 2 > 0 {\\n                    right -= 1;\\n                    res += 1;\\n                }\\n                right += 2;\\n            } else {\\n                right -= 1;\\n                if right < 0 {\\n                    right += 2;\\n                    res += 1;\\n                }\\n            }\\n        }\\n        right + res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_insertions(s: String) -> i32 {\\n        let (mut res, mut right) = (0, 0);\\n        let s = s.as_bytes();\\n        for &c in s.iter() {\\n            if c == b\\'(\\' {\\n                if right % 2 > 0 {\\n                    right -= 1;\\n                    res += 1;\\n                }\\n                right += 2;\\n            } else {\\n                right -= 1;\\n                if right < 0 {\\n                    right += 2;\\n                    res += 1;\\n                }\\n            }\\n        }\\n        right + res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164406,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s1=s+\"1\"\\n        i=0\\n        l=[]\\n        count=0\\n        while(i<len(s1)):\\n            if(s1[i]==\\'(\\'):\\n                l.append(s[i])\\n            else:\\n                if(s1[i]==\")\" and s1[i+1]==\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                    else:\\n                        count+=1\\n                    i+=1\\n                elif(s1[i]==\\')\\' and s1[i+1]!=\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                        count+=1\\n                    else:\\n                        count+=2\\n            i+=1\\n        if(len(l)!=0):\\n            count+=2*len(l)\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        s1=s+\"1\"\\n        i=0\\n        l=[]\\n        count=0\\n        while(i<len(s1)):\\n            if(s1[i]==\\'(\\'):\\n                l.append(s[i])\\n            else:\\n                if(s1[i]==\")\" and s1[i+1]==\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                    else:\\n                        count+=1\\n                    i+=1\\n                elif(s1[i]==\\')\\' and s1[i+1]!=\")\"):\\n                    if(len(l)!=0):\\n                        l.pop()\\n                        count+=1\\n                    else:\\n                        count+=2\\n            i+=1\\n        if(len(l)!=0):\\n            count+=2*len(l)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161626,
                "title": "o-n-c-solution-without-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to question 921\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWalk through every parantheses in input string and use two variable **insertion** and **right_need** to record the status of parantheses need.\\n- **Insertion** record the number of insertion activities needed before current char\\n- **right_need** record the number of right parantheses need\\n***\\n\\n## Cases\\n1. If current char is \\'(\\'\\n    * We need two more right parantheses: \\n        * right_need +=2\\n    * If current right_need is odd, the pattern is invalid. Thus, we need to insert one \\')\\' \\n        * insertion++, right_need--\\n2. If current char is \\')\\'\\n    * The right paranthesis we need would minus one \\n    * If the right_need is -1, it means there is a extra right paranthesis. To match the pattern \\'())\\', we insert one left paranthesis and need one more right paranthesis.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int insertion=0;\\n        int right_need=0;\\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                right_need+=2;\\n                if(right_need%2==1){\\n                    insertion++;\\n                    right_need--;\\n                }\\n            }\\n            else if(c==\\')\\'){\\n                right_need--;\\n                if(right_need==-1){\\n                    right_need=1;\\n                    insertion++;\\n                }\\n\\n            }\\n        }\\n        return insertion+right_need;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int insertion=0;\\n        int right_need=0;\\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                right_need+=2;\\n                if(right_need%2==1){\\n                    insertion++;\\n                    right_need--;\\n                }\\n            }\\n            else if(c==\\')\\'){\\n                right_need--;\\n                if(right_need==-1){\\n                    right_need=1;\\n                    insertion++;\\n                }\\n\\n            }\\n        }\\n        return insertion+right_need;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564804,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1570807,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1576499,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1574183,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1568412,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1870978,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2055662,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2025105,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783148,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1662228,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1564804,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1570807,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1576499,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1574183,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1568412,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1870978,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2055662,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2025105,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783148,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1662228,
                "content": [
                    {
                        "username": "chrisTris",
                        "content": "For test case \"(()))(()))()())))\" expected is 4\\nbut consider steps\\n(()))(()))()()))) => Removing all ()) => ()()()))\\n()()())) => Removing ()) => ()())\\n()()) => Removing ()) => ()\\n() => insert ) => ()) => \"\""
                    },
                    {
                        "username": "akshay303",
                        "content": "Same encountered issue my ans is 1 but expected is 4\\nAre we missing something ?"
                    },
                    {
                        "username": "Kublai",
                        "content": "A bit confused about the question.\\n\\nFor test case \"(()))(()))()())))\" why is the answer 4, not 1 ? \\n\\nIt seems to me that I can insert \\')\\' to the end and make it balanced. That is: \"(()))(()))()())))\" + \\')\\' = \"(()))(()))()()))))\"\\n\\nwhich will satisfy the two criterions:\\n\\n1. Any left parenthesis \\'(\\' must have a corresponding two consecutive right parenthesis \\'))\\'.\\n\\n2. Left parenthesis \\'(\\' must go before the corresponding two consecutive right parenthesis \\'))\\'.\\n\\n================================\\n\\n\"(()))(()))()**())**)))\"\\n-> \\n\"(()))(()))**())**))\"\\n->\\n\"(()))(**())**)))\"\\n->\\n\"(()))**())**)\"\\n->\\n\"(**())**))\"\\n->\\n\"**())**\"\\n->\\n\"\"\\n-> balanced\\n\\n"
                    },
                    {
                        "username": "shivi127",
                        "content": "\\n\"(()))(()))()())))\""
                    },
                    {
                        "username": "Bakushin",
                        "content": "The answer for \"(()))(()))()())))\" is 4. but my answr is 1 and it seems right to me.\\nI can eventually break this down to \"()\" and the answer should be 1.\\n\\nthe question is poorly worded, so I know I am missing some stuff. Can you please tell me why the answer is 4 ? \\n"
                    },
                    {
                        "username": "Blackdot_11",
                        "content": "\"(()))(()))()())))\"\\nThanks in advance"
                    },
                    {
                        "username": "srk696772",
                        "content": "Read This Statement Carefully Before Solving it .\\n\" corresponding two  **CONSECUTIVE** right parenthesis \" \\n For  This Testcase  \"(()))(()))()())))\" answer is 4 ."
                    },
                    {
                        "username": "FransV",
                        "content": "Thank you!"
                    },
                    {
                        "username": "sufiyan052",
                        "content": "Basically we need to make balance parenthesis if and only if left braces ( meets to it\\'s double closing braces ).\\n\\n# Approach\\nIf two closing braces came together then pop it from stack.\\n1- Take a counter, initially it is zero.\\n2- if \\'(\\' this came then insert in stack.\\n3- if \\')\\' came then check if next of current is closing if this is the case then skip it otherwise increase count.\\n4- check if stack isEmpty, Yes then increase count otherwise pop brackets.\\n5- return 2 * stack.size()"
                    },
                    {
                        "username": "jeffabc1997",
                        "content": "\"()()))\" expected outcome is 3 instead of 0. Why?\\nI think I understand this problem in a wrong way"
                    },
                    {
                        "username": "gaurav111",
                        "content": "Can someone please explain the logic for below inputs:\\n1 Input s = \"((()()))\"  Expected Output = 4\\n2 Input s = \"(()))()))\" Expected Output = 3\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        stack<char> pstack;\\n        const char * p = s.c_str();\\n        int res = 0;\\n        while(*p != \\'\\\\0\\') {\\n            //cout <<\" current ch \" << *p << endl;\\n            const char ch = *p;\\n            if(ch == \\'(\\') {\\n                pstack.push(ch);\\n                ++p;\\n            } else {\\n                if( *(p+1) != \\'\\\\0\\' && *(p+1) == \\')\\') {\\n                    // found \"))\", see if there\\'s march in the stack\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                    } else {\\n                        res += 1;\\n                    }\\n                    p += 2;\\n                } else if(*(p+1) != \\'\\\\0\\' && *(p+1) == \\'(\\') {\\n                    // only one ), need aonther one to march\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        // only has \\')\\' and no \\'(\\' in statck, need two more to be balanced\\n                        res += 2;\\n                    }\\n                    ++p;\\n                } else {\\n                    // p is \\')\\' *(p+1) is \\'\\\\0\\'\\n                    if(!pstack.empty()) {\\n                        pstack.pop();\\n                        res += 1;\\n                    } else {\\n                        res += 2;\\n                    }\\n                    //cout << \" else ch \" << ch << \" next ch \" << *(p+1) <<endl;\\n                    ++p;\\n                }\\n            }\\n        }\\n\\n        while(!pstack.empty()){\\n            res += 2;\\n            pstack.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Longest Awesome Substring",
        "question_content": "<p>You are given a string <code>s</code>. An <strong>awesome</strong> substring is a non-empty substring of <code>s</code> such that we can make any number of swaps in order to make it a palindrome.</p>\n\n<p>Return <em>the length of the maximum length <strong>awesome substring</strong> of</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3242415&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> &quot;24241&quot; is the longest awesome substring, we can form the palindrome &quot;24142&quot; with some swaps.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;12345678&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;213123&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> &quot;213123&quot; is the longest awesome substring, we can form the palindrome &quot;231132&quot; with some swaps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 779893,
                "title": "c-java-python3-with-picture-similar-to-1371",
                "content": "#### Intuition\\nThis is similar to [1371. Find the Longest Substring Containing Vowels in Even Counts](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534135/C%2B%2BJava-with-picture).\\n\\nWe can form a palindrome if the count of each included number (expcept maybe one) is even, and this is the property of an awesome string.\\n\\nA bit in our `mask` is `0` if the count for the corresponding number is even, and `1` if it\\'s odd.  As we go through the string, we track odd/even counts in our mask. If we see the same `mask` again, the subarray between first poistion (exclusive) and the current position (inclusive) with the same `mask` has all numbers with the even count. \\n\\nWe will use the `dp` array to track the smallest (first) position of each `mask`. We can get the size of the substring by substracting it from the current poisition. \\n\\n> Note that position for zero mask is `-1`, as we need to include the very first character.\\n\\nNow, the difference from #1371 is that a palindrome can have up to one number with the odd count. Therefore, we need to also check all masks that are different from the current one by one bit. In other words, if two masks are different by one bit, that means that there is one odd count in the substring.\\n\\n![image](https://assets.leetcode.com/users/images/4fb7c48e-699d-4303-ade3-52300e87abf6_1596907985.4008424.png)\\n\\n**C++**\\n```cpp\\nint longestAwesome(string s) {\\n    vector<int> dp(1024, s.size());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        mask ^= 1 << (s[i] - \\'0\\');\\n        res = max(res, i - dp[mask]);\\n        for (auto j = 0; j <= 9; ++j)\\n            res = max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = min(dp[mask], i);\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int longestAwesome(String s) {\\n    int dp[] = new int[1024];\\n    Arrays.fill(dp, s.length());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (int i = 0; i < s.length(); ++i) {\\n        mask ^= 1 << (s.charAt(i) - \\'0\\');\\n        res = Math.max(res, i - dp[mask]);\\n        for (int j = 0; j <= 9; ++j)\\n            res = Math.max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = Math.min(dp[mask], i);\\n    }\\n    return res;\\n}\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        mask, res = 0, 0\\n        dp = [-1] + [len(s)] * 1023\\n        for i in range(len(s)):\\n            mask ^= 1 << (ord(s[i]) - 48)\\n            for j in range(11):\\n                check_mask = 1023 & (mask ^ (1 << j))\\n                res = max(res, i - dp[check_mask])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```\\n\\n#### Complexity Analysis\\n- Time: O(nk), where k is the number of unique characters we track. We go through the string once, and do k checks for each character.\\n- Memory: O(2^ k), where k is the number of unique characters to track.",
                "solutionTags": [],
                "code": "```cpp\\nint longestAwesome(string s) {\\n    vector<int> dp(1024, s.size());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        mask ^= 1 << (s[i] - \\'0\\');\\n        res = max(res, i - dp[mask]);\\n        for (auto j = 0; j <= 9; ++j)\\n            res = max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = min(dp[mask], i);\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int longestAwesome(String s) {\\n    int dp[] = new int[1024];\\n    Arrays.fill(dp, s.length());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (int i = 0; i < s.length(); ++i) {\\n        mask ^= 1 << (s.charAt(i) - \\'0\\');\\n        res = Math.max(res, i - dp[mask]);\\n        for (int j = 0; j <= 9; ++j)\\n            res = Math.max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = Math.min(dp[mask], i);\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        mask, res = 0, 0\\n        dp = [-1] + [len(s)] * 1023\\n        for i in range(len(s)):\\n            mask ^= 1 << (ord(s[i]) - 48)\\n            for j in range(11):\\n                check_mask = 1023 & (mask ^ (1 << j))\\n                res = max(res, i - dp[check_mask])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785213,
                "title": "example-input-3242415-explanation-with-bitmask",
                "content": "**Definition of Awesomeness**\\nString S is a palindrome if S equals to its reversed version: \"1112111\"\\nAny string is awesome if we can reorder its characters to make it a palindrome: \\n\"24241\" can be reordered to \"24142\".\\n\\n**Properties of Awesome string**\\nThere are 2 cases that a string can be reordered to be a palindrome:\\n**Case 1**. All of its characters have even occurrences: \\n\\t\\t\"2424\" -> there are two \\'2\\'s and two \\'4\\'s.\\n**Case 2**. All of its characters have even occurrences except one: \\n\\t\\t\"24241\" -> there are two \\'2\\'s, two \\'4\\'s and one \\'1\\'\\n\\t\\t\\n**Brute force solution**\\nThe most straighforward solution would be keeping track of all counters while looping through characters. Once we are at position i, we go back and subtract all our previous counters from our current counter to check if any of them is awesome. However, its time complexity is O(10*N^2): 10 digits * N chars * N comparisons which is not desirable\\n\\n**BitMask solution**\\nWe don\\'t have to keep track of counters, we are only interested in odd counts in a substring. We can use one bit to say if some digit has even or odd count at any point.\\nLet 0 represent \"even\" and 1 represent \"odd\". \\nFor example, for an input of \"233\":\\n1. i = 0, char = \\'2\\', xor 2nd bit from right:\\n\\tmask = \"100\"\\n2. i = 1, char = \\'3\\', xor 3rd bit from right:\\n\\tmask = \"1100\"\\n3. i = 2, char = \\'3\\', xor 3rd bit from right:\\n\\tmask = \"0100\"\\n\\t\\nThe last mask is \"0100\" which says it has only one number with odd count, so, the input can be rearranged to make it a palindrome: \"233\" => \"323\".\\n\\nEven simpler, if the input is \"22\", we set and unset 2nd bit, then the remaining mask would be \"000\", which says we have numbers with all having even counts.\\n\\nNow, let\\'s analyze the example input \"3242415\" from problem definition.\\n1. i = 0, char = \\'3\\', xor 3rd bit from right:\\n\\n\\t\\tmask = \\'0000001000\\'\\n2. i = 1, char = \\'2\\', xor 2nd bit from right:\\n\\t\\n\\t\\tmask = \\'0000001100\\'\\n3. i = 2, char = \\'4\\', xor 4th bit from right:\\n    \\n\\t\\tmask = \\'0000011100\\'\\n4. i = 3, char = \\'2\\', xor 2nd bit from right:\\n\\t\\n\\t\\tmask = \\'0000011000\\'\\n5. i = 4, char = \\'4\\', xor 4th bit from right:\\n\\t\\n\\t\\tmask = \\'0000001000\\'\\n6. i = 5, char = \\'1\\', xor 1st bit from right:\\n\\t\\n\\t\\tmask = \\'0000001010\\'\\n7. i = 6, char = \\'5\\', xor 5th bit from right:\\n\\t\\n\\t\\tmask = \\'0000101010\\'\\n\\t\\nThe problem asks to find the longest awesome substring, it can be anywhere between i and j such that i <= j <= lenth of input. For this, on every step above, we need to memoize the current mask and check if we have seen similar mask before.\\nUpdate the answer if:\\n\\t\\ta. We have seen similar mask before.\\n\\t\\tb. We have seen a mask such that it differs from the current mask by one bit being different.\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        ans, mask = 0, 0\\n        \\n        memo = [n] * 1024\\n        memo[0] = -1\\n        \\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n\\t\\t\\t\\n\\t\\t\\t# Case 1. Check if we have seen similar mask\\n            ans = max(ans, i - memo[mask])\\n            \\n\\t\\t\\t# Case 2. Check for masks that differ by one bit\\n            for j in range(10):\\n                test_mask = mask ^ (1 << j)\\n                ans = max(ans, i - memo[test_mask])\\n                \\n\\t\\t\\t# save the earliest position\\n            memo[mask] = min(memo[mask], i)    \\n        \\n        return ans\\n```\\nThere are number of questions arise from the above solution:\\n**Question 1. Why 1024?**\\nSince the input only contains 10 digits (\"0123456789\"), we can only see 2^10 or 1024 variations of bit masks: 0000000000, 0000000001, .... , 1111111110, 1111111111\\n**Question 2. What is 1 << int(s[i])**\\nIt shifts 1 by s[i] times, for ex: 1 << 3 gives us \\'1000\\'.\\nAnd it updates the current mask: 0000 ^ 1000 = 1000 or 1110 ^ 1000 = 0110 \\nIf you didn\\'t get it, please, read bit operations in depth.\\n**Question 3. What is the test mask**\\nThe test mask in above solution alters one of the bits of the current mask to check for Case 2.\\n**Question 4. Why do we check for similar masks?**\\nThat means between the similar mask and the current mask, we have seen such digits that xored themselves along the way and disappeared from the mask. Only if the number of digits is even, they can disappear from the current mask: for ex: \"223\", the current mask evolution is: \"100\" -> \"000\" -> \"1000\". \\n**Question 5. Why do we check for masks that differ by one bit?**\\nSince it is allowed to have one number with odd count, we can check for masks that differ by one bit from the current mask.\\n\\nI think, you got this, let me know if you have any other questions.\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        ans, mask = 0, 0\\n        \\n        memo = [n] * 1024\\n        memo[0] = -1\\n        \\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n\\t\\t\\t\\n\\t\\t\\t# Case 1. Check if we have seen similar mask\\n            ans = max(ans, i - memo[mask])\\n            \\n\\t\\t\\t# Case 2. Check for masks that differ by one bit\\n            for j in range(10):\\n                test_mask = mask ^ (1 << j)\\n                ans = max(ans, i - memo[test_mask])\\n                \\n\\t\\t\\t# save the earliest position\\n            memo[mask] = min(memo[mask], i)    \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779919,
                "title": "java-c-python-prefix-bitmask",
                "content": "## **Intuition**\\nSimilar to [1371. Find the Longest Substring Containing Vowels in Even Counts](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531840/JavaC++Python-One-Pass).\\n<br>\\n\\n## **Explanation**\\nWe have 10 + 1 types of palindromes.\\nUse any number as the middle character, or don\\'t have a middle character.\\n<br>\\n\\n## **Complexity**\\nTime `O(10N)`\\nSpace `O(1024)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int longestAwesome(String s) {\\n        int res = 0, cur = 0, n = s.length(), seen[] = new int[1024];\\n        Arrays.fill(seen, n);\\n        seen[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (s.charAt(i) - \\'0\\');\\n            for (int a = 0; a < 10; ++a)\\n                res = Math.max(res, i - seen[cur ^ (1 << a)]);\\n            res = Math.max(res, i - seen[cur]);\\n            seen[cur] = Math.min(seen[cur], i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int longestAwesome(string s) {\\n        int res = 0, cur = 0, n = s.size();\\n        vector<int> seen(1024, n);\\n        seen[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (s[i] - \\'0\\');\\n            for (int a = 0; a < 10; ++a)\\n                res = max(res, i - seen[cur ^ (1 << a)]);\\n            res = max(res, i - seen[cur]);\\n            seen[cur] = min(seen[cur], i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def longestAwesome(self, s):\\n        res, cur, n = 0, 0, len(s)\\n        seen = [-1] + [n] * 1024\\n        for i, c in enumerate(s):\\n            cur ^= 1 << int(c)\\n            for a in xrange(10):\\n                res = max(res, i - seen[cur ^ (1 << a)])\\n            res = max(res, i - seen[cur])\\n            seen[cur] = min(seen[cur], i)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int longestAwesome(String s) {\\n        int res = 0, cur = 0, n = s.length(), seen[] = new int[1024];\\n        Arrays.fill(seen, n);\\n        seen[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (s.charAt(i) - \\'0\\');\\n            for (int a = 0; a < 10; ++a)\\n                res = Math.max(res, i - seen[cur ^ (1 << a)]);\\n            res = Math.max(res, i - seen[cur]);\\n            seen[cur] = Math.min(seen[cur], i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int longestAwesome(string s) {\\n        int res = 0, cur = 0, n = s.size();\\n        vector<int> seen(1024, n);\\n        seen[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (s[i] - \\'0\\');\\n            for (int a = 0; a < 10; ++a)\\n                res = max(res, i - seen[cur ^ (1 << a)]);\\n            res = max(res, i - seen[cur]);\\n            seen[cur] = min(seen[cur], i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def longestAwesome(self, s):\\n        res, cur, n = 0, 0, len(s)\\n        seen = [-1] + [n] * 1024\\n        for i, c in enumerate(s):\\n            cur ^= 1 << int(c)\\n            for a in xrange(10):\\n                res = max(res, i - seen[cur ^ (1 << a)])\\n            res = max(res, i - seen[cur])\\n            seen[cur] = min(seen[cur], i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 779888,
                "title": "detailed-explanation-case-wise-solution",
                "content": ">Observation 1: \\n>We need to find a substring that contains:\\n>\\n>1. Even occurrences of 0, 1, 2, 3 ... 9.\\n>OR\\n>2. Odd occurrences of one of 0, 1, 2, 3 ... 9. And even occurrences of all other digits.\\n\\nNow, let\\'s enumerate occurrences of each digit for this string \"011233444555569\". And for even occurrences of a digit represent it as set bit in our state.\\n\\n\"\": will have following occurrences: (0, 0, 0, 0, 0, 0, 0, 0, 0, 0) => (1111111111)base2\\n\"0\": will have following occurrences: (1, 0, 0, 0, 0, 0, 0, 0, 0, 0) => (1111111110)base2\\n\"01\": will have following occurrences: (1, 1, 0, 0, 0, 0, 0, 0, 0, 0) => (1111111100)base2\\n\"011\": will have following occurrences: (1, 2, 0, 0, 0, 0, 0, 0, 0, 0) => (1111111110)base2\\n\"0112\": will have following occurrences: (1, 2, 1, 0, 0, 0, 0, 0, 0, 0) => (1111111010)base2\\n\\nMaintaining state in the form of bits will help us find index which will give us a substring that satisfy case1 or case2. Let\\'s see how:\\n\\nFor observation 1 case 1: For this case we only need to check when did we encountered the same set bits earlier.\\n\\nBecause to get even occurences of a digit that has even occurrences we must\\'ve had even occurrences earlier. And to get even occurrences of a digit that has odd occurrences we must\\'ve had odd occurrences of same digit earlier. \\n\\nWhy?\\n\\n>Observation 2: \\n>even - even = even\\n>odd - odd = even\\n\\nFor observation 1 case 2: Keep even occurrences of each digit and use odd occurrence of one of the digit and see if there is a longer substring.\\n\\n**Case wise, light bit-wise operation, easy to understand solution:**\\n\\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> pos = new HashMap<>();   // `state` => index of first occurence of this `state`\\n        int[] occurrences = new int[10];\\n\\n        // Minimum answer will always be 1\\n        int ans = 1;\\n\\n        // All digits have even number of occurences in the beginning.\\n        pos.put(1023, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            occurrences[s.charAt(i) - \\'0\\']++;\\n\\n            int currentState = 0;\\n            for (int j = 0; j < 10; ++j) {\\n                if (occurrences[j] % 2 == 0) {\\n                    currentState |= (1 << j);\\n                }\\n            }\\n            // Case 1: All even\\n            ans = Math.max(ans, i - pos.getOrDefault(currentState, i));\\n\\n            // Case 2: All even, except one odd\\n            for (int digitWithOddOccurrences = 0; digitWithOddOccurrences < 10; ++digitWithOddOccurrences) {\\n                int state = 0;\\n                for (int j = 0; j < 10; ++j) {\\n                    if (j != digitWithOddOccurrences) {\\n                        if (occurrences[j] % 2 == 0) {\\n                            state |= (1 << j);\\n                        }\\n                    } else {\\n                        if (occurrences[j] % 2 == 1) {\\n                            state |= (1 << j);\\n                        }\\n                    }\\n                }\\n\\n                ans = Math.max(ans, i - pos.getOrDefault(state, i));\\n            }\\n            if (!pos.containsKey(currentState)) {\\n                pos.put(currentState, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n**Refactored solution:**\\n\\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> pos = new HashMap<>();   // `state` => index of first occurence of this `state`\\n        int[] occurrences = new int[10];\\n\\n        // Minimum answer will always be 1\\n        int ans = 1;\\n        \\n        // All digits have even number of occurences in the beginning.\\n        int currentState = 1023;\\n\\n        pos.put(currentState, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            currentState ^= (1 << (s.charAt(i) - \\'0\\'));\\n            \\n            // Case 1: All even\\n            ans = Math.max(ans, i - pos.getOrDefault(currentState, i));\\n\\n            // Case 2: All even, except one odd\\n            for (int digitWithOddOccurrences = 0; digitWithOddOccurrences < 10; ++digitWithOddOccurrences) {\\n                ans = Math.max(ans, i - pos.getOrDefault(currentState ^ (1 << digitWithOddOccurrences), i));\\n            }\\n            if (!pos.containsKey(currentState)) {\\n                pos.put(currentState, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> pos = new HashMap<>();   // `state` => index of first occurence of this `state`\\n        int[] occurrences = new int[10];\\n\\n        // Minimum answer will always be 1\\n        int ans = 1;\\n\\n        // All digits have even number of occurences in the beginning.\\n        pos.put(1023, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            occurrences[s.charAt(i) - \\'0\\']++;\\n\\n            int currentState = 0;\\n            for (int j = 0; j < 10; ++j) {\\n                if (occurrences[j] % 2 == 0) {\\n                    currentState |= (1 << j);\\n                }\\n            }\\n            // Case 1: All even\\n            ans = Math.max(ans, i - pos.getOrDefault(currentState, i));\\n\\n            // Case 2: All even, except one odd\\n            for (int digitWithOddOccurrences = 0; digitWithOddOccurrences < 10; ++digitWithOddOccurrences) {\\n                int state = 0;\\n                for (int j = 0; j < 10; ++j) {\\n                    if (j != digitWithOddOccurrences) {\\n                        if (occurrences[j] % 2 == 0) {\\n                            state |= (1 << j);\\n                        }\\n                    } else {\\n                        if (occurrences[j] % 2 == 1) {\\n                            state |= (1 << j);\\n                        }\\n                    }\\n                }\\n\\n                ans = Math.max(ans, i - pos.getOrDefault(state, i));\\n            }\\n            if (!pos.containsKey(currentState)) {\\n                pos.put(currentState, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> pos = new HashMap<>();   // `state` => index of first occurence of this `state`\\n        int[] occurrences = new int[10];\\n\\n        // Minimum answer will always be 1\\n        int ans = 1;\\n        \\n        // All digits have even number of occurences in the beginning.\\n        int currentState = 1023;\\n\\n        pos.put(currentState, -1);\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            currentState ^= (1 << (s.charAt(i) - \\'0\\'));\\n            \\n            // Case 1: All even\\n            ans = Math.max(ans, i - pos.getOrDefault(currentState, i));\\n\\n            // Case 2: All even, except one odd\\n            for (int digitWithOddOccurrences = 0; digitWithOddOccurrences < 10; ++digitWithOddOccurrences) {\\n                ans = Math.max(ans, i - pos.getOrDefault(currentState ^ (1 << digitWithOddOccurrences), i));\\n            }\\n            if (!pos.containsKey(currentState)) {\\n                pos.put(currentState, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217420,
                "title": "c-solution-bit-manipulation-and-hashmaps-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/99e88436-7a7e-4309-97ac-55108293a6ac_1656577255.5991323.jpeg)\\n![image](https://assets.leetcode.com/users/images/82940c6e-3c42-4eca-b3d2-444ba0663d11_1656577267.6991522.jpeg)\\n![image](https://assets.leetcode.com/users/images/4adff6e6-77b6-4987-9b99-0ebcb0c144c7_1656577286.23025.jpeg)\\n![image](https://assets.leetcode.com/users/images/153f279b-d4f8-4b3c-bfc9-02b3e48c7c98_1656577299.7385113.jpeg)\\n![image](https://assets.leetcode.com/users/images/f49ec115-14a4-41ec-958f-29b9adbf1ab3_1656577324.9608977.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int>maskTable;\\n        maskTable[0]=-1;\\n        int ans=0;\\n        int mask=0;\\n        for(int i=0;i<s.size();i++){\\n            int digit=s[i]-\\'0\\';\\n            mask^=(1<<digit);\\n            if(!maskTable.count(mask)){\\n                maskTable[mask]=i;\\n            } else {\\n                //case III\\n                ans=max(ans,i-maskTable[mask]);\\n            }\\n            //caseI and case II\\n            if(mask==0 or (mask&(mask-1))==0){\\n                ans=max(ans,i+1);\\n            }\\n            //case IV\\n            for(int pos=0;pos<=10;pos++){\\n                int nwmask=mask^(1<<pos);\\n                if(maskTable.count(nwmask)){\\n                    ans=max(ans,i-maskTable[nwmask]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int>maskTable;\\n        maskTable[0]=-1;\\n        int ans=0;\\n        int mask=0;\\n        for(int i=0;i<s.size();i++){\\n            int digit=s[i]-\\'0\\';\\n            mask^=(1<<digit);\\n            if(!maskTable.count(mask)){\\n                maskTable[mask]=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 779944,
                "title": "easy-bitmask-with-explanation-o-n",
                "content": "We store the first occurance of counts in a mask\\nfor all even we do\\n`mask[i]` = set `digit\\'th` bit if `count[digit]` in `1..i` is odd\\n\\n`ans = i \\u2013 start[mask]`\\nfor only one odd (digit = `b`)\\nwe find `new mask`\\n`new_mask = mask ^ (1<<b)`\\n`ans = i \\u2013 start[new_mask]`\\n\\nps we only do this when we have seen atleast one occourance of the mask\\n\\ncode:\\n```\\n    int longestAwesome(string s) {\\n\\n        int n = s.length();\\n        int ans = 1;\\n        int mask = 0;\\n        vector<int> pos(2000, -1);\\n        pos[0] = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            int d = s[i-1] - \\'0\\';\\n            mask ^= 1<<d;\\n            if (pos[mask] == -1)\\n                pos[mask] = i;\\n\\t\\t\\t\\t\\n\\t\\t\\t // for no odd digit in subarray\\n            ans = max(ans, i - pos[mask]);\\n\\t\\t\\t// for only one odd digit in subarray\\n            for (int b = 0; b < 10; b++)\\n            {\\n\\t\\t\\t\\t// only odd bit is b\\n                int new_mask = mask^(1<<b);\\n                if (pos[new_mask] != -1)\\n                {\\n                    ans = max(ans, i - pos[new_mask]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\n    int longestAwesome(string s) {\\n\\n        int n = s.length();\\n        int ans = 1;\\n        int mask = 0;\\n        vector<int> pos(2000, -1);\\n        pos[0] = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            int d = s[i-1] - \\'0\\';\\n            mask ^= 1<<d;\\n            if (pos[mask] == -1)\\n                pos[mask] = i;\\n\\t\\t\\t\\t\\n\\t\\t\\t // for no odd digit in subarray\\n            ans = max(ans, i - pos[mask]);\\n\\t\\t\\t// for only one odd digit in subarray\\n            for (int b = 0; b < 10; b++)\\n            {\\n\\t\\t\\t\\t// only odd bit is b\\n                int new_mask = mask^(1<<b);\\n                if (pos[new_mask] != -1)\\n                {\\n                    ans = max(ans, i - pos[new_mask]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234697,
                "title": "explained-simple-efficient",
                "content": "A substring will be an awesome substring:-\\n* \\xA0 \\xA0 If the frequency of each digit/character is even in the substring\\n\\xA0 \\xA0 Or\\n* \\xA0 \\xA0 If only one of the digit/character is having odd count of frequency and rest of the ohters are having even frequency\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 Here the possible character in the string are \\'0\\' to \\'9\\', so we can use a bitmap of length 10 where each position will have either 0 or 1\\n\\xA0 \\xA0 If frequecy of digit \\'0\\' is even, then the first bit will be set as 0, or 1 otherwise\\n\\xA0 \\xA0 If the frequency of digit \\'1\\' is even, then the second digit in bitmap will be 0, or 1 otherwise\\n\\xA0 \\xA0 Same goese for digits 2,3,4....9 and 3rd,4th,5th....10th digit\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 Now we will try to find substrings which are having even number of frequency for each digit or atmost 1 digit with odd frequency.\\n\\xA0 \\xA0 For this we will use (digit-1)th bit in a bitmap\\n\\xA0 \\xA0 When we process each digit, we will toggle the (digit-1)th position bit in bitmap.\\xA0Toggeling this so it becomes 0 for even frequencies, and 1 for odd frequencies. \\n\\xA0 \\xA0 Each time we will set the new bitmap in hashmap where bitmap will be key and the current index will be the value. \\n\\tBefore pushing this in hash, we will check if the same bitmap is already there in hasmap. If yes, then we know there has been a substring which has added even number of frequency for each digit, That\\'s why the overall impact is nothing and we got the same bitmap again. That substring started from the last_index+1(We got last_index from hashmap) and ending on the current index.\\n\\tThe hashmap approach is similar to this, Refer to \"Approach 4: Using Hashmap\" here https://leetcode.com/problems/subarray-sum-equals-k/solution/\\n\\xA0 \\xA0 The above thing covers all the substrings with even frequency of each digit\\n\\xA0 \\xA0 \\n\\xA0 \\xA0 Now to cover substring with odd frequency for 1 digit, we will follow below step\\n\\xA0 \\xA0 There are 10 positions in the bitmap\\n\\xA0 \\xA0 We will toggle the bit on 1st position and check if the toggled bitmap is there in hashmap, if yes then there is an awesome subtring starting after the value of hashmap till this index. It is becuase the substring in between these 2 indexes has added odd frequency only for 1 digit,\\xA0rest of the other digits were added in even freqeuncy. That\\'s why the current bitmap differs by 1 bit only.\\n\\xA0 \\xA0 We will repeat the above step 10 times, each time we will toggle a new digit and check for the match.\\n\\xA0 \\xA0 \\n\\tWhenever we find an awesome substring, we will check for the maximum length.\\n\\n```\\n\\tvar longestAwesome = function(s) {\\n    let bitmap=0,hash={},digit,ans=0,d=1,toggledBitmap;\\n    hash[0]=-1;\\n    for(let i=0;i<s.length;i++){\\n        digit = parseInt(s[i]);\\n        bitmap^= 1<<digit;//Toggle digit bit in total bitmap. So if bit for digit 3 is already set then it will make it zero, otherwise it will set it to 1\\n\\t\\t\\n        if(hash[bitmap]!==undefined){//Here we are checking if the same bitmap has already been there\\n            ans = Math.max(ans,i-hash[bitmap]);\\n        }else{//***We are niw overriding the last key,value pair by the current one, this is to maximize the length whenever a match is found for any index on the right side. \\n            hash[bitmap] = i;\\n        }\\n        for(let j=0;j<10;j++){//Here we are checking for bit with a difference of 1 bit. This is to cover the substrings having odd frequency for 1 digit. \\n             d = 1<<j;\\n            toggledBitmap = bitmap^d;\\n            if(hash[toggledBitmap]!==undefined){\\n                ans = Math.max(ans,i-hash[toggledBitmap]);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvar longestAwesome = function(s) {\\n    let bitmap=0,hash={},digit,ans=0,d=1,toggledBitmap;\\n    hash[0]=-1;\\n    for(let i=0;i<s.length;i++){\\n        digit = parseInt(s[i]);\\n        bitmap^= 1<<digit;//Toggle digit bit in total bitmap. So if bit for digit 3 is already set then it will make it zero, otherwise it will set it to 1\\n\\t\\t\\n        if(hash[bitmap]!==undefined){//Here we are checking if the same bitmap has already been there\\n            ans = Math.max(ans,i-hash[bitmap]);\\n        }else{//***We are niw overriding the last key,value pair by the current one, this is to maximize the length whenever a match is found for any index on the right side. \\n            hash[bitmap] = i;\\n        }\\n        for(let j=0;j<10;j++){//Here we are checking for bit with a difference of 1 bit. This is to cover the substrings having odd frequency for 1 digit. \\n             d = 1<<j;\\n            toggledBitmap = bitmap^d;\\n            if(hash[toggledBitmap]!==undefined){\\n                ans = Math.max(ans,i-hash[toggledBitmap]);\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779909,
                "title": "python-bit-mask",
                "content": "Since the string only contains digits, we can use 10 bits to represent the status of a substring, bit 1 indicates there is an odd number of digits, bit 0 indicates there is an even number of digits. So for an awesome substring, its status has to be zero (all the digits occur even number of times), or only one bit is 1 (there\\'s only one digit occurs odd times)\\n\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        left_most_masks = {0:-1}\\n        valid_masks = {1 << i for i in range(10)} | {0}\\n        ans = 0\\n        curr_mask = 0\\n        for i, x in enumerate(map(int, s)):\\n            curr_mask ^= 1 << x\\n            for valid_mask in valid_masks:\\n                left_mask = valid_mask ^ curr_mask\\n                if left_mask in left_most_masks:\\n                    ans = max(ans, i - left_most_masks[left_mask])\\n            if curr_mask not in left_most_masks:\\n                left_most_masks[curr_mask] = i\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        left_most_masks = {0:-1}\\n        valid_masks = {1 << i for i in range(10)} | {0}\\n        ans = 0\\n        curr_mask = 0\\n        for i, x in enumerate(map(int, s)):\\n            curr_mask ^= 1 << x\\n            for valid_mask in valid_masks:\\n                left_mask = valid_mask ^ curr_mask\\n                if left_mask in left_most_masks:\\n                    ans = max(ans, i - left_most_masks[left_mask])\\n            if curr_mask not in left_most_masks:\\n                left_most_masks[curr_mask] = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780639,
                "title": "python-blazingly-fast-208-ms-99-runtime-while-short-and-simple",
                "content": "Two simple ideas that take advantage of long test scenarios:\\n\\n1. In the first loop, create dictionaries dictF(orward) and dictB(ackward) that contain first and last occurances of cumulative XOR for bitwise coding of digits - the coding is explained very well in other solutions in the discussion. [E.g., see this great post from votrubac.](https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371))\\n2. In the return statement, browse dictF and dictB for the largest distance between the indices. \\n\\nTime saving: finding max at every step is no longer needed. Instead, we need to populate additional dictionary.\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        \\n        digits=[512 >> move for move in range(11)]\\n        xor, dictF, dictB=0, {0:-1}, {0:-1}\\n        \\n        for i in range(len(s)):\\n            xor=xor ^ (1 << int(s[i]))\\n            if xor not in dictF:\\n                dictF[xor]=i\\n            dictB[xor]=i\\n\\n        return max([(ind-dictF[val ^ digit]) \\\\\\n                            for val, ind in dictB.items() \\\\\\n                            for digit in digits \\\\\\n                            if digit ^ val in dictF])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        \\n        digits=[512 >> move for move in range(11)]\\n        xor, dictF, dictB=0, {0:-1}, {0:-1}\\n        \\n        for i in range(len(s)):\\n            xor=xor ^ (1 << int(s[i]))\\n            if xor not in dictF:\\n                dictF[xor]=i\\n            dictB[xor]=i\\n\\n        return max([(ind-dictF[val ^ digit]) \\\\\\n                            for val, ind in dictB.items() \\\\\\n                            for digit in digits \\\\\\n                            if digit ^ val in dictF])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565770,
                "title": "java-solution-problem-for-input-9498331-93139-ans-should-be-5-but-leet-code-show-3",
                "content": "class Solution {\\n    public int longestAwesome(String string) {\\n\\t\\tList<Integer> list1 = new ArrayList<>();\\n\\t\\tList<Integer> list2 = new ArrayList<>();\\n\\t\\tMap<Character, Integer> map = new HashMap<Character, Integer>();\\n\\t\\tfor(int i=0; i<string.length();i++) {\\n\\t\\t\\tif(map.containsKey(string.charAt(i))) {\\n\\t\\t\\t\\tmap.put(string.charAt(i), map.get(string.charAt(i))+1);\\n\\t\\t\\t}\\n\\t\\t\\tmap.putIfAbsent(string.charAt(i), 1);\\n\\t\\t}\\n\\n\\t\\tfor(Character c1 : map.keySet()) {\\n\\t\\t\\tint value = map.get(c1);\\n\\t\\t\\tif(value > 1) {\\n\\t\\t\\t\\tif(value % 2 == 0 ) {\\n\\t\\t\\t\\t\\tlist1.add(value);\\n\\t\\t\\t\\t}else {\\n\\t\\t\\t\\t\\tlist1.add(value-1);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tlist2.add(map.get(c1));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(list1.size() == 0)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif(list2.size() == 0) \\n\\t\\t\\treturn list1.stream().mapToInt(Integer::intValue).sum();\\n\\n\\t\\treturn list1.stream().mapToInt(Integer::intValue).sum()+1;\\n    }\\t\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestAwesome(String string) {\\n\\t\\tList<Integer> list1 = new ArrayList<>();\\n\\t\\tList<Integer> list2 = new ArrayList<>();\\n\\t\\tMap<Character, Integer> map = new HashMap<Character, Integer>();\\n\\t\\tfor(int i=0; i<string.length();i++) {\\n\\t\\t\\tif(map.containsKey(string.charAt(i))) {\\n\\t\\t\\t\\tmap.put(string.charAt(i), map.get(string.charAt(i))+1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3525043,
                "title": "c-bitmask-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[100005];\\n    int longestAwesome(string s) {\\n        \\n        dp[0]=dp[0]+1<<(s[0]-\\'0\\');\\n        \\n        for(int i=1;i<s.size();i++)\\n        {\\n            int temp=(dp[i-1]>>(s[i]-\\'0\\'))%2;\\n            int x=1<<(s[i]-\\'0\\');\\n            if(temp) dp[i]=dp[i-1]-x;\\n            else dp[i]=dp[i-1]+x;\\n        }\\n        int ans=1;\\n        map<int,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int x=dp[i];\\n            int l=dp[i]&(dp[i]-1);\\n\\n            // Case: 1 if no masked no. is present \\n            if(m[dp[i]]==0)m[dp[i]]=i+1;\\n            // Case:2 if same masked no. is present in the map\\n            else ans=max(ans,i+1-m[dp[i]]+1);\\n            // Case:3/4 if the value of mask no. is 0 i.e, all the numbers get balanced or the value is the mask no. just has one setbit i.e, only one no. has odd parity before the current index.\\n            if(dp[i]==0||(dp[i]&(dp[i]-1))==0) {ans=i+1;}\\n            // Case: 5 if same masked no. is present in the map if we will remove any one setbit from the current mask no. i.e, an odd parity no. is present in between the two ends of the no.\\n            for(int pos=0;pos<=10;pos++){\\n                int nwmask=dp[i]^(1<<pos);\\n                if(m.count(nwmask)){\\n                    ans=max(ans,i+1-m[nwmask]);\\n                }\\n            }\\n        }\\n            \\n        cout<<endl;\\n         return ans;\\n    }\\n};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[100005];\\n    int longestAwesome(string s) {\\n        \\n        dp[0]=dp[0]+1<<(s[0]-\\'0\\');\\n        \\n        for(int i=1;i<s.size();i++)\\n        {\\n            int temp=(dp[i-1]>>(s[i]-\\'0\\'))%2;\\n            int x=1<<(s[i]-\\'0\\');\\n            if(temp) dp[i]=dp[i-1]-x;\\n            else dp[i]=dp[i-1]+x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1161457,
                "title": "simple-explanation-of-the-idea-using-bitmasking",
                "content": "If the subtring S[j....i] is making a palindrome then the XOR of this substring will be either 0(in case of even length palindrome) or only one of the 10 bit will be set(in case of odd length palindrome)\\n\\n1.In case of even length palindromic S[j.....i] is a palindromic substring then XOR(S[0....j-1]) and XOR(S[0....i]) should be the same  since XOR(S[j...i]) is zero.\\nSo we can use dp to get the last location we found the same XOR.\\n2.Similarly for odd length palindrome we can try setting each of the 10 bits and see if we got the same xor earlier.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s)\\n    {\\n        int n=s.length();\\n        vector<int> last(1025,n);//To store the last position of xor\\n        \\n        last[0]=-1;\\n        \\n        int ans=0,cur=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cur^= 1<<(s[i]-\\'0\\');\\n            ans=max(ans,i-last[cur]);//suppose the last time curr mask was occured at jth position\\n                    //then xor of j.....i should be 0\\n            \\n            for(int j=0;j<10;j++)\\n            {\\n                ans=max(ans,i-last[cur ^ (1<<j)]);//if the palindrome is of odd length\\n            }\\n            last[cur]=min(last[cur],i);//The last location for which i found this mask\\n        }\\n             \\n        return ans;\\n    }\\n};\\n\\n```\\nPlease **Upvote** if you found this helpful.Any **Suggestions** are welcome",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s)\\n    {\\n        int n=s.length();\\n        vector<int> last(1025,n);//To store the last position of xor\\n        \\n        last[0]=-1;\\n        \\n        int ans=0,cur=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cur^= 1<<(s[i]-\\'0\\');\\n            ans=max(ans,i-last[cur]);//suppose the last time curr mask was occured at jth position\\n                    //then xor of j.....i should be 0\\n            \\n            for(int j=0;j<10;j++)\\n            {\\n                ans=max(ans,i-last[cur ^ (1<<j)]);//if the palindrome is of odd length\\n            }\\n            last[cur]=min(last[cur],i);//The last location for which i found this mask\\n        }\\n             \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102430,
                "title": "java-hashmap-bits-xor-explaination",
                "content": "We use Xor operation to add/include elements. We check in the hashmap if at some previous index \\'n\\' we found the same Xor as current Xor. If yes then it mean all elements from index \\'n\\' to current index have even frequencies since their Xor is zero. but we can have atmost one digit with odd frequency. So for that we will use a for loop and check in th map for currXor Xored with any one digit. this is done to check odd length palindrome. Algorithm is similar to finding max Length subarray with sum equal to k OR 0.\\n```\\n\\tpublic int longestAwesome(String s) {\\n        Map<Integer,Integer> bitXor= new HashMap<>();\\n        bitXor.put(0,-1);\\n        int currXor= 0, maxLength= 0;\\n        for(int i=0; i<s.length(); i++){\\n            currXor^= (1<<(s.charAt(i)-\\'0\\'));\\n            if(bitXor.containsKey(currXor)) maxLength= Math.max(maxLength,i-bitXor.get(currXor));\\n            for(int j=0; j<=9; j++){\\n                int oddLength= currXor^(1<<j);\\n                if(bitXor.containsKey(oddLength)){\\n                    maxLength= Math.max(maxLength,i-bitXor.get(oddLength));\\n                }\\n            }\\n            bitXor.putIfAbsent(currXor,i);\\n        }\\n        return maxLength;\\n    }\\n",
                "solutionTags": [],
                "code": "We use Xor operation to add/include elements. We check in the hashmap if at some previous index \\'n\\' we found the same Xor as current Xor. If yes then it mean all elements from index \\'n\\' to current index have even frequencies since their Xor is zero. but we can have atmost one digit with odd frequency. So for that we will use a for loop and check in th map for currXor Xored with any one digit. this is done to check odd length palindrome. Algorithm is similar to finding max Length subarray with sum equal to k OR 0.\\n```\\n\\tpublic int longestAwesome(String s) {\\n        Map<Integer,Integer> bitXor= new HashMap<>();\\n        bitXor.put(0,-1);\\n        int currXor= 0, maxLength= 0;\\n        for(int i=0; i<s.length(); i++){\\n            currXor^= (1<<(s.charAt(i)-\\'0\\'));\\n            if(bitXor.containsKey(currXor)) maxLength= Math.max(maxLength,i-bitXor.get(currXor));\\n            for(int j=0; j<=9; j++){\\n                int oddLength= currXor^(1<<j);\\n                if(bitXor.containsKey(oddLength)){\\n                    maxLength= Math.max(maxLength,i-bitXor.get(oddLength));\\n                }\\n            }\\n            bitXor.putIfAbsent(currXor,i);\\n        }\\n        return maxLength;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 789284,
                "title": "python-o-n-solution-with-explanation",
                "content": "A substring is palindrome if all the numbers occurs even number of times or only one number occurs odd number of times.\\n\\nLet \\'n\\' represent the integer corresponding to the bit vector whether count of the digit k is even or odd.\\n\\n\\'0010100010\\' is the bit vector indicating that counts of digits 1, 5 and 7 are odd and the rest are even.\\n\\nAt each index i, update n by toggling the s[i]-th bit because if count of s[i] increments by 1 the bit toggles.\\nKeep a map from n to the last i.\\n\\nIf all the digits in the palindrome i to j occurs even number of times then n(i) = n(j+1). Thus check if n(i) has been seen earlier.\\n\\nTo check if any one digit occurs in odd number of times, for each digit j toggle the j-th bit in n(i) (call it m(i)) and check if we have seen m(i) earlier.\\n\\n```\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        n = 0\\n        pos_map = {0:len(s)}\\n        \\n        max_len = 1\\n        \\n        for i in range(len(s)-1, -1, -1):\\n            n = n ^ (1 << int(s[i]))\\n            \\n            if n in pos_map:\\n                max_len = max(max_len, pos_map[n]-i)\\n                \\n            for j in range(10):\\n                m = n ^ (1 << j)\\n                if m in pos_map:\\n                    max_len = max(max_len, pos_map[m]-i)\\n                    \\n            if n not in pos_map:\\n                pos_map[n] = i\\n        \\n        return max_len",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def longestAwesome(self, s):\\n        n = 0\\n        pos_map = {0:len(s)}",
                "codeTag": "Java"
            },
            {
                "id": 780420,
                "title": "javascript-bitwise-mask-prefix-xor-comments-explanation",
                "content": "First off, let\\'s deal with the palindromes. Any possible number of switches is allowed so I only have to deal with the frequency of the characters inside the string. Any string will be palindrome if every frequency is even, except maybe one. \\n\\nSo essentially, there are only 11 possible states Im interested in\\n1000000000,010000000,....,000000001,000000000\\n which mean that The only odd frequency seen so far is of the number i\\n  0<=i<=9\\n Prefix Xor part: \\nWell Every time i come across any new state, I save it as a key with the value being the index I first met that accumulative xor. Then, any time in the future, i come across the same state that means that inbetween value\\n\\n```\\nvar longestAwesome = function(s) {\\n    // freq starts with 0:0 because 9 0s is also a state and if I come across a \\n    // 0 down the road, that means that the whole array up to index i is of the required type\\n    let firstIndex={0:0}, result=-1, curr=0\\n    for (let i = 0; i < s.length; i++) {\\n       curr^= 1<<s[i]\\n       // Check if you have seen curr^0=curr before, \\n\\t   // because that would make the inbetween elements\\' xor = 000000000\\n       if(firstIndex[curr]!==undefined)\\n            result=Math.max(result,i-firstIndex[curr]+1)\\n       // Check all the other xors, because that would make \\n\\t   // the inbetween elements of the required type (100000000,010000000,......,000000001)\\n       for (let j = 0; j <10; j++) {\\n            let ele=1<<j\\n            if(firstIndex[curr^ele]!==undefined)\\n                //i-firstIndex[curr^ele] because on freq I saved\\n\\t\\t\\t\\t//the smallest index where I last met curr^ele\\n                result=Math.max(result,i-firstIndex[curr^ele]+1)\\n       }\\n       if(firstIndex[curr]===undefined)\\n\\t\\t   firstIndex[curr]=i+1// +1 cos 0th place is for my 0 state\\n    }\\n \\n    return result\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar longestAwesome = function(s) {\\n    // freq starts with 0:0 because 9 0s is also a state and if I come across a \\n    // 0 down the road, that means that the whole array up to index i is of the required type\\n    let firstIndex={0:0}, result=-1, curr=0\\n    for (let i = 0; i < s.length; i++) {\\n       curr^= 1<<s[i]\\n       // Check if you have seen curr^0=curr before, \\n\\t   // because that would make the inbetween elements\\' xor = 000000000\\n       if(firstIndex[curr]!==undefined)\\n            result=Math.max(result,i-firstIndex[curr]+1)\\n       // Check all the other xors, because that would make \\n\\t   // the inbetween elements of the required type (100000000,010000000,......,000000001)\\n       for (let j = 0; j <10; j++) {\\n            let ele=1<<j\\n            if(firstIndex[curr^ele]!==undefined)\\n                //i-firstIndex[curr^ele] because on freq I saved\\n\\t\\t\\t\\t//the smallest index where I last met curr^ele\\n                result=Math.max(result,i-firstIndex[curr^ele]+1)\\n       }\\n       if(firstIndex[curr]===undefined)\\n\\t\\t   firstIndex[curr]=i+1// +1 cos 0th place is for my 0 state\\n    }\\n \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414556,
                "title": "intuitive-bit-mask-solution-with-comments",
                "content": "# Intuition\\nWant to use a bitmask to subsitute a dictionary because our alphabet is a fixed length (the numebr of digits \"0-9\" = 10 digits). Similar to Prefix Sum + Hashmap Medium problems, but with a bitmask spin to get lower time and space complexity. \\n\\n# Approach\\nRead in-text comments\\n\\n# Complexity\\n- Time complexity:\\nO(N) for the outer for loop and O(10) for inner for loop = O(10 * N) = O(N)\\n\\n- Space complexity:\\nO(1), because of bitmask\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int ans = 0;\\n        // Mask = 0b0000000000 -> There are 10 zeroes because we have 10 possible vals 0-9 as our alphabet\\n        // 0th place is 1 if we have odd number of 0s and 0 if we have even number of 0s\\n        // 1th place is 1 ... \\n        int mask = 0;\\n\\n        HashMap<Integer, Integer> map = new HashMap();\\n        map.put(0, -1);\\n\\n        for (int idx = 0; idx < s.length(); idx++) {\\n            // lets say s.charAt(idx) == 3. We shift 0b1 by 3 so that we get 0b1000\\n            // lets say mask = 0b1000 -> the xOr will evaluate to 0b000\\n            // This means we had an odd number of 3s now we have an even number of all values\\n            mask ^= 1 << (s.charAt(idx) - \\'0\\');\\n\\n\\n            // If we see matching masks then that means the number of odd characters \\n            // and those corresponding characters that are odd are the same\\n            // Substracting one substring from another we get a new susbtring with no odd freq characters\\n            if (map.containsKey(mask)) {\\n                ans = Math.max(ans, idx - map.get(mask));\\n            } else {\\n                map.put(mask, idx);\\n            }\\n\\n            // Palindrome can also have 1 character with an odd freq (in the middle)\\n            for (int shift = 0; shift < 10; shift++) {\\n                // Consider all masks that differ by mask in 1 place\\n                int oddMask = mask ^ (1 << shift);\\n\\n                if (map.containsKey(oddMask)) {\\n                    ans = Math.max(ans, idx - map.get(oddMask));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int ans = 0;\\n        // Mask = 0b0000000000 -> There are 10 zeroes because we have 10 possible vals 0-9 as our alphabet\\n        // 0th place is 1 if we have odd number of 0s and 0 if we have even number of 0s\\n        // 1th place is 1 ... \\n        int mask = 0;\\n\\n        HashMap<Integer, Integer> map = new HashMap();\\n        map.put(0, -1);\\n\\n        for (int idx = 0; idx < s.length(); idx++) {\\n            // lets say s.charAt(idx) == 3. We shift 0b1 by 3 so that we get 0b1000\\n            // lets say mask = 0b1000 -> the xOr will evaluate to 0b000\\n            // This means we had an odd number of 3s now we have an even number of all values\\n            mask ^= 1 << (s.charAt(idx) - \\'0\\');\\n\\n\\n            // If we see matching masks then that means the number of odd characters \\n            // and those corresponding characters that are odd are the same\\n            // Substracting one substring from another we get a new susbtring with no odd freq characters\\n            if (map.containsKey(mask)) {\\n                ans = Math.max(ans, idx - map.get(mask));\\n            } else {\\n                map.put(mask, idx);\\n            }\\n\\n            // Palindrome can also have 1 character with an odd freq (in the middle)\\n            for (int shift = 0; shift < 10; shift++) {\\n                // Consider all masks that differ by mask in 1 place\\n                int oddMask = mask ^ (1 << shift);\\n\\n                if (map.containsKey(oddMask)) {\\n                    ans = Math.max(ans, idx - map.get(oddMask));\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287021,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        // 3 2 4 2 4 1 5\\n        unordered_map<int,int>mp;\\n        int ans=1;\\n        int num=0;\\n        mp[0]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            num=num^(1<<(s[i]-\\'0\\'));\\n            // case 1\\n            if(mp.find(num)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[num]);\\n            }\\n            // checking for palindrome\\n            for(int j=0;j<=9;j++)\\n            {\\n                int mask=num^(1<<j);\\n                if(mp.find(mask)!=mp.end())\\n                {\\n                    ans=max(ans,i-mp[mask]);\\n                }\\n            }\\n            if(mp.find(num)==mp.end())\\n            {\\n                mp[num]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        // 3 2 4 2 4 1 5\\n        unordered_map<int,int>mp;\\n        int ans=1;\\n        int num=0;\\n        mp[0]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            num=num^(1<<(s[i]-\\'0\\'));\\n            // case 1\\n            if(mp.find(num)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[num]);\\n            }\\n            // checking for palindrome\\n            for(int j=0;j<=9;j++)\\n            {\\n                int mask=num^(1<<j);\\n                if(mp.find(mask)!=mp.end())\\n                {\\n                    ans=max(ans,i-mp[mask]);\\n                }\\n            }\\n            if(mp.find(num)==mp.end())\\n            {\\n                mp[num]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802585,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int longestAwesome(string s) {\\n    vector<int> dp(1024, s.size());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        mask ^= 1 << (s[i] - \\'0\\');\\n        res = max(res, i - dp[mask]);\\n        for (auto j = 0; j <= 9; ++j)\\n            res = max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = min(dp[mask], i);\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int longestAwesome(string s) {\\n    vector<int> dp(1024, s.size());\\n    int res = 0, mask = 0;\\n    dp[0] = -1;\\n    for (auto i = 0; i < s.size(); ++i) {\\n        mask ^= 1 << (s[i] - \\'0\\');\\n        res = max(res, i - dp[mask]);\\n        for (auto j = 0; j <= 9; ++j)\\n            res = max(res, i - dp[mask ^ (1 << j)]);\\n        dp[mask] = min(dp[mask], i);\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259262,
                "title": "python3-prefix-xor-o-n-solution",
                "content": "Time Complexity: O(n) ->  O(512n) in worst case?\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        # li = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\\n        li = [2**i for i in range(10)]\\n        # checker = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512}\\n        checker = set(li)\\n        checker.add(0)\\n        # di: k = prefix xor, v = the first idx I got a new prefix_xor_value.\\n        di = collections.OrderedDict({0: -1})\\n        maxLength = prefix_xor = 0\\n        \\n        for i in range(len(s)):\\n            prefix_xor ^= li[int(s[i])]\\n            # Found a new prefix_xor_value\\n            if prefix_xor not in di:\\n                di[prefix_xor] = i\\n            \\n            # XOR operation with previous prefix_xor_value\\n            for key in di.keys():\\n                if i - di[key] <= maxLength:\\n                    break\\n\\t\\t\\t\\t# s[di[key] : i] is Awesome Substring\\n                if key ^ prefix_xor in checker:\\n                    maxLength = i - di[key]\\n        return maxLength\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        # li = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\\n        li = [2**i for i in range(10)]\\n        # checker = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512}\\n        checker = set(li)\\n        checker.add(0)\\n        # di: k = prefix xor, v = the first idx I got a new prefix_xor_value.\\n        di = collections.OrderedDict({0: -1})\\n        maxLength = prefix_xor = 0\\n        \\n        for i in range(len(s)):\\n            prefix_xor ^= li[int(s[i])]\\n            # Found a new prefix_xor_value\\n            if prefix_xor not in di:\\n                di[prefix_xor] = i\\n            \\n            # XOR operation with previous prefix_xor_value\\n            for key in di.keys():\\n                if i - di[key] <= maxLength:\\n                    break\\n\\t\\t\\t\\t# s[di[key] : i] is Awesome Substring\\n                if key ^ prefix_xor in checker:\\n                    maxLength = i - di[key]\\n        return maxLength\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875354,
                "title": "c-easy-understanding-explained-with-comments-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    // Similar to :-\\n    // https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n\\t// To understand logic behind using xor here , see:\\n\\t// https://leetcode.com/submissions/detail/665490340/\\n\\t//\\n    int longestAwesome(string s) {\\n        int parity = 0000000000 ; // 9-8-7..1-0\\n        unordered_map <int,int> m ;\\n        m[0] = 0; // empty case\\n        int ans = 0;\\n        for ( int i = 0;i<s.length();i++){\\n            int x = s[i]-\\'0\\';\\n            parity ^= (1<<x);\\n            if(m.find(parity)!=m.end()){ // for 0 case\\n                    ans=max(ans,i+1-m[parity]);\\n                    m[parity]=min(m[parity],i+1);\\n            }\\n            for ( int j=0 ; j<=9;j++)\\n                if(m.find(parity^(1<<j))!=m.end())\\n                    ans=max(ans,i+1-m[parity^(1<<j)]);\\n            if(m.find(parity)==m.end())\\n                m[parity]=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Similar to :-\\n    // https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n\\t// To understand logic behind using xor here , see:\\n\\t// https://leetcode.com/submissions/detail/665490340/\\n\\t//\\n    int longestAwesome(string s) {\\n        int parity = 0000000000 ; // 9-8-7..1-0\\n        unordered_map <int,int> m ;\\n        m[0] = 0; // empty case\\n        int ans = 0;\\n        for ( int i = 0;i<s.length();i++){\\n            int x = s[i]-\\'0\\';\\n            parity ^= (1<<x);\\n            if(m.find(parity)!=m.end()){ // for 0 case\\n                    ans=max(ans,i+1-m[parity]);\\n                    m[parity]=min(m[parity],i+1);\\n            }\\n            for ( int j=0 ; j<=9;j++)\\n                if(m.find(parity^(1<<j))!=m.end())\\n                    ans=max(ans,i+1-m[parity^(1<<j)]);\\n            if(m.find(parity)==m.end())\\n                m[parity]=i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751201,
                "title": "c-clean-and-simple-with-important-comments",
                "content": "we just need to find the longest substring wth atmax 1 character occuring odd number of times\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.length();\\n        unordered_map<int,int>M;\\n        M[0] = -1;\\n        int mask = 0;\\n        int max_len = 0;\\n        for(int i = 0;i < n; i++)\\n        {\\n            mask ^= (1 << (s[i] - \\'0\\'));\\n            if(M.find(mask) == M.end())\\n                M[mask] = i;\\n            else//all the character are of even occurances\\n            {\\n                max_len = max(max_len, i - M[mask]);\\n                \\n            }\\n\\t\\t\\t//at max 1 occurance of a character is fine \\n            for(int j = 0; j <= 9; j++)\\n            {\\n                if(M.find(mask ^ (1 << j)) != M.end())\\n                    max_len = max(max_len, i - M[mask ^ (1 << j)]);\\n            }\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.length();\\n        unordered_map<int,int>M;\\n        M[0] = -1;\\n        int mask = 0;\\n        int max_len = 0;\\n        for(int i = 0;i < n; i++)\\n        {\\n            mask ^= (1 << (s[i] - \\'0\\'));\\n            if(M.find(mask) == M.end())\\n                M[mask] = i;\\n            else//all the character are of even occurances\\n            {\\n                max_len = max(max_len, i - M[mask]);\\n                \\n            }\\n\\t\\t\\t//at max 1 occurance of a character is fine \\n            for(int j = 0; j <= 9; j++)\\n            {\\n                if(M.find(mask ^ (1 << j)) != M.end())\\n                    max_len = max(max_len, i - M[mask ^ (1 << j)]);\\n            }\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744050,
                "title": "python-bit-mask",
                "content": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n\\t    #keeps track of last index where this state was seen\\n        last_seen={}\\n        ans=0\\n        mask=0\\n        last_seen[mask]=-1\\n        for i,c in enumerate(s):\\n            c=int(c)\\n            mask ^= (1<<c)\\n            if mask in last_seen:\\n                ans=max(ans,i-last_seen[mask])\\n            else:\\n                last_seen[mask]=i\\n\\t\\t\\t#checking for one odd char in palindrome\\n            for x in range(10):\\n                new_mask=mask ^ (1<<x)\\n                if new_mask in last_seen:\\n                    ans=max(ans,i-last_seen[new_mask])\\n        return ans\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n\\t    #keeps track of last index where this state was seen\\n        last_seen={}\\n        ans=0\\n        mask=0\\n        last_seen[mask]=-1\\n        for i,c in enumerate(s):\\n            c=int(c)\\n            mask ^= (1<<c)\\n            if mask in last_seen:\\n                ans=max(ans,i-last_seen[mask])\\n            else:\\n                last_seen[mask]=i\\n\\t\\t\\t#checking for one odd char in palindrome\\n            for x in range(10):\\n                new_mask=mask ^ (1<<x)\\n                if new_mask in last_seen:\\n                    ans=max(ans,i-last_seen[new_mask])\\n        return ans\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 855538,
                "title": "java-o-n-solution-shortest",
                "content": "I have implemented BitMasking with HashMap since ther is only 10 possible characters.\\n```\\npublic int longestAwesome(String s) {\\n        \\n        \\n        int l=s.length(),x=0,res=0;\\n        HashMap<Integer,Integer> h=new HashMap<>();\\n        h.put(0,-1);\\n        for(int i=0;i<l;i++)\\n        {\\n            x=x^(1<<(s.charAt(i)-\\'0\\'));\\n            if(h.containsKey(x))\\n            res=Math.max(res,i-h.get(x));\\n            else\\n            h.put(x,i);\\n            \\n            for(int j=0;j<10;j++)\\n            {\\n                if(h.containsKey(x^(1<<j)))\\n                res = Math.max(res,i-h.get(x^(1<<j)));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```\\n\\nIncase, of any explanation is required for the above solution, let me know.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\npublic int longestAwesome(String s) {\\n        \\n        \\n        int l=s.length(),x=0,res=0;\\n        HashMap<Integer,Integer> h=new HashMap<>();\\n        h.put(0,-1);\\n        for(int i=0;i<l;i++)\\n        {\\n            x=x^(1<<(s.charAt(i)-\\'0\\'));\\n            if(h.containsKey(x))\\n            res=Math.max(res,i-h.get(x));\\n            else\\n            h.put(x,i);\\n            \\n            for(int j=0;j<10;j++)\\n            {\\n                if(h.containsKey(x^(1<<j)))\\n                res = Math.max(res,i-h.get(x^(1<<j)));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806334,
                "title": "python-traverse-from-longest",
                "content": "```\\n# I am assuming they mean contiguous substrings\\n\\nfrom collections import Counter\\n\\ndef palindromable(s):\\n    # to be palindromable there needs to be an even number of all chars except one odd is acceptable\\n    counts = Counter(s)\\n    num_odds = 0\\n    for char, ct in counts.items():\\n        if ct % 2 != 0:\\n            num_odds += 1\\n            if num_odds > 1:\\n                return False\\n    return True\\n\\ndef findlength(s: str) -> int:\\n\\t# traverse from longest contiguous substrings\\n\\tnum_chars = len(s)\\n\\tfor num_dropped in range(num_chars):\\n\\t\\tfor left_idx in range(num_dropped + 1):\\n\\t\\t\\tright_idx = num_chars - (num_dropped - left_idx)\\n\\t\\t\\tsub_s = s[left_idx: right_idx]\\n\\t\\t\\tif palindromable(sub_s):\\n\\t\\t\\t\\toutput = num_chars - num_dropped\\n\\t\\t\\t\\treturn output\\n\\t```",
                "solutionTags": [],
                "code": "```\\n# I am assuming they mean contiguous substrings\\n\\nfrom collections import Counter\\n\\ndef palindromable(s):\\n    # to be palindromable there needs to be an even number of all chars except one odd is acceptable\\n    counts = Counter(s)\\n    num_odds = 0\\n    for char, ct in counts.items():\\n        if ct % 2 != 0:\\n            num_odds += 1\\n            if num_odds > 1:\\n                return False\\n    return True\\n\\ndef findlength(s: str) -> int:\\n\\t# traverse from longest contiguous substrings\\n\\tnum_chars = len(s)\\n\\tfor num_dropped in range(num_chars):\\n\\t\\tfor left_idx in range(num_dropped + 1):\\n\\t\\t\\tright_idx = num_chars - (num_dropped - left_idx)\\n\\t\\t\\tsub_s = s[left_idx: right_idx]\\n\\t\\t\\tif palindromable(sub_s):\\n\\t\\t\\t\\toutput = num_chars - num_dropped\\n\\t\\t\\t\\treturn output\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 801683,
                "title": "c-unordered-map-bitmask",
                "content": "```\\n        vector<int> pbit = {0};\\n        for(int i=0; i<10; i++) pbit.push_back(1<<i);\\n        unordered_map<int, int> bitmap; //bit, index\\n        bitmap[0] = -1;\\n        int res = 0, bits = 0;\\n        for(int i=0; i<s.size(); i++){\\n            bits ^= (1<<(s[i]-\\'0\\'));\\n            for(auto x:pbit){\\n                auto it = bitmap.find(bits ^ x);\\n                if(it != bitmap.end()){\\n                    res = max(res, i - it->second);\\n                }\\n            }\\n            if(!bitmap.count(bits)) bitmap[bits] = i;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n        vector<int> pbit = {0};\\n        for(int i=0; i<10; i++) pbit.push_back(1<<i);\\n        unordered_map<int, int> bitmap; //bit, index\\n        bitmap[0] = -1;\\n        int res = 0, bits = 0;\\n        for(int i=0; i<s.size(); i++){\\n            bits ^= (1<<(s[i]-\\'0\\'));\\n            for(auto x:pbit){\\n                auto it = bitmap.find(bits ^ x);\\n                if(it != bitmap.end()){\\n                    res = max(res, i - it->second);\\n                }\\n            }\\n            if(!bitmap.count(bits)) bitmap[bits] = i;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 784632,
                "title": "python3-prefix-xor",
                "content": "Toggle bit to indicate if a number has appeared even/odd number of times. \\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        ans = prefix = 0\\n        seen = {0: -1}\\n        for i, c in enumerate(s):\\n            prefix ^= 1 << int(c) #toggle bit \\n            ans = max(ans, i - seen.get(prefix, inf))\\n            for k in range(10): \\n                x = prefix ^ (1 << k) #toggle kth bit \\n                ans = max(ans, i - seen.get(x, inf))\\n            seen.setdefault(prefix, i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        ans = prefix = 0\\n        seen = {0: -1}\\n        for i, c in enumerate(s):\\n            prefix ^= 1 << int(c) #toggle bit \\n            ans = max(ans, i - seen.get(prefix, inf))\\n            for k in range(10): \\n                x = prefix ^ (1 << k) #toggle kth bit \\n                ans = max(ans, i - seen.get(x, inf))\\n            seen.setdefault(prefix, i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 780127,
                "title": "easy-bitmasking-o-n-solution-c",
                "content": "Solved using Bitmasking!\\nSimple O(n)\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size(),ans=0;\\n        vector<int> mask(1<<10,-1);\\n        vector<int>count(10);\\n        mask[0]=-1;\\n        for(int i=0;i<n;i++){\\n            count[s[i]-\\'0\\']++;\\n            int temp=0;\\n            for(int j=0;j<10;j++){\\n                if(count[j]&1)temp|=(1<<j);\\n            }\\n            int req=0,chk=0;\\n            for(int j=0;j<10;j++){\\n                if((temp)&(1<<j))req|=(1<<j),chk++;\\n            }\\n            if(chk<=1){\\n                ans=max(ans,i+1);\\n            }\\n            else{\\n                if(mask[req]!=-1)ans=max(ans,i-mask[req]+1);//all zero\\n                for(int j=0;j<10;j++){\\n                    //jth bit is one and else zero\\n                    int Z=0;\\n                    if(temp&(1<<j)){\\n                        Z=req^(1<<j);\\n                    }else{\\n                        Z=req|(1<<j); \\n                    }\\n                    if(mask[Z]!=-1)ans=max(ans,i-mask[Z]);\\n                }                \\n            }\\n            if(mask[temp]==-1)\\n                mask[temp]=i;\\n            // cout<<i<<\" \"<<ans<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size(),ans=0;\\n        vector<int> mask(1<<10,-1);\\n        vector<int>count(10);\\n        mask[0]=-1;\\n        for(int i=0;i<n;i++){\\n            count[s[i]-\\'0\\']++;\\n            int temp=0;\\n            for(int j=0;j<10;j++){\\n                if(count[j]&1)temp|=(1<<j);\\n            }\\n            int req=0,chk=0;\\n            for(int j=0;j<10;j++){\\n                if((temp)&(1<<j))req|=(1<<j),chk++;\\n            }\\n            if(chk<=1){\\n                ans=max(ans,i+1);\\n            }\\n            else{\\n                if(mask[req]!=-1)ans=max(ans,i-mask[req]+1);//all zero\\n                for(int j=0;j<10;j++){\\n                    //jth bit is one and else zero\\n                    int Z=0;\\n                    if(temp&(1<<j)){\\n                        Z=req^(1<<j);\\n                    }else{\\n                        Z=req|(1<<j); \\n                    }\\n                    if(mask[Z]!=-1)ans=max(ans,i-mask[Z]);\\n                }                \\n            }\\n            if(mask[temp]==-1)\\n                mask[temp]=i;\\n            // cout<<i<<\" \"<<ans<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 779922,
                "title": "java-prefix-bitmask-o-10-n",
                "content": "Similar idea to https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n\\nBut additionally at each step we check for complements that add to power of two. Power of two since a palindrome can contain at most 1 odd number of characters.\\n\\n```\\n    public int longestAwesome(String s) {\\n        final Map<Integer, Integer> idx = new HashMap<>(Collections.singletonMap(0, -1));\\n        int res = 0, mask = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            mask ^= 1 << (s.charAt(i) - \\'0\\');\\n            idx.putIfAbsent(mask, i);\\n            res = Math.max(res, i - idx.getOrDefault(mask, i));\\n            for (int value = 1; value <= (1 << 10); value <<= 1) {\\n                final int complement = value ^ mask;\\n                res = Math.max(res, i - idx.getOrDefault(complement, i));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestAwesome(String s) {\\n        final Map<Integer, Integer> idx = new HashMap<>(Collections.singletonMap(0, -1));\\n        int res = 0, mask = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            mask ^= 1 << (s.charAt(i) - \\'0\\');\\n            idx.putIfAbsent(mask, i);\\n            res = Math.max(res, i - idx.getOrDefault(mask, i));\\n            for (int value = 1; value <= (1 << 10); value <<= 1) {\\n                final int complement = value ^ mask;\\n                res = Math.max(res, i - idx.getOrDefault(complement, i));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779898,
                "title": "c-o-11n-bitmask",
                "content": "[a, b] is an awesome substring if at most one letter appears odd number of times in [a, b].\\n\\nlet dp[i] = parity of each letter in [0, i] by setting j-th bit to 1 if \\'j\\' appears odd number of times in [0, i], otherwise 0.\\n\\ns[a, b] is an awesome substring if dp[a] ^ dp[b] == 0 or (1 << k) for some k\\n\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> dp(1 << 10, -1);\\n        int x = 0;\\n        for(int i = 0; i < n; ++i) {\\n            x ^= 1 << (s[i] - \\'0\\');\\n            dp[x] = i;\\n        }\\n        int ans = 1;\\n        x = 0;\\n        for(int i = 0; i < n; ++i) {\\n            ans = max(ans, dp[x] - i + 1);\\n            for(int j = 0; j < 10; ++j) {\\n                ans = max(ans, dp[x ^ (1 << j)] - i + 1);\\n            }\\n            x ^= 1 << (s[i] - \\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> dp(1 << 10, -1);\\n        int x = 0;\\n        for(int i = 0; i < n; ++i) {\\n            x ^= 1 << (s[i] - \\'0\\');\\n            dp[x] = i;\\n        }\\n        int ans = 1;\\n        x = 0;\\n        for(int i = 0; i < n; ++i) {\\n            ans = max(ans, dp[x] - i + 1);\\n            for(int j = 0; j < 10; ++j) {\\n                ans = max(ans, dp[x ^ (1 << j)] - i + 1);\\n            }\\n            x ^= 1 << (s[i] - \\'0\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975112,
                "title": "c-hash-table-bitmasking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        unordered_map<int,int> m;\\n        int mask = 0;\\n        m[mask] = -1;\\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            mask^=(1<<(s[i]-\\'0\\'));\\n            if(m.find(mask)!=m.end())\\n            {\\n                ans = max(ans,i-m[mask]);\\n            }\\n            for(int j=0;j<=9;j++)\\n            {\\n                int tmp = mask^(1<<j);\\n                if(m.find(tmp)!=m.end())\\n                ans = max(ans,i-m[tmp]);\\n            }\\n            if(m.find(mask)==m.end())\\n            m[mask] = i;\\n        }\\n        if(ans==INT_MIN)\\n        return 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        unordered_map<int,int> m;\\n        int mask = 0;\\n        m[mask] = -1;\\n        int ans = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            mask^=(1<<(s[i]-\\'0\\'));\\n            if(m.find(mask)!=m.end())\\n            {\\n                ans = max(ans,i-m[mask]);\\n            }\\n            for(int j=0;j<=9;j++)\\n            {\\n                int tmp = mask^(1<<j);\\n                if(m.find(tmp)!=m.end())\\n                ans = max(ans,i-m[tmp]);\\n            }\\n            if(m.find(mask)==m.end())\\n            m[mask] = i;\\n        }\\n        if(ans==INT_MIN)\\n        return 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903963,
                "title": "bitmask",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n\\n     unordered_map<int,int>mp;\\n        mp[0]=-1;\\n      \\n         int mask=0; \\n          int ans=1;\\n          \\n          for(int i=0;i<s.size();i++){\\n            mask=mask ^( 1<<(s[i]-\\'0\\')); \\n            if(mp.find(mask)!=mp.end()) ans=max(ans,i-mp[mask]);\\n            else mp[mask]=i;\\n        \\n            for(int k=0;k<=9;k++){\\n                  int num=mask^(1<<k);\\n                if(mp.find(num)!=mp.end()) ans=max(i-mp[num],ans);\\n            }\\n     \\n        \\n          }\\n          return  ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n\\n     unordered_map<int,int>mp;\\n        mp[0]=-1;\\n      \\n         int mask=0; \\n          int ans=1;\\n          \\n          for(int i=0;i<s.size();i++){\\n            mask=mask ^( 1<<(s[i]-\\'0\\')); \\n            if(mp.find(mask)!=mp.end()) ans=max(ans,i-mp[mask]);\\n            else mp[mask]=i;\\n        \\n            for(int k=0;k<=9;k++){\\n                  int num=mask^(1<<k);\\n                if(mp.find(num)!=mp.end()) ans=max(i-mp[num],ans);\\n            }\\n     \\n        \\n          }\\n          return  ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858394,
                "title": "bit-masking-and-prefix-sum-c",
                "content": "# Intuition\\nWe know a string can only become a palindrome in 2 cases :-\\n1. If all the distinct elements occurs even no. of times.\\n2. If all the distinct elements except one occurs even no. of times.\\n\\nWe have to find the longest substring that satistfies any one of the above condition.\\n\\n# Approach\\nWe will check for each index if the string ending at it can become palindrome (i.e satisifies above condtion).\\nIf it doesn\\'t then we will check if removing a substring from its behind helps it become palindrome.\\n\\nSince the elements present are all digits `(0 - 9)`, we will create bitmask for each index and store them in a prefix array.\\nEach index in the bitmask represents corresponding digit.\\n\\n`0` bit represents that digit at that index have occured even no. of times, `1` represents odd no. of times.\\n\\nAfter forming the prefix array, we will traverse the string along with maintaining a hashmap to store previously seen bitmask.\\n\\nfor each index i, \\n**if** \\nmask == 0 (means all no.s occur even no. of times) \\nor mask contains only one 1 i.e it\\'s a power of 2 (means all no.s except 1 occurs even no. of times),\\nthen we will calculate length of string\\n\\n**else** \\nwe will check if there exists a mask before, xoring with which we get 0\\n\\ncurMask ^ toBeFindMask = 0\\ntoBeFindMask = 0 ^ curMask\\ntoBeFindMask = curMask\\n\\nor we will check if there exists a mask before, xoring with which we get a no. which contains only one 1.\\n\\ncurMask ^ toBeFindMask = $$2^x$$  (0 <= x <= 9)\\ntoBeFindMask = $$2^x$$ ^ curMask\\n\\nand update max length string found.\\n\\nStore the bit mask only if it is not seen already, that way we can get the farthest index from current index when we search for it, thereby getting maximum length \\n\\n\\n# Complexity\\n- Time complexity: $$O(10*n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> prefix(n+1);\\n        for(int i=0; i<n; i++){\\n            int bit = s[i] - \\'0\\';\\n            prefix[i+1] = prefix[i] ^ (1 << bit);\\n        }\\n\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int mask = prefix[i+1];\\n            \\n            // mask == 0 means all numbers present even times\\n            // mask with all 0 except 1 means all numbers present even times except one\\n            if(mask == 0 || !(mask & (mask-1))){\\n                ans = max(ans, i+1);\\n            }\\n            else{\\n                // check if a mask exist with which if we take XOR we\\'ll get a 0\\n                // that means check if same mask exist previously\\n                if(mp.count(mask)){\\n                    ans = max(ans, i-mp[mask]);\\n                }\\n                // check if a mask exist with which if we take XOR we\\'ll get a number which have only one 1\\n                for(int j=0; j<10; j++){\\n                    int submask = (1 << j);\\n                    int f = mask ^ submask;\\n                    \\n                    if(mp.count(f)){\\n                        ans = max(ans, i - mp[f]);\\n                    }\\n                }\\n            }\\n            if(!mp.count(mask)){\\n                mp[mask] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> prefix(n+1);\\n        for(int i=0; i<n; i++){\\n            int bit = s[i] - \\'0\\';\\n            prefix[i+1] = prefix[i] ^ (1 << bit);\\n        }\\n\\n        unordered_map<int,int> mp;\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int mask = prefix[i+1];\\n            \\n            // mask == 0 means all numbers present even times\\n            // mask with all 0 except 1 means all numbers present even times except one\\n            if(mask == 0 || !(mask & (mask-1))){\\n                ans = max(ans, i+1);\\n            }\\n            else{\\n                // check if a mask exist with which if we take XOR we\\'ll get a 0\\n                // that means check if same mask exist previously\\n                if(mp.count(mask)){\\n                    ans = max(ans, i-mp[mask]);\\n                }\\n                // check if a mask exist with which if we take XOR we\\'ll get a number which have only one 1\\n                for(int j=0; j<10; j++){\\n                    int submask = (1 << j);\\n                    int f = mask ^ submask;\\n                    \\n                    if(mp.count(f)){\\n                        ans = max(ans, i - mp[f]);\\n                    }\\n                }\\n            }\\n            if(!mp.count(mask)){\\n                mp[mask] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825043,
                "title": "python-simple-bit-manipulation",
                "content": "```\\n\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        d,mask,ans={},0,0\\n        d[0]=-1\\n        for i in range(len(s)):\\n            num=ord(s[i])-ord(\\'0\\')\\n            mask=mask^(1<<num)\\n            if mask in d:\\n                ans=max(ans,i-d[mask])\\n            else:\\n                d[mask]=i\\n            for j in range(0,10):\\n                temp=mask^(1<<j)\\n                if temp in d:\\n                    ans=max(ans,i-d[temp])\\n        return ans \\n                    \\n```\\nPlease upvote",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        d,mask,ans={},0,0\\n        d[0]=-1\\n        for i in range(len(s)):\\n            num=ord(s[i])-ord(\\'0\\')\\n            mask=mask^(1<<num)\\n            if mask in d:\\n                ans=max(ans,i-d[mask])\\n            else:\\n                d[mask]=i\\n            for j in range(0,10):\\n                temp=mask^(1<<j)\\n                if temp in d:\\n                    ans=max(ans,i-d[temp])\\n        return ans \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811807,
                "title": "bitmask-cpp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size();\\n\\n        int mask=0;\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {   \\n            mask = mask^(1<<(s[i]-\\'0\\'));           \\n\\n            for(int j=0;j<10;j++)\\n            {\\n                int new_mask = mask^(1<<j);\\n\\n                if(mp.find(new_mask)!=mp.end())\\n                ans=max(ans,i-mp[new_mask]);\\n            }\\n            if(mp.find(mask)==mp.end())\\n            mp[mask] = i;\\n            else \\n            ans = max(ans,i-mp[mask]);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size();\\n\\n        int mask=0;\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {   \\n            mask = mask^(1<<(s[i]-\\'0\\'));           \\n\\n            for(int j=0;j<10;j++)\\n            {\\n                int new_mask = mask^(1<<j);\\n\\n                if(mp.find(new_mask)!=mp.end())\\n                ans=max(ans,i-mp[new_mask]);\\n            }\\n            if(mp.find(mask)==mp.end())\\n            mp[mask] = i;\\n            else \\n            ans = max(ans,i-mp[mask]);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798274,
                "title": "providing-a-link-pattern-can-anyone-do-this-question-with-same-pattern",
                "content": "https://leetcode.com/problems/minimum-window-substring/solutions/26808/Here-is-a-10-line-template-that-can-solve-most-\\'substring\\'-problems/\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3797684,
                "title": "bitmask-prefix-xor-explaination",
                "content": "if looked carefully, this question reduces to the problem which is a slight variation of the problem\\nhttps://leetcode.com/problems/number-of-wonderful-substrings/\\n\\nif we want to make a substing palindrome, it either could have even length or odd length, for even length palindrome, we need all the constituting characters to occur even number of times, \\nand to have a palindrome of odd length, we need all the other characters to occur even number of times except that one character at the middle which will occur once. \\n\\nSo, at last the problem reduces to finding the length of longest substring that has at most 1 character that occurs odd number of times.\\n\\nhere is the solution, we will be storing the first index of every prefix xor.\\n\\nclass Solution {\\npublic:\\n\\n    int longestAwesome(string s) {\\n\\t\\n        // i think the question reduces to finding the longest substring having at at most one character that occurs odd number of times\\n        \\n        int mask=0;\\n        unordered_map<int,int> m;\\n        \\n        m[0]=-1; // prefix xor and its index\\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            mask^= (1<<(s[i]-\\'0\\'));\\n            \\n            if(m.count(mask^0))\\n                ans= max(ans,i-m[mask^0]);\\n            \\n            for(int k=0;k<32;k++)\\n            {\\n                int copy= mask;\\n                \\n                copy^=(1<<k);\\n                \\n                if(m.count(copy))\\n                    ans= max(ans,i-m[copy]);\\n            }\\n            if(m.count(mask)==0)\\n                m[mask]=i;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestAwesome(string s) {\\n\\t\\n        // i think the question reduces to finding the longest substring having at at most one character that occurs odd number of times\\n        \\n        int mask=0;\\n        unordered_map<int,int> m;\\n        \\n        m[0]=-1; // prefix xor and its index\\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            mask^= (1<<(s[i]-\\'0\\'));\\n            \\n            if(m.count(mask^0))\\n                ans= max(ans,i-m[mask^0]);\\n            \\n            for(int k=0;k<32;k++)\\n            {\\n                int copy= mask;\\n                \\n                copy^=(1<<k);\\n                \\n                if(m.count(copy))\\n                    ans= max(ans,i-m[copy]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3704191,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n + 1] * (1 << 10)\\n        dp[0] = -1\\n        res, mask = 0, 0\\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n            res = max(res, i - dp[mask])\\n            for j in range(10):\\n                res = max(res, i - dp[mask ^ (1 << j)])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n + 1] * (1 << 10)\\n        dp[0] = -1\\n        res, mask = 0, 0\\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n            res = max(res, i - dp[mask])\\n            for j in range(10):\\n                res = max(res, i - dp[mask ^ (1 << j)])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700531,
                "title": "c-bitmask-and-prefix-sum-and-hashmaps",
                "content": "\\n# Code\\n```\\nclass Solution {\\n//find string having even parity for each character + \\n//string having at most one odd parity\\n\\n//find longest length of such string so we store smallest index for mask in dp[mask];\\n\\npublic:\\n    int longestAwesome(string s) {\\n        int res = 0, mask = 0;\\n        int n = s.length();\\n        //dp[i] = min index for the prefix having parity corrosponding to i(mask);\\n        vector<int> dp(1024, 200000);\\n        dp[0] = -1;\\n        for(int i=0;i<n; i++){\\n            mask = mask ^ (1<<(s[i]-\\'0\\'));\\n            //check for the mask containig even no. of items;\\n            res = max(res, i-dp[mask]);\\n            //cehck for the mask containing all  even no. of items except one;\\n            for(int j=0; j<=9; j++){\\n                int newmask = mask^(1<<j);\\n                res = max(res, i-dp[newmask]);\\n            }\\n            dp[mask] = min(dp[mask], i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n//find string having even parity for each character + \\n//string having at most one odd parity\\n\\n//find longest length of such string so we store smallest index for mask in dp[mask];\\n\\npublic:\\n    int longestAwesome(string s) {\\n        int res = 0, mask = 0;\\n        int n = s.length();\\n        //dp[i] = min index for the prefix having parity corrosponding to i(mask);\\n        vector<int> dp(1024, 200000);\\n        dp[0] = -1;\\n        for(int i=0;i<n; i++){\\n            mask = mask ^ (1<<(s[i]-\\'0\\'));\\n            //check for the mask containig even no. of items;\\n            res = max(res, i-dp[mask]);\\n            //cehck for the mask containing all  even no. of items except one;\\n            for(int j=0; j<=9; j++){\\n                int newmask = mask^(1<<j);\\n                res = max(res, i-dp[newmask]);\\n            }\\n            dp[mask] = min(dp[mask], i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375935,
                "title": "swift-bit-mask-and-dictionary",
                "content": "# Intuition\\nwe use a mask to track the number of each digit we have seen. For example, if we have seen an even number of digit 7, we would set 0 in the 7th bit position in the mask, otherwise we set it to 1.\\nWe also use a dictionary to track the first position we have seen this mask.\\nThen we use bit manipulation to test if there exist a subarray that has only one single digit, or no single digit.\\n\\n# Code\\n```\\nclass Solution {\\n    func longestAwesome(_ s: String) -> Int {\\n        let s = Array(s)\\n        var visited = [Int: Int]()\\n        visited[0] = -1\\n        var mask = 0\\n        var res = 0\\n        for i in 0..<s.count {\\n            let c = s[i]\\n            let bit = c.asciiValue! - Character(\"0\").asciiValue!\\n            mask ^= 1 << bit\\n            for (old_mask, index) in visited {\\n                var diff = mask ^ old_mask\\n                if diff == 0 || ((diff & (diff - 1)) == 0) {\\n                    res = max(i - index, res)\\n                }\\n            }\\n            if visited[mask] == nil {\\n                visited[mask] = i\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestAwesome(_ s: String) -> Int {\\n        let s = Array(s)\\n        var visited = [Int: Int]()\\n        visited[0] = -1\\n        var mask = 0\\n        var res = 0\\n        for i in 0..<s.count {\\n            let c = s[i]\\n            let bit = c.asciiValue! - Character(\"0\").asciiValue!\\n            mask ^= 1 << bit\\n            for (old_mask, index) in visited {\\n                var diff = mask ^ old_mask\\n                if diff == 0 || ((diff & (diff - 1)) == 0) {\\n                    res = max(i - index, res)\\n                }\\n            }\\n            if visited[mask] == nil {\\n                visited[mask] = i\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319065,
                "title": "c-solution-explained-why-need-for-bitmanipulation-or-hashmap-easy-peasy",
                "content": "# Intuition\\nis we have observed a state of mask before it has occured now,then an even length palindrome has occured since all the characters which occured have count as even, or if some other mask has occured before which has 1 bit different than the current mask,this means a odd length palindrome has occured,as they have only one character having odd count and all others even count.Also if the mask has become zero or only one bit is sent in the mask means that from the indx=0 to the current index either even length or odd length palindrome has occured respectively.\\n\\nWe need to make a check on the above three conditions also if a mask has not occured yet we will store its value int he hashtable with value as current index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        //using a count of digits occuring is bad in this case ,because it will not tell us that which occuring digits don\\'t match.\\n        //masking will help us to store a state that has occured previously.\\n        //thus using masking we can solve the question easily.\\n\\n        int mask=0;\\n        int ans = 1;\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        for(int i=0;i<s.size();i++){\\n            int digit = s[i]-\\'0\\';\\n            int p = 1<<digit;\\n            mask^=p;\\n            if(!mp.count(mask)){\\n                mp[mask] = i;\\n            }else{\\n                ans = max(ans,i-mp[mask]);\\n            }\\n\\n            if(mask&(mask-1)==0){\\n                ans = max(ans,i+1);\\n            }\\n\\n            for(int j=0;j<10;j++){\\n                int nmask = mask^(1<<j);\\n                if(mp.count(nmask)){\\n                    ans = max(ans,i-mp[nmask]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        //using a count of digits occuring is bad in this case ,because it will not tell us that which occuring digits don\\'t match.\\n        //masking will help us to store a state that has occured previously.\\n        //thus using masking we can solve the question easily.\\n\\n        int mask=0;\\n        int ans = 1;\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        for(int i=0;i<s.size();i++){\\n            int digit = s[i]-\\'0\\';\\n            int p = 1<<digit;\\n            mask^=p;\\n            if(!mp.count(mask)){\\n                mp[mask] = i;\\n            }else{\\n                ans = max(ans,i-mp[mask]);\\n            }\\n\\n            if(mask&(mask-1)==0){\\n                ans = max(ans,i+1);\\n            }\\n\\n            for(int j=0;j<10;j++){\\n                int nmask = mask^(1<<j);\\n                if(mp.count(nmask)){\\n                    ans = max(ans,i-mp[nmask]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217020,
                "title": "bitmask-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int>mp;  //mask->index\\n        int mask=0,ans=0;\\n        //string of is if length 0\\n        mp[0]=-1;\\n        for(int i=0;i<s.size();i++){\\n            mask^=(1<<(s[i]-\\'0\\'));\\n           \\n           //if mask already exist\\n           if(mp.count(mask)){\\n               //if mask is present then calculate the maximum\\n               ans=max(ans,i-mp[mask]);\\n           }else{\\n               mp[mask]=i;   //if msk does not exist then store its index\\n           }\\n\\n           //for odd length the mask can differ by at most one bit\\n           for(int j=0;j<10;j++){\\n               if(mp.count(mask^(1<<j))){\\n                   ans=max(ans,i-mp[mask^(1<<j)]);\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int>mp;  //mask->index\\n        int mask=0,ans=0;\\n        //string of is if length 0\\n        mp[0]=-1;\\n        for(int i=0;i<s.size();i++){\\n            mask^=(1<<(s[i]-\\'0\\'));\\n           \\n           //if mask already exist\\n           if(mp.count(mask)){\\n               //if mask is present then calculate the maximum\\n               ans=max(ans,i-mp[mask]);\\n           }else{\\n               mp[mask]=i;   //if msk does not exist then store its index\\n           }\\n\\n           //for odd length the mask can differ by at most one bit\\n           for(int j=0;j<10;j++){\\n               if(mp.count(mask^(1<<j))){\\n                   ans=max(ans,i-mp[mask^(1<<j)]);\\n               }\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171125,
                "title": "hashmap-prefix-bitmask-clean-code-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        // hashmap to store the index of the first\\n        // occurrence of a bitmask\\n        unordered_map<int,int> ind;\\n\\n        // the empty substring has no digits\\n        // hence its bitmask will be 0\\n        ind[0] = -1;\\n\\n        // A bitmask for keeping track of the occurrences of the digits.\\n        // In order for a substring to be awesome, the digits have to occur even number of times and atmost 1\\n        // digit can occur odd number of times. Whenever we see a digit in the substring, we toggle the bit\\n        // corresponding to that digit in the bitmask, hence after we go through the entire substring\\n        // If the ith bit is 1, then it means that the digit i occurs odd number of times (1, 3, 5, ....)\\n        // If the ith bit is 0, then it means that the digit i occurs even number of times (0, 2, 4, ....).\\n        // Therefore, for a substring to be awesome, the count of set bits in the bitmask has to be 0 or 1.\\n        int mask = 0;\\n\\n        // the length of the longest awesome substring\\n        int maxlen = 0;\\n\\n        // go through all the digits in the string\\n        for(int i=0; i<s.size(); i++) {\\n            // toggle the bit corresponding to the digit\\n            mask ^= (1<<(s[i]-\\'0\\'));\\n\\n            // if we have seen this bitmask before, then it means that there\\n            // is a substring with all even occurrences of digits.\\n            if(ind.count(mask)) {\\n                // find the length of the substring\\n                maxlen = max(maxlen, i - ind[mask]);\\n            }\\n            // if we haven\\'t seen this bitmask before\\n            else {\\n                // note the index of the first occurrence of the bitmask\\n                ind[mask] = i;\\n            }\\n\\n            // check for bitmasks that differ from the current bitmask by 1 bit.\\n            for(int j=0; j<10; j++) {\\n                if(ind.count(mask ^ (1<<j))) {\\n                    // awesome substring with 1 odd occurrence of a digit\\n                    maxlen = max(maxlen, i - ind[mask ^ (1<<j)]);\\n                }\\n            }\\n        }\\n\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        // hashmap to store the index of the first\\n        // occurrence of a bitmask\\n        unordered_map<int,int> ind;\\n\\n        // the empty substring has no digits\\n        // hence its bitmask will be 0\\n        ind[0] = -1;\\n\\n        // A bitmask for keeping track of the occurrences of the digits.\\n        // In order for a substring to be awesome, the digits have to occur even number of times and atmost 1\\n        // digit can occur odd number of times. Whenever we see a digit in the substring, we toggle the bit\\n        // corresponding to that digit in the bitmask, hence after we go through the entire substring\\n        // If the ith bit is 1, then it means that the digit i occurs odd number of times (1, 3, 5, ....)\\n        // If the ith bit is 0, then it means that the digit i occurs even number of times (0, 2, 4, ....).\\n        // Therefore, for a substring to be awesome, the count of set bits in the bitmask has to be 0 or 1.\\n        int mask = 0;\\n\\n        // the length of the longest awesome substring\\n        int maxlen = 0;\\n\\n        // go through all the digits in the string\\n        for(int i=0; i<s.size(); i++) {\\n            // toggle the bit corresponding to the digit\\n            mask ^= (1<<(s[i]-\\'0\\'));\\n\\n            // if we have seen this bitmask before, then it means that there\\n            // is a substring with all even occurrences of digits.\\n            if(ind.count(mask)) {\\n                // find the length of the substring\\n                maxlen = max(maxlen, i - ind[mask]);\\n            }\\n            // if we haven\\'t seen this bitmask before\\n            else {\\n                // note the index of the first occurrence of the bitmask\\n                ind[mask] = i;\\n            }\\n\\n            // check for bitmasks that differ from the current bitmask by 1 bit.\\n            for(int j=0; j<10; j++) {\\n                if(ind.count(mask ^ (1<<j))) {\\n                    // awesome substring with 1 odd occurrence of a digit\\n                    maxlen = max(maxlen, i - ind[mask ^ (1<<j)]);\\n                }\\n            }\\n        }\\n\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167295,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn longest_awesome(s: String) -> i32 {\\n        use std::collections::HashMap;\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        let mut mask = 0;\\n        let mut ans = 0;\\n        map.insert(0, -1);\\n        for (i, c) in s.bytes().enumerate() {\\n            mask ^= 1 << (c - b\\'0\\');\\n            if let Some(&j) = map.get(&mask) {\\n                ans = ans.max(i as i32 - j);\\n            }\\n            for k in 0..10 {\\n                let mask2 = mask ^ (1 << k);\\n                if let Some(&j) = map.get(&mask2) {\\n                    ans = ans.max(i as i32 - j);\\n                }\\n            }\\n            map.entry(mask).or_insert(i as i32);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_awesome(s: String) -> i32 {\\n        use std::collections::HashMap;\\n        let mut map: HashMap<i32, i32> = HashMap::new();\\n        let mut mask = 0;\\n        let mut ans = 0;\\n        map.insert(0, -1);\\n        for (i, c) in s.bytes().enumerate() {\\n            mask ^= 1 << (c - b\\'0\\');\\n            if let Some(&j) = map.get(&mask) {\\n                ans = ans.max(i as i32 - j);\\n            }\\n            for k in 0..10 {\\n                let mask2 = mask ^ (1 << k);\\n                if let Some(&j) = map.get(&mask2) {\\n                    ans = ans.max(i as i32 - j);\\n                }\\n            }\\n            map.entry(mask).or_insert(i as i32);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143256,
                "title": "simple-java-presum-bitmask-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(2^9)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int n = s.length();\\n        int[] preSum = new int[1 << 9 + 1];\\n        Arrays.fill(preSum, n);\\n        preSum[0] = -1;\\n        int res = 0;\\n        int mask = 0;\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n            mask ^= 1 << (c - \\'0\\');\\n            res = Math.max(res, i - preSum[mask]);\\n            for (int j = 0; j < 10; j++) {\\n                res = Math.max(res, i - preSum[mask ^ (1 << j)]);\\n            }\\n            if (preSum[mask] == n) preSum[mask] = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int n = s.length();\\n        int[] preSum = new int[1 << 9 + 1];\\n        Arrays.fill(preSum, n);\\n        preSum[0] = -1;\\n        int res = 0;\\n        int mask = 0;\\n        for (int i = 0; i < n; i++) {\\n            char c = s.charAt(i);\\n            mask ^= 1 << (c - \\'0\\');\\n            res = Math.max(res, i - preSum[mask]);\\n            for (int j = 0; j < 10; j++) {\\n                res = Math.max(res, i - preSum[mask ^ (1 << j)]);\\n            }\\n            if (preSum[mask] == n) preSum[mask] = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115576,
                "title": "python-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we are looking for the longest substring that is an awesome string. An awesome string is a string that has an even number of each digit from 0-9. To solve this problem, we can use dynamic programming to keep track of the longest substring that is an awesome string at each index of the input string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use dynamic programming to solve this problem. We can create an array, `dp`, of length 10 to keep track of the longest substring that is an awesome string at each index of the string. We can also keep track of the current mask of the substring, which is a bitmask that stores the count of each digit in the current substring. To calculate the longest awesome substring at each index, we can iterate through the string and update the mask and the `dp` array accordingly. At each index, we can check if the current substring is an awesome string. If it is, we can update the `dp` array and the longest substring length. \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n + 1] * (1 << 10)\\n        dp[0] = -1\\n        res, mask = 0, 0\\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n            res = max(res, i - dp[mask])\\n            for j in range(10):\\n                res = max(res, i - dp[mask ^ (1 << j)])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        n = len(s)\\n        dp = [n + 1] * (1 << 10)\\n        dp[0] = -1\\n        res, mask = 0, 0\\n        for i in range(n):\\n            mask ^= 1 << int(s[i])\\n            res = max(res, i - dp[mask])\\n            for j in range(10):\\n                res = max(res, i - dp[mask ^ (1 << j)])\\n            dp[mask] = min(dp[mask], i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115571,
                "title": "c-solution-masking-technique-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom the problem statement, it is clear that we have to find the longest substring in the given string which has even number of occurrences for each digit from 0 to 9. To accomplish this, we can use a bit masking technique to track the occurrence of each digit in the current substring. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use a bit masking technique to track the occurrence of each digit in the current substring. We use a bit mask of length 10 with each bit representing the occurrence of a digit in the current substring. Initially, all the bits in the mask are set to 0. We traverse through the string and everytime we encounter a digit we toggle the corresponding bit in the mask. We also maintain an array pos of length 1024 which stores the index of the last occurence of each mask. We also maintain a variable mask which stores the current bit mask. \\n\\nWe use the variable res to store the length of the longest awesome substring. For every index, we update the res variable by taking the maximum of the current index minus the last index corresponding to the current mask and current index minus the last index corresponding to the current mask with all its bits toggled. \\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int res = 0, n = s.size();\\n        vector<int> pos(1 << 10, n); // pos array of length 1024 to store the last index of each mask\\n        pos[0] = -1; // initially setting the last index corresponding to 0 mask to -1\\n        int mask = 0;\\n        for (int i = 0; i < n; ++i) {\\n            mask ^= 1 << (s[i] - \\'0\\'); // toggling the bit corresponding to the current digit\\n            res = max(res, i - pos[mask]); // updating the res variable with the current index minus the last index corresponding to the current mask\\n            for (int j = 0; j < 10; ++j) \\n                res = max(res, i - pos[mask ^ (1 << j)]); // updating the res variable with the current index minus the last index corresponding to the current mask with all its bits toggled\\n            pos[mask] = min(pos[mask], i); // updating the last index corresponding to the current mask\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int res = 0, n = s.size();\\n        vector<int> pos(1 << 10, n); // pos array of length 1024 to store the last index of each mask\\n        pos[0] = -1; // initially setting the last index corresponding to 0 mask to -1\\n        int mask = 0;\\n        for (int i = 0; i < n; ++i) {\\n            mask ^= 1 << (s[i] - \\'0\\'); // toggling the bit corresponding to the current digit\\n            res = max(res, i - pos[mask]); // updating the res variable with the current index minus the last index corresponding to the current mask\\n            for (int j = 0; j < 10; ++j) \\n                res = max(res, i - pos[mask ^ (1 << j)]); // updating the res variable with the current index minus the last index corresponding to the current mask with all its bits toggled\\n            pos[mask] = min(pos[mask], i); // updating the last index corresponding to the current mask\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929056,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size(), res = 0, seen[1024]{[0]=-1,[1 ... 1023]=n};\\n        for(int i = 0, cur = 0; i < n; i++) {\\n            cur ^= (1 << (s[i]-\\'0\\'));\\n            for(int j = 0; j < 10; j++) res = max(res, i-seen[cur^(1 << j)]);\\n            res = max(res, i-seen[cur]);\\n            seen[cur] = min(i, seen[cur]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size(), res = 0, seen[1024]{[0]=-1,[1 ... 1023]=n};\\n        for(int i = 0, cur = 0; i < n; i++) {\\n            cur ^= (1 << (s[i]-\\'0\\'));\\n            for(int j = 0; j < 10; j++) res = max(res, i-seen[cur^(1 << j)]);\\n            res = max(res, i-seen[cur]);\\n            seen[cur] = min(i, seen[cur]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913431,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(10 * n)\\n\\n- Space complexity:\\nO(1024)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        static const int ALPHABET_SIZE = 10;\\n        int result = 0, mask = 0;\\n        vector<int> lookup(1 << ALPHABET_SIZE, s.length());\\n        lookup[0] = -1;\\n        for (int i = 0; i < s.length(); ++i) {\\n            mask ^= 1 << (s[i] - \\'0\\');\\n            if (lookup[mask] == s.length()) {\\n                lookup[mask] = i;\\n            }\\n            result = max(result, i - lookup[mask]);  // no middle\\n            for (int d = 0; d < ALPHABET_SIZE; ++d) {\\n                result = max(result, i - lookup[mask  ^ (1 << d)]); // as middle\\n            }\\n            lookup[mask] = min(lookup[mask], i);\\n        }      \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        static const int ALPHABET_SIZE = 10;\\n        int result = 0, mask = 0;\\n        vector<int> lookup(1 << ALPHABET_SIZE, s.length());\\n        lookup[0] = -1;\\n        for (int i = 0; i < s.length(); ++i) {\\n            mask ^= 1 << (s[i] - \\'0\\');\\n            if (lookup[mask] == s.length()) {\\n                lookup[mask] = i;\\n            }\\n            result = max(result, i - lookup[mask]);  // no middle\\n            for (int d = 0; d < ALPHABET_SIZE; ++d) {\\n                result = max(result, i - lookup[mask  ^ (1 << d)]); // as middle\\n            }\\n            lookup[mask] = min(lookup[mask], i);\\n        }      \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776195,
                "title": "use-bitmask-of-10-letters-as-states",
                "content": "# Approach\\nSince there\\'s only 10 possible letters/numbers, we can remember the state for each position, where the state can be defined as if the frequency of one number is even or odd.\\n\\nAt any position, we can check if there\\'s a previous position, who share the same state (same even/oddness for each number), if there is, we can use that position to form a palindrome, since excluding it will give us even number of each kind of letters.\\n```\\n[...a...] b\\n\\ndiff(a,b) = {x: 0, y: 1}\\n            {x: 0}\\n\\n 0 1 2 3 4 5 6\\n e o e o e o e  -- original state\\n e o e o e o e  -- if the same state existed before, we can for a palindrome with no center (even palindrome)\\n o o e o e o e  -- toggle one letter, try forming an odd palindrome with a center letter\\n ^\\n e e e o e o e  -- toggle one letter, try forming an odd palindrome with a center letter\\n   ^\\n```\\n\\n# Complexity\\nSince we only have 10 letters (0-9), b = 10.\\n\\n- Time complexity: O(b*n)\\n\\n- Space complexity: O(2^(b+1))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> D(1<<11,-2), F(10, 0);\\n        D[0] = -1;\\n        int res = 1;\\n        auto make_mask = [&]() {\\n            int mask = 0;\\n            for (int j = 0, b = 1; j <= 9; ++j, b<<=1) {\\n                if (F[j]&1) mask += b;\\n            }\\n            return mask;\\n        };\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            ++F[s[i]-\\'0\\'];\\n            int mask = make_mask();\\n            for (int b = 1, j = 0; j <= 9; ++j, b <<= 1) {\\n                if (F[j] <= 0) continue;\\n                mask ^= b;\\n                if (D[mask] >= -1) res = max(res, i-D[mask]);\\n                mask ^= b;\\n            }\\n            if (D[mask] >= -1) res = max(res, i-D[mask]);\\n            else D[mask] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n[...a...] b\\n\\ndiff(a,b) = {x: 0, y: 1}\\n            {x: 0}\\n\\n 0 1 2 3 4 5 6\\n e o e o e o e  -- original state\\n e o e o e o e  -- if the same state existed before, we can for a palindrome with no center (even palindrome)\\n o o e o e o e  -- toggle one letter, try forming an odd palindrome with a center letter\\n ^\\n e e e o e o e  -- toggle one letter, try forming an odd palindrome with a center letter\\n   ^\\n```\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> D(1<<11,-2), F(10, 0);\\n        D[0] = -1;\\n        int res = 1;\\n        auto make_mask = [&]() {\\n            int mask = 0;\\n            for (int j = 0, b = 1; j <= 9; ++j, b<<=1) {\\n                if (F[j]&1) mask += b;\\n            }\\n            return mask;\\n        };\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            ++F[s[i]-\\'0\\'];\\n            int mask = make_mask();\\n            for (int b = 1, j = 0; j <= 9; ++j, b <<= 1) {\\n                if (F[j] <= 0) continue;\\n                mask ^= b;\\n                if (D[mask] >= -1) res = max(res, i-D[mask]);\\n                mask ^= b;\\n            }\\n            if (D[mask] >= -1) res = max(res, i-D[mask]);\\n            else D[mask] = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755418,
                "title": "simple-clean-bitmask-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n    unordered_map<int,int>mp;\\n    int result=0;\\n    for (int i=0;i<10;i++)\\n    {\\n        mp[i]=(1<<i);\\n    }\\n        \\n// set bit denotes current element has occured odd number of times\\n// when we are at i , we calculate length of longest substring ending at index i which can be made as a palindrome\\n        \\n    unordered_map<int,int> maskedindex;\\n    int mask=0;\\n    maskedindex[0]=-1;\\n    for (int i=0;i<s.size();i++)\\n    {\\n        mask=mask^(mp[s[i]-\\'0\\']);\\n        for (int j=0;j<10;j++)\\n        {\\n            \\n            mask=mask^(mp[j]);\\n           if (maskedindex.find(mask)!=maskedindex.end())\\n           {\\n            result=max(result,i-maskedindex[mask]);\\n           }\\n         mask=mask^(mp[j]);   \\n        }\\n        \\n        if (maskedindex.find(mask)==maskedindex.end())\\n            maskedindex[mask]=i;\\n        else\\n        {\\n            result=max(result,i-maskedindex[mask]);\\n        }\\n  \\n        \\n    }\\n        \\n        return result;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n    unordered_map<int,int>mp;\\n    int result=0;\\n    for (int i=0;i<10;i++)\\n    {\\n        mp[i]=(1<<i);\\n    }\\n        \\n// set bit denotes current element has occured odd number of times\\n// when we are at i , we calculate length of longest substring ending at index i which can be made as a palindrome\\n        \\n    unordered_map<int,int> maskedindex;\\n    int mask=0;\\n    maskedindex[0]=-1;\\n    for (int i=0;i<s.size();i++)\\n    {\\n        mask=mask^(mp[s[i]-\\'0\\']);\\n        for (int j=0;j<10;j++)\\n        {\\n            \\n            mask=mask^(mp[j]);\\n           if (maskedindex.find(mask)!=maskedindex.end())\\n           {\\n            result=max(result,i-maskedindex[mask]);\\n           }\\n         mask=mask^(mp[j]);   \\n        }\\n        \\n        if (maskedindex.find(mask)==maskedindex.end())\\n            maskedindex[mask]=i;\\n        else\\n        {\\n            result=max(result,i-maskedindex[mask]);\\n        }\\n  \\n        \\n    }\\n        \\n        return result;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737239,
                "title": "java-efficient-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    public int longestAwesome(String s) {\\n        \\n        // We only need to care about if a digit appears odd or even number of times.\\n        // Since the total number of digits is 10, the number of possible states is\\n        // (1<<10) == 1024\\n        int[] idxFirstAppearance = new int[1<<10]; // index where a state first appears\\n        Arrays.fill(idxFirstAppearance, Integer.MIN_VALUE);\\n        idxFirstAppearance[0] = -1;\\n        \\n        int mask = 0; // initial state\\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            int idx = s.charAt(i) - \\'0\\';\\n            \\n            // Case 1: all digits appear even number of times\\n            mask ^= (1 << idx); // update state\\n            \\n            if (idxFirstAppearance[mask] == Integer.MIN_VALUE)\\n                idxFirstAppearance[mask] = i;\\n            else\\n                ans = Math.max(ans, i-idxFirstAppearance[mask]);\\n            \\n            // Case 2: all digits but one appear even number of times\\n            for (int j=0; j<10; j++) {\\n                \\n                int temp = mask ^ (1 << j);\\n                \\n                ans = Math.max(ans, i-idxFirstAppearance[temp]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int longestAwesome(String s) {\\n        \\n        // We only need to care about if a digit appears odd or even number of times.\\n        // Since the total number of digits is 10, the number of possible states is\\n        // (1<<10) == 1024\\n        int[] idxFirstAppearance = new int[1<<10]; // index where a state first appears\\n        Arrays.fill(idxFirstAppearance, Integer.MIN_VALUE);\\n        idxFirstAppearance[0] = -1;\\n        \\n        int mask = 0; // initial state\\n        int ans = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            \\n            int idx = s.charAt(i) - \\'0\\';\\n            \\n            // Case 1: all digits appear even number of times\\n            mask ^= (1 << idx); // update state\\n            \\n            if (idxFirstAppearance[mask] == Integer.MIN_VALUE)\\n                idxFirstAppearance[mask] = i;\\n            else\\n                ans = Math.max(ans, i-idxFirstAppearance[mask]);\\n            \\n            // Case 2: all digits but one appear even number of times\\n            for (int j=0; j<10; j++) {\\n                \\n                int temp = mask ^ (1 << j);\\n                \\n                ans = Math.max(ans, i-idxFirstAppearance[temp]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650665,
                "title": "where-i-went-wrong-using-a-dictionary-and-python3-when-i-found-93139-from-9498331",
                "content": "I thought I had a clever solution to this as I don\\'t really know how to use bitmasks, so I basically used a dictionary instead to store the occurences of each character, and then since there can be unlimited swaps, I created a new string based on each value that is greater than 2 in my dictionary. \\n\\nFor the awesome string, I built it using the half + single + half reflected and then counted the length. \\n\\nWhy should this testcase be 3 as the longest instead of 5? \\n\\nWrong Answer\\nDetails\\nInput\\n\"9498331\"\\nstdout\\n93439\\n\\nOutput\\n5\\nExpected\\n3\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        number_of_ch = {}\\n        \\n        #Read the string character by character into a dict\\n        #Key is the ch, value is the # of char found in the string. \\n        for ch in s:\\n            if number_of_ch.get(ch) is not None:\\n                number_of_ch.update({ch:number_of_ch[ch] + 1})\\n            else: \\n                number_of_ch[ch] = 1\\n                    \\n        #Create palindrome from the values in the dict. \\n        #When the value in the dict is >= 2 then we can add that value to beginning and end of the awesome string, and then reduce the value of the char by 2.\\n        single_used = False\\n        single_ch = \\'\\'\\n        awesome_half = \\'\\'\\n\\n        for ch in number_of_ch.keys():\\n            if number_of_ch.get(ch) >= 2:\\n                multi = (int(number_of_ch.get(ch) / 2))\\n                awesome_half = awesome_half + multi * str(ch)\\n                number_of_ch.update({ch:number_of_ch[ch] % 2})\\n            elif single_used == False and number_of_ch.get(ch) == 1:\\n                single_ch = ch\\n                number_of_ch.update({ch:number_of_ch[ch] - 1})\\n                single_used = True\\n        awesome = awesome_half + single_ch + awesome_half[::-1]\\n        \\n        print(awesome)\\n        return len(awesome)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        number_of_ch = {}\\n        \\n        #Read the string character by character into a dict\\n        #Key is the ch, value is the # of char found in the string. \\n        for ch in s:\\n            if number_of_ch.get(ch) is not None:\\n                number_of_ch.update({ch:number_of_ch[ch] + 1})\\n            else: \\n                number_of_ch[ch] = 1\\n                    \\n        #Create palindrome from the values in the dict. \\n        #When the value in the dict is >= 2 then we can add that value to beginning and end of the awesome string, and then reduce the value of the char by 2.\\n        single_used = False\\n        single_ch = \\'\\'\\n        awesome_half = \\'\\'\\n\\n        for ch in number_of_ch.keys():\\n            if number_of_ch.get(ch) >= 2:\\n                multi = (int(number_of_ch.get(ch) / 2))\\n                awesome_half = awesome_half + multi * str(ch)\\n                number_of_ch.update({ch:number_of_ch[ch] % 2})\\n            elif single_used == False and number_of_ch.get(ch) == 1:\\n                single_ch = ch\\n                number_of_ch.update({ch:number_of_ch[ch] - 1})\\n                single_used = True\\n        awesome = awesome_half + single_ch + awesome_half[::-1]\\n        \\n        print(awesome)\\n        return len(awesome)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2627565,
                "title": "easy-short-clean-efficient-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int longestAwesome(const string&s) {\\n        ll n=s.size(), bm=0, ans=1;\\n        vi(ll)ump(1024, n);\\n        ump[0]=-1;\\n        for(ll i=0;i<n;++i){\\n            bm^=1<<(s[i]-\\'0\\');\\n            ans=max(ans, i-ump[bm]);\\n            for(ll j=0;j<10;++j){\\n                ans=max(ans, i-ump[bm^(1<<j)]);\\n            }\\n            ump[bm]=min(ump[bm], i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int longestAwesome(const string&s) {\\n        ll n=s.size(), bm=0, ans=1;\\n        vi(ll)ump(1024, n);\\n        ump[0]=-1;\\n        for(ll i=0;i<n;++i){\\n            bm^=1<<(s[i]-\\'0\\');\\n            ans=max(ans, i-ump[bm]);\\n            for(ll j=0;j<10;++j){\\n                ans=max(ans, i-ump[bm^(1<<j)]);\\n            }\\n            ump[bm]=min(ump[bm], i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569852,
                "title": "c-bitmask-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int, int>where;\\n        int cur=0;\\n        where[cur] = -1;\\n        int n=s.size();\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            int dig = s[i]-\\'0\\';\\n            cur^=(1<<dig); //flip \\'dig\\' bit\\n            \\n            if(where.find(cur)!=where.end())\\n                ans = max(ans, i-where[cur]); //all even characters\\n            \\n            for(int bit = 0; bit<10; bit++){\\n                int better = cur^(1<<bit); //allowing the \\'bit\\' bit to be odd in the substring\\n                if(where.find(better)!=where.end())\\n                    ans = max(ans, i-where[better]); //one odd, others even\\n            }\\n            \\n            if(where.find(cur)==where.end())\\n                where[cur]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int, int>where;\\n        int cur=0;\\n        where[cur] = -1;\\n        int n=s.size();\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            int dig = s[i]-\\'0\\';\\n            cur^=(1<<dig); //flip \\'dig\\' bit\\n            \\n            if(where.find(cur)!=where.end())\\n                ans = max(ans, i-where[cur]); //all even characters\\n            \\n            for(int bit = 0; bit<10; bit++){\\n                int better = cur^(1<<bit); //allowing the \\'bit\\' bit to be odd in the substring\\n                if(where.find(better)!=where.end())\\n                    ans = max(ans, i-where[better]); //one odd, others even\\n            }\\n            \\n            if(where.find(cur)==where.end())\\n                where[cur]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483621,
                "title": "without-bitmasking-c",
                "content": "cnt(j) --> number of occurences of j, till ith index.\\ncur_state --> string to represent the current state.\\n\\ncur_state(j) ->0 ==> j appears an even number of times till ith index.\\ncur_state(j) ->1 ==> j appears an odd number of times till ith index.\\n\\nLet cur_state for any arbitary index i = \"0100000000\"\\nThis means that 1 has appeared an odd number of times, till ith index and all other digits appeared \\n0 number of times.\\n\\nSince we want to find longest substring, for which the substring could be rearranged to a palindrome .\\nThis is possible in 2 cases\\ncase 1: if all the distinct characters in the substring appears an even number of time\\ncase 2: if all the distinct characters in the substring appears an even number of time, except for one character.\\n\\nany state that we encouter is stored in a hash map against the index where that state occured, if the same state  or a state such that only one index is altered occurs later in the traversal ==> the substring between them including the cur index and not including the prev index is a valid answer.\\nJust find the maximum length among all such valid answers.\\n\\n``\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        \\n        unordered_map<string, int>mp; // (state, earliest index where this state was seen).\\n        int n = s.size();\\n        \\n        mp[\"0000000000\"] = -1; \\n        \\n        int ans = 0;\\n        \\n        int cnt[10] = {};\\n        \\n        for(int i = 0; i<n; i++){\\n            \\n            cnt[s[i]-\\'0\\']++; // incrementing the count of cur_character.\\n            \\n            string cur_state = \"\"; // stores the cur_state.\\n            \\n            for(int j = 0; j<10; j++){\\n                \\n                if(cnt[j] % 2 ==0){\\n                    \\n                    cur_state+=\\'0\\';\\n                }\\n                else{\\n                    cur_state+=\\'1\\';\\n                }\\n            }\\n            \\n            // Case 1 : if same to same state was there earlier ==> all chars even substring ==> yes a palindrome.\\n            \\n            if(mp.find(cur_state) != mp.end()){\\n                ans = max(ans, i - mp[cur_state]);\\n                \\n                \\n            }\\n            \\n            else{\\n                mp[cur_state]  = i;\\n            }\\n            \\n          \\n           \\n            \\n            // Case 2 : if only one change..\\n            \\n            for(int j = 0; j<10; j++){\\n                \\n                \\n                // changing the state for the time being..\\n                \\n                if(cur_state[j]==\\'0\\'){\\n                    cur_state[j] = \\'1\\';\\n                }\\n                else{\\n                    cur_state[j] = \\'0\\';\\n                }\\n                \\n                if(mp.find(cur_state) != mp.end()){\\n                    ans = max(ans, i - mp[cur_state]);\\n                }\\n                \\n                // changing it back to original state.\\n                \\n                 if(cur_state[j]==\\'0\\'){\\n                    cur_state[j] = \\'1\\';\\n                }\\n                \\n                else{\\n                    cur_state[j] = \\'0\\';\\n                }\\n                \\n                \\n                 \\n            }\\n            \\n           \\n            \\n            \\n        }\\n        \\n     \\n        return ans;\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        \\n        unordered_map<string, int>mp; // (state, earliest index where this state was seen).\\n        int n = s.size();\\n        \\n        mp[\"0000000000\"] = -1; \\n        \\n        int ans = 0;\\n        \\n        int cnt[10] = {}",
                "codeTag": "Java"
            },
            {
                "id": 2413991,
                "title": "intresting-problem-c",
                "content": "```\\n  int longestAwesome(string A ) {\\n        \\n        int N = A.size();\\n        string t(10,0);\\n        unordered_map< string , int > M ;\\n        M[t] = -1 ;\\n        int res = 0 ;\\n        \\n        for( int i = 0 ; i < N ; i++ )\\n        {\\n            int v = A[i]-\\'0\\';\\n            t[v] ^= 1 ;\\n            \\n            // even count \\n            if( M.find(t) != M.end() )\\n                res = max( res , i-M[t]);\\n            // one odd count \\n            for( int j = 0 ; j < 10 ; j++ )\\n            {\\n                t[j] ^= 1;\\n                \\n                if( M.find(t) != M.end() )\\n                    res = max( res , i-M[t] );\\n                \\n                t[j] ^= 1;\\n            }\\n            \\n            if( M.find(t) == M.end() )\\n                M[t] = i ;\\n        }\\n        return res ;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int longestAwesome(string A ) {\\n        \\n        int N = A.size();\\n        string t(10,0);\\n        unordered_map< string , int > M ;\\n        M[t] = -1 ;\\n        int res = 0 ;\\n        \\n        for( int i = 0 ; i < N ; i++ )\\n        {\\n            int v = A[i]-\\'0\\';\\n            t[v] ^= 1 ;\\n            \\n            // even count \\n            if( M.find(t) != M.end() )\\n                res = max( res , i-M[t]);\\n            // one odd count \\n            for( int j = 0 ; j < 10 ; j++ )\\n            {\\n                t[j] ^= 1;\\n                \\n                if( M.find(t) != M.end() )\\n                    res = max( res , i-M[t] );\\n                \\n                t[j] ^= 1;\\n            }\\n            \\n            if( M.find(t) == M.end() )\\n                M[t] = i ;\\n        }\\n        return res ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408929,
                "title": "c-bit-manipulation-bitmasking-string",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint longestAwesome(string s) {\\n\\n\\t\\t\\tunordered_map<int , int> mp;\\n\\t\\t\\tmp[0] = -1;\\n\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint len = 0;\\n\\t\\t\\tint curr = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\n\\t\\t\\t\\tint mask = 1 << (s[i] - \\'0\\');\\n\\t\\t\\t\\tcurr ^= mask;\\n\\n\\t\\t\\t\\t/// case : 1\\n\\t\\t\\t\\t/// To check for all even position\\n\\t\\t\\t\\tif(mp.count(curr)){\\n\\t\\t\\t\\t   len = max(len , i - mp[curr]);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t/// case : 2\\n\\t\\t\\t\\t/// To make exactly one odd position\\n\\t\\t\\t\\tfor(int j = 0 ; j <= 9 ; j++){\\n\\t\\t\\t\\t\\tmask = 1 << j;\\n\\t\\t\\t\\t\\tif(mp.count(curr ^ mask)){\\n\\t\\t\\t\\t\\t   len = max(len , i - mp[curr ^ mask]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(mp.count(curr) == 0){\\n\\t\\t\\t\\t   mp[curr] = i;   \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn len;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "String",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint longestAwesome(string s) {\\n\\n\\t\\t\\tunordered_map<int , int> mp;\\n\\t\\t\\tmp[0] = -1;\\n\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint len = 0;\\n\\t\\t\\tint curr = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\n\\t\\t\\t\\tint mask = 1 << (s[i] - \\'0\\');\\n\\t\\t\\t\\tcurr ^= mask;\\n\\n\\t\\t\\t\\t/// case : 1\\n\\t\\t\\t\\t/// To check for all even position\\n\\t\\t\\t\\tif(mp.count(curr)){\\n\\t\\t\\t\\t   len = max(len , i - mp[curr]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2298662,
                "title": "java-bit-mask",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer,Integer>map=new HashMap<>();\\n        map.put(0,-1);\\n        \\n        int state=0;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            int bit=(1<<(s.charAt(i)-\\'0\\'));\\n            state ^=bit; //if odd freq then it becomes even or if even becomes odd\\n            \\n            if(map.containsKey(state))\\n               ans=Math.max(ans,i-map.get(state));\\n            \\n                for(int odd=0;odd<=9;odd++){ //become odds one by one\\n                    int mask=(1<<odd);\\n                    \\n                    Integer j=map.get(state^mask);\\n                    \\n                    if(j!=null)\\n                        ans=Math.max(ans,i-j);\\n                }\\n            \\n            if(!map.containsKey(state))\\n                map.put(state,i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer,Integer>map=new HashMap<>();\\n        map.put(0,-1);\\n        \\n        int state=0;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            int bit=(1<<(s.charAt(i)-\\'0\\'));\\n            state ^=bit; //if odd freq then it becomes even or if even becomes odd\\n            \\n            if(map.containsKey(state))\\n               ans=Math.max(ans,i-map.get(state));\\n            \\n                for(int odd=0;odd<=9;odd++){ //become odds one by one\\n                    int mask=(1<<odd);\\n                    \\n                    Integer j=map.get(state^mask);\\n                    \\n                    if(j!=null)\\n                        ans=Math.max(ans,i-j);\\n                }\\n            \\n            if(!map.containsKey(state))\\n                map.put(state,i);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277674,
                "title": "bit-masking-kind-of-not-really-using-bit-manipulation-just-the-concept",
                "content": "class Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        \\n        mask = [\"0\"]*10\\n        \\n        myhash = {}\\n        myhash[\"\".join(mask)] = -1\\n        ans = 1\\n        \\n        s2 = []\\n        for ch in s:\\n            s2.append(ch)\\n            \\n            \\n        for i,ch in enumerate(s2):\\n            \\n            ind = int(ch)\\n            \\n            if mask[ind] == \\'0\\':\\n                #occurs odd number of times\\n                mask[ind] = \\'1\\'\\n            else:\\n                #even number of times this has occured\\n                mask[ind] = \\'0\\'\\n            \\n            if \"\".join(mask) in myhash.keys():\\n                ans = max(i - myhash[\"\".join(mask)],ans)\\n                \\n            \\n            for ik in range(10):\\n                if mask[ik] == \\'0\\':\\n                    mask[ik] = \\'1\\'\\n                    if \"\".join(mask) in myhash.keys():\\n                        ans = max(i - myhash[\"\".join(mask)],ans)\\n                    mask[ik] = \\'0\\'\\n                    \\n                elif mask[ik] == \\'1\\':\\n                    mask[ik] = \\'0\\'\\n                    if \"\".join(mask) in myhash.keys():\\n                        ans = max(i - myhash[\"\".join(mask)],ans)\\n                    mask[ik] = \\'1\\'       \\n\\n            if \"\".join(mask) not in myhash.keys():\\n                myhash[\"\".join(mask)] = i\\n        \\n        \\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        \\n        mask = [\"0\"]*10\\n        \\n        myhash = {}",
                "codeTag": "Java"
            },
            {
                "id": 2249440,
                "title": "hashmap-python-solution",
                "content": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        cur = res = 0\\n        d = defaultdict(lambda:float(\\'inf\\'), {0:-1})\\n        for i, ch in enumerate(s):\\n            cur ^= 1 << int(ch)\\n            res = max(res, i-d[cur])\\n            for j in range(10):\\n                res = max(res, i-d[cur^(1<<j)])\\n            d[cur] = min(d[cur], i)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        cur = res = 0\\n        d = defaultdict(lambda:float(\\'inf\\'), {0:-1})\\n        for i, ch in enumerate(s):\\n            cur ^= 1 << int(ch)\\n            res = max(res, i-d[cur])\\n            for j in range(10):\\n                res = max(res, i-d[cur^(1<<j)])\\n            d[cur] = min(d[cur], i)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197275,
                "title": "easy-solution-java-t-o-n-s-o-2-10-with-array-and-s-o-n-with-hashmap",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        //Pre-requisite: just dry-run 1-2 times atleast to grab the deep insight behind the working of this code then u can easly understand this question\\n        \\n        //time Optimized approach uses large array instead of  hashmap\\n        Integer[]map = new Integer[(1 << 10)];//(1 << 10) -> 10000000000\\n        // HashMap<Integer,Integer>map = new HashMap<>();//map(state, index);\\n        map[0] = -1;\\n        \\n        int state = 0;\\n        int ans = 0;\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            int mask = (1 << (ch - \\'0\\'));\\n            state ^= mask;\\n            \\n            if(map[state] != null) {\\n                int j = map[state];\\n                ans = Math.max(ans, i - j);\\n            }\\n            \\n            for(int b = 0; b<10; b++) {\\n                mask = (1 << b);//state^mask -> togling of \\'bth\\' bit in the state variable\\n                \\n                if(map[state ^ mask] != null) {\\n                    int j = map[state ^ mask];\\n                    \\n                    ans = Math.max(ans, i - j);\\n                }\\n            }\\n            \\n            if(map[state] == null) {\\n                map[state] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        //Pre-requisite: just dry-run 1-2 times atleast to grab the deep insight behind the working of this code then u can easly understand this question\\n        \\n        //time Optimized approach uses large array instead of  hashmap\\n        Integer[]map = new Integer[(1 << 10)];//(1 << 10) -> 10000000000\\n        // HashMap<Integer,Integer>map = new HashMap<>();//map(state, index);\\n        map[0] = -1;\\n        \\n        int state = 0;\\n        int ans = 0;\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            int mask = (1 << (ch - \\'0\\'));\\n            state ^= mask;\\n            \\n            if(map[state] != null) {\\n                int j = map[state];\\n                ans = Math.max(ans, i - j);\\n            }\\n            \\n            for(int b = 0; b<10; b++) {\\n                mask = (1 << b);//state^mask -> togling of \\'bth\\' bit in the state variable\\n                \\n                if(map[state ^ mask] != null) {\\n                    int j = map[state ^ mask];\\n                    \\n                    ans = Math.max(ans, i - j);\\n                }\\n            }\\n            \\n            if(map[state] == null) {\\n                map[state] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171375,
                "title": "debug-the-code",
                "content": "please can anyone tell me what\\'s wrong in the following code if i am not using dp then it\\'s right ans. but while using dp it;s showing wrong ans. can someone help me to figure out what is wrong in  the following algo..\\n\\n\\nLogic---\\n\\nI have used the map for frequency and checking if the count of numbers whose frequency is odd if odd==1 or 2 then the number can become pallindrome other wise not \\n\\n```\\nclass Solution {\\npublic:\\n    int odd = 0;\\n    vector<vector<int>> dp;\\n    int find(string &str,int start,int end,unordered_map<char,int> m){\\n        \\n        if(start > end) return 0;\\n        if(dp[start][end] != -1){ return dp[start][end];}\\n        if(odd == 1 || odd == 0){ cout<<start<<\" \"<<end<<endl;   return dp[start][end] = end-start+1;}\\n    \\n        // we are going to first half\\n        int res = 0;\\n        if(m[str[end]]%2) odd--;\\n        else odd++;\\n        m[str[end]]--;\\n        \\n        res = find(str,start,end-1,m);\\n        \\n        if(m[str[end]]%2) odd++;\\n        else odd--;\\n        m[str[end]]++;\\n        \\n        if(m[str[start]]%2) odd--;\\n        else odd++;\\n        m[str[start]]--;\\n        \\n        res=max(res,find(str,start+1,end,m));\\n        if(m[str[start]]%2) odd++;\\n        else odd--;\\n        m[str[start]]++;\\n        \\n        return dp[start][end] = res;\\n        \\n    }\\n    \\n    int longestAwesome(string str){\\n        \\n        dp.resize(str.length(),vector<int>(str.length(),-1));\\n        unordered_map<char,int> m;\\n        for(auto x:str) m[x]++;\\n        \\n        for(auto x:m) {if(x.second%2) odd++;}\\n        return find(str,0,str.length()-1,m);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int odd = 0;\\n    vector<vector<int>> dp;\\n    int find(string &str,int start,int end,unordered_map<char,int> m){\\n        \\n        if(start > end) return 0;\\n        if(dp[start][end] != -1){ return dp[start][end];}\\n        if(odd == 1 || odd == 0){ cout<<start<<\" \"<<end<<endl;   return dp[start][end] = end-start+1;}\\n    \\n        // we are going to first half\\n        int res = 0;\\n        if(m[str[end]]%2) odd--;\\n        else odd++;\\n        m[str[end]]--;\\n        \\n        res = find(str,start,end-1,m);\\n        \\n        if(m[str[end]]%2) odd++;\\n        else odd--;\\n        m[str[end]]++;\\n        \\n        if(m[str[start]]%2) odd--;\\n        else odd++;\\n        m[str[start]]--;\\n        \\n        res=max(res,find(str,start+1,end,m));\\n        if(m[str[start]]%2) odd++;\\n        else odd--;\\n        m[str[start]]++;\\n        \\n        return dp[start][end] = res;\\n        \\n    }\\n    \\n    int longestAwesome(string str){\\n        \\n        dp.resize(str.length(),vector<int>(str.length(),-1));\\n        unordered_map<char,int> m;\\n        for(auto x:str) m[x]++;\\n        \\n        for(auto x:m) {if(x.second%2) odd++;}\\n        return find(str,0,str.length()-1,m);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2145739,
                "title": "python-bitmask-clean-code",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        mask = 0\\n        index = defaultdict(lambda:float(\\'-inf\\'),{0:-1})\\n        res = 0\\n        for i,c in enumerate(s):\\n            mask ^= (1<<(ord(c)-ord(\\'0\\')))\\n            if index[mask] == float(\\'-inf\\'):\\n                index[mask] = i\\n            res = max(res, i-index[mask])\\n\\t\\t\\t#when the palindrome has one odd numbers of digits\\n            for j in range(10):\\n                tmp_mask = mask^(1<<j)\\n                res = max(res, i-index[tmp_mask] if index[tmp_mask] != float(\\'-inf\\') else 0)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "class Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        mask = 0\\n        index = defaultdict(lambda:float(\\'-inf\\'),{0:-1}",
                "codeTag": "Java"
            },
            {
                "id": 2113464,
                "title": "c-easy-to-understand-simple-bitmasking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size();\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        int state=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int mask=(1<<(s[i]-\\'0\\'));\\n            state=(state^mask);\\n            if(mp.find(state)!=mp.end())\\n            {\\n                int j=mp[state];\\n                ans=max(ans,i-j);\\n            }\\n            for(int k=0;k<=9;k++)\\n            {\\n                int mask=(1<<k);\\n                int state2=state^mask;\\n                if(mp.find(state2)!=mp.end())\\n                {\\n                    int j=mp[state2];\\n                    ans=max(ans,i-j);\\n                }\\n            }\\n            if(mp.find(state)==mp.end())\\n            mp[state]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size();\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        int state=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int mask=(1<<(s[i]-\\'0\\'));\\n            state=(state^mask);\\n            if(mp.find(state)!=mp.end())\\n            {\\n                int j=mp[state];\\n                ans=max(ans,i-j);\\n            }\\n            for(int k=0;k<=9;k++)\\n            {\\n                int mask=(1<<k);\\n                int state2=state^mask;\\n                if(mp.find(state2)!=mp.end())\\n                {\\n                    int j=mp[state2];\\n                    ans=max(ans,i-j);\\n                }\\n            }\\n            if(mp.find(state)==mp.end())\\n            mp[state]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098100,
                "title": "python-prefix-bitmask-fastest-99",
                "content": "I have givien solution below, with comments on each line to see what that line is doing.\\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = cur = 0\\n        seen = {0:-1}\\n        \\n        # as there is only 10 digits, define dict \\n        digits = {\\'0\\':1,\\'1\\':2,\\'2\\':4,\\'3\\':8,\\'4\\':16,\\'5\\':32,\\'6\\':64,\\'7\\':128,\\'8\\':256,\\'9\\':1024}\\n        \\n        for i,c in enumerate(s):\\n            cur ^= digits.get(c)\\n            \\n            # See if mask alredy in seen, if not then set it\\n            if cur not in seen:\\n                seen[cur] = i\\n            else:\\n                # else calulate length and save max in res\\n                res = max(res, i - seen[cur])\\n            \\n            # by fliping each digit, see if there prefix palindrome string\\n            for j in digits.values():\\n                newmask = cur ^ j\\n                \\n                if newmask in seen:\\n                    res = max(res,i-seen[newmask])\\n\\n        return res\\n```\\n\\n##### With this I suggest you also solve below very similar problem,\\n[1915. Number of Wonderful Substrings](https://leetcode.com/problems/number-of-wonderful-substrings/)\\n\\nIf you find this helpful, please do **upVote^**. \\nFor any help or suggestion, comment below.",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = cur = 0\\n        seen = {0:-1}\\n        \\n        # as there is only 10 digits, define dict \\n        digits = {\\'0\\':1,\\'1\\':2,\\'2\\':4,\\'3\\':8,\\'4\\':16,\\'5\\':32,\\'6\\':64,\\'7\\':128,\\'8\\':256,\\'9\\':1024}\\n        \\n        for i,c in enumerate(s):\\n            cur ^= digits.get(c)\\n            \\n            # See if mask alredy in seen, if not then set it\\n            if cur not in seen:\\n                seen[cur] = i\\n            else:\\n                # else calulate length and save max in res\\n                res = max(res, i - seen[cur])\\n            \\n            # by fliping each digit, see if there prefix palindrome string\\n            for j in digits.values():\\n                newmask = cur ^ j\\n                \\n                if newmask in seen:\\n                    res = max(res,i-seen[newmask])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045971,
                "title": "c-bit-manipulation-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string str) {\\n        // mask, index\\n        map<int, int> inx;\\n        inx[0] = -1;\\n        \\n        int mask = 0, ans = 1;\\n        for(int i = 0; i < str.length(); i++) {\\n            mask ^= (1 << (str[i]-\\'0\\'));\\n            \\n            // all are even\\n            if(inx.count(mask))\\n                ans = max(ans, i - inx[mask]);\\n            \\n            // one is odd and others are even\\n            for(int j = 0; j < 10; j++) {\\n                int tmp_mask = mask ^ (1<<j);\\n                if(inx.count(tmp_mask))\\n                    ans = max(ans, i - inx[tmp_mask]);\\n            }\\n            \\n            // add to map\\n            if(inx.count(mask) == 0)\\n                inx[mask] = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string str) {\\n        // mask, index\\n        map<int, int> inx;\\n        inx[0] = -1;\\n        \\n        int mask = 0, ans = 1;\\n        for(int i = 0; i < str.length(); i++) {\\n            mask ^= (1 << (str[i]-\\'0\\'));\\n            \\n            // all are even\\n            if(inx.count(mask))\\n                ans = max(ans, i - inx[mask]);\\n            \\n            // one is odd and others are even\\n            for(int j = 0; j < 10; j++) {\\n                int tmp_mask = mask ^ (1<<j);\\n                if(inx.count(tmp_mask))\\n                    ans = max(ans, i - inx[tmp_mask]);\\n            }\\n            \\n            // add to map\\n            if(inx.count(mask) == 0)\\n                inx[mask] = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947695,
                "title": "c-study-java-code-first-c-code-engineering-skills",
                "content": "April 14, 2022\\n**Introduction**\\nEngineering skills are hard to train through leetcode algorithm practice. What I like to work on is to have more submissions. One of ideas is to study discuss posts and write C# code based on Java code shared by votrubac. \\n\\n**Engineering skills | Analytical skills**\\nI have some issues, maybe because I applied over-engineering analysis on this hard level algorithm. So I like to copy the analysis in the following, and then learn from expert instead. \\n\\n**votrubac\\'s analysis | My translation is next**\\nWe can form a palindrome if the count of each included number (expcept maybe one) is even, and this is the property of an awesome string.\\n\\nA bit in our mask is 0 if the count for the corresponding number is even, and 1 if it\\'s odd. As we go through the string, we track odd/even counts in our mask. If we see the same mask again, the subarray between first poistion (exclusive) and the current position (inclusive) with the same mask has all numbers with the even count.\\n\\nWe will use the dp array to track the smallest (first) position of each mask. We can get the size of the substring by substracting it from the current poisition.\\n\\nNote that position for zero mask is -1, as we need to include the very first character.\\n\\nNow, the difference from 1371 is that a palindrome can have up to one number with the odd count. Therefore, we need to also check all masks that are different from the current one by one bit. In other words, if two masks are different by one bit, that means that there is one odd count in the substring.\\n\\n**My translation**\\n1. Palindrome substring - even length - count of each digit is even\\n2. Palindrome substring - odd length - one digit count is odd, all others are even\\n3. 0 and 1 are used to represent even or odd. Iterate the given string char by char, record odd/even count in a mask variable - each digit from 0 to 9 is one bit, one integer can have 10 bits to cover all digits\\'s count. \\n4. Design: define an integer array called dp[1024], explain 1024 = 2^10 to cover all 10 digits\\'s count;\\n5. Initialization - position for zero mask is -1, since the first character should be included. \\n6. Go back to review my practice 1371. Check all masks that are diffrent from the current one by one bit. In other words, if two masks are different by one bit, that means that there is one odd count in the substring. <- why one odd count, not at least one? \\n\\n**Leetcode algorithm practice | Meta onsite in May 2022**\\nI need to figure out how to prepare algorithm interview. One of ideas is to learn ideas from other discuss post, and then quickly understand the analysis and write C# code. \\n\\n**C# catchup | Enumerable.Range(start, count)**\\nI run into exception, so that I made change on C# code\\n```\\ndp = Enumerable.Range(0, 1024).Select(i => length).ToArray();\\n```\\nI thought that start and end two indexes, actually it is start and count two variables. \\n```\\npublic static System.Collections.Generic.IEnumerable<int> Range (int start, int count);\\n```\\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_longest_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n        }\\n\\n        /// <summary>\\n        /// study code:\\n        /// https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371)\\n        /// Learn to convert Java code to C# code\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {\\n            // design: 2^0, ..., 2^9, so 2^10 = 1024, minimum upper bound\\n            var dp = new int[1024];\\n\\n            var length = s.Length;\\n            //Arrays.fill(dp, s.length()); - Google Java Arrays.fill C# analog -> \\n            dp = Enumerable.Range(0, 1024).Select(i => length).ToArray();\\n\\n            int result = 0;  // default value is zero\\n            var mask = 0;\\n            dp[0] = -1;\\n\\n            for (int i = 0; i < length; ++i)\\n            {\\n                mask ^= 1 << (s[i] - \\'0\\');\\n                result = Math.Max(result, i - dp[mask]);\\n\\n                for (int digit = 0; digit <= 9; ++digit)\\n                {\\n                    result = Math.Max(result, i - dp[mask ^ (1 << digit)]);\\n                }\\n\\n                dp[mask] = Math.Min(dp[mask], i);\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndp = Enumerable.Range(0, 1024).Select(i => length).ToArray();\\n```\n```\\npublic static System.Collections.Generic.IEnumerable<int> Range (int start, int count);\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_longest_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n        }\\n\\n        /// <summary>\\n        /// study code:\\n        /// https://leetcode.com/problems/find-longest-awesome-substring/discuss/779893/C%2B%2BJavaPython3-with-picture-(similar-to-1371)\\n        /// Learn to convert Java code to C# code\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {\\n            // design: 2^0, ..., 2^9, so 2^10 = 1024, minimum upper bound\\n            var dp = new int[1024];\\n\\n            var length = s.Length;\\n            //Arrays.fill(dp, s.length()); - Google Java Arrays.fill C# analog -> \\n            dp = Enumerable.Range(0, 1024).Select(i => length).ToArray();\\n\\n            int result = 0;  // default value is zero\\n            var mask = 0;\\n            dp[0] = -1;\\n\\n            for (int i = 0; i < length; ++i)\\n            {\\n                mask ^= 1 << (s[i] - \\'0\\');\\n                result = Math.Max(result, i - dp[mask]);\\n\\n                for (int digit = 0; digit <= 9; ++digit)\\n                {\\n                    result = Math.Max(result, i - dp[mask ^ (1 << digit)]);\\n                }\\n\\n                dp[mask] = Math.Min(dp[mask], i);\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947500,
                "title": "c-bit-manipulation-hashmap",
                "content": "April 14, 2022\\n**Introduction**\\nI like to share my working C# solution using bit manipulation and hashmap solution. Compared to the idea using an integer array int[1024] to do the work, it takes extra steps to check if key exists or not. \\n\\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_test_one_case\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = LongestAwesome(\"3242415\");\\n        }\\n\\n        public static int LongestAwesome(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            var map = new Dictionary<int, int>();\\n\\n            map.Add(0, -1); //\\n\\n            var length = s.Length;\\n            var bitsForDigits = 0;\\n            var maxLength = 0;\\n\\n            // 0 ^ 0 = 0\\n            // 0 ^ 1 = 1\\n            // 1 ^ 1 = 1  // xor - determine odd or even in each bit\\n            for (int i = 0; i < length; i++)\\n            {\\n                var digit = s[i] - \\'0\\';\\n                bitsForDigits ^= 1 << digit;\\n\\n                if (!map.ContainsKey(bitsForDigits))\\n                {\\n                    map.Add(bitsForDigits, i);\\n                }\\n                else\\n                {\\n                    maxLength = Math.Max(maxLength, i - map[bitsForDigits]);\\n                }\\n\\n                // search odd matching \\n                // brute force all digits with 1 - at most 10 cases\\n                for (int shift = 0; shift <= 9; shift++)\\n                {\\n                    var key = bitsForDigits ^ (1 << shift);  // remove one digit      \\n                      \\n                    if (map.ContainsKey(key))\\n                    {\\n                        maxLength = Math.Max(maxLength, i - map[key]);\\n                    }  \\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_test_one_case\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = LongestAwesome(\"3242415\");\\n        }\\n\\n        public static int LongestAwesome(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            var map = new Dictionary<int, int>();\\n\\n            map.Add(0, -1); //\\n\\n            var length = s.Length;\\n            var bitsForDigits = 0;\\n            var maxLength = 0;\\n\\n            // 0 ^ 0 = 0\\n            // 0 ^ 1 = 1\\n            // 1 ^ 1 = 1  // xor - determine odd or even in each bit\\n            for (int i = 0; i < length; i++)\\n            {\\n                var digit = s[i] - \\'0\\';\\n                bitsForDigits ^= 1 << digit;\\n\\n                if (!map.ContainsKey(bitsForDigits))\\n                {\\n                    map.Add(bitsForDigits, i);\\n                }\\n                else\\n                {\\n                    maxLength = Math.Max(maxLength, i - map[bitsForDigits]);\\n                }\\n\\n                // search odd matching \\n                // brute force all digits with 1 - at most 10 cases\\n                for (int shift = 0; shift <= 9; shift++)\\n                {\\n                    var key = bitsForDigits ^ (1 << shift);  // remove one digit      \\n                      \\n                    if (map.ContainsKey(key))\\n                    {\\n                        maxLength = Math.Max(maxLength, i - map[key]);\\n                    }  \\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940881,
                "title": "c-last-position-bit-manipulation-study-code",
                "content": "April 12, 2022\\n**Introduction**\\nThere is only one C# solution in discuss, and I chose to study it and wrote my own C# code. \\n\\n**Bit manipulation**\\nFrom each integer n from 0 to 9, 2^n can be ranged from 1 to 512. So it is working solution to define masks array using those 10 numbers. \\n\\n**Case study: 76263**\\nGiven an integer 76263, longest substring 626 can be swapped into a palindrome. \\n\\nSubstring starting from index = 0, \"7\" can be mapped to prefixes[0] = 2^7 = 128. How to find a longest substring starting from index = 1 which can be swapped to a palindrome substring. \\n\\nOne of search is to find lastPosition defined as int[1024], here key is 128, lastPosition[128], if it is not defined or found, the default value of integer array is 0. Since maximum substring default value is 1, it is not a problem using default value 0 of lastPosition. \\n\\nAnother of search is to go through all possible masks - 1st to 9th bit, masks array index position from 0 to 9, XOR two values, one is prefixes[0] = 2&6 = 128, and look for last position of the mask value. If it is not found, then lastPosition array\\'s lookup is 0, and then \\n```\\nlastPosition[prefixes[i] ^ mask] - i + 1\\n```\\nThe above expression returns negative value, which does not matter since it will not be bigger than default value 1 of variable answer - maximum length of substring. \\n\\nSo \"7\", with all possible one extra digit, look for lastPosition with same odd and even count of string \"70\",\"71\",\"72\",\"73\",\"74\",\"75\",\"76\",\"77\",\"78\",\"79\". \\n\\n**First tip | Use array for 10 bits = 1111111111 in binary form = 2^9 + 2^8 + ...+ 2^0 < 2^10 = 1024 | Compare to use HashMap** \\nIt is hard level algorithm. Most of important is to design a working solution. Using array compared to HashMap on this algorithm definitely makes it easy to write a working solution. \\n\\n**Last position vs first position | Luck or smartness | I do not know**\\nI chose to first position, but I came cross a bug and I could not fix it. My design and the algorithm failed one test case: 9498331. [Here](https://leetcode.com/problems/find-longest-awesome-substring/discuss/1940771/C-or-First-position-or-Bit-manipulation-or-Failed%3A-%229498331%22-or-Lessons-learned) is my C# practice with failed test case. \\n\\nI learned to write using last position by studying discuss section C# code. I do not know how to advance myself in such short time to prepare for May Meta onsite. \\n\\n\\nThe following code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_study_code\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {   \\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n\\n            var max2 = LongestAwesome(\"30003\");\\n            Debug.Assert(max2 == 5);\\n\\n            // 76263 - 30003\\n            var max3 = LongestAwesome(\"76263\");\\n            Debug.Assert(max3 == 3);\\n        }\\n\\n        /// <summary>\\n        /// study code:\\n        /// https://leetcode.com/problems/find-longest-awesome-substring/discuss/952409/C-Bit-Manipulation\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {            \\n            var masks = new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };\\n\\n            var length = s.Length;\\n            // calculate prefixes\\n            var prefixes = new int[length + 1];\\n\\n            for (var i = 1; i <= length; i++)\\n            {\\n                // XOR - 1 or 0, even or odd count\\n                prefixes[i] = prefixes[i - 1] ^ masks[s[i - 1] - \\'0\\'];\\n            }\\n\\n            // calculate last indexes of prefixes\\n            // 1024 - what for? 2^10 = 1024, 0 - 9, 2^0 = 1, ..., 2^9 = 512 \\n            var lastPosition = new int[1024];\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                lastPosition[prefixes[i + 1]] = i;\\n            }\\n\\n            var answer = 1;\\n            // check max length between last index (+ any variations(10)) and current index\\n            // I failed in my practice since I chose to work on previous position - this makes buggy code\\n            for (var i = 0; i < length; i++)\\n            {\\n                answer = Math.Max(answer, lastPosition[prefixes[i]] - i + 1);\\n\\n                foreach (var mask in masks)\\n                {\\n                    answer = Math.Max(answer, lastPosition[prefixes[i] ^ mask] - i + 1);\\n                }\\n            }\\n\\n            return answer;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlastPosition[prefixes[i] ^ mask] - i + 1\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_study_code\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {   \\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n\\n            var max2 = LongestAwesome(\"30003\");\\n            Debug.Assert(max2 == 5);\\n\\n            // 76263 - 30003\\n            var max3 = LongestAwesome(\"76263\");\\n            Debug.Assert(max3 == 3);\\n        }\\n\\n        /// <summary>\\n        /// study code:\\n        /// https://leetcode.com/problems/find-longest-awesome-substring/discuss/952409/C-Bit-Manipulation\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {            \\n            var masks = new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };\\n\\n            var length = s.Length;\\n            // calculate prefixes\\n            var prefixes = new int[length + 1];\\n\\n            for (var i = 1; i <= length; i++)\\n            {\\n                // XOR - 1 or 0, even or odd count\\n                prefixes[i] = prefixes[i - 1] ^ masks[s[i - 1] - \\'0\\'];\\n            }\\n\\n            // calculate last indexes of prefixes\\n            // 1024 - what for? 2^10 = 1024, 0 - 9, 2^0 = 1, ..., 2^9 = 512 \\n            var lastPosition = new int[1024];\\n\\n            for (var i = 0; i < s.Length; i++)\\n            {\\n                lastPosition[prefixes[i + 1]] = i;\\n            }\\n\\n            var answer = 1;\\n            // check max length between last index (+ any variations(10)) and current index\\n            // I failed in my practice since I chose to work on previous position - this makes buggy code\\n            for (var i = 0; i < length; i++)\\n            {\\n                answer = Math.Max(answer, lastPosition[prefixes[i]] - i + 1);\\n\\n                foreach (var mask in masks)\\n                {\\n                    answer = Math.Max(answer, lastPosition[prefixes[i] ^ mask] - i + 1);\\n                }\\n            }\\n\\n            return answer;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940771,
                "title": "c-first-position-bit-manipulation-failed-9498331-lessons-learned",
                "content": "April 12, 2022\\n**Introduction**\\nIt is a hard level algorithm. I chose to work on it, since I just did solve a similar bit manipulation algorithm 1371. Find the Longest Substring Containing Vowels in Even Counts based on discuss post by votrubac. I chose to work on first position of bit manipulation, and I came cross this failed test case \"9498331\". I could not solve the issue, and I just could not believe that how others solve the problem but no warning on this first position idea and its bugg issue. \\n\\n**Brute force solution | O(N^2)**\\nIt takes O(N^2) to find all substrings, and then it can be calculated to maximum substring to be swapped to a palindrome. \\n\\n**Optimal solution | Hashmap to record count of digits**\\nIt is easy to come out the design to use 10 bits to represent 0 to 9 10 digits, even or odd count using 0 or 1 to represent. \\n\\n**Case study | \"9498331\" | Should return 3, not 4**\\n\\nThe following code failed test case: 78 / 153 test cases passed.\\nInput:\\n\"9498331\"\\nOutput: 4\\nShould be: 3\\n\\n**Lesson learned:**\\nAnalysis:\\n949833 \\n94 - remove 9, so, 4 maps to a number 1<< 4 = 2^4 = 16. \\n949833 - remove 8, 94933 maps to a number 1 << 4 = 2^4 = 16\\nfirst position with 16\\'s index = 1, and the current positon with 16\\'s index = 5, so the answer is 4, but \"9833\" can not be a palindrome by the option to remove one char. \\n\\nThere are more than two issues in my design using those 10 bits mask to map 0 to 9 10 digits. It took me hours to figure out what is wrong, and how to address the issues. \\n\\n**Faulty design | Save substring with all possible one extra digit into HashMap**\\nI just gave it a quick try without strictly proof that it should work. I even save extra key into HashMap to pad at the end one more digit - any digit from 0 to 9. \\n\\nI chose to use first position, and then handle extra digit case. It is not easy to figure out so many things in such a short time. Just be patient. Learn from those failed submissions and those failed test cases, and I think that the failures should be best teacher for me. To prepare for Mata onsite in May 2022, I should try 10 hard level algorithms, and learn from all those mistakes in practice. [Here](https://leetcode.com/discuss/interview-question/1914695/30-days-to-meta-onsite-4th-facebook-onsite-system-design-daily-update-day-5) is my discuss post related to Meta onsite 30 day preparation. \\n\\nI should work on last position instead. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_find_longest_awesome_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            //var maximumLength = LongestAwesome(\"3242415\");\\n            //Debug.Assert(maximumLength == 5);\\n\\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n        }\\n\\n        /// <summary>\\n        /// April 8, 2022\\n        /// Brute force solution O(N^2) \\n        /// find all substrings and then check if it is an awesome substring\\n        /// Optimal solution should be O(N), go through the array once, and then \\n        /// record all digits count in terms of even or odd, using one integer 10 bits \\n        /// to contain all 10 bits - left to right, 0 - 9\\n        /// \\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n            {\\n                return 0;\\n            }\\n            \\n            var map = new Dictionary<int, int>();            \\n\\n            map.Add(0, -1); //\\n\\n            var length = s.Length;\\n            var bitsForDigits = 0;\\n            var maxLength = 0;\\n\\n            // 0 ^ 0 = 0\\n            // 0 ^ 1 = 1\\n            // 1 ^ 1 = 1  // xor - determine odd or even in each bit\\n            for (int i = 0; i < length; i++)\\n            {\\n                var digit = s[i] - \\'0\\';\\n                bitsForDigits ^= 1 << digit;\\n\\n                if (!map.ContainsKey(bitsForDigits))\\n                {\\n                    map.Add(bitsForDigits, i);\\n                }\\n                else\\n                {\\n                     maxLength = Math.Max(maxLength, i - map[bitsForDigits]);\\n                }\\n                  \\n                // search odd matching \\n                // brute force all digits with 1 - at most 10 cases\\n                for (int shift = 0; shift <= 9; shift++)\\n                {\\n                    // mask one bit\\n                    if ((bitsForDigits & (1 << shift)) == 0)\\n                    {\\n                        continue;\\n                    }\\n\\n                    var key = bitsForDigits ^ (1 << shift);  // remove one digit\\n\\n                    if (!map.ContainsKey(key))\\n                    {\\n                        map.Add(key, i);\\n                    }\\n                    else\\n                    {\\n                        // 949833, remove 4, 99833, but 8\\'s count is odd \\n                        //if (key == 0)  // make sure that all digits have even count\\n                        {\\n                            maxLength = Math.Max(maxLength, i - map[key]);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1542_find_longest_awesome_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            //var maximumLength = LongestAwesome(\"3242415\");\\n            //Debug.Assert(maximumLength == 5);\\n\\n            var max = LongestAwesome(\"9498331\");\\n            Debug.Assert(max == 3);\\n        }\\n\\n        /// <summary>\\n        /// April 8, 2022\\n        /// Brute force solution O(N^2) \\n        /// find all substrings and then check if it is an awesome substring\\n        /// Optimal solution should be O(N), go through the array once, and then \\n        /// record all digits count in terms of even or odd, using one integer 10 bits \\n        /// to contain all 10 bits - left to right, 0 - 9\\n        /// \\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int LongestAwesome(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n            {\\n                return 0;\\n            }\\n            \\n            var map = new Dictionary<int, int>();            \\n\\n            map.Add(0, -1); //\\n\\n            var length = s.Length;\\n            var bitsForDigits = 0;\\n            var maxLength = 0;\\n\\n            // 0 ^ 0 = 0\\n            // 0 ^ 1 = 1\\n            // 1 ^ 1 = 1  // xor - determine odd or even in each bit\\n            for (int i = 0; i < length; i++)\\n            {\\n                var digit = s[i] - \\'0\\';\\n                bitsForDigits ^= 1 << digit;\\n\\n                if (!map.ContainsKey(bitsForDigits))\\n                {\\n                    map.Add(bitsForDigits, i);\\n                }\\n                else\\n                {\\n                     maxLength = Math.Max(maxLength, i - map[bitsForDigits]);\\n                }\\n                  \\n                // search odd matching \\n                // brute force all digits with 1 - at most 10 cases\\n                for (int shift = 0; shift <= 9; shift++)\\n                {\\n                    // mask one bit\\n                    if ((bitsForDigits & (1 << shift)) == 0)\\n                    {\\n                        continue;\\n                    }\\n\\n                    var key = bitsForDigits ^ (1 << shift);  // remove one digit\\n\\n                    if (!map.ContainsKey(key))\\n                    {\\n                        map.Add(key, i);\\n                    }\\n                    else\\n                    {\\n                        // 949833, remove 4, 99833, but 8\\'s count is odd \\n                        //if (key == 0)  // make sure that all digits have even count\\n                        {\\n                            maxLength = Math.Max(maxLength, i - map[key]);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return maxLength;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897753,
                "title": "c-bitmask-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int> map;\\n        int mask = 0, maxL = 0;\\n        map[mask] = -1;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            int ch = s[i]-\\'0\\';\\n            mask^= (1<<ch);\\n            \\n            if(map.find(mask) != map.end()){\\n                maxL = max(maxL, i-map[mask]);\\n            }\\n            \\n            for(int x=0; x<=9; ++x){\\n                int newMask = mask^(1<<x);\\n                if(map.find(newMask) != map.end()){\\n                    maxL = max(maxL, i-map[newMask]);\\n                }\\n            }\\n            \\n            if(map.find(mask) == map.end()){\\n                map[mask] = i;\\n            }\\n        }\\n        return maxL;\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<int,int> map;\\n        int mask = 0, maxL = 0;\\n        map[mask] = -1;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            int ch = s[i]-\\'0\\';\\n            mask^= (1<<ch);\\n            \\n            if(map.find(mask) != map.end()){\\n                maxL = max(maxL, i-map[mask]);\\n            }\\n            \\n            for(int x=0; x<=9; ++x){\\n                int newMask = mask^(1<<x);\\n                if(map.find(newMask) != map.end()){\\n                    maxL = max(maxL, i-map[newMask]);\\n                }\\n            }\\n            \\n            if(map.find(mask) == map.end()){\\n                map[mask] = i;\\n            }\\n        }\\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848904,
                "title": "help-please-tell-why-is-this-solution-worng",
                "content": "class Solution {\\n    public int longestAwesome(String s) {\\n        int st[] = new int[10];\\n        int ans=0;\\n        for(int i =0;i<s.length();i++){\\n            st[s.charAt(i)-\\'0\\']++;\\n        }\\n        int i=0;\\n        for(;i<10;i++){\\n           if(st[i]!=0) {if(st[i]%2==1){\\n                ans+=st[i];\\n                break;\\n            }\\n            else{\\n                ans+=st[i];\\n            }}\\n        }\\n        ++i;\\n        for(;i<10;i++){\\n            if(st[i]!=0) {\\n            if(st[i]%2==1){\\n                ans+=st[i]-1;\\n            }\\n            else{\\n                ans+=st[i];\\n            }}\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestAwesome(String s) {\\n        int st[] = new int[10];\\n        int ans=0;\\n        for(int i =0;i<s.length();i++){\\n            st[s.charAt(i)-\\'0\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1770659,
                "title": "pls-help-needed-why-this-can-t-be-solved-by-using-concept-of-leetcode-395",
                "content": "![image](https://assets.leetcode.com/users/images/c3eae3b2-6aa1-4f7d-868f-ccbec53a192f_1644845764.5541365.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/c3eae3b2-6aa1-4f7d-868f-ccbec53a192f_1644845764.5541365.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1745933,
                "title": "golang-bitmask-subarray-caching",
                "content": "same idea as: https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\n\\nthis idea is also prevalent in: \\nhttps://leetcode.com/problems/contiguous-array/\\nhttps://leetcode.com/problems/subarray-sum-equals-k/\\nhttps://leetcode.com/problems/continuous-subarray-sum/\\n\\n```\\nfunc longestAwesome(s string) int {\\n    cache := make(map[int]int)\\n    cache[0] = -1 // at idx -1, all digits\\' count is also 0\\n    mask := 0\\n    res := 0\\n    for i, c := range s {\\n        mask = mask ^ (1 << int(c - \\'0\\'))  // toggle the nth bit\\n        \\n        // check for all cases where we allow 1 of the digits to be odd count\\n        for j := 0; j<=9; j++ {\\n            oddMask := mask ^ (1 << j)\\n            if prevEnd, exist := cache[oddMask]; exist {\\n                res = max(res, i - prevEnd)\\n            }\\n        }\\n        \\n        if prevEnd, exist := cache[mask]; exist {  // check for all even case\\n            res = max(res, i - prevEnd)\\n        } else {\\n            cache[mask] = i\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n/*\\n    bitmasking -> 10 bits to represent 10 digits\\' parity\\n    \\n    possible legal combinations:\\n    0 -> all even counts\\n    only one 1 -> all even counts except for 1 odd count\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestAwesome(s string) int {\\n    cache := make(map[int]int)\\n    cache[0] = -1 // at idx -1, all digits\\' count is also 0\\n    mask := 0\\n    res := 0\\n    for i, c := range s {\\n        mask = mask ^ (1 << int(c - \\'0\\'))  // toggle the nth bit\\n        \\n        // check for all cases where we allow 1 of the digits to be odd count\\n        for j := 0; j<=9; j++ {\\n            oddMask := mask ^ (1 << j)\\n            if prevEnd, exist := cache[oddMask]; exist {\\n                res = max(res, i - prevEnd)\\n            }\\n        }\\n        \\n        if prevEnd, exist := cache[mask]; exist {  // check for all even case\\n            res = max(res, i - prevEnd)\\n        } else {\\n            cache[mask] = i\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n/*\\n    bitmasking -> 10 bits to represent 10 digits\\' parity\\n    \\n    possible legal combinations:\\n    0 -> all even counts\\n    only one 1 -> all even counts except for 1 odd count\\n\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700546,
                "title": "java-using-string-instead-of-bitmask",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    int[] arr = new int[10];\\n    int best = 1;\\n    map.put(\"0000000000\", -1);\\n    for (int i = 0; i < s.length(); i++) {\\n      int num = Character.getNumericValue(s.charAt(i));\\n      arr[num]++;\\n      arr[num] %= 2;\\n      StringBuffer str = new StringBuffer(\"0000000000\");\\n      for (int j = 0; j < arr.length; j++) {\\n        if (arr[j] == 1) {\\n          str.setCharAt(j, \\'1\\');\\n        }\\n      }\\n      boolean add = false;\\n      if (map.containsKey(str.toString())) {\\n        int prevIdx = map.get(str.toString());\\n        best = Math.max(best, i - prevIdx);\\n      } else {\\n\\n        add = true;\\n      }\\n      for (int j = 0; j < arr.length; j++) {\\n        if (str.charAt(j) == \\'0\\') {\\n          str.setCharAt(j, \\'1\\');\\n          if (map.containsKey(str.toString())) {\\n            best = Math.max(best, i - map.get(str.toString()));\\n          }\\n          str.setCharAt(j, \\'0\\');\\n        } else {\\n          str.setCharAt(j, \\'0\\');\\n          if (map.containsKey(str.toString())) {\\n            best = Math.max(best, i - map.get(str.toString()));\\n          }\\n          str.setCharAt(j, \\'1\\');\\n        }\\n\\n      }\\n      if (add) {\\n        map.put(str.toString(), i);\\n      }\\n    }\\n    return best;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    int[] arr = new int[10];\\n    int best = 1;\\n    map.put(\"0000000000\", -1);\\n    for (int i = 0; i < s.length(); i++) {\\n      int num = Character.getNumericValue(s.charAt(i));\\n      arr[num]++;\\n      arr[num] %= 2;\\n      StringBuffer str = new StringBuffer(\"0000000000\");\\n      for (int j = 0; j < arr.length; j++) {\\n        if (arr[j] == 1) {\\n          str.setCharAt(j, \\'1\\');\\n        }\\n      }\\n      boolean add = false;\\n      if (map.containsKey(str.toString())) {\\n        int prevIdx = map.get(str.toString());\\n        best = Math.max(best, i - prevIdx);\\n      } else {\\n\\n        add = true;\\n      }\\n      for (int j = 0; j < arr.length; j++) {\\n        if (str.charAt(j) == \\'0\\') {\\n          str.setCharAt(j, \\'1\\');\\n          if (map.containsKey(str.toString())) {\\n            best = Math.max(best, i - map.get(str.toString()));\\n          }\\n          str.setCharAt(j, \\'0\\');\\n        } else {\\n          str.setCharAt(j, \\'0\\');\\n          if (map.containsKey(str.toString())) {\\n            best = Math.max(best, i - map.get(str.toString()));\\n          }\\n          str.setCharAt(j, \\'1\\');\\n        }\\n\\n      }\\n      if (add) {\\n        map.put(str.toString(), i);\\n      }\\n    }\\n    return best;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386885,
                "title": "c-hash-bitmask",
                "content": "The key idea is to use a hashmap to store the previous config of the string so that when we have more than one odd element in the substring we can look for a similar event in past \\n```\\nmap<long long,int>M;\\n        //M[0]=-1;\\n        vector<int>fre(10,0);\\n        int n=s.size();\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            fre[s[i]-\\'0\\']=(fre[s[i]-\\'0\\']+1)%2;\\n            long long te=0;\\n           for(int j=0;j<10;j++){\\n                if(fre[j])\\n                    te+=pow(2,j);}\\n            if(te==0||ceil(log2(te)*1.0)==floor(log2(te)*1.0))\\n               mx=max(mx,i+1);\\n            if(M.count(te)==0)\\n                M[te]=i;\\n            mx=max(mx,i-M[te]);\\n            for(int j=0;j<10;j++){\\n                long long el=pow(2,j);\\n                long long va=el^te;\\n                if(M.count(va))\\n                    mx=max(mx,i-M[va]);\\n            }\\n        }\\n        return mx;\\n```",
                "solutionTags": [],
                "code": "```\\nmap<long long,int>M;\\n        //M[0]=-1;\\n        vector<int>fre(10,0);\\n        int n=s.size();\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            fre[s[i]-\\'0\\']=(fre[s[i]-\\'0\\']+1)%2;\\n            long long te=0;\\n           for(int j=0;j<10;j++){\\n                if(fre[j])\\n                    te+=pow(2,j);}\\n            if(te==0||ceil(log2(te)*1.0)==floor(log2(te)*1.0))\\n               mx=max(mx,i+1);\\n            if(M.count(te)==0)\\n                M[te]=i;\\n            mx=max(mx,i-M[te]);\\n            for(int j=0;j<10;j++){\\n                long long el=pow(2,j);\\n                long long va=el^te;\\n                if(M.count(va))\\n                    mx=max(mx,i-M[va]);\\n            }\\n        }\\n        return mx;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375991,
                "title": "java-bit-mask",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n       int[] firstIndex = new int[1028];\\n        Arrays.fill(firstIndex,-2);\\n        firstIndex[0] = -1;\\n        int mask = 0;\\n        int len = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            mask^=(1<<(ch-\\'0\\'));\\n            if(firstIndex[mask]!=-2){\\n                len = Math.max(len,i-firstIndex[mask]);\\n            }\\n            else{\\n                firstIndex[mask] = i;\\n            }\\n            for(int n=0;n<10;n++){\\n                if(firstIndex[mask^(1<<n)]!=-2){\\n                    len = Math.max(len,i-firstIndex[mask^(1<<n)]);\\n                }\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n       int[] firstIndex = new int[1028];\\n        Arrays.fill(firstIndex,-2);\\n        firstIndex[0] = -1;\\n        int mask = 0;\\n        int len = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            mask^=(1<<(ch-\\'0\\'));\\n            if(firstIndex[mask]!=-2){\\n                len = Math.max(len,i-firstIndex[mask]);\\n            }\\n            else{\\n                firstIndex[mask] = i;\\n            }\\n            for(int n=0;n<10;n++){\\n                if(firstIndex[mask^(1<<n)]!=-2){\\n                    len = Math.max(len,i-firstIndex[mask^(1<<n)]);\\n                }\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361572,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> pos((1<<10),-1);\\n        \\n        int curr=0,ans=1;\\n        pos[0]=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char ch=s[i];\\n            \\n            curr^=(1<<(ch-\\'0\\'));\\n            \\n            if(pos[curr]!=-1)\\n            {\\n                ans=max(ans,i-pos[curr]+1);\\n            }\\n            \\n            for(int d=0;d<10;d++)\\n            {\\n                int req=curr^(1<<d);\\n                if(pos[req]==-1) continue;\\n                ans=max(ans,i-pos[req]+1);\\n            }\\n            if(pos[curr]==-1) pos[curr]=i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> pos((1<<10),-1);\\n        \\n        int curr=0,ans=1;\\n        pos[0]=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char ch=s[i];\\n            \\n            curr^=(1<<(ch-\\'0\\'));\\n            \\n            if(pos[curr]!=-1)\\n            {\\n                ans=max(ans,i-pos[curr]+1);\\n            }\\n            \\n            for(int d=0;d<10;d++)\\n            {\\n                int req=curr^(1<<d);\\n                if(pos[req]==-1) continue;\\n                ans=max(ans,i-pos[req]+1);\\n            }\\n            if(pos[curr]==-1) pos[curr]=i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308059,
                "title": "scala-solution-bit-mask",
                "content": "```\\n\\tdef longestAwesome(s: String): Int = {\\n        var bits = 0\\n        var res = 1\\n        val bitMap = scala.collection.mutable.Map[Int,Int]()//mask -> index\\n        bitMap(bits) = -1//As we need to consider the first element as well, so start index = -1 to get substring length\\n        \\n        s.zipWithIndex.foreach{case(c,i) =>\\n            bits = flipBit(bits,c.asDigit)\\n            \\n            //If exact same bit mask occured at an earlier index, we update result\\n            if(bitMap.contains(bits)){\\n                res = res.max(i-bitMap(bits))\\n            }\\n            //If bitMask with only 1 bit difference occured earlier (palindrome with odd length), we again update result\\n            for(n<- 0 to 9){\\n                val testBits =  flipBit(bits,n)\\n                if(bitMap.contains(testBits)){\\n                    res = res.max(i-bitMap(testBits))\\n                }\\n            }\\n            //We need to save the earlier position to maintain the longest path in b/w and not update the mask index everytime\\n            if(!bitMap.contains(bits)){\\n                bitMap(bits) = i\\n            }\\n        }\\n        res\\n    }\\n    \\n    def flipBit(n:Int,i:Int):Int = {\\n        var p = 1<<i\\n        n^p\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tdef longestAwesome(s: String): Int = {\\n        var bits = 0\\n        var res = 1\\n        val bitMap = scala.collection.mutable.Map[Int,Int]()//mask -> index\\n        bitMap(bits) = -1//As we need to consider the first element as well, so start index = -1 to get substring length\\n        \\n        s.zipWithIndex.foreach{case(c,i) =>\\n            bits = flipBit(bits,c.asDigit)\\n            \\n            //If exact same bit mask occured at an earlier index, we update result\\n            if(bitMap.contains(bits)){\\n                res = res.max(i-bitMap(bits))\\n            }\\n            //If bitMask with only 1 bit difference occured earlier (palindrome with odd length), we again update result\\n            for(n<- 0 to 9){\\n                val testBits =  flipBit(bits,n)\\n                if(bitMap.contains(testBits)){\\n                    res = res.max(i-bitMap(testBits))\\n                }\\n            }\\n            //We need to save the earlier position to maintain the longest path in b/w and not update the mask index everytime\\n            if(!bitMap.contains(bits)){\\n                bitMap(bits) = i\\n            }\\n        }\\n        res\\n    }\\n    \\n    def flipBit(n:Int,i:Int):Int = {\\n        var p = 1<<i\\n        n^p\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1305025,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int[] dp=new int[1024];\\n        Arrays.fill(dp,-5);\\n        dp[0]=-1;\\n        int mask=0;\\n        int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            mask= mask ^ (1<<(s.charAt(i)-\\'0\\'));\\n            if(dp[mask]!=-5)\\n            {\\n                res=Math.max(res,i-dp[mask]);\\n            }\\n            for(int j=0;j<=9;j++)\\n            {\\n                if(dp[mask ^ (1<<j)]!=-5)\\n                    res=Math.max(res,i-dp[mask ^ (1<<j)]);\\n            }\\n            if(dp[mask]==-5)\\n               dp[mask]=i;\\n        }\\n       return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int[] dp=new int[1024];\\n        Arrays.fill(dp,-5);\\n        dp[0]=-1;\\n        int mask=0;\\n        int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            mask= mask ^ (1<<(s.charAt(i)-\\'0\\'));\\n            if(dp[mask]!=-5)\\n            {\\n                res=Math.max(res,i-dp[mask]);\\n            }\\n            for(int j=0;j<=9;j++)\\n            {\\n                if(dp[mask ^ (1<<j)]!=-5)\\n                    res=Math.max(res,i-dp[mask ^ (1<<j)]);\\n            }\\n            if(dp[mask]==-5)\\n               dp[mask]=i;\\n        }\\n       return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262186,
                "title": "doubt-over-a-test-case",
                "content": "Why test input ```\"9498331\"``` has len 3 not 5? Since we have 2-9, 2-3, 1-1, 1-4, 1-8, can\\'t we form ```39193``` or ```39493``` or ```39893```? Or am I missing soemething here?",
                "solutionTags": [],
                "code": "```\"9498331\"```\n```39193```\n```39493```\n```39893```",
                "codeTag": "Unknown"
            },
            {
                "id": 1171351,
                "title": "simple-go",
                "content": "```\\nfunc longestAwesome(s string) int {\\n    n := 0\\n    m := map[int]int {0: -1}\\n    maxLen := 1\\n    \\n    for i:=0;i<len(s);i++ {\\n        n = n ^ (1 << (s[i]-\\'0\\'))\\n        \\n        if val, ok := m[n]; ok {\\n            maxLen = max(maxLen, i-val)\\n        }\\n        \\n        for j:=0;j<10;j++ {\\n            n_ := n ^ (1 << j)\\n            if val, ok := m[n_]; ok {\\n                maxLen = max(maxLen, i-val)\\n            }\\n        }\\n        \\n        if _, ok := m[n]; !ok {\\n            m[n] = i\\n        }\\n    }\\n    return maxLen\\n    \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestAwesome(s string) int {\\n    n := 0\\n    m := map[int]int {0: -1}\\n    maxLen := 1\\n    \\n    for i:=0;i<len(s);i++ {\\n        n = n ^ (1 << (s[i]-\\'0\\'))\\n        \\n        if val, ok := m[n]; ok {\\n            maxLen = max(maxLen, i-val)\\n        }\\n        \\n        for j:=0;j<10;j++ {\\n            n_ := n ^ (1 << j)\\n            if val, ok := m[n_]; ok {\\n                maxLen = max(maxLen, i-val)\\n            }\\n        }\\n        \\n        if _, ok := m[n]; !ok {\\n            m[n] = i\\n        }\\n    }\\n    return maxLen\\n    \\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161312,
                "title": "code-review-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerofTwo(int x){\\n        return x&&(!(x&(x-1)));\\n    }\\n    int longestAwesome(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            int mask=0;\\n            for(int j=i;j<n;++j){\\n                mask^=(1<<(s[j]-\\'0\\'));\\n                if(mask==0 || isPowerofTwo(mask)){\\n                    ans=max(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nWhen I am submitting this code it is showing TLE.But when i am running this code with the same input it is working fine.Though the complexity is O(n^2) but still it should work with this input atleast.\\nLast executed input:\"3242415\"\\nI don\\'t know wrong with this code.Can someone help me upon this.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerofTwo(int x){\\n        return x&&(!(x&(x-1)));\\n    }\\n    int longestAwesome(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        for(int i=0;i<n;++i){\\n            int mask=0;\\n            for(int j=i;j<n;++j){\\n                mask^=(1<<(s[j]-\\'0\\'));\\n                if(mask==0 || isPowerofTwo(mask)){\\n                    ans=max(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103737,
                "title": "c-bit",
                "content": "It would be better to represent the \"key\" using integer. The idea behind is the same.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        string key(10, \\'0\\');\\n        unordered_map<string, vector<int>> mp;\\n        mp[key].push_back(-1);\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            int a = s[i] - \\'0\\';\\n            if(key[a] == \\'0\\') key[a] = \\'1\\';\\n            else key[a] = \\'0\\';\\n            mp[key].push_back(i);\\n        }\\n        \\n        int ans = 1;\\n        for(auto &[k, v] : mp) {\\n            if(v.size() > 1) ans = max(ans, v.back() - v[0]);\\n            \\n            string cp = k;\\n            for(int j=0; j<10; ++j) {\\n                string cp = k;\\n                if(k[j] == \\'1\\') cp[j] = \\'0\\';\\n                else cp[j] = \\'1\\';\\n                \\n                if(mp.count(cp)) {\\n                    auto v2 = mp[cp];\\n                    ans = max(ans, v.back() - v2[0]);\\n                    ans = max(ans, v2.back() - v[0]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        string key(10, \\'0\\');\\n        unordered_map<string, vector<int>> mp;\\n        mp[key].push_back(-1);\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            int a = s[i] - \\'0\\';\\n            if(key[a] == \\'0\\') key[a] = \\'1\\';\\n            else key[a] = \\'0\\';\\n            mp[key].push_back(i);\\n        }\\n        \\n        int ans = 1;\\n        for(auto &[k, v] : mp) {\\n            if(v.size() > 1) ans = max(ans, v.back() - v[0]);\\n            \\n            string cp = k;\\n            for(int j=0; j<10; ++j) {\\n                string cp = k;\\n                if(k[j] == \\'1\\') cp[j] = \\'0\\';\\n                else cp[j] = \\'1\\';\\n                \\n                if(mp.count(cp)) {\\n                    auto v2 = mp[cp];\\n                    ans = max(ans, v.back() - v2[0]);\\n                    ans = max(ans, v2.back() - v[0]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048240,
                "title": "invalid-test-case-expected-output-9498331",
                "content": "\"9498331\" -> \"4998331\" -> \"4938931\" -> \"4938391\" , gives 93839 a palindrome and hence 5 and not 3",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 997366,
                "title": "clean-java-using-xor",
                "content": "XOR works simply as a half adder here, if there is odd numbers of certain digit, the corresponding bit will be a \"1\" and vice versa. For palindrome, we at most allow one such digit. \\n```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int prev = 0, res = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int val = s.charAt(i) - \\'0\\';\\n            prev ^= (1 << val);\\n            for (int j = 0; j <= 9; j++) {\\n                if (map.containsKey(prev ^ (1 << j))) {\\n                    res = Math.max(res, i - map.get(prev ^ (1 << j)));\\n                }\\n            }\\n            if (map.containsKey(prev)) {\\n                res = Math.max(res, i - map.get(prev));\\n            }\\n            map.putIfAbsent(prev, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int prev = 0, res = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            int val = s.charAt(i) - \\'0\\';\\n            prev ^= (1 << val);\\n            for (int j = 0; j <= 9; j++) {\\n                if (map.containsKey(prev ^ (1 << j))) {\\n                    res = Math.max(res, i - map.get(prev ^ (1 << j)));\\n                }\\n            }\\n            if (map.containsKey(prev)) {\\n                res = Math.max(res, i - map.get(prev));\\n            }\\n            map.putIfAbsent(prev, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966292,
                "title": "p23-5",
                "content": "https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\nSame bit trick for even and odd making\\nBit trick of even and odd\\nIf count is even at say 5\\nthen put 5th bit 0\\nsimilalry if count of 0 is odd put 0th bit as\\nKeep the ruuning bm\\nUse map\\nFor making palindrome either one of digits count is odd or all are even\\nNow for making count of say 7 to be odd\\nif 7th bit is 0, then we have to subtract odd number from it\\nso make 7th bit as 1\\nSimilarly if 7th bit is 1(means count is odd till now) to make count odd, subtract eve from it so make 7th bit as \\n",
                "solutionTags": [],
                "code": "https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/\\nSame bit trick for even and odd making\\nBit trick of even and odd\\nIf count is even at say 5\\nthen put 5th bit 0\\nsimilalry if count of 0 is odd put 0th bit as\\nKeep the ruuning bm\\nUse map\\nFor making palindrome either one of digits count is odd or all are even\\nNow for making count of say 7 to be odd\\nif 7th bit is 0, then we have to subtract odd number from it\\nso make 7th bit as 1\\nSimilarly if 7th bit is 1(means count is odd till now) to make count odd, subtract eve from it so make 7th bit as \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 952409,
                "title": "c-bit-manipulation",
                "content": "```\\npublic class Solution\\n{\\n  public int LongestAwesome(string s)\\n  {\\n    var ans = 1;\\n    var masks = new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };\\n\\n    // calculate prefixes\\n    var pre = new int[s.Length + 1];\\n    for (var i = 1; i <= s.Length; i++)\\n      pre[i] = pre[i - 1] ^ masks[s[i - 1] - \\'0\\'];\\n    \\n    // calculate last indexes of prefixes\\n    var lastpos = new int[1024];\\n    for (var i = 0; i < s.Length; i++)\\n      lastpos[pre[i + 1]] = i;\\n\\n    // check max length between last index (+ any variations(10)) and current index\\n    for (var i = 0; i < s.Length; i++)\\n    {\\n      ans = Math.Max(ans, lastpos[pre[i]] - i + 1);\\n\\n      foreach (var mask in masks)\\n        ans = Math.Max(ans, lastpos[pre[i] ^ mask] - i + 1);\\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public int LongestAwesome(string s)\\n  {\\n    var ans = 1;\\n    var masks = new int[] { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 };\\n\\n    // calculate prefixes\\n    var pre = new int[s.Length + 1];\\n    for (var i = 1; i <= s.Length; i++)\\n      pre[i] = pre[i - 1] ^ masks[s[i - 1] - \\'0\\'];\\n    \\n    // calculate last indexes of prefixes\\n    var lastpos = new int[1024];\\n    for (var i = 0; i < s.Length; i++)\\n      lastpos[pre[i + 1]] = i;\\n\\n    // check max length between last index (+ any variations(10)) and current index\\n    for (var i = 0; i < s.Length; i++)\\n    {\\n      ans = Math.Max(ans, lastpos[pre[i]] - i + 1);\\n\\n      foreach (var mask in masks)\\n        ans = Math.Max(ans, lastpos[pre[i] ^ mask] - i + 1);\\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938617,
                "title": "java-solution-hashmap-and-bitmask",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int n = s.length();\\n        int[] idx = new int[(int)Math.pow(2, 10)]; // mask can be 2 ^ 10 at most\\n        // initial state\\n        Arrays.fill(idx, Integer.MAX_VALUE);\\n        idx[0] = -1; \\n        int mask = 0;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            mask ^= 1 << (s.charAt(i) - \\'0\\');\\n            // check the all even case of palindrome\\n            ans = Math.max(ans, i - idx[mask]);\\n            // check the all even but one single case of palindrome\\n            for (int j = 0; j < 10; j++) {\\n                ans = Math.max(ans, i - idx[mask ^ (1 << j)]);\\n            }\\n            // update the min index ever seen\\n            idx[mask] = Math.min(idx[mask], i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        int n = s.length();\\n        int[] idx = new int[(int)Math.pow(2, 10)]; // mask can be 2 ^ 10 at most\\n        // initial state\\n        Arrays.fill(idx, Integer.MAX_VALUE);\\n        idx[0] = -1; \\n        int mask = 0;\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            mask ^= 1 << (s.charAt(i) - \\'0\\');\\n            // check the all even case of palindrome\\n            ans = Math.max(ans, i - idx[mask]);\\n            // check the all even but one single case of palindrome\\n            for (int j = 0; j < 10; j++) {\\n                ans = Math.max(ans, i - idx[mask ^ (1 << j)]);\\n            }\\n            // update the min index ever seen\\n            idx[mask] = Math.min(idx[mask], i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938368,
                "title": "c-98-85-time-o-len-s-and-96-space-o-1-short-code",
                "content": "```\\n#define F(x,y) for(int x = 0 ; x < y ; x++)\\n\\nconst int d_size = 1<<10;\\n\\nclass Solution {\\npublic:\\n    int digit[d_size];\\n    int longestAwesome(string s) {\\n        F(i,d_size) digit[i] = -2;\\n        digit[0] = -1;\\n        int temp = 0, ans = 0;\\n        for(int i = 0 ; s[i] ; i++){\\n            temp ^= (1<<(s[i] - \\'0\\'));\\n            if (digit[temp] == -2) digit[temp] = i;\\n            ans = max(ans, i - digit[temp]);\\n            F(j,10) if (digit[temp^(1<<j)] != -2) ans = max(ans, i - digit[temp^(1<<j)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define F(x,y) for(int x = 0 ; x < y ; x++)\\n\\nconst int d_size = 1<<10;\\n\\nclass Solution {\\npublic:\\n    int digit[d_size];\\n    int longestAwesome(string s) {\\n        F(i,d_size) digit[i] = -2;\\n        digit[0] = -1;\\n        int temp = 0, ans = 0;\\n        for(int i = 0 ; s[i] ; i++){\\n            temp ^= (1<<(s[i] - \\'0\\'));\\n            if (digit[temp] == -2) digit[temp] = i;\\n            ans = max(ans, i - digit[temp]);\\n            F(j,10) if (digit[temp^(1<<j)] != -2) ans = max(ans, i - digit[temp^(1<<j)]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865762,
                "title": "a-simple-solution-in-c-using-bitmasks",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<vector<int>> v(1500, vector<int>(0));\\n        int cur = 0;\\n        for(char x=\\'0\\'; x<=\\'9\\'; x++) if(s[0]==x) cur^=(1<<(x-\\'0\\'));\\n        v[cur].push_back(0);\\n        vector <int> p; p.push_back(0);\\n        for(int i=0; i<=9; i++) p.push_back(1<<i);\\n        int ans = 1;\\n        for(int i=1; i<n; i++) {\\n            for(char x=\\'0\\'; x<=\\'9\\'; x++) if(s[i]==x) cur^=(1<<(x-\\'0\\'));\\n            for(auto x: p) {\\n                if(cur==x) ans = max(ans, i+1);\\n                if(v[cur^x].size()>0) ans = max(ans, i-v[cur^x][0]);\\n            }\\n            v[cur].push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<vector<int>> v(1500, vector<int>(0));\\n        int cur = 0;\\n        for(char x=\\'0\\'; x<=\\'9\\'; x++) if(s[0]==x) cur^=(1<<(x-\\'0\\'));\\n        v[cur].push_back(0);\\n        vector <int> p; p.push_back(0);\\n        for(int i=0; i<=9; i++) p.push_back(1<<i);\\n        int ans = 1;\\n        for(int i=1; i<n; i++) {\\n            for(char x=\\'0\\'; x<=\\'9\\'; x++) if(s[i]==x) cur^=(1<<(x-\\'0\\'));\\n            for(auto x: p) {\\n                if(cur==x) ans = max(ans, i+1);\\n                if(v[cur^x].size()>0) ans = max(ans, i-v[cur^x][0]);\\n            }\\n            v[cur].push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859733,
                "title": "unordered-map-bitmasks-c",
                "content": "Each character can be represented as 10 sized bitmask. For example we represent \\'0\\' as \\'0000000001\\'  \\'1\\' as \\'0000000010\\' \\'2\\' as \\'0000000100\\' so on. For a substring to form pallindrome on rearrangement the count of all characters except possibly one should be even. To check the parity of count of characters of a stirng we do the XOR of bitmasks of all the elements in it. Bits that are 0 are have corresponding letter even number of times and the bits that have 1 should have corresponding letter odd number of times. Therefore XORs like 0001000, 00100000, 000000, will form a pallindrome while 0001001001 etc wont form a pallindrome. So we maintain a cumulative XOR of the array from left to right and try to convert the current XOR to any of the previous form. Following code materialises the idea:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    inline int mask(char x) {\\n        return (1 << (x - \\'0\\'));\\n    }\\n    \\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> arr(n);\\n        for(int i = 0; i < n; ++i) {\\n            arr[i] = mask(s[i]);\\n        }\\n        int i, j;\\n        unordered_map<int, int> H;\\n        H[arr[0]] = 0;\\n        int ans = 1;\\n        int cumXor = arr[0];\\n        H[0] = -1;\\n        for(i = 1; i < n; ++i) {\\n            int m = 0;\\n            int b = cumXor ^ arr[i];\\n            for(j = -1; j <= 9; ++j) {\\n                int newB;\\n                if(j == -1) {\\n                    newB = b;\\n                } else {\\n                    newB = b ^ (1 << j);\\n                }\\n                if(H.find(newB) != H.end()) {\\n                    int d = H[newB];\\n                    d++;\\n                    ans = max(ans, i - d + 1);\\n                }\\n            }\\n            if(H.find(b) == H.end()) {\\n                H[b] = i;\\n            }\\n            cumXor = b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    inline int mask(char x) {\\n        return (1 << (x - \\'0\\'));\\n    }\\n    \\n    int longestAwesome(string s) {\\n        int n = s.size();\\n        vector<int> arr(n);\\n        for(int i = 0; i < n; ++i) {\\n            arr[i] = mask(s[i]);\\n        }\\n        int i, j;\\n        unordered_map<int, int> H;\\n        H[arr[0]] = 0;\\n        int ans = 1;\\n        int cumXor = arr[0];\\n        H[0] = -1;\\n        for(i = 1; i < n; ++i) {\\n            int m = 0;\\n            int b = cumXor ^ arr[i];\\n            for(j = -1; j <= 9; ++j) {\\n                int newB;\\n                if(j == -1) {\\n                    newB = b;\\n                } else {\\n                    newB = b ^ (1 << j);\\n                }\\n                if(H.find(newB) != H.end()) {\\n                    int d = H[newB];\\n                    d++;\\n                    ans = max(ans, i - d + 1);\\n                }\\n            }\\n            if(H.find(b) == H.end()) {\\n                H[b] = i;\\n            }\\n            cumXor = b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857578,
                "title": "python-list-solution-without-xor-in-comments",
                "content": "Why is 3 the expected answer for the string \"9498331\" ? My code returns 5 which i think is correct.\\nCould someone explain me why am I wrong? \\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        counter = [0]*10\\n\\n        for i in s:\\n            counter[int(i)] += 1\\n\\n        output = 0 \\n        flag = True\\n        \\n        for el in counter: \\n            output += el - el%2\\n            if flag and el%2 != 0 :\\n                flag = False\\n                output += 1\\n        \\n        return output\\n                \\n                \\n        \\n",
                "solutionTags": [],
                "code": "Why is 3 the expected answer for the string \"9498331\" ? My code returns 5 which i think is correct.\\nCould someone explain me why am I wrong? \\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        counter = [0]*10\\n\\n        for i in s:\\n            counter[int(i)] += 1\\n\\n        output = 0 \\n        flag = True\\n        \\n        for el in counter: \\n            output += el - el%2\\n            if flag and el%2 != 0 :\\n                flag = False\\n                output += 1\\n        \\n        return output\\n                \\n                \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 800720,
                "title": "concise-python",
                "content": "```\\ndef longestAwesome(self, s: str) -> int:\\n    memo, state = {}, 0\\n    memo[state], ans = -1, 0\\n    for i, c in enumerate(s):            \\n        state ^= 1 << int(c)                        \\n        if state not in memo: memo[state] = i\\n        else: ans = max(ans, i - memo[state])                            \\n        for n in range(10):\\n            state1 = state ^ (1 << n)                                 \\n            if state1 in memo: ans = max(ans, i - memo[state1])\\n    return ans",
                "solutionTags": [],
                "code": "```\\ndef longestAwesome(self, s: str) -> int:\\n    memo, state = {}, 0\\n    memo[state], ans = -1, 0\\n    for i, c in enumerate(s):            \\n        state ^= 1 << int(c)                        \\n        if state not in memo: memo[state] = i\\n        else: ans = max(ans, i - memo[state])                            \\n        for n in range(10):\\n            state1 = state ^ (1 << n)                                 \\n            if state1 in memo: ans = max(ans, i - memo[state1])\\n    return ans",
                "codeTag": "Python3"
            },
            {
                "id": 793647,
                "title": "python-3-solutions-with-and-without-bitmask",
                "content": "Without using bitmask.  \\n\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = 0\\n\\n        # pattern[i] True means we have even number of i so far\\n        # pattern[i] false means we have odd number of i so far\\n        pattern: List[bool] = [False] * 10\\n\\n        existing = {tuple(pattern): -1}\\n\\n        for cur_i, char in enumerate(s):\\n            num = int(char)\\n            pattern[num] = not pattern[num]\\n\\n            for i in range(10):\\n                new_pattern = pattern.copy()\\n                new_pattern[i] = not new_pattern[i]\\n                # `existing[new_pattern]` give us the position of j where\\n                # starting from `j` we know we have 1 odd number.\\n\\t\\t\\t\\t# Default to `cur_i` so that when it is missing from the \\n\\t\\t\\t\\t# existing dict, we don\\'t increase res\\n                res = max(res, cur_i - existing.get(tuple(new_pattern), cur_i))\\n\\n            # If we have `pattern` in `existing`, then we know it is also a palindrome starting from existing[pattern]\\n            res = max(res, cur_i - existing.get(tuple(pattern), cur_i))\\n\\n            existing.setdefault(tuple(pattern), cur_i)\\n\\n        return res\\n```\\n\\nExact same idea as the above but with bit mask. We know `pattern` can be fit inside an integer since it has only 10 possition numbers from `0` to `9` and the maximum will be `1 << 10` (or 1024). \\n\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = 0\\n        pattern = 0\\n\\n        existing = {pattern: -1}\\n\\n        for cur_i, char in enumerate(s):\\n            pattern ^= 1 << int(char)\\n\\n            for i in range(10):\\n                new_pattern = pattern ^ (1 << i)\\n                res = max(res, cur_i - existing.get(new_pattern, cur_i))\\n\\n            res = max(res, cur_i - existing.get(pattern, cur_i))\\n\\n            existing.setdefault(pattern, cur_i)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = 0\\n\\n        # pattern[i] True means we have even number of i so far\\n        # pattern[i] false means we have odd number of i so far\\n        pattern: List[bool] = [False] * 10\\n\\n        existing = {tuple(pattern): -1}\\n\\n        for cur_i, char in enumerate(s):\\n            num = int(char)\\n            pattern[num] = not pattern[num]\\n\\n            for i in range(10):\\n                new_pattern = pattern.copy()\\n                new_pattern[i] = not new_pattern[i]\\n                # `existing[new_pattern]` give us the position of j where\\n                # starting from `j` we know we have 1 odd number.\\n\\t\\t\\t\\t# Default to `cur_i` so that when it is missing from the \\n\\t\\t\\t\\t# existing dict, we don\\'t increase res\\n                res = max(res, cur_i - existing.get(tuple(new_pattern), cur_i))\\n\\n            # If we have `pattern` in `existing`, then we know it is also a palindrome starting from existing[pattern]\\n            res = max(res, cur_i - existing.get(tuple(pattern), cur_i))\\n\\n            existing.setdefault(tuple(pattern), cur_i)\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        res = 0\\n        pattern = 0\\n\\n        existing = {pattern: -1}\\n\\n        for cur_i, char in enumerate(s):\\n            pattern ^= 1 << int(char)\\n\\n            for i in range(10):\\n                new_pattern = pattern ^ (1 << i)\\n                res = max(res, cur_i - existing.get(new_pattern, cur_i))\\n\\n            res = max(res, cur_i - existing.get(pattern, cur_i))\\n\\n            existing.setdefault(pattern, cur_i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793114,
                "title": "c-simple-sln-using-bitmasks-and-hashmap",
                "content": "```\\nint longestAwesome(string s) {\\n  int curr = 0;\\n  unordered_map<int, int> processed;\\n  processed.reserve(size(s));\\n  int ans = 0;\\n  for (int i = 0; i < size(s); ++i) {\\n    curr ^=  1 << (s[i] - \\'0\\');\\n    for (int j = -1; j < 26; ++j) {\\n      int search_value = j >= 0 ? (1 << j) : 0;\\n      if (curr == search_value) {\\n        ans = i + 1;\\n      }\\n      else {\\n        if (auto it = processed.find(curr ^ search_value); it != cend(processed))\\n          ans = max(ans, i - it->second);\\n      }\\n    }\\n    processed.emplace(curr, i);\\n  }\\n  return ans;\\n}",
                "solutionTags": [],
                "code": "```\\nint longestAwesome(string s) {\\n  int curr = 0;\\n  unordered_map<int, int> processed;\\n  processed.reserve(size(s));\\n  int ans = 0;\\n  for (int i = 0; i < size(s); ++i) {\\n    curr ^=  1 << (s[i] - \\'0\\');\\n    for (int j = -1; j < 26; ++j) {\\n      int search_value = j >= 0 ? (1 << j) : 0;\\n      if (curr == search_value) {\\n        ans = i + 1;\\n      }\\n      else {\\n        if (auto it = processed.find(curr ^ search_value); it != cend(processed))\\n          ans = max(ans, i - it->second);\\n      }\\n    }\\n    processed.emplace(curr, i);\\n  }\\n  return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 792531,
                "title": "c-bit-manipulation-exclusive-or-solution",
                "content": "Actually, the problem is very simliar to https://leetcode.com/problems/subarray-sum-equals-k/. \\nInstead of compute pre-sum, we compute exculsive or. \\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        if(s.size()<=1){\\n            return s.size();\\n        }\\n        vector<int> a;\\n        for(int i = 0;i<10;i++){\\n            a.push_back(1<<i);\\n        }\\n        vector<int> m(1024,s.size()); \\n        int hash = 0; \\n        int ret = 0;\\n        for(int i = 0;i<s.size();i++) {\\n            int next_hash = hash ^ (1<<(s[i]-\\'0\\'));\\n            if(next_hash == 0) {\\n                ret = i + 1;\\n                hash = next_hash;\\n                continue;\\n            }\\n            for(auto x : a) {\\n                int y = x ^ next_hash; \\n                if(y == 0) {\\n                    ret = i + 1;\\n                    break;\\n                }\\n                ret = max(ret,i-m[y]);\\n                \\n            }\\n            hash = next_hash;\\n            m[hash] = min(m[hash],i);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        if(s.size()<=1){\\n            return s.size();\\n        }\\n        vector<int> a;\\n        for(int i = 0;i<10;i++){\\n            a.push_back(1<<i);\\n        }\\n        vector<int> m(1024,s.size()); \\n        int hash = 0; \\n        int ret = 0;\\n        for(int i = 0;i<s.size();i++) {\\n            int next_hash = hash ^ (1<<(s[i]-\\'0\\'));\\n            if(next_hash == 0) {\\n                ret = i + 1;\\n                hash = next_hash;\\n                continue;\\n            }\\n            for(auto x : a) {\\n                int y = x ^ next_hash; \\n                if(y == 0) {\\n                    ret = i + 1;\\n                    break;\\n                }\\n                ret = max(ret,i-m[y]);\\n                \\n            }\\n            hash = next_hash;\\n            m[hash] = min(m[hash],i);\\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791313,
                "title": "cpp-hashmap-bitmask-clean-commented-solution",
                "content": "\\n\\t\\n\\t\\n\\t  here we used bitmasking \\n\\t  the number 0000000001 represents odd occurence of \\'0\\' and even occurence off all remaining  digits\\n\\t  another example 0110010101 represents  even occrence of \\'9\\',\\'6\\',\\'5\\',\\'3\\',\\'1\\' and odd occrence of the remaining digits\\n\\t  int longestAwesome(string s)\\n\\t    {\\n          int curr=0;\\n          //to store the first occurance of an particular no\\n          unordered_map<int,int>occ;\\n          int max_len=0;\\n          //occ  of 0 is -1 cause maybe there\\'s and array starting with index 0\\n          occ[0]=-1;\\n             for(int i=0;i<s.length();i++)\\n              {      \\n                    //here we toggle the curr state of our number\\n                    curr^=1<<(s[i]-\\'0\\');\\n                   //if this state is encountered for the first time than store it\\'s it\\'s index\\n                    if(occ.find(curr)==occ.end()){\\n                         occ[curr]=i;\\n                     }\\n                   //here we check the case if there\\'s a number with only one bit toggled in our curr\\n                 //this will handle the palindrome with odd length \\n                //here we allow one number with odd occurance\\n               //this loop will do the work\\n                      for(int j=0;j<10;j++)\\n                      {\\n                              int prev=curr^(1<<j);\\n                              if(occ.find(prev)!=occ.end())\\n                                  {\\n                                    max_len=max(max_len,i-occ[prev]);\\n                                  }\\n                          \\n                      }\\n                 //this is to check the palindrome with even length\\n                    max_len=max(max_len,i-occ[curr]);\\n                    \\n             }\\n        return max_len;\\n    }",
                "solutionTags": [],
                "code": "\\n\\t\\n\\t\\n\\t  here we used bitmasking \\n\\t  the number 0000000001 represents odd occurence of \\'0\\' and even occurence off all remaining  digits\\n\\t  another example 0110010101 represents  even occrence of \\'9\\',\\'6\\',\\'5\\',\\'3\\',\\'1\\' and odd occrence of the remaining digits\\n\\t  int longestAwesome(string s)\\n\\t    {\\n          int curr=0;\\n          //to store the first occurance of an particular no\\n          unordered_map<int,int>occ;\\n          int max_len=0;\\n          //occ  of 0 is -1 cause maybe there\\'s and array starting with index 0\\n          occ[0]=-1;\\n             for(int i=0;i<s.length();i++)\\n              {      \\n                    //here we toggle the curr state of our number\\n                    curr^=1<<(s[i]-\\'0\\');\\n                   //if this state is encountered for the first time than store it\\'s it\\'s index\\n                    if(occ.find(curr)==occ.end()){\\n                         occ[curr]=i;\\n                     }\\n                   //here we check the case if there\\'s a number with only one bit toggled in our curr\\n                 //this will handle the palindrome with odd length \\n                //here we allow one number with odd occurance\\n               //this loop will do the work\\n                      for(int j=0;j<10;j++)\\n                      {\\n                              int prev=curr^(1<<j);\\n                              if(occ.find(prev)!=occ.end())\\n                                  {\\n                                    max_len=max(max_len,i-occ[prev]);\\n                                  }\\n                          \\n                      }\\n                 //this is to check the palindrome with even length\\n                    max_len=max(max_len,i-occ[curr]);\\n                    \\n             }\\n        return max_len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 784749,
                "title": "python-sliding-window-solution-by-compacting-large-input-strings",
                "content": "```python\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        \\n        def compact_string(tempString):\\n            startPoint = 0\\n\\n            while startPoint < len(tempString):\\n                count = 1\\n                while startPoint+1 < len(tempString) and tempString[startPoint] == tempString[startPoint+1]:\\n                    tempString.pop(startPoint+1)\\n                    count += 1\\n\\n                if count >= 1000:\\n\\n                    startVal = tempString[startPoint]\\n                    for i in range(20):\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                        startPoint += 1\\n                        count -= 1\\n                    while count > 1000:\\n                        tempString.insert(startPoint, startVal + \"1000\")\\n                        startPoint += 1\\n                        count -= 1000\\n                    count -= 20\\n                    if count % 2 != 0:\\n                        tempString[startPoint] = tempString[startPoint] + str(count-1)\\n                        tempString.insert(startPoint+1, tempString[startPoint][0] + str(1))\\n                        startPoint += 1\\n                    else:\\n                        tempString[startPoint] = tempString[startPoint] + str(count)\\n                    for i in range(20):\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                        startPoint += 1\\n                else:\\n                    startVal = tempString[startPoint]\\n                    tempString[startPoint] = startVal + \"1\"\\n                    for i in range(count-1):\\n                        startPoint += 1\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                startPoint += 1\\n            return tempString\\n        \\n        s = compact_string(list(s))\\n        \\n        def is_awesome_db(db):\\n            temp_db = {}\\n            for k, v in db.iteritems():\\n                if k[0] not in temp_db:\\n                    temp_db[k[0]] = 0\\n                temp_db[k[0]] += int(k[1:]) * v\\n            size = sum(temp_db.values())\\n            return len([x for x in temp_db.values() if x % 2 != 0]) < 2, size\\n       \\n        def sliding_window(size):\\n            db = {}\\n            for i in range((len(s)-size)+1):\\n                if len(db) == 0:\\n                    for v in s[i:i+size]:\\n                        if v not in db:\\n                            db[v] = 0\\n                        db[v] += 1\\n                else:\\n                    db[s[i-1]] -= 1\\n                    if s[i+size-1] not in db:\\n                        db[s[i+size-1]] = 0\\n                    db[s[i+size-1]] += 1\\n                    if db[s[i-1]] == 0:\\n                        del db[s[i-1]]\\n                success, string_size = is_awesome_db(db)\\n                if success:\\n                    return string_size\\n            return 0\\n        \\n        for i in range(len(s)):\\n            string_size = sliding_window(len(s)-i)\\n            if string_size > 0:\\n                return string_size\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        \\n        def compact_string(tempString):\\n            startPoint = 0\\n\\n            while startPoint < len(tempString):\\n                count = 1\\n                while startPoint+1 < len(tempString) and tempString[startPoint] == tempString[startPoint+1]:\\n                    tempString.pop(startPoint+1)\\n                    count += 1\\n\\n                if count >= 1000:\\n\\n                    startVal = tempString[startPoint]\\n                    for i in range(20):\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                        startPoint += 1\\n                        count -= 1\\n                    while count > 1000:\\n                        tempString.insert(startPoint, startVal + \"1000\")\\n                        startPoint += 1\\n                        count -= 1000\\n                    count -= 20\\n                    if count % 2 != 0:\\n                        tempString[startPoint] = tempString[startPoint] + str(count-1)\\n                        tempString.insert(startPoint+1, tempString[startPoint][0] + str(1))\\n                        startPoint += 1\\n                    else:\\n                        tempString[startPoint] = tempString[startPoint] + str(count)\\n                    for i in range(20):\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                        startPoint += 1\\n                else:\\n                    startVal = tempString[startPoint]\\n                    tempString[startPoint] = startVal + \"1\"\\n                    for i in range(count-1):\\n                        startPoint += 1\\n                        tempString.insert(startPoint, startVal + \"1\")\\n                startPoint += 1\\n            return tempString\\n        \\n        s = compact_string(list(s))\\n        \\n        def is_awesome_db(db):\\n            temp_db = {}\\n            for k, v in db.iteritems():\\n                if k[0] not in temp_db:\\n                    temp_db[k[0]] = 0\\n                temp_db[k[0]] += int(k[1:]) * v\\n            size = sum(temp_db.values())\\n            return len([x for x in temp_db.values() if x % 2 != 0]) < 2, size\\n       \\n        def sliding_window(size):\\n            db = {}\\n            for i in range((len(s)-size)+1):\\n                if len(db) == 0:\\n                    for v in s[i:i+size]:\\n                        if v not in db:\\n                            db[v] = 0\\n                        db[v] += 1\\n                else:\\n                    db[s[i-1]] -= 1\\n                    if s[i+size-1] not in db:\\n                        db[s[i+size-1]] = 0\\n                    db[s[i+size-1]] += 1\\n                    if db[s[i-1]] == 0:\\n                        del db[s[i-1]]\\n                success, string_size = is_awesome_db(db)\\n                if success:\\n                    return string_size\\n            return 0\\n        \\n        for i in range(len(s)):\\n            string_size = sliding_window(len(s)-i)\\n            if string_size > 0:\\n                return string_size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782677,
                "title": "java-simple-and-clear-solution-using-bitmap",
                "content": "```\\n\\tpublic int longestAwesome(String s) {\\n\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, -1);\\n\\t\\tint res = 1;\\n\\t\\tint mask = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tmask ^= 1 << (s.charAt(i) - \\'0\\');\\n\\t\\t\\tList<Integer> possiblePrefix = generateValidPrefix(mask);\\n\\t\\t\\tfor (int prefix : possiblePrefix) {\\n\\t\\t\\t\\tif (map.containsKey(prefix)) {\\n\\t\\t\\t\\t\\tres = Math.max(res, i - map.get(prefix));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!map.containsKey(mask)) {\\n\\t\\t\\t\\tmap.put(mask, i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    \\n    private List<Integer> generateValidPrefix(int mask) {\\n        List<Integer> prefixes = new ArrayList<>();\\n        prefixes.add(mask);\\n        for (int i = 0; i < 10; i++) {\\n            prefixes.add(1 << i ^ mask);\\n        }\\n        return prefixes;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int longestAwesome(String s) {\\n\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\tmap.put(0, -1);\\n\\t\\tint res = 1;\\n\\t\\tint mask = 0;\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tmask ^= 1 << (s.charAt(i) - \\'0\\');\\n\\t\\t\\tList<Integer> possiblePrefix = generateValidPrefix(mask);\\n\\t\\t\\tfor (int prefix : possiblePrefix) {\\n\\t\\t\\t\\tif (map.containsKey(prefix)) {\\n\\t\\t\\t\\t\\tres = Math.max(res, i - map.get(prefix));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (!map.containsKey(mask)) {\\n\\t\\t\\t\\tmap.put(mask, i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n    \\n    private List<Integer> generateValidPrefix(int mask) {\\n        List<Integer> prefixes = new ArrayList<>();\\n        prefixes.add(mask);\\n        for (int i = 0; i < 10; i++) {\\n            prefixes.add(1 << i ^ mask);\\n        }\\n        return prefixes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781888,
                "title": "python-bitmask",
                "content": "Store in prefix if we have an odd or even number of elements for each numer from 0 to 9, update using xor, then check if have seen a valid state.\\n```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        d = {i: 2**i for i in range(10)}\\n        lookup = {0: -1} \\n        prefix = 0\\n        ans = 0 \\n        for i, num in enumerate(map(int,s)):\\n            prefix ^= d[num]\\n            if prefix not in lookup: lookup[prefix] = i  \\n            k = min([lookup[prefix]]+[lookup[prefix^d[x]] for x in d if prefix^d[x] in lookup])\\n            ans = max(ans, i-k)\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestAwesome(self, s: str) -> int:\\n        d = {i: 2**i for i in range(10)}\\n        lookup = {0: -1} \\n        prefix = 0\\n        ans = 0 \\n        for i, num in enumerate(map(int,s)):\\n            prefix ^= d[num]\\n            if prefix not in lookup: lookup[prefix] = i  \\n            k = min([lookup[prefix]]+[lookup[prefix^d[x]] for x in d if prefix^d[x] in lookup])\\n            ans = max(ans, i-k)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 781730,
                "title": "o-n-1024-11-not-o-10-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> m(1024, 200000), n(1024, -1);\\n        int p = 0, r = 0;\\n        m[0] = n[0] = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            p ^= (1 << (s[i] - \\'0\\'));\\n            n[p] = i + 1;\\n            if (m[p] == 200000) m[p] = i + 1;\\n        }\\n        for (int i = 0; i < 1024; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                r = max(r, n[i ^ (1 << j)] - m[i]);\\n            }\\n            r = max(r, n[i] - m[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int> m(1024, 200000), n(1024, -1);\\n        int p = 0, r = 0;\\n        m[0] = n[0] = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            p ^= (1 << (s[i] - \\'0\\'));\\n            n[p] = i + 1;\\n            if (m[p] == 200000) m[p] = i + 1;\\n        }\\n        for (int i = 0; i < 1024; ++i) {\\n            for (int j = 0; j < 10; ++j) {\\n                r = max(r, n[i ^ (1 << j)] - m[i]);\\n            }\\n            r = max(r, n[i] - m[i]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781706,
                "title": "why-tle-passing-133-153-tcs-can-t-it-be-done-without-bitmasking",
                "content": "```\\nclass Solution {\\n    int max = 1;\\n    Map<String, Integer> memo = new HashMap<>();\\n    public int longestAwesome(String s) {\\n        return choice(new StringBuilder(s), 0, s.length());\\n    }\\n    \\n    private int choice(StringBuilder s, int i, int j) {\\n        if (j - i < max) return j - i;\\n        if (i >= j) return max;\\n        if (memo.containsKey(s.substring(i, j))) {\\n            return Math.max(max, memo.get(s.substring(i, j)));\\n        }\\n        if (isPalindrome(s, i, j)) {\\n            max = Math.max(max, j - i);\\n            return max;\\n        }\\n        int m = choice(s, i + 1, j - 1);\\n        memo.put(s.substring(i + 1, j - 1), m);\\n        int l = choice(s, i, j - 1);\\n        memo.put(s.substring(i, j - 1), l);\\n        int r = choice(s, i + 1, j);\\n        memo.put(s.substring(i + 1, j), r);\\n        return Math.max(m, Math.max(l, r));\\n    }\\n    \\n    Map<String, Boolean> memo2 = new HashMap<>();\\n    private boolean isPalindrome(StringBuilder s, int i, int j) {\\n        String key = i + \"_\" + j + \"_\" + s;\\n        if (memo2.containsKey(key)) return memo2.containsKey(key);\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int k = i; k < j; k++) {\\n            char c = s.charAt(k);\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        int odd = 0;\\n        for(char c : map.keySet()) {\\n            if (map.get(c) % 2 != 0) odd++;\\n        }\\n        if (odd > 1) {\\n            memo2.put(key, false);\\n            return false;\\n        }\\n        memo2.put(key, true);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int max = 1;\\n    Map<String, Integer> memo = new HashMap<>();\\n    public int longestAwesome(String s) {\\n        return choice(new StringBuilder(s), 0, s.length());\\n    }\\n    \\n    private int choice(StringBuilder s, int i, int j) {\\n        if (j - i < max) return j - i;\\n        if (i >= j) return max;\\n        if (memo.containsKey(s.substring(i, j))) {\\n            return Math.max(max, memo.get(s.substring(i, j)));\\n        }\\n        if (isPalindrome(s, i, j)) {\\n            max = Math.max(max, j - i);\\n            return max;\\n        }\\n        int m = choice(s, i + 1, j - 1);\\n        memo.put(s.substring(i + 1, j - 1), m);\\n        int l = choice(s, i, j - 1);\\n        memo.put(s.substring(i, j - 1), l);\\n        int r = choice(s, i + 1, j);\\n        memo.put(s.substring(i + 1, j), r);\\n        return Math.max(m, Math.max(l, r));\\n    }\\n    \\n    Map<String, Boolean> memo2 = new HashMap<>();\\n    private boolean isPalindrome(StringBuilder s, int i, int j) {\\n        String key = i + \"_\" + j + \"_\" + s;\\n        if (memo2.containsKey(key)) return memo2.containsKey(key);\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int k = i; k < j; k++) {\\n            char c = s.charAt(k);\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        int odd = 0;\\n        for(char c : map.keySet()) {\\n            if (map.get(c) % 2 != 0) odd++;\\n        }\\n        if (odd > 1) {\\n            memo2.put(key, false);\\n            return false;\\n        }\\n        memo2.put(key, true);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780773,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<String,Integer> map = new HashMap<>();\\n        int sum = 0;\\n        int ans = 0;\\n        map.put(\"0\" , -1);\\n        for(int j = 0 ; j < s.length() ; j++){\\n            int t = s.charAt(j) -\\'0\\';\\n            sum ^= (1 << t);\\n            \\n            for(int i = 0 ; i <= 9 ; i++){\\n                int m = sum ^ (1 << i);\\n                if(map.containsKey(String.valueOf(m))){\\n                    ans = Math.max(ans , j - map.get(String.valueOf(m)));\\n                }\\n            }\\n            if(!map.containsKey(sum+\"\")){\\n                map.put(sum+\"\" , j);\\n            }else{\\n                ans = Math.max(ans , j - map.get(String.valueOf(sum)));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        Map<String,Integer> map = new HashMap<>();\\n        int sum = 0;\\n        int ans = 0;\\n        map.put(\"0\" , -1);\\n        for(int j = 0 ; j < s.length() ; j++){\\n            int t = s.charAt(j) -\\'0\\';\\n            sum ^= (1 << t);\\n            \\n            for(int i = 0 ; i <= 9 ; i++){\\n                int m = sum ^ (1 << i);\\n                if(map.containsKey(String.valueOf(m))){\\n                    ans = Math.max(ans , j - map.get(String.valueOf(m)));\\n                }\\n            }\\n            if(!map.containsKey(sum+\"\")){\\n                map.put(sum+\"\" , j);\\n            }else{\\n                ans = Math.max(ans , j - map.get(String.valueOf(sum)));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780419,
                "title": "c-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.length();\\n        unordered_map<int, int> m;\\n        int curr =0;\\n        m[0]=-1;\\n        int res =0;\\n        for(int i =0; i< n; i++){\\n            int sh = s[i]-\\'0\\';\\n            curr  ^= (1<<sh);\\n            for(int j =0; j< 10; j++){\\n                int temp = curr ^ (1<<j);\\n                if(m.count(temp)) res = max(res, i-m[temp]);\\n            }\\n            if(m.count(curr)) res = max(res, i-m[curr]);\\n            else m[curr]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n = s.length();\\n        unordered_map<int, int> m;\\n        int curr =0;\\n        m[0]=-1;\\n        int res =0;\\n        for(int i =0; i< n; i++){\\n            int sh = s[i]-\\'0\\';\\n            curr  ^= (1<<sh);\\n            for(int j =0; j< 10; j++){\\n                int temp = curr ^ (1<<j);\\n                if(m.count(temp)) res = max(res, i-m[temp]);\\n            }\\n            if(m.count(curr)) res = max(res, i-m[curr]);\\n            else m[curr]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780336,
                "title": "java-prefix-mask",
                "content": "Ref: https://leetcode.com/problems/find-longest-awesome-substring/discuss/779919/JavaC%2B%2BPython-Prefix-%2B-BitMask\\n```\\n    public int longestAwesome(String s) {\\n        int n = s.length(), res = 0, len = (int) Math.pow(2, 10), mask[] = new int[len + 1], curr = 0;\\n        Arrays.fill(mask, n);\\n        mask[curr] = -1;  // prefix mask init\\n        for (int i = 0; i < n; i++) {\\n            int num = s.charAt(i) - \\'0\\';  // switch, even as 0, odd as 1;\\n            curr ^= 1 << num;\\n            for (int j = 0; j < 10; j++) res = Math.max(res, i - mask[curr ^ (1 << j)]);  // 212\\n            res = Math.max(res, i - mask[curr]); // 22\\n            mask[curr] = Math.min(i, mask[curr]);  // keep the first exists;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestAwesome(String s) {\\n        int n = s.length(), res = 0, len = (int) Math.pow(2, 10), mask[] = new int[len + 1], curr = 0;\\n        Arrays.fill(mask, n);\\n        mask[curr] = -1;  // prefix mask init\\n        for (int i = 0; i < n; i++) {\\n            int num = s.charAt(i) - \\'0\\';  // switch, even as 0, odd as 1;\\n            curr ^= 1 << num;\\n            for (int j = 0; j < 10; j++) res = Math.max(res, i - mask[curr ^ (1 << j)]);  // 212\\n            res = Math.max(res, i - mask[curr]); // 22\\n            mask[curr] = Math.min(i, mask[curr]);  // keep the first exists;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780077,
                "title": "java-o-n-one-pass-solution-with-easy-explanation-and-heavily-commented",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        /*\\n        Check if the digit with value i(0-9) is present odd or even time in the present calculated number. Suppose x of the digits are present in odd numbers and 10-x are present in even numbers.\\n        If we get a previous calculated number, where the same x digits are present in odd numbers, then we can simply calculate the difference of the indices of the current number and the previous calculated number, in this case we can get a palindrome with all the digits present in even numbers. Now, we need to find such palindromes where one of the digit is present in odd number, rest in even number. To do so, we need to find for any previously calculated number where we have every other digits in the same parity(even/odd), except one.                \\n        */\\n        HashMap<Integer,Integer>hmap=new HashMap<>();\\n        hmap.put(0,-1); // number 0 has count of every digits 0, hence even.\\n        int n=s.length();\\n        /*\\n            sum stores the pesent calculated number after processing at index i.\\n            \\n            for every digit, I used one bit. The bit is set if the digit is found odd times else unset. Digit 0 given the right most bit and digit 9, the 10th bit from right.\\n            \\n            hmap maps the generated number to the index it was found first.\\n            \\n            max stores the maximum length.\\n            \\n            sum starts with 0 and for every digit we encounter, we xor that digits bit with 1, so that the value flips. If previously, it was in odd count, it will not become even count(unset) and vice versa.\\n        */\\n        \\n        int sum=0,z,max=0;\\n        for(int i=0;i<n;i++){\\n            z=s.charAt(i)-\\'0\\'; // the digit at ith place.\\n            sum^=(1<<z);       // the presently generated number.\\n            for(int j=0;j<10;j++) \\n                \\n                if(hmap.containsKey(sum^(1<<j))) // flipping one bit to find any previously generated number, hence finding palindromes with only one digit present odd number of times.\\n                    max=Math.max(max,i-hmap.get(sum^(1<<j)));\\n            \\n            // if same number was generated before, we get a palindrome with all digits appearing even number of times.\\n            if(hmap.containsKey(sum))\\n                    max=Math.max(max,i-hmap.get(sum));\\n            else\\n                hmap.put(sum,i);   // the present index is set only when no such number was found previously. This gives the maximum length of palindrome.\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        /*\\n        Check if the digit with value i(0-9) is present odd or even time in the present calculated number. Suppose x of the digits are present in odd numbers and 10-x are present in even numbers.\\n        If we get a previous calculated number, where the same x digits are present in odd numbers, then we can simply calculate the difference of the indices of the current number and the previous calculated number, in this case we can get a palindrome with all the digits present in even numbers. Now, we need to find such palindromes where one of the digit is present in odd number, rest in even number. To do so, we need to find for any previously calculated number where we have every other digits in the same parity(even/odd), except one.                \\n        */\\n        HashMap<Integer,Integer>hmap=new HashMap<>();\\n        hmap.put(0,-1); // number 0 has count of every digits 0, hence even.\\n        int n=s.length();\\n        /*\\n            sum stores the pesent calculated number after processing at index i.\\n            \\n            for every digit, I used one bit. The bit is set if the digit is found odd times else unset. Digit 0 given the right most bit and digit 9, the 10th bit from right.\\n            \\n            hmap maps the generated number to the index it was found first.\\n            \\n            max stores the maximum length.\\n            \\n            sum starts with 0 and for every digit we encounter, we xor that digits bit with 1, so that the value flips. If previously, it was in odd count, it will not become even count(unset) and vice versa.\\n        */\\n        \\n        int sum=0,z,max=0;\\n        for(int i=0;i<n;i++){\\n            z=s.charAt(i)-\\'0\\'; // the digit at ith place.\\n            sum^=(1<<z);       // the presently generated number.\\n            for(int j=0;j<10;j++) \\n                \\n                if(hmap.containsKey(sum^(1<<j))) // flipping one bit to find any previously generated number, hence finding palindromes with only one digit present odd number of times.\\n                    max=Math.max(max,i-hmap.get(sum^(1<<j)));\\n            \\n            // if same number was generated before, we get a palindrome with all digits appearing even number of times.\\n            if(hmap.containsKey(sum))\\n                    max=Math.max(max,i-hmap.get(sum));\\n            else\\n                hmap.put(sum,i);   // the present index is set only when no such number was found previously. This gives the maximum length of palindrome.\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780062,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int counter = 0;\\n        vector<int> state(1<<10, -1);        \\n        state[0] = 0;\\n        int ans = 0;\\n        int cur = 0;\\n        for(int i = 0; i < s.size(); ++i) {\\n            cur ^= 1 << (s[i] - \\'0\\');\\n            if(state[cur] == -1)\\n                state[cur] = i + 1;\\n            ans = max(ans, i - state[cur] + 1);\\n            for(int j = 0; j <= 9; ++j) {\\n                int ns = cur ^ (1 << j);\\n                if(state[ns]>=0)\\n                    ans = max(ans, i - state[ns] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int counter = 0;\\n        vector<int> state(1<<10, -1);        \\n        state[0] = 0;\\n        int ans = 0;\\n        int cur = 0;\\n        for(int i = 0; i < s.size(); ++i) {\\n            cur ^= 1 << (s[i] - \\'0\\');\\n            if(state[cur] == -1)\\n                state[cur] = i + 1;\\n            ans = max(ans, i - state[cur] + 1);\\n            for(int j = 0; j <= 9; ++j) {\\n                int ns = cur ^ (1 << j);\\n                if(state[ns]>=0)\\n                    ans = max(ans, i - state[ns] + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780060,
                "title": "javascript",
                "content": "```\\nvar longestAwesome = function(s) {\\n  let Z = 0;\\n  for (let d = 0; d < 10; d += 1) Z = Math.max(Z, f(s, d));\\n  return Z;\\n};\\n\\nfunction f(s, d) {\\n  let sn = Array(1024).fill(-1);\\n  sn[0] = 0;\\n  let cur = 0;\\n  let z = 0;\\n  for (let i = 0; i < s.length; i += 1) {\\n    let x = +s[i] - 0;\\n    if (x != d) cur ^= 1 << x;\\n    if (~sn[cur]) z = Math.max(z, i - sn[cur] + 1);\\n    else sn[cur] = i + 1;\\n  }\\n  return z;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestAwesome = function(s) {\\n  let Z = 0;\\n  for (let d = 0; d < 10; d += 1) Z = Math.max(Z, f(s, d));\\n  return Z;\\n};\\n\\nfunction f(s, d) {\\n  let sn = Array(1024).fill(-1);\\n  sn[0] = 0;\\n  let cur = 0;\\n  let z = 0;\\n  for (let i = 0; i < s.length; i += 1) {\\n    let x = +s[i] - 0;\\n    if (x != d) cur ^= 1 << x;\\n    if (~sn[cur]) z = Math.max(z, i - sn[cur] + 1);\\n    else sn[cur] = i + 1;\\n  }\\n  return z;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779990,
                "title": "why-is-this-code-giving-tle",
                "content": "```  \\n class Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size() ;\\n        int dp[10][n+1] ;\\n               int i ; \\n        for(i=0;i<10;i++)\\n            dp[i][0]=0 ;\\n        map<vector<int>,int> p ;\\n       int x=1 ;\\n        vector<int> v ;\\n \\n        for(i=0;i<10;i++)\\n        {\\n            v.push_back(0) ;\\n        }\\n        p[v]=0 ;\\n        for(i=1;i<=n;i++)\\n        {\\n            int j ;\\n            for(j=0;j<10;j++)\\n                dp[j][i]=dp[j][i-1] ;\\n            dp[(s[i-1]-\\'0\\')][i]=(dp[(s[i-1]-\\'0\\')][i]^1) ;\\n            vector<int> v ;\\n            for(j=0;j<10;j++)\\n                v.push_back(dp[j][i]) ;\\n            if(p.find(v)!=p.end())\\n             x=max(x,i-p[v]) ; \\n            else p[v]=i ;\\n           \\n            for(int k=0;k<10;k++)\\n            {\\n                vector<int> ans=v ;\\n                ans[k]=v[k]^1 ;\\n                if(p.find(ans)!=p.end())\\n                {  \\n                    x=max(x,i-p[ans]) ; } \\n            }\\n          //  cout<<x<<\" \" ;\\n            \\n        }\\n        return x ;\\n        \\n        \\n    }\\n};   ```   \\nThe time complexity seems fine?\\n",
                "solutionTags": [],
                "code": "```  \\n class Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int n=s.size() ;\\n        int dp[10][n+1] ;\\n               int i ; \\n        for(i=0;i<10;i++)\\n            dp[i][0]=0 ;\\n        map<vector<int>,int> p ;\\n       int x=1 ;\\n        vector<int> v ;\\n \\n        for(i=0;i<10;i++)\\n        {\\n            v.push_back(0) ;\\n        }\\n        p[v]=0 ;\\n        for(i=1;i<=n;i++)\\n        {\\n            int j ;\\n            for(j=0;j<10;j++)\\n                dp[j][i]=dp[j][i-1] ;\\n            dp[(s[i-1]-\\'0\\')][i]=(dp[(s[i-1]-\\'0\\')][i]^1) ;\\n            vector<int> v ;\\n            for(j=0;j<10;j++)\\n                v.push_back(dp[j][i]) ;\\n            if(p.find(v)!=p.end())\\n             x=max(x,i-p[v]) ; \\n            else p[v]=i ;\\n           \\n            for(int k=0;k<10;k++)\\n            {\\n                vector<int> ans=v ;\\n                ans[k]=v[k]^1 ;\\n                if(p.find(ans)!=p.end())\\n                {  \\n                    x=max(x,i-p[ans]) ; } \\n            }\\n          //  cout<<x<<\" \" ;\\n            \\n        }\\n        return x ;\\n        \\n        \\n    }\\n};   ```",
                "codeTag": "C++"
            },
            {
                "id": 779936,
                "title": "python-o-10-n-bitmask",
                "content": "```\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = collections.defaultdict(int)\\n        dp[0] = -1\\n        \\n        ans = 0\\n        curr = 0\\n        for i,c in enumerate(s):\\n            curr ^= (1 << int(c))\\n            \\n            if not curr:\\n                ans = max(ans,i-dp[curr])\\n            else:\\n                for j in reversed(range(10)):\\n                    if (curr ^ (1 << j)) in dp:\\n                        ans = max(ans,i-dp[(curr ^ (1 << j))])\\n            \\n            if curr not in dp:\\n                dp[curr] = i\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestAwesome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        dp = collections.defaultdict(int)\\n        dp[0] = -1\\n        \\n        ans = 0\\n        curr = 0\\n        for i,c in enumerate(s):\\n            curr ^= (1 << int(c))\\n            \\n            if not curr:\\n                ans = max(ans,i-dp[curr])\\n            else:\\n                for j in reversed(range(10)):\\n                    if (curr ^ (1 << j)) in dp:\\n                        ans = max(ans,i-dp[(curr ^ (1 << j))])\\n            \\n            if curr not in dp:\\n                dp[curr] = i\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779924,
                "title": "c-dp-with-bitmask-o-10-n",
                "content": "Use dp to solve this problem.\\nA substring is awesome if there is at most one digit has the odd number of appearance time.\\nFor each index i, we need to find the smallest index j in which s[j..i] is awesome substring.\\nTo determine the smallest proper index, we need a bitmask array f[0..2^10-1].\\n  - f[status] is the smallest index i if the substring s[0..i] has a bitmask is status.\\n  - status represents in bitmask from (0..9), bit (0,1) for digit j if s[0..i] has the number of appearance time is even or odd.\\n\\nTime: O(10*N)\\nSpace: O(2^10)\\n\\n```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int f[1 << 10]; // this is a bitmask array to store the smallest index.\\n        int digits[10]; // to store the number of appearance for each digit.\\n        memset(f, -1, sizeof(f));\\n        memset(digits, 0, sizeof(digits));\\n        f[0] = 0;\\n        int res = 0;\\n        for (int i = 1; i <= s.length(); i++) {\\n            digits[s[i-1]-\\'0\\'] = (digits[s[i-1]-\\'0\\'] + 1) % 2;\\n            int value = 0;\\n            for (int j = 0; j < 10; j++)\\n                if (digits[j] == 1) value += 1 << j;\\n            if (f[value] > -1) res = max(res, i-f[value]);\\n            for (int j = 0; j < 10; j++) {\\n                if (digits[j] == 0) {\\n                    int newValue = value + (1 << j);\\n                    if (f[newValue] > -1) res = max(res, i-f[newValue]);\\n                } else {\\n                    int newValue = value - (1 << j);\\n                    if (f[newValue] > -1) res = max(res, i-f[newValue]);\\n                }\\n            }\\n            if (f[value] == -1) f[value] = i; // store the smallest index\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        int f[1 << 10]; // this is a bitmask array to store the smallest index.\\n        int digits[10]; // to store the number of appearance for each digit.\\n        memset(f, -1, sizeof(f));\\n        memset(digits, 0, sizeof(digits));\\n        f[0] = 0;\\n        int res = 0;\\n        for (int i = 1; i <= s.length(); i++) {\\n            digits[s[i-1]-\\'0\\'] = (digits[s[i-1]-\\'0\\'] + 1) % 2;\\n            int value = 0;\\n            for (int j = 0; j < 10; j++)\\n                if (digits[j] == 1) value += 1 << j;\\n            if (f[value] > -1) res = max(res, i-f[value]);\\n            for (int j = 0; j < 10; j++) {\\n                if (digits[j] == 0) {\\n                    int newValue = value + (1 << j);\\n                    if (f[newValue] > -1) res = max(res, i-f[newValue]);\\n                } else {\\n                    int newValue = value - (1 << j);\\n                    if (f[newValue] > -1) res = max(res, i-f[newValue]);\\n                }\\n            }\\n            if (f[value] == -1) f[value] = i; // store the smallest index\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779923,
                "title": "java-bitmask-prefix-map-o-n",
                "content": "```\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int res = 0,mask = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            mask = mask ^ ( 1 << (s.charAt(i) - \\'0\\'));\\n            if(!map.containsKey(mask)) map.put(mask, i);\\n            res = Math.max(res, i - map.get(mask));\\n            int temp = mask;\\n            for(int j = 0; j <=9; j++){\\n                temp = mask ^(1 << j);\\n                if(map.containsKey(temp)) res = Math.max(res, i - map.get(temp));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestAwesome(String s) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int res = 0,mask = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            mask = mask ^ ( 1 << (s.charAt(i) - \\'0\\'));\\n            if(!map.containsKey(mask)) map.put(mask, i);\\n            res = Math.max(res, i - map.get(mask));\\n            int temp = mask;\\n            for(int j = 0; j <=9; j++){\\n                temp = mask ^(1 << j);\\n                if(map.containsKey(temp)) res = Math.max(res, i - map.get(temp));\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779914,
                "title": "tle-the-best-i-could-do",
                "content": "```\\nclass Solution {\\n    \\n    unordered_map<string,int> cache;\\n    \\n    bool isMapPalindrome(unordered_map<char,int>& myMap) {\\n        //one odd or no odd\\n        int oddCount = 0;\\n        \\n        for(auto& m: myMap) {\\n            if(m.second % 2 == 1)\\n                oddCount++;\\n        }\\n        \\n        if(oddCount <= 1)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<char,int> myMap;\\n        \\n        if(cache.find(s) != cache.end())\\n            return cache[s];\\n        \\n        for(auto& ch: s)\\n            myMap[ch]++;\\n        \\n        if(isMapPalindrome(myMap)) {\\n            \\n            cache[s] = s.length();\\n            \\n            return s.length();\\n        }\\n        \\n        string sleft =  s.substr(0, s.size() - 1);\\n        string sright = s.substr(1, s.size() - 1);\\n        string middle = s.substr(1, s.size() - 2);\\n        \\n        \\n        cache[s] = max(max(longestAwesome(sleft), longestAwesome(sright)),longestAwesome(middle));\\n        return cache[s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    unordered_map<string,int> cache;\\n    \\n    bool isMapPalindrome(unordered_map<char,int>& myMap) {\\n        //one odd or no odd\\n        int oddCount = 0;\\n        \\n        for(auto& m: myMap) {\\n            if(m.second % 2 == 1)\\n                oddCount++;\\n        }\\n        \\n        if(oddCount <= 1)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\npublic:\\n    int longestAwesome(string s) {\\n        unordered_map<char,int> myMap;\\n        \\n        if(cache.find(s) != cache.end())\\n            return cache[s];\\n        \\n        for(auto& ch: s)\\n            myMap[ch]++;\\n        \\n        if(isMapPalindrome(myMap)) {\\n            \\n            cache[s] = s.length();\\n            \\n            return s.length();\\n        }\\n        \\n        string sleft =  s.substr(0, s.size() - 1);\\n        string sright = s.substr(1, s.size() - 1);\\n        string middle = s.substr(1, s.size() - 2);\\n        \\n        \\n        cache[s] = max(max(longestAwesome(sleft), longestAwesome(sright)),longestAwesome(middle));\\n        return cache[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779895,
                "title": "java-prefix-bitmask-o-11-n",
                "content": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int fHash = 0;\\n        int n = s.length();\\n        int res = 0;\\n        map.put(fHash, -1);\\n        for(int i=0; i<n; i++){\\n            int cIndex = s.charAt(i)-\\'0\\';\\n            fHash = fHash^(1<<cIndex);\\n            res = Math.max(i-map.getOrDefault(fHash, i), res);\\n            for(int j=0; j<10; j++){\\n                int posHash = 1<<j;\\n                int prevHash = fHash^posHash;\\n                res = Math.max(i-map.getOrDefault(prevHash, i), res);\\n            }\\n            map.putIfAbsent(fHash, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestAwesome(String s) {\\n        HashMap<Integer, Integer> map = new HashMap();\\n        int fHash = 0;\\n        int n = s.length();\\n        int res = 0;\\n        map.put(fHash, -1);\\n        for(int i=0; i<n; i++){\\n            int cIndex = s.charAt(i)-\\'0\\';\\n            fHash = fHash^(1<<cIndex);\\n            res = Math.max(i-map.getOrDefault(fHash, i), res);\\n            for(int j=0; j<10; j++){\\n                int posHash = 1<<j;\\n                int prevHash = fHash^posHash;\\n                res = Math.max(i-map.getOrDefault(prevHash, i), res);\\n            }\\n            map.putIfAbsent(fHash, i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779891,
                "title": "same-concept-as-longest-subarray-with-given-sum",
                "content": "**Same Concept as longest subarray with given sum**\\n\\n```class Solution:\\n    def getRequired(self, currentCount):\\n        required = []\\n        required.append(\\'\\'.join(list(currentCount)))\\n        for i in range(10):\\n            currentCount[i] = str((int(currentCount[i]) + 1) % 2)\\n            required.append(\\'\\'.join(list(currentCount)))\\n            currentCount[i] = str((int(currentCount[i]) + 1) % 2)\\n        return required\\n            \\n    def longestAwesome(self, s: str) -> int:\\n        currentCount = [\\'0\\' for _ in range(10)]\\n        result = 0\\n        previousMap = { \\'\\'.join(list(currentCount)) : -1}\\n        for index,letter in enumerate(s):\\n            letter = int(letter)\\n            currentCount[letter] = str((int(currentCount[letter])+1) % 2)\\n            searchingFor = self.getRequired(currentCount)\\n            for searching in searchingFor:\\n                if searching in previousMap:\\n                    result = max(result, index - previousMap[searching])\\n            \\n            key = \\'\\'.join(currentCount)\\n            if key not in previousMap:\\n                previousMap[key] = index\\n        \\n        return result",
                "solutionTags": [],
                "code": "class Solution:\\n    def getRequired(self, currentCount):\\n        required = []\\n        required.append(\\'\\'.join(list(currentCount)))\\n        for i in range(10):\\n            currentCount[i] = str((int(currentCount[i]) + 1) % 2)\\n            required.append(\\'\\'.join(list(currentCount)))\\n            currentCount[i] = str((int(currentCount[i]) + 1) % 2)\\n        return required\\n            \\n    def longestAwesome(self, s: str) -> int:\\n        currentCount = [\\'0\\' for _ in range(10)]\\n        result = 0\\n        previousMap = { \\'\\'.join(list(currentCount)) : -1}",
                "codeTag": "Java"
            },
            {
                "id": 2699862,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int longestAwesome(string s)\\n    {\\n        unordered_map<int,int> map;\\n        \\n        int mask = 0, maxL = 0;\\n        \\n        map[mask] = -1;\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            int ch = s[i]-\\'0\\';\\n            \\n            mask = mask ^ (1<<ch);\\n            \\n            if(map.find(mask) != map.end())\\n            {\\n                maxL = max(maxL, i-map[mask]);\\n            }\\n            \\n            for(int x=0; x< 10; ++x)\\n            {\\n                int newMask = mask^(1<<x);\\n                \\n                if(map.find(newMask) != map.end())\\n                {\\n                    maxL = max(maxL, i-map[newMask]);\\n                }\\n            }\\n            \\n            if(map.find(mask) == map.end())\\n            {\\n                map[mask] = i;\\n            }\\n        }\\n        return maxL;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestAwesome(string s)\\n    {\\n        unordered_map<int,int> map;\\n        \\n        int mask = 0, maxL = 0;\\n        \\n        map[mask] = -1;\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            int ch = s[i]-\\'0\\';\\n            \\n            mask = mask ^ (1<<ch);\\n            \\n            if(map.find(mask) != map.end())\\n            {\\n                maxL = max(maxL, i-map[mask]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1451029,
                "title": "bitmanipulation",
                "content": "Simply storing whether a digit occurs even or odd times in a map storing 1st occurence of a state so that the substring we get has maximum length\\n\\n```\\nclass Solution {\\n    int mp[1025],n,ans;\\npublic:\\n    \\n    void check(int s,int ind){\\n        // even length palindromes\\n        if(mp[s]!=-1)\\n            ans=max(ans,ind+1-mp[s]);\\n        \\n        // odd length palindromes\\n        for(int i=0;i<10;i++){\\n            int t=s^(1<<i);\\n            if(mp[t]!=-1){\\n                int l=ind-mp[t]+1;\\n                ans=max(ans,l);\\n            }\\n        }\\n    }\\n    \\n    int longestAwesome(string t) {\\n        int i;\\n        n=t.length();\\n        int state=0;\\n        memset(mp,-1,sizeof(mp));\\n        mp[0]=0;\\n        ans=1;\\n        \\n        for(i=0;i<n;i++){\\n            char c=t[i];\\n            state=state^(1<<(c-\\'0\\'));\\n            check(state,i);\\n            if(mp[state]==-1)\\n                mp[state]=i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int mp[1025],n,ans;\\npublic:\\n    \\n    void check(int s,int ind){\\n        // even length palindromes\\n        if(mp[s]!=-1)\\n            ans=max(ans,ind+1-mp[s]);\\n        \\n        // odd length palindromes\\n        for(int i=0;i<10;i++){\\n            int t=s^(1<<i);\\n            if(mp[t]!=-1){\\n                int l=ind-mp[t]+1;\\n                ans=max(ans,l);\\n            }\\n        }\\n    }\\n    \\n    int longestAwesome(string t) {\\n        int i;\\n        n=t.length();\\n        int state=0;\\n        memset(mp,-1,sizeof(mp));\\n        mp[0]=0;\\n        ans=1;\\n        \\n        for(i=0;i<n;i++){\\n            char c=t[i];\\n            state=state^(1<<(c-\\'0\\'));\\n            check(state,i);\\n            if(mp[state]==-1)\\n                mp[state]=i+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337953,
                "title": "c-5-6-lines-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int>vis(1024,-2),keys={1,2,4,8,16,32,64,128,256,512};\\n        vis[0]=-1;\\n        int n=s.size(),ans=0,stage=0;\\n        for(int i=0;i<n;i++){\\n            stage=stage^(keys[s[i]-\\'0\\']);\\n            if(vis[stage]!=-2) ans=max(ans,i-vis[stage]); \\n            for(auto j: keys) if(vis[stage^j]!=-2) ans=max(ans,i-vis[stage^j]); \\n            if(vis[stage]==-2)vis[stage]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s) {\\n        vector<int>vis(1024,-2),keys={1,2,4,8,16,32,64,128,256,512};\\n        vis[0]=-1;\\n        int n=s.size(),ans=0,stage=0;\\n        for(int i=0;i<n;i++){\\n            stage=stage^(keys[s[i]-\\'0\\']);\\n            if(vis[stage]!=-2) ans=max(ans,i-vis[stage]); \\n            for(auto j: keys) if(vis[stage^j]!=-2) ans=max(ans,i-vis[stage^j]); \\n            if(vis[stage]==-2)vis[stage]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080538,
                "title": "short-bitmask-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestAwesome(string s){\\n        int res = 0;\\n        vector<int> m(1024, s.size() + 7);\\n        m[0] = 0;\\n        for(int i = 0, mask = 0;i < s.size();i++){\\n            mask ^= (1 << (s[i] - \\'0\\'));\\n            m[mask] = min(m[mask], i);\\n            if(__builtin_popcount(mask) <= 1)\\n                res = i + 1;\\n            for(int digit = 0;digit < 10;digit++){\\n                int new_mask = mask ^ (1 << digit);\\n                res = max(res, i - m[new_mask]);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestAwesome(string s){\\n        int res = 0;\\n        vector<int> m(1024, s.size() + 7);\\n        m[0] = 0;\\n        for(int i = 0, mask = 0;i < s.size();i++){\\n            mask ^= (1 << (s[i] - \\'0\\'));\\n            m[mask] = min(m[mask], i);\\n            if(__builtin_popcount(mask) <= 1)\\n                res = i + 1;\\n            for(int digit = 0;digit < 10;digit++){\\n                int new_mask = mask ^ (1 << digit);\\n                res = max(res, i - m[new_mask]);\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568413,
                "content": [
                    {
                        "username": "kg1910",
                        "content": "can we do Binary search in this problem? any idea?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Binary search won\\'t work here"
                    },
                    {
                        "username": "dkray",
                        "content": "as I know binary search works only for searching for a specific value in a sorted array, but this is a palindrome task.\\nI tried using radix, but still failing"
                    },
                    {
                        "username": "beerus_25",
                        "content": "Can someone tell me some good resources to learn about bitmasking?\\nI have tried mutliple times but still unable to grasp the concept and how to apply in questions.\\n\\nThanks in advance :)"
                    },
                    {
                        "username": "leaopard_13",
                        "content": "see full playlist "
                    },
                    {
                        "username": "leaopard_13",
                        "content": "pepcoding bit manipulation on you tube"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Here](https://leetcode.com/problems/number-of-wonderful-substrings/description/) is exactly the same problem in disguise."
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "For the testcase \"9498331\" How the answer could be 3. \\nI got wrong answer on this testcase. \\nBut if you try it this testcase manually, you can create the longest palindromic substring as \"93139\" or \"93439\" and so on.. like this having the length as 5. How the answer can be 3?."
                    },
                    {
                        "username": "abhavgoel",
                        "content": "the questions asks for substrings ,  which are continuos. i guess you are confusing it with subsequences. the ans would be \"949\", which is continuous so 3 is returned."
                    }
                ]
            },
            {
                "id": 1574184,
                "content": [
                    {
                        "username": "kg1910",
                        "content": "can we do Binary search in this problem? any idea?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Binary search won\\'t work here"
                    },
                    {
                        "username": "dkray",
                        "content": "as I know binary search works only for searching for a specific value in a sorted array, but this is a palindrome task.\\nI tried using radix, but still failing"
                    },
                    {
                        "username": "beerus_25",
                        "content": "Can someone tell me some good resources to learn about bitmasking?\\nI have tried mutliple times but still unable to grasp the concept and how to apply in questions.\\n\\nThanks in advance :)"
                    },
                    {
                        "username": "leaopard_13",
                        "content": "see full playlist "
                    },
                    {
                        "username": "leaopard_13",
                        "content": "pepcoding bit manipulation on you tube"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Here](https://leetcode.com/problems/number-of-wonderful-substrings/description/) is exactly the same problem in disguise."
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "For the testcase \"9498331\" How the answer could be 3. \\nI got wrong answer on this testcase. \\nBut if you try it this testcase manually, you can create the longest palindromic substring as \"93139\" or \"93439\" and so on.. like this having the length as 5. How the answer can be 3?."
                    },
                    {
                        "username": "abhavgoel",
                        "content": "the questions asks for substrings ,  which are continuos. i guess you are confusing it with subsequences. the ans would be \"949\", which is continuous so 3 is returned."
                    }
                ]
            },
            {
                "id": 2034555,
                "content": [
                    {
                        "username": "kg1910",
                        "content": "can we do Binary search in this problem? any idea?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Binary search won\\'t work here"
                    },
                    {
                        "username": "dkray",
                        "content": "as I know binary search works only for searching for a specific value in a sorted array, but this is a palindrome task.\\nI tried using radix, but still failing"
                    },
                    {
                        "username": "beerus_25",
                        "content": "Can someone tell me some good resources to learn about bitmasking?\\nI have tried mutliple times but still unable to grasp the concept and how to apply in questions.\\n\\nThanks in advance :)"
                    },
                    {
                        "username": "leaopard_13",
                        "content": "see full playlist "
                    },
                    {
                        "username": "leaopard_13",
                        "content": "pepcoding bit manipulation on you tube"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Here](https://leetcode.com/problems/number-of-wonderful-substrings/description/) is exactly the same problem in disguise."
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "For the testcase \"9498331\" How the answer could be 3. \\nI got wrong answer on this testcase. \\nBut if you try it this testcase manually, you can create the longest palindromic substring as \"93139\" or \"93439\" and so on.. like this having the length as 5. How the answer can be 3?."
                    },
                    {
                        "username": "abhavgoel",
                        "content": "the questions asks for substrings ,  which are continuos. i guess you are confusing it with subsequences. the ans would be \"949\", which is continuous so 3 is returned."
                    }
                ]
            },
            {
                "id": 1963565,
                "content": [
                    {
                        "username": "kg1910",
                        "content": "can we do Binary search in this problem? any idea?"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Binary search won\\'t work here"
                    },
                    {
                        "username": "dkray",
                        "content": "as I know binary search works only for searching for a specific value in a sorted array, but this is a palindrome task.\\nI tried using radix, but still failing"
                    },
                    {
                        "username": "beerus_25",
                        "content": "Can someone tell me some good resources to learn about bitmasking?\\nI have tried mutliple times but still unable to grasp the concept and how to apply in questions.\\n\\nThanks in advance :)"
                    },
                    {
                        "username": "leaopard_13",
                        "content": "see full playlist "
                    },
                    {
                        "username": "leaopard_13",
                        "content": "pepcoding bit manipulation on you tube"
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "[Here](https://leetcode.com/problems/number-of-wonderful-substrings/description/) is exactly the same problem in disguise."
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "For the testcase \"9498331\" How the answer could be 3. \\nI got wrong answer on this testcase. \\nBut if you try it this testcase manually, you can create the longest palindromic substring as \"93139\" or \"93439\" and so on.. like this having the length as 5. How the answer can be 3?."
                    },
                    {
                        "username": "abhavgoel",
                        "content": "the questions asks for substrings ,  which are continuos. i guess you are confusing it with subsequences. the ans would be \"949\", which is continuous so 3 is returned."
                    }
                ]
            }
        ]
    },
    {
        "title": "Fix Product Name Format",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576626,
                "content": [
                    {
                        "username": "pkuaaron",
                        "content": "\\nselect lcase(trim(product_name)) as product_name, date_format(sale_date,\\'%Y-%m\\') as sale_date\\n, count(*) as total\\nfrom Sales\\ngroup by lcase(trim(product_name)), date_format(sale_date, \\'%Y-%m\\')\\norder by product_name, sale_date\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Make The String Great",
        "question_content": "<p>Given a string <code>s</code> of lower and upper case English letters.</p>\n\n<p>A good string is a string which doesn&#39;t have <strong>two adjacent characters</strong> <code>s[i]</code> and <code>s[i + 1]</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt;= s.length - 2</code></li>\n\t<li><code>s[i]</code> is a lower-case letter and <code>s[i + 1]</code> is the same letter but in upper-case or <strong>vice-versa</strong>.</li>\n</ul>\n\n<p>To make the string good, you can choose <strong>two adjacent</strong> characters that make the string bad and remove them. You can keep doing this until the string becomes good.</p>\n\n<p>Return <em>the string</em> after making it good. The answer is guaranteed to be unique under the given constraints.</p>\n\n<p><strong>Notice</strong> that an empty string is also good.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leEeetcode&quot;\n<strong>Output:</strong> &quot;leetcode&quot;\n<strong>Explanation:</strong> In the first step, either you choose i = 1 or i = 2, both will result &quot;leEeetcode&quot; to be reduced to &quot;leetcode&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abBAcC&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> We have many possible scenarios, and all lead to the same answer. For example:\n&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;\n&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;s&quot;\n<strong>Output:</strong> &quot;s&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> contains only lower and upper case English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 781009,
                "title": "java-simple-solution-using-stack-explained",
                "content": "**Explanation** -\\nIt should be noted that the difference between the any lowercase and uppercase alphabet is 32. Example - ASCII value of `a is 97` and `A is 65` , 97-65 = 32\\n\\nUsing same trick, we can delete adjacent characters with absolute difference of 32.\\n\\n**`Example`** -\\nIf current character is A and a is at top of stack, we pop a and dont insert A.\\nOtherwise, we insert the current character in stack.\\nCollect result in String at the end.\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(!stack.isEmpty() && Math.abs(stack.peek()-s.charAt(i)) == 32)\\n                stack.pop();\\n            else\\n                stack.push(s.charAt(i));\\n        }\\n        char res[] = new char[stack.size()];\\n        int index = stack.size()-1;\\n        while(!stack.isEmpty()){\\n            res[index--] = stack.pop();\\n        }\\n        return new String(res);\\n    }\\n```\\n\\n`*Feel free to ask questions in comment section, do upvote if you understood the solution*`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack();\\n        for(int i=0;i<s.length();i++){\\n            if(!stack.isEmpty() && Math.abs(stack.peek()-s.charAt(i)) == 32)\\n                stack.pop();\\n            else\\n                stack.push(s.charAt(i));\\n        }\\n        char res[] = new char[stack.size()];\\n        int index = stack.size()-1;\\n        while(!stack.isEmpty()){\\n            res[index--] = stack.pop();\\n        }\\n        return new String(res);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790806,
                "title": "c-easy-one-pass-o-n-space",
                "content": "\\t\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n\\t\\t\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        string ans;\\n        \\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            ans.push_back(s[i]);\\n            \\n            while(ans.size() && (ans.back()==s[i+1]+32 || ans.back()==s[i+1]-32))\\n            {\\n                ans.pop_back();\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Explanation:**\\n\\n                    \\n                    Consider Sample Example 2   s = \"abBAcC\"\\n                    \\n*                     i = 0   ans = a          s[i+1] = b\\n*                     i = 1   ans = ab         s[i+1] = B\\n*                     i = 2   ans = a          s[i+1] = A\\n*                     i = 3   ans = \"\"         s[i+1] = c\\n*                     i = 4   ans = c          s[i+1] = C\\n*                     i = 5   ans = \"\" \\n*                     Finally ans = \"\"                 \\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        string ans;\\n        \\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            ans.push_back(s[i]);\\n            \\n            while(ans.size() && (ans.back()==s[i+1]+32 || ans.back()==s[i+1]-32))\\n            {\\n                ans.pop_back();\\n                i++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780897,
                "title": "c-brute-force-two-pointers",
                "content": "#### Brute-Force\\nJust do what the problem asks us to do until you can\\'t.\\n\\n```cpp\\nstring makeGood(string s, int sz = 0) {\\n    while (sz != s.size()) {\\n        sz = s.size();\\n        for (int i = 0; i + 1 < s.size(); ++i)\\n            if (abs(s[i] - s[i + 1]) == 32)\\n                s = s.substr(0, i) + s.substr(i + 2);\\n    }\\n    return s;\\n}\\n```\\n\\n**Complexity Analysis**\\n- Time: O(n * n) - in the worst case, we are going through the entire string n times, and also copyting it n times. \\n- Memory: O(n) to create a copy of the string.\\n\\n#### Optimized Solution\\nWe can use the two pointers pattern to construct the resulting string in one pass. `i` indicates the current pointer in the input string, and `p` - the insertion point in the result string. If the current character in the input string \"conflicts\" with the last character of the result string - we decrease `p`. Otherwise, we copy the current character to the input string and increase `p`.\\n\\nNote that we can use the same input string to hold the output - because `p` will never go ahead of `i`. In the end, we return the portion of the string till the insertion point `p`.\\n\\n```cpp\\nstring makeGood(string s, int p = 0) {\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (p > 0 && abs(s[i] - s[p - 1]) == 32)\\n            --p;\\n        else\\n            s[p++] = s[i];\\n    }\\n    return s.substr(0, p);\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n). We are going through the string once.\\n- Memory: O(1), as we reuse the same string.",
                "solutionTags": [],
                "code": "```cpp\\nstring makeGood(string s, int sz = 0) {\\n    while (sz != s.size()) {\\n        sz = s.size();\\n        for (int i = 0; i + 1 < s.size(); ++i)\\n            if (abs(s[i] - s[i + 1]) == 32)\\n                s = s.substr(0, i) + s.substr(i + 2);\\n    }\\n    return s;\\n}\\n```\n```cpp\\nstring makeGood(string s, int p = 0) {\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (p > 0 && abs(s[i] - s[p - 1]) == 32)\\n            --p;\\n        else\\n            s[p++] = s[i];\\n    }\\n    return s.substr(0, p);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780991,
                "title": "clean-python-3-stack-o-n",
                "content": "Just check if next character makes the string bad, if so pop the stack. Otherwise, push to the stack.\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        result = []\\n        for c in s:\\n            if not result:\\n                result.append(c)\\n            elif result[-1].isupper() and result[-1].lower() == c:\\n                result.pop()\\n            elif result[-1].islower() and result[-1].upper() == c:\\n                result.pop()\\n            else:\\n                result.append(c)\\n        return \\'\\'.join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        result = []\\n        for c in s:\\n            if not result:\\n                result.append(c)\\n            elif result[-1].isupper() and result[-1].lower() == c:\\n                result.pop()\\n            elif result[-1].islower() and result[-1].upper() == c:\\n                result.pop()\\n            else:\\n                result.append(c)\\n        return \\'\\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791276,
                "title": "easy-java-solution-4-lines-of-code-with-explanation-recursive-lines-clean",
                "content": "You guys can add your solutions in the comments it will help other viewers .\\n```\\nclass Solution {\\n\\t public String makeGood(String s) {\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            //Now we check if the either the present or the next character is capital\\n            if (Math.abs(s.charAt(i) - s.charAt(i+1)) == 32) {  \\n                //recursive call for the rest of the string \\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }     \\n        return s;\\n    }\\n}\\n```\\n**Upvote please **",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\t public String makeGood(String s) {\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            //Now we check if the either the present or the next character is capital\\n            if (Math.abs(s.charAt(i) - s.charAt(i+1)) == 32) {  \\n                //recursive call for the rest of the string \\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }     \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781044,
                "title": "python3-5-line-stack-o-n",
                "content": "push \"good\" & pop \"bad\" \\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for c in s: \\n            if stack and abs(ord(stack[-1]) - ord(c)) == 32: stack.pop() #pop \"bad\"\\n            else: stack.append(c) #push \"good\"\\n        return \"\".join(stack)\\n```\\n\\nEdit: Surprisingly, one could use `chr(ord(c) ^ 32)` to convert a letter `c` to its corresponding uppercase/lowercase. Please see this [post](https://leetcode.com/problems/make-the-string-great/discuss/780930/JavaPython-3-Stack-O(n)-code-w-brief-explanation-and-analysis.).\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for c in s: \\n            if stack and ord(stack[-1]) ^ ord(c) == 32: stack.pop() #pop \"bad\"\\n            else: stack.append(c) #push \"good\"\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for c in s: \\n            if stack and abs(ord(stack[-1]) - ord(c)) == 32: stack.pop() #pop \"bad\"\\n            else: stack.append(c) #push \"good\"\\n        return \"\".join(stack)\\n```\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for c in s: \\n            if stack and ord(stack[-1]) ^ ord(c) == 32: stack.pop() #pop \"bad\"\\n            else: stack.append(c) #push \"good\"\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706082,
                "title": "easy-3-line-c-100-solution-o-n",
                "content": "\\n```\\nstring makeGood(string s) {\\n        for(int i=0;i<s.size();i++)\\n            if(abs(s[i]-s[i+1])==32)\\n                s.erase(i,2),i=max(-1,i-2);\\n        return s;\\n    }\\n```\\nPlease Upvote if find helpful, suggestions are welcomed :)\\nFind me on https://coderaky.com",
                "solutionTags": [],
                "code": "```\\nstring makeGood(string s) {\\n        for(int i=0;i<s.size();i++)\\n            if(abs(s[i]-s[i+1])==32)\\n                s.erase(i,2),i=max(-1,i-2);\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781271,
                "title": "javascript-clean-o-n-stack-solution",
                "content": "```javascript\\nvar makeGood = function(s) {\\n    const stack = [\\'\\'];\\n    \\n    for(let c of s) {\\n        let top = stack[stack.length-1];\\n        if(top.toLowerCase() === c.toLowerCase() && top !== c) stack.pop()\\n        else stack.push(c);\\n    }\\n    return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar makeGood = function(s) {\\n    const stack = [\\'\\'];\\n    \\n    for(let c of s) {\\n        let top = stack[stack.length-1];\\n        if(top.toLowerCase() === c.toLowerCase() && top !== c) stack.pop()\\n        else stack.push(c);\\n    }\\n    return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780930,
                "title": "java-python-3-stack-o-n-code-w-brief-explanation-and-analysis",
                "content": "credit to **@ras123  @singlemancombat**\\n ^ is logical xor:\\nThe decimal values of lowercase and uppercase English letters differ with each other by 32. Take an example: a -> 97(1100001), A -> 65 (1000001). So we have a ^ 32 = A, A ^ 32 = a.\\n```\\n   1 1 0 0 0 0 1 (97)\\n^  0 1 0 0 0 0 0 (32)\\n   1 0 0 0 0 0 1 (65)\\n```\\n\\n----\\n\\n \\n1. Use `^ 32` to toggle the case of a character;\\n2. Pair the lower and upper cases and cancel them.\\n\\n```java\\n    public String makeGood(String s) {\\n        var dq = new ArrayDeque<Character>();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (!dq.isEmpty() && (dq.peekLast() ^ 32) == c) {\\n                dq.pollLast();\\n            }else {\\n                dq.offer(c);\\n            }\\n        }\\n        var ans = new StringBuilder();\\n        for (char c : dq) {\\n            ans.append(c);\\n        }\\n        return ans.toString();\\n    }\\n```\\nOr make it shorter: use StringBuilder as Stack. - credit to **@puru_cat**.\\n```java\\n    public String makeGood(String s) {\\n        var ans = new StringBuilder();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (ans.length() > 0 && (ans.charAt(ans.length() - 1) ^ 32) == c) {\\n                ans.deleteCharAt(ans.length() - 1);\\n            }else {\\n                ans.append(c);\\n            }\\n        }\\n        return ans.toString();       \\n    }\\n```\\n```python\\n    def makeGood(self, s: str) -> str:\\n        stk = []\\n        for char in s:\\n            if stk and stk[-1] == chr(ord(char) ^ 32):\\n                stk.pop()\\n            else:\\n                stk.append(char)\\n        return \\'\\'.join(stk)\\n```\\n**Analysis:**\\n\\nTime & space: O(n), where n = s.length().",
                "solutionTags": [],
                "code": "```\\n   1 1 0 0 0 0 1 (97)\\n^  0 1 0 0 0 0 0 (32)\\n   1 0 0 0 0 0 1 (65)\\n```\n```java\\n    public String makeGood(String s) {\\n        var dq = new ArrayDeque<Character>();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (!dq.isEmpty() && (dq.peekLast() ^ 32) == c) {\\n                dq.pollLast();\\n            }else {\\n                dq.offer(c);\\n            }\\n        }\\n        var ans = new StringBuilder();\\n        for (char c : dq) {\\n            ans.append(c);\\n        }\\n        return ans.toString();\\n    }\\n```\n```java\\n    public String makeGood(String s) {\\n        var ans = new StringBuilder();\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (ans.length() > 0 && (ans.charAt(ans.length() - 1) ^ 32) == c) {\\n                ans.deleteCharAt(ans.length() - 1);\\n            }else {\\n                ans.append(c);\\n            }\\n        }\\n        return ans.toString();       \\n    }\\n```\n```python\\n    def makeGood(self, s: str) -> str:\\n        stk = []\\n        for char in s:\\n            if stk and stk[-1] == chr(ord(char) ^ 32):\\n                stk.pop()\\n            else:\\n                stk.append(char)\\n        return \\'\\'.join(stk)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2790965,
                "title": "python-c-java-rust-make-the-string-great-again-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a stack to keep track of adjacent characters in one pass. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** Stack is optimal here but there is also a brute-force apporach, i.e., \"replace till death\".\\n\\n**Python #1.** The naive brute-force aproach.\\n```\\nfrom string import ascii_lowercase as lc, ascii_uppercase as uc\\n\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        it1 = [lc[i] + uc[i] for i in range(26)]    # make pairs of letters of both\\n        it2 = [uc[i] + lc[i] for i in range(26)]    # types, e.g., aA and Aa\\n        \\n        while True:                                \\n            ss = s\\n            for cc in it1 : s = s.replace(cc, \"\")   # delete pairs of lowercase/uppercase\\n            for cc in it2 : s = s.replace(cc, \"\")   # letters until there is nothing left\\n            if s == ss: break\\n            \\n        return s\\n```\\n\\n**Python #2.** The optimal solution using stack.\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        ss = []\\n        \\n        for c in s: \\n            if ss and ss[-1] == c.swapcase():    # if the stack is not empty and the last letter on the stack is\\n                ss.pop()                         # a match for the current letter (e.g., \\'a\\' and \\'A\\'), remove both\\n            else: \\n                ss.append(c)                     # continue adding to stack to compare with next letter\\n        \\n        return \"\".join(ss)\\n```\\n\\nThis solution in other languages.\\n<iframe src=\"https://leetcode.com/playground/hn99gFjB/shared\" frameBorder=\"0\" width=\"800\" height=\"380\"></iframe>",
                "solutionTags": [],
                "code": "```\\nfrom string import ascii_lowercase as lc, ascii_uppercase as uc\\n\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        it1 = [lc[i] + uc[i] for i in range(26)]    # make pairs of letters of both\\n        it2 = [uc[i] + lc[i] for i in range(26)]    # types, e.g., aA and Aa\\n        \\n        while True:                                \\n            ss = s\\n            for cc in it1 : s = s.replace(cc, \"\")   # delete pairs of lowercase/uppercase\\n            for cc in it2 : s = s.replace(cc, \"\")   # letters until there is nothing left\\n            if s == ss: break\\n            \\n        return s\\n```\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        ss = []\\n        \\n        for c in s: \\n            if ss and ss[-1] == c.swapcase():    # if the stack is not empty and the last letter on the stack is\\n                ss.pop()                         # a match for the current letter (e.g., \\'a\\' and \\'A\\'), remove both\\n            else: \\n                ss.append(c)                     # continue adding to stack to compare with next letter\\n        \\n        return \"\".join(ss)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781446,
                "title": "very-easy-java-recursive-solution",
                "content": "if we find two adjacent characters is upper and lower case of same letter,\\nthen the result will get from the string which after remove these two letters.\\n\\nif we don\\'t find any two letters, means the string is good, just return it.\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (Math.abs(s.charAt(i) - s.charAt(i+1)) == 32) {\\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int n = s.length();\\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            if (Math.abs(s.charAt(i) - s.charAt(i+1)) == 32) {\\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790782,
                "title": "python3-stack-approach-o-n",
                "content": "The idea is to compare ```s[i]``` and the last item in the stack ```stack[-1]``` to see if these two characters will make the string \"bad\"; if they are, then pop the last character from the stack, if they are not, then append s[i] to the stack.\\n\\nHere is a quick example illustrating the process:\\n\\n>i = 0 ------- stack = [] -------- s = \"**L**abBAcCC\" ------- stack = [L] ======= stack was empty **append**\\ni = 1 ------- stack = [L] ------- s = \"L**a**bBAcCC\" ------- stack = [L,a] ===== **append**\\ni = 2 ------- stack = [L,a] ----- s = \"La**b**BAcCC\" ------- stack = [L,a,b] ==== **append**\\ni = 3 ------- stack = [L,a,b] --- s = \"Lab**B**AcCC\" ------- stack = [L,a] ====== stack[-1]=\\'b\\', s[i]=\\'B\\', **pop**\\ni = 4 ------- stack = [L,a] ----- s = \"LabB**A**cCC\" ------- stack = [L] ======= stack[-1]=\\'a\\', s[i]=\\'A\\', **pop**\\ni = 5 ------- stack = [L] ------- s = \"LabBA**c**CC\" ------- stack = [L,c] ===== **append**\\ni = 6 ------- stack = [L,c] ----- s = \"LabBAc**C**C\" ------- stack = [L] ======= stack[-1]=\\'c\\', s[i]=\\'C\\', **pop**\\ni = 7 ------- stack = [L] ------- s = \"LabBAcC**C**\" ------- stack = [L,C] ===== **append**\\nreturn \"LC\"\\n\\n```python\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            if stack and stack[-1] == s[i].swapcase():\\n                stack.pop(-1)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```\\nor\\n```python\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            if stack and abs(ord(s[i]) - ord(stack[-1])) == 32:\\n                stack.pop(-1)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```s[i]```\n```stack[-1]```\n```python\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            if stack and stack[-1] == s[i].swapcase():\\n                stack.pop(-1)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```\n```python\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for i in range(len(s)):\\n            if stack and abs(ord(s[i]) - ord(stack[-1])) == 32:\\n                stack.pop(-1)\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791072,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/mYiz7HWN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Kotlin",
                    "Stack"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/mYiz7HWN/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2791604,
                "title": "java-100-faster-solution-two-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int pt2 = 0;\\n        for(int i = 0; i<s.length(); i++){\\n            if(pt2>0 && Math.abs(sb.charAt(pt2-1) - s.charAt(i)) == 32){\\n                pt2--;\\n                sb.deleteCharAt(pt2);\\n            }\\n            else{\\n                sb.append(s.charAt(i));\\n                pt2++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n**Upvote Please**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int pt2 = 0;\\n        for(int i = 0; i<s.length(); i++){\\n            if(pt2>0 && Math.abs(sb.charAt(pt2-1) - s.charAt(i)) == 32){\\n                pt2--;\\n                sb.deleteCharAt(pt2);\\n            }\\n            else{\\n                sb.append(s.charAt(i));\\n                pt2++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791272,
                "title": "detailed-explanation-of-the-python-solution-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        \\n        for i in range(len(s)):\\n            if stack and stack[-1] == s[i].swapcase():\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        \\n        return \\'\\'.join(stack)\\n```\\n**For Detail Explaination Refer this Blog:\\nhttps://www.python-techs.com/2022/11/make-the-string-great.html\\n(Please open this link in new tab)**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        \\n        for i in range(len(s)):\\n            if stack and stack[-1] == s[i].swapcase():\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781448,
                "title": "java-1ms-beats-100-using-stringbuilder-and-while-loop",
                "content": "```\\nclass Solution {\\n  public String makeGood(String s) {\\n    \\n    /*\\n    Runtime: 1 ms, faster than 100.00% of Java online submissions for Make The String Great.\\n    Memory Usage: 37.9 MB, less than 100.00% of Java online submissions for Make The String Great.\\n\\tRuntime complexity: O(n)\\n\\tSpace complexity: O(n), since we duplicate the input String in a StringBuilder\\n    */\\n\\n    // edge case\\n    if (s.isEmpty()) {\\n      return s; // an empty String is a good String per problem requirements\\n    }\\n\\n    StringBuilder sb = new StringBuilder(s); // our working space and what we\\'ll return\\n    \\n    int index = 0; // to keep track of where in the StringBuilder we are\\n    \\n    while (index < sb.length() - 1) {\\n      if (Math.abs(sb.charAt(index) - sb.charAt(index + 1)) == 32) { // if lower-upper pair is found\\n        sb.deleteCharAt(index);\\n        sb.deleteCharAt(index);\\n        index = Math.max(index - 1, 0); // thanks to @prdp89 for the tip!\\n      } else {\\n        ++index; // move on to next char\\n      }\\n    }\\n    \\n    return sb.toString();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n  public String makeGood(String s) {\\n    \\n    /*\\n    Runtime: 1 ms, faster than 100.00% of Java online submissions for Make The String Great.\\n    Memory Usage: 37.9 MB, less than 100.00% of Java online submissions for Make The String Great.\\n\\tRuntime complexity: O(n)\\n\\tSpace complexity: O(n), since we duplicate the input String in a StringBuilder\\n    */\\n\\n    // edge case\\n    if (s.isEmpty()) {\\n      return s; // an empty String is a good String per problem requirements\\n    }\\n\\n    StringBuilder sb = new StringBuilder(s); // our working space and what we\\'ll return\\n    \\n    int index = 0; // to keep track of where in the StringBuilder we are\\n    \\n    while (index < sb.length() - 1) {\\n      if (Math.abs(sb.charAt(index) - sb.charAt(index + 1)) == 32) { // if lower-upper pair is found\\n        sb.deleteCharAt(index);\\n        sb.deleteCharAt(index);\\n        index = Math.max(index - 1, 0); // thanks to @prdp89 for the tip!\\n      } else {\\n        ++index; // move on to next char\\n      }\\n    }\\n    \\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781103,
                "title": "c-using-a-stack-o-n-with-detailed-explanations",
                "content": "Put the characters on top of each other on a ```stack```. And remove them off the ```stack``` when the combination with the next neighbor makes a \"xX or Xx\" string. Remembering the [ASCII](http://cs.smu.ca/~porter/csc/ref/ascii.html) table, the small letters and capital letters have an absolute value of \"32\" difference (alternatively use ```int diff = \\'a\\'-\\'A\\'``` which sets diff to 32), thus, we can check whether the current index and neighbor make a \"xX or Xx\" string or not, by checking ```(st.top()==s[i+1]+32) || (st.top()==s[i+1]-32)```. \\nTime: O(n)\\nSpace: O(n)\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for (int i = 0;i<s.size();i++){\\n            st.push(s[i]);\\n            while (!st.empty() && ((st.top()==s[i+1]+32) || (st.top()==s[i+1]-32))){\\n                st.pop();\\n                i++;\\n            }\\n        }\\n\\t\\tstring ret = \"\";\\n        while(!st.empty()){\\n            ret = st.top() + ret;\\n            st.pop();\\n        }\\n        return ret;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```stack```\n```stack```\n```int diff = \\'a\\'-\\'A\\'```\n```(st.top()==s[i+1]+32) || (st.top()==s[i+1]-32)```",
                "codeTag": "Unknown"
            },
            {
                "id": 781391,
                "title": "python-no-extra-space",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        i = 0\\n        while i < len(s)-1:\\n            if s[i] == s[i+1]:\\n                i += 1\\n            elif s[i].lower() == s[i+1] or s[i].upper() == s[i+1]:\\n                s = s[:i] + s[i+2:]\\n                i = 0\\n            else:\\n                i += 1\\n        \\n        return s\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        i = 0\\n        while i < len(s)-1:\\n            if s[i] == s[i+1]:\\n                i += 1\\n            elif s[i].lower() == s[i+1] or s[i].upper() == s[i+1]:\\n                s = s[:i] + s[i+2:]\\n                i = 0\\n            else:\\n                i += 1\\n        \\n        return s\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790958,
                "title": "kotlin-using-stack-kotlin-infix-function",
                "content": "```kt\\nfun makeGood(s: String): String {\\n    return Stack<Char>().apply {\\n        s.forEach { ch ->\\n            if (isNotEmpty() && peek() isNotGoodPair ch) pop()\\n            else push(ch)\\n        }\\n    }.joinToString(\"\")\\n}\\n\\n// in ASCII & UNICODE, the difference between lowercase and uppercase is 32.\\nprivate infix fun Char.isNotGoodPair(ch: Char): Boolean {\\n    return abs(this - ch) == 32\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Stack"
                ],
                "code": "```kt\\nfun makeGood(s: String): String {\\n    return Stack<Char>().apply {\\n        s.forEach { ch ->\\n            if (isNotEmpty() && peek() isNotGoodPair ch) pop()\\n            else push(ch)\\n        }\\n    }.joinToString(\"\")\\n}\\n\\n// in ASCII & UNICODE, the difference between lowercase and uppercase is 32.\\nprivate infix fun Char.isNotGoodPair(ch: Char): Boolean {\\n    return abs(this - ch) == 32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 965029,
                "title": "simple-c-stack-solution-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n        if(s.length()<2) return s;\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++) {\\n            if(!st.empty() && abs(st.top()-s[i])== (\\'a\\'-\\'A\\')) \\n            {\\n                st.pop();                \\n            }\\n            else \\n            st.push(s[i]);\\n        }\\n        while(!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n        if(s.length()<2) return s;\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++) {\\n            if(!st.empty() && abs(st.top()-s[i])== (\\'a\\'-\\'A\\')) \\n            {\\n                st.pop();                \\n            }\\n            else \\n            st.push(s[i]);\\n        }\\n        while(!st.empty()) {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804803,
                "title": "python-using-stack-beats-99-o-n",
                "content": "```\\n        stack = []\\n        for char in s: \\n            # upper char\\n            if stack and stack[-1].isupper() and stack[-1].lower() == char:\\n                stack.pop()\\n            # lower char\\n            elif stack and stack[-1].islower() and stack[-1].upper() == char:\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        return \\'\\'.join(stack)\\n```\\nIf you like this solution please consider giving it a star on my [github](https://github.com/bwiens/leetcode-python). Means a lot to me.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        stack = []\\n        for char in s: \\n            # upper char\\n            if stack and stack[-1].isupper() and stack[-1].lower() == char:\\n                stack.pop()\\n            # lower char\\n            elif stack and stack[-1].islower() and stack[-1].upper() == char:\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780961,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n     \\n      \\n        for(int i=0; i<s.length()-1; i++){       \\n            if((s[i]==s[i+1]+32) || (s[i]==s[i+1]-32))\\n            {  \\n                s.erase(i,2);\\n                i=max(-1,i-2);              \\n            }\\n            if(s.length()==0)\\n                break;    \\n        }\\n       return s; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n     \\n      \\n        for(int i=0; i<s.length()-1; i++){       \\n            if((s[i]==s[i+1]+32) || (s[i]==s[i+1]-32))\\n            {  \\n                s.erase(i,2);\\n                i=max(-1,i-2);              \\n            }\\n            if(s.length()==0)\\n                break;    \\n        }\\n       return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790939,
                "title": "javascript-neat-5-methods-regexp-and-officials",
                "content": "## RegExp and recursion\\n```js\\nconst abc = [...\\'abcdefghijklmnopqrstuvwxyz\\']\\n    .map(c => `${c}${c.toUpperCase()}|${c.toUpperCase()}${c}`).join(\\'|\\')\\nconst isBad = new RegExp(`(${abc})`, \\'g\\')\\nconst makeGood = (s) => isBad.test(s) ? makeGood(s.replace(isBad, \\'\\')) : s\\n```\\n\\n## 1st approach: Iteration\\n\\n```js\\nconst isBad = (...ab) => Math.abs(ab.map(x => x.charCodeAt()).reduce((a, b) => a - b)) === 32\\nconst makeGood = (s) => {\\n    for (let i = 0; i < s.length - 1; ++i)\\n        if (isBad(s[i], s[i + 1])) {\\n            s = s.slice(0, i) + s.slice(i + 2)\\n            i = Math.max(-1, i - 2)\\n        }\\n    return s\\n}\\n```\\n\\n## 2nd approach: Recursion\\n\\n```js\\nconst isBad = (s, i) => Math.abs(s.charCodeAt(i) - s.charCodeAt(i + 1)) === 32\\nconst makeGood = (s) => {\\n    for (let i = 0; i < s.length - 1; ++i)\\n        if (isBad(s, i))\\n            return makeGood(s.slice(0, i) + s.slice(i + 2))\\n    return s\\n}\\n```\\n\\n## 3rd approach: Stack\\n```js\\nconst isBad = (a, b) => a !== b && a.toLowerCase() === b.toLowerCase()\\nconst makeGood = (s) => {\\n    let stack = [\\'\\']\\n    for (const x of s)\\n        isBad(x, stack.at(-1)) ? stack.pop() : stack.push(x)\\n    return stack.join(\\'\\')\\n}\\n```\\n\\n## 4th approach: Two pointers, in-place modify\\n```js\\nconst isBad = (a, b) => Math.abs(a.charCodeAt() - b.charCodeAt()) === 32\\nconst makeGood = (s) => {\\n    s = [...s]\\n    let end = 1\\n    for (let i = 1, x; x = s[i]; ++i)\\n        if (end && isBad(x, s[end - 1]))\\n            end--\\n        else\\n            s[end++] = x\\n    return s.slice(0, end).join(\\'\\')\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst abc = [...\\'abcdefghijklmnopqrstuvwxyz\\']\\n    .map(c => `${c}${c.toUpperCase()}|${c.toUpperCase()}${c}`).join(\\'|\\')\\nconst isBad = new RegExp(`(${abc})`, \\'g\\')\\nconst makeGood = (s) => isBad.test(s) ? makeGood(s.replace(isBad, \\'\\')) : s\\n```\n```js\\nconst isBad = (...ab) => Math.abs(ab.map(x => x.charCodeAt()).reduce((a, b) => a - b)) === 32\\nconst makeGood = (s) => {\\n    for (let i = 0; i < s.length - 1; ++i)\\n        if (isBad(s[i], s[i + 1])) {\\n            s = s.slice(0, i) + s.slice(i + 2)\\n            i = Math.max(-1, i - 2)\\n        }\\n    return s\\n}\\n```\n```js\\nconst isBad = (s, i) => Math.abs(s.charCodeAt(i) - s.charCodeAt(i + 1)) === 32\\nconst makeGood = (s) => {\\n    for (let i = 0; i < s.length - 1; ++i)\\n        if (isBad(s, i))\\n            return makeGood(s.slice(0, i) + s.slice(i + 2))\\n    return s\\n}\\n```\n```js\\nconst isBad = (a, b) => a !== b && a.toLowerCase() === b.toLowerCase()\\nconst makeGood = (s) => {\\n    let stack = [\\'\\']\\n    for (const x of s)\\n        isBad(x, stack.at(-1)) ? stack.pop() : stack.push(x)\\n    return stack.join(\\'\\')\\n}\\n```\n```js\\nconst isBad = (a, b) => Math.abs(a.charCodeAt() - b.charCodeAt()) === 32\\nconst makeGood = (s) => {\\n    s = [...s]\\n    let end = 1\\n    for (let i = 1, x; x = s[i]; ++i)\\n        if (end && isBad(x, s[end - 1]))\\n            end--\\n        else\\n            s[end++] = x\\n    return s.slice(0, end).join(\\'\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2793757,
                "title": "python-o-1-memory",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        i = 0\\n        while i < len(s) - 1:\\n            if ord(s[i]) - ord(s[i + 1]) == 32 or ord(s[i]) - ord(s[i + 1]) == -32:\\n                s = s[:i] + s[i + 2:]\\n                if i > 0:\\n                    i -= 1\\n            else:\\n                i += 1\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        i = 0\\n        while i < len(s) - 1:\\n            if ord(s[i]) - ord(s[i + 1]) == 32 or ord(s[i]) - ord(s[i + 1]) == -32:\\n                s = s[:i] + s[i + 2:]\\n                if i > 0:\\n                    i -= 1\\n            else:\\n                i += 1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606587,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem requires transforming a string into a \"good\" string by removing adjacent characters that violate the given conditions. To determine if a character violates the conditions, we need to compare it with its adjacent character and check if they have opposite cases (lower-case and upper-case) but represent the same letter. We can iterate through the string and continuously remove such adjacent characters until the string becomes \"good.\"\\n\\n\\n# Approach\\n1.\\tInitialize a boolean variable, test, as True, which will act as a flag to indicate whether there are still adjacent characters violating the conditions.\\n2.\\tEnter a while loop that will continue until no more violations are found (test becomes False).\\n3.\\tSet test to False at the beginning of each iteration to assume that there are no violations.\\n4.\\tInitialize a variable i as 0 to iterate through the string.\\n5.\\tEnter a nested while loop that will check adjacent characters at index i and i+1.\\n6.\\tIf the absolute difference between the ASCII values of the characters is exactly 32 (indicating that they are the same letter but with opposite cases), remove these characters from the string and update test to True to indicate that a violation has been found.\\n7.\\tIf no violation is found, increment i by 1 to move to the next pair of characters.\\n8.\\tOnce the inner while loop is exited, return the transformed string.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach depends on the length of the input string s. In the worst case, we might have to iterate through the string multiple times until it becomes \"good.\" Therefore, the time complexity is O(n^2), where n is the length of the string.\\n\\n\\n- Space complexity:\\nThe space complexity of this approach is O(n), where n is the length of the input string s. The space is used to store the modified string during each iteration.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        test=True\\n        while test:\\n            test=False\\n            i=0\\n            while i<len(s)-1:\\n                if abs(ord(s[i])-ord(s[i+1]))==32:\\n                    s=s[:i]+s[i+2:]\\n                    test=True\\n                else:\\n                    i+=1\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        test=True\\n        while test:\\n            test=False\\n            i=0\\n            while i<len(s)-1:\\n                if abs(ord(s[i])-ord(s[i+1]))==32:\\n                    s=s[:i]+s[i+2:]\\n                    test=True\\n                else:\\n                    i+=1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792347,
                "title": "rust-stack-one-liner-with-comments",
                "content": "# Intuition\\nAny character added can form an unwanted pair with the last character added to the result, so we want to ignore all those pairs.\\n\\n# Approach\\nTreat the result string as a stack. For each character of `s`, check if it forms an unwanted pair with the top of the stack. Add only those characters that do not form unwanted pairs.\\n\\nA one-liner is its own reward. :)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        s.chars().fold(String::new(), |mut rez, c2| {\\n            match (rez.pop(), c2) {\\n                (None, c2) => c2.to_string(),\\n                (Some(c1), c2) \\n                    if c1 != c2 && c1.to_lowercase().eq(c2.to_lowercase())\\n                    => rez,\\n                (Some(c1), c2) => rez + &c1.to_string() + &c2.to_string(),\\n            }\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        s.chars().fold(String::new(), |mut rez, c2| {\\n            match (rez.pop(), c2) {\\n                (None, c2) => c2.to_string(),\\n                (Some(c1), c2) \\n                    if c1 != c2 && c1.to_lowercase().eq(c2.to_lowercase())\\n                    => rez,\\n                (Some(c1), c2) => rez + &c1.to_string() + &c2.to_string(),\\n            }\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791190,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string str;\\n            int prev=s.size();\\n            int i=0;\\n        for(i=0;i<s.size()-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else str.push_back(s[i]);\\n        }\\n        if(i<s.size()){\\n        str.push_back(s[i]);\\n        }\\n        if(str.size()==prev||str.size()==0){\\n            ans=str;\\n            flag=0;\\n        }\\n        else{\\n            s=str;\\n        }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string str;\\n            int prev=s.size();\\n            int i=0;\\n        for(i=0;i<s.size()-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else str.push_back(s[i]);\\n        }\\n        if(i<s.size()){\\n        str.push_back(s[i]);\\n        }\\n        if(str.size()==prev||str.size()==0){\\n            ans=str;\\n            flag=0;\\n        }\\n        else{\\n            s=str;\\n        }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790953,
                "title": "python-3-code-golf",
                "content": "\\nThe following code is the code before code golf. **(288B)**\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        f = lambda x,y: abs(ord(x)-ord(y)) == 32\\n        for k in s:\\n            if stack and f(stack[-1], k):\\n                stack.pop()\\n            else:\\n                stack += k,\\n        return \"\".join(stack)\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839040013/**\\n\\nYou can remove **type hinting**, **lambda functions**, and **unnecessary white space**, and shorten variable names. **(212B)**\\n```\\nclass Solution:\\n    def makeGood(self,s):\\n        t=[]\\n        for k in s:\\n            if t and abs(ord(t[-1])-ord(k))==32:\\n                t.pop()\\n            else:\\n                t+=k,\\n        return\"\".join(t)\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839056824/**\\n\\nBy replacing the **if-else statement** with a **ternary operator**, you can shorten the length of the code, such as tap(4B).\\n```\\nif statement:\\n\\t[on_true]\\nelse:\\n\\t[on_false]\\n\\t\\n->\\n[on_true] if statement else [on_false]\\n```\\n\\n\\nIf the following format is applied, You can shorten the code. **(155B)**\\nBut You must replace **t+=k,** with **(t:=t+[k])** because of Runtime Error.\\n```\\nclass Solution:\\n    def makeGood(self,s):\\n        t=[]\\n        for k in s:t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])\\n        return\"\".join(t)\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839086569/**\\n\\nIn Python, you can reduce unnecessary tabs by using semicolons.\\nAnd you can attach the code after the colon.\\nLike this:\\n```\\ndef f():\\n\\ta=1\\n\\tb=2\\n(24B)\\ndef f():a=1;b=2\\n(15B)\\n```\\nHowever, the for statement cannot be attached in code golf using the semicolon above.\\nSo, You need to use a trick: **list comprehension**.\\n```\\nfor k in s:t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])\\n(67B)\\n[t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])for k in s]\\n(68B)\\n```\\nAlthough the length has increased by 1B, it is a benefit to be able to attach code with semicolons. **(131B)**\\n```\\nclass Solution:\\n    def makeGood(self,s):t=[];[t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])for k in s];return\"\".join(t)\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839070366/**\\n\\nSo far, the code has been using the stack. \\nif the stack is replaced with string, code would further shorten. **(125B)**\\n**But, this method can be risky because time complexity of slicing in str is O(n).**\\n\\n```\\nclass Solution:\\n    def makeGood(self,s):t=\\'\\';[(t:=t[:-1])if t and abs(ord(t[-1])-ord(k))==32else(t:=t+k)for k in s];return t\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839075113/**\\nIronically, this code is faster than 91%.\\n\\n**Addition**\\n```\\nabs(ord(t[-1])-ord(k))==32 (26B)\\nord(t[-1])^ord(k)==32      (21B)\\n```\\nSo, length of code is **120B**.\\n```\\nclass Solution:\\n    def makeGood(self,s):t=\\'\\';[(t:=t[:-1])if t and ord(t[-1])^ord(k)==32else(t:=t+k)for k in s];return t\\n```\\nAbove code link: **https://leetcode.com/submissions/detail/839094991/**\\n\\nNow, there is very little code to shorten.\\nI will edit the post whenever I have some idea.\\n\\n**Thanks for viewing my Post**\\n**All code lengths were measured in tio.run. https://tio.run/#\\nAll codes received AC.\\nSuggestions of mistakes in my post and how to shorten the code more are always welcome.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        f = lambda x,y: abs(ord(x)-ord(y)) == 32\\n        for k in s:\\n            if stack and f(stack[-1], k):\\n                stack.pop()\\n            else:\\n                stack += k,\\n        return \"\".join(stack)\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):\\n        t=[]\\n        for k in s:\\n            if t and abs(ord(t[-1])-ord(k))==32:\\n                t.pop()\\n            else:\\n                t+=k,\\n        return\"\".join(t)\\n```\n```\\nif statement:\\n\\t[on_true]\\nelse:\\n\\t[on_false]\\n\\t\\n->\\n[on_true] if statement else [on_false]\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):\\n        t=[]\\n        for k in s:t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])\\n        return\"\".join(t)\\n```\n```\\ndef f():\\n\\ta=1\\n\\tb=2\\n(24B)\\ndef f():a=1;b=2\\n(15B)\\n```\n```\\nfor k in s:t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])\\n(67B)\\n[t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])for k in s]\\n(68B)\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):t=[];[t.pop()if t and abs(ord(t[-1])-ord(k))==32else(t:=t+[k])for k in s];return\"\".join(t)\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):t=\\'\\';[(t:=t[:-1])if t and abs(ord(t[-1])-ord(k))==32else(t:=t+k)for k in s];return t\\n```\n```\\nabs(ord(t[-1])-ord(k))==32 (26B)\\nord(t[-1])^ord(k)==32      (21B)\\n```\n```\\nclass Solution:\\n    def makeGood(self,s):t=\\'\\';[(t:=t[:-1])if t and ord(t[-1])^ord(k)==32else(t:=t+k)for k in s];return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790938,
                "title": "javascript-typescript-two-solutions",
                "content": "1. use Upper Case & slice\\n```\\nfunction makeGood(s: string): string {\\n  let i:number = 0;\\n  while (i < s.length - 1) {\\n    if (s[i] !== s[i+1] && (s[i].toUpperCase() === s[i+1] || s[i].toLowerCase() === s[i+1])) {\\n      s = s.slice(0, i) + s.slice(i+2);\\n      i = 0;\\n      continue;\\n    }\\n    i++;\\n  }\\n  return s;\\n};\\n```\\n\\n2. use stack\\n```\\nfunction makeGood(s: string): string {\\n  let stack:Array<string> = [];\\n  \\n  for (let i = 0; i < s.length; i++) {\\n  if (stack) {\\n    if (Math.abs(stack[stack.length - 1]?.charCodeAt(0) - s[i].charCodeAt(0)) === 32) {\\n      stack.pop();  \\n    } \\n} else {\\n      stack.push(s[i]);\\n    }\\n  }\\n  return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction makeGood(s: string): string {\\n  let i:number = 0;\\n  while (i < s.length - 1) {\\n    if (s[i] !== s[i+1] && (s[i].toUpperCase() === s[i+1] || s[i].toLowerCase() === s[i+1])) {\\n      s = s.slice(0, i) + s.slice(i+2);\\n      i = 0;\\n      continue;\\n    }\\n    i++;\\n  }\\n  return s;\\n};\\n```\n```\\nfunction makeGood(s: string): string {\\n  let stack:Array<string> = [];\\n  \\n  for (let i = 0; i < s.length; i++) {\\n  if (stack) {\\n    if (Math.abs(stack[stack.length - 1]?.charCodeAt(0) - s[i].charCodeAt(0)) === 32) {\\n      stack.pop();  \\n    } \\n} else {\\n      stack.push(s[i]);\\n    }\\n  }\\n  return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790818,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(abs(st.top()-s[i])==32)\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.size();\\n        stack<char> st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(abs(st.top()-s[i])==32)\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554257,
                "title": "python-96-faster-easy-solution",
                "content": "```\\ndef makeGood(self, s: str) -> str:\\n        i = 0\\n        s = list(s)\\n        while i<len(s)-1:\\n            if s[i].lower() == s[i+1].lower() and ((s[i].isupper() and s[i+1].islower()) or (s[i].islower() and s[i+1].isupper())):\\n                s.pop(i)\\n                s.pop(i)\\n                i -= 1 if i>0 else 0\\n                continue\\n            i +=1\\n        return \"\".join(s)\\n```\\n![image](https://assets.leetcode.com/users/images/08d40d57-cd80-4642-b414-8a86e06a9065_1662738381.1621356.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef makeGood(self, s: str) -> str:\\n        i = 0\\n        s = list(s)\\n        while i<len(s)-1:\\n            if s[i].lower() == s[i+1].lower() and ((s[i].isupper() and s[i+1].islower()) or (s[i].islower() and s[i+1].isupper())):\\n                s.pop(i)\\n                s.pop(i)\\n                i -= 1 if i>0 else 0\\n                continue\\n            i +=1\\n        return \"\".join(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 781021,
                "title": "python-one-pass-o-n-commented-solution",
                "content": "Here I have ch as a marker for where along the string we are. We move along the string until we find two consecutive letters that can be reduced. If we do find a spot where two consecutive leters can be reduced, we throw them out of the string and continue testing. We then have to move back one step because it is possible that a new reducable pair formed. \\nFor example, if s = \"abJjBq\", after we remove the Jj, bB is formed, so we move back a step to check for that.\\nThis way only one pass is needed. \\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        ch=0 #ch is a marker for where we are along the string\\n        while ch < len(s)-1: #we can stop once we reach the end of the string\\n            if (s[ch].upper()==s[ch+1] and s[ch]==s[ch+1].lower()) or (s[ch].lower()==s[ch+1] and s[ch]==s[ch+1].upper()): #checks if current letter and next letter form a pair we can reduce\\n                s=s[:ch]+s[ch+2:] #takes the reducable pair out of the string\\n                ch=max(0,ch-1) # moves back a step if we just reduced, but also makes sure we dont go negative\\n            else:\\n                ch+=1 #if we dont reduce, simply continue along the string\\n        return s \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        ch=0 #ch is a marker for where we are along the string\\n        while ch < len(s)-1: #we can stop once we reach the end of the string\\n            if (s[ch].upper()==s[ch+1] and s[ch]==s[ch+1].lower()) or (s[ch].lower()==s[ch+1] and s[ch]==s[ch+1].upper()): #checks if current letter and next letter form a pair we can reduce\\n                s=s[:ch]+s[ch+2:] #takes the reducable pair out of the string\\n                ch=max(0,ch-1) # moves back a step if we just reduced, but also makes sure we dont go negative\\n            else:\\n                ch+=1 #if we dont reduce, simply continue along the string\\n        return s \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792914,
                "title": "java-easy-stack-solution-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder stack = new StringBuilder();\\n        int upperLowerCaseDiff = Math.abs(\\'A\\'-\\'a\\');\\n        for (char c: s.toCharArray()){\\n            if (stack.length()==0 || Math.abs(stack.charAt(stack.length()-1) - c)!=upperLowerCaseDiff)stack.append(c);\\n            else {\\n                stack.deleteCharAt(stack.length()-1);\\n            }\\n        }\\n        return stack.toString();\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder stack = new StringBuilder();\\n        int upperLowerCaseDiff = Math.abs(\\'A\\'-\\'a\\');\\n        for (char c: s.toCharArray()){\\n            if (stack.length()==0 || Math.abs(stack.charAt(stack.length()-1) - c)!=upperLowerCaseDiff)stack.append(c);\\n            else {\\n                stack.deleteCharAt(stack.length()-1);\\n            }\\n        }\\n        return stack.toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792407,
                "title": "java-easy-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n       Stack<Character> stack=new Stack<>();\\n       for(int i=0;i<s.length();i++){\\n           if(!stack.isEmpty() && Math.abs(stack.peek()-s.charAt(i))==32){\\n               stack.pop();\\n           }\\n           else stack.push(s.charAt(i));\\n       }\\n        char[] charArr=new char[stack.size()];\\n        int lastIndex=stack.size()-1;\\n        \\n        while(!stack.isEmpty()){\\n            charArr[lastIndex--]=stack.pop();\\n        }\\n       return new String(charArr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n       Stack<Character> stack=new Stack<>();\\n       for(int i=0;i<s.length();i++){\\n           if(!stack.isEmpty() && Math.abs(stack.peek()-s.charAt(i))==32){\\n               stack.pop();\\n           }\\n           else stack.push(s.charAt(i));\\n       }\\n        char[] charArr=new char[stack.size()];\\n        int lastIndex=stack.size()-1;\\n        \\n        while(!stack.isEmpty()){\\n            charArr[lastIndex--]=stack.pop();\\n        }\\n       return new String(charArr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791848,
                "title": "100-faster-and-easy-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove the pair of consecutive characters if one of them is the upercase of the other!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStack\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack <char> stk; //create stack of characters\\n        stk.push(s[0]); //push the first element\\n        for(int i=1;i<s.length();++i) //start comparing from 2nd character if the string\\n        {\\n            if(stk.empty()|| (stk.top()-s[i] != 32 && s[i]-stk.top() != 32)) stk.push(s[i]); // push the character if the stack is empty or in the pair of consecutive characters one is uppercase of the other\\n            else stk.pop(); // difference of ASCII value of lowercase from its uppercase is 32\\n        }\\n        string ans=\"\";\\n        while(!stk.empty())  // pop the remaining stack\\n        {\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end()); // reverse the string as stack pops in reverse order\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack <char> stk; //create stack of characters\\n        stk.push(s[0]); //push the first element\\n        for(int i=1;i<s.length();++i) //start comparing from 2nd character if the string\\n        {\\n            if(stk.empty()|| (stk.top()-s[i] != 32 && s[i]-stk.top() != 32)) stk.push(s[i]); // push the character if the stack is empty or in the pair of consecutive characters one is uppercase of the other\\n            else stk.pop(); // difference of ASCII value of lowercase from its uppercase is 32\\n        }\\n        string ans=\"\";\\n        while(!stk.empty())  // pop the remaining stack\\n        {\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end()); // reverse the string as stack pops in reverse order\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791828,
                "title": "easy-c-solution-using-stack",
                "content": "\"\"\"\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        int i;\\n        stack<char> st;\\n        char x;\\n        string str=\"\";\\n        for(i=0;i<s.size();++i)\\n        {\\n            if(st.empty())\\n                st.push(s[i]);\\n            else\\n            {\\n                x = st.top();\\n                if(isupper(s[i]))\\n                {\\n                    if(islower(x) && toupper(x)==s[i])\\n                        st.pop();\\n                    else\\n                        st.push(s[i]);\\n                }\\n                if(islower(s[i]))\\n                {\\n                    if(isupper(x) && tolower(x)==s[i])\\n                        st.pop();\\n                    else\\n                        st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty())\\n        {\\n            x = st.top();\\n            str=str+x;\\n            st.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n\"\"\"\\nTraverse through the string and push the current character only if the top of stack character and current character satisfy the conditions of a good string else don\\'t push the current character and pop the top element of stack.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        int i;\\n        stack<char> st;\\n        char x;\\n        string str=\"\";\\n        for(i=0;i<s.size();++i)\\n        {\\n            if(st.empty())\\n                st.push(s[i]);\\n            else\\n            {\\n                x = st.top();\\n                if(isupper(s[i]))\\n                {\\n                    if(islower(x) && toupper(x)==s[i])\\n                        st.pop();\\n                    else\\n                        st.push(s[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2791685,
                "title": "best-solution-in-c-o-1-sc",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n\\n***1st Approach : O(1) SC***\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.size(),i=0;\\n        if(n==0 || n==1) \\n            return s;\\n        while(i<n-1){\\n            if(abs(s[i]-s[i+1])==32){  //ASCII diff b/w same characters of opposite case is always 32\\n                s.erase(s.begin()+i);\\n                s.erase(s.begin()+i); //As deleting a character in previous step shifts the next character to the current \\'i\\' index so thats why deleting at same position again to remove 2nd adjacent character\\n                if(i>0)\\n                    i--;\\n                n=s.size();\\n            }\\n            else\\n                i++;\\n        }\\n        return s;\\n    }\\n};\\n```\\n***2nd Approach : O(n) SC(Using Stack)***\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> sta;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(sta.size()==0){\\n                sta.push(s[i]);\\n                continue;\\n            }\\n            int x=sta.top();\\n            if(abs(x-s[i])==32)\\n                sta.pop();\\n            else{\\n                sta.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(sta.size()){\\n            ans+=sta.top();\\n            sta.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n**Happy LeetCoding**\\uD83D\\uDCAF\\n**Please Upvote**\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.size(),i=0;\\n        if(n==0 || n==1) \\n            return s;\\n        while(i<n-1){\\n            if(abs(s[i]-s[i+1])==32){  //ASCII diff b/w same characters of opposite case is always 32\\n                s.erase(s.begin()+i);\\n                s.erase(s.begin()+i); //As deleting a character in previous step shifts the next character to the current \\'i\\' index so thats why deleting at same position again to remove 2nd adjacent character\\n                if(i>0)\\n                    i--;\\n                n=s.size();\\n            }\\n            else\\n                i++;\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> sta;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(sta.size()==0){\\n                sta.push(s[i]);\\n                continue;\\n            }\\n            int x=sta.top();\\n            if(abs(x-s[i])==32)\\n                sta.pop();\\n            else{\\n                sta.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(sta.size()){\\n            ans+=sta.top();\\n            sta.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791513,
                "title": "java-100-faster-simplest-and-easiest-soln-using-for-loop-biginner-friendly",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int len=sb.length();\\n        for(int i=0;i<sb.length()-1;i++){\\n            char c1=sb.charAt(i);\\n            char c2=sb.charAt(i+1);\\n            if(c1==c2+32 || c1==c2-32){\\n                sb.delete(i,i+2);\\n                i=i==0?i-1:i-2;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int len=sb.length();\\n        for(int i=0;i<sb.length()-1;i++){\\n            char c1=sb.charAt(i);\\n            char c2=sb.charAt(i+1);\\n            if(c1==c2+32 || c1==c2-32){\\n                sb.delete(i,i+2);\\n                i=i==0?i-1:i-2;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791168,
                "title": "stack-based-approach-one-pass-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse char of string one by one and maintain a ans stack. For every element check if top of stack is lower case or upper case of current element, If yes, then pop it from the stack else pust current element to the stack itself. After traversing all characters we are left with out ans in the stack.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        stack<char> st;\\n         int diff = \\'a\\'-\\'A\\';   //** diff b/w 2 same char (upper & lower)\\n        for(char c:s){\\n            if(st.size()==0)st.push(c);\\n               \\n            else{\\n               char a = st.top();\\n               if((c+diff==a || a+diff==c))st.pop(); //**if upper lower case combination found\\n               else\\n                 st.push(c);   \\n            }\\n\\n        }\\n\\n        string ans = \"\";\\n        while(st.size()!=0){\\n           ans = st.top()+ans;\\n           st.pop();\\n        }\\n        \\n        return ans;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n        stack<char> st;\\n         int diff = \\'a\\'-\\'A\\';   //** diff b/w 2 same char (upper & lower)\\n        for(char c:s){\\n            if(st.size()==0)st.push(c);\\n               \\n            else{\\n               char a = st.top();\\n               if((c+diff==a || a+diff==c))st.pop(); //**if upper lower case combination found\\n               else\\n                 st.push(c);   \\n            }\\n\\n        }\\n\\n        string ans = \"\";\\n        while(st.size()!=0){\\n           ans = st.top()+ans;\\n           st.pop();\\n        }\\n        \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790935,
                "title": "javascript",
                "content": "```\\n    let checkGoodStr = false;\\n    let array = s.split(\"\");\\n    let count = 0;\\n    \\n    while (checkGoodStr === false) {\\n\\t\\n\\t\\t//check if it is single-letter string\\n        if (array.length === 1) checkGoodStr = true;\\n\\t\\t\\n\\t\\t//if not single letter, each time we see uppercase and lowercase next to each other, \\n\\t\\t// we remove the 2 letters, condition set to false, counter + 1, break the loop\\n        for (let i = 0; i < array.length - 1; i++) {\\n            if (Math.abs(array[i].charCodeAt(0) - array[i + 1].charCodeAt(0)) === 32) {\\n                array.splice(i, 2);\\n                checkGoodStr = false;\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// if counter = 0, that means we have are good \\n\\t\\t//otherwise, set the counter to 0 \\n        if (count === 0) {\\n            checkGoodStr = true;\\n        } else {\\n            count = 0;\\n        }\\n    }\\n        \\n    //console.log(array)\\n    return array.join(\"\")",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    let checkGoodStr = false;\\n    let array = s.split(\"\");\\n    let count = 0;\\n    \\n    while (checkGoodStr === false) {\\n\\t\\n\\t\\t//check if it is single-letter string\\n        if (array.length === 1) checkGoodStr = true;\\n\\t\\t\\n\\t\\t//if not single letter, each time we see uppercase and lowercase next to each other, \\n\\t\\t// we remove the 2 letters, condition set to false, counter + 1, break the loop\\n        for (let i = 0; i < array.length - 1; i++) {\\n            if (Math.abs(array[i].charCodeAt(0) - array[i + 1].charCodeAt(0)) === 32) {\\n                array.splice(i, 2);\\n                checkGoodStr = false;\\n                count++;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// if counter = 0, that means we have are good \\n\\t\\t//otherwise, set the counter to 0 \\n        if (count === 0) {\\n            checkGoodStr = true;\\n        } else {\\n            count = 0;\\n        }\\n    }\\n        \\n    //console.log(array)\\n    return array.join(\"\")",
                "codeTag": "Unknown"
            },
            {
                "id": 2790918,
                "title": "golang-stack",
                "content": "```\\nfunc makeGood(s string) string {\\n    bytes := make([]byte, 0)\\n    for i, _ := range s {\\n        n := len(bytes)\\n        if n > 0 && (bytes[n-1] == s[i] - \\'a\\' + \\'A\\' || bytes[n-1] == s[i] - \\'A\\' + \\'a\\') {\\n            bytes = bytes[:n-1]\\n        } else {\\n            bytes = append(bytes, s[i])\\n        }\\n    }\\n    return string(bytes)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeGood(s string) string {\\n    bytes := make([]byte, 0)\\n    for i, _ := range s {\\n        n := len(bytes)\\n        if n > 0 && (bytes[n-1] == s[i] - \\'a\\' + \\'A\\' || bytes[n-1] == s[i] - \\'A\\' + \\'a\\') {\\n            bytes = bytes[:n-1]\\n        } else {\\n            bytes = append(bytes, s[i])\\n        }\\n    }\\n    return string(bytes)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790887,
                "title": "daily-leetcoding-challenge-november-8-o-n-t-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.length();\\n        //first we will initialize epty string answer or strong\\n        //we will check that is there two adjacent char is in this string or not\\n        string ans=\"\";\\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            //if stack is empty we will push element in the stack \\n            if(st.empty()) \\n                st.push(s[i]);\\n            else\\n            //here we are chacking top element of the stack is making string bad or not\\n            //if yes we will ignore currunt element and pop top element of that stack\\n                if(abs(st.top()-s[i])==32)\\n                    st.pop();\\n                else\\n                 //else we will push that element in the stack\\n                    st.push(s[i]);  \\n        }\\n        //push all elemnt int the stack but it will be in reverse order\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n         reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.length();\\n        //first we will initialize epty string answer or strong\\n        //we will check that is there two adjacent char is in this string or not\\n        string ans=\"\";\\n        stack<int>st;\\n        for(int i=0;i<n;i++){\\n            //if stack is empty we will push element in the stack \\n            if(st.empty()) \\n                st.push(s[i]);\\n            else\\n            //here we are chacking top element of the stack is making string bad or not\\n            //if yes we will ignore currunt element and pop top element of that stack\\n                if(abs(st.top()-s[i])==32)\\n                    st.pop();\\n                else\\n                 //else we will push that element in the stack\\n                    st.push(s[i]);  \\n        }\\n        //push all elemnt int the stack but it will be in reverse order\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n         reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790762,
                "title": "daily-leetcoding-challenge-november-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/make-the-string-great/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/make-the-string-great/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2616477,
                "title": "java-simple-and-easy-to-understand-solution-using-stack",
                "content": "```\\npublic String makeGood(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<n; i++){\\n            if(!stack.empty() && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                  stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(String.valueOf(stack.pop()));\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String makeGood(String s) {\\n        int n = s.length();\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<n; i++){\\n            if(!stack.empty() && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                  stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(String.valueOf(stack.pop()));\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2527693,
                "title": "java-5ms-runtime-easy-and-easy-solution",
                "content": "```\\nStringBuilder ss = new StringBuilder(s);\\nfor (int i = 0; i <= ss.length() - 2; i++)\\n\\tif (ss.codePointAt(i)+32 == ss.codePointAt(i + 1) || ss.codePointAt(i)-32 == ss.codePointAt(i + 1)) {\\n\\t\\tss.delete(i, i + 2);\\n\\t\\ti =- 1;\\n\\t}\\nreturn ss.toString();\\n```\\n\\n\\n# **explanation**\\nSee, codepoint gives unique Ascii(Decimal value) code of each character.\\ntry this code\\n\\nSystem.out.println(\"123\".codePointAt(0)); it will give 49 as output code for \"1\"\\n\\nSystem.out.println(\"A\".codePointAt(0))-->65\\nSystem.out.println(\"a\".codePointAt(0))-->97\\n\\n97-65 = 32\\n\\ncharacter-> A a --> if( \"Aa\".codePointAt(0) + 32 == \"Aa\".codePointAt(1) ) then delete both character\\nindex -> 0 1\\n\\nor\\n\\ncharacter-> a A --> if( \"aA\".codePointAt(0) - 32 == \"aA\".codePointAt(1) ) then delete both character\\nindex -> 0 1\\n\\ni=i-1--> when we delete both character we have to tell loop to come 1 index/step before then loop continue\\n\\nbelow is link for ASCII table\\nhttps://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/ASCII-Table-wide.svg/2560px-ASCII-Table-wide.svg.png\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nStringBuilder ss = new StringBuilder(s);\\nfor (int i = 0; i <= ss.length() - 2; i++)\\n\\tif (ss.codePointAt(i)+32 == ss.codePointAt(i + 1) || ss.codePointAt(i)-32 == ss.codePointAt(i + 1)) {\\n\\t\\tss.delete(i, i + 2);\\n\\t\\ti =- 1;\\n\\t}\\nreturn ss.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786233,
                "title": "java-easy-without-stringbuilder-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n    Stack <Character> stk = new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)>=65 && s.charAt(i)<=90){ //checking if character is uppercase //\\n            \\n            if(!stk.empty() && stk.peek()==Character.toLowerCase(s.charAt(i)) ){  // checking chacter at top of stack if it is lowercase of our current character then we will remove it //\\n                stk.pop();\\n            }else stk.push(s.charAt(i)); // otherwise we will add it to stack //\\n        }else{ // similarly it is for if our char is lower case//\\n            if(!stk.empty() && stk.peek()==Character.toUpperCase(s.charAt(i)) ){ \\n                stk.pop();\\n            }else stk.push(s.charAt(i));\\n        }\\n        \\n    }\\n        String ans =\"\";\\n        while(!stk.empty())ans=stk.pop()+ans;  retrieving our ans from stack//\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n    Stack <Character> stk = new Stack<>();\\n    for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)>=65 && s.charAt(i)<=90){ //checking if character is uppercase //\\n            \\n            if(!stk.empty() && stk.peek()==Character.toLowerCase(s.charAt(i)) ){  // checking chacter at top of stack if it is lowercase of our current character then we will remove it //\\n                stk.pop();\\n            }else stk.push(s.charAt(i)); // otherwise we will add it to stack //\\n        }else{ // similarly it is for if our char is lower case//\\n            if(!stk.empty() && stk.peek()==Character.toUpperCase(s.charAt(i)) ){ \\n                stk.pop();\\n            }else stk.push(s.charAt(i));\\n        }\\n        \\n    }\\n        String ans =\"\";\\n        while(!stk.empty())ans=stk.pop()+ans;  retrieving our ans from stack//\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387662,
                "title": "c-tc-o-n-sc-o-n-stack",
                "content": "# Feel free to post your doubt in comment\\n```\\nstring makeGood(string s) {\\n\\tint n=s.size();\\n\\tstack<char> st;\\n\\tfor( int i=0; i<n; i++ ){\\n\\t\\tchar c = s[i];\\n\\t\\tif( st.empty() ){\\n\\t\\t\\tst.push( c );\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tchar t = st.top();\\n\\t\\tif( (t)==(char)(c-32) || (t)==(char)(c+32)  ){\\n\\t\\t\\tst.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tst.push( c );\\n\\t}\\n\\tstring ans=\"\";\\n\\twhile( !st.empty() ){\\n\\t\\tans+=st.top();\\n\\t\\tst.pop();\\n\\t}\\n\\treverse( ans.begin(), ans.end() );\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring makeGood(string s) {\\n\\tint n=s.size();\\n\\tstack<char> st;\\n\\tfor( int i=0; i<n; i++ ){\\n\\t\\tchar c = s[i];\\n\\t\\tif( st.empty() ){\\n\\t\\t\\tst.push( c );\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tchar t = st.top();\\n\\t\\tif( (t)==(char)(c-32) || (t)==(char)(c+32)  ){\\n\\t\\t\\tst.pop();\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tst.push( c );\\n\\t}\\n\\tstring ans=\"\";\\n\\twhile( !st.empty() ){\\n\\t\\tans+=st.top();\\n\\t\\tst.pop();\\n\\t}\\n\\treverse( ans.begin(), ans.end() );\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156310,
                "title": "python-extremely-fast-and-easy-solution",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        #Self done\\n        stack = []\\n        for i in s:\\n            if len(stack)==0:\\n                stack.append(i)\\n                continue\\n            if stack[-1]==i.swapcase():\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return \"\".join(stack)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        #Self done\\n        stack = []\\n        for i in s:\\n            if len(stack)==0:\\n                stack.append(i)\\n                continue\\n            if stack[-1]==i.swapcase():\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return \"\".join(stack)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1110640,
                "title": "c-easy-solution",
                "content": "\\tif u like plz upvote ->\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\tstring makeGood(string s) {\\n\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\t\\t\\tif(s.size()==0)\\n\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\tif(s.size()<2)\\n\\t\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<s.size();++i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(abs(s[i]-s[i+1])==32)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\ts.erase(i,2);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(i==0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti-=2;\\n\\t\\t\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\tstring makeGood(string s) {\\n\\t\\t\\t\\t\\t\\tint n=s.size();\\n\\t\\t\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\t\\t\\tif(s.size()==0)\\n\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\tif(s.size()<2)\\n\\t\\t\\t\\t\\t\\t\\treturn s;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<s.size();++i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(abs(s[i]-s[i+1])==32)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\ts.erase(i,2);\\n\\t\\t\\t\\t\\t\\t\\t\\tif(i==0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti-=2;\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 781011,
                "title": "java-recursive-solution",
                "content": "``` java\\nclass Solution {\\n    public String makeGood(String s) {\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            char a = s.charAt(i);\\n            char b = s.charAt(i + 1);\\n            if (a != b && Character.toLowerCase(a) == Character.toLowerCase(b)) {\\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public String makeGood(String s) {\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            char a = s.charAt(i);\\n            char b = s.charAt(i + 1);\\n            if (a != b && Character.toLowerCase(a) == Character.toLowerCase(b)) {\\n                return makeGood(s.substring(0, i) + s.substring(i+2));\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791593,
                "title": "easiest-of-all-0ms-faster-than-100-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n       string k;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            k.push_back(s[i]);\\n            while(k.size()&&(abs(k.back()-s[i+1])==32))\\n            {\\n                k.pop_back();\\n                i++;\\n            }\\n            i++;\\n        }\\n        return k;\\n    }\\n};\\n//Feedback and suggestions are welcomed , Happy coding!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n       string k;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            k.push_back(s[i]);\\n            while(k.size()&&(abs(k.back()-s[i+1])==32))\\n            {\\n                k.pop_back();\\n                i++;\\n            }\\n            i++;\\n        }\\n        return k;\\n    }\\n};\\n//Feedback and suggestions are welcomed , Happy coding!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790846,
                "title": "java-simple-solution-with-linkedlist",
                "content": "\\uD83D\\uDC69  If you like this solution, please click UpVote button. If you have any question, feel free write as a comment. Thanks. \\uD83D\\uDE0A\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        char[] chArr = s.toCharArray(); String str=\"\";\\n        LinkedList<Character> linkedList = new LinkedList<>();\\n        for(int i = 0; i < chArr.length; i++){\\n            if(!linkedList.isEmpty() && Math.abs(linkedList.getLast() - chArr[i]) == \\'a\\' - \\'A\\'){\\n                linkedList.removeLast(); continue;\\n            }\\n            if(i + 1 != chArr.length && Math.abs(chArr[i + 1] - chArr[i]) == \\'a\\' - \\'A\\') i++;\\n            else linkedList.add(chArr[i]);\\n        }\\n        while(!linkedList.isEmpty()){\\n            str+=(linkedList.removeFirst());\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n        char[] chArr = s.toCharArray(); String str=\"\";\\n        LinkedList<Character> linkedList = new LinkedList<>();\\n        for(int i = 0; i < chArr.length; i++){\\n            if(!linkedList.isEmpty() && Math.abs(linkedList.getLast() - chArr[i]) == \\'a\\' - \\'A\\'){\\n                linkedList.removeLast(); continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1981476,
                "title": "javascript-solution-without-stack-runtime-90-memory-73",
                "content": "Just make step back after hitting the main case.\\n```\\nvar makeGood = function(s) {\\n    s = s.split(\\'\\');\\n    let i = 0;\\n    while (i < s.length - 1) {\\n        if (s[i] && s[i + 1] && s[i].toLowerCase() === s[i + 1].toLowerCase() && s[i] !== s[i + 1]) { // main check: two adjacent chars, one lowerCase another upperCase\\n            s.splice(i, 2); // remove those two chars\\n            i--; // go one step back to start checking if the main case check is relevant for previous char and chars next to removed chars\\n\\t\\t\\tcontinue;\\n        }\\n        i++;\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeGood = function(s) {\\n    s = s.split(\\'\\');\\n    let i = 0;\\n    while (i < s.length - 1) {\\n        if (s[i] && s[i + 1] && s[i].toLowerCase() === s[i + 1].toLowerCase() && s[i] !== s[i + 1]) { // main check: two adjacent chars, one lowerCase another upperCase\\n            s.splice(i, 2); // remove those two chars\\n            i--; // go one step back to start checking if the main case check is relevant for previous char and chars next to removed chars\\n\\t\\t\\tcontinue;\\n        }\\n        i++;\\n    }\\n    \\n    return s.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1281860,
                "title": "brute-force-100-fast",
                "content": "```class Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            if(!st.empty()&&(st.top()>=\\'a\\'&&st.top()<=\\'z\\')&&(st.top()-\\'a\\')!=(s[i]-\\'A\\')){\\n                st.push(s[i]);\\n            }\\n            else if(!st.empty()&&(st.top()>=\\'A\\'&&st.top()<=\\'Z\\')&&(st.top()-\\'A\\')!=(s[i]-\\'a\\')){\\n                st.push(s[i]);\\n            }\\n            else if(!st.empty()&&(st.top()>=\\'a\\'&&st.top()<=\\'z\\')&&(st.top()-\\'a\\')==(s[i]-\\'A\\')){\\n                st.pop();\\n            }\\n            else if(!st.empty()&&(st.top()>=\\'A\\'&&st.top()<=\\'Z\\')&&(st.top()-\\'A\\')==(s[i]-\\'a\\')){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        string res;\\n        int n=st.size();\\n        if(n==0) return \"\";\\n        for(int i=0;i<n;i++){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.length();i++){\\n            if(!st.empty()&&(st.top()>=\\'a\\'&&st.top()<=\\'z\\')&&(st.top()-\\'a\\')!=(s[i]-\\'A\\')){\\n                st.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1271399,
                "title": "easy-to-understand-c-solution-using-stack",
                "content": "**You can also approach this problem with C++STL, without using stack.**\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack<char>stk;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(!stk.empty() && (i + 32 == stk.top() || i-32 == stk.top()))\\n            {\\n                stk.pop();\\n            }\\n            else\\n            {\\n                stk.push(i);\\n            }\\n        }\\n        \\n        while(!stk.empty())\\n        {\\n            ans = stk.top()+ans;\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t able to understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack<char>stk;\\n        string ans;\\n        for(char i:s)\\n        {\\n            if(!stk.empty() && (i + 32 == stk.top() || i-32 == stk.top()))\\n            {\\n                stk.pop();\\n            }\\n            else\\n            {\\n                stk.push(i);\\n            }\\n        }\\n        \\n        while(!stk.empty())\\n        {\\n            ans = stk.top()+ans;\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243178,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        let diff_cases =\\n            |c1: char, c2: char| c1.to_ascii_lowercase() == c2.to_ascii_lowercase() && c1 != c2;\\n        s.chars()\\n            .into_iter()\\n            .fold(Vec::with_capacity(s.len()), |mut v: Vec<char>, c| {\\n                match v.last() {\\n                    Some(prev_c) if diff_cases(c, *prev_c) => {\\n                        v.pop();\\n                    }\\n                    _ => v.push(c),\\n                }\\n                v\\n            })\\n            .iter()\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        let diff_cases =\\n            |c1: char, c2: char| c1.to_ascii_lowercase() == c2.to_ascii_lowercase() && c1 != c2;\\n        s.chars()\\n            .into_iter()\\n            .fold(Vec::with_capacity(s.len()), |mut v: Vec<char>, c| {\\n                match v.last() {\\n                    Some(prev_c) if diff_cases(c, *prev_c) => {\\n                        v.pop();\\n                    }\\n                    _ => v.push(c),\\n                }\\n                v\\n            })\\n            .iter()\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929909,
                "title": "c-5-solutions-compared-and-explained-100-time-80-space",
                "content": "This is a relatively easy problem; so let\\'s solve it in more than one way :)\\n\\n##  Mk I - marking pairs\\n\\nFirst we declare a few support variables:\\n* our string `res`, that will store the result;\\n* `mustCheck`, a boolean set to `true`  that will take note of changes was we go;\\n* `len` an int storing the size of the input string `s`, reduced by `- 1`.\\n\\nWe are then going to loop as long as `mustCheck == true`; inside the loop, we will:\\n* set `mustCheck` to `false`;\\n* run a for loop with `i` going from `0` to `len` and inside it:\\n\\t* set `j` to be initially `i + 1`, then in case it points to a marked character, move it right until you find another non-marked character;\\n\\t* check for a match, that you can easily do with `abs(s[i] - s[j]) == 32)`, since all lowercase characters are `32` positions away from their uppercase counterparts; when a match is found:\\n\\t\\t* mark both characters as `\\' \\'`;\\n\\t\\t* move `i` to `j`\\'s position, so that the next iteration of the for loop will put it to `j + 1`;\\n\\t\\t* set `mustCheck` again to `true`, since each new pair found will imply we need to scan again.\\n\\nOnce we have run a full loop without new changes, we can run one last time through `s`, collect all the characters not marked and push them into `res`, before returning it :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        bool mustCheck = true;\\n        int len = s.size() - 1;\\n        // loop to removes pairs\\n        while (mustCheck) {\\n            mustCheck = false;\\n            for (int i = 0, j; i < len; i++) {\\n                // skipping already marked characters\\n                if (s[i] == \\' \\') continue;\\n                j = i + 1;\\n                // moving j to the next non marked character\\n                while (j <= len && s[j] == \\' \\') j++;\\n                // checking for a match of upper-+lowercase\\n                if (abs(s[i] - s[j]) == 32) {\\n                    s[i] = \\' \\';\\n                    s[j] = \\' \\';\\n                    i = j -1;\\n                    mustCheck = true;\\n                }\\n            }\\n        }\\n        // extracting all \"surviving\" characters\\n        for (char c: s) if (c != \\' \\') res.push_back(c);\\n        return res;\\n    }\\n};\\n```\\n\\n## Mk II - marking pairs, improved\\n\\nSimilar to the above, but now when we find a match, we will also \"expand\" to the characters immediately before and after said match, to avoid finding them later with more expensive new iterations.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        bool mustCheck = true;\\n        int len = s.size() - 1;\\n        // loop to removes pairs\\n        while (mustCheck) {\\n            mustCheck = false;\\n            for (int i = 0, j; i < len; i++) {\\n                // skipping already marked characters\\n                if (s[i] == \\' \\') continue;\\n                j = i + 1;\\n                // moving j to the next non marked character\\n                while (j <= len && s[j] == \\' \\') j++;\\n                // checking for a match of upper-+lowercase\\n                while (i >= 0 && j <= len && abs(s[i] - s[j]) == 32) {\\n                    s[i] = \\' \\';\\n                    s[j] = \\' \\';\\n                    // checking for more adjacent matches\\n                    i--, j++;\\n                    mustCheck = true;\\n                }\\n                if (mustCheck) i = j;\\n            }\\n        }\\n        // extracting all \"surviving\" characters\\n        for (char c: s) if (c != \\' \\') res.push_back(c);\\n        return res;\\n    }\\n};\\n```\\n\\n## Mk III - using substr\\n\\nBoring one, this one will also probably use more memory to deal with our substrings as we go.\\n\\nWe will create 2 support variables:\\n* `res` will store our polished string, initialised to be `s`;\\n* `len` will store the (constantly updated) length of the string.\\n\\nNotice that we do not need to use a boolean now - our main loop is turned into a `do... while` and it will check the if at the end of each iteration `res` is different from `s`, which means changes were made and maybe more are needed.\\n\\nInitially I put the condition as `res != s`, but then I realised that `len != s.size()` is just terribly more efficient: comparing a lot of characters one by one vs. comparing a couple of integers if a big win for larger strings!\\n\\nInside the loop, we will proceed similarly to the first method, having a `for` loop go through all the characters (starting from position `1` for convenience) up to `len`; once we find a match, we:\\n* update `res`, cutting the `2` matching characters from it;\\n* update `len` to be smaller by `2`;\\n* shift back `i` by one position, so that it will basically stay at the same place when the loop increments it, to check the new character on that position and potentially save us some loops.\\n\\nOnce we are done and no more changes can be done, we return `res` :)\\n\\nThis approach is significantly less efficient in both time and space than the previous two.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res = s;\\n        int len = s.size();\\n        // loop to removes pairs\\n        do {\\n            s = res;\\n            for (int i = 1; i < len; i++) {\\n                // cutting out matching pairs of characters\\n                if (abs(res[i - 1] - res[i]) == 32) {\\n                    // removing the chars from res\\n                    res = res.substr(0, i - 1) + res.substr(i + 1);\\n                    // updating len to the new value\\n                    len -= 2;\\n                    // moving back i to check the new character in the same position\\n                    i--;\\n                }\\n            }\\n        } while (len != s.size());\\n        return res;\\n    }\\n};\\n```\\n\\n## Mk IV - using substr, improved\\n\\nBasically a combination of version 3 with the logic of the expanding check from version 2, for the added advantage of doing only one string replacement for potentially multiple matching characters.\\n\\nSimilarly to the other `substr` method, this is still slower and more memory gulping than my first 2 versions.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res = s;\\n        int len = s.size();\\n        // loop to removes pairs\\n        do {\\n            s = res;\\n            for (int j = 1, i; j < len; j++) {\\n                i = j - 1;\\n                // cutting out matching pairs of characters\\n                while (i >= 0 && j < len && abs(res[i] - res[j]) == 32) {\\n                    // updating len to the new value\\n                    len -= 2;\\n                    // moving back i to check the new character in the same position\\n                    i--, j++;\\n                }\\n                // removing the matched chars from res\\n                res = res.substr(0, i + 1) + res.substr(j);\\n            }\\n        } while (len != s.size());\\n        return res;\\n    }\\n};\\n```\\n\\n## Mk V - using a stack (which is actually a cheaper array)\\n\\nSimilarly to the valid parentheses-family of problems, we store in a \"stack\" each character, unless it is a match (uppercase/lowercase pair), in which case we pop the last element and move on.\\n\\nThe logic is pretty simple, starting with a few variables:\\n* `res` is our initially empty response string;\\n* `st` is going to be our stack (we do not care if it is `char` or `int`, since they work the same for us) - set to be of length equal to `s.size()`, in case we get an input string without a single match;\\n* `pos` will tell us where to put our next element in the \"stack\", initialised to `0` (first element).\\n\\nLooping each character `c` from `s`, we will do 2 simple actions:\\n* if the \"stack\" is empty (`pos == 0`) or the character on top of it and the currently parsed one do not match (`abs(st[pos - 1] - c) != 32`), then we add `c` to the stack (`st[pos++] = c`);\\n* otherwise we just pop from the stack (`pos--`).\\n\\nNotice that on top of being much more efficient than a normal stack (at possibly the cost of a bit more memory in some cases), this approach also makes easier to extract data from it, since we can just now resize `res` to be `pos` long and write with a normal `for` loops all the characters in it, without having to cause multiple reallocations and/or reverse the string later as you would have to if you composed `res` popping one element at a time from the top of a stack.\\n\\nIf you really wanted to keep things even cheaper, you might have saved declaring `res` and just resized and over-written `s`.\\n\\nIn any case, once you are done you can just return your result string :)\\n\\nThis version seems to be the winner in speed and consumes as much memory as the first one.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        int st[s.size()], pos = 0;\\n        // loop to removes pairs\\n        for (char c: s) {\\n            // adding a char to the stack if the stack is empty\\n            // or the top does not match the char\\n            if (!pos || abs(st[pos - 1] - c) != 32) st[pos++] = c;\\n            else pos--;\\n        }\\n        // moving the char out of the stack into res\\n        if (pos) res.resize(pos);\\n        for (int i = 0; i < pos; i++) res[i] = st[i];\\n        return res;\\n    }\\n};\\n```\\n\\nI planned on converting some solution to recursive, but then I got too bored with the same problem to continue eviscerating it :D",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        bool mustCheck = true;\\n        int len = s.size() - 1;\\n        // loop to removes pairs\\n        while (mustCheck) {\\n            mustCheck = false;\\n            for (int i = 0, j; i < len; i++) {\\n                // skipping already marked characters\\n                if (s[i] == \\' \\') continue;\\n                j = i + 1;\\n                // moving j to the next non marked character\\n                while (j <= len && s[j] == \\' \\') j++;\\n                // checking for a match of upper-+lowercase\\n                if (abs(s[i] - s[j]) == 32) {\\n                    s[i] = \\' \\';\\n                    s[j] = \\' \\';\\n                    i = j -1;\\n                    mustCheck = true;\\n                }\\n            }\\n        }\\n        // extracting all \"surviving\" characters\\n        for (char c: s) if (c != \\' \\') res.push_back(c);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        bool mustCheck = true;\\n        int len = s.size() - 1;\\n        // loop to removes pairs\\n        while (mustCheck) {\\n            mustCheck = false;\\n            for (int i = 0, j; i < len; i++) {\\n                // skipping already marked characters\\n                if (s[i] == \\' \\') continue;\\n                j = i + 1;\\n                // moving j to the next non marked character\\n                while (j <= len && s[j] == \\' \\') j++;\\n                // checking for a match of upper-+lowercase\\n                while (i >= 0 && j <= len && abs(s[i] - s[j]) == 32) {\\n                    s[i] = \\' \\';\\n                    s[j] = \\' \\';\\n                    // checking for more adjacent matches\\n                    i--, j++;\\n                    mustCheck = true;\\n                }\\n                if (mustCheck) i = j;\\n            }\\n        }\\n        // extracting all \"surviving\" characters\\n        for (char c: s) if (c != \\' \\') res.push_back(c);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res = s;\\n        int len = s.size();\\n        // loop to removes pairs\\n        do {\\n            s = res;\\n            for (int i = 1; i < len; i++) {\\n                // cutting out matching pairs of characters\\n                if (abs(res[i - 1] - res[i]) == 32) {\\n                    // removing the chars from res\\n                    res = res.substr(0, i - 1) + res.substr(i + 1);\\n                    // updating len to the new value\\n                    len -= 2;\\n                    // moving back i to check the new character in the same position\\n                    i--;\\n                }\\n            }\\n        } while (len != s.size());\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res = s;\\n        int len = s.size();\\n        // loop to removes pairs\\n        do {\\n            s = res;\\n            for (int j = 1, i; j < len; j++) {\\n                i = j - 1;\\n                // cutting out matching pairs of characters\\n                while (i >= 0 && j < len && abs(res[i] - res[j]) == 32) {\\n                    // updating len to the new value\\n                    len -= 2;\\n                    // moving back i to check the new character in the same position\\n                    i--, j++;\\n                }\\n                // removing the matched chars from res\\n                res = res.substr(0, i + 1) + res.substr(j);\\n            }\\n        } while (len != s.size());\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        // support variables\\n        string res;\\n        int st[s.size()], pos = 0;\\n        // loop to removes pairs\\n        for (char c: s) {\\n            // adding a char to the stack if the stack is empty\\n            // or the top does not match the char\\n            if (!pos || abs(st[pos - 1] - c) != 32) st[pos++] = c;\\n            else pos--;\\n        }\\n        // moving the char out of the stack into res\\n        if (pos) res.resize(pos);\\n        for (int i = 0; i < pos; i++) res[i] = st[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834502,
                "title": "python-easy-to-understand-solution-using-stack",
                "content": "```\\nclass Solution(object):\\n    def makeGood(self, s):\\n        stack = []\\n        for item in s:\\n            if stack and abs(ord(stack[-1])-ord(item)) == 32:\\n                stack.pop()\\n            else:\\n                stack.append(item)\\n        return str.join(\"\", stack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def makeGood(self, s):\\n        stack = []\\n        for item in s:\\n            if stack and abs(ord(stack[-1])-ord(item)) == 32:\\n                stack.pop()\\n            else:\\n                stack.append(item)\\n        return str.join(\"\", stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783905,
                "title": "simple-java-while-loop-solution-100-fast",
                "content": "```\\nclass Solution {\\n\\n\\tpublic String makeGood(String s) {\\n\\t\\tif(s.length()<=1)\\n\\t\\t\\treturn s;\\n        int i=0, j=1;\\n        StringBuilder sb = new StringBuilder(s);\\n        while(j < sb.length() && sb.length() > 1) {\\n        \\tif(Math.abs(sb.charAt(i) - sb.charAt(j)) == 32) {\\n        \\t\\tsb.deleteCharAt(i);\\n        \\t\\tsb.deleteCharAt(i);\\n        \\t\\tif(i>0)\\n        \\t\\t\\ti = i-1;\\n        \\t\\tj = i+1;\\n        \\t\\tcontinue;\\n        \\t}\\n        \\ti++;j++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\tpublic String makeGood(String s) {\\n\\t\\tif(s.length()<=1)\\n\\t\\t\\treturn s;\\n        int i=0, j=1;\\n        StringBuilder sb = new StringBuilder(s);\\n        while(j < sb.length() && sb.length() > 1) {\\n        \\tif(Math.abs(sb.charAt(i) - sb.charAt(j)) == 32) {\\n        \\t\\tsb.deleteCharAt(i);\\n        \\t\\tsb.deleteCharAt(i);\\n        \\t\\tif(i>0)\\n        \\t\\t\\ti = i-1;\\n        \\t\\tj = i+1;\\n        \\t\\tcontinue;\\n        \\t}\\n        \\ti++;j++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783827,
                "title": "python-by-recursion-ascii-property",
                "content": "Hint:\\n\\nall bad pair are with offset either +32 or -32 in ASCII code\\n\\n![image](https://assets.leetcode.com/users/images/ee77ed1e-468b-42c9-8304-cf894d90bb66_1597061856.1984293.png)\\n\\nASCII Code Table source:\\nhttp://www.cls-solutions.com/blog/?p=641\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        # initialized to \\'@\\' for dummy\\n        prev = \\'@\\'\\n        \\n        for idx, char in enumerate(s):\\n            \\n            if abs( ord(char)-ord(prev) ) == 32:\\n                \\n                # remove bad part and keep making remaining string good\\n                return self.makeGood(s[:idx-1] + s[idx+1:])\\n            \\n            prev = char\\n        \\n        # all good\\n        return s\\n```\\n\\n---\\n\\nReference:\\n[1] [Wiki: ASCII table](https://en.wikipedia.org/wiki/ASCII)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        # initialized to \\'@\\' for dummy\\n        prev = \\'@\\'\\n        \\n        for idx, char in enumerate(s):\\n            \\n            if abs( ord(char)-ord(prev) ) == 32:\\n                \\n                # remove bad part and keep making remaining string good\\n                return self.makeGood(s[:idx-1] + s[idx+1:])\\n            \\n            prev = char\\n        \\n        # all good\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780934,
                "title": "java-simple-o-n-time-o-1-space-no-extra-stack",
                "content": "```\\n    public String makeGood(String s) {\\n      if (s.length() <= 1) {\\n        return s;\\n      }\\n      StringBuilder sb = new StringBuilder();\\n      sb.append(s.charAt(0));\\n      for (int i = 1; i < s.length(); i++) {\\n        if (sb.length() > 0 && Math.abs(sb.charAt(sb.length() - 1) - s.charAt(i))==32) {\\n          sb.deleteCharAt(sb.length() - 1);\\n        } else {\\n          sb.append(s.charAt(i));\\n        }\\n      }\\n      return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public String makeGood(String s) {\\n      if (s.length() <= 1) {\\n        return s;\\n      }\\n      StringBuilder sb = new StringBuilder();\\n      sb.append(s.charAt(0));\\n      for (int i = 1; i < s.length(); i++) {\\n        if (sb.length() > 0 && Math.abs(sb.charAt(sb.length() - 1) - s.charAt(i))==32) {\\n          sb.deleteCharAt(sb.length() - 1);\\n        } else {\\n          sb.append(s.charAt(i));\\n        }\\n      }\\n      return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172903,
                "title": "c-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\nUsing string only and wothout stack\\n\\n# Approach\\n1. Create a new string and we will use it as a stack.\\n2. Check if string is not empty and it\\'s top and string\\'s current character\\'s difference is 32, If it is, then pop_back.\\n3. else, just push_back it in the string.\\n4. Return the string.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string str = \"\";\\n\\n        for(char ch : s){\\n            if( !str.empty() && (abs(str.back() - ch) == 32) ){\\n                str.pop_back();\\n            }else{\\n                str.push_back(ch);\\n            }\\n        }\\n\\n        return str;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string str = \"\";\\n\\n        for(char ch : s){\\n            if( !str.empty() && (abs(str.back() - ch) == 32) ){\\n                str.pop_back();\\n            }else{\\n                str.push_back(ch);\\n            }\\n        }\\n\\n        return str;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959377,
                "title": "java-stack-98-85-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        char[] c = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> stack = new Stack<>();\\n        for (char value : c) {\\n            if (!stack.isEmpty() && Math.abs(stack.peek() - value) == 32) stack.pop();\\n            else stack.push(value);\\n        }\\n        for (char ch : stack) {\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        char[] c = s.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> stack = new Stack<>();\\n        for (char value : c) {\\n            if (!stack.isEmpty() && Math.abs(stack.peek() - value) == 32) stack.pop();\\n            else stack.push(value);\\n        }\\n        for (char ch : stack) {\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812879,
                "title": "c-easy-solution-using-stack",
                "content": "# Approach\\n1) We know that \\'a\\' - \\'A\\' = 32, and is same for every alphabatic character\\n2) To make the string good,we have to eliminate adjacent characters that make the string bad.\\n\\n3) check if top element of stack+32 is equal to strings character at i location or char+32 is equal to top element of stack, in both the cases you have to pop out the element else push following character of string\\n\\n4) append stack elements in ans string and return the reverse of it.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string str) {\\n        stack<char>s;\\n        for(int i=0; i<str.length(); i++){\\n            if(s.size()==0){\\n                s.push(str[i]);\\n                continue;\\n            }\\n            if(s.top()+32==str[i] || str[i]+32 == s.top()){\\n                s.pop();\\n            }else{\\n                s.push(str[i]);\\n            }\\n        }\\n        string ans = \"\";\\n        while(s.size()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string str) {\\n        stack<char>s;\\n        for(int i=0; i<str.length(); i++){\\n            if(s.size()==0){\\n                s.push(str[i]);\\n                continue;\\n            }\\n            if(s.top()+32==str[i] || str[i]+32 == s.top()){\\n                s.pop();\\n            }else{\\n                s.push(str[i]);\\n            }\\n        }\\n        string ans = \"\";\\n        while(s.size()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794692,
                "title": "one-pass-recursive-two-pointer-approach-o-n",
                "content": "This is a very easy and interesting problem. Using StringBuilder in java makes the code easier.\\n\\n```\\nclass Solution {\\n    StringBuilder sb;\\n    public String makeGood(String s) {\\n        // string builder provides good control over string modification.\\n        sb = new StringBuilder(s);\\n        recurMakeGood(0);\\n        return sb.toString();\\n    }\\n\\n    void recurMakeGood(int index){\\n        if(index<0)\\n            index=0;\\n        if(sb.length()<2)\\n            return;\\n        if(index==sb.length()-1){\\n            return;\\n        }\\n        char c1 = sb.charAt(index);\\n        char c2 = sb.charAt(index+1);\\n        if(areTheyPair(c1, c2)){\\n            sb.deleteCharAt(index);\\n            // length is reduced by one..\\n            // so index+1 element will now point to index\\n            sb.deleteCharAt(index);\\n            // two data are deleted, need to check next data with previous one so reduce by 2\\n            // later we are incrementing this by one\\n            index-=2;\\n        }\\n        // pointing to the next element\\n        recurMakeGood(index+1);\\n    }\\n\\n    boolean areTheyPair(char c1, char c2){\\n        return areTheypairInside(c1,c2) || areTheypairInside(c2, c1);\\n    }\\n\\n    boolean areTheypairInside(char c1, char c2){\\n        return c1-\\'a\\' == c2-\\'A\\';\\n    }\\n}\\n```\\n\\n# Here\\'s the prove:\\n\\n![image](https://assets.leetcode.com/users/images/b7789852-003b-4046-a4e5-c9d4a8fcdff4_1667945552.7049477.png)\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String makeGood(String s) {\\n        // string builder provides good control over string modification.\\n        sb = new StringBuilder(s);\\n        recurMakeGood(0);\\n        return sb.toString();\\n    }\\n\\n    void recurMakeGood(int index){\\n        if(index<0)\\n            index=0;\\n        if(sb.length()<2)\\n            return;\\n        if(index==sb.length()-1){\\n            return;\\n        }\\n        char c1 = sb.charAt(index);\\n        char c2 = sb.charAt(index+1);\\n        if(areTheyPair(c1, c2)){\\n            sb.deleteCharAt(index);\\n            // length is reduced by one..\\n            // so index+1 element will now point to index\\n            sb.deleteCharAt(index);\\n            // two data are deleted, need to check next data with previous one so reduce by 2\\n            // later we are incrementing this by one\\n            index-=2;\\n        }\\n        // pointing to the next element\\n        recurMakeGood(index+1);\\n    }\\n\\n    boolean areTheyPair(char c1, char c2){\\n        return areTheypairInside(c1,c2) || areTheypairInside(c2, c1);\\n    }\\n\\n    boolean areTheypairInside(char c1, char c2){\\n        return c1-\\'a\\' == c2-\\'A\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794610,
                "title": "python-3-6-lines-stack-w-explanation-t-m-95-82",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        stack = deque()\\n\\n        for ch in s:\\n            \\n            if stack and abs(ord(stack[-1])-ord(ch)) == 32: # <- check whether two successive chars in s\\n                                                            #    are corresponding upper/lowercase letters\\n            \\n                stack.pop()                                 # <- if so, pop the stack and ignore ch, so\\n                                                            #    neither will be on the stack hereafter \\n\\n            else: stack.append(ch)                          # <-- if not, put ch on the stack to compare\\n                                                            #     with next ch in s\\n\\n        return \\'\\'.join(stack)                               # <-- remaining stack is the solution\\n```\\n[https://leetcode.com/submissions/detail/637453076/](http://)\\n\\nI could be wrong, but I think it\\'s O(n) / O(n).",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        \\n        stack = deque()\\n\\n        for ch in s:\\n            \\n            if stack and abs(ord(stack[-1])-ord(ch)) == 32: # <- check whether two successive chars in s\\n                                                            #    are corresponding upper/lowercase letters\\n            \\n                stack.pop()                                 # <- if so, pop the stack and ignore ch, so\\n                                                            #    neither will be on the stack hereafter \\n\\n            else: stack.append(ch)                          # <-- if not, put ch on the stack to compare\\n                                                            #     with next ch in s\\n\\n        return \\'\\'.join(stack)                               # <-- remaining stack is the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793717,
                "title": "java-easy-to-understand-o-n-solution",
                "content": "\\n# Approach\\nKeep checking the difference between the last character in result and the `ith` character. The difference between the ASCII value of lower and upper case of same character is 32. \\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n         // create result with empty string\\n        StringBuilder res = new StringBuilder();\\n        for (char ch : s.toCharArray()) {\\n            int resLength = res.length();\\n            // if the difference between the ith character of s\\n            // and last character in result is 32\\n            // then remove the last character from result\\n            // otherwise append the latest character to result\\n            if (resLength!=0 && Math.abs(res.charAt(resLength-1) - ch) == 32) {\\n                res.deleteCharAt(resLength - 1);\\n            } else {\\n                res.append(ch);\\n            }\\n\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n         // create result with empty string\\n        StringBuilder res = new StringBuilder();\\n        for (char ch : s.toCharArray()) {\\n            int resLength = res.length();\\n            // if the difference between the ith character of s\\n            // and last character in result is 32\\n            // then remove the last character from result\\n            // otherwise append the latest character to result\\n            if (resLength!=0 && Math.abs(res.charAt(resLength-1) - ch) == 32) {\\n                res.deleteCharAt(resLength - 1);\\n            } else {\\n                res.append(ch);\\n            }\\n\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793502,
                "title": "java-simple-solution-with-the-following-complexities",
                "content": "Time complexity : O(n)\\nSpace complexity : O(1)\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuffer sb = new StringBuffer(s);\\n        for (int i = sb.length() - 1; i >= 0; i--) {\\n            if (i == sb.length() - 1)\\n                continue;\\n            char c1 = sb.charAt(i), c2 = sb.charAt(i + 1);\\n            if (sameLetterDifferentCase(c1, c2)) {\\n                sb.deleteCharAt(i + 1);\\n                sb.deleteCharAt(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    public boolean sameLetterDifferentCase(char letter1, char letter2) {\\n        return Math.abs(letter1 - letter2) == \\'a\\' - \\'A\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuffer sb = new StringBuffer(s);\\n        for (int i = sb.length() - 1; i >= 0; i--) {\\n            if (i == sb.length() - 1)\\n                continue;\\n            char c1 = sb.charAt(i), c2 = sb.charAt(i + 1);\\n            if (sameLetterDifferentCase(c1, c2)) {\\n                sb.deleteCharAt(i + 1);\\n                sb.deleteCharAt(i);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\n    public boolean sameLetterDifferentCase(char letter1, char letter2) {\\n        return Math.abs(letter1 - letter2) == \\'a\\' - \\'A\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793440,
                "title": "c-7-line-super-easy-solution-w-comments",
                "content": "# Intuition\\nErase adjucent same lower case and upper case laters every time by setting counter to 0.\\n\\n# Approach\\n1. Loop through s.\\n2. If any adjuscent characters are similar lower case and upper case characters are same, erase them.\\n3. Set counter to -1, as we are increasing the counter every time in the loop.\\n4. At the end return the modified s.\\n\\n# Complexity\\n- Time complexity:\\nBeats 82.74%\\n\\n- Space complexity:\\nBeats 97.69%\\n\\n**Please upvote** if you like the solution.\\nComments to make the solution bettter are welcome.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        for(int i = 0; i < s.length(); ++i)\\n        {\\n            int len = s.length();\\n            if(s[i] == s[i+1] + 32 || s[i] + 32 == s[i+1])\\n                s.erase(i, 2);\\n            if(len != s.length())\\n                i = -1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        for(int i = 0; i < s.length(); ++i)\\n        {\\n            int len = s.length();\\n            if(s[i] == s[i+1] + 32 || s[i] + 32 == s[i+1])\\n                s.erase(i, 2);\\n            if(len != s.length())\\n                i = -1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793273,
                "title": "easy-explained-c",
                "content": "Here are the following 2 approaches to the question:\\n\\n## 1) modifying string in place\\n``` C++ []\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int i{0}, l=s.length()-1;\\n\\n        // we will continue the process as long as the current index within the length of the string\\n        while (i<l) {\\n            // if the differnce between current and next character is 32, then either of them is lower and upper\\n            if (abs(s[i]-s[i+1])==32) {\\n                // modify s in place adding it\\'s part before current index and after the to be removed part\\n                s = s.substr(0,i) + s.substr(i+2);\\n                // length decreased by 2\\n                l-=2;\\n                // now that we have moved the character at index we need to check whether the \\n                // previous character matches with nex character so we decrease i\\n                if (i>0) i--;\\n            }\\n            else i++;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n## 2) creating a new string and adding characters to it one by one\\n``` C++ []\\nclass Solution \\n{\\npublic:\\n    string makeGood(string s) \\n    {\\n        string t;\\n\\n        for (char x:s) {\\n            // if the previous character in string t match the current character\\n            // we remove the previous character and don\\'t add the current one\\n            if (!t.empty() && abs(t.back()-x)==32) t.pop_back();\\n            // if the string is empty or if the character doesn\\'t match the existing previous\\n            // character we add it to string t\\n            else t.push_back(x);\\n        }\\n\\n        return t;\\n    }\\n};\\n```\\n\\n*Upvote the solution if you liked it*",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int i{0}, l=s.length()-1;\\n\\n        // we will continue the process as long as the current index within the length of the string\\n        while (i<l) {\\n            // if the differnce between current and next character is 32, then either of them is lower and upper\\n            if (abs(s[i]-s[i+1])==32) {\\n                // modify s in place adding it\\'s part before current index and after the to be removed part\\n                s = s.substr(0,i) + s.substr(i+2);\\n                // length decreased by 2\\n                l-=2;\\n                // now that we have moved the character at index we need to check whether the \\n                // previous character matches with nex character so we decrease i\\n                if (i>0) i--;\\n            }\\n            else i++;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\n``` C++ []\\nclass Solution \\n{\\npublic:\\n    string makeGood(string s) \\n    {\\n        string t;\\n\\n        for (char x:s) {\\n            // if the previous character in string t match the current character\\n            // we remove the previous character and don\\'t add the current one\\n            if (!t.empty() && abs(t.back()-x)==32) t.pop_back();\\n            // if the string is empty or if the character doesn\\'t match the existing previous\\n            // character we add it to string t\\n            else t.push_back(x);\\n        }\\n\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793163,
                "title": "c-simple-solution-o-n-easy-to-understand-few-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n = s.size()-1;\\n        for(int i = 0 ; i < n ; i++) {\\n            if(abs(s[i] -s [i+1])==32 ){\\n                s.erase(i,2);\\n                i=-1;    n-=2;\\n            } }\\n        return s;\\n    }\\n};\\n\\n***if you found its useful and easy to understand then please upvote me ***\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n = s.size()-1;\\n        for(int i = 0 ; i < n ; i++) {\\n            if(abs(s[i] -s [i+1])==32 ){\\n                s.erase(i,2);\\n                i=-1;    n-=2;\\n            } }\\n        return s;\\n    }\\n};\\n\\n***if you found its useful and easy to understand then please upvote me ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792665,
                "title": "c-vector-beats-82-sol",
                "content": "# Intuition\\n<!-- it can be felt that we need to use some extra space to store our result and to modify the string using the stack was a great option -->\\nIt can be felt that we need to use some extra space to store our result and to modify the string using the stack was a great option.\\n\\n# Complexity\\n- Time complexity:\\no(n) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.length()-1,i=0;\\n        stack<char> chk;\\n        string ans=\"\";\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(chk.empty())\\n            {\\n                chk.push(s[i]);\\n            }\\n            else{  \\n                   if(s[i]>=97&&s[i]<=122)\\n                   {\\n                       if(s[i]-chk.top()==32)\\n                       chk.pop();\\n                       else{chk.push(s[i]);}\\n                   }\\n                   else if(s[i]>=65&&s[i]<=90)\\n                   {\\n                       if(chk.top()-s[i]==32)\\n                       chk.pop();\\n                       else{chk.push(s[i]);}\\n                   }\\n\\n            }\\n        }\\n        while(!chk.empty())\\n        {\\n        ans.push_back(chk.top());\\n        chk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int n=s.length()-1,i=0;\\n        stack<char> chk;\\n        string ans=\"\";\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(chk.empty())\\n            {\\n                chk.push(s[i]);\\n            }\\n            else{  \\n                   if(s[i]>=97&&s[i]<=122)\\n                   {\\n                       if(s[i]-chk.top()==32)\\n                       chk.pop();\\n                       else{chk.push(s[i]);}\\n                   }\\n                   else if(s[i]>=65&&s[i]<=90)\\n                   {\\n                       if(chk.top()-s[i]==32)\\n                       chk.pop();\\n                       else{chk.push(s[i]);}\\n                   }\\n\\n            }\\n        }\\n        while(!chk.empty())\\n        {\\n        ans.push_back(chk.top());\\n        chk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792284,
                "title": "java-iterative-easiest-no-stack-no-stringbuilder",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to traverse the whole string keeping in mind that we go on eliminating the bad string . \\nIn general scenario , if we just use a for loop for traversing, which checks whether character at index i and index i+1 do not form a bad string , this will work for some cases . But still there might be some bad strings left.\\n\\nConsider the case where String s =\"AbBacd\" , here according to our above approach , only \"bB\" will be eliminated and the loop will end , because in a single pass it found only one bad string.The String will become s=\"Aacd\".\\n\\nHere there is a **imp observation** that if we find any bad string and we eliminate it , we need to **check again if there can be a possible case where after eliminating this bad string ,the string formed contains a bad string or not** . \\nSo for this we need to recheck the string from **index , i= i-1** because the character at index **i-1** might form a bad string with character **i+2** as characters at **i** and **i+1** have been removed.\\nTo recheck we update the value of **index i to i-1 when i>0 else update i to 0.** Used MAX function for this.\\n**This was the main part.**\\n\\nThere is no need to use any stack or Stringbuilder to store the new string , we are going to use the given string only for this.\\nConsider , we eliminated characters at i and i+1. Now we update the string using substring function. **Take substring from 0 to i-1 and i+2 to s.length.**\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int i=0;\\n// loop until strings gets empty or index does not exceed length-1.\\n        while(s!=\"\" && i<s.length()-1)\\n        {\\n// to get the ASCII values of characters as difference between values of same characters is 32.\\n            int a=(int) s.charAt(i);\\n            int b=(int) s.charAt(i+1);\\n            if(Math.abs(a-b)==32)\\n            {\\n                s=s.substring(0,i)+s.substring(i+2,s.length());\\n                i=Math.max(i-1,0);\\n            }\\n            else i++;\\n        }\\n        return s;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int i=0;\\n// loop until strings gets empty or index does not exceed length-1.\\n        while(s!=\"\" && i<s.length()-1)\\n        {\\n// to get the ASCII values of characters as difference between values of same characters is 32.\\n            int a=(int) s.charAt(i);\\n            int b=(int) s.charAt(i+1);\\n            if(Math.abs(a-b)==32)\\n            {\\n                s=s.substring(0,i)+s.substring(i+2,s.length());\\n                i=Math.max(i-1,0);\\n            }\\n            else i++;\\n        }\\n        return s;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792208,
                "title": "make-the-string-great",
                "content": "The code is very simple and comments are added for your understanding.\\n**Upvote if you like the solution. \\uD83D\\uDE09**\\n\\n```\\nclass Solution {\\n    \\n    //\\uD83D\\uDCA1 The logic behind using stack is for every ith charcater we want to check i+1th character and whenever some iterator depends on another iterator there is a possibility that we can optimize this using stack\\n    //watch first video of stack of Aditya Verma for better understanding of where to use Stack.\\n    \\n    public String makeGood(String s) {\\n        //First create a stack to store the good characters\\n        Stack<Character>stack=new Stack<>();\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            //insert the characters from the last index of the string \\n            //\\uD83D\\uDCA1We are inserting from last because we want to add all the stack characters which is part of good string.. and stack is LIFO so we won\\'t need to reverse the final string..\\n            \\n            if(!stack.isEmpty()&&Math.abs(stack.peek()-s.charAt(i))==32){\\n                //here we first check if stack is not empty and top element of stack difference with current character is 32\\n                // \\uD83D\\uDCA1 here we are checking difference as 32 because difference of uppercase and lowercase of same alphabet is 32\\n                //if it is then we need to pop  as it\\'s making the pair of => eE oe Ee\\n                stack.pop();\\n            }else{\\n                //else if stack is empty or they are not making pairs of eE and Ee\\n                //then we can simply insert the character where we are standing as it will be the part of our good string \\uD83D\\uDE09\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        //at the end stack contains all the characters good string should possess by removing bad pairs.\\uD83E\\uDD29\\n        \\n        //created a empty string to store our answer \\n        String str=\"\";\\n        \\n        //till stack is not empty insert it in the string \\n        while(!stack.isEmpty()){\\n            str+=stack.pop();\\n        }\\n        \\n        //at last return the string.\\n        return str;\\n    }\\n    \\n}\\n```\\n\\nTime Complexity :- **O(N)**  => Because we are traversing each character of string once.\\uD83E\\uDDD0\\nSpace Complexity :- **O(N)** => Because Stack can hold all the characters of string (at worst case when there is no bad pairs \\uD83D\\uDE08).",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //\\uD83D\\uDCA1 The logic behind using stack is for every ith charcater we want to check i+1th character and whenever some iterator depends on another iterator there is a possibility that we can optimize this using stack\\n    //watch first video of stack of Aditya Verma for better understanding of where to use Stack.\\n    \\n    public String makeGood(String s) {\\n        //First create a stack to store the good characters\\n        Stack<Character>stack=new Stack<>();\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            //insert the characters from the last index of the string \\n            //\\uD83D\\uDCA1We are inserting from last because we want to add all the stack characters which is part of good string.. and stack is LIFO so we won\\'t need to reverse the final string..\\n            \\n            if(!stack.isEmpty()&&Math.abs(stack.peek()-s.charAt(i))==32){\\n                //here we first check if stack is not empty and top element of stack difference with current character is 32\\n                // \\uD83D\\uDCA1 here we are checking difference as 32 because difference of uppercase and lowercase of same alphabet is 32\\n                //if it is then we need to pop  as it\\'s making the pair of => eE oe Ee\\n                stack.pop();\\n            }else{\\n                //else if stack is empty or they are not making pairs of eE and Ee\\n                //then we can simply insert the character where we are standing as it will be the part of our good string \\uD83D\\uDE09\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        //at the end stack contains all the characters good string should possess by removing bad pairs.\\uD83E\\uDD29\\n        \\n        //created a empty string to store our answer \\n        String str=\"\";\\n        \\n        //till stack is not empty insert it in the string \\n        while(!stack.isEmpty()){\\n            str+=stack.pop();\\n        }\\n        \\n        //at last return the string.\\n        return str;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792158,
                "title": "c-easy-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur task is to create a string which is good, to make a string good we need to consider\\nthis things first\\n* if `last_character == curr_character` like `a, a` then append it to data structure.\\n* if `last_character != curr_chracter` like `(a, b) or (a, A)` then\\n        * check `lower(last_character) == lower(curr_character)` `(a,A)` then pop_back from data structure.\\n        * else append to the data structure.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use deque here for sake of simplicity.\\n* Create a `deque of characters`.\\n* Iterate from start to end of the string.\\n* Check is `deque is empty` then simply append to it.\\n* else check `if(deque.back() == curr_char)` then append that character.\\n* else check `if(lower(deque.back()) != lower(curr_char))` then append that character.\\n* else pop_back from the character.\\n* After n iterations, create a string and append all characters of deque in it.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n***where `n` is the size of the string.***\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n***where `n` is the size of the string.***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(char a, char b) {\\n        if(a == b) {\\n            return true;\\n        }\\n        return tolower(a) != tolower(b); \\n    }\\n\\n    string makeGood(string s) {\\n        deque<char> st;\\n\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            if (st.empty()) {\\n                st.push_back(s[i]);\\n            }\\n            else if(check(st.back(), s[i])) {\\n                st.push_back(s[i]);\\n            } else {\\n                st.pop_back();\\n            }\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty()) {\\n            ans.push_back(st.front());\\n            st.pop_front();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char a, char b) {\\n        if(a == b) {\\n            return true;\\n        }\\n        return tolower(a) != tolower(b); \\n    }\\n\\n    string makeGood(string s) {\\n        deque<char> st;\\n\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            if (st.empty()) {\\n                st.push_back(s[i]);\\n            }\\n            else if(check(st.back(), s[i])) {\\n                st.push_back(s[i]);\\n            } else {\\n                st.pop_back();\\n            }\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty()) {\\n            ans.push_back(st.front());\\n            st.pop_front();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791985,
                "title": "java-easy-to-understand-solution-recursion-stack-approach-also",
                "content": "*Upvote if you like the solution!!!*\\n**Here\\'s my accepted basic Java code [O(n^2) +O(n) ]**\\n```\\nclass Solution {\\n    \\n    public static int ContainUpperCase(String text) {\\n       int count=0;\\n       for(char c:text.toCharArray()){\\n           if(Character.isUpperCase(c)) count++;\\n       }\\n        return count;\\n}\\n    \\n    public String makeGood(String s) {\\n        int t = ContainUpperCase(s);\\n        while(t--!=0)\\n        s= helper(s);\\n        return s;\\n    }\\n    String helper(String s){\\n        char [] c = s.toCharArray();\\n        String ans = \"\";\\n        for(int i=0;i<c.length;i++){\\n            if(Character.isUpperCase(c[i])){\\n                if(i>0 && c[i-1]==(\\'a\\'+(c[i]-\\'A\\'))) \\n                    {c[i]=\\'1\\';c[i-1]=\\'1\\';}\\n                else if(i<c.length-1 && c[i+1]==(\\'a\\'+(c[i]-\\'A\\'))) \\n                    {c[i]=\\'1\\';c[i+1]=\\'1\\';}\\n            }\\n        }\\n        \\n        for(int i=0;i<c.length;i++){\\n            if(c[i]==\\'1\\')continue;\\n            ans+=c[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Here Recusive Approch[O(n^2) ] :**\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==(s.charAt(i+1)^32))\\n                //recursive call passing string removing pair found\\n                return makeGood(s.substring(0,i)+s.substring(i+2));\\n        }\\n        //if we didn\\'t found a pair, we\\'ll return s\\n        return s;\\n    }\\n}\\n```\\n\\n**But i found Stack approch best here\\'s the code [O(n)] :**\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        // Use stack to store the visited characters.\\n        Stack<Character> stack = new Stack<>();\\n        for(char c:s.toCharArray()){\\n            /* If the current character make a pair with the last character in the stack,\\n             remove both of them. Otherwise, we the add current character to stack.*/\\n            if(!stack.isEmpty() && c==(stack.lastElement()^32)){\\n                stack.pop();\\n            }\\n            else\\n                stack.add(c);\\n            \\n        }\\n        \\n        //Just converting all characters left in stack to string\\n        StringBuilder ans = new StringBuilder();\\n        for(char c:stack){\\n            ans.append(c);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int ContainUpperCase(String text) {\\n       int count=0;\\n       for(char c:text.toCharArray()){\\n           if(Character.isUpperCase(c)) count++;\\n       }\\n        return count;\\n}\\n    \\n    public String makeGood(String s) {\\n        int t = ContainUpperCase(s);\\n        while(t--!=0)\\n        s= helper(s);\\n        return s;\\n    }\\n    String helper(String s){\\n        char [] c = s.toCharArray();\\n        String ans = \"\";\\n        for(int i=0;i<c.length;i++){\\n            if(Character.isUpperCase(c[i])){\\n                if(i>0 && c[i-1]==(\\'a\\'+(c[i]-\\'A\\'))) \\n                    {c[i]=\\'1\\';c[i-1]=\\'1\\';}\\n                else if(i<c.length-1 && c[i+1]==(\\'a\\'+(c[i]-\\'A\\'))) \\n                    {c[i]=\\'1\\';c[i+1]=\\'1\\';}\\n            }\\n        }\\n        \\n        for(int i=0;i<c.length;i++){\\n            if(c[i]==\\'1\\')continue;\\n            ans+=c[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==(s.charAt(i+1)^32))\\n                //recursive call passing string removing pair found\\n                return makeGood(s.substring(0,i)+s.substring(i+2));\\n        }\\n        //if we didn\\'t found a pair, we\\'ll return s\\n        return s;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        // Use stack to store the visited characters.\\n        Stack<Character> stack = new Stack<>();\\n        for(char c:s.toCharArray()){\\n            /* If the current character make a pair with the last character in the stack,\\n             remove both of them. Otherwise, we the add current character to stack.*/\\n            if(!stack.isEmpty() && c==(stack.lastElement()^32)){\\n                stack.pop();\\n            }\\n            else\\n                stack.add(c);\\n            \\n        }\\n        \\n        //Just converting all characters left in stack to string\\n        StringBuilder ans = new StringBuilder();\\n        for(char c:stack){\\n            ans.append(c);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791734,
                "title": "stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Data Structure\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n\\n            if((!st.empty())  && abs(st.top()-s[i])==(\\'a\\'-\\'A\\')){\\n                st.pop();\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n\\n            if((!st.empty())  && abs(st.top()-s[i])==(\\'a\\'-\\'A\\')){\\n                st.pop();\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791557,
                "title": "c-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        if(s.size()==1 || s==\"\")\\n        {\\n           return s;\\n        }\\n        auto it=s.begin();\\n        while(it<s.end() && s.size()>0)\\n        {\\n           if((abs(*it - *(it+1))==32))\\n           {\\n               s.erase(it,it+2);\\n               it=s.begin();\\n           }\\n           else\\n           {\\n             it++;\\n           }\\n           \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        if(s.size()==1 || s==\"\")\\n        {\\n           return s;\\n        }\\n        auto it=s.begin();\\n        while(it<s.end() && s.size()>0)\\n        {\\n           if((abs(*it - *(it+1))==32))\\n           {\\n               s.erase(it,it+2);\\n               it=s.begin();\\n           }\\n           else\\n           {\\n             it++;\\n           }\\n           \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791434,
                "title": "c-using-stack-easy-and-simple-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Using stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(auto i: s){\\n            if(st.empty()){\\n                st.push(i);\\n            }\\n            else{\\n                if(abs(i-st.top()) == 32){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(i);\\n                }\\n            }\\n            \\n        }\\n        string ans;\\n        /*\\n        //instead doing this below approach can also be done.\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        */\\n\\n    while (!st.empty()) {\\n        ans = st.top() + ans;\\n        st.pop();\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(auto i: s){\\n            if(st.empty()){\\n                st.push(i);\\n            }\\n            else{\\n                if(abs(i-st.top()) == 32){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(i);\\n                }\\n            }\\n            \\n        }\\n        string ans;\\n        /*\\n        //instead doing this below approach can also be done.\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        */\\n\\n    while (!st.empty()) {\\n        ans = st.top() + ans;\\n        st.pop();\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791378,
                "title": "simple-well-explained-stack-implemented-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStack is Excellent in getting the last probable element in string after deleting the adjacent characters\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>`!stack.isEmpty() && Math.abs(stack.peek()-ch)==(\\'a\\'-\\'A\\')` this code here checks if the stack is empty, then it just pushes the next character in the stack, but if its there then the absolute difference between capital letter and small letter of same character must be equal to the absolute difference between `a` and `A`.\\n\\n>In the final lines, poping from the stack and directly storing in string may result in reversed string. Thats when the best way to reverse the string would be inserting the elements in the string in the reverse order.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(!stack.isEmpty() && Math.abs(stack.peek()-ch)==(\\'a\\'-\\'A\\'))\\n                stack.pop();\\n            else stack.push(ch);\\n        }\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(!stack.isEmpty() && Math.abs(stack.peek()-ch)==(\\'a\\'-\\'A\\'))\\n                stack.pop();\\n            else stack.push(ch);\\n        }\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791209,
                "title": "c-clean-o-n-solution-using-stack-0-ms-runtime",
                "content": "We would be using the fact that the difference between the ascii values of same alphabets in capital ans small letters is 32.\\ni.e A - a=32 && a- A=32;\\n\\nSo, we will keep popping up the top element of the stack if we the current element and top of the stack has an absolute diffrenece of 32.\\n\\nHere is the C++ code-\\n\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()) st.push(s[i]);\\n            else{\\n                int a=abs(s[i]-st.top());\\n                if(a==32) st.pop();\\n                else st.push(s[i]);\\n        }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        int ss=0,e=ans.size()-1;\\n        while(ss<e){\\n            swap(ans[ss],ans[e]);\\n            ss++;\\n            e--;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nDo upvote if you understood the solution and suggestions are welcome.",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()) st.push(s[i]);\\n            else{\\n                int a=abs(s[i]-st.top());\\n                if(a==32) st.pop();\\n                else st.push(s[i]);\\n        }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        int ss=0,e=ans.size()-1;\\n        while(ss<e){\\n            swap(ans[ss],ans[e]);\\n            ss++;\\n            e--;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790978,
                "title": "java-detailed-solution-using-stack-o-n",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (!stack.isEmpty() && Math.abs(c - stack.peek()) == 32) {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (char c : stack) ans.append(c);\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (!stack.isEmpty() && Math.abs(c - stack.peek()) == 32) {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (char c : stack) ans.append(c);\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790913,
                "title": "c-stack-two-easy-approaches-explained",
                "content": "**Approach 1:**\\n\\n```\\nclass Solution {\\npublic:\\n    //app 1: using stack [intuitive approach]\\n    string makeGood(string s) {\\n        stack<char> st;\\n        \\n        for(char &ch: s){\\n            if(st.empty()){\\n                st.push(ch);\\n            }\\n            //if cur char is same as top of stk but with opposite case ==> pop it\\n\\t\\t\\t//difference between the any lowercase and uppercase alphabet is 32\\n            else if(abs(ch - st.top()) == 32 ){\\n                st.pop();\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2:**\\n\\n```\\nclass Solution {\\npublic:\\n    //app 2: using string as stack\\n    string makeGood(string s) {\\n        string ans;\\n        \\n        for(char &ch: s){\\n            if(ans.length() == 0){\\n                ans += ch;\\n            }\\n            //difference between the any lowercase and uppercase alphabet is 32\\n            else if(abs(ch - ans.back()) == 32){\\n                ans.pop_back();\\n            }\\n            \\n            else{\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nDo upvote the post, if it\\'s been any help to you! \\uD83D\\uDE80",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //app 1: using stack [intuitive approach]\\n    string makeGood(string s) {\\n        stack<char> st;\\n        \\n        for(char &ch: s){\\n            if(st.empty()){\\n                st.push(ch);\\n            }\\n            //if cur char is same as top of stk but with opposite case ==> pop it\\n\\t\\t\\t//difference between the any lowercase and uppercase alphabet is 32\\n            else if(abs(ch - st.top()) == 32 ){\\n                st.pop();\\n            }\\n            else{\\n                st.push(ch);\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //app 2: using string as stack\\n    string makeGood(string s) {\\n        string ans;\\n        \\n        for(char &ch: s){\\n            if(ans.length() == 0){\\n                ans += ch;\\n            }\\n            //difference between the any lowercase and uppercase alphabet is 32\\n            else if(abs(ch - ans.back()) == 32){\\n                ans.pop_back();\\n            }\\n            \\n            else{\\n                ans += ch;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790896,
                "title": "rust-simple-stack-solution",
                "content": "```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        if s == \"\" {\\n            return s;\\n        }\\n        \\n        let mut stack = VecDeque::<char>::new();\\n        let s = s.chars().collect::<Vec<char>>();\\n        \\n        let last = s[0];\\n        stack.push_back(s[0]);\\n        \\n        for i in 1..s.len() {\\n            if stack.len() > 0 {\\n                let last = stack.pop_back().unwrap();\\n                let is_eq = match last > s[i] {\\n                    true => {\\n                        (last as u8) - (s[i] as u8) == 32\\n                    },\\n                    false => {\\n                        (s[i] as u8) - (last as u8) == 32\\n                    }\\n                };\\n\\n                if is_eq {\\n                    continue;\\n                }\\n                \\n                stack.push_back(last);\\n            }\\n            \\n            stack.push_back(s[i]);\\n            \\n        }\\n        \\n        stack.into_iter().collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        if s == \"\" {\\n            return s;\\n        }\\n        \\n        let mut stack = VecDeque::<char>::new();\\n        let s = s.chars().collect::<Vec<char>>();\\n        \\n        let last = s[0];\\n        stack.push_back(s[0]);\\n        \\n        for i in 1..s.len() {\\n            if stack.len() > 0 {\\n                let last = stack.pop_back().unwrap();\\n                let is_eq = match last > s[i] {\\n                    true => {\\n                        (last as u8) - (s[i] as u8) == 32\\n                    },\\n                    false => {\\n                        (s[i] as u8) - (last as u8) == 32\\n                    }\\n                };\\n\\n                if is_eq {\\n                    continue;\\n                }\\n                \\n                stack.push_back(last);\\n            }\\n            \\n            stack.push_back(s[i]);\\n            \\n        }\\n        \\n        stack.into_iter().collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2790886,
                "title": "most-easy-c-solution-beginner-friendly",
                "content": "**Please Upvote if you like the Solution**\\n\\nclass Solution {\\npublic:\\n    \\n\\tstring makeGood(string s) {\\n        string ans = \"\";                    // String for storing result\\n        for(auto i : s) {                    \\n            if(ans.size()!= 0) {\\n                char temp = ans.back();\\n                char check = i;\\n                if((temp-\\'a\\' == check-\\'A\\') ||(check - \\'a\\' == temp - \\'A\\')) {     // checking for adjacent element if \\n                                                                                // such element is found then pop back last inserted\\n                                                                                // char from \\'ans\\' else push_back the current char.\\n                    ans.pop_back();\\n                } else {\\n                    ans += i;\\n                }\\n            } else {\\n                ans += i;                   // if \\'ans\\' string is empty then place the \\n                                            // currently visiting character in the \\'ans\\' string\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tstring makeGood(string s) {\\n        string ans = \"\";                    // String for storing result\\n        for(auto i : s) {                    \\n            if(ans.size()!= 0) {\\n                char temp = ans.back();\\n                char check = i;\\n                if((temp-\\'a\\' == check-\\'A\\') ||(check - \\'a\\' == temp - \\'A\\')) {     // checking for adjacent element if \\n                                                                                // such element is found then pop back last inserted\\n                                                                                // char from \\'ans\\' else push_back the current char.\\n                    ans.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1637899,
                "title": "i-can-t-make-it-more-easy-with-and-without-stack",
                "content": "### With stack\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string res;\\n        for(int i=0; i<s.size(); i++) {\\n            if(!res.empty() &&  abs(s[i] - res.back()) == 32 ) {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(s[i]);\\n            }   \\n        }\\n        return res;\\n    }\\n};\\n```\\n### Without Stack\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int j=0;\\n        for(int i=0; i<s.size(); i++) {\\n            \\n            if(j>0 &&  abs(s[i] - s[j-1]) == 32 ) {\\n                j--;\\n            }\\n            else {\\n                s[j]=s[i];\\n                j++;\\n            }   \\n\\n        }\\n        return s.substr(0,j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string res;\\n        for(int i=0; i<s.size(); i++) {\\n            if(!res.empty() &&  abs(s[i] - res.back()) == 32 ) {\\n                res.pop_back();\\n            }\\n            else {\\n                res.push_back(s[i]);\\n            }   \\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int j=0;\\n        for(int i=0; i<s.size(); i++) {\\n            \\n            if(j>0 &&  abs(s[i] - s[j-1]) == 32 ) {\\n                j--;\\n            }\\n            else {\\n                s[j]=s[i];\\n                j++;\\n            }   \\n\\n        }\\n        return s.substr(0,j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939965,
                "title": "java-simple-o-n-solution",
                "content": "```\\npublic String makeGood(String s) {\\n\\tif (s == null || s.length() < 2)\\n\\t\\treturn s;\\n\\n\\tStack<Character> st= new Stack<>();\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (st.isEmpty())\\n\\t\\t\\tst.push(c);\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(c-st.peek()) != 32)\\n\\t\\t\\t\\tst.push(c);\\n\\t\\t\\telse\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tStringBuilder sb= new StringBuilder();\\n\\tfor(char s1 : st){\\n\\t\\tsb.append(s1);\\n\\t}\\n\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String makeGood(String s) {\\n\\tif (s == null || s.length() < 2)\\n\\t\\treturn s;\\n\\n\\tStack<Character> st= new Stack<>();\\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (st.isEmpty())\\n\\t\\t\\tst.push(c);\\n\\t\\telse {\\n\\t\\t\\tif (Math.abs(c-st.peek()) != 32)\\n\\t\\t\\t\\tst.push(c);\\n\\t\\t\\telse\\n\\t\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tStringBuilder sb= new StringBuilder();\\n\\tfor(char s1 : st){\\n\\t\\tsb.append(s1);\\n\\t}\\n\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906273,
                "title": "python-4-lines-97-faster-and-100-memory",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        sol = []\\n        for el in s:\\n            if sol and el == sol[-1].swapcase(): sol.pop()\\n            else: sol.append(el)\\n        return \\'\\'.join(sol)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        sol = []\\n        for el in s:\\n            if sol and el == sol[-1].swapcase(): sol.pop()\\n            else: sol.append(el)\\n        return \\'\\'.join(sol)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864200,
                "title": "python-beats-99-5-and-simple-solution-using-stack",
                "content": "1) Define a stack to keep track of the results\\n2) Iterate over the string \\n3) For each letter, perfrom a case sensitive comparison against the last item in the stack if it exists\\n4) Add/remove an item from the result stack based on the comparison\\n\\n```\\n    def makeGood(self, s: str) -> str:\\n        stack = list()\\n        for c in s:\\n            if stack and stack[-1].lower() == c.lower():\\n                if stack[-1] == c:\\n                    stack.append(c)\\n                else:\\n                    stack.pop()\\n            else:\\n                stack.append(c)\\n        return \\'\\'.join(stack)\\n```\\n\\nO(N) runtime",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n    def makeGood(self, s: str) -> str:\\n        stack = list()\\n        for c in s:\\n            if stack and stack[-1].lower() == c.lower():\\n                if stack[-1] == c:\\n                    stack.append(c)\\n                else:\\n                    stack.pop()\\n            else:\\n                stack.append(c)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 782596,
                "title": "rust-stack-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        let mut stack: Vec<char> = Vec::new();\\n        \\n        for l in s.chars() {\\n            if stack.len() > 0 && (l as i32 - stack[stack.len() - 1] as i32).abs() == 32 {\\n                stack.pop();\\n            }\\n            else {\\n                stack.push(l);\\n            }\\n        }\\n        \\n        return stack.iter().collect();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn make_good(s: String) -> String {\\n        let mut stack: Vec<char> = Vec::new();\\n        \\n        for l in s.chars() {\\n            if stack.len() > 0 && (l as i32 - stack[stack.len() - 1] as i32).abs() == 32 {\\n                stack.pop();\\n            }\\n            else {\\n                stack.push(l);\\n            }\\n        }\\n        \\n        return stack.iter().collect();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3168786,
                "title": "beats-54-75-make-the-string-great",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        l=[]\\n        for i in range(len(s)):\\n            if len(l)==0:\\n                l.append(s[i])\\n            elif l[len(l)-1]==s[i].lower() and s[i].isupper()==True or l[len(l)-1]==s[i].upper() and s[i].islower()==True:\\n                l.pop()\\n            else:\\n                l.append(s[i])\\n        return \"\".join(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        l=[]\\n        for i in range(len(s)):\\n            if len(l)==0:\\n                l.append(s[i])\\n            elif l[len(l)-1]==s[i].lower() and s[i].isupper()==True or l[len(l)-1]==s[i].upper() and s[i].islower()==True:\\n                l.pop()\\n            else:\\n                l.append(s[i])\\n        return \"\".join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038384,
                "title": "two-pointers-in-place-modification-c",
                "content": "# Complexity\\n    Let n be the length of the input string s.\\n\\n- Time complexity : O(n)\\n\\n  We only need one iteration over s.\\nIn each step, we update the position of the two pointers and overwrite a character at most once, both of which take constant time.\\n- Space complexity : O(1)\\n\\n   We modify the input string s in place.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int last_index = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(last_index and abs(s[i]-s[last_index-1]) == 32)\\n            last_index--;\\n            else\\n            s[last_index++] = s[i];\\n        }\\n        return s.substr(0,last_index);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        int last_index = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(last_index and abs(s[i]-s[last_index-1]) == 32)\\n            last_index--;\\n            else\\n            s[last_index++] = s[i];\\n        }\\n        return s.substr(0,last_index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794221,
                "title": "java-easy-to-understand-self-explanatory",
                "content": "# Intuition\\nwe need to see last ele which can be find by stack\\n\\n# Approach\\nuse stack, if consition satisfy, pop, else push current\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean check(char a, char b){\\n        if(a >=\\'a\\' && a <=\\'z\\' && b >=\\'A\\' && b<=\\'Z\\'){\\n             return a == Character.toLowerCase(b); \\n        }\\n\\n        else if(a >=\\'A\\' && a <=\\'Z\\' && b>=\\'a\\' && b<=\\'z\\'){\\n            return a == Character.toUpperCase(b); \\n        }\\n        return false;\\n    }\\n\\n    public String makeGood(String s) {\\n        if(s.length()==0)\\n        return s;\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!st.isEmpty() && check(st.peek(), s.charAt(i))){\\n                st.pop();\\n            }\\n            else{\\n            st.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean check(char a, char b){\\n        if(a >=\\'a\\' && a <=\\'z\\' && b >=\\'A\\' && b<=\\'Z\\'){\\n             return a == Character.toLowerCase(b); \\n        }\\n\\n        else if(a >=\\'A\\' && a <=\\'Z\\' && b>=\\'a\\' && b<=\\'z\\'){\\n            return a == Character.toUpperCase(b); \\n        }\\n        return false;\\n    }\\n\\n    public String makeGood(String s) {\\n        if(s.length()==0)\\n        return s;\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!st.isEmpty() && check(st.peek(), s.charAt(i))){\\n                st.pop();\\n            }\\n            else{\\n            st.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793832,
                "title": "javascript-simple-solution-stack",
                "content": "I have used stack to solve this problem\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeGood = function(s) {\\n    var stack = []\\n    for ( let i = 0;i<s.length;i++)\\n    {\\n        if(stack.length &&Math.abs(s[i].charCodeAt()-stack[stack.length-1].charCodeAt())===32)\\n        {\\n            stack.pop();\\n\\n        }else{\\n            stack.push(s[i]);\\n\\n        }\\n\\n\\n    }\\n    return stack.join(\"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeGood = function(s) {\\n    var stack = []\\n    for ( let i = 0;i<s.length;i++)\\n    {\\n        if(stack.length &&Math.abs(s[i].charCodeAt()-stack[stack.length-1].charCodeAt())===32)\\n        {\\n            stack.pop();\\n\\n        }else{\\n            stack.push(s[i]);\\n\\n        }\\n\\n\\n    }\\n    return stack.join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2793415,
                "title": "100-0ms-simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        for(int i=s.size()-1;i>0;i--){\\n            if(abs(s[i]-s[i-1])==32)\\n                s.erase(i-1,2);\\n\\t\\t\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        for(int i=s.size()-1;i>0;i--){\\n            if(abs(s[i]-s[i-1])==32)\\n                s.erase(i-1,2);\\n\\t\\t\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793031,
                "title": "go-clean-solution-stack-o-n",
                "content": "It could be much cleaner if we had native Stack implementation in Go, but we don\\'t, so the solution contains some slice operation to push and pop elements.\\n\\nThe `isBad` function uses the idea that two characters in different registers are placed at the same distance in the ASCII table, but we have to ensure that `a` is greather than `b` in order not to overflow the `byte` type which is unsigned integer when we calculate distance between `a` and `b`.\\n\\n```go\\nfunc makeGood(s string) string {\\n    if len(s) < 2 {\\n        return s\\n    }\\n    \\n    res := make([]byte, 0, len(s))\\n    for i := 0; i < len(s); i++ {\\n        last := len(res) - 1\\n\\n        if len(res) == 0 || !isBad(res[last], s[i]) {\\n            res = append(res, s[i])\\n        } else {\\n            res = res[:last]\\n        }\\n    }\\n    \\n    return string(res)\\n}\\n\\nfunc isBad(a, b byte) bool {\\n    if a < b {\\n        a, b = b, a\\n    }\\n    const distance = int(\\'a\\' - \\'A\\') // 32\\n    return int(a - b) == distance\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Stack"
                ],
                "code": "```go\\nfunc makeGood(s string) string {\\n    if len(s) < 2 {\\n        return s\\n    }\\n    \\n    res := make([]byte, 0, len(s))\\n    for i := 0; i < len(s); i++ {\\n        last := len(res) - 1\\n\\n        if len(res) == 0 || !isBad(res[last], s[i]) {\\n            res = append(res, s[i])\\n        } else {\\n            res = res[:last]\\n        }\\n    }\\n    \\n    return string(res)\\n}\\n\\nfunc isBad(a, b byte) bool {\\n    if a < b {\\n        a, b = b, a\\n    }\\n    const distance = int(\\'a\\' - \\'A\\') // 32\\n    return int(a - b) == distance\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792812,
                "title": "simplest-c-solution-ever-seen",
                "content": "If you fine simplest one send me it. Thanks.)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string MakeGood(string s) {      \\n        var sb = new StringBuilder(s);\\n        for (int i = 0; i < sb.Length - 1;)\\n            if (sb[i] - 32 == sb[i + 1]) { sb.Remove(i, 2); i = 0; }\\n            else if (sb[i] + 32 == sb[i + 1]) { sb.Remove(i, 2); i = 0; }\\n            else i++;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeGood(string s) {      \\n        var sb = new StringBuilder(s);\\n        for (int i = 0; i < sb.Length - 1;)\\n            if (sb[i] - 32 == sb[i + 1]) { sb.Remove(i, 2); i = 0; }\\n            else if (sb[i] + 32 == sb[i + 1]) { sb.Remove(i, 2); i = 0; }\\n            else i++;\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792792,
                "title": "c-easy-3ms-only-loops-and-substr",
                "content": "What I am doing here?\\nLets say we have aABbcCDD\\nnow you can see that we need to remove aA Bb and cC but not DD so our answer will be DD.\\nbut how we are gonna do this??\\nchecking two consecutive elements and if their ascii differs by 32, means 65+32==97 which is for \\'a\\' and \\'A\\' and 97-32==65 which is for \\'A\\' and \\'a\\' , using this we can find lowercase and uppercase letters easily using their ascii codes.\\nif two consecutive elements are same by ascii nature, we will remove both of them and our string will shrink by 2, like aABbcC-> BbcC-> cC -> \"\" empty string at last.\\nSo, we will remove these two characters using s.substr(0,i) function and it will help us to shrink the string, please I beg you to google this substr function otherwise no reason to see this solution, hardly take 5 mins for its understanding.\\nNow, this string shrinking will either empty the string or we will left with no pair to be removed. \\nSo, we will use a bool check, if it stays the same means nothing removed so the loop will break or if the string is empty the loop will end, returning the final string at the last.\\n\\n```\\nclass Solution\\n{\\n    public:\\n        string makeGood(string s)\\n        {\\n\\n            bool flag = false;\\n            while (true)\\n            {\\n                // cout<<\"Flag : \"<<flag<<endl;\\n                // cout<<\"S Size : \"<<s.size()<<endl;\\n                flag = false;\\n                for (int i = 1; i <= s.size() - 1; i++)\\n                {\\n                    // cout<<\"i : \"<<i<<endl;\\n                    // cout<<\"C Size : \"<<s.size()<<endl;\\n                    if (s[i - 1] - 32 == s[i] || s[i - 1] + 32 == s[i])\\n                    {\\n                        // cout<<\"Removal of \"<<s[i-1]<<\" and \"<<s[i]<<endl;\\n                        flag = true;\\n                        s = s.substr(0, i - 1) + s.substr(i + 1);\\n                        // cout<<\"New string : \"<<s<<endl;\\n                    }\\n                    if(s.size()==0){\\n                    // cout<<\"String empty, hence done\"<<endl;\\n                    break;\\n                    }\\n                }\\n                if(flag==false){\\n                    // cout<<\"No removal this time, hence done\"<<endl;\\n                    break;\\n                }\\n                if(s.size()==0){\\n                    // cout<<\"String empty, hence done\"<<endl;\\n                    break;\\n                }\\n            }\\n\\n            return s;\\n        }\\n};\\n```\\n\\nIf you loved it, pls guys upvote me so that I can post more.\\nFor any suggestions pls write the comment below.\\nThankyou for your time to read till now.\\n\\nHappy Leetcoding.",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string makeGood(string s)\\n        {\\n\\n            bool flag = false;\\n            while (true)\\n            {\\n                // cout<<\"Flag : \"<<flag<<endl;\\n                // cout<<\"S Size : \"<<s.size()<<endl;\\n                flag = false;\\n                for (int i = 1; i <= s.size() - 1; i++)\\n                {\\n                    // cout<<\"i : \"<<i<<endl;\\n                    // cout<<\"C Size : \"<<s.size()<<endl;\\n                    if (s[i - 1] - 32 == s[i] || s[i - 1] + 32 == s[i])\\n                    {\\n                        // cout<<\"Removal of \"<<s[i-1]<<\" and \"<<s[i]<<endl;\\n                        flag = true;\\n                        s = s.substr(0, i - 1) + s.substr(i + 1);\\n                        // cout<<\"New string : \"<<s<<endl;\\n                    }\\n                    if(s.size()==0){\\n                    // cout<<\"String empty, hence done\"<<endl;\\n                    break;\\n                    }\\n                }\\n                if(flag==false){\\n                    // cout<<\"No removal this time, hence done\"<<endl;\\n                    break;\\n                }\\n                if(s.size()==0){\\n                    // cout<<\"String empty, hence done\"<<endl;\\n                    break;\\n                }\\n            }\\n\\n            return s;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2792782,
                "title": "1544-make-the-string-great",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Make The String Great.\\nMemory Usage: 7.1 MB, less than 8.20% of C++ online submissions for Make The String Great.**\\n\\n```\\n string makeGood(string s) {\\n        \\n        stack<char>st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            //if stack is empty push element \\n            if(st.empty()){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            \\n            //else check if the difference of stack\\'s top element and char is 32, if yes then remove the top most element of stack and if not then push char into the stack\\n            else{\\n                if(abs(st.top() - s[i])== 32){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        \\n        //Now insert the stack elements in string ans until the stack is empty and return\\n        string ans;\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(n)**",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n string makeGood(string s) {\\n        \\n        stack<char>st;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            //if stack is empty push element \\n            if(st.empty()){\\n                st.push(s[i]);\\n                continue;\\n            }\\n            \\n            //else check if the difference of stack\\'s top element and char is 32, if yes then remove the top most element of stack and if not then push char into the stack\\n            else{\\n                if(abs(st.top() - s[i])== 32){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        \\n        //Now insert the stack elements in string ans until the stack is empty and return\\n        string ans;\\n        while(!st.empty()){\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792716,
                "title": "easy-solution-one-pass-96-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        idx =0\\n        while(idx+1<len(s)):\\n            if(abs(ord(s[idx])-ord(s[idx+1]))==32):\\n                s= s[:idx]+s[idx+2:]\\n                idx =0\\n            else:\\n                idx+=1\\n        return s\\n\\n\\n\\n        \\n        \\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        idx =0\\n        while(idx+1<len(s)):\\n            if(abs(ord(s[idx])-ord(s[idx+1]))==32):\\n                s= s[:idx]+s[idx+2:]\\n                idx =0\\n            else:\\n                idx+=1\\n        return s\\n\\n\\n\\n        \\n        \\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792529,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        while(true) {\\n            int upd = 0;\\n            for(int i=1; i<s.size(); i++) {\\n                if(s[i-1]-\\'a\\' == s[i]-\\'A\\' or s[i-1]-\\'A\\' == s[i]-\\'a\\') {\\n                    s.erase(i-1, 2);\\n                    upd = 1;\\n                    break;\\n                }\\n            }\\n            if(!upd) break;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        while(true) {\\n            int upd = 0;\\n            for(int i=1; i<s.size(); i++) {\\n                if(s[i-1]-\\'a\\' == s[i]-\\'A\\' or s[i-1]-\\'A\\' == s[i]-\\'a\\') {\\n                    s.erase(i-1, 2);\\n                    upd = 1;\\n                    break;\\n                }\\n            }\\n            if(!upd) break;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792482,
                "title": "c-simple-stringbuilder-only-solution",
                "content": "```\\npublic class Solution {\\n    public string MakeGood(string s) {\\n        var sb = new StringBuilder();\\n        foreach (var c in s)\\n            if (sb.Length > 0 && Math.Abs(sb[^1]-c) == 32)\\n                    sb.Length--;\\n                else\\n                    sb.Append(c);\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeGood(string s) {\\n        var sb = new StringBuilder();\\n        foreach (var c in s)\\n            if (sb.Length > 0 && Math.Abs(sb[^1]-c) == 32)\\n                    sb.Length--;\\n                else\\n                    sb.Append(c);\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791897,
                "title": "easy-c-solution-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a stack and traverse over the string: \\n1. If the stack is empty then push the character in the stack. \\n2. If the element at the top of the stack is lowercase letter and next character in the string is same upper case letter or vice-versa then pop that character from the stack. \\n3. Otherwise push the character onto the stack.\\n\\nThe characters present in the stack forms the good string.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        for (int i =0  ; i < s.size() ; i++)\\n        {\\n            if (st.size() == 0)\\n            {\\n                st.push(s[i]);\\n            }\\n            else if (st.top() == (s[i]+32) || st.top()+32 == s[i])\\n            st.pop();\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans = \"\";\\n        while(!st.empty())\\n        {\\n            ans.insert(ans.begin(), st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        for (int i =0  ; i < s.size() ; i++)\\n        {\\n            if (st.size() == 0)\\n            {\\n                st.push(s[i]);\\n            }\\n            else if (st.top() == (s[i]+32) || st.top()+32 == s[i])\\n            st.pop();\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans = \"\";\\n        while(!st.empty())\\n        {\\n            ans.insert(ans.begin(), st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791620,
                "title": "o-n-stack-make-the-string-great",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack=new Stack<>();\\n       \\n        for(int i=0;i<s.length();i++)\\n        {\\n            \\n            if(stack.size()>0&&stack.peek()!=s.charAt(i)){\\n               String t1=\"\"+stack.peek();\\n               String t2=\"\"+s.charAt(i);\\n                if(t1.toLowerCase().equals(t2.toLowerCase()))stack.pop();\\n                else stack.push(s.charAt(i));\\n            }\\n            else\\n               stack.push(s.charAt(i));  \\n            \\n        }\\n        String str=\"\";\\n        while(stack.size()>0){\\n            str=stack.pop()+str;\\n        }\\n        return str;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stack=new Stack<>();\\n       \\n        for(int i=0;i<s.length();i++)\\n        {\\n            \\n            if(stack.size()>0&&stack.peek()!=s.charAt(i)){\\n               String t1=\"\"+stack.peek();\\n               String t2=\"\"+s.charAt(i);\\n                if(t1.toLowerCase().equals(t2.toLowerCase()))stack.pop();\\n                else stack.push(s.charAt(i));\\n            }\\n            else\\n               stack.push(s.charAt(i));  \\n            \\n        }\\n        String str=\"\";\\n        while(stack.size()>0){\\n            str=stack.pop()+str;\\n        }\\n        return str;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791614,
                "title": "java-easy-solution-using-stacks",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        int n = s.length();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(st.size()!=0){\\n                char ch2 = st.peek();\\n                if(Math.abs(ch-ch2) == 32) st.pop();  //abs(\\'a\\'-\\'A\\') = abs(\\'A\\'-\\'a\\') = abs(\\'z\\'-\\'Z\\')... = 32\\n                \\n                else st.push(ch);\\n            }\\n            else st.push(ch);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(st.size()!=0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n        int n = s.length();\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(st.size()!=0){\\n                char ch2 = st.peek();\\n                if(Math.abs(ch-ch2) == 32) st.pop();  //abs(\\'a\\'-\\'A\\') = abs(\\'A\\'-\\'a\\') = abs(\\'z\\'-\\'Z\\')... = 32\\n                \\n                else st.push(ch);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2791602,
                "title": "java-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the string and add character of string to the stack if it is empty , if stack is not empty check the difference of peek value of stack and character of string is 32 or not if it is then pop the character from the stack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n      \\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0;i<s.length();i++){\\n           \\n            if(!st.isEmpty() && Math.abs(st.peek()-s.charAt(i))==32) st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        String ans = \"\";\\n        while(!st.isEmpty()){\\n            ans += st.peek()+\"\";\\n            st.pop();\\n        }\\n        StringBuilder sb = new StringBuilder(ans);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n      \\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0;i<s.length();i++){\\n           \\n            if(!st.isEmpty() && Math.abs(st.peek()-s.charAt(i))==32) st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        String ans = \"\";\\n        while(!st.isEmpty()){\\n            ans += st.peek()+\"\";\\n            st.pop();\\n        }\\n        StringBuilder sb = new StringBuilder(ans);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791154,
                "title": "beats-100-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string &s) {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(abs(int(s[i+1]) - int(s[i])) == 32)\\n                s.erase(i,2),i=max(-1,i-2);\\n        }\\n        return s;\\n    }\\n};\\n// s.erase(i,2) will erase 2 letter from ith position\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string &s) {\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(abs(int(s[i+1]) - int(s[i])) == 32)\\n                s.erase(i,2),i=max(-1,i-2);\\n        }\\n        return s;\\n    }\\n};\\n// s.erase(i,2) will erase 2 letter from ith position\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791148,
                "title": "python3-stack-simple",
                "content": "# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\n        stack = []\\n        i = 0\\n\\n        def check(s1, s2):\\n            return abs(ord(s1)-ord(s2)) == 32\\n\\n        for i in range(len(s)):\\n            if not stack:\\n                stack.append(s[i])\\n                continue\\n\\n            l = stack[-1]\\n            r = s[i]\\n\\n            if check(l, r):\\n                stack.pop()\\n                continue\\n            \\n            stack.append(r)\\n        \\n        return \"\".join(stack)\\n```\\n\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\n        stack = []\\n        i = 0\\n\\n        for i in range(len(s)):\\n            if not stack:\\n                stack.append(s[i])\\n                continue\\n\\n            l = stack[-1]\\n            r = s[i]\\n\\n            if (l.isupper() and l.lower() == r) or (l.islower() and l.upper() == r):\\n                stack.pop()\\n                continue\\n            \\n            stack.append(r)\\n        \\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\n        stack = []\\n        i = 0\\n\\n        def check(s1, s2):\\n            return abs(ord(s1)-ord(s2)) == 32\\n\\n        for i in range(len(s)):\\n            if not stack:\\n                stack.append(s[i])\\n                continue\\n\\n            l = stack[-1]\\n            r = s[i]\\n\\n            if check(l, r):\\n                stack.pop()\\n                continue\\n            \\n            stack.append(r)\\n        \\n        return \"\".join(stack)\\n```\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\n        stack = []\\n        i = 0\\n\\n        for i in range(len(s)):\\n            if not stack:\\n                stack.append(s[i])\\n                continue\\n\\n            l = stack[-1]\\n            r = s[i]\\n\\n            if (l.isupper() and l.lower() == r) or (l.islower() and l.upper() == r):\\n                stack.pop()\\n                continue\\n            \\n            stack.append(r)\\n        \\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791107,
                "title": "c-simple-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n       while(1)\\n       {\\n           stack<char>st;\\n           st.push(s[0]);\\n           int ind=0;\\n           int a=s.size();\\n           for(int i=1;i<s.size();i++)\\n           {\\n               if(s[i]+32==st.top() or s[i]-32==st.top())\\n               {\\n                   s.erase(s.begin()+i);\\n                   s.erase(s.begin()+ind);\\n                   st.pop();\\n               }\\n               ind=i;\\n               st.push(s[i]);\\n           }\\n           if(a==s.size())\\n               return s;\\n       }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n       while(1)\\n       {\\n           stack<char>st;\\n           st.push(s[0]);\\n           int ind=0;\\n           int a=s.size();\\n           for(int i=1;i<s.size();i++)\\n           {\\n               if(s[i]+32==st.top() or s[i]-32==st.top())\\n               {\\n                   s.erase(s.begin()+i);\\n                   s.erase(s.begin()+ind);\\n                   st.pop();\\n               }\\n               ind=i;\\n               st.push(s[i]);\\n           }\\n           if(a==s.size())\\n               return s;\\n       }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791045,
                "title": "python3-stack-easy-smart-way-with-ascii-code-to-know-upper-lower-or-lower-upper-pairs",
                "content": "### Solution\\n1 Use the stack to eliminate the pairs defined in the problem -- `s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case  or **vice versa**`\\n2 In the loop, we check the pairs by knowing the difference of the two chars == `(ord(\\'a\\') - ord(\\'A\\'))`\\n\\n65 A\\n66 B\\n....\\n90 Z\\n91 [\\n92 \\\\\\n93 ]\\n...\\n97 a\\n98 b\\n\\nThat\\'s it!\\n\\n```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        n = len(s)\\n        stack = []\\n        # for i in range(n - 1):\\n        for i in range(n):  # CAUTIOUS!\\n            if stack and abs(ord(stack[-1]) - ord(s[i])) == (ord(\\'a\\') - ord(\\'A\\')):\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        n = len(s)\\n        stack = []\\n        # for i in range(n - 1):\\n        for i in range(n):  # CAUTIOUS!\\n            if stack and abs(ord(stack[-1]) - ord(s[i])) == (ord(\\'a\\') - ord(\\'A\\')):\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790871,
                "title": "easy-solution-using-c",
                "content": "\" \"\\nstring makeGood(string s) \\n    {\\n   \\n\\n\\n\\t if(s==\"\")\\n            return s;\\n        if(s.size()==1)\\n            return s;\\n        int i=0;\\n        while(i<(s.size()-1) && (s.size()!=0))\\n        {\\n           if((s[i]>=65 && s[i]<=90)&& (s[i+1]>=65 && s[i+1]<=90))\\n           {\\n               i++;\\n               \\n           }\\n           else  if((s[i]>=97 && s[i]<=122)&& (s[i+1]>=97 && s[i+1]<=122))\\n           {\\n               i++;\\n               \\n           }\\n            else \\n            {\\n                \\n               int l=s[i];\\n               int u=s[i+1];\\n               \\n               if(l==u+32 || l+32==u)\\n               {\\n                   \\n                  s.erase(s.begin()+i,s.begin()+i+2);\\n                \\n                  i=0;\\n                 \\n                  \\n                  \\n                  \\n               }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n            \\n            \\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "\" \"\\nstring makeGood(string s) \\n    {\\n   \\n\\n\\n\\t if(s==\"\")\\n            return s;\\n        if(s.size()==1)\\n            return s;\\n        int i=0;\\n        while(i<(s.size()-1) && (s.size()!=0))\\n        {\\n           if((s[i]>=65 && s[i]<=90)&& (s[i+1]>=65 && s[i+1]<=90))\\n           {\\n               i++;\\n               \\n           }\\n           else  if((s[i]>=97 && s[i]<=122)&& (s[i+1]>=97 && s[i+1]<=122))\\n           {\\n               i++;\\n               \\n           }\\n            else \\n            {\\n                \\n               int l=s[i];\\n               int u=s[i+1];\\n               \\n               if(l==u+32 || l+32==u)\\n               {\\n                   \\n                  s.erase(s.begin()+i,s.begin()+i+2);\\n                \\n                  i=0;\\n                 \\n                  \\n                  \\n                  \\n               }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n            \\n            \\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2790816,
                "title": "ruby-no-brainer",
                "content": "# Code\\n```\\n# BAD = /aA|Aa|bB|Bb|.../\\nBAD = Regexp.compile((\\'a\\'..\\'z\\').flat_map{|c| [\"#{c}#{c.upcase}\", \"#{c.upcase}#{c}\"]}.join(\\'|\\'))\\n\\n# @param {String} s\\n# @return {String}\\ndef make_good(s)\\n  s.gsub!(BAD, \"\") ? make_good(s) : s\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# BAD = /aA|Aa|bB|Bb|.../\\nBAD = Regexp.compile((\\'a\\'..\\'z\\').flat_map{|c| [\"#{c}#{c.upcase}\", \"#{c.upcase}#{c}\"]}.join(\\'|\\'))\\n\\n# @param {String} s\\n# @return {String}\\ndef make_good(s)\\n  s.gsub!(BAD, \"\") ? make_good(s) : s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2790787,
                "title": "simple-python-solution-faster-than-99-57-stack-implementation",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        st = []\\n        for i in s:\\n            if st:\\n                if i.isupper() and st[-1].islower() and st[-1].upper() == i: \\n                    st.pop()\\n                    continue\\n                elif i.islower() and st[-1].isupper() and st[-1].lower() == i:\\n                    st.pop()\\n                    continue\\n                else:\\n                    st.append(i)\\n                    continue \\n            else:\\n                st.append(i)\\n                continue\\n        return \"\".join(st)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        st = []\\n        for i in s:\\n            if st:\\n                if i.isupper() and st[-1].islower() and st[-1].upper() == i: \\n                    st.pop()\\n                    continue\\n                elif i.islower() and st[-1].isupper() and st[-1].lower() == i:\\n                    st.pop()\\n                    continue\\n                else:\\n                    st.append(i)\\n                    continue \\n            else:\\n                st.append(i)\\n                continue\\n        return \"\".join(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716661,
                "title": "js-very-easy-solution",
                "content": "```\\nvar makeGood = function(s) {\\n    const stack = [s[0]];\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if ([32, -32].includes(s.charCodeAt(i) - s.charCodeAt(i - 1))) {\\n            s = s.substring(0, i - 1) + s.substring(i + 1, s.length);\\n            i-=2;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    \\n    return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar makeGood = function(s) {\\n    const stack = [s[0]];\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if ([32, -32].includes(s.charCodeAt(i) - s.charCodeAt(i - 1))) {\\n            s = s.substring(0, i - 1) + s.substring(i + 1, s.length);\\n            i-=2;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    \\n    return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2619198,
                "title": "js-with-explanation-easy-to-understand-stack",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/1544-make-string-great-stack.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst makeGood = function (s) {\\n    if (s.length == 1) return s;\\n    let stack = [s[0]];\\n    for (let i = 1; i < s.length; i++) {\\n        if (stack.length == 0){\\n            stack.push(s[i]);\\n        }  else {\\n            let end = stack[stack.length - 1];\\n            if ((isUpperCase(end) && isLowerCase(s[i]) && isEqual(end, s[i])) || (isLowerCase(end) && isUpperCase(s[i]) && isEqual(end, s[i]))) {\\n                stack.pop();\\n                continue;\\n            }\\n            stack.push(s[i]);\\n        }\\n    }\\n    return stack.join(\"\");\\n};\\n\\n\\nconst isEqual = (s1, s2) => {\\n    if (s1.toLowerCase() == s2.toLowerCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nconst isUpperCase = (character) => {\\n    if (character == character.toUpperCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nconst isLowerCase = (character) => {\\n    if (character == character.toLowerCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nconst makeGood = function (s) {\\n    if (s.length == 1) return s;\\n    let stack = [s[0]];\\n    for (let i = 1; i < s.length; i++) {\\n        if (stack.length == 0){\\n            stack.push(s[i]);\\n        }  else {\\n            let end = stack[stack.length - 1];\\n            if ((isUpperCase(end) && isLowerCase(s[i]) && isEqual(end, s[i])) || (isLowerCase(end) && isUpperCase(s[i]) && isEqual(end, s[i]))) {\\n                stack.pop();\\n                continue;\\n            }\\n            stack.push(s[i]);\\n        }\\n    }\\n    return stack.join(\"\");\\n};\\n\\n\\nconst isEqual = (s1, s2) => {\\n    if (s1.toLowerCase() == s2.toLowerCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nconst isUpperCase = (character) => {\\n    if (character == character.toUpperCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n\\nconst isLowerCase = (character) => {\\n    if (character == character.toLowerCase()) {\\n        return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606408,
                "title": "c-stack-solution",
                "content": "class Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n      stack<char>st;\\n      int n=s.length();\\n      for(int i=0;i<s.length();i++)\\n      {\\n          int flag=0;\\n        if(!st.empty()&&(char(s[i]-32)==char(st.top())||char(s[i]+32)==char(st.top())))\\n        {\\n        flag=1;\\n        st.pop();\\n        }\\n        else\\n        {\\n        st.push(s[i]);\\n        }\\n      }\\n    string ans;\\n        while(!st.empty())\\n        {\\n           ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n      stack<char>st;\\n      int n=s.length();\\n      for(int i=0;i<s.length();i++)\\n      {\\n          int flag=0;\\n        if(!st.empty()&&(char(s[i]-32)==char(st.top())||char(s[i]+32)==char(st.top())))\\n        {\\n        flag=1;\\n        st.pop();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2606399,
                "title": "c-solution-using-stack",
                "content": "class Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack<char>st;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                int flag=0;\\n                if(abs(st.top()-s[i])==32)\\n                {\\n                flag=1;\\n                st.pop();\\n                }\\n                if(flag==0)\\n            st.push(s[i]);\\n            }\\n        i++;\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans=st.top()+ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack<char>st;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457890,
                "title": "c-t-c-o-n-s-c-o-n-stack-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n         stack<char>stk;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(stk.size()==0)\\n             {\\n                stk.push(s[i]);   \\n             }\\n             else if(stk.size()>0)\\n             {\\n                char currchar=s[i];\\n                 \\n                char upperchar=toupper(currchar);\\n                char lowerchar=tolower(currchar);\\n                 \\n                if(stk.top()==upperchar and s[i]==lowerchar)\\n                {\\n                    //code\\n                    stk.pop();\\n                }\\n                else if(stk.top()==lowerchar and s[i]==upperchar)\\n                {\\n                    stk.pop();\\n                }\\n                else  //upper upper lower lower or not equal\\n                {\\n                    stk.push(s[i]);\\n                }\\n                 \\n             }\\n         }\\n        string ans=\"\";\\n        while(!stk.empty())\\n        {\\n            ans=stk.top()+ans;\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n         stack<char>stk;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(stk.size()==0)\\n             {\\n                stk.push(s[i]);   \\n             }\\n             else if(stk.size()>0)\\n             {\\n                char currchar=s[i];\\n                 \\n                char upperchar=toupper(currchar);\\n                char lowerchar=tolower(currchar);\\n                 \\n                if(stk.top()==upperchar and s[i]==lowerchar)\\n                {\\n                    //code\\n                    stk.pop();\\n                }\\n                else if(stk.top()==lowerchar and s[i]==upperchar)\\n                {\\n                    stk.pop();\\n                }\\n                else  //upper upper lower lower or not equal\\n                {\\n                    stk.push(s[i]);\\n                }\\n                 \\n             }\\n         }\\n        string ans=\"\";\\n        while(!stk.empty())\\n        {\\n            ans=stk.top()+ans;\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381942,
                "title": "java-easy-solution-o-n",
                "content": "class Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(!st.empty()) {\\n                if(  Math.abs(s.charAt(i) - st.peek()) ==32  ){\\n                    st.pop();\\n                    continue;\\n                } \\n            }\\n            st.push(s.charAt(i));\\n        }\\n        String ans=\"\";\\n         while(!st.empty())\\n            ans=st.pop()+ans;\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(!st.empty()) {\\n                if(  Math.abs(s.charAt(i) - st.peek()) ==32  ){\\n                    st.pop();\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2185879,
                "title": "java-easy-solution-98-44-faster",
                "content": "![image](https://assets.leetcode.com/users/images/940e35ab-c7fe-4c60-9c59-884c92c8c4a9_1655961391.3109472.png)\\n**Please UpVote If you like**\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i=0; i<sb.length()-1; i++)\\n        {\\n\\t\\t// Checking if two adjacent characters are in upper and lower case. \\n\\t\\t//If both are same then their ASCII difference will always be 32 (For Ex - A->65 and a-> 97 therefore |65-97| = 32) \\n            if(Math.abs((int)sb.charAt(i) - (int)sb.charAt(i+1)) == 32)  \\n            {\\n                sb.deleteCharAt(i);\\n                sb.deleteCharAt(i);\\n                if(i == 0)\\n                    --i;\\n                else\\n                    i = i-2;\\n            }\\n            if(sb.length() == 0)\\n                return \"\";\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i=0; i<sb.length()-1; i++)\\n        {\\n\\t\\t// Checking if two adjacent characters are in upper and lower case. \\n\\t\\t//If both are same then their ASCII difference will always be 32 (For Ex - A->65 and a-> 97 therefore |65-97| = 32) \\n            if(Math.abs((int)sb.charAt(i) - (int)sb.charAt(i+1)) == 32)  \\n            {\\n                sb.deleteCharAt(i);\\n                sb.deleteCharAt(i);\\n                if(i == 0)\\n                    --i;\\n                else\\n                    i = i-2;\\n            }\\n            if(sb.length() == 0)\\n                return \"\";\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939297,
                "title": "very-simple-solution-beats-96-in-java",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        if(s.length()==0 || s.length()==1)return s;\\n        int i=0;\\n\\t\\t\\n        while(i<s.length()-1){\\n            char c=s.charAt(i);\\n            char ch=s.charAt(i+1);\\n            if(c-\\'a\\'==ch-\\'A\\' || c-\\'A\\'==ch-\\'a\\'){\\n                if(i==0){\\n                    s=s.substring(2);\\n                }\\n                else{\\n                    s=s.substring(0,i)+s.substring(i+2);\\n                }\\n                i--;\\n                if(i<0){\\n                    i=0;\\n                }\\n            }\\n            else{\\n                i++;\\n            }  \\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n        if(s.length()==0 || s.length()==1)return s;\\n        int i=0;\\n\\t\\t\\n        while(i<s.length()-1){\\n            char c=s.charAt(i);\\n            char ch=s.charAt(i+1);\\n            if(c-\\'a\\'==ch-\\'A\\' || c-\\'A\\'==ch-\\'a\\'){\\n                if(i==0){\\n                    s=s.substring(2);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1569653,
                "title": "very-easy-java-solution-o-n",
                "content": "\\nclass Solution {\\n    public String makeGood(String s) {\\n       \\n         StringBuilder stringBuilder = new StringBuilder(s);\\n        \\n        for (int i = 1; i < stringBuilder.length(); i++) {\\n            if (Math.abs((int) stringBuilder.charAt(i) - (int) stringBuilder.charAt(i - 1)) == 32) {\\n                stringBuilder.deleteCharAt(i - 1);\\n\\t\\t\\t\\t//after deleting index (i-1) , stringBuilder\\'s length shrinks so again delete index (i - 1)\\n                stringBuilder.deleteCharAt(i - 1);\\n                i = 0;\\n            }\\n        }\\n        return stringBuilder.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n       \\n         StringBuilder stringBuilder = new StringBuilder(s);\\n        \\n        for (int i = 1; i < stringBuilder.length(); i++) {\\n            if (Math.abs((int) stringBuilder.charAt(i) - (int) stringBuilder.charAt(i - 1)) == 32) {\\n                stringBuilder.deleteCharAt(i - 1);\\n\\t\\t\\t\\t//after deleting index (i-1) , stringBuilder\\'s length shrinks so again delete index (i - 1)\\n                stringBuilder.deleteCharAt(i - 1);\\n                i = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1526033,
                "title": "java-simple-solution-and-100-faster",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        \\n        for(int i=0; i<str.length()-1;){\\n            if(Math.abs(str.charAt(i)-str.charAt(i+1))==32){\\n                str.delete(i, i+2);\\n                i= i-1>0?i-1:0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder(s);\\n        \\n        for(int i=0; i<str.length()-1;){\\n            if(Math.abs(str.charAt(i)-str.charAt(i+1))==32){\\n                str.delete(i, i+2);\\n                i= i-1>0?i-1:0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        \\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359253,
                "title": "two-simple-java-solutions",
                "content": "\\nHere every character should be checked with last visited character so if they are same character(either one is in lowercase and other one is in upercase) then we have to remove both the character from our final string. \\n\\nSolution 1: Using stack\\ncheck each character with stack\\'s peek character. if they above condition matches then pop the character otherwise push current character into stack.\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!stack.isEmpty() && Math.abs(s.charAt(i) - stack.peek())==32) \\n                stack.pop();\\n            else\\n                stack.push(s.charAt(i));\\n        }\\n        while(!stack.isEmpty()) {\\n            str.insert(0, stack.pop());\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\n\\n\\nSolution 2: \\nIn the above solution we are comparing only last visited character with current character so instead of using stack, we can directly use final string and compare last appended character with current character.\\n\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int size=0;\\n        for(int i=0;i<s.length();i++){\\n            size = str.length();\\n            if(str.length()>0 && Math.abs(s.charAt(i) - str.charAt(size-1))==32) {\\n                str.deleteCharAt(size-1);\\n            }\\n            else{\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if(!stack.isEmpty() && Math.abs(s.charAt(i) - stack.peek())==32) \\n                stack.pop();\\n            else\\n                stack.push(s.charAt(i));\\n        }\\n        while(!stack.isEmpty()) {\\n            str.insert(0, stack.pop());\\n        }\\n        return str.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int size=0;\\n        for(int i=0;i<s.length();i++){\\n            size = str.length();\\n            if(str.length()>0 && Math.abs(s.charAt(i) - str.charAt(size-1))==32) {\\n                str.deleteCharAt(size-1);\\n            }\\n            else{\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333217,
                "title": "simple-c-using-stack-0ms",
                "content": "```\\nstring makeGood(string s) {\\n        stack<char> Stack;\\n        for(int i=0;i<s.length();i++){\\n            if(Stack.empty())\\n                Stack.push(s[i]);\\n            else{\\n                if(abs(Stack.top()-s[i])==32)\\n                    Stack.pop();\\n                else\\n                    Stack.push(s[i]);\\n            }\\n        }\\n        string ret;\\n        while(!Stack.empty()){\\n            ret=Stack.top()+ret;\\n            Stack.pop();\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring makeGood(string s) {\\n        stack<char> Stack;\\n        for(int i=0;i<s.length();i++){\\n            if(Stack.empty())\\n                Stack.push(s[i]);\\n            else{\\n                if(abs(Stack.top()-s[i])==32)\\n                    Stack.pop();\\n                else\\n                    Stack.push(s[i]);\\n            }\\n        }\\n        string ret;\\n        while(!Stack.empty()){\\n            ret=Stack.top()+ret;\\n            Stack.pop();\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1209460,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n     Stack<Character> stk=new Stack<Character>();\\n        char[] ch=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(Character.isUpperCase(ch[i]))\\n            {\\n                char curr=Character.toLowerCase(ch[i]);\\n                if(!stk.empty()&&curr==stk.peek())\\n                {\\n                    stk.pop();\\n                    continue;\\n                }\\n            }\\n            else\\n            {\\n                char curr=Character.toUpperCase(ch[i]);\\n                if(!stk.empty()&&curr==stk.peek())\\n                {\\n                    stk.pop();\\n                    continue;\\n                }\\n            }\\n            \\n            stk.push(ch[i]);\\n        }\\n        StringBuilder res=new StringBuilder();\\n        while(!stk.empty())\\n        {\\n            res.append(stk.pop());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n     Stack<Character> stk=new Stack<Character>();\\n        char[] ch=s.toCharArray();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(Character.isUpperCase(ch[i]))\\n            {\\n                char curr=Character.toLowerCase(ch[i]);\\n                if(!stk.empty()&&curr==stk.peek())\\n                {\\n                    stk.pop();\\n                    continue;\\n                }\\n            }\\n            else\\n            {\\n                char curr=Character.toUpperCase(ch[i]);\\n                if(!stk.empty()&&curr==stk.peek())\\n                {\\n                    stk.pop();\\n                    continue;\\n                }\\n            }\\n            \\n            stk.push(ch[i]);\\n        }\\n        StringBuilder res=new StringBuilder();\\n        while(!stk.empty())\\n        {\\n            res.append(stk.pop());\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190421,
                "title": "java-solution-100",
                "content": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            if(sb.length() == 0 || Math.abs((sb.charAt(sb.length() - 1) - s.charAt(i))) != 32){\\n                sb.append(s.charAt(i));\\n            }else{\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            if(sb.length() == 0 || Math.abs((sb.charAt(sb.length() - 1) - s.charAt(i))) != 32){\\n                sb.append(s.charAt(i));\\n            }else{\\n                sb.deleteCharAt(sb.length() - 1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099787,
                "title": "0-ms-faster-than-100-00-of-c-using-stack-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n       if(!s.empty()){\\n          for (int i = 0; i < s.size(); i++) {\\n            if (st.empty()) st.push(s[i]);\\n            else if (abs(s[i] - st.top()) == 32) st.pop();\\n            else st.push(s[i]);\\n          }\\n          while(!st.empty()){\\n              ans+=st.top();\\n              st.pop();\\n          }\\n            reverse(ans.begin(),ans.end());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n       if(!s.empty()){\\n          for (int i = 0; i < s.size(); i++) {\\n            if (st.empty()) st.push(s[i]);\\n            else if (abs(s[i] - st.top()) == 32) st.pop();\\n            else st.push(s[i]);\\n          }\\n          while(!st.empty()){\\n              ans+=st.top();\\n              st.pop();\\n          }\\n            reverse(ans.begin(),ans.end());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092337,
                "title": "c-solution-simple-one-pass-version",
                "content": "```\\n\\nint badPair(char ch1, char ch2){\\n    /* Wacky ASCII assumption version:\\n    return (ch1 ^ ch2) == 0x20; */\\n    \\n    return ch1 != ch2 && tolower(ch1) == tolower(ch2);\\n}\\n\\nchar * makeGood(char * s){\\n    const char * in = s;\\n    char * out = s;\\n    \\n    for(; *in != \\'\\\\0\\'; ++in){\\n        if(out > s && badPair(*(out - 1), *in)){\\n            --out;\\n        }else{\\n            *(out++) = *in;\\n        }\\n    }\\n    \\n    *out = \\'\\\\0\\';\\n    \\n    return s;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint badPair(char ch1, char ch2){\\n    /* Wacky ASCII assumption version:\\n    return (ch1 ^ ch2) == 0x20; */\\n    \\n    return ch1 != ch2 && tolower(ch1) == tolower(ch2);\\n}\\n\\nchar * makeGood(char * s){\\n    const char * in = s;\\n    char * out = s;\\n    \\n    for(; *in != \\'\\\\0\\'; ++in){\\n        if(out > s && badPair(*(out - 1), *in)){\\n            --out;\\n        }else{\\n            *(out++) = *in;\\n        }\\n    }\\n    \\n    *out = \\'\\\\0\\';\\n    \\n    return s;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1044617,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\t\\n        stack_that = []\\n\\t\\t\\n        for c in s:\\n\\t\\t\\tif stack_that and stack_that[-1] == c.swapcase(): #saw this on a posted solution\\n\\t\\t# if stack_that and stack_that[-1] == chr(ord(c) ^ 32): # cool trick on a posted solution\\n         # if stack_that and abs(ord(stack_that[-1]) - ord(c)) == 32:  # my original approach\\n                stack_that.pop()\\n            else:\\n                stack_that.append(c)\\n                \\n        return \\'\\'.join(stack_that)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n\\t\\n        stack_that = []\\n\\t\\t\\n        for c in s:\\n\\t\\t\\tif stack_that and stack_that[-1] == c.swapcase(): #saw this on a posted solution\\n\\t\\t# if stack_that and stack_that[-1] == chr(ord(c) ^ 32): # cool trick on a posted solution\\n         # if stack_that and abs(ord(stack_that[-1]) - ord(c)) == 32:  # my original approach\\n                stack_that.pop()\\n            else:\\n                stack_that.append(c)\\n                \\n        return \\'\\'.join(stack_that)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933041,
                "title": "simple-java-brute-force",
                "content": "```\\npublic String makeGood(String s) {\\n        for(int i=0;i>=0 && i<s.length()-1;){\\n            if((s.charAt(i)+32==s.charAt(i+1) || s.charAt(i)-32==s.charAt(i+1))){\\n                s=s.substring(0, i) + s.substring(i+2); \\n                i--;\\n                if(i<0)i=0;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String makeGood(String s) {\\n        for(int i=0;i>=0 && i<s.length()-1;){\\n            if((s.charAt(i)+32==s.charAt(i+1) || s.charAt(i)-32==s.charAt(i+1))){\\n                s=s.substring(0, i) + s.substring(i+2); \\n                i--;\\n                if(i<0)i=0;\\n            }\\n            else\\n            i++;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 852380,
                "title": "100-faster-solution-c-with-xor-explained",
                "content": "From the ASCII table, we see that there\\'s always a difference of exactly 32 between the value of a lowercase and uppercase letter. Therefore, if we do (UPPERCASE(of a letter i))^(lowercase(of  a letter i)), we get 32. I used that in my code to get 100% C++ faster Solution.\\n```\\nstd::string Solution::MakeStringGreat::makeGood(std::string s) const {\\n    if (s.empty()) return \"\";\\n    if (s.size() == 1) return s;\\n    for (int i = 0; i < static_cast<int>(s.size() - 1); ++i) {\\n        if ((s.at(i) ^ s.at(i + 1)) == 32) {\\n            s.erase(i,2); // erases two character starting from pos i.\\n            i = -1; // returns to the begin of s.\\n        }\\n    return s;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstd::string Solution::MakeStringGreat::makeGood(std::string s) const {\\n    if (s.empty()) return \"\";\\n    if (s.size() == 1) return s;\\n    for (int i = 0; i < static_cast<int>(s.size() - 1); ++i) {\\n        if ((s.at(i) ^ s.at(i + 1)) == 32) {\\n            s.erase(i,2); // erases two character starting from pos i.\\n            i = -1; // returns to the begin of s.\\n        }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825637,
                "title": "python-3-stack-based-o-n-time-and-o-n-space",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nIf the requirement is of using O(1) space, then don\\'t use stack. Implement the below algorithm by updating the input string s.\\n\\n**Explanation of below algo:**\\n2 characters are equal if after converting them to lowercase results True. And without conversion they return True. In this case, we are confident that this character can stay in our output.\\n\\nIf our new character and the top element in the stack are same character but different in cases, then don\\'t add the new character to the stack. Also remove the top element from the stack.\\n\\n```\\ndef makeGood(self, s: str) -> str:\\n\\tstack: = []\\n\\tfor i in range(len(s)):\\n\\t\\tif not stack: stack.append(s[i])                 # if stack is empty, then add our new character. We cannot compare empty stack with anything.\\n\\t\\telse:\\n\\t\\t\\tif s[i].lower()==stack[-1].lower() and s[i]!=stack[-1]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(s[i])\\n\\treturn \\'\\'.join(stack)\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef makeGood(self, s: str) -> str:\\n\\tstack: = []\\n\\tfor i in range(len(s)):\\n\\t\\tif not stack: stack.append(s[i])                 # if stack is empty, then add our new character. We cannot compare empty stack with anything.\\n\\t\\telse:\\n\\t\\t\\tif s[i].lower()==stack[-1].lower() and s[i]!=stack[-1]:\\n\\t\\t\\t\\tstack.pop()\\n\\t\\t\\telse:\\n\\t\\t\\t\\tstack.append(s[i])\\n\\treturn \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 819101,
                "title": "simple-7-lines-code-in-python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack=[]\\n        for char in s:\\n            if stack and ((stack[-1].islower() and char==stack[-1].upper()) or (stack[-1].isupper() and char==stack[-1].lower())):\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack=[]\\n        for char in s:\\n            if stack and ((stack[-1].islower() and char==stack[-1].upper()) or (stack[-1].isupper() and char==stack[-1].lower())):\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819077,
                "title": "php-solution-faster-than-100-4ms",
                "content": "**Simple solution and faster than 100%, takes only 4ms:**\\n* Start from the first to the penultimate char of the string.\\n* Compare the char with the next with **strcasecmp** because it\\'s case insensitive.\\n* If different or both (original) chars are equal continue (everything is good).\\n* Both chars are therefore not equal in upper/lowercase so use **substr_replace** to cut out both.\\n* Set iterator 2 steps back to continue with the last char (1 will be balanced through the $i++ of the loop) with a min of -1 (so the index is not getting smaller than 0) because through deletion of chars could be last char with next char getting bad.\\n\\n```\\n    function makeGood($s) {\\n\\t\\tfor ($i=0; $i<strlen ($s)-1; $i++) {\\n\\t\\t\\tif (strcasecmp($s[$i], $s[$i+1])!=0 || $s[$i]==$s[$i+1])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t$s = substr_replace($s, \\'\\', $i, 2);\\n\\t\\t\\t$i = max(-1,$i-2);\\n\\t\\t}\\n\\t\\treturn $s;\\n\\t}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n    function makeGood($s) {\\n\\t\\tfor ($i=0; $i<strlen ($s)-1; $i++) {\\n\\t\\t\\tif (strcasecmp($s[$i], $s[$i+1])!=0 || $s[$i]==$s[$i+1])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t$s = substr_replace($s, \\'\\', $i, 2);\\n\\t\\t\\t$i = max(-1,$i-2);\\n\\t\\t}\\n\\t\\treturn $s;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802261,
                "title": "c-stack-faster-than-98-34",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string kq = \"\";\\n        stack<char> temp;\\n        temp.push(s[0]);\\n        for(int i=1; i<s.length(); i++){\\n            if(temp.empty()) temp.push(s[i]);\\n            else{\\n                int ich = (int)s[i]; //ASCII of s[i]\\n                int itop = (int)temp.top(); //ASCII of temp.top()\\n                int cl = abs(ich - itop);  // ASCII upper - ASCII lower =32\\n                if(cl == 32) temp.pop();\\n                else temp.push(s[i]);\\n            }\\n        }\\n        while(!temp.empty()){\\n            kq = temp.top() + kq;\\n            temp.pop();\\n        }\\n        return kq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        string kq = \"\";\\n        stack<char> temp;\\n        temp.push(s[0]);\\n        for(int i=1; i<s.length(); i++){\\n            if(temp.empty()) temp.push(s[i]);\\n            else{\\n                int ich = (int)s[i]; //ASCII of s[i]\\n                int itop = (int)temp.top(); //ASCII of temp.top()\\n                int cl = abs(ich - itop);  // ASCII upper - ASCII lower =32\\n                if(cl == 32) temp.pop();\\n                else temp.push(s[i]);\\n            }\\n        }\\n        while(!temp.empty()){\\n            kq = temp.top() + kq;\\n            temp.pop();\\n        }\\n        return kq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786278,
                "title": "simple-java-solution-for-good-string",
                "content": "class Solution {\\n    public String makeGood(String s) {\\n\\n        Stack<Character> st= new Stack<>();\\n        char[] chars= s.toCharArray();\\n        for(int i=0;i<chars.length;i++){\\n            char currLetter=chars[i];\\n            if(!st.isEmpty()){\\n                char top=st.peek();\\n                int topLetter=top;\\n                 if( (currLetter+32)==top || (currLetter-32)==top){\\n                    st.pop();\\n                }else{\\n                    st.push(currLetter);\\n                }\\n            }else{\\n                st.push(currLetter);\\n            }\\n\\n        }\\n        StringBuilder sb= new StringBuilder();\\n        for(char s1:st){\\n            sb.append(Character.toString(s1));\\n        }\\n        return sb.toString();\\n\\n\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String makeGood(String s) {\\n\\n        Stack<Character> st= new Stack<>();\\n        char[] chars= s.toCharArray();\\n        for(int i=0;i<chars.length;i++){\\n            char currLetter=chars[i];\\n            if(!st.isEmpty()){\\n                char top=st.peek();\\n                int topLetter=top;\\n                 if( (currLetter+32)==top || (currLetter-32)==top){\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 783147,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Make The String Great.\\nMemory Usage: 2.1 MB, less than 100.00% of Go online submissions for Make The String Great.\\n\\n```go\\nfunc makeGood(s string) string {\\n    stack := []byte{}\\n    for i := 0; i < len(s); i++ {\\n        if len(stack) > 0 && abs(int(stack[len(stack) - 1]) - int(s[i])) == 32 {\\n            stack = stack[:len(stack) - 1]\\n        } else {\\n            stack = append(stack, s[i])\\n        }\\n    }\\n    return string(stack)\\n}\\n\\nfunc abs(n int) int {\\n    if n > 0 { return n }\\n    return -n\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc makeGood(s string) string {\\n    stack := []byte{}\\n    for i := 0; i < len(s); i++ {\\n        if len(stack) > 0 && abs(int(stack[len(stack) - 1]) - int(s[i])) == 32 {\\n            stack = stack[:len(stack) - 1]\\n        } else {\\n            stack = append(stack, s[i])\\n        }\\n    }\\n    return string(stack)\\n}\\n\\nfunc abs(n int) int {\\n    if n > 0 { return n }\\n    return -n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781161,
                "title": "swift-stack-solution-with-explanation",
                "content": "* The question asks us to make the string great by removing consecutive characters that are the same but are differently cased.\\n* Use a stack to store the characters of the given string.\\n* As you continue to the push the characters, check if the present character is the uppercased or the lowercased form of the last element pushed in the stack. If true, Pop the last element.\\n```\\nfunc makeGood(_ s: String) -> String {\\n    var stack : [Character] = []\\n    for c in s{\\n        if stack.isEmpty{\\n            stack.append(c)\\n        }\\n        else{\\n            if stack.last?.uppercased() == String(c) && stack.last!.isLowercase && c.isUppercase{\\n                stack.popLast()\\n            }\\n            else if stack.last?.lowercased() == String(c) && c.isLowercase && stack.last!.isUppercase{\\n                stack.popLast()\\n            }\\n            else{\\n                stack.append(c)\\n            }\\n        }\\n    }\\n    return String(stack)\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc makeGood(_ s: String) -> String {\\n    var stack : [Character] = []\\n    for c in s{\\n        if stack.isEmpty{\\n            stack.append(c)\\n        }\\n        else{\\n            if stack.last?.uppercased() == String(c) && stack.last!.isLowercase && c.isUppercase{\\n                stack.popLast()\\n            }\\n            else if stack.last?.lowercased() == String(c) && c.isLowercase && stack.last!.isUppercase{\\n                stack.popLast()\\n            }\\n            else{\\n                stack.append(c)\\n            }\\n        }\\n    }\\n    return String(stack)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781019,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        i = 0\\n        while(i >= 0 and i < len(s)-1):\\n            if s[i].lower() == s[i+1].lower() and ( (s[i].islower() and s[i+1].isupper()) or (s[i].isupper() and s[i+1].islower()) ):\\n                s = s[:i] + s[i+2:]\\n                i -= 1\\n            else:\\n                i += 1\\n            if i < 0:\\n                i = 0\\n        return s\\n```\\nPLEASE UPVOTE IF YOU LIKE MY SOLUTION.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeGood(self, s: str) -> str:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        i = 0\\n        while(i >= 0 and i < len(s)-1):\\n            if s[i].lower() == s[i+1].lower() and ( (s[i].islower() and s[i+1].isupper()) or (s[i].isupper() and s[i+1].islower()) ):\\n                s = s[:i] + s[i+2:]\\n                i -= 1\\n            else:\\n                i += 1\\n            if i < 0:\\n                i = 0\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781001,
                "title": "c-o-n-stack-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring makeGood(string s) {\\n\\t\\t\\tstack<char> st;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!st.empty() && ((st.top()-\\'a\\'==s[i]-\\'A\\') ||(st.top()-\\'A\\'==s[i]-\\'a\\')))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\twhile(!st.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar cur=st.top();\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tans=cur+ans;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring makeGood(string s) {\\n\\t\\t\\tstack<char> st;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(!st.empty() && ((st.top()-\\'a\\'==s[i]-\\'A\\') ||(st.top()-\\'A\\'==s[i]-\\'a\\')))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 780905,
                "title": "java-o-n-time-o-n-space-stack",
                "content": "We continuously push characters to a stack and if there exists a violation (which we can detect by seeing if the difference of the current character and top stack character is exactly 32. See Ascii Table.), we pop a character instead and don\\'t push the current character.\\n\\n```\\npublic String makeGood(String s) {\\n    Stack<Character> stack = new Stack<>();\\n    for (int i=0;i<s.length();i++) {\\n        if (!stack.isEmpty() && Math.abs(stack.peek() - s.charAt(i)) == 32) stack.pop();\\n        else stack.push(s.charAt(i));\\n    }\\n    StringBuilder sb = new StringBuilder();\\n    while (!stack.isEmpty()) sb.append(stack.pop());\\n    return sb.reverse().toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String makeGood(String s) {\\n    Stack<Character> stack = new Stack<>();\\n    for (int i=0;i<s.length();i++) {\\n        if (!stack.isEmpty() && Math.abs(stack.peek() - s.charAt(i)) == 32) stack.pop();\\n        else stack.push(s.charAt(i));\\n    }\\n    StringBuilder sb = new StringBuilder();\\n    while (!stack.isEmpty()) sb.append(stack.pop());\\n    return sb.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032851,
                "title": "c-easy-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> stk;\\n        string ans;\\n        stk.push(\\'-\\');\\n        for(int i=0;i<s.size();i++){\\n            char curr=s[i];\\n            stk.push(curr);\\n            if(curr>=\\'a\\'&&curr<=\\'z\\'){\\n                char temp=curr-32;\\n                stk.pop();\\n                if(stk.top()==temp){\\n                    stk.pop();\\n                }else{\\n                    stk.push(curr);\\n                }\\n            }else if(curr>=\\'A\\'&&curr<=\\'Z\\'){\\n                char temp=curr+32;\\n                stk.pop();\\n                if(stk.top()==temp){\\n                    stk.pop();\\n                }else{\\n                    stk.push(curr);\\n                }\\n            }\\n\\n        }\\n        while(stk.size()!=1){\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char> stk;\\n        string ans;\\n        stk.push(\\'-\\');\\n        for(int i=0;i<s.size();i++){\\n            char curr=s[i];\\n            stk.push(curr);\\n            if(curr>=\\'a\\'&&curr<=\\'z\\'){\\n                char temp=curr-32;\\n                stk.pop();\\n                if(stk.top()==temp){\\n                    stk.pop();\\n                }else{\\n                    stk.push(curr);\\n                }\\n            }else if(curr>=\\'A\\'&&curr<=\\'Z\\'){\\n                char temp=curr+32;\\n                stk.pop();\\n                if(stk.top()==temp){\\n                    stk.pop();\\n                }else{\\n                    stk.push(curr);\\n                }\\n            }\\n\\n        }\\n        while(stk.size()!=1){\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030695,
                "title": "java-easy-solution-using-stack-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        \\n        if(s.length()==1)\\n            return s;\\n        \\n        Stack <Character> st=new Stack<>();\\n            \\n    for (char c : s.toCharArray()) {\\n        if (!st.isEmpty() && Math.abs(st.peek() - c) == 32) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\nStringBuilder strange = new StringBuilder();  \\n        while(!st.isEmpty())\\n        {\\n            strange.append(st.pop());\\n        }\\n        strange.reverse();\\n        return strange.toString();\\n    }\\n}\\n\\n\\n   \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        \\n        if(s.length()==1)\\n            return s;\\n        \\n        Stack <Character> st=new Stack<>();\\n            \\n    for (char c : s.toCharArray()) {\\n        if (!st.isEmpty() && Math.abs(st.peek() - c) == 32) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\nStringBuilder strange = new StringBuilder();  \\n        while(!st.isEmpty())\\n        {\\n            strange.append(st.pop());\\n        }\\n        strange.reverse();\\n        return strange.toString();\\n    }\\n}\\n\\n\\n   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022146,
                "title": "c-using-stack",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public string MakeGood(string s)\\n    {\\n        var stack = new Stack<char>();\\n        foreach (var c in s)\\n        {\\n            if (stack.Count > 0 && stack.Peek() != c && char.ToLower(stack.Peek()) == char.ToLower(c))\\n            {\\n                stack.Pop();\\n            }\\n            else\\n            {\\n                stack.Push(c);\\n            }\\n        }\\n\\n        var sb = new StringBuilder();\\n        while (stack.Count > 0)\\n        {\\n            sb.Append(stack.Pop());\\n        }\\n\\n        return new string(sb.ToString().Reverse().ToArray());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string MakeGood(string s)\\n    {\\n        var stack = new Stack<char>();\\n        foreach (var c in s)\\n        {\\n            if (stack.Count > 0 && stack.Peek() != c && char.ToLower(stack.Peek()) == char.ToLower(c))\\n            {\\n                stack.Pop();\\n            }\\n            else\\n            {\\n                stack.Push(c);\\n            }\\n        }\\n\\n        var sb = new StringBuilder();\\n        while (stack.Count > 0)\\n        {\\n            sb.Append(stack.Pop());\\n        }\\n\\n        return new string(sb.ToString().Reverse().ToArray());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833385,
                "title": "java-beginner-solution-runtime-100-memory-100-with-explanation",
                "content": "# Approach\\n\\nThe approach used in the given solution is to iterate through the input string `s`, and for each character encountered, check if it forms a \"bad\" pair with the previous character in the `StringBuilder`. If a \"bad\" pair is found, we remove both characters from the `StringBuilder`. Otherwise, we append the current character to the `StringBuilder`. In the end, the `StringBuilder` will contain the modified \"good\" string, which is the desired output.\\n\\nLogic:\\n\\n1. Create an empty `StringBuilder` called `sb` to store the characters of the modified string.\\n\\n2. Iterate through the characters of the input string `s`.\\n\\n3. For each character `c`, check if the `StringBuilder` is not empty (`len != 0`) and if the absolute difference between the ASCII values of the last character in the `StringBuilder` and the current character `c` is equal to 32. ASCII values of lowercase and uppercase English letters differ by 32. If this condition is true, it means that the characters form a \"bad\" pair, and we need to remove both characters from the `StringBuilder`.\\n\\n4. If the condition in step 3 is false, it means that the current character `c` does not form a \"bad\" pair with the last character in the `StringBuilder`. In this case, we can safely append the current character `c` to the `StringBuilder`.\\n\\n5. Repeat steps 3-4 for all characters in the input string `s`.\\n\\n6. After the iteration is complete, the `StringBuilder` will contain the modified \"good\" string, and we can convert it to a regular string using `sb.toString()` and return it as the output.\\n\\nThe solution effectively removes all the \"bad\" pairs of adjacent characters from the input string and returns the resulting \"good\" string. Since the solution processes each character in a single pass, the time complexity of this approach is O(n), where n is the length of the input string. The space complexity is also O(n) due to the usage of the `StringBuilder`. Overall, the solution is clear, concise, and efficient, making it easy to understand for beginners as well.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            int len = sb.length();\\n\\n            if (len != 0 && Math.abs(sb.charAt(len - 1) - c) == 32)\\n                sb.deleteCharAt(len - 1);\\n            else\\n                sb.append(c);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "String",
                    "Stack",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n            int len = sb.length();\\n\\n            if (len != 0 && Math.abs(sb.charAt(len - 1) - c) == 32)\\n                sb.deleteCharAt(len - 1);\\n            else\\n                sb.append(c);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717965,
                "title": "easy-solution-using-stack-and-stringbuilder",
                "content": "# Intuition\\nSince in Java we can\\'t modify the string in place (because the string is immutable), so we have to use extra space for building the result.\\nPair is great if the difference of thier ASCII values is differnt than 323232\\n\\n# Approach\\nloop over the string, and for each character:\\n\\ncompare its value with the last character in the result,\\nif this pair makes the string bad:\\nremove the last character from the result\\nelse\\nadd the current character to the result.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stk = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(stk.size()>0 && (stk.peek()==ch-32 || stk.peek()==ch+32)){\\n                stk.pop();\\n            }\\n            else{\\n                stk.push(ch);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(stk.size()>0){\\n            char ch = stk.pop();\\n            sb.append(ch);\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeGood(String s) {\\n        Stack<Character> stk = new Stack<>();\\n        for(char ch : s.toCharArray()){\\n            if(stk.size()>0 && (stk.peek()==ch-32 || stk.peek()==ch+32)){\\n                stk.pop();\\n            }\\n            else{\\n                stk.push(ch);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(stk.size()>0){\\n            char ch = stk.pop();\\n            sb.append(ch);\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614500,
                "title": "100-beats-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.size();i++){\\n            if(!st.empty() && (st.top()-32==s[i] || s[i]-32==st.top())){\\n                st.pop();\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.size();i++){\\n            if(!st.empty() && (st.top()-32==s[i] || s[i]-32==st.top())){\\n                st.pop();\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605507,
                "title": "easy-one-stop-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere as we have to remove adjacent characters of a string if the string is a bad string. As we have to keep the track of the previous character processed of the string along with the current character we proceed using the stack approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we use ASCII difference to compare the characters. We know ASCII value of A-Z is from 65 to 90 and ASCII value of a-z is from a-z. Here we notice that difference between any lower case character and corresponding upper case character is 32. \\n(E.g : a-A => 97-65 = 32).\\n\\nIf the difference between the top character of the stack and the current character of the string is equal to 32, this implies we have found a pair (eE or Ee) to be removed.\\nWe then remove the top character of the stack and move forward. This goes until we reach the end of the string and all such pairs.\\n\\nAt the end we run a loop on the stack and transfer all characters of the stack to the ans string variable in such a way that stack is reversed and we get the desired string,\\n# Complexity\\n- Time complexity:  O(n)\\n- As we are traversing the string only once , hence the time complexity of the above solution is O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n- As we are using a stack which in worst case may store all the characters of the string , hence the space complexity of the above approach is O(n). \\n\\n- The space complexity can be optimized to O(1) using two pointers and proceeding with a similar trend changing the string in place.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++) {\\n            if(!st.empty() && abs(s[i]-st.top())==32) // If we find a bad pair such as Aa or aA , then we remove the previous character processed\\n            st.pop();\\n            else\\n            st.push(s[i]); // if the stack is empty or if the pair is not a bad one.\\n        }\\n\\n        while (!st.empty()) {\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n        int n=s.size();\\n        for(int i=0;i<n;i++) {\\n            if(!st.empty() && abs(s[i]-st.top())==32) // If we find a bad pair such as Aa or aA , then we remove the previous character processed\\n            st.pop();\\n            else\\n            st.push(s[i]); // if the stack is empty or if the pair is not a bad one.\\n        }\\n\\n        while (!st.empty()) {\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427077,
                "title": "100-cpp-stack-reverse-basic-ascii",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        stack<char> st;\\n        string ans = \"\";\\n        st.push(s[0]);\\n        \\n        for(int i = 1; i < s.size(); i++){\\n            \\n            if(st.empty()){\\n                \\n                st.push(s[i]);\\n                continue;\\n                \\n            }\\n            \\n            if(abs(st.top() - s[i]) == 32)\\n                st.pop();\\n            \\n            else\\n                st.push(s[i]);\\n            \\n        }\\n        \\n        while(!st.empty()){\\n            \\n            ans.push_back(st.top());\\n            st.pop();\\n            \\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeGood(string s) {\\n        \\n        stack<char> st;\\n        string ans = \"\";\\n        st.push(s[0]);\\n        \\n        for(int i = 1; i < s.size(); i++){\\n            \\n            if(st.empty()){\\n                \\n                st.push(s[i]);\\n                continue;\\n                \\n            }\\n            \\n            if(abs(st.top() - s[i]) == 32)\\n                st.pop();\\n            \\n            else\\n                st.push(s[i]);\\n            \\n        }\\n        \\n        while(!st.empty()){\\n            \\n            ans.push_back(st.top());\\n            st.pop();\\n            \\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568416,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675928,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675654,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676486,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675558,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676344,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676294,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1968723,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1893781,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1876253,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1568416,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675928,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675654,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676486,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1675558,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676344,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1676294,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1968723,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1893781,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1876253,
                "content": [
                    {
                        "username": "WKelvinson",
                        "content": "Just for fun, the name of this problem remindes me of the orange president,  anyway happy coding!"
                    },
                    {
                        "username": "IliaOzhmegov",
                        "content": "it passed a few years now but it still does "
                    },
                    {
                        "username": "kumarkunal4052002",
                        "content": "Thing to remember difference between capital and small of alphabet in ascii is 32 . "
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "Try a stack, maybe?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Can Plz Someone explain me how \"Leetcode\" is good string, as this string have adjacent e ?"
                    },
                    {
                        "username": "Mspatild7",
                        "content": "Ok. Got it. Thanks\\n"
                    },
                    {
                        "username": "dmonack",
                        "content": "A good string can have adjacent characters that are the same case. It\\'s not allowed to have a lower case letter next to its upper-case version. So \\'leetcode\\' is a good string but \\'leEtcode\\' and \\'lEetcode\\' are not."
                    },
                    {
                        "username": "Unpoco_loco",
                        "content": "yepp, because it doesn't satisfy the conditions of bad string ,as it is very clearly given in the problem that string can only be a bad string if (ascii value of char) s[i]-s[i+1] ==32 in which one should be in lower case and other in upper case more clearly s[i] and s[i+1] should be a same alphabate (where one in lower and other in upper case) , \"leetcode\" it doesn't consist any uppercase adjacent letter that follows the above conditions. happy coding !."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "It has adjacent e but neither are a capital. For example \\u201CleEtcode\\u201D would be bad, but \\u201Cleetcode\\u201D is not"
                    },
                    {
                        "username": "kanealdrich12",
                        "content": "Reading the instructions for this made me smell burnt toast. Anyway, happy coding!"
                    },
                    {
                        "username": "drap5468",
                        "content": "The title requires us to make the string great, but the function only allows us to make it good. Sad day."
                    },
                    {
                        "username": "itsadityap",
                        "content": "MSGA !!!\\n\\nMake String Great Again!!"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Spent a lot longer than I should have for this problem... D:"
                    },
                    {
                        "username": "mirshod_py",
                        "content": "class Solution:\\n    def makeGood(self, s: str) -> str:\\n        stack = []\\n        for idx, char in enumerate(s):\\n            if stack and (stack[-1].lower() == char.lower()):\\n                if stack[-1] != char:\\n                    stack.pop()\\n            else:\\n                stack.append(char)\\n                \\n        print(stack)\\n        return \"\".join(stack) this is not passing in fir test case"
                    },
                    {
                        "username": "Chayan_Rai",
                        "content": "https://leetcode.com/problems/make-the-string-great/solutions/3463968/using-stack/?orderBy=most_relevant "
                    }
                ]
            },
            {
                "id": 1764869,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1764471,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1756055,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1714129,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1681372,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1678915,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676903,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676850,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676797,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676620,
                "content": [
                    {
                        "username": "CCThumper",
                        "content": "As of 01/19/2023, the problem definition no longer contains the definition of a great string."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "Can anybody explain me the difference? else condition is used in first code. and in later code, it is not used. in some codes we dont use else, but we write the code in the latter format instead of else condition..\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            else:\n                i+=1 \n        return s \n\n\ndef makeGood(self, s: str) -> str:\n        i= 0\n        while i<len(s)-1:\n            if abs(ord(s[i])- ord(s[i+1]))== 32:\n                s= s[:i]+s[i+2:]\n                i = 0 \n            i+=1 \n        return s "
                    },
                    {
                        "username": "arohikeshavsirke",
                        "content": "Simple Approach\\nThe difference between ascii(Capital Letter)-ascii(small letter)=32 or -32.\\ntake stack and pop when diff is 32 or -32.\\nbelow is code part---\\n\\n\\nclass Solution {\\n    public String makeGood(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.size()>0){\\n                if(st.peek()-ch==32 || st.peek()-ch==-32){\\n                    st.pop();\\n                }else{\\n                st.push(ch);\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        System.out.print(st);\\n        while(st.size()>0){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}"
                    },
                    {
                        "username": "Praveensarathy",
                        "content": "class Solution {\\n    public String makeGood(String s) {\\n        StringBuilder str = new StringBuilder();\\n        int i,j;\\n        for(char c : s.toCharArray()){\\n            if(str.length()==0 ){\\n                str.append(c);\\n            }\\n            else if(str.charAt(str.length()-1)== c+32 || str.charAt(str.length()-1)== c-32){\\n                str.deleteCharAt(str.length()-1);\\n            }\\n            else{\\n                str.append(c);\\n            }\\n        }\\n        return String.valueOf(str);\\n    }\\n}"
                    },
                    {
                        "username": "lovely08",
                        "content": "is this a really easy problem or I am too dumb. It should be a medium category problem. Although I solved that."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "If you are comfortable with stack data structure, this problem is not that hard:)"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1047 Remove All Adjacent Duplicates In String"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "> Notice that an empty string is also good.\\n\\nTherefore \\n\\n```\\nreturn \"\";\\n```\\n\\nIs a valid response.\\n"
                    },
                    {
                        "username": "limitless_f",
                        "content": "I'm confused, why this is wrong\n```\nif (s.charAt(i) == Character.toUpperCase(s.charAt(i + 1)) || s.charAt(i + 1) == Character.toUpperCase(s.charAt(i)))\n```\n\nbut this works:\n```\nf (Math.abs(s.charAt(i) - s.charAt(i + 1)) == 32) {\n```\n?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can use toUpperCase and to lower case, but than you have to check both directions, to prevent issues when chars are 'aa' or 'AA'. In js this works:\n ```\nif (char.toUpperCase() === stack[stack.length-1] && stack[stack.length-1].toLowerCase() === char) stack.pop()\nelse if (char.toLowerCase() === stack[stack.length-1] && stack[stack.length-1].toUpperCase() === char) stack.pop()\nelse stack.push(char)\n```\n\nusing ASCII is nicer though"
                    },
                    {
                        "username": "quackdack",
                        "content": "The first snippet falsely returns true for AA (both letters uppercase)"
                    },
                    {
                        "username": "Dev_Johri",
                        "content": "think how to check it recursively and how to compare capital and small case letter. "
                    },
                    {
                        "username": "ghoshkoustav18",
                        "content": "JAVA (O(N)):\\nclass Solution { \\n    public String makeGood(String s)\\n     {\\n         if(s == null || s.isEmpty() || s.length() == 1)\\n         { \\n             return s; \\n         }\\n         StringBuilder sb = new StringBuilder(s); \\n         int len = sb.length(); \\n         int i = 0;\\n         while(i<len-1)\\n         {\\n            if(Math.abs(sb.charAt(i) - sb.charAt(i+1)) == 32)\\n                { \\n                 sb.delete(i,i+2);\\n                 i = 0;\\n                 len = sb.length();\\n                }\\n            else\\n            {\\n                i++;\\n            }\\n         } \\n         return sb.toString();\\n     }\\n }"
                    },
                    {
                        "username": "mynk_rjpt",
                        "content": "Don\\'t post solutions here. You look fool!"
                    }
                ]
            },
            {
                "id": 1676551,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676548,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676395,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676323,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676226,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1676174,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1675977,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1675963,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1675896,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            },
            {
                "id": 1675741,
                "content": [
                    {
                        "username": "yadavkanishk57",
                        "content": "1.Take Math.abs function to to remove the \\'-\\' sign and is cheked equal to 32\\n# Math.abs(stack.peek()-s.charAt(i)) == 32\\n\\n Stack<Character> stack = new Stack<Character>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            if((!stack.isEmpty()) && (Math.abs(stack.peek()-s.charAt(i)) == 32)){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n\\n        char[] ch = new char[stack.size()];\\n        for(int i=stack.size()-1;!stack.isEmpty();i--) \\n            ch[i]=stack.pop();\\n        return new String(ch);\\n    }\\n}\\n\\n\\n\\n\\n        // |      o      |\\n        // |      c      |\\n        // |      t      |\\n        // |      e      |       \\n        // |      e      |\\n        // |      E      |\\n        // |      e      |\\n        // |______l______|           \\n        //System.out.print(t);\\n        \\n"
                    },
                    {
                        "username": "Amanjot_Kaur",
                        "content": "solving using string, after removing 2 characters, decrease the value of position/index to check again if difference is 32 or not\\n if(Math.abs(m-n)==32){\\n            st.deleteCharAt(i);\\n              st.deleteCharAt(i);\\n              if(i==0){\\n                  i--;\\n              }\\n              else{\\n                  i=i-2;\\n              }"
                    },
                    {
                        "username": "atulkumarsingh952",
                        "content": "Use Stack of character, start a loop and for every index check the condition (st.empty()==false &&((s[i]+32==st.top() ) ||  (s[i]-32==st.top())  ) if it satisfies the condtion then pop out the top element of the stack else push in the current charcter.\\nAfter iteration completion push all the character of stack in    a string and reverse it then return it."
                    },
                    {
                        "username": "jainnamya1306",
                        "content": "class Solution {\\npublic:\\n    string makeGood(string s) {\\n        string ans;\\n         int flag=1;\\n        while(flag){\\n            string temp;\\n            int n=s.size();\\n            int i=0;\\n        for(i=0;i<n-1;i++){\\n            if(s[i]-\\'a\\'==s[i+1]-\\'A\\'||s[i]-\\'A\\'==s[i+1]-\\'a\\')i++;\\n            else temp.push_back(s[i]);\\n        }\\n        if(i<n){\\n        temp.push_back(s[i]);\\n        }\\n        if(temp.size()==n||temp.size()==0){\\n            ans=temp;\\n            flag=0;\\n        }\\n        else{\\n            s=temp;\\n        }\\n      }\\n        return ans;\\n    }\\n    \\n};\\n\\nCan someone please confirm whether its time complexity is 0(n) or 0(n2)?"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "O(n)"
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" what should be the output of this."
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\" Beacause m is lower case and C is upper case. It would have been \"\" if it was cC or Mm (basically same letters adjacent to each other but in different cases that is upper and lower in that case it\\'s a bad string. The reason why \"mC\" will output \"mC\" because they are different letters."
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "[@suryadevsingh](/suryadevsingh) \"mC\""
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "\"mC\" or \"\"."
                    },
                    {
                        "username": "rahul_542003",
                        "content": "Can we use recursion in this case??\\n"
                    },
                    {
                        "username": "slipnslidebaby",
                        "content": "Yeah recursion works, you just keep passing a string which reduces by 2 chars whenever your removal criteria is true"
                    },
                    {
                        "username": "varunkusabi8",
                        "content": "Can anybody please help me why am I getting this error :\\nRuntime Error\\nAddressSanitizer:DEADLYSIGNAL\\n\\nfor the following code :\\n\\nclass Solution {\\npublic:\\n    string makeGood(string s)\\n    {\\n        stack <char> x;\\n        x.push(s[0]);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(abs(x.top()-s[i])==32)\\n            {\\n                x.pop();           \\n            }\\n            else\\n            {\\n                x.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!x.empty())\\n        {\\n            ans=ans+x.top();\\n            x.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        // cout<<ans;\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Dry run on this Case: aAfnAan \nYou'll figure it out.\n\nHint: what is stk.top() if stack is empty ?"
                    },
                    {
                        "username": "m_afnan2018",
                        "content": "Everyone will submit solution today. (XD)"
                    },
                    {
                        "username": "viraj2003",
                        "content": "C++ Easy to understand Solution \n```\nstring makeGood(string s) {\n        if(s.size()==1 || s==\"\")\n        {\n           return s;\n        }\n        auto it=s.begin();\n        while(it<s.end() && s.size()>0)\n        {\n           if((abs(*it - *(it+1))==32))\n           {\n               s.erase(it,it+2);\n               it=s.begin();\n           }\n           else\n           {\n             it++;\n           }\n           \n        }\n        \n        return s;"
                    },
                    {
                        "username": "sounish",
                        "content": "- Turing native approach to normal approach\n- Use of `isBad(s)` and `_makeGood(s)` two simple function to think of and build your appoarch\n- Look close we are iterating `i` and `j` where `j` dependent on `i` and vice-versa.\n- Normally in this situation we apply `Stack` to the rescue."
                    }
                ]
            }
        ]
    }
]